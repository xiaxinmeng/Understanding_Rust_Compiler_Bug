{"sha": "f1f5c04c07f2e888c43cb577810659a7c1d87a00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZjVjMDRjMDdmMmU4ODhjNDNjYjU3NzgxMDY1OWE3YzFkODdhMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-11T16:50:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-11T16:50:48Z"}, "message": "Auto merge of #29763 - nikomatsakis:mir-29227, r=nikomatsakis\n\nThe older algorithm was pretty inefficient for big matches. Fixes #29227. (On my computer, MIR construction on this test case goes from 9.9s to 0.025s.) Whereas before we had a loop like:\n\n- for all outcomes of the test we are performing\n    - for all candidates\n        - check whether candidate is relevant to outcome\n\nWe now do:\n\n- for all candidates\n    - determine which outcomes the candidate is relevant to\n\nSince the number of outcomes in this case is proportional to the number of candidates, the original algorithm turned out to be O(n^2), and the newer one is just O(n).\n\nThis PR also does some minor speedups by eagerly mirroring all patterns, so that we can just pass around `&Pattern<'tcx>`, which makes cloning cheaper. We could probably go a bit further in this direction.\n\nr? @Aatch", "tree": {"sha": "80d3abed39ae6a6ac4017b333033f26c12efc830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80d3abed39ae6a6ac4017b333033f26c12efc830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1f5c04c07f2e888c43cb577810659a7c1d87a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f5c04c07f2e888c43cb577810659a7c1d87a00", "html_url": "https://github.com/rust-lang/rust/commit/f1f5c04c07f2e888c43cb577810659a7c1d87a00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1f5c04c07f2e888c43cb577810659a7c1d87a00/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c743a95d74da5af649a6c6b2608f5f65a0da716", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c743a95d74da5af649a6c6b2608f5f65a0da716", "html_url": "https://github.com/rust-lang/rust/commit/8c743a95d74da5af649a6c6b2608f5f65a0da716"}, {"sha": "38cf175784e08723d0108778b1ebf5e52f3018dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/38cf175784e08723d0108778b1ebf5e52f3018dc", "html_url": "https://github.com/rust-lang/rust/commit/38cf175784e08723d0108778b1ebf5e52f3018dc"}], "stats": {"total": 1120, "additions": 570, "deletions": 550}, "files": [{"sha": "4eda6961a1921f5ca4c7de10291322e4362a2d0e", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -44,7 +44,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // be unreachable or reachable multiple times.\n         let var_extent = self.extent_of_innermost_scope().unwrap();\n         for arm in &arms {\n-            self.declare_bindings(var_extent, arm.patterns[0].clone());\n+            self.declare_bindings(var_extent, &arm.patterns[0]);\n         }\n \n         let mut arm_blocks = ArmBlocks {\n@@ -64,18 +64,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // highest priority candidate comes last in the list. This the\n         // reverse of the order in which candidates are written in the\n         // source.\n-        let candidates: Vec<Candidate<'tcx>> =\n+        let candidates: Vec<_> =\n             arms.iter()\n                 .enumerate()\n                 .rev() // highest priority comes last\n                 .flat_map(|(arm_index, arm)| {\n                     arm.patterns.iter()\n                                 .rev()\n-                                .map(move |pat| (arm_index, pat.clone(), arm.guard.clone()))\n+                                .map(move |pat| (arm_index, pat, arm.guard.clone()))\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n-                        match_pairs: vec![self.match_pair(discriminant_lvalue.clone(), pattern)],\n+                        match_pairs: vec![MatchPair::new(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n                         guard: guard,\n                         arm_index: arm_index,\n@@ -102,12 +102,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n                              var_extent: CodeExtent, // lifetime of vars\n-                             irrefutable_pat: PatternRef<'tcx>,\n+                             irrefutable_pat: Pattern<'tcx>,\n                              initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()> {\n         // optimize the case of `let x = ...`\n-        let irrefutable_pat = self.hir.mirror(irrefutable_pat);\n-        match irrefutable_pat.kind {\n+        match *irrefutable_pat.kind {\n             PatternKind::Binding { mutability,\n                                    name,\n                                    mode: BindingMode::ByValue,\n@@ -128,22 +127,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n         self.lvalue_into_pattern(block,\n                                  var_extent,\n-                                 PatternRef::Mirror(Box::new(irrefutable_pat)),\n+                                 irrefutable_pat,\n                                  &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                var_extent: CodeExtent,\n-                               irrefutable_pat: PatternRef<'tcx>,\n+                               irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()> {\n         // first, creating the bindings\n-        self.declare_bindings(var_extent, irrefutable_pat.clone());\n+        self.declare_bindings(var_extent, &irrefutable_pat);\n \n         // create a dummy candidate\n-        let mut candidate = Candidate::<'tcx> {\n-            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat.clone())],\n+        let mut candidate = Candidate {\n+            match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n             guard: None,\n             arm_index: 0, // since we don't call `match_candidates`, this field is unused\n@@ -166,29 +165,29 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: PatternRef<'tcx>) {\n-        let pattern = self.hir.mirror(pattern);\n-        match pattern.kind {\n-            PatternKind::Binding { mutability, name, mode: _, var, ty, subpattern } => {\n+    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: &Pattern<'tcx>) {\n+        match *pattern.kind {\n+            PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n                 self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n-                if let Some(subpattern) = subpattern {\n+                if let Some(subpattern) = subpattern.as_ref() {\n                     self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n-            PatternKind::Array { prefix, slice, suffix } |\n-            PatternKind::Slice { prefix, slice, suffix } => {\n-                for subpattern in prefix.into_iter().chain(slice).chain(suffix) {\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+                for subpattern in prefix.iter().chain(slice).chain(suffix) {\n                     self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n-            PatternKind::Deref { subpattern } => {\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n+            }\n+            PatternKind::Deref { ref subpattern } => {\n                 self.declare_bindings(var_extent, subpattern);\n             }\n-            PatternKind::Leaf { subpatterns } |\n-            PatternKind::Variant { subpatterns, .. } => {\n+            PatternKind::Leaf { ref subpatterns } |\n+            PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_bindings(var_extent, subpattern.pattern);\n+                    self.declare_bindings(var_extent, &subpattern.pattern);\n                 }\n             }\n         }\n@@ -202,9 +201,9 @@ struct ArmBlocks {\n }\n \n #[derive(Clone, Debug)]\n-struct Candidate<'tcx> {\n+struct Candidate<'pat, 'tcx:'pat> {\n     // all of these must be satisfied...\n-    match_pairs: Vec<MatchPair<'tcx>>,\n+    match_pairs: Vec<MatchPair<'pat, 'tcx>>,\n \n     // ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n@@ -228,12 +227,12 @@ struct Binding<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-struct MatchPair<'tcx> {\n+struct MatchPair<'pat, 'tcx:'pat> {\n     // this lvalue...\n     lvalue: Lvalue<'tcx>,\n \n     // ... must match this pattern.\n-    pattern: Pattern<'tcx>,\n+    pattern: &'pat Pattern<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -280,11 +279,11 @@ struct Test<'tcx> {\n // Main matching algorithm\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn match_candidates(&mut self,\n-                        span: Span,\n-                        arm_blocks: &mut ArmBlocks,\n-                        mut candidates: Vec<Candidate<'tcx>>,\n-                        mut block: BasicBlock)\n+    fn match_candidates<'pat>(&mut self,\n+                              span: Span,\n+                              arm_blocks: &mut ArmBlocks,\n+                              mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+                              mut block: BasicBlock)\n     {\n         debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n                span, block, candidates);\n@@ -346,17 +345,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n \n-        for (outcome, target_block) in target_blocks.into_iter().enumerate() {\n-            let applicable_candidates: Vec<Candidate<'tcx>> =\n-                candidates.iter()\n-                          .filter_map(|candidate| {\n-                              self.candidate_under_assumption(&match_pair.lvalue,\n-                                                              &test.kind,\n-                                                              outcome,\n-                                                              candidate)\n-                          })\n-                          .collect();\n-            self.match_candidates(span, arm_blocks, applicable_candidates, target_block);\n+        let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n+\n+        for candidate in &candidates {\n+            self.sort_candidate(&match_pair.lvalue,\n+                                &test,\n+                                candidate,\n+                                &mut target_candidates);\n+        }\n+\n+        for (target_block, target_candidates) in\n+            target_blocks.into_iter()\n+                         .zip(target_candidates.into_iter())\n+        {\n+            self.match_candidates(span, arm_blocks, target_candidates, target_block);\n         }\n     }\n \n@@ -372,11 +374,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// bindings, further tests would be a use-after-move (which would\n     /// in turn be detected by the borrowck code that runs on the\n     /// MIR).\n-    fn bind_and_guard_matched_candidate(&mut self,\n-                                        mut block: BasicBlock,\n-                                        arm_blocks: &mut ArmBlocks,\n-                                        candidate: Candidate<'tcx>)\n-                                        -> Option<BasicBlock> {\n+    fn bind_and_guard_matched_candidate<'pat>(&mut self,\n+                                              mut block: BasicBlock,\n+                                              arm_blocks: &mut ArmBlocks,\n+                                              candidate: Candidate<'pat, 'tcx>)\n+                                              -> Option<BasicBlock> {\n         debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n                block, candidate);\n "}, {"sha": "e69a04322c201bd40f21b4f321652f3d1700d668", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -30,10 +30,10 @@ use repr::*;\n use std::mem;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    pub fn simplify_candidate(&mut self,\n-                              mut block: BasicBlock,\n-                              candidate: &mut Candidate<'tcx>)\n-                              -> BlockAnd<()> {\n+    pub fn simplify_candidate<'pat>(&mut self,\n+                                    mut block: BasicBlock,\n+                                    candidate: &mut Candidate<'pat, 'tcx>)\n+                                    -> BlockAnd<()> {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n@@ -60,18 +60,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// have been pushed into the candidate. If no simplification is\n     /// possible, Err is returned and no changes are made to\n     /// candidate.\n-    fn simplify_match_pair(&mut self,\n-                           mut block: BasicBlock,\n-                           match_pair: MatchPair<'tcx>,\n-                           candidate: &mut Candidate<'tcx>)\n-                           -> Result<BasicBlock, MatchPair<'tcx>> {\n-        match match_pair.pattern.kind {\n+    fn simplify_match_pair<'pat>(&mut self,\n+                                 mut block: BasicBlock,\n+                                 match_pair: MatchPair<'pat, 'tcx>,\n+                                 candidate: &mut Candidate<'pat, 'tcx>)\n+                                 -> Result<BasicBlock, MatchPair<'pat, 'tcx>> {\n+        match *match_pair.pattern.kind {\n             PatternKind::Wild(..) => {\n                 // nothing left to do\n                 Ok(block)\n             }\n \n-            PatternKind::Binding { name, mutability, mode, var, ty, subpattern } => {\n+            PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n                 candidate.bindings.push(Binding {\n                     name: name,\n                     mutability: mutability,\n@@ -82,9 +82,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     binding_mode: mode,\n                 });\n \n-                if let Some(subpattern) = subpattern {\n+                if let Some(subpattern) = subpattern.as_ref() {\n                     // this is the `x @ P` case; have to keep matching against `P` now\n-                    let subpattern = self.hir.mirror(subpattern);\n                     candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n                 }\n \n@@ -96,12 +95,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Array { prefix, slice, suffix } => {\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n                                                          block,\n                                                          match_pair.lvalue.clone(),\n                                                          prefix,\n-                                                         slice,\n+                                                         slice.as_ref(),\n                                                          suffix));\n                 Ok(block)\n             }\n@@ -113,16 +112,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Leaf { subpatterns } => {\n+            PatternKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n                          .extend(self.field_match_pairs(match_pair.lvalue, subpatterns));\n                 Ok(block)\n             }\n \n-            PatternKind::Deref { subpattern } => {\n+            PatternKind::Deref { ref subpattern } => {\n                 let lvalue = match_pair.lvalue.deref();\n-                let subpattern = self.hir.mirror(subpattern);\n                 candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n                 Ok(block)\n             }"}, {"sha": "312ab61ba6cec73f10f3394090d226f5fa5ca513", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 156, "deletions": 232, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -21,15 +21,15 @@ use hair::*;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::middle::const_eval::ConstVal;\n-use rustc::middle::ty::Ty;\n+use rustc::middle::ty::{self, Ty};\n use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifyable pattern.\n-    pub fn test(&mut self, match_pair: &MatchPair<'tcx>) -> Test<'tcx> {\n-        match match_pair.pattern.kind {\n+    pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n+        match *match_pair.pattern.kind {\n             PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n@@ -99,19 +99,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n-    pub fn add_cases_to_switch(&mut self,\n-                               test_lvalue: &Lvalue<'tcx>,\n-                               candidate: &Candidate<'tcx>,\n-                               switch_ty: Ty<'tcx>,\n-                               options: &mut Vec<ConstVal>,\n-                               indices: &mut FnvHashMap<ConstVal, usize>)\n+    pub fn add_cases_to_switch<'pat>(&mut self,\n+                                     test_lvalue: &Lvalue<'tcx>,\n+                                     candidate: &Candidate<'pat, 'tcx>,\n+                                     switch_ty: Ty<'tcx>,\n+                                     options: &mut Vec<ConstVal>,\n+                                     indices: &mut FnvHashMap<ConstVal, usize>)\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n             Some(match_pair) => match_pair,\n             _ => { return; }\n         };\n \n-        match match_pair.pattern.kind {\n+        match *match_pair.pattern.kind {\n             PatternKind::Constant { value: Literal::Value { ref value } } => {\n                 // if the lvalues match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n@@ -271,252 +271,176 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         target_blocks\n     }\n \n-    /// Given a candidate and the outcome of a test we have performed,\n-    /// transforms the candidate into a new candidate that reflects\n-    /// further tests still needed. Returns `None` if this candidate\n-    /// has now been ruled out.\n+    /// Given that we are performing `test` against `test_lvalue`,\n+    /// this job sorts out what the status of `candidate` will be\n+    /// after the test. The `resulting_candidates` vector stores, for\n+    /// each possible outcome of `test`, a vector of the candidates\n+    /// that will result. This fn should add a (possibly modified)\n+    /// clone of candidate into `resulting_candidates` wherever\n+    /// appropriate.\n     ///\n-    /// For example, if a candidate included the patterns `[x.0 @\n-    /// Ok(P1), x.1 @ 22]`, and we did a switch test on `x.0` and\n-    /// found the variant `Err` (as indicated by the `test_outcome`\n-    /// parameter), we would return `None`. But if the test_outcome\n-    /// were `Ok`, we would return `Some([x.0.downcast<Ok>.0 @ P1, x.1\n-    /// @ 22])`.\n-    pub fn candidate_under_assumption(&mut self,\n-                                      test_lvalue: &Lvalue<'tcx>,\n-                                      test_kind: &TestKind<'tcx>,\n-                                      test_outcome: usize,\n-                                      candidate: &Candidate<'tcx>)\n-                                      -> Option<Candidate<'tcx>> {\n-        let candidate = candidate.clone();\n-        let match_pairs = candidate.match_pairs;\n-        let result = self.match_pairs_under_assumption(test_lvalue,\n-                                                       test_kind,\n-                                                       test_outcome,\n-                                                       match_pairs);\n-        match result {\n-            Some(match_pairs) => Some(Candidate { match_pairs: match_pairs, ..candidate }),\n-            None => None,\n-        }\n-    }\n-\n-    /// Helper for candidate_under_assumption that does the actual\n-    /// work of transforming the list of match pairs.\n-    fn match_pairs_under_assumption(&mut self,\n-                                    test_lvalue: &Lvalue<'tcx>,\n-                                    test_kind: &TestKind<'tcx>,\n-                                    test_outcome: usize,\n-                                    match_pairs: Vec<MatchPair<'tcx>>)\n-                                    -> Option<Vec<MatchPair<'tcx>>> {\n-        let mut result = vec![];\n-\n-        for match_pair in match_pairs {\n-            // if the match pair is testing a different lvalue, it\n-            // is unaffected by this test.\n-            if match_pair.lvalue != *test_lvalue {\n-                result.push(match_pair);\n-                continue;\n-            }\n-\n-            // if this test doesn't tell us anything about this match-pair, then hang onto it.\n-            if !self.test_informs_match_pair(&match_pair, test_kind, test_outcome) {\n-                result.push(match_pair);\n-                continue;\n-            }\n-\n-            // otherwise, build up the consequence match pairs\n-            let opt_consequent_match_pairs =\n-                self.consequent_match_pairs_under_assumption(match_pair,\n-                                                             test_kind,\n-                                                             test_outcome);\n-            match opt_consequent_match_pairs {\n-                None => {\n-                    // Right kind of test, but wrong outcome. That\n-                    // means this **entire candidate** is\n-                    // inapplicable, since the candidate is only\n-                    // applicable if all of its match-pairs apply (and\n-                    // this one doesn't).\n-                    return None;\n-                }\n-\n-                Some(consequent_match_pairs) => {\n-                    // Test passed; add any new patterns we have to test to the final result.\n-                    result.extend(consequent_match_pairs)\n-                }\n+    /// So, for example, if this candidate is `x @ Some(P0)` and the\n+    /// test is a variant test, then we would add `(x as Option).0 @\n+    /// P0` to the `resulting_candidates` entry corresponding to the\n+    /// variant `Some`.\n+    ///\n+    /// In many cases we will add the `candidate` to more than one\n+    /// outcome. For example, say that the test is `x == 22`, but the\n+    /// candidate is `x @ 13..55`. In that case, if the test is true,\n+    /// then we know that the candidate applies (without this match\n+    /// pair, potentially, though we don't optimize this due to\n+    /// #29623). If the test is false, the candidate may also apply\n+    /// (with the match pair, still).\n+    pub fn sort_candidate<'pat>(&mut self,\n+                                test_lvalue: &Lvalue<'tcx>,\n+                                test: &Test<'tcx>,\n+                                candidate: &Candidate<'pat, 'tcx>,\n+                                resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>]) {\n+        // Find the match_pair for this lvalue (if any). At present,\n+        // afaik, there can be at most one. (In the future, if we\n+        // adopted a more general `@` operator, there might be more\n+        // than one, but it'd be very unusual to have two sides that\n+        // both require tests; you'd expect one side to be simplified\n+        // away.)\n+        let tested_match_pair = candidate.match_pairs.iter()\n+                                                     .enumerate()\n+                                                     .filter(|&(_, mp)| mp.lvalue == *test_lvalue)\n+                                                     .next();\n+        let (match_pair_index, match_pair) = match tested_match_pair {\n+            Some(pair) => pair,\n+            None => {\n+                // We are not testing this lvalue. Therefore, this\n+                // candidate applies to ALL outcomes.\n+                return self.add_to_all_candidate_sets(candidate, resulting_candidates);\n             }\n-        }\n-\n-        Some(result)\n-    }\n+        };\n \n-    /// Given that we executed `test` to `match_pair.lvalue` with\n-    /// outcome `test_outcome`, does that tell us anything about\n-    /// whether `match_pair` applies?\n-    ///\n-    /// Often it does not. For example, if we are testing whether\n-    /// the discriminant equals 4, and we find that it does not,\n-    /// but the `match_pair` is testing if the discriminant equals 5,\n-    /// that does not help us.\n-    fn test_informs_match_pair(&mut self,\n-                               match_pair: &MatchPair<'tcx>,\n-                               test_kind: &TestKind<'tcx>,\n-                               _test_outcome: usize)\n-                               -> bool {\n-        match match_pair.pattern.kind {\n-            PatternKind::Variant { .. } => {\n-                match *test_kind {\n-                    TestKind::Switch { .. } => true,\n-                    _ => false,\n+        match test.kind {\n+            // If we are performing a variant switch, then this\n+            // informs variant patterns, but nothing else.\n+            TestKind::Switch { adt_def: tested_adt_def } => {\n+                match *match_pair.pattern.kind {\n+                    PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n+                        assert_eq!(adt_def, tested_adt_def);\n+                        let new_candidate =\n+                            self.candidate_after_variant_switch(match_pair_index,\n+                                                                adt_def,\n+                                                                variant_index,\n+                                                                subpatterns,\n+                                                                candidate);\n+                        resulting_candidates[variant_index].push(new_candidate);\n+                    }\n+                    _ => {\n+                        self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                    }\n                 }\n             }\n \n-            PatternKind::Constant { value: Literal::Value { .. } }\n-            if is_switch_ty(match_pair.pattern.ty) => {\n-                match *test_kind {\n-                    TestKind::SwitchInt { .. } => true,\n-\n-                    // Did not do an integer equality test (which is always a SwitchInt).\n-                    // So we learned nothing relevant to this match-pair.\n-                    //\n-                    // FIXME(#29623) we could use TestKind::Range to rule\n-                    // things out here, in some cases.\n-                    _ => false,\n+            // If we are performing a switch over integers, then this informs integer\n+            // equality, but nothing else.\n+            //\n+            // FIXME(#29623) we could use TestKind::Range to rule\n+            // things out here, in some cases.\n+            TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n+                match *match_pair.pattern.kind {\n+                    PatternKind::Constant { value: Literal::Value { ref value } }\n+                    if is_switch_ty(match_pair.pattern.ty) => {\n+                        let index = indices[value];\n+                        let new_candidate = self.candidate_without_match_pair(match_pair_index,\n+                                                                              candidate);\n+                        resulting_candidates[index].push(new_candidate);\n+                    }\n+                    _ => {\n+                        self.add_to_all_candidate_sets(candidate, resulting_candidates);\n+                    }\n                 }\n             }\n \n-            PatternKind::Constant { .. } |\n-            PatternKind::Range { .. } |\n-            PatternKind::Slice { .. } => {\n+            TestKind::Eq { .. } |\n+            TestKind::Range { .. } |\n+            TestKind::Len { .. } => {\n+                // These are all binary tests.\n+                //\n+                // FIXME(#29623) we can be more clever here\n                 let pattern_test = self.test(&match_pair);\n-                if pattern_test.kind == *test_kind {\n-                    true\n+                if pattern_test.kind == test.kind {\n+                    let new_candidate = self.candidate_without_match_pair(match_pair_index,\n+                                                                          candidate);\n+                    resulting_candidates[0].push(new_candidate);\n                 } else {\n-                    // FIXME(#29623) in all 3 cases, we could sometimes do\n-                    // better here. For example, if we are checking\n-                    // whether the value is equal to X, and we find\n-                    // that it is, that (may) imply value is not equal\n-                    // to Y. Or, if the range tested is `3..5`, and\n-                    // our range is `4..5`, then we know that our\n-                    // range also does not apply. Similarly, if we\n-                    // test that length is >= 5, and it fails, we also\n-                    // know that length is not >= 7. etc.\n-                    false\n+                    self.add_to_all_candidate_sets(candidate, resulting_candidates);\n                 }\n             }\n-\n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Binding { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n-                self.error_simplifyable(&match_pair)\n-            }\n         }\n     }\n \n-    /// Given that we executed `test` with outcome `test_outcome`,\n-    /// what are the resulting match pairs? This can return either:\n-    ///\n-    /// - None, meaning that the test indicated that this outcome\n-    ///   means that this match-pair is not the current one for the\n-    ///   current discriminant (which rules out the enclosing\n-    ///   candidate);\n-    /// - Some(...), meaning that either the test didn't tell us whether this\n-    ///   match-pair is correct or not, or that we DID match and now have\n-    ///   subsequent matches to perform.\n-    ///\n-    /// As an example, consider:\n-    ///\n-    /// ```\n-    /// match option {\n-    ///     Ok(<pattern>) => ...,\n-    ///     Err(_) => ...,\n-    /// }\n-    /// ```\n-    ///\n-    /// Suppose that the `test` is a `Switch` and the outcome is\n-    /// `Ok`. Then in that case, the first arm will have a match-pair\n-    /// of `option @ Ok(<pattern>)`. In that case we will return\n-    /// `Some(vec![(option as Ok) @ <pattern>])`. The `Some` reuslt\n-    /// indicates that the match-pair still applies, and we now have\n-    /// to test `(option as Ok) @ <pattern>`.\n-    ///\n-    /// On the second arm, a `None` will be returned, because if we\n-    /// observed that `option` has the discriminant `Ok`, then the\n-    /// second arm cannot apply.\n-    pub fn consequent_match_pairs_under_assumption(&mut self,\n-                                                   match_pair: MatchPair<'tcx>,\n-                                                   test_kind: &TestKind<'tcx>,\n-                                                   test_outcome: usize)\n-                                                   -> Option<Vec<MatchPair<'tcx>>> {\n-        match match_pair.pattern.kind {\n-            PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n-                assert!(match *test_kind { TestKind::Switch { .. } => true,\n-                                           _ => false });\n-\n-                if test_outcome != variant_index {\n-                    return None; // Tested, but found the wrong variant.\n-                }\n+    fn candidate_without_match_pair<'pat>(&mut self,\n+                                          match_pair_index: usize,\n+                                          candidate: &Candidate<'pat, 'tcx>)\n+                                          -> Candidate<'pat, 'tcx> {\n+        let other_match_pairs =\n+            candidate.match_pairs.iter()\n+                                 .enumerate()\n+                                 .filter(|&(index, _)| index != match_pair_index)\n+                                 .map(|(_, mp)| mp.clone())\n+                                 .collect();\n+        Candidate {\n+            match_pairs: other_match_pairs,\n+            bindings: candidate.bindings.clone(),\n+            guard: candidate.guard.clone(),\n+            arm_index: candidate.arm_index,\n+        }\n+    }\n \n-                // Correct variant. Extract the subitems and match\n-                // those. The lvalue goes gets downcast, so\n-                // e.g. `foo.bar` becomes `foo.bar as Variant`.\n-                let elem = ProjectionElem::Downcast(adt_def, variant_index);\n-                let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n-                let consequent_match_pairs =\n-                    subpatterns.into_iter()\n-                               .map(|subpattern| {\n-                                   let lvalue =\n-                                       downcast_lvalue.clone().field(\n-                                           subpattern.field);\n-                                   self.match_pair(lvalue, subpattern.pattern)\n-                               })\n-                               .collect();\n-                Some(consequent_match_pairs)\n-            }\n+    fn add_to_all_candidate_sets<'pat>(&mut self,\n+                                       candidate: &Candidate<'pat, 'tcx>,\n+                                       resulting_candidates: &mut [Vec<Candidate<'pat, 'tcx>>]) {\n+        for resulting_candidate in resulting_candidates {\n+            resulting_candidate.push(candidate.clone());\n+        }\n+    }\n \n-            PatternKind::Constant { value: Literal::Value { ref value } }\n-            if is_switch_ty(match_pair.pattern.ty) => {\n-                match *test_kind {\n-                    TestKind::SwitchInt { switch_ty: _, options: _, ref indices } => {\n-                        let index = indices[value];\n-                        if index == test_outcome {\n-                            Some(vec![]) // this value, nothing left to test\n-                        } else {\n-                            None // some other value, candidate is inapplicable\n-                        }\n-                    }\n+    fn candidate_after_variant_switch<'pat>(&mut self,\n+                                            match_pair_index: usize,\n+                                            adt_def: ty::AdtDef<'tcx>,\n+                                            variant_index: usize,\n+                                            subpatterns: &'pat [FieldPattern<'tcx>],\n+                                            candidate: &Candidate<'pat, 'tcx>)\n+                                            -> Candidate<'pat, 'tcx> {\n+        let match_pair = &candidate.match_pairs[match_pair_index];\n+\n+        // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n+        // we want to create a set of derived match-patterns like\n+        // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n+        let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+        let downcast_lvalue = match_pair.lvalue.clone().elem(elem); // `(x as Variant)`\n+        let consequent_match_pairs =\n+            subpatterns.iter()\n+                       .map(|subpattern| {\n+                           // e.g., `(x as Variant).0`\n+                           let lvalue = downcast_lvalue.clone().field(subpattern.field);\n+                           // e.g., `(x as Variant).0 @ P1`\n+                           MatchPair::new(lvalue, &subpattern.pattern)\n+                       });\n \n-                    _ => {\n-                        self.hir.span_bug(\n-                            match_pair.pattern.span,\n-                            &format!(\"did a switch-int, but value {:?} not found in cases\",\n-                                     value));\n-                    }\n-                }\n-            }\n+        // In addition, we need all the other match pairs from the old candidate.\n+        let other_match_pairs =\n+            candidate.match_pairs.iter()\n+                                 .enumerate()\n+                                 .filter(|&(index, _)| index != match_pair_index)\n+                                 .map(|(_, mp)| mp.clone());\n \n-            PatternKind::Constant { .. } |\n-            PatternKind::Range { .. } |\n-            PatternKind::Slice { .. } => {\n-                if test_outcome == 0 {\n-                    Some(vec![])\n-                } else {\n-                    None\n-                }\n-            }\n+        let all_match_pairs = consequent_match_pairs.chain(other_match_pairs).collect();\n \n-            PatternKind::Array { .. } |\n-            PatternKind::Wild |\n-            PatternKind::Binding { .. } |\n-            PatternKind::Leaf { .. } |\n-            PatternKind::Deref { .. } => {\n-                self.error_simplifyable(&match_pair)\n-            }\n+        Candidate {\n+            match_pairs: all_match_pairs,\n+            bindings: candidate.bindings.clone(),\n+            guard: candidate.guard.clone(),\n+            arm_index: candidate.arm_index,\n         }\n     }\n \n-    fn error_simplifyable(&mut self, match_pair: &MatchPair<'tcx>) -> ! {\n+    fn error_simplifyable<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> ! {\n         self.hir.span_bug(match_pair.pattern.span,\n                           &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n     }"}, {"sha": "18dde5537da4dc40c944035f541229d0761ade6c", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -15,26 +15,18 @@ use repr::*;\n use std::u32;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    pub fn field_match_pairs(&mut self,\n-                             lvalue: Lvalue<'tcx>,\n-                             subpatterns: Vec<FieldPatternRef<'tcx>>)\n-                             -> Vec<MatchPair<'tcx>> {\n-        subpatterns.into_iter()\n+    pub fn field_match_pairs<'pat>(&mut self,\n+                                   lvalue: Lvalue<'tcx>,\n+                                   subpatterns: &'pat [FieldPattern<'tcx>])\n+                                   -> Vec<MatchPair<'pat, 'tcx>> {\n+        subpatterns.iter()\n                    .map(|fieldpat| {\n                        let lvalue = lvalue.clone().field(fieldpat.field);\n-                       self.match_pair(lvalue, fieldpat.pattern)\n+                       MatchPair::new(lvalue, &fieldpat.pattern)\n                    })\n                    .collect()\n     }\n \n-    pub fn match_pair(&mut self,\n-                      lvalue: Lvalue<'tcx>,\n-                      pattern: PatternRef<'tcx>)\n-                      -> MatchPair<'tcx> {\n-        let pattern = self.hir.mirror(pattern);\n-        MatchPair::new(lvalue, pattern)\n-    }\n-\n     /// When processing an array/slice pattern like `lv @ [x, y, ..s, z]`,\n     /// this function converts the prefix (`x`, `y`) and suffix (`z`) into\n     /// distinct match pairs:\n@@ -49,18 +41,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     ///     tmp0 = lv[2..-1] // using the special Rvalue::Slice\n     ///\n     /// and creates a match pair `tmp0 @ s`\n-    pub fn prefix_suffix_slice(&mut self,\n-                               match_pairs: &mut Vec<MatchPair<'tcx>>,\n-                               block: BasicBlock,\n-                               lvalue: Lvalue<'tcx>,\n-                               prefix: Vec<PatternRef<'tcx>>,\n-                               opt_slice: Option<PatternRef<'tcx>>,\n-                               suffix: Vec<PatternRef<'tcx>>)\n-                               -> BlockAnd<()> {\n+    pub fn prefix_suffix_slice<'pat>(&mut self,\n+                                     match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n+                                     block: BasicBlock,\n+                                     lvalue: Lvalue<'tcx>,\n+                                     prefix: &'pat [Pattern<'tcx>],\n+                                     opt_slice: Option<&'pat Pattern<'tcx>>,\n+                                     suffix: &'pat [Pattern<'tcx>])\n+                                     -> BlockAnd<()> {\n         // If there is a `..P` pattern, create a temporary `t0` for\n         // the slice and then a match pair `t0 @ P`:\n         if let Some(slice) = opt_slice {\n-            let slice = self.hir.mirror(slice);\n             let prefix_len = prefix.len();\n             let suffix_len = suffix.len();\n             let rvalue = Rvalue::Slice {\n@@ -79,17 +70,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n     /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n-    fn prefix_suffix(&mut self,\n-                     match_pairs: &mut Vec<MatchPair<'tcx>>,\n-                     lvalue: Lvalue<'tcx>,\n-                     prefix: Vec<PatternRef<'tcx>>,\n-                     suffix: Vec<PatternRef<'tcx>>) {\n+    fn prefix_suffix<'pat>(&mut self,\n+                           match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n+                           lvalue: Lvalue<'tcx>,\n+                           prefix: &'pat [Pattern<'tcx>],\n+                           suffix: &'pat [Pattern<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);\n         let min_length = min_length as u32;\n \n         let prefix_pairs: Vec<_> =\n-            prefix.into_iter()\n+            prefix.iter()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n                       let elem = ProjectionElem::ConstantIndex {\n@@ -98,12 +89,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           from_end: false,\n                       };\n                       let lvalue = lvalue.clone().elem(elem);\n-                      self.match_pair(lvalue, subpattern)\n+                      MatchPair::new(lvalue, subpattern)\n                   })\n                   .collect();\n \n         let suffix_pairs: Vec<_> =\n-            suffix.into_iter()\n+            suffix.iter()\n                   .rev()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n@@ -113,16 +104,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           from_end: true,\n                       };\n                       let lvalue = lvalue.clone().elem(elem);\n-                      self.match_pair(lvalue, subpattern)\n+                      MatchPair::new(lvalue, subpattern)\n                   })\n                   .collect();\n \n         match_pairs.extend(prefix_pairs.into_iter().chain(suffix_pairs));\n     }\n }\n \n-impl<'tcx> MatchPair<'tcx> {\n-    pub fn new(lvalue: Lvalue<'tcx>, pattern: Pattern<'tcx>) -> MatchPair<'tcx> {\n+impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n+    pub fn new(lvalue: Lvalue<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             lvalue: lvalue,\n             pattern: pattern,"}, {"sha": "eb03727d9b2c02afa81d1012df73e4da80cca56f", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hair;\n-use hair::cx::{Cx, PatNode};\n+use hair::cx::Cx;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::ty::{FnOutput, Ty};\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -78,7 +77,7 @@ macro_rules! unpack {\n pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n                           _span: Span,\n                           implicit_arguments: Vec<Ty<'tcx>>,\n-                          explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                          explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                           argument_extent: CodeExtent,\n                           return_ty: FnOutput<'tcx>,\n                           ast_block: &'tcx hir::Block)\n@@ -130,7 +129,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      implicit_arguments: Vec<Ty<'tcx>>,\n-                     explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                     explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                      argument_extent: CodeExtent,\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<Vec<ArgDecl<'tcx>>>\n@@ -148,9 +147,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     .enumerate()\n                     .map(|(index, (ty, pattern))| {\n                         let lvalue = Lvalue::Arg(index as u32);\n+                        let pattern = this.hir.irrefutable_pat(pattern);\n                         unpack!(block = this.lvalue_into_pattern(block,\n                                                                  argument_extent,\n-                                                                 hair::PatternRef::Hair(pattern),\n+                                                                 pattern,\n                                                                  &lvalue));\n                         ArgDecl { ty: ty }\n                     });"}, {"sha": "0c0816a2d9d28001ca927e7a739eb554e3f548e3", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -40,7 +40,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n                 this.in_scope(remainder_scope, block, |this| {\n                     unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.declare_bindings(remainder_scope, pattern);\n+                        this.declare_bindings(remainder_scope, &pattern);\n                         block.unit()\n                     }));\n                     this.stmts(block, stmts)"}, {"sha": "bedcefe3b0dac2171116e17582ab99a07ebd930c", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -10,7 +10,6 @@\n \n use hair::*;\n use hair::cx::Cx;\n-use hair::cx::pattern::PatNode;\n use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{BlockRemainder, CodeExtentData};\n use rustc_front::hir;\n@@ -65,12 +64,13 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                         // they are within the scope of this let:\n                         let following_stmts = mirror_stmts(cx, block_id, stmts);\n \n+                        let pattern = cx.irrefutable_pat(&local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n                                 init_scope: cx.tcx.region_maps.node_extent(id),\n-                                pattern: PatNode::irrefutable(&local.pat).to_ref(),\n+                                pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                                 stmts: following_stmts,\n                             },"}, {"sha": "3fd895afa983e8e3a08a335a2b490d67eb0bb18d", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -11,10 +11,8 @@\n use hair::*;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n-use std::rc::Rc;\n use hair::cx::Cx;\n use hair::cx::block;\n-use hair::cx::pattern::PatNode;\n use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n use rustc::middle::const_eval;\n@@ -486,19 +484,20 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'tcx: 'a>(cx: &Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n-    let map = if arm.pats.len() == 1 {\n+fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+    let mut map;\n+    let opt_map = if arm.pats.len() == 1 {\n         None\n     } else {\n-        let mut map = FnvHashMap();\n+        map = FnvHashMap();\n         pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n             map.insert(path.node, p_id);\n         });\n-        Some(Rc::new(map))\n+        Some(&map)\n     };\n \n     Arm {\n-        patterns: arm.pats.iter().map(|p| PatNode::new(p, map.clone()).to_ref()).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.refutable_pat(opt_map, p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }"}, {"sha": "70a64a5653a3c8b6535ef50ce1909ac3b45b534a", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -41,8 +41,6 @@ impl<'a,'tcx> Cx<'a,'tcx> {\n     }\n }\n \n-pub use self::pattern::PatNode;\n-\n impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n     /// Normalizes `ast` into the appropriate `mirror` type.\n     pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {"}, {"sha": "e9b58199023bf4c5229e54bac4e292ba1ae24f4e", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 138, "deletions": 139, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -10,10 +10,8 @@\n \n use hair::*;\n use hair::cx::Cx;\n-use hair::cx::to_ref::ToRef;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n-use std::rc::Rc;\n use rustc::middle::const_eval;\n use rustc::middle::def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n@@ -36,183 +34,111 @@ use syntax::ptr::P;\n ///    _ => { ... }\n /// }\n /// ```\n-#[derive(Clone, Debug)]\n-pub struct PatNode<'tcx> {\n-    pat: &'tcx hir::Pat,\n-    binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>,\n+struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> {\n+    cx: &'patcx mut Cx<'cx, 'tcx>,\n+    binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n-impl<'tcx> PatNode<'tcx> {\n-    pub fn new(pat: &'tcx hir::Pat,\n-               binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>)\n-               -> PatNode<'tcx> {\n-        PatNode {\n-            pat: pat,\n-            binding_map: binding_map,\n-        }\n-    }\n-\n-    pub fn irrefutable(pat: &'tcx hir::Pat) -> PatNode<'tcx> {\n-        PatNode::new(pat, None)\n-    }\n-\n-    fn pat_ref<'a>(&self, pat: &'tcx hir::Pat) -> PatternRef<'tcx> {\n-        PatNode::new(pat, self.binding_map.clone()).to_ref()\n+impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n+    pub fn irrefutable_pat(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        PatCx::new(self, None).to_pat(pat)\n     }\n \n-    fn pat_refs<'a>(&self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<PatternRef<'tcx>> {\n-        pats.iter().map(|p| self.pat_ref(p)).collect()\n-    }\n-\n-    fn opt_pat_ref<'a>(&self, pat: &'tcx Option<P<hir::Pat>>) -> Option<PatternRef<'tcx>> {\n-        pat.as_ref().map(|p| self.pat_ref(p))\n-    }\n-\n-    fn slice_or_array_pattern<'a>(&self,\n-                                  cx: &mut Cx<'a, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  prefix: &'tcx Vec<P<hir::Pat>>,\n-                                  slice: &'tcx Option<P<hir::Pat>>,\n-                                  suffix: &'tcx Vec<P<hir::Pat>>)\n-                                  -> PatternKind<'tcx> {\n-        match ty.sty {\n-            ty::TySlice(..) =>\n-                // matching a slice or fixed-length array\n-                PatternKind::Slice {\n-                    prefix: self.pat_refs(prefix),\n-                    slice: self.opt_pat_ref(slice),\n-                    suffix: self.pat_refs(suffix),\n-                },\n-\n-            ty::TyArray(_, len) => {\n-                // fixed-length array\n-                assert!(len >= prefix.len() + suffix.len());\n-                PatternKind::Array {\n-                    prefix: self.pat_refs(prefix),\n-                    slice: self.opt_pat_ref(slice),\n-                    suffix: self.pat_refs(suffix),\n-                }\n-            }\n-\n-            _ => {\n-                cx.tcx.sess.span_bug(self.pat.span, \"unexpanded macro or bad constant etc\");\n-            }\n-        }\n+    pub fn refutable_pat(&mut self,\n+                         binding_map: Option<&FnvHashMap<ast::Name, ast::NodeId>>,\n+                         pat: &'tcx hir::Pat)\n+                         -> Pattern<'tcx> {\n+        PatCx::new(self, binding_map).to_pat(pat)\n     }\n+}\n \n-    fn variant_or_leaf<'a>(&self,\n-                           cx: &mut Cx<'a, 'tcx>,\n-                           subpatterns: Vec<FieldPatternRef<'tcx>>)\n-                           -> PatternKind<'tcx> {\n-        let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n-        match def {\n-            def::DefVariant(enum_id, variant_id, _) => {\n-                let adt_def = cx.tcx.lookup_adt_def(enum_id);\n-                if adt_def.variants.len() > 1 {\n-                    PatternKind::Variant {\n-                        adt_def: adt_def,\n-                        variant_index: adt_def.variant_index_with_id(variant_id),\n-                        subpatterns: subpatterns,\n-                    }\n-                } else {\n-                    PatternKind::Leaf { subpatterns: subpatterns }\n-                }\n-            }\n-\n-            // NB: resolving to DefStruct means the struct *constructor*,\n-            // not the struct as a type.\n-            def::DefStruct(..) | def::DefTy(..) => {\n-                PatternKind::Leaf { subpatterns: subpatterns }\n-            }\n-\n-            _ => {\n-                cx.tcx.sess.span_bug(self.pat.span,\n-                                     &format!(\"inappropriate def for pattern: {:?}\", def));\n-            }\n+impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n+    fn new(cx: &'patcx mut Cx<'cx, 'tcx>,\n+               binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n+               -> PatCx<'patcx, 'cx, 'tcx> {\n+        PatCx {\n+            cx: cx,\n+            binding_map: binding_map,\n         }\n     }\n-}\n \n-impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n-    type Output = Pattern<'tcx>;\n-\n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n-        let kind = match self.pat.node {\n+    fn to_pat(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        let kind = match pat.node {\n             hir::PatWild => PatternKind::Wild,\n \n             hir::PatLit(ref value) => {\n-                let value = const_eval::eval_const_expr(cx.tcx, value);\n+                let value = const_eval::eval_const_expr(self.cx.tcx, value);\n                 let value = Literal::Value { value: value };\n                 PatternKind::Constant { value: value }\n             }\n \n             hir::PatRange(ref lo, ref hi) => {\n-                let lo = const_eval::eval_const_expr(cx.tcx, lo);\n+                let lo = const_eval::eval_const_expr(self.cx.tcx, lo);\n                 let lo = Literal::Value { value: lo };\n-                let hi = const_eval::eval_const_expr(cx.tcx, hi);\n+                let hi = const_eval::eval_const_expr(self.cx.tcx, hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n             hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n-                if pat_is_resolved_const(&cx.tcx.def_map.borrow(), self.pat) =>\n+                if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n-                let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n                     def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n-                        match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n+                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, Some(pat.id)) {\n                             Some(const_expr) => {\n                                 let opt_value =\n                                     const_eval::eval_const_expr_partial(\n-                                        cx.tcx, const_expr,\n+                                        self.cx.tcx, const_expr,\n                                         const_eval::EvalHint::ExprTypeChecked,\n                                         None);\n                                 let literal = if let Ok(value) = opt_value {\n                                     Literal::Value { value: value }\n                                 } else {\n-                                    let substs = cx.tcx.mk_substs(Substs::empty());\n+                                    let substs = self.cx.tcx.mk_substs(Substs::empty());\n                                     Literal::Item { def_id: def_id, substs: substs }\n                                 };\n                                 PatternKind::Constant { value: literal }\n                             }\n                             None => {\n-                                cx.tcx.sess.span_bug(\n-                                    self.pat.span,\n+                                self.cx.tcx.sess.span_bug(\n+                                    pat.span,\n                                     &format!(\"cannot eval constant: {:?}\", def_id))\n                             }\n                         },\n                     _ =>\n-                        cx.tcx.sess.span_bug(\n-                            self.pat.span,\n+                        self.cx.tcx.sess.span_bug(\n+                            pat.span,\n                             &format!(\"def not a constant: {:?}\", def)),\n                 }\n             }\n \n             hir::PatRegion(ref subpattern, _) |\n             hir::PatBox(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.pat_ref(subpattern) }\n+                PatternKind::Deref { subpattern: self.to_pat(subpattern) }\n             }\n \n             hir::PatVec(ref prefix, ref slice, ref suffix) => {\n-                let ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let ty = self.cx.tcx.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n                                 ty: mt.ty,\n-                                span: self.pat.span,\n-                                kind: self.slice_or_array_pattern(cx, mt.ty, prefix,\n-                                                                  slice, suffix),\n-                            }.to_ref()\n+                                span: pat.span,\n+                                kind: Box::new(self.slice_or_array_pattern(pat, mt.ty, prefix,\n+                                                                           slice, suffix)),\n+                            },\n                         },\n \n                     ty::TySlice(..) |\n                     ty::TyArray(..) =>\n-                        self.slice_or_array_pattern(cx, ty, prefix, slice, suffix),\n+                        self.slice_or_array_pattern(pat, ty, prefix, slice, suffix),\n \n                     ref sty =>\n-                        cx.tcx.sess.span_bug(\n-                            self.pat.span,\n+                        self.cx.tcx.sess.span_bug(\n+                            pat.span,\n                             &format!(\"unexpanded type for vector pattern: {:?}\", sty)),\n                 }\n             }\n@@ -221,23 +147,23 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                 let subpatterns =\n                     subpatterns.iter()\n                                .enumerate()\n-                               .map(|(i, subpattern)| FieldPatternRef {\n+                               .map(|(i, subpattern)| FieldPattern {\n                                    field: Field::new(i),\n-                                   pattern: self.pat_ref(subpattern),\n+                                   pattern: self.to_pat(subpattern),\n                                })\n                                .collect();\n \n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n             hir::PatIdent(bm, ref ident, ref sub)\n-                if pat_is_binding(&cx.tcx.def_map.borrow(), self.pat) =>\n+                if pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let id = match self.binding_map {\n-                    None => self.pat.id,\n+                    None => pat.id,\n                     Some(ref map) => map[&ident.node.name],\n                 };\n-                let var_ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(&r, _) => Some(r),\n                     _ => None,\n@@ -258,71 +184,144 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                     name: ident.node.name,\n                     var: id,\n                     ty: var_ty,\n-                    subpattern: self.opt_pat_ref(sub),\n+                    subpattern: self.to_opt_pat(sub),\n                 }\n             }\n \n             hir::PatIdent(..) => {\n-                self.variant_or_leaf(cx, vec![])\n+                self.variant_or_leaf(pat, vec![])\n             }\n \n             hir::PatEnum(_, ref opt_subpatterns) => {\n                 let subpatterns =\n                     opt_subpatterns.iter()\n                                    .flat_map(|v| v.iter())\n                                    .enumerate()\n-                                   .map(|(i, field)| FieldPatternRef {\n+                                   .map(|(i, field)| FieldPattern {\n                                        field: Field::new(i),\n-                                       pattern: self.pat_ref(field),\n+                                       pattern: self.to_pat(field),\n                                    })\n                                    .collect();\n-                self.variant_or_leaf(cx, subpatterns)\n+                self.variant_or_leaf(pat, subpatterns)\n             }\n \n             hir::PatStruct(_, ref fields, _) => {\n-                let pat_ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n                     _ => {\n-                        cx.tcx.sess.span_bug(\n-                            self.pat.span,\n+                        self.cx.tcx.sess.span_bug(\n+                            pat.span,\n                             \"struct pattern not applied to struct or enum\");\n                     }\n                 };\n \n-                let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| {\n                               let index = variant_def.index_of_field_named(field.node.name);\n                               let index = index.unwrap_or_else(|| {\n-                                  cx.tcx.sess.span_bug(\n-                                      self.pat.span,\n+                                  self.cx.tcx.sess.span_bug(\n+                                      pat.span,\n                                       &format!(\"no field with name {:?}\", field.node.name));\n                               });\n-                              FieldPatternRef {\n+                              FieldPattern {\n                                   field: Field::new(index),\n-                                  pattern: self.pat_ref(&field.node.pat),\n+                                  pattern: self.to_pat(&field.node.pat),\n                               }\n                           })\n                           .collect();\n \n-                self.variant_or_leaf(cx, subpatterns)\n+                self.variant_or_leaf(pat, subpatterns)\n             }\n \n             hir::PatQPath(..) => {\n-                cx.tcx.sess.span_bug(self.pat.span, \"unexpanded macro or bad constant etc\");\n+                self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         };\n \n-        let ty = cx.tcx.node_id_to_type(self.pat.id);\n+        let ty = self.cx.tcx.node_id_to_type(pat.id);\n \n         Pattern {\n-            span: self.pat.span,\n+            span: pat.span,\n             ty: ty,\n-            kind: kind,\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn to_pats(&mut self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<Pattern<'tcx>> {\n+        pats.iter().map(|p| self.to_pat(p)).collect()\n+    }\n+\n+    fn to_opt_pat(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> {\n+        pat.as_ref().map(|p| self.to_pat(p))\n+    }\n+\n+    fn slice_or_array_pattern(&mut self,\n+                              pat: &'tcx hir::Pat,\n+                              ty: Ty<'tcx>,\n+                              prefix: &'tcx Vec<P<hir::Pat>>,\n+                              slice: &'tcx Option<P<hir::Pat>>,\n+                              suffix: &'tcx Vec<P<hir::Pat>>)\n+                              -> PatternKind<'tcx> {\n+        match ty.sty {\n+            ty::TySlice(..) => {\n+                // matching a slice or fixed-length array\n+                PatternKind::Slice {\n+                    prefix: self.to_pats(prefix),\n+                    slice: self.to_opt_pat(slice),\n+                    suffix: self.to_pats(suffix),\n+                }\n+            }\n+\n+            ty::TyArray(_, len) => {\n+                // fixed-length array\n+                assert!(len >= prefix.len() + suffix.len());\n+                PatternKind::Array {\n+                    prefix: self.to_pats(prefix),\n+                    slice: self.to_opt_pat(slice),\n+                    suffix: self.to_pats(suffix),\n+                }\n+            }\n+\n+            _ => {\n+                self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n+            }\n+        }\n+    }\n+\n+    fn variant_or_leaf(&mut self,\n+                       pat: &'tcx hir::Pat,\n+                       subpatterns: Vec<FieldPattern<'tcx>>)\n+                       -> PatternKind<'tcx> {\n+        let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+        match def {\n+            def::DefVariant(enum_id, variant_id, _) => {\n+                let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n+                if adt_def.variants.len() > 1 {\n+                    PatternKind::Variant {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(variant_id),\n+                        subpatterns: subpatterns,\n+                    }\n+                } else {\n+                    PatternKind::Leaf { subpatterns: subpatterns }\n+                }\n+            }\n+\n+            // NB: resolving to DefStruct means the struct *constructor*,\n+            // not the struct as a type.\n+            def::DefStruct(..) | def::DefTy(..) => {\n+                PatternKind::Leaf { subpatterns: subpatterns }\n+            }\n+\n+            _ => {\n+                self.cx.tcx.sess.span_bug(pat.span,\n+                                          &format!(\"inappropriate def for pattern: {:?}\", def));\n+            }\n         }\n     }\n }"}, {"sha": "da200a8a33f083616333f42641c4a77c9b96fe88", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -10,7 +10,6 @@\n \n use hair::*;\n \n-use hair::cx::pattern::PatNode;\n use rustc_front::hir;\n use syntax::ptr::P;\n \n@@ -43,22 +42,6 @@ impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for PatNode<'tcx> {\n-    type Output = PatternRef<'tcx>;\n-\n-    fn to_ref(self) -> PatternRef<'tcx> {\n-        PatternRef::Hair(self)\n-    }\n-}\n-\n-impl<'a,'tcx:'a> ToRef for Pattern<'tcx> {\n-    type Output = PatternRef<'tcx>;\n-\n-    fn to_ref(self) -> PatternRef<'tcx> {\n-        PatternRef::Mirror(Box::new(self))\n-    }\n-}\n-\n impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n     where &'tcx T: ToRef<Output=U>\n {"}, {"sha": "6066791501424336a0fa83ef3886a45d89e1d076", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n-use self::cx::{Cx, PatNode};\n+use self::cx::Cx;\n \n pub mod cx;\n \n@@ -72,7 +72,7 @@ pub enum StmtKind<'tcx> {\n         init_scope: CodeExtent,\n \n         /// let <PAT> = ...\n-        pattern: PatternRef<'tcx>,\n+        pattern: Pattern<'tcx>,\n \n         /// let pat = <INIT> ...\n         initializer: Option<ExprRef<'tcx>>,\n@@ -252,7 +252,7 @@ pub struct FieldExprRef<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n-    pub patterns: Vec<PatternRef<'tcx>>,\n+    pub patterns: Vec<Pattern<'tcx>>,\n     pub guard: Option<ExprRef<'tcx>>,\n     pub body: ExprRef<'tcx>,\n }\n@@ -261,7 +261,7 @@ pub struct Arm<'tcx> {\n pub struct Pattern<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub kind: PatternKind<'tcx>,\n+    pub kind: Box<PatternKind<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -281,23 +281,23 @@ pub enum PatternKind<'tcx> {\n         mode: BindingMode,\n         var: ast::NodeId,\n         ty: Ty<'tcx>,\n-        subpattern: Option<PatternRef<'tcx>>,\n+        subpattern: Option<Pattern<'tcx>>,\n     },\n \n     // Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n         adt_def: AdtDef<'tcx>,\n         variant_index: usize,\n-        subpatterns: Vec<FieldPatternRef<'tcx>>,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n     // (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n     Leaf {\n-        subpatterns: Vec<FieldPatternRef<'tcx>>,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n     Deref {\n-        subpattern: PatternRef<'tcx>,\n+        subpattern: Pattern<'tcx>,\n     }, // box P, &P, &mut P, etc\n \n     Constant {\n@@ -311,16 +311,16 @@ pub enum PatternKind<'tcx> {\n \n     // matches against a slice, checking the length and extracting elements\n     Slice {\n-        prefix: Vec<PatternRef<'tcx>>,\n-        slice: Option<PatternRef<'tcx>>,\n-        suffix: Vec<PatternRef<'tcx>>,\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n     },\n \n     // fixed match against an array, irrefutable\n     Array {\n-        prefix: Vec<PatternRef<'tcx>>,\n-        slice: Option<PatternRef<'tcx>>,\n-        suffix: Vec<PatternRef<'tcx>>,\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n     },\n }\n \n@@ -331,15 +331,9 @@ pub enum BindingMode {\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatternRef<'tcx> {\n-    Hair(PatNode<'tcx>),\n-    Mirror(Box<Pattern<'tcx>>),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct FieldPatternRef<'tcx> {\n+pub struct FieldPattern<'tcx> {\n     pub field: Field,\n-    pub pattern: PatternRef<'tcx>,\n+    pub pattern: Pattern<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -400,25 +394,6 @@ impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Mirror<'tcx> for Pattern<'tcx> {\n-    type Output = Pattern<'tcx>;\n-\n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for PatternRef<'tcx> {\n-    type Output = Pattern<'tcx>;\n-\n-    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n-        match self {\n-            PatternRef::Hair(h) => h.make_mirror(hir),\n-            PatternRef::Mirror(m) => *m,\n-        }\n-    }\n-}\n-\n impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n     type Output = Block<'tcx>;\n "}, {"sha": "9362aeb6005c148757f4df155a0e8dc1e3a2dda1", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_front;\n use build;\n use dot;\n use repr::Mir;\n-use hair::cx::{PatNode, Cx};\n+use hair::cx::Cx;\n use std::fs::File;\n \n use self::rustc::middle::infer;\n@@ -211,7 +211,7 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n             .iter()\n             .enumerate()\n             .map(|(index, arg)| {\n-                (fn_sig.inputs[index], PatNode::irrefutable(&arg.pat))\n+                (fn_sig.inputs[index], &*arg.pat)\n             })\n             .collect();\n "}, {"sha": "7e27f7093ad6bfbd8d3179a6e1e6aedc6d8fd83a", "filename": "src/test/run-pass/issue-29227.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Ftest%2Frun-pass%2Fissue-29227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1f5c04c07f2e888c43cb577810659a7c1d87a00/src%2Ftest%2Frun-pass%2Fissue-29227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29227.rs?ref=f1f5c04c07f2e888c43cb577810659a7c1d87a00"}]}