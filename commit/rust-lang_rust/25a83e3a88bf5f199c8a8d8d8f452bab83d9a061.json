{"sha": "25a83e3a88bf5f199c8a8d8d8f452bab83d9a061", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YTgzZTNhODhiZjVmMTk5YzhhOGQ4ZDhmNDUyYmFiODNkOWEwNjE=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2018-08-23T18:22:22Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2018-08-23T21:13:14Z"}, "message": "Use SmallVec for SmallCStr", "tree": {"sha": "5e68b47e932b6fa925589f6abceb29967eb0e59e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e68b47e932b6fa925589f6abceb29967eb0e59e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25a83e3a88bf5f199c8a8d8d8f452bab83d9a061", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25a83e3a88bf5f199c8a8d8d8f452bab83d9a061", "html_url": "https://github.com/rust-lang/rust/commit/25a83e3a88bf5f199c8a8d8d8f452bab83d9a061", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25a83e3a88bf5f199c8a8d8d8f452bab83d9a061/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5284b0b57275cb18618ef1532ee7f07c32a1e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5284b0b57275cb18618ef1532ee7f07c32a1e18", "html_url": "https://github.com/rust-lang/rust/commit/e5284b0b57275cb18618ef1532ee7f07c32a1e18"}], "stats": {"total": 87, "additions": 39, "deletions": 48}, "files": [{"sha": "08794fbec8dc5df7adb7ae66083e137e94b85b64", "filename": "src/librustc_data_structures/small_c_str.rs", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/25a83e3a88bf5f199c8a8d8d8f452bab83d9a061/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25a83e3a88bf5f199c8a8d8d8f452bab83d9a061/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_c_str.rs?ref=25a83e3a88bf5f199c8a8d8d8f452bab83d9a061", "patch": "@@ -11,69 +11,61 @@\n use std::ffi;\n use std::ops::Deref;\n \n-const SIZE: usize = 38;\n+use smallvec::SmallVec;\n+\n+const SIZE: usize = 36;\n \n /// Like SmallVec but for C strings.\n #[derive(Clone)]\n-pub enum SmallCStr {\n-    OnStack {\n-        data: [u8; SIZE],\n-        len_with_nul: u8,\n-    },\n-    OnHeap {\n-        data: ffi::CString,\n-    }\n+pub struct SmallCStr {\n+    data: SmallVec<[u8; SIZE]>,\n }\n \n impl SmallCStr {\n     #[inline]\n     pub fn new(s: &str) -> SmallCStr {\n-        if s.len() < SIZE {\n-            let mut data = [0; SIZE];\n-            data[.. s.len()].copy_from_slice(s.as_bytes());\n-            let len_with_nul = s.len() + 1;\n-\n-            // Make sure once that this is a valid CStr\n-            if let Err(e) = ffi::CStr::from_bytes_with_nul(&data[.. len_with_nul]) {\n-                panic!(\"The string \\\"{}\\\" cannot be converted into a CStr: {}\", s, e);\n-            }\n-\n-            SmallCStr::OnStack {\n-                data,\n-                len_with_nul: len_with_nul as u8,\n-            }\n+        let len = s.len();\n+        let len1 = len + 1;\n+        let data = if len < SIZE {\n+            let mut buf = [0; SIZE];\n+            buf[..len].copy_from_slice(s.as_bytes());\n+            SmallVec::from_buf_and_len(buf, len1)\n         } else {\n-            SmallCStr::OnHeap {\n-                data: ffi::CString::new(s).unwrap()\n-            }\n+            let mut data = Vec::with_capacity(len1);\n+            data.extend_from_slice(s.as_bytes());\n+            data.push(0);\n+            SmallVec::from_vec(data)\n+        };\n+        if let Err(e) = ffi::CStr::from_bytes_with_nul(&data) {\n+            panic!(\"The string \\\"{}\\\" cannot be converted into a CStr: {}\", s, e);\n         }\n+        SmallCStr { data }\n     }\n \n+    #[inline]\n+    pub fn new_with_nul(s: &str) -> SmallCStr {\n+        let b = s.as_bytes();\n+        if let Err(e) = ffi::CStr::from_bytes_with_nul(b) {\n+            panic!(\"The string \\\"{}\\\" cannot be converted into a CStr: {}\", s, e);\n+        }\n+        SmallCStr { data: SmallVec::from_slice(s.as_bytes()) }\n+    }\n+\n+\n     #[inline]\n     pub fn as_c_str(&self) -> &ffi::CStr {\n-        match *self {\n-            SmallCStr::OnStack { ref data, len_with_nul } => {\n-                unsafe {\n-                    let slice = &data[.. len_with_nul as usize];\n-                    ffi::CStr::from_bytes_with_nul_unchecked(slice)\n-                }\n-            }\n-            SmallCStr::OnHeap { ref data } => {\n-                data.as_c_str()\n-            }\n+        unsafe {\n+            ffi::CStr::from_bytes_with_nul_unchecked(&self.data[..])\n         }\n     }\n \n     #[inline]\n     pub fn len_with_nul(&self) -> usize {\n-        match *self {\n-            SmallCStr::OnStack { len_with_nul, .. } => {\n-                len_with_nul as usize\n-            }\n-            SmallCStr::OnHeap { ref data } => {\n-                data.as_bytes_with_nul().len()\n-            }\n-        }\n+        self.data.len()\n+    }\n+\n+    pub fn spilled(&self) -> bool {\n+        self.data.spilled()\n     }\n }\n \n@@ -85,7 +77,6 @@ impl Deref for SmallCStr {\n     }\n }\n \n-\n #[test]\n fn short() {\n     const TEXT: &str = \"abcd\";\n@@ -95,7 +86,7 @@ fn short() {\n \n     assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n     assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(if let SmallCStr::OnStack { .. } = scs { true } else { false });\n+    assert!(!scs.spilled());\n }\n \n #[test]\n@@ -107,7 +98,7 @@ fn empty() {\n \n     assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n     assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(if let SmallCStr::OnStack { .. } = scs { true } else { false });\n+    assert!(!scs.spilled());\n }\n \n #[test]\n@@ -121,7 +112,7 @@ fn long() {\n \n     assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n     assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(if let SmallCStr::OnHeap { .. } = scs { true } else { false });\n+    assert!(scs.spilled());\n }\n \n #[test]"}]}