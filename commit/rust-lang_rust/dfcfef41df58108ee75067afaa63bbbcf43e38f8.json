{"sha": "dfcfef41df58108ee75067afaa63bbbcf43e38f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmY2ZlZjQxZGY1ODEwOGVlNzUwNjdhZmFhNjNiYmJjZjQzZTM4Zjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-28T23:52:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-28T23:52:59Z"}, "message": "rustc: Rename take glue to copy glue", "tree": {"sha": "7abfc613aafac9dae3668169f59d4e7ca878d406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7abfc613aafac9dae3668169f59d4e7ca878d406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfcfef41df58108ee75067afaa63bbbcf43e38f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfcfef41df58108ee75067afaa63bbbcf43e38f8", "html_url": "https://github.com/rust-lang/rust/commit/dfcfef41df58108ee75067afaa63bbbcf43e38f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfcfef41df58108ee75067afaa63bbbcf43e38f8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d37118a00d5343641c7a949c89bf5a4841c1eec", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d37118a00d5343641c7a949c89bf5a4841c1eec", "html_url": "https://github.com/rust-lang/rust/commit/1d37118a00d5343641c7a949c89bf5a4841c1eec"}], "stats": {"total": 63, "additions": 32, "deletions": 31}, "files": [{"sha": "95308f0cf74b14dca5243adde40623bb464c7299", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=dfcfef41df58108ee75067afaa63bbbcf43e38f8", "patch": "@@ -52,7 +52,7 @@ const int tydesc_field_size = 1;\n \n const int tydesc_field_align = 2;\n \n-const int tydesc_field_take_glue = 3;\n+const int tydesc_field_copy_glue = 3;\n \n const int tydesc_field_drop_glue = 4;\n "}, {"sha": "5afd7724dc396790dfc929f4a8b4d07f65620774", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dfcfef41df58108ee75067afaa63bbbcf43e38f8", "patch": "@@ -86,7 +86,7 @@ type tydesc_info =\n         ValueRef tydesc,\n         ValueRef size,\n         ValueRef align,\n-        mutable option::t[ValueRef] take_glue,\n+        mutable option::t[ValueRef] copy_glue,\n         mutable option::t[ValueRef] drop_glue,\n         mutable option::t[ValueRef] free_glue,\n         mutable option::t[ValueRef] cmp_glue,\n@@ -506,7 +506,7 @@ fn T_tydesc(&type_names tn) -> TypeRef {\n         T_struct([tydescpp, // first_param\n                    T_int(), // size\n                    T_int(), // align\n-                   glue_fn_ty, // take_glue\n+                   glue_fn_ty, // copy_glue\n                    glue_fn_ty, // drop_glue\n                    glue_fn_ty, // free_glue\n                    glue_fn_ty, // sever_glue\n@@ -1797,7 +1797,7 @@ fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t, vec[uint] ty_params) ->\n              tydesc=gvar,\n              size=llsize,\n              align=llalign,\n-             mutable take_glue=none[ValueRef],\n+             mutable copy_glue=none[ValueRef],\n              mutable drop_glue=none[ValueRef],\n              mutable free_glue=none[ValueRef],\n              mutable cmp_glue=none[ValueRef],\n@@ -1874,8 +1874,8 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n         auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n         auto cmp_fn_ty = T_ptr(T_cmp_glue_fn(ccx.tn));\n         auto ti = pair._1;\n-        auto take_glue =\n-            alt ({ ti.take_glue }) {\n+        auto copy_glue =\n+            alt ({ ti.copy_glue }) {\n                 case (none) {\n                     ccx.stats.n_null_glues += 1u;\n                     C_null(glue_fn_ty)\n@@ -1908,7 +1908,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n             };\n         auto tydesc =\n             C_struct([C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))), ti.size,\n-                      ti.align, take_glue, // take_glue\n+                      ti.align, copy_glue, // copy_glue\n                        drop_glue, // drop_glue\n                        free_glue, // free_glue\n                        C_null(glue_fn_ty), // sever_glue\n@@ -1925,14 +1925,14 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n     }\n }\n \n-fn make_take_glue(&@block_ctxt cx, ValueRef v, &ty::t t) {\n+fn make_copy_glue(&@block_ctxt cx, ValueRef v, &ty::t t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n \n     auto bcx;\n     if (ty::type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n         bcx = incr_refcnt_of_boxed(cx, cx.build.Load(v)).bcx;\n     } else if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t)) {\n-        bcx = iter_structural_ty(cx, v, t, bind take_ty(_, _, _)).bcx;\n+        bcx = iter_structural_ty(cx, v, t, bind copy_ty(_, _, _)).bcx;\n     } else { bcx = cx; }\n     bcx.build.RetVoid();\n }\n@@ -2839,7 +2839,7 @@ fn iter_sequence(@block_ctxt cx, ValueRef v, &ty::t t, &val_and_ty_fn f) ->\n \n fn lazily_emit_all_tydesc_glue(&@block_ctxt cx,\n                                &option::t[@tydesc_info] static_ti) {\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, static_ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_copy_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, static_ti);\n@@ -2857,8 +2857,8 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n     alt (static_ti) {\n         case (none) { }\n         case (some(?ti)) {\n-            if (field == abi::tydesc_field_take_glue) {\n-                alt ({ ti.take_glue }) {\n+            if (field == abi::tydesc_field_copy_glue) {\n+                alt ({ ti.copy_glue }) {\n                     case (some(_)) { }\n                     case (none) {\n                         log #fmt(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n@@ -2867,9 +2867,9 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n                                                  T_glue_fn(lcx.ccx.tn),\n-                                                 \"take\");\n-                        ti.take_glue = some[ValueRef](glue_fn);\n-                        auto tg = make_take_glue;\n+                                                 \"copy\");\n+                        ti.copy_glue = some[ValueRef](glue_fn);\n+                        auto tg = make_copy_glue;\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n                                           mgghf_single(tg), ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue TAKE %s\",\n@@ -2945,8 +2945,8 @@ fn call_tydesc_glue_full(&@block_ctxt cx, ValueRef v, ValueRef tydesc,\n     alt (static_ti) {\n       case (none) { /* no-op */ }\n       case (some(?sti)) {\n-        if (field == abi::tydesc_field_take_glue) {\n-            static_glue_fn = sti.take_glue;\n+        if (field == abi::tydesc_field_copy_glue) {\n+            static_glue_fn = sti.copy_glue;\n         } else if (field == abi::tydesc_field_drop_glue) {\n             static_glue_fn = sti.drop_glue;\n         } else if (field == abi::tydesc_field_free_glue) {\n@@ -3053,9 +3053,9 @@ fn compare(&@block_ctxt cx, ValueRef lhs, ValueRef rhs, &ty::t t,\n     ret call_cmp_glue(cx, lhs, rhs, t, llop);\n }\n \n-fn take_ty(&@block_ctxt cx, ValueRef v, ty::t t) -> result {\n+fn copy_ty(&@block_ctxt cx, ValueRef v, ty::t t) -> result {\n     if (ty::type_has_pointers(cx.fcx.lcx.ccx.tcx, t)) {\n-        ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n+        ret call_tydesc_glue(cx, v, t, abi::tydesc_field_copy_glue);\n     }\n     ret rslt(cx, C_nil());\n }\n@@ -3168,14 +3168,14 @@ fn copy_val(&@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n                    ty::type_is_bot(ccx.tcx, t)) {\n         ret rslt(cx, C_nil());\n     } else if (ty::type_is_boxed(ccx.tcx, t)) {\n-        auto r = take_ty(cx, src, t);\n+        auto r = copy_ty(cx, src, t);\n         if (action == DROP_EXISTING) {\n             r = drop_ty(r.bcx, r.bcx.build.Load(dst), t);\n         }\n         ret rslt(r.bcx, r.bcx.build.Store(src, dst));\n     } else if (ty::type_is_structural(ccx.tcx, t) ||\n                    ty::type_has_dynamic_size(ccx.tcx, t)) {\n-        auto r = take_ty(cx, src, t);\n+        auto r = copy_ty(cx, src, t);\n         if (action == DROP_EXISTING) { r = drop_ty(r.bcx, dst, t); }\n         r = memmove_ty(r.bcx, dst, src, t);\n         if (ty::type_owns_heap_mem(ccx.tcx, t)) {\n@@ -3376,7 +3376,7 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n     bcx = llvec_tydesc.bcx;\n     ti = none[@tydesc_info];\n     auto llelt_tydesc = get_tydesc(bcx, elt_ty, false, ti);\n-    lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_copy_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, ti);\n     bcx = llelt_tydesc.bcx;\n@@ -3663,7 +3663,7 @@ mod ivec {\n         rs = get_tydesc(bcx, unit_ty, false, no_tydesc_info);\n         auto unit_tydesc = rs.val;\n         bcx = rs.bcx;\n-        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_copy_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n         auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n@@ -3950,7 +3950,7 @@ mod ivec {\n     }\n \n     // NB: This does *not* adjust reference counts. The caller must have done\n-    // this via take_ty() beforehand.\n+    // this via copy_ty() beforehand.\n     fn duplicate_heap_part(&@block_ctxt cx, ValueRef orig_vptr,\n                            ty::t unit_ty) -> result {\n         // Cast to an opaque interior vector if we can't trust the pointer\n@@ -5160,9 +5160,9 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n                 if (out_arg.mode == ty::mo_val) {\n                     if (type_is_immediate(cx.ccx, e_ty)) {\n                         val = bcx.build.Load(val);\n-                        bcx = take_ty(bcx, val, e_ty).bcx;\n+                        bcx = copy_ty(bcx, val, e_ty).bcx;\n                     } else {\n-                        bcx = take_ty(bcx, val, e_ty).bcx;\n+                        bcx = copy_ty(bcx, val, e_ty).bcx;\n                         val = bcx.build.Load(val);\n                     }\n                 } else if (ty::type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n@@ -5401,7 +5401,7 @@ fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n             val = do_spill(lv.res.bcx, lv.res.val);\n         }\n     } else { auto re = trans_expr(bcx, e); val = re.val; bcx = re.bcx; }\n-    if (arg.mode == ty::mo_val) { bcx = take_ty(bcx, val, e_ty).bcx; }\n+    if (arg.mode == ty::mo_val) { bcx = copy_ty(bcx, val, e_ty).bcx; }\n     if (ty::type_is_bot(cx.fcx.lcx.ccx.tcx, e_ty)) {\n         // For values of type _|_, we generate an\n         // \"undef\" value, as such a value should never"}, {"sha": "d5c4f459f1c7eed3faea6f309342a2d1ec33f1ec", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=dfcfef41df58108ee75067afaa63bbbcf43e38f8", "patch": "@@ -212,7 +212,7 @@ struct type_desc {\n     const type_desc **first_param;\n     size_t size;\n     size_t align;\n-    glue_fn *take_glue;\n+    glue_fn *copy_glue;\n     glue_fn *drop_glue;\n     glue_fn *free_glue;\n     glue_fn *sever_glue;    // For GC."}, {"sha": "7b1ddc4c3a455d6e2641311854e3cf27af38a398", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/dfcfef41df58108ee75067afaa63bbbcf43e38f8/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=dfcfef41df58108ee75067afaa63bbbcf43e38f8", "patch": "@@ -453,13 +453,14 @@ copy_elements(rust_task *task, type_desc *elem_t,\n {\n     char *dst = (char *)pdst, *src = (char *)psrc;\n \n+    // FIXME: Copy glue doesn't work this way.\n     // increment the refcount of each element of the vector\n-    if (elem_t->take_glue) {\n-        glue_fn *take_glue = elem_t->take_glue;\n+    if (elem_t->copy_glue) {\n+        glue_fn *copy_glue = elem_t->copy_glue;\n         size_t elem_size = elem_t->size;\n         const type_desc **tydescs = elem_t->first_param;\n         for (char *p = src; p < src+n; p += elem_size) {\n-            take_glue(NULL, task, NULL, tydescs, p);\n+            copy_glue(NULL, task, NULL, tydescs, p);\n         }\n     }\n     memmove(dst, src, n);"}]}