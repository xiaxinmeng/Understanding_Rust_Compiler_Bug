{"sha": "341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MWNmNDA1ZTViZTU2YjliMWM4ZjNiZTZkMGZlOWEwMTRlZWZmMjY=", "commit": {"author": {"name": "Chase Southwood", "email": "chase.southwood@gmail.com", "date": "2014-12-13T18:36:05Z"}, "committer": {"name": "Chase Southwood", "email": "chase.southwood@gmail.com", "date": "2014-12-16T01:31:07Z"}, "message": "Use wrapper structs for `HashSet`'s iterators.\n\nUsing a type alias for iterator implementations is fragile since this\nexposes the implementation to users of the iterator, and any changes\ncould break existing code.\n\nThis commit changes the iterators of `HashSet` to use\nproper new types, rather than type aliases.  However, since it is\nfair-game to treat a type-alias as the aliased type, this is a:\n\n[breaking-change].", "tree": {"sha": "c051eed4bc7897cfc66885f272edfe90fce9fd22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c051eed4bc7897cfc66885f272edfe90fce9fd22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "html_url": "https://github.com/rust-lang/rust/commit/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26/comments", "author": {"login": "csouth3", "id": 6758080, "node_id": "MDQ6VXNlcjY3NTgwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6758080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csouth3", "html_url": "https://github.com/csouth3", "followers_url": "https://api.github.com/users/csouth3/followers", "following_url": "https://api.github.com/users/csouth3/following{/other_user}", "gists_url": "https://api.github.com/users/csouth3/gists{/gist_id}", "starred_url": "https://api.github.com/users/csouth3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csouth3/subscriptions", "organizations_url": "https://api.github.com/users/csouth3/orgs", "repos_url": "https://api.github.com/users/csouth3/repos", "events_url": "https://api.github.com/users/csouth3/events{/privacy}", "received_events_url": "https://api.github.com/users/csouth3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csouth3", "id": 6758080, "node_id": "MDQ6VXNlcjY3NTgwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6758080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csouth3", "html_url": "https://github.com/csouth3", "followers_url": "https://api.github.com/users/csouth3/followers", "following_url": "https://api.github.com/users/csouth3/following{/other_user}", "gists_url": "https://api.github.com/users/csouth3/gists{/gist_id}", "starred_url": "https://api.github.com/users/csouth3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csouth3/subscriptions", "organizations_url": "https://api.github.com/users/csouth3/orgs", "repos_url": "https://api.github.com/users/csouth3/repos", "events_url": "https://api.github.com/users/csouth3/events{/privacy}", "received_events_url": "https://api.github.com/users/csouth3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85fe141fb7c066e88a6872e74347c5f34d0223a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/85fe141fb7c066e88a6872e74347c5f34d0223a7", "html_url": "https://github.com/rust-lang/rust/commit/85fe141fb7c066e88a6872e74347c5f34d0223a7"}], "stats": {"total": 79, "additions": 59, "deletions": 20}, "files": [{"sha": "865d8840c526625de55233cf79abe88e745d0c50", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 59, "deletions": 20, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/341cf405e5be56b9b1c8f3be6d0fe9a014eeff26/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=341cf405e5be56b9b1c8f3be6d0fe9a014eeff26", "patch": "@@ -17,8 +17,7 @@ use default::Default;\n use fmt::Show;\n use fmt;\n use hash::{Hash, Hasher, RandomSipHasher};\n-use iter::{Iterator, IteratorExt, FromIterator, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n-use iter;\n+use iter::{Iterator, IteratorExt, FromIterator, Map, FilterMap, Chain, Repeat, Zip, Extend, repeat};\n use option::Option::{Some, None, mod};\n use result::Result::{Ok, Err};\n \n@@ -252,7 +251,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n-        self.map.keys()\n+        SetItems { iter: self.map.keys() }\n     }\n \n     /// Creates a consuming iterator, that is, one that moves each value out\n@@ -279,7 +278,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     pub fn into_iter(self) -> SetMoveItems<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }\n \n-        self.map.into_iter().map(first)\n+        SetMoveItems { iter: self.map.into_iter().map(first) }\n     }\n \n     /// Visit the values representing the difference.\n@@ -312,7 +311,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             if !other.contains(elt) { Some(elt) } else { None }\n         }\n \n-        repeat(other).zip(self.iter()).filter_map(filter)\n+        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the symmetric difference.\n@@ -337,8 +336,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n-        self.difference(other).chain(other.difference(self))\n+        -> SymDifferenceItems<'a, T, H> {\n+        SymDifferenceItems { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n     /// Visit the values representing the intersection.\n@@ -366,7 +365,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n             if other.contains(elt) { Some(elt) } else { None }\n         }\n \n-        repeat(other).zip(self.iter()).filter_map(filter)\n+        SetAlgebraItems { iter: repeat(other).zip(self.iter()).filter_map(filter) }\n     }\n \n     /// Visit the values representing the union.\n@@ -387,9 +386,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n-        self.iter().chain(other.difference(self))\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> UnionItems<'a, T, H> {\n+        UnionItems { iter: self.iter().chain(other.difference(self)) }\n     }\n \n     /// Return the number of elements in the set\n@@ -617,20 +615,61 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n }\n \n /// HashSet iterator\n-pub type SetItems<'a, K> = Keys<'a, K, ()>;\n+pub struct SetItems<'a, K: 'a> {\n+    iter: Keys<'a, K, ()>\n+}\n \n /// HashSet move iterator\n-pub type SetMoveItems<K> = iter::Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>;\n+pub struct SetMoveItems<K> {\n+    iter: Map<(K, ()), K, MoveEntries<K, ()>, fn((K, ())) -> K>\n+}\n \n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n-/// Set operations iterator\n-pub type SetAlgebraItems<'a, T, H> = FilterMap<\n-    (&'a HashSet<T, H>, &'a T),\n-    &'a T,\n-    Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n-    for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n->;\n+/// Set operations iterator, used directly for intersection and difference\n+pub struct SetAlgebraItems<'a, T: 'a, H: 'a> {\n+    iter: FilterMap<\n+        (&'a HashSet<T, H>, &'a T),\n+        &'a T,\n+        Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>,\n+        for<'b> fn((&HashSet<T, H>, &'b T)) -> Option<&'b T>,\n+    >\n+}\n+\n+/// Symmetric difference iterator.\n+pub struct SymDifferenceItems<'a, T: 'a, H: 'a> {\n+    iter: Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>>\n+}\n+\n+/// Set union iterator.\n+pub struct UnionItems<'a, T: 'a, H: 'a> {\n+    iter: Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>>\n+}\n+\n+impl<'a, K> Iterator<&'a K> for SetItems<'a, K> {\n+    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<K> Iterator<K> for SetMoveItems<K> {\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for SetAlgebraItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for SymDifferenceItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<'a, T, H> Iterator<&'a T> for UnionItems<'a, T, H> {\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n \n #[cfg(test)]\n mod test_set {"}]}