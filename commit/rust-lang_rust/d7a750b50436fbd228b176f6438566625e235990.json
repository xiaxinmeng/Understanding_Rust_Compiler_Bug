{"sha": "d7a750b50436fbd228b176f6438566625e235990", "node_id": "C_kwDOAAsO6NoAKGQ3YTc1MGI1MDQzNmZiZDIyOGIxNzZmNjQzODU2NjYyNWUyMzU5OTA", "commit": {"author": {"name": "Michael Benfield", "email": "mbenfield@google.com", "date": "2022-03-08T19:07:01Z"}, "committer": {"name": "Michael Benfield", "email": "mbenfield@google.com", "date": "2022-09-07T20:12:45Z"}, "message": "Use niche-filling optimization even when multiple variants have data.\n\nFixes #46213", "tree": {"sha": "4fc710101a6ad49617739201ebb72660e54b2e43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fc710101a6ad49617739201ebb72660e54b2e43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7a750b50436fbd228b176f6438566625e235990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a750b50436fbd228b176f6438566625e235990", "html_url": "https://github.com/rust-lang/rust/commit/d7a750b50436fbd228b176f6438566625e235990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7a750b50436fbd228b176f6438566625e235990/comments", "author": {"login": "mikebenfield", "id": 543755, "node_id": "MDQ6VXNlcjU0Mzc1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/543755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikebenfield", "html_url": "https://github.com/mikebenfield", "followers_url": "https://api.github.com/users/mikebenfield/followers", "following_url": "https://api.github.com/users/mikebenfield/following{/other_user}", "gists_url": "https://api.github.com/users/mikebenfield/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikebenfield/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikebenfield/subscriptions", "organizations_url": "https://api.github.com/users/mikebenfield/orgs", "repos_url": "https://api.github.com/users/mikebenfield/repos", "events_url": "https://api.github.com/users/mikebenfield/events{/privacy}", "received_events_url": "https://api.github.com/users/mikebenfield/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikebenfield", "id": 543755, "node_id": "MDQ6VXNlcjU0Mzc1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/543755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikebenfield", "html_url": "https://github.com/mikebenfield", "followers_url": "https://api.github.com/users/mikebenfield/followers", "following_url": "https://api.github.com/users/mikebenfield/following{/other_user}", "gists_url": "https://api.github.com/users/mikebenfield/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikebenfield/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikebenfield/subscriptions", "organizations_url": "https://api.github.com/users/mikebenfield/orgs", "repos_url": "https://api.github.com/users/mikebenfield/repos", "events_url": "https://api.github.com/users/mikebenfield/events{/privacy}", "received_events_url": "https://api.github.com/users/mikebenfield/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a08b96a0bb7c170130144214787b4a46aa5eb17", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a08b96a0bb7c170130144214787b4a46aa5eb17", "html_url": "https://github.com/rust-lang/rust/commit/1a08b96a0bb7c170130144214787b4a46aa5eb17"}], "stats": {"total": 498, "additions": 339, "deletions": 159}, "files": [{"sha": "e38572f609b3178828dd61af42f8c184a57783bc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -3075,7 +3075,8 @@ mod size_asserts {\n     static_assert_size!(Block, 48);\n     static_assert_size!(Expr, 104);\n     static_assert_size!(ExprKind, 72);\n-    static_assert_size!(Fn, 192);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Fn, 184);\n     static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n     static_assert_size!(GenericArg, 24);"}, {"sha": "ba041810bd19e8d71a593f1d82d719c5b5476921", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -780,13 +780,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(bootstrap)))]\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(Immediate, 56);\n-    static_assert_size!(ImmTy<'_>, 72);\n-    static_assert_size!(Operand, 64);\n-    static_assert_size!(OpTy<'_>, 88);\n+    static_assert_size!(Immediate, 48);\n+    static_assert_size!(ImmTy<'_>, 64);\n+    static_assert_size!(Operand, 56);\n+    static_assert_size!(OpTy<'_>, 80);\n }"}, {"sha": "b328892906df22217f8b2afcb39c160766f2bc74", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -890,6 +890,8 @@ mod size_asserts {\n     static_assert_size!(MemPlaceMeta, 24);\n     static_assert_size!(MemPlace, 40);\n     static_assert_size!(MPlaceTy<'_>, 64);\n-    static_assert_size!(Place, 48);\n-    static_assert_size!(PlaceTy<'_>, 72);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Place, 40);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(PlaceTy<'_>, 64);\n }"}, {"sha": "e351b650a16c1a8c7c6829e01dbc326a0ed8d13e", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -117,6 +117,10 @@ pub trait ObligationProcessor {\n }\n \n /// The result type used by `process_obligation`.\n+// `repr(C)` to inhibit the niche filling optimization. Otherwise, the `match` appearing\n+// in `process_obligations` is significantly slower, which can substantially affect\n+// benchmarks like `rustc-perf`'s inflate and keccak.\n+#[repr(C)]\n #[derive(Debug)]\n pub enum ProcessResult<O, E> {\n     Unchanged,"}, {"sha": "513225e1606452e73cb63c6fe1296e4673007994", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -69,8 +69,8 @@ pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n // (See also the comment on `DiagnosticBuilder`'s `diagnostic` field.)\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, ()>, 16);\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(PResult<'_, bool>, 24);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(bootstrap)))]\n+rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {"}, {"sha": "a668c0e95ce4b1f328a625a3d6762749909093ba", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -3473,12 +3473,15 @@ mod size_asserts {\n     static_assert_size!(FnDecl<'_>, 40);\n     static_assert_size!(ForeignItem<'_>, 72);\n     static_assert_size!(ForeignItemKind<'_>, 40);\n-    static_assert_size!(GenericArg<'_>, 40);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(GenericArg<'_>, 32);\n     static_assert_size!(GenericBound<'_>, 48);\n     static_assert_size!(Generics<'_>, 56);\n     static_assert_size!(Impl<'_>, 80);\n-    static_assert_size!(ImplItem<'_>, 88);\n-    static_assert_size!(ImplItemKind<'_>, 40);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(ImplItem<'_>, 80);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(ImplItemKind<'_>, 32);\n     static_assert_size!(Item<'_>, 80);\n     static_assert_size!(ItemKind<'_>, 48);\n     static_assert_size!(Local<'_>, 64);\n@@ -3490,8 +3493,10 @@ mod size_asserts {\n     static_assert_size!(QPath<'_>, 24);\n     static_assert_size!(Stmt<'_>, 32);\n     static_assert_size!(StmtKind<'_>, 16);\n-    static_assert_size!(TraitItem<'_>, 96);\n-    static_assert_size!(TraitItemKind<'_>, 56);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(TraitItem<'static>, 88);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(TraitItemKind<'_>, 48);\n     static_assert_size!(Ty<'_>, 72);\n     static_assert_size!(TyKind<'_>, 56);\n }"}, {"sha": "e149535bec7b56e13e66304a05f9c901d2163a19", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -1231,7 +1231,8 @@ pub enum BinOp {\n mod size_asserts {\n     use super::*;\n     // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(AggregateKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(AggregateKind<'_>, 40);\n     static_assert_size!(Operand<'_>, 24);\n     static_assert_size!(Place<'_>, 16);\n     static_assert_size!(PlaceElem<'_>, 24);"}, {"sha": "c50f8b0eebe1a03686430d45872cdb63999b20b6", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -825,8 +825,12 @@ mod size_asserts {\n     static_assert_size!(Block, 56);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 40);\n-    static_assert_size!(Pat<'_>, 72);\n-    static_assert_size!(PatKind<'_>, 56);\n-    static_assert_size!(Stmt<'_>, 56);\n-    static_assert_size!(StmtKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Pat<'_>, 64);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(PatKind<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(Stmt<'_>, 48);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(StmtKind<'_>, 40);\n }"}, {"sha": "abb7ddd88b14db57bdfa0828ba3732cbba1147e7", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 198, "deletions": 116, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -22,7 +22,7 @@ use rustc_target::abi::call::{\n use rustc_target::abi::*;\n use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy, Target};\n \n-use std::cmp;\n+use std::cmp::{self, Ordering};\n use std::fmt;\n use std::iter;\n use std::num::NonZeroUsize;\n@@ -1046,131 +1046,191 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 // that allow representation optimization.)\n                 assert!(def.is_enum());\n \n-                // The current code for niche-filling relies on variant indices\n-                // instead of actual discriminants, so untagged enums with\n-                // explicit discriminants (RFC #2363) would misbehave.\n-                let no_explicit_discriminants = def\n-                    .variants()\n-                    .iter_enumerated()\n-                    .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i.as_u32()));\n-\n-                let mut niche_filling_layout = None;\n-\n-                // Niche-filling enum optimization.\n-                if !def.repr().inhibit_enum_layout_opt() && no_explicit_discriminants {\n-                    let mut untagged_variant = None;\n-                    let mut niche_variants = VariantIdx::MAX..=VariantIdx::new(0);\n+                // Until we've decided whether to use the tagged or\n+                // niche filling LayoutS, we don't want to intern the\n+                // variant layouts, so we can't store them in the\n+                // overall LayoutS. Store the overall LayoutS\n+                // and the variant LayoutSs here until then.\n+                struct TmpLayout<'tcx> {\n+                    layout: LayoutS<'tcx>,\n+                    variants: IndexVec<VariantIdx, LayoutS<'tcx>>,\n+                }\n \n-                    // Find one non-ZST variant.\n-                    'variants: for (v, fields) in variants.iter_enumerated() {\n-                        if absent(fields) {\n-                            continue 'variants;\n+                let calculate_niche_filling_layout =\n+                    || -> Result<Option<TmpLayout<'tcx>>, LayoutError<'tcx>> {\n+                        // The current code for niche-filling relies on variant indices\n+                        // instead of actual discriminants, so enums with\n+                        // explicit discriminants (RFC #2363) would misbehave.\n+                        if def.repr().inhibit_enum_layout_opt()\n+                            || def\n+                                .variants()\n+                                .iter_enumerated()\n+                                .any(|(i, v)| v.discr != ty::VariantDiscr::Relative(i.as_u32()))\n+                        {\n+                            return Ok(None);\n                         }\n-                        for f in fields {\n-                            if !f.is_zst() {\n-                                if untagged_variant.is_none() {\n-                                    untagged_variant = Some(v);\n-                                    continue 'variants;\n-                                } else {\n-                                    untagged_variant = None;\n-                                    break 'variants;\n-                                }\n-                            }\n+\n+                        if variants.len() < 2 {\n+                            return Ok(None);\n                         }\n-                        niche_variants = *niche_variants.start().min(&v)..=v;\n-                    }\n \n-                    if niche_variants.start() > niche_variants.end() {\n-                        untagged_variant = None;\n-                    }\n+                        let mut align = dl.aggregate_align;\n+                        let mut variant_layouts = variants\n+                            .iter_enumerated()\n+                            .map(|(j, v)| {\n+                                let mut st = self.univariant_uninterned(\n+                                    ty,\n+                                    v,\n+                                    &def.repr(),\n+                                    StructKind::AlwaysSized,\n+                                )?;\n+                                st.variants = Variants::Single { index: j };\n+\n+                                align = align.max(st.align);\n+\n+                                Ok(st)\n+                            })\n+                            .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+\n+                        let largest_variant_index = match variant_layouts\n+                            .iter_enumerated()\n+                            .max_by_key(|(_i, layout)| layout.size.bytes())\n+                            .map(|(i, _layout)| i)\n+                        {\n+                            None => return Ok(None),\n+                            Some(i) => i,\n+                        };\n \n-                    if let Some(i) = untagged_variant {\n-                        let count = (niche_variants.end().as_u32()\n-                            - niche_variants.start().as_u32()\n-                            + 1) as u128;\n+                        let all_indices = VariantIdx::new(0)..=VariantIdx::new(variants.len() - 1);\n+                        let needs_disc = |index: VariantIdx| {\n+                            index != largest_variant_index && !absent(&variants[index])\n+                        };\n+                        let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap()\n+                            ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap();\n+\n+                        let count = niche_variants.size_hint().1.unwrap() as u128;\n \n                         // Find the field with the largest niche\n-                        let niche_candidate = variants[i]\n+                        let (field_index, niche, (niche_start, niche_scalar)) = match variants\n+                            [largest_variant_index]\n                             .iter()\n                             .enumerate()\n                             .filter_map(|(j, field)| Some((j, field.largest_niche?)))\n-                            .max_by_key(|(_, niche)| niche.available(dl));\n-\n-                        if let Some((field_index, niche, (niche_start, niche_scalar))) =\n-                            niche_candidate.and_then(|(field_index, niche)| {\n-                                Some((field_index, niche, niche.reserve(self, count)?))\n-                            })\n+                            .max_by_key(|(_, niche)| niche.available(dl))\n+                            .and_then(|(j, niche)| Some((j, niche, niche.reserve(self, count)?)))\n                         {\n-                            let mut align = dl.aggregate_align;\n-                            let st = variants\n-                                .iter_enumerated()\n-                                .map(|(j, v)| {\n-                                    let mut st = self.univariant_uninterned(\n-                                        ty,\n-                                        v,\n-                                        &def.repr(),\n-                                        StructKind::AlwaysSized,\n-                                    )?;\n-                                    st.variants = Variants::Single { index: j };\n+                            None => return Ok(None),\n+                            Some(x) => x,\n+                        };\n \n-                                    align = align.max(st.align);\n+                        let niche_offset = niche.offset\n+                            + variant_layouts[largest_variant_index].fields.offset(field_index);\n+                        let niche_size = niche.value.size(dl);\n+                        let size = variant_layouts[largest_variant_index].size.align_to(align.abi);\n \n-                                    Ok(tcx.intern_layout(st))\n-                                })\n-                                .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n+                        let all_variants_fit =\n+                            variant_layouts.iter_enumerated_mut().all(|(i, layout)| {\n+                                if i == largest_variant_index {\n+                                    return true;\n+                                }\n \n-                            let offset = st[i].fields().offset(field_index) + niche.offset;\n+                                layout.largest_niche = None;\n \n-                            // Align the total size to the largest alignment.\n-                            let size = st[i].size().align_to(align.abi);\n+                                if layout.size <= niche_offset {\n+                                    // This variant will fit before the niche.\n+                                    return true;\n+                                }\n \n-                            let abi = if st.iter().all(|v| v.abi().is_uninhabited()) {\n-                                Abi::Uninhabited\n-                            } else if align == st[i].align() && size == st[i].size() {\n-                                // When the total alignment and size match, we can use the\n-                                // same ABI as the scalar variant with the reserved niche.\n-                                match st[i].abi() {\n-                                    Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n-                                    Abi::ScalarPair(first, second) => {\n-                                        // Only the niche is guaranteed to be initialised,\n-                                        // so use union layout for the other primitive.\n-                                        if offset.bytes() == 0 {\n-                                            Abi::ScalarPair(niche_scalar, second.to_union())\n-                                        } else {\n-                                            Abi::ScalarPair(first.to_union(), niche_scalar)\n+                                // Determine if it'll fit after the niche.\n+                                let this_align = layout.align.abi;\n+                                let this_offset = (niche_offset + niche_size).align_to(this_align);\n+\n+                                if this_offset + layout.size > size {\n+                                    return false;\n+                                }\n+\n+                                // It'll fit, but we need to make some adjustments.\n+                                match layout.fields {\n+                                    FieldsShape::Arbitrary { ref mut offsets, .. } => {\n+                                        for (j, offset) in offsets.iter_mut().enumerate() {\n+                                            if !variants[i][j].is_zst() {\n+                                                *offset += this_offset;\n+                                            }\n                                         }\n                                     }\n-                                    _ => Abi::Aggregate { sized: true },\n+                                    _ => {\n+                                        panic!(\"Layout of fields should be Arbitrary for variants\")\n+                                    }\n                                 }\n-                            } else {\n-                                Abi::Aggregate { sized: true }\n-                            };\n \n-                            let largest_niche = Niche::from_scalar(dl, offset, niche_scalar);\n-\n-                            niche_filling_layout = Some(LayoutS {\n-                                variants: Variants::Multiple {\n-                                    tag: niche_scalar,\n-                                    tag_encoding: TagEncoding::Niche {\n-                                        untagged_variant: i,\n-                                        niche_variants,\n-                                        niche_start,\n-                                    },\n-                                    tag_field: 0,\n-                                    variants: st,\n-                                },\n-                                fields: FieldsShape::Arbitrary {\n-                                    offsets: vec![offset],\n-                                    memory_index: vec![0],\n-                                },\n-                                abi,\n-                                largest_niche,\n-                                size,\n-                                align,\n+                                // It can't be a Scalar or ScalarPair because the offset isn't 0.\n+                                if !layout.abi.is_uninhabited() {\n+                                    layout.abi = Abi::Aggregate { sized: true };\n+                                }\n+                                layout.size += this_offset;\n+\n+                                true\n                             });\n+\n+                        if !all_variants_fit {\n+                            return Ok(None);\n                         }\n-                    }\n-                }\n+\n+                        let largest_niche = Niche::from_scalar(dl, niche_offset, niche_scalar);\n+\n+                        let others_zst = variant_layouts.iter_enumerated().all(|(i, layout)| {\n+                            i == largest_variant_index || layout.size == Size::ZERO\n+                        });\n+                        let same_size = size == variant_layouts[largest_variant_index].size;\n+                        let same_align = align == variant_layouts[largest_variant_index].align;\n+\n+                        let abi = if variant_layouts.iter().all(|v| v.abi.is_uninhabited()) {\n+                            Abi::Uninhabited\n+                        } else if same_size && same_align && others_zst {\n+                            match variant_layouts[largest_variant_index].abi {\n+                                // When the total alignment and size match, we can use the\n+                                // same ABI as the scalar variant with the reserved niche.\n+                                Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n+                                Abi::ScalarPair(first, second) => {\n+                                    // Only the niche is guaranteed to be initialised,\n+                                    // so use union layouts for the other primitive.\n+                                    if niche_offset == Size::ZERO {\n+                                        Abi::ScalarPair(niche_scalar, second.to_union())\n+                                    } else {\n+                                        Abi::ScalarPair(first.to_union(), niche_scalar)\n+                                    }\n+                                }\n+                                _ => Abi::Aggregate { sized: true },\n+                            }\n+                        } else {\n+                            Abi::Aggregate { sized: true }\n+                        };\n+\n+                        let layout = LayoutS {\n+                            variants: Variants::Multiple {\n+                                tag: niche_scalar,\n+                                tag_encoding: TagEncoding::Niche {\n+                                    untagged_variant: largest_variant_index,\n+                                    niche_variants,\n+                                    niche_start,\n+                                },\n+                                tag_field: 0,\n+                                variants: IndexVec::new(),\n+                            },\n+                            fields: FieldsShape::Arbitrary {\n+                                offsets: vec![niche_offset],\n+                                memory_index: vec![0],\n+                            },\n+                            abi,\n+                            largest_niche,\n+                            size,\n+                            align,\n+                        };\n+\n+                        Ok(Some(TmpLayout { layout, variants: variant_layouts }))\n+                    };\n+\n+                let niche_filling_layout = calculate_niche_filling_layout()?;\n \n                 let (mut min, mut max) = (i128::MAX, i128::MIN);\n                 let discr_type = def.repr().discr_type();\n@@ -1425,15 +1485,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n \n                 let largest_niche = Niche::from_scalar(dl, Size::ZERO, tag);\n \n-                let layout_variants =\n-                    layout_variants.into_iter().map(|v| tcx.intern_layout(v)).collect();\n-\n                 let tagged_layout = LayoutS {\n                     variants: Variants::Multiple {\n                         tag,\n                         tag_encoding: TagEncoding::Direct,\n                         tag_field: 0,\n-                        variants: layout_variants,\n+                        variants: IndexVec::new(),\n                     },\n                     fields: FieldsShape::Arbitrary {\n                         offsets: vec![Size::ZERO],\n@@ -1445,20 +1502,45 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     size,\n                 };\n \n-                let best_layout = match (tagged_layout, niche_filling_layout) {\n-                    (tagged_layout, Some(niche_filling_layout)) => {\n+                let tagged_layout = TmpLayout { layout: tagged_layout, variants: layout_variants };\n+\n+                let mut best_layout = match (tagged_layout, niche_filling_layout) {\n+                    (tl, Some(nl)) => {\n                         // Pick the smaller layout; otherwise,\n                         // pick the layout with the larger niche; otherwise,\n                         // pick tagged as it has simpler codegen.\n-                        cmp::min_by_key(tagged_layout, niche_filling_layout, |layout| {\n-                            let niche_size = layout.largest_niche.map_or(0, |n| n.available(dl));\n-                            (layout.size, cmp::Reverse(niche_size))\n-                        })\n+                        use Ordering::*;\n+                        let niche_size = |tmp_l: &TmpLayout<'_>| {\n+                            tmp_l.layout.largest_niche.map_or(0, |n| n.available(dl))\n+                        };\n+                        match (\n+                            tl.layout.size.cmp(&nl.layout.size),\n+                            niche_size(&tl).cmp(&niche_size(&nl)),\n+                        ) {\n+                            (Greater, _) => nl,\n+                            (Equal, Less) => nl,\n+                            _ => tl,\n+                        }\n                     }\n-                    (tagged_layout, None) => tagged_layout,\n+                    (tl, None) => tl,\n+                };\n+\n+                // Now we can intern the variant layouts and store them in the enum layout.\n+                best_layout.layout.variants = match best_layout.layout.variants {\n+                    Variants::Multiple { tag, tag_encoding, tag_field, .. } => Variants::Multiple {\n+                        tag,\n+                        tag_encoding,\n+                        tag_field,\n+                        variants: best_layout\n+                            .variants\n+                            .into_iter()\n+                            .map(|layout| tcx.intern_layout(layout))\n+                            .collect(),\n+                    },\n+                    _ => bug!(),\n                 };\n \n-                tcx.intern_layout(best_layout)\n+                tcx.intern_layout(best_layout.layout)\n             }\n \n             // Types with no meaningful known layout."}, {"sha": "2077cf71b2ef72924b414513a1a28d22e2aebc66", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -2532,7 +2532,8 @@ mod size_asserts {\n     // These are in alphabetical order, which is easy to maintain.\n     static_assert_size!(Crate, 72); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n-    static_assert_size!(GenericArg, 64);\n+    #[cfg(not(bootstrap))]\n+    static_assert_size!(GenericArg, 56);\n     static_assert_size!(GenericArgs, 32);\n     static_assert_size!(GenericParamDef, 56);\n     static_assert_size!(Item, 56);"}, {"sha": "5102574d4be3ece384bfef2a5e2ec50172e9d5ff", "filename": "src/test/ui/stats/hir-stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -1,6 +1,7 @@\n // check-pass\n // compile-flags: -Zhir-stats\n // only-x86_64\n+// ignore-stage1\n \n // The aim here is to include at least one of every different type of top-level\n // AST/HIR node reported by `-Zhir-stats`."}, {"sha": "c8ceb6ff22df24a731d4ee4f7d5e7df3361197c1", "filename": "src/test/ui/stats/hir-stats.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstats%2Fhir-stats.stderr?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -21,39 +21,39 @@ ast-stats-1 - MacCall                   32 ( 0.4%)             1\n ast-stats-1 - Expr                      96 ( 1.1%)             3\n ast-stats-1 Param                    160 ( 1.9%)             4            40\n ast-stats-1 FnDecl                   200 ( 2.4%)             5            40\n-ast-stats-1 Variant                  240 ( 2.8%)             2           120\n+ast-stats-1 Variant                  240 ( 2.9%)             2           120\n ast-stats-1 Block                    288 ( 3.4%)             6            48\n ast-stats-1 GenericBound             352 ( 4.2%)             4            88\n ast-stats-1 - Trait                    352 ( 4.2%)             4\n ast-stats-1 AssocItem                416 ( 4.9%)             4           104\n ast-stats-1 - TyAlias                  208 ( 2.5%)             2\n ast-stats-1 - Fn                       208 ( 2.5%)             2\n-ast-stats-1 GenericParam             520 ( 6.1%)             5           104\n-ast-stats-1 PathSegment              720 ( 8.5%)            30            24\n-ast-stats-1 Expr                     832 ( 9.8%)             8           104\n+ast-stats-1 GenericParam             480 ( 5.7%)             5            96\n+ast-stats-1 PathSegment              720 ( 8.6%)            30            24\n+ast-stats-1 Expr                     832 ( 9.9%)             8           104\n ast-stats-1 - Path                     104 ( 1.2%)             1\n ast-stats-1 - Match                    104 ( 1.2%)             1\n ast-stats-1 - Struct                   104 ( 1.2%)             1\n ast-stats-1 - Lit                      208 ( 2.5%)             2\n ast-stats-1 - Block                    312 ( 3.7%)             3\n-ast-stats-1 Pat                      840 ( 9.9%)             7           120\n+ast-stats-1 Pat                      840 (10.0%)             7           120\n ast-stats-1 - Struct                   120 ( 1.4%)             1\n ast-stats-1 - Wild                     120 ( 1.4%)             1\n ast-stats-1 - Ident                    600 ( 7.1%)             5\n-ast-stats-1 Ty                     1_344 (15.9%)            14            96\n+ast-stats-1 Ty                     1_344 (16.0%)            14            96\n ast-stats-1 - Rptr                      96 ( 1.1%)             1\n ast-stats-1 - Ptr                       96 ( 1.1%)             1\n ast-stats-1 - ImplicitSelf             192 ( 2.3%)             2\n ast-stats-1 - Path                     960 (11.4%)            10\n-ast-stats-1 Item                   1_656 (19.6%)             9           184\n+ast-stats-1 Item                   1_656 (19.7%)             9           184\n ast-stats-1 - Trait                    184 ( 2.2%)             1\n ast-stats-1 - Enum                     184 ( 2.2%)             1\n ast-stats-1 - ForeignMod               184 ( 2.2%)             1\n ast-stats-1 - Impl                     184 ( 2.2%)             1\n ast-stats-1 - Fn                       368 ( 4.4%)             2\n-ast-stats-1 - Use                      552 ( 6.5%)             3\n+ast-stats-1 - Use                      552 ( 6.6%)             3\n ast-stats-1 ----------------------------------------------------------------\n-ast-stats-1 Total                  8_456\n+ast-stats-1 Total                  8_416\n ast-stats-1\n ast-stats-2 POST EXPANSION AST STATS\n ast-stats-2 Name                Accumulated Size         Count     Item Size\n@@ -86,25 +86,25 @@ ast-stats-2 - Trait                    352 ( 3.8%)             4\n ast-stats-2 AssocItem                416 ( 4.5%)             4           104\n ast-stats-2 - TyAlias                  208 ( 2.3%)             2\n ast-stats-2 - Fn                       208 ( 2.3%)             2\n-ast-stats-2 GenericParam             520 ( 5.7%)             5           104\n-ast-stats-2 PathSegment              792 ( 8.6%)            33            24\n-ast-stats-2 Pat                      840 ( 9.1%)             7           120\n+ast-stats-2 GenericParam             480 ( 5.2%)             5            96\n+ast-stats-2 PathSegment              792 ( 8.7%)            33            24\n+ast-stats-2 Pat                      840 ( 9.2%)             7           120\n ast-stats-2 - Struct                   120 ( 1.3%)             1\n ast-stats-2 - Wild                     120 ( 1.3%)             1\n-ast-stats-2 - Ident                    600 ( 6.5%)             5\n+ast-stats-2 - Ident                    600 ( 6.6%)             5\n ast-stats-2 Expr                     936 (10.2%)             9           104\n ast-stats-2 - Path                     104 ( 1.1%)             1\n ast-stats-2 - Match                    104 ( 1.1%)             1\n ast-stats-2 - Struct                   104 ( 1.1%)             1\n ast-stats-2 - InlineAsm                104 ( 1.1%)             1\n ast-stats-2 - Lit                      208 ( 2.3%)             2\n ast-stats-2 - Block                    312 ( 3.4%)             3\n-ast-stats-2 Ty                     1_344 (14.6%)            14            96\n+ast-stats-2 Ty                     1_344 (14.7%)            14            96\n ast-stats-2 - Rptr                      96 ( 1.0%)             1\n ast-stats-2 - Ptr                       96 ( 1.0%)             1\n ast-stats-2 - ImplicitSelf             192 ( 2.1%)             2\n ast-stats-2 - Path                     960 (10.5%)            10\n-ast-stats-2 Item                   2_024 (22.0%)            11           184\n+ast-stats-2 Item                   2_024 (22.1%)            11           184\n ast-stats-2 - Trait                    184 ( 2.0%)             1\n ast-stats-2 - Enum                     184 ( 2.0%)             1\n ast-stats-2 - ExternCrate              184 ( 2.0%)             1\n@@ -113,15 +113,15 @@ ast-stats-2 - Impl                     184 ( 2.0%)             1\n ast-stats-2 - Fn                       368 ( 4.0%)             2\n ast-stats-2 - Use                      736 ( 8.0%)             4\n ast-stats-2 ----------------------------------------------------------------\n-ast-stats-2 Total                  9_184\n+ast-stats-2 Total                  9_144\n ast-stats-2\n hir-stats HIR STATS\n hir-stats Name                Accumulated Size         Count     Item Size\n hir-stats ----------------------------------------------------------------\n hir-stats ForeignItemRef            24 ( 0.2%)             1            24\n hir-stats Mod                       32 ( 0.3%)             1            32\n hir-stats ExprField                 40 ( 0.4%)             1            40\n-hir-stats TraitItemRef              56 ( 0.5%)             2            28\n+hir-stats TraitItemRef              56 ( 0.6%)             2            28\n hir-stats Param                     64 ( 0.6%)             2            32\n hir-stats Local                     64 ( 0.6%)             1            64\n hir-stats InlineAsm                 72 ( 0.7%)             1            72\n@@ -135,11 +135,11 @@ hir-stats - Semi                      32 ( 0.3%)             1\n hir-stats - Expr                      32 ( 0.3%)             1\n hir-stats FnDecl                   120 ( 1.2%)             3            40\n hir-stats Attribute                128 ( 1.3%)             4            32\n+hir-stats GenericArg               128 ( 1.3%)             4            32\n+hir-stats - Type                      32 ( 0.3%)             1\n+hir-stats - Lifetime                  96 ( 0.9%)             3\n hir-stats GenericArgs              144 ( 1.4%)             3            48\n hir-stats Variant                  160 ( 1.6%)             2            80\n-hir-stats GenericArg               160 ( 1.6%)             4            40\n-hir-stats - Type                      40 ( 0.4%)             1\n-hir-stats - Lifetime                 120 ( 1.2%)             3\n hir-stats GenericBound             192 ( 1.9%)             4            48\n hir-stats - Trait                    192 ( 1.9%)             4\n hir-stats WherePredicate           216 ( 2.1%)             3            72\n@@ -151,7 +151,7 @@ hir-stats - Wild                      88 ( 0.9%)             1\n hir-stats - Struct                    88 ( 0.9%)             1\n hir-stats - Binding                  264 ( 2.6%)             3\n hir-stats Generics                 560 ( 5.5%)            10            56\n-hir-stats Expr                     768 ( 7.5%)            12            64\n+hir-stats Expr                     768 ( 7.6%)            12            64\n hir-stats - Path                      64 ( 0.6%)             1\n hir-stats - Struct                    64 ( 0.6%)             1\n hir-stats - Match                     64 ( 0.6%)             1\n@@ -173,5 +173,5 @@ hir-stats - Path                     936 ( 9.2%)            13\n hir-stats Path                   1_536 (15.1%)            32            48\n hir-stats PathSegment            2_240 (22.0%)            40            56\n hir-stats ----------------------------------------------------------------\n-hir-stats Total                 10_200\n+hir-stats Total                 10_168\n hir-stats"}, {"sha": "7a23f13630a43fabcfdbea1251b182fce6a890f7", "filename": "src/test/ui/structs-enums/type-sizes.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d7a750b50436fbd228b176f6438566625e235990/src%2Ftest%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7a750b50436fbd228b176f6438566625e235990/src%2Ftest%2Fui%2Fstructs-enums%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Ftype-sizes.rs?ref=d7a750b50436fbd228b176f6438566625e235990", "patch": "@@ -120,6 +120,54 @@ pub enum AlwaysTaggedBecauseItHasNoNiche {\n     B\n }\n \n+pub enum NicheFilledMultipleFields {\n+    A(bool, u8),\n+    B(u8),\n+    C(u8),\n+    D(bool),\n+    E,\n+    F,\n+    G,\n+}\n+\n+struct BoolInTheMiddle(std::num::NonZeroU16, bool, u8);\n+\n+enum NicheWithData {\n+    A,\n+    B([u16; 5]),\n+    Largest { a1: u32, a2: BoolInTheMiddle, a3: u32 },\n+    C,\n+    D(u32, u32),\n+}\n+\n+// A type with almost 2^16 invalid values.\n+#[repr(u16)]\n+pub enum NicheU16 {\n+    _0,\n+}\n+\n+pub enum EnumManyVariant<X> {\n+    Dataful(u8, X),\n+\n+    // 0x100 niche variants.\n+    _00, _01, _02, _03, _04, _05, _06, _07, _08, _09, _0A, _0B, _0C, _0D, _0E, _0F,\n+    _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _1A, _1B, _1C, _1D, _1E, _1F,\n+    _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _2A, _2B, _2C, _2D, _2E, _2F,\n+    _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _3A, _3B, _3C, _3D, _3E, _3F,\n+    _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _4A, _4B, _4C, _4D, _4E, _4F,\n+    _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _5A, _5B, _5C, _5D, _5E, _5F,\n+    _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _6A, _6B, _6C, _6D, _6E, _6F,\n+    _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _7A, _7B, _7C, _7D, _7E, _7F,\n+    _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _8A, _8B, _8C, _8D, _8E, _8F,\n+    _90, _91, _92, _93, _94, _95, _96, _97, _98, _99, _9A, _9B, _9C, _9D, _9E, _9F,\n+    _A0, _A1, _A2, _A3, _A4, _A5, _A6, _A7, _A8, _A9, _AA, _AB, _AC, _AD, _AE, _AF,\n+    _B0, _B1, _B2, _B3, _B4, _B5, _B6, _B7, _B8, _B9, _BA, _BB, _BC, _BD, _BE, _BF,\n+    _C0, _C1, _C2, _C3, _C4, _C5, _C6, _C7, _C8, _C9, _CA, _CB, _CC, _CD, _CE, _CF,\n+    _D0, _D1, _D2, _D3, _D4, _D5, _D6, _D7, _D8, _D9, _DA, _DB, _DC, _DD, _DE, _DF,\n+    _E0, _E1, _E2, _E3, _E4, _E5, _E6, _E7, _E8, _E9, _EA, _EB, _EC, _ED, _EE, _EF,\n+    _F0, _F1, _F2, _F3, _F4, _F5, _F6, _F7, _F8, _F9, _FA, _FB, _FC, _FD, _FE, _FF,\n+}\n+\n pub fn main() {\n     assert_eq!(size_of::<u8>(), 1 as usize);\n     assert_eq!(size_of::<u32>(), 4 as usize);\n@@ -170,4 +218,35 @@ pub fn main() {\n     assert_eq!(size_of::<AlwaysTaggedBecauseItHasNoNiche>(), 8);\n     assert_eq!(size_of::<Option<AlwaysTaggedBecauseItHasNoNiche>>(), 8);\n     assert_eq!(size_of::<Option<Option<AlwaysTaggedBecauseItHasNoNiche>>>(), 8);\n+\n+    assert_eq!(size_of::<NicheFilledMultipleFields>(), 2);\n+    assert_eq!(size_of::<Option<NicheFilledMultipleFields>>(), 2);\n+    assert_eq!(size_of::<Option<Option<NicheFilledMultipleFields>>>(), 2);\n+\n+    struct S1{ a: u16, b: std::num::NonZeroU16, c: u16, d: u8, e: u32, f: u64, g:[u8;2] }\n+    assert_eq!(size_of::<S1>(), 24);\n+    assert_eq!(size_of::<Option<S1>>(), 24);\n+\n+    assert_eq!(size_of::<NicheWithData>(), 12);\n+    assert_eq!(size_of::<Option<NicheWithData>>(), 12);\n+    assert_eq!(size_of::<Option<Option<NicheWithData>>>(), 12);\n+    assert_eq!(\n+        size_of::<Option<Option2<&(), Option<NicheWithData>>>>(),\n+        size_of::<(&(), NicheWithData)>()\n+    );\n+\n+    pub enum FillPadding { A(std::num::NonZeroU8, u32), B }\n+    assert_eq!(size_of::<FillPadding>(), 8);\n+    assert_eq!(size_of::<Option<FillPadding>>(), 8);\n+    assert_eq!(size_of::<Option<Option<FillPadding>>>(), 8);\n+\n+    assert_eq!(size_of::<Result<(std::num::NonZeroU8, u8, u8), u16>>(), 4);\n+    assert_eq!(size_of::<Option<Result<(std::num::NonZeroU8, u8, u8), u16>>>(), 4);\n+    assert_eq!(size_of::<Result<(std::num::NonZeroU8, u8, u8, u8), u16>>(), 4);\n+\n+    assert_eq!(size_of::<EnumManyVariant<u16>>(), 6);\n+    assert_eq!(size_of::<EnumManyVariant<NicheU16>>(), 4);\n+    assert_eq!(size_of::<EnumManyVariant<Option<NicheU16>>>(), 4);\n+    assert_eq!(size_of::<EnumManyVariant<Option2<NicheU16,u8>>>(), 6);\n+    assert_eq!(size_of::<EnumManyVariant<Option<(NicheU16,u8)>>>(), 6);\n }"}]}