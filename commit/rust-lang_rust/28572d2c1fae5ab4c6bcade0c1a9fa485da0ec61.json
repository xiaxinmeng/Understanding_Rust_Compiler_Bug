{"sha": "28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NTcyZDJjMWZhZTVhYjRjNmJjYWRlMGMxYTlmYTQ4NWRhMGVjNjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-16T08:28:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:08:14Z"}, "message": "Nuke the entire ctfe from orbit, it's the only way to be sure", "tree": {"sha": "f22eb741c97adb6c6b06ef49ead8391adb55a03a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f22eb741c97adb6c6b06ef49ead8391adb55a03a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg4V4ACgkQpp+NIls6\n19n58A/7BDUslv16EvXqah/ShFBsrGRo7/Vy7LOOe1qC41pfSVJdoesSLKOQnv1A\ndhWcxdNR8R0Z1xM2vMFi7J+dcpgIDDMWyxVfCkmN6uDoW+T0uandQ9Xpk/tS0JUg\nkxUcazuWTwihWMhVeJeN6c3Q919r84QCGeF7wSx3RdEvIdYaL3ML4W+JBsuCFLF3\nzSTFKReF4Hwq9mbOvgwT8OYpMVfEaNmRsEzmFcO6MarYa3lUHCee0ShrhUps+xPG\nCGK4Qoc4VWDQh0C2P8m7ck7SJwNJ1QESlotHc7BPAW7crj0k2x/Ox0kxtJZt9NZN\npQLmc2L/q4Cut6bH5AKfiXL8mY61+fJB2adnuKvCMq7sMvjueGJVg2DxWNs4/MnK\nJh3n72fidWiKN0qbtTGQapmEhJoEX73kGXXs0U07LyPSaj5AGePiVJtXw+DvZV4W\nV9x/UhxJPJJ4CNGzVV1s8GxHcAjcND4GDHN4ReGfY9QLepntMZX1sgsDV0PjjgOy\n4ChbnFmzEwH2/Oh7sVVJZusT4hw23dFplAVN8oGDpVQtJN1YQowviFkxQ8ZvHFEI\nckPie43NBGSQbNNXkxLWCHx6Qa5/doFe/DqoOFZYl2Sg0w7kQoIkFukQYVSzn4Xv\nB5dnu133zZu9eNrhgRc0ehxaPeI/pzszZ1TIsXJ0wocOkaobw90=\n=GFxl\n-----END PGP SIGNATURE-----", "payload": "tree f22eb741c97adb6c6b06ef49ead8391adb55a03a\nparent 0b9db5716f31d1df62214edd63ba26c368f9c6bf\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1516091307 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520492894 +0100\n\nNuke the entire ctfe from orbit, it's the only way to be sure\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "html_url": "https://github.com/rust-lang/rust/commit/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b9db5716f31d1df62214edd63ba26c368f9c6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9db5716f31d1df62214edd63ba26c368f9c6bf", "html_url": "https://github.com/rust-lang/rust/commit/0b9db5716f31d1df62214edd63ba26c368f9c6bf"}], "stats": {"total": 2697, "additions": 630, "deletions": 2067}, "files": [{"sha": "08a42e61ea0001bf508dd41fe3445aae6ef9a33b", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -338,53 +338,10 @@ for ::middle::const_val::ConstVal<'gcx> {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal::*;\n-        use middle::const_val::ConstAggregate::*;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Integral(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Float(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Str(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            ByteStr(ref value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Bool(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Char(value) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Variant(def_id) => {\n-                def_id.hash_stable(hcx, hasher);\n-            }\n-            Function(def_id, substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-                    substs.hash_stable(hcx, hasher);\n-                });\n-            }\n-            Aggregate(Struct(ref name_values)) => {\n-                let mut values = name_values.to_vec();\n-                values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n-                values.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Tuple(ref value)) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Array(ref value)) => {\n-                value.hash_stable(hcx, hasher);\n-            }\n-            Aggregate(Repeat(ref value, times)) => {\n-                value.hash_stable(hcx, hasher);\n-                times.hash_stable(hcx, hasher);\n-            }\n             Unevaluated(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);"}, {"sha": "a951265d458bf2e6a78ec67dad8e234593227b94", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -20,6 +20,12 @@ use session::Session;\n use session::config::Epoch;\n use syntax::codemap::Span;\n \n+declare_lint! {\n+    pub EXCEEDING_BITSHIFTS,\n+    Deny,\n+    \"shift exceeds the type's number of bits\"\n+}\n+\n declare_lint! {\n     pub CONST_ERR,\n     Warn,\n@@ -263,6 +269,12 @@ declare_lint! {\n     Epoch::Epoch2018\n }\n \n+declare_lint! {\n+    pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+    Warn,\n+    \"floating-point literals cannot be used in patterns\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -271,6 +283,8 @@ pub struct HardwiredLints;\n impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n+            ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+            EXCEEDING_BITSHIFTS,\n             UNUSED_IMPORTS,\n             UNUSED_EXTERN_CRATES,\n             UNUSED_QUALIFICATIONS,"}, {"sha": "dd99305809c2840b6c0a3470258aa7b8dc466801", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -18,9 +18,7 @@ use mir::interpret::{Value, PrimVal};\n \n use graphviz::IntoCow;\n use errors::DiagnosticBuilder;\n-use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n-use syntax::symbol::InternedString;\n-use syntax::ast;\n+use serialize;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n@@ -29,17 +27,7 @@ pub type EvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ConstEvalErr<'tcx>>;\n \n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal<'tcx> {\n-    Integral(ConstInt),\n-    Float(ConstFloat),\n-    Str(InternedString),\n-    ByteStr(ByteArray<'tcx>),\n-    Bool(bool),\n-    Char(char),\n-    Variant(DefId),\n-    Function(DefId, &'tcx Substs<'tcx>),\n-    Aggregate(ConstAggregate<'tcx>),\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n-    /// A miri value, currently only produced if --miri is enabled\n     Value(Value),\n }\n \n@@ -50,32 +38,9 @@ pub struct ByteArray<'tcx> {\n \n impl<'tcx> serialize::UseSpecializedDecodable for ByteArray<'tcx> {}\n \n-#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n-pub enum ConstAggregate<'tcx> {\n-    Struct(&'tcx [(ast::Name, &'tcx ty::Const<'tcx>)]),\n-    Tuple(&'tcx [&'tcx ty::Const<'tcx>]),\n-    Array(&'tcx [&'tcx ty::Const<'tcx>]),\n-    Repeat(&'tcx ty::Const<'tcx>, u64),\n-}\n-\n-impl<'tcx> Encodable for ConstAggregate<'tcx> {\n-    fn encode<S: Encoder>(&self, _: &mut S) -> Result<(), S::Error> {\n-        bug!(\"should never encode ConstAggregate::{:?}\", self)\n-    }\n-}\n-\n-impl<'tcx> Decodable for ConstAggregate<'tcx> {\n-    fn decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n-        bug!(\"should never decode ConstAggregate\")\n-    }\n-}\n-\n impl<'tcx> ConstVal<'tcx> {\n     pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n-            ConstVal::Integral(i) => i.to_u128(),\n-            ConstVal::Bool(b) => Some(b as u128),\n-            ConstVal::Char(ch) => Some(ch as u32 as u128),\n             ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n                 Some(b)\n             },\n@@ -93,7 +58,6 @@ impl<'tcx> ConstVal<'tcx> {\n     }\n     pub fn unwrap_usize<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> ConstUsize {\n         match *self {\n-            ConstVal::Integral(ConstInt::Usize(i)) => i,\n             ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n                 assert_eq!(b as u64 as u128, b);\n                 match ConstUsize::new(b as u64, tcx.sess.target.usize_ty) {"}, {"sha": "d8994351418199910f06cb5ac6255324c476c3f4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -33,7 +33,6 @@ use ty::TypeAndMut;\n use util::ppaux;\n use std::slice;\n use hir::{self, InlineAsm};\n-use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n use std::fmt::{self, Debug, Formatter, Write};\n@@ -1539,12 +1538,8 @@ impl<'tcx> Operand<'tcx> {\n             ty,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: if tcx.sess.opts.debugging_opts.miri {\n-                        // ZST function type\n-                        ConstVal::Value(Value::ByVal(PrimVal::Undef))\n-                    } else {\n-                        ConstVal::Function(def_id, substs)\n-                    },\n+                    // ZST function type\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty\n                 })\n             },\n@@ -1877,21 +1872,6 @@ impl<'tcx> Debug for Literal<'tcx> {\n fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n     use middle::const_val::ConstVal::*;\n     match const_val.val {\n-        Float(f) => write!(fmt, \"{:?}\", f),\n-        Integral(n) => write!(fmt, \"{}\", n),\n-        Str(s) => write!(fmt, \"{:?}\", s),\n-        ByteStr(bytes) => {\n-            let escaped: String = bytes.data\n-                .iter()\n-                .flat_map(|&ch| ascii::escape_default(ch).map(|c| c as char))\n-                .collect();\n-            write!(fmt, \"b\\\"{}\\\"\", escaped)\n-        }\n-        Bool(b) => write!(fmt, \"{:?}\", b),\n-        Char(c) => write!(fmt, \"{:?}\", c),\n-        Variant(def_id) |\n-        Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n-        Aggregate(_) => bug!(\"`ConstVal::{:?}` should not be in MIR\", const_val),\n         Unevaluated(..) => write!(fmt, \"{:?}\", const_val),\n         Value(val) => print_miri_value(val, const_val.ty, fmt),\n     }\n@@ -1918,7 +1898,7 @@ fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n                 let alloc = tcx\n                     .interpret_interner\n                     .borrow()\n-                    .get_alloc(ptr.alloc_id.0)\n+                    .get_alloc(ptr.alloc_id)\n                     .expect(\"miri alloc not found\");\n                 assert_eq!(len as usize as u128, len);\n                 let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];"}, {"sha": "ebd78467c3b9ea63051566c6e4e124576c0d90aa", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -54,7 +54,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::{TypedArena, DroplessArena};\n-use rustc_const_math::{ConstInt, ConstUsize};\n+use rustc_const_math::ConstUsize;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n use std::any::Any;\n@@ -909,7 +909,7 @@ pub struct InterpretInterner<'tcx> {\n     /// Reverse map of `alloc_cache`\n     ///\n     /// Multiple globals may share the same memory\n-    global_cache: FxHashMap<interpret::Pointer, Vec<interpret::GlobalId<'tcx>>>,\n+    global_cache: FxHashMap<interpret::AllocId, Vec<interpret::GlobalId<'tcx>>>,\n \n     /// The AllocId to assign to the next new regular allocation.\n     /// Always incremented, never gets smaller.\n@@ -959,20 +959,17 @@ impl<'tcx> InterpretInterner<'tcx> {\n     pub fn cache(\n         &mut self,\n         global_id: interpret::GlobalId<'tcx>,\n-        ptr: interpret::AllocId,\n+        alloc_id: interpret::AllocId,\n     ) {\n-        if let interpret::PrimVal::Ptr(ptr) = ptr.primval {\n-            assert!(ptr.offset == 0);\n-        }\n-        self.global_cache.entry(ptr).or_default().push(global_id);\n-        if let Some(old) = self.alloc_cache.insert(global_id, ptr) {\n+        self.global_cache.entry(alloc_id).or_default().push(global_id);\n+        if let Some(old) = self.alloc_cache.insert(global_id, alloc_id) {\n             bug!(\"tried to cache {:?}, but was already existing as {:#?}\", global_id, old);\n         }\n     }\n \n     pub fn get_globals(\n         &self,\n-        ptr: interpret::Pointer,\n+        ptr: interpret::AllocId,\n     ) -> &[interpret::GlobalId<'tcx>] {\n         match self.global_cache.get(&ptr) {\n             Some(v) => v,\n@@ -2099,11 +2096,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_array_const_usize(self, ty: Ty<'tcx>, n: ConstUsize) -> Ty<'tcx> {\n         self.mk_ty(TyArray(ty, self.mk_const(ty::Const {\n-            val: if self.sess.opts.debugging_opts.miri {\n-                ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.as_u64().into())))\n-            } else {\n-                ConstVal::Integral(ConstInt::Usize(n))\n-            },\n+            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(n.as_u64().into()))),\n             ty: self.types.usize\n         })))\n     }"}, {"sha": "5dc78d84da8355e679fc2432d2a07f7867e4536f", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -19,8 +19,6 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n-use rustc_const_math::ConstInt;\n-\n use hir;\n \n #[derive(Clone, Copy, Debug)]\n@@ -188,8 +186,6 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyForeign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)),\n             ty::TyArray(_, n) => {\n                 match n.val {\n-                    ConstVal::Integral(ConstInt::Usize(n)) =>\n-                        format!(\"array of {} elements\", n),\n                     ConstVal::Value(Value::ByVal(PrimVal::Bytes(n))) =>\n                         format!(\"array of {} elements\", n),\n                     _ => \"array\".to_string(),"}, {"sha": "f067789771c59ba6115e782dde94e85dbcc136e1", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::const_val::{ConstVal, ConstAggregate};\n+use middle::const_val::ConstVal;\n use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n@@ -218,31 +218,7 @@ impl FlagComputation {\n     fn add_const(&mut self, constant: &ty::Const) {\n         self.add_ty(constant.ty);\n         match constant.val {\n-            ConstVal::Integral(_) |\n-            ConstVal::Float(_) |\n-            ConstVal::Str(_) |\n-            ConstVal::ByteStr(_) |\n-            ConstVal::Bool(_) |\n-            ConstVal::Char(_) |\n-            ConstVal::Value(_) |\n-            ConstVal::Variant(_) => {}\n-            ConstVal::Function(_, substs) => {\n-                self.add_substs(substs);\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                for &(_, v) in fields {\n-                    self.add_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                for v in fields {\n-                    self.add_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-                self.add_const(v);\n-            }\n+            ConstVal::Value(_) => {}\n             ConstVal::Unevaluated(_, substs) => {\n                 self.add_flags(TypeFlags::HAS_PROJECTION);\n                 self.add_substs(substs);"}, {"sha": "8c955bf340e8d2f449db4c3d72a5c61d8508e760", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -1836,9 +1836,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             if let VariantDiscr::Explicit(expr_did) = v.discr {\n                 let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                 match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                    Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n-                        discr = v;\n-                    }\n                     Ok(&ty::Const {\n                         val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n                         ..\n@@ -1889,10 +1886,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 ty::VariantDiscr::Explicit(expr_did) => {\n                     let substs = Substs::identity_for_item(tcx.global_tcx(), expr_did);\n                     match tcx.const_eval(param_env.and((expr_did, substs))) {\n-                        Ok(&ty::Const { val: ConstVal::Integral(v), .. }) => {\n-                            explicit_value = v;\n-                            break;\n-                        }\n                         Ok(&ty::Const {\n                             val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n                             .."}, {"sha": "2cbe9da88b51b392123f898798573ee4d1802b00", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -483,17 +483,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             assert_eq!(sz_b.ty, tcx.types.usize);\n             let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n                 match x.val {\n-                    ConstVal::Integral(x) => Ok(x.to_u64().unwrap()),\n                     ConstVal::Value(Value::ByVal(prim)) => Ok(prim.to_u64().unwrap()),\n                     ConstVal::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                         match tcx.lift_to_global(&substs) {\n                             Some(substs) => {\n                                 match tcx.const_eval(param_env.and((def_id, substs))) {\n-                                    Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => {\n-                                        return Ok(x.to_u64().unwrap());\n-                                    }\n                                     Ok(&ty::Const {\n                                         val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n                                         .."}, {"sha": "ad66cbd9eab3bd777334bd4e02b5d3a7afd27499", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -13,7 +13,7 @@\n //! hand, though we've recently added some macros (e.g.,\n //! `BraceStructLiftImpl!`) to help with the tedium.\n \n-use middle::const_val::{self, ConstVal, ConstAggregate, ConstEvalErr};\n+use middle::const_val::{self, ConstVal, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -1410,54 +1410,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstVal::Integral(i) => ConstVal::Integral(i),\n-            ConstVal::Float(f) => ConstVal::Float(f),\n-            ConstVal::Str(s) => ConstVal::Str(s),\n-            ConstVal::ByteStr(b) => ConstVal::ByteStr(b),\n-            ConstVal::Bool(b) => ConstVal::Bool(b),\n-            ConstVal::Char(c) => ConstVal::Char(c),\n             ConstVal::Value(v) => ConstVal::Value(v),\n-            ConstVal::Variant(def_id) => ConstVal::Variant(def_id),\n-            ConstVal::Function(def_id, substs) => {\n-                ConstVal::Function(def_id, substs.fold_with(folder))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                let new_fields: Vec<_> = fields.iter().map(|&(name, v)| {\n-                    (name, v.fold_with(folder))\n-                }).collect();\n-                let fields = if new_fields == fields {\n-                    fields\n-                } else {\n-                    folder.tcx().alloc_name_const_slice(&new_fields)\n-                };\n-                ConstVal::Aggregate(ConstAggregate::Struct(fields))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) => {\n-                let new_fields: Vec<_> = fields.iter().map(|v| {\n-                    v.fold_with(folder)\n-                }).collect();\n-                let fields = if new_fields == fields {\n-                    fields\n-                } else {\n-                    folder.tcx().alloc_const_slice(&new_fields)\n-                };\n-                ConstVal::Aggregate(ConstAggregate::Tuple(fields))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                let new_fields: Vec<_> = fields.iter().map(|v| {\n-                    v.fold_with(folder)\n-                }).collect();\n-                let fields = if new_fields == fields {\n-                    fields\n-                } else {\n-                    folder.tcx().alloc_const_slice(&new_fields)\n-                };\n-                ConstVal::Aggregate(ConstAggregate::Array(fields))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, count)) => {\n-                let v = v.fold_with(folder);\n-                ConstVal::Aggregate(ConstAggregate::Repeat(v, count))\n-            }\n             ConstVal::Unevaluated(def_id, substs) => {\n                 ConstVal::Unevaluated(def_id, substs.fold_with(folder))\n             }\n@@ -1466,25 +1419,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstVal<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ConstVal::Integral(_) |\n-            ConstVal::Float(_) |\n-            ConstVal::Str(_) |\n-            ConstVal::ByteStr(_) |\n-            ConstVal::Bool(_) |\n-            ConstVal::Char(_) |\n-            ConstVal::Value(_) |\n-            ConstVal::Variant(_) => false,\n-            ConstVal::Function(_, substs) => substs.visit_with(visitor),\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                fields.iter().any(|&(_, v)| v.visit_with(visitor))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                fields.iter().any(|v| v.visit_with(visitor))\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-                v.visit_with(visitor)\n-            }\n+            ConstVal::Value(_) => false,\n             ConstVal::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }"}, {"sha": "6ae0d520e54d36795fb418aa46d423f2006dc833", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -765,7 +765,6 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n             TyArray(_, n) => {\n                 self.hash_discriminant_u8(&n.val);\n                 match n.val {\n-                    ConstVal::Integral(x) => self.hash(x.to_u64().unwrap()),\n                     ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => self.hash(b),\n                     ConstVal::Unevaluated(def_id, _) => self.def_id(def_id),\n                     _ => bug!(\"arrays should not have {:?} as length\", n)"}, {"sha": "722fdfe773a98bac45eab8bbf6a4ad5a260337ba", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -11,7 +11,7 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use middle::const_val::{ConstVal, ConstAggregate};\n+use middle::const_val::ConstVal;\n use ty::{self, Ty};\n use rustc_data_structures::small_vec::SmallVec;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n@@ -140,31 +140,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n \n fn push_const<'tcx>(stack: &mut TypeWalkerStack<'tcx>, constant: &'tcx ty::Const<'tcx>) {\n     match constant.val {\n-        ConstVal::Integral(_) |\n-        ConstVal::Float(_) |\n-        ConstVal::Str(_) |\n-        ConstVal::ByteStr(_) |\n-        ConstVal::Bool(_) |\n-        ConstVal::Char(_) |\n-        ConstVal::Value(_) |\n-        ConstVal::Variant(_) => {}\n-        ConstVal::Function(_, substs) => {\n-            stack.extend(substs.types().rev());\n-        }\n-        ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-            for &(_, v) in fields.iter().rev() {\n-                push_const(stack, v);\n-            }\n-        }\n-        ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-        ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-            for v in fields.iter().rev() {\n-                push_const(stack, v);\n-            }\n-        }\n-        ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-            push_const(stack, v);\n-        }\n+        ConstVal::Value(_) => {}\n         ConstVal::Unevaluated(_, substs) => {\n             stack.extend(substs.types().rev());\n         }"}, {"sha": "49ae79ae9c92c69b9babf214f6168d3d8da97bc6", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use middle::const_val::{ConstVal, ConstAggregate};\n+use middle::const_val::ConstVal;\n use infer::InferCtxt;\n use ty::subst::Substs;\n use traits;\n@@ -217,29 +217,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn compute_const(&mut self, constant: &'tcx ty::Const<'tcx>) {\n         self.require_sized(constant.ty, traits::ConstSized);\n         match constant.val {\n-            ConstVal::Integral(_) |\n-            ConstVal::Float(_) |\n-            ConstVal::Str(_) |\n-            ConstVal::ByteStr(_) |\n-            ConstVal::Bool(_) |\n-            ConstVal::Char(_) |\n-            ConstVal::Variant(_) |\n-            ConstVal::Value(_) |\n-            ConstVal::Function(..) => {}\n-            ConstVal::Aggregate(ConstAggregate::Struct(fields)) => {\n-                for &(_, v) in fields {\n-                    self.compute_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Tuple(fields)) |\n-            ConstVal::Aggregate(ConstAggregate::Array(fields)) => {\n-                for v in fields {\n-                    self.compute_const(v);\n-                }\n-            }\n-            ConstVal::Aggregate(ConstAggregate::Repeat(v, _)) => {\n-                self.compute_const(v);\n-            }\n+            ConstVal::Value(_) => {}\n             ConstVal::Unevaluated(def_id, substs) => {\n                 let obligations = self.nominal_obligations(def_id, substs);\n                 self.out.extend(obligations);"}, {"sha": "5e2792ee6410e6a1fe2d1b95aed8fca80e45ce60", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -27,7 +27,6 @@ use std::cell::Cell;\n use std::fmt;\n use std::usize;\n \n-use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::abi::Abi;\n use syntax::ast::CRATE_NODE_ID;\n@@ -1166,9 +1165,6 @@ define_print! {\n                 TyArray(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n                     match sz.val {\n-                        ConstVal::Integral(ConstInt::Usize(sz)) => {\n-                            write!(f, \"{}\", sz)?;\n-                        }\n                         ConstVal::Value(Value::ByVal(PrimVal::Bytes(sz))) => {\n                             write!(f, \"{}\", sz)?;\n                         }"}, {"sha": "943de1211182c6e81a6de3da07d5f3c7bdd37ac9", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -1088,6 +1088,13 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(trans: &TransCrate,\n             stability::check_unused_or_stable_features(tcx)\n         });\n \n+\n+        time(time_passes,\n+             \"MIR linting\",\n+             || for def_id in tcx.body_owners() {\n+                 mir::const_eval::check::check(tcx, def_id)\n+             });\n+\n         time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n         return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));"}, {"sha": "831d4fc755f8f03490bcd76051ad790fd29e60e1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -682,78 +682,6 @@ impl EarlyLintPass for DeprecatedAttr {\n     }\n }\n \n-declare_lint! {\n-    pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-    Warn,\n-    \"floating-point literals cannot be used in patterns\"\n-}\n-\n-/// Checks for floating point literals in patterns.\n-#[derive(Clone)]\n-pub struct IllegalFloatLiteralPattern;\n-\n-impl LintPass for IllegalFloatLiteralPattern {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN)\n-    }\n-}\n-\n-fn fl_lit_check_expr(cx: &EarlyContext, expr: &ast::Expr) {\n-    use self::ast::{ExprKind, LitKind};\n-    match expr.node {\n-        ExprKind::Lit(ref l) => {\n-            match l.node {\n-                LitKind::FloatUnsuffixed(..) |\n-                LitKind::Float(..) => {\n-                    cx.span_lint(ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-                                 l.span,\n-                                 \"floating-point literals cannot be used in patterns\");\n-                    },\n-                _ => (),\n-            }\n-        }\n-        // These may occur in patterns\n-        // and can maybe contain float literals\n-        ExprKind::Unary(_, ref f) => fl_lit_check_expr(cx, f),\n-        // Other kinds of exprs can't occur in patterns so we don't have to check them\n-        // (ast_validation will emit an error if they occur)\n-        _ => (),\n-    }\n-}\n-\n-impl EarlyLintPass for IllegalFloatLiteralPattern {\n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &ast::Pat) {\n-        use self::ast::PatKind;\n-        pat.walk(&mut |p| {\n-            match p.node {\n-                // Wildcard patterns and paths are uninteresting for the lint\n-                PatKind::Wild |\n-                PatKind::Path(..) => (),\n-\n-                // The walk logic recurses inside these\n-                PatKind::Ident(..) |\n-                PatKind::Struct(..) |\n-                PatKind::Tuple(..) |\n-                PatKind::TupleStruct(..) |\n-                PatKind::Ref(..) |\n-                PatKind::Box(..) |\n-                PatKind::Paren(..) |\n-                PatKind::Slice(..) => (),\n-\n-                // Extract the expressions and check them\n-                PatKind::Lit(ref e) => fl_lit_check_expr(cx, e),\n-                PatKind::Range(ref st, ref en, _) => {\n-                    fl_lit_check_expr(cx, st);\n-                    fl_lit_check_expr(cx, en);\n-                },\n-\n-                PatKind::Mac(_) => bug!(\"lint must run post-expansion\"),\n-            }\n-            true\n-        });\n-    }\n-}\n-\n declare_lint! {\n     pub UNUSED_DOC_COMMENT,\n     Warn,"}, {"sha": "e941f2e4e1c2a185441e69d6fe34b5a56eec35f4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -43,7 +43,6 @@ extern crate rustc_mir;\n extern crate syntax_pos;\n \n use rustc::lint;\n-use rustc::middle;\n use rustc::session;\n use rustc::util;\n \n@@ -107,7 +106,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                        UnusedParens,\n                        UnusedImportBraces,\n                        AnonymousParameters,\n-                       IllegalFloatLiteralPattern,\n                        UnusedDocComment,\n                        );\n "}, {"sha": "be7f1152ea4a0300a86d3656542277952e80c074", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -14,9 +14,6 @@ use rustc::hir::map as hir_map;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n-use middle::const_val::ConstVal;\n-use rustc_mir::const_eval::ConstContext;\n-use rustc::mir::interpret::{Value, PrimVal};\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -43,12 +40,6 @@ declare_lint! {\n     \"literal out of range for its type\"\n }\n \n-declare_lint! {\n-    EXCEEDING_BITSHIFTS,\n-    Deny,\n-    \"shift exceeds the type's number of bits\"\n-}\n-\n declare_lint! {\n     VARIANT_SIZE_DIFFERENCES,\n     Allow,\n@@ -70,8 +61,7 @@ impl TypeLimits {\n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNUSED_COMPARISONS,\n-                    OVERFLOWING_LITERALS,\n-                    EXCEEDING_BITSHIFTS)\n+                    OVERFLOWING_LITERALS)\n     }\n }\n \n@@ -90,59 +80,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                  e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n-\n-                if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n-                        ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.isize_ty)),\n-                        ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.usize_ty)),\n-                        _ => None,\n-                    };\n-\n-                    if let Some(bits) = opt_ty_bits {\n-                        let exceeding = if let hir::ExprLit(ref lit) = r.node {\n-                            if let ast::LitKind::Int(shift, _) = lit.node {\n-                                shift as u64 >= bits\n-                            } else {\n-                                false\n-                            }\n-                        } else {\n-                            // HACK(eddyb) This might be quite inefficient.\n-                            // This would be better left to MIR constant propagation,\n-                            // perhaps even at trans time (like is the case already\n-                            // when the value being shifted is *also* constant).\n-                            let parent_item = cx.tcx.hir.get_parent(e.id);\n-                            let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-                            let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-                            let const_cx = ConstContext::new(cx.tcx,\n-                                                             cx.param_env.and(substs),\n-                                                             cx.tables);\n-                            match const_cx.eval(&r) {\n-                                Ok(&ty::Const { val: ConstVal::Integral(i), .. }) => {\n-                                    i.is_negative() ||\n-                                    i.to_u64()\n-                                        .map(|i| i >= bits)\n-                                        .unwrap_or(true)\n-                                }\n-                                Ok(&ty::Const {\n-                                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n-                                    ty,\n-                                }) => {\n-                                    if ty.is_signed() {\n-                                        (b as i128) < 0\n-                                    } else {\n-                                        b >= bits as u128\n-                                    }\n-                                }\n-                                _ => false,\n-                            }\n-                        };\n-                        if exceeding {\n-                            cx.span_lint(EXCEEDING_BITSHIFTS,\n-                                         e.span,\n-                                         \"bitshift exceeds the type's number of bits\");\n-                        }\n-                    };\n-                }\n             }\n             hir::ExprLit(ref lit) => {\n                 match cx.tables.node_id_to_type(e.hir_id).sty {\n@@ -301,28 +238,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn int_ty_bits(int_ty: ast::IntTy, isize_ty: ast::IntTy) -> u64 {\n-            match int_ty {\n-                ast::IntTy::Isize => int_ty_bits(isize_ty, isize_ty),\n-                ast::IntTy::I8 => 8,\n-                ast::IntTy::I16 => 16 as u64,\n-                ast::IntTy::I32 => 32,\n-                ast::IntTy::I64 => 64,\n-                ast::IntTy::I128 => 128,\n-            }\n-        }\n-\n-        fn uint_ty_bits(uint_ty: ast::UintTy, usize_ty: ast::UintTy) -> u64 {\n-            match uint_ty {\n-                ast::UintTy::Usize => uint_ty_bits(usize_ty, usize_ty),\n-                ast::UintTy::U8 => 8,\n-                ast::UintTy::U16 => 16,\n-                ast::UintTy::U32 => 32,\n-                ast::UintTy::U64 => 64,\n-                ast::UintTy::U128 => 128,\n-            }\n-        }\n-\n         fn check_limits(cx: &LateContext,\n                         binop: hir::BinOp,\n                         l: &hir::Expr,"}, {"sha": "77c3eed9e44d21c069b47186dd66c48279c0fe23", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -281,27 +281,20 @@ impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx\n         let pos = self.position();\n         match usize::decode(self)? {\n             ::std::usize::MAX => {\n-                let id = interpret_interner().reserve();\n-                let alloc_id = interpret::AllocId(id);\n+                let alloc_id = interpret_interner().reserve();\n                 trace!(\"creating alloc id {:?} at {}\", alloc_id, pos);\n                 // insert early to allow recursive allocs\n                 self.interpret_alloc_cache.insert(pos, alloc_id);\n \n                 let allocation = interpret::Allocation::decode(self)?;\n                 trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n                 let allocation = self.tcx.unwrap().intern_const_alloc(allocation);\n-                interpret_interner().intern_at_reserved(id, allocation);\n+                interpret_interner().intern_at_reserved(alloc_id, allocation);\n \n                 let num = usize::decode(self)?;\n-                let ptr = interpret::Pointer {\n-                    primval: interpret::PrimVal::Ptr(interpret::MemoryPointer {\n-                        alloc_id,\n-                        offset: 0,\n-                    }),\n-                };\n                 for _ in 0..num {\n                     let glob = interpret::GlobalId::decode(self)?;\n-                    interpret_interner().cache(glob, ptr);\n+                    interpret_interner().cache(glob, alloc_id);\n                 }\n \n                 Ok(alloc_id)\n@@ -310,7 +303,7 @@ impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx\n                 trace!(\"creating fn alloc id at {}\", pos);\n                 let instance = ty::Instance::decode(self)?;\n                 trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                let id = interpret::AllocId(interpret_interner().create_fn_alloc(instance));\n+                let id = interpret_interner().create_fn_alloc(instance);\n                 trace!(\"created fn alloc id: {:?}\", id);\n                 self.interpret_alloc_cache.insert(pos, id);\n                 Ok(id)"}, {"sha": "f5631f5fab91f5988c79873a6856d717021a70a9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -199,26 +199,21 @@ impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx\n         // point to itself.\n         self.interpret_alloc_shorthands.insert(*alloc_id, start);\n         let interpret_interner = self.tcx.interpret_interner.borrow();\n-        if let Some(alloc) = interpret_interner.get_alloc(alloc_id.0) {\n+        if let Some(alloc) = interpret_interner.get_alloc(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n             usize::max_value().encode(self)?;\n             alloc.encode(self)?;\n-            let globals = interpret_interner.get_globals(interpret::Pointer {\n-                primval: interpret::PrimVal::Ptr(interpret::MemoryPointer {\n-                    alloc_id: *alloc_id,\n-                    offset: 0,\n-                }),\n-            });\n+            let globals = interpret_interner.get_globals(*alloc_id);\n             globals.len().encode(self)?;\n             for glob in globals {\n                 glob.encode(self)?;\n             }\n-        } else if let Some(fn_instance) = interpret_interner.get_fn(alloc_id.0) {\n+        } else if let Some(fn_instance) = interpret_interner.get_fn(*alloc_id) {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n             (usize::max_value() - 1).encode(self)?;\n             fn_instance.encode(self)?;\n         } else {\n-            bug!(\"alloc id without corresponding allocation: {}\", alloc_id.0);\n+            bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n         }\n         Ok(())\n     }"}, {"sha": "182ed52961929f0e4cfa205ef17eb8c33be95b17", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -260,12 +260,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 // would be lost if we just look at the normalized\n                 // value.\n                 let did = match value.val {\n-                    ConstVal::Function(def_id, ..) => Some(def_id),\n                     ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n                         self.tcx()\n                             .interpret_interner\n                             .borrow()\n-                            .get_fn(p.alloc_id.0)\n+                            .get_fn(p.alloc_id)\n                             .map(|instance| instance.def_id())\n                     },\n                     ConstVal::Value(Value::ByVal(PrimVal::Undef)) => {\n@@ -1044,11 +1043,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     },\n                 ..\n             }) => match val {\n-                ConstVal::Function(def_id, _) => {\n-                    Some(def_id) == self.tcx().lang_items().box_free_fn()\n-                },\n                 ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n-                    let inst = self.tcx().interpret_interner.borrow().get_fn(p.alloc_id.0);\n+                    let inst = self.tcx().interpret_interner.borrow().get_fn(p.alloc_id);\n                     inst.map_or(false, |inst| {\n                         Some(inst.def_id()) == self.tcx().lang_items().box_free_fn()\n                     })"}, {"sha": "ca6e7c2c4158039ab8ae884de96a21ea7c03a127", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -204,11 +204,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         ty: this.hir.tcx().types.u32,\n                         literal: Literal::Value {\n                             value: this.hir.tcx().mk_const(ty::Const {\n-                                val: if this.hir.tcx().sess.opts.debugging_opts.miri {\n-                                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n-                                } else {\n-                                    ConstVal::Integral(ConstInt::U32(0))\n-                                },\n+                                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                                 ty: this.hir.tcx().types.u32\n                             }),\n                         },\n@@ -406,11 +402,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n-                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.to_u128_unchecked())))\n-                        } else {\n-                            ConstVal::Integral(val)\n-                        },\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.to_u128_unchecked()))),\n                         ty\n                     })\n                 }\n@@ -448,13 +440,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n-                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(\n-                                val.to_u128_unchecked()\n-                            )))\n-                        } else {\n-                            ConstVal::Integral(val)\n-                        },\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(\n+                            val.to_u128_unchecked()\n+                        ))),\n                         ty\n                     })\n                 }"}, {"sha": "30c70ac30a70b5d4cc3b459bdb3dcedd92856f07", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -299,7 +299,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let mut val = Operand::Copy(place.clone());\n \n                 let bytes = match value.val {\n-                    ConstVal::ByteStr(bytes) => Some(bytes.data),\n                     ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n                         let is_array_ptr = ty\n                             .builtin_deref(true, ty::NoPreference)\n@@ -310,7 +309,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 .tcx()\n                                 .interpret_interner\n                                 .borrow()\n-                                .get_alloc(p.alloc_id.0)\n+                                .get_alloc(p.alloc_id)\n                                 .map(|alloc| &alloc.bytes[..])\n                         } else {\n                             None"}, {"sha": "78c7004ef6034070b820c9df3245fb2bb97a368b", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 4, "deletions": 51, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -13,13 +13,11 @@\n \n use build::Builder;\n \n-use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc::mir::*;\n-use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n@@ -63,61 +61,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ty::TyChar => {\n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n-                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n-                        } else {\n-                            ConstVal::Char('\\0')\n-                        },\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                         ty\n                     })\n                 }\n             }\n-            ty::TyUint(ity) => {\n-                let val = match ity {\n-                    ast::UintTy::U8  => ConstInt::U8(0),\n-                    ast::UintTy::U16 => ConstInt::U16(0),\n-                    ast::UintTy::U32 => ConstInt::U32(0),\n-                    ast::UintTy::U64 => ConstInt::U64(0),\n-                    ast::UintTy::U128 => ConstInt::U128(0),\n-                    ast::UintTy::Usize => {\n-                        let uint_ty = self.hir.tcx().sess.target.usize_ty;\n-                        let val = ConstUsize::new(0, uint_ty).unwrap();\n-                        ConstInt::Usize(val)\n-                    }\n-                };\n-\n-                Literal::Value {\n-                    value: self.hir.tcx().mk_const(ty::Const {\n-                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n-                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n-                        } else {\n-                            ConstVal::Integral(val)\n-                        },\n-                        ty\n-                    })\n-                }\n-            }\n-            ty::TyInt(ity) => {\n-                let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(0),\n-                    ast::IntTy::I16 => ConstInt::I16(0),\n-                    ast::IntTy::I32 => ConstInt::I32(0),\n-                    ast::IntTy::I64 => ConstInt::I64(0),\n-                    ast::IntTy::I128 => ConstInt::I128(0),\n-                    ast::IntTy::Isize => {\n-                        let int_ty = self.hir.tcx().sess.target.isize_ty;\n-                        let val = ConstIsize::new(0, int_ty).unwrap();\n-                        ConstInt::Isize(val)\n-                    }\n-                };\n-\n+            ty::TyUint(_) |\n+            ty::TyInt(_) => {\n                 Literal::Value {\n                     value: self.hir.tcx().mk_const(ty::Const {\n-                        val: if self.hir.tcx().sess.opts.debugging_opts.miri {\n-                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n-                        } else {\n-                            ConstVal::Integral(val)\n-                        },\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                         ty\n                     })\n                 }"}, {"sha": "2057b0a5b4f7c19dbf14a62023e0977c9572d65e", "filename": "src/librustc_mir/const_eval/_match.rs", "status": "modified", "additions": 5, "deletions": 41, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -15,8 +15,6 @@ use self::WitnessPreference::*;\n use rustc::middle::const_val::ConstVal;\n use const_eval::eval::{compare_const_vals};\n \n-use rustc_const_math::ConstInt;\n-\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -182,20 +180,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         self.byte_array_map.entry(pat).or_insert_with(|| {\n             match pat.kind {\n-                box PatternKind::Constant {\n-                    value: &ty::Const { val: ConstVal::ByteStr(b), .. }\n-                } => {\n-                    b.data.iter().map(|&b| &*pattern_arena.alloc(Pattern {\n-                        ty: tcx.types.u8,\n-                        span: pat.span,\n-                        kind: box PatternKind::Constant {\n-                            value: tcx.mk_const(ty::Const {\n-                                val: ConstVal::Integral(ConstInt::U8(b)),\n-                                ty: tcx.types.u8\n-                            })\n-                        }\n-                    })).collect()\n-                }\n                 box PatternKind::Constant {\n                     value: &ty::Const { val: ConstVal::Value(b), ty }\n                 } => {\n@@ -209,7 +193,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                             let alloc = tcx\n                                 .interpret_interner\n                                 .borrow()\n-                                .get_alloc(ptr.alloc_id.0)\n+                                .get_alloc(ptr.alloc_id)\n                                 .unwrap();\n                             assert_eq!(ptr.offset, 0);\n                             // FIXME: check length\n@@ -458,11 +442,7 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(cx.tcx.mk_const(ty::Const {\n-                    val: if cx.tcx.sess.opts.debugging_opts.miri {\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(b as u128)))\n-                    } else {\n-                        ConstVal::Bool(b)\n-                    },\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b as u128))),\n                     ty: cx.tcx.types.bool\n                 }))\n             }).collect()\n@@ -575,9 +555,6 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n     for row in patterns {\n         match *row.kind {\n-            PatternKind::Constant { value: &ty::Const { val: ConstVal::ByteStr(b), .. } } => {\n-                max_fixed_len = cmp::max(max_fixed_len, b.data.len() as u64);\n-            }\n             PatternKind::Constant {\n                 value: &ty::Const {\n                     val: ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))),\n@@ -592,7 +569,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n                     let alloc = cx.tcx\n                         .interpret_interner\n                         .borrow()\n-                        .get_alloc(ptr.alloc_id.0)\n+                        .get_alloc(ptr.alloc_id)\n                         .unwrap();\n                     max_fixed_len = cmp::max(max_fixed_len, alloc.bytes.len() as u64);\n                 }\n@@ -971,7 +948,6 @@ fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n                                     suffix: &[Pattern])\n                                     -> Result<bool, ErrorReported> {\n     let data: &[u8] = match *ctor {\n-        ConstantValue(&ty::Const { val: ConstVal::ByteStr(b), .. }) => b.data,\n         ConstantValue(&ty::Const { val: ConstVal::Value(\n             Value::ByVal(PrimVal::Ptr(ptr))\n         ), ty }) => {\n@@ -983,7 +959,7 @@ fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n             tcx\n                 .interpret_interner\n                 .borrow()\n-                .get_alloc(ptr.alloc_id.0)\n+                .get_alloc(ptr.alloc_id)\n                 .unwrap()\n                 .bytes\n                 .as_ref()\n@@ -1002,11 +978,6 @@ fn slice_pat_covered_by_constructor(tcx: TyCtxt, _span: Span,\n     {\n         match pat.kind {\n             box PatternKind::Constant { value } => match value.val {\n-                ConstVal::Integral(ConstInt::U8(u)) => {\n-                    if u != *ch {\n-                        return Ok(false);\n-                    }\n-                },\n                 ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => {\n                     assert_eq!(b as u8 as u128, b);\n                     if b as u8 != *ch {\n@@ -1120,13 +1091,6 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n         PatternKind::Constant { value } => {\n             match *constructor {\n                 Slice(..) => match value.val {\n-                    ConstVal::ByteStr(b) => {\n-                        if wild_patterns.len() == b.data.len() {\n-                            Some(cx.lower_byte_str_pattern(pat))\n-                        } else {\n-                            None\n-                        }\n-                    }\n                     ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr))) => {\n                         let is_array_ptr = value.ty\n                             .builtin_deref(true, ty::NoPreference)\n@@ -1136,7 +1100,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                         let data_len = cx.tcx\n                             .interpret_interner\n                             .borrow()\n-                            .get_alloc(ptr.alloc_id.0)\n+                            .get_alloc(ptr.alloc_id)\n                             .unwrap()\n                             .bytes\n                             .len();"}, {"sha": "70435c16ff72e88050104e40e58048bf0416ecac", "filename": "src/librustc_mir/const_eval/check.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fcheck.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Lints statically known runtime failures\n+\n+use rustc::mir::*;\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::interpret::{Value, PrimVal};\n+use rustc::middle::const_val::{ConstVal, ConstEvalErr, ErrKind};\n+use rustc::traits;\n+use interpret::{eval_body_as_integer, check_body};\n+use rustc::ty::{TyCtxt, ParamEnv, self};\n+use rustc::ty::Instance;\n+use rustc::ty::layout::LayoutOf;\n+use rustc::hir::def_id::DefId;\n+\n+pub fn check<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    if tcx.is_closure(def_id) {\n+        return;\n+    }\n+    let generics = tcx.generics_of(def_id);\n+    // FIXME: miri should be able to eval stuff that doesn't need info\n+    // from the generics\n+    if generics.parent_types as usize + generics.types.len() > 0 {\n+        return;\n+    }\n+    let mir = &tcx.optimized_mir(def_id);\n+    ConstErrVisitor {\n+        tcx,\n+        def_id,\n+        mir,\n+    }.visit_mir(mir);\n+    let param_env = ParamEnv::empty(traits::Reveal::All);\n+    let instance = Instance::mono(tcx, def_id);\n+    for i in 0.. mir.promoted.len() {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        check_body(tcx, instance, Some(Promoted::new(i)), param_env);\n+    }\n+}\n+\n+struct ConstErrVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx> ConstErrVisitor<'a, 'tcx> {\n+    fn eval_op(&self, op: &Operand<'tcx>) -> Option<u128> {\n+        let op = match *op {\n+            Operand::Constant(ref c) => c,\n+            _ => return None,\n+        };\n+        let param_env = ParamEnv::empty(traits::Reveal::All);\n+        let val = match op.literal {\n+            Literal::Value { value } => match value.val {\n+                ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => b,\n+                _ => return None,\n+            },\n+            Literal::Promoted { index } => {\n+                let instance = Instance::mono(self.tcx, self.def_id);\n+                eval_body_as_integer(self.tcx, param_env, instance, Some(index)).unwrap()\n+            }\n+        };\n+        Some(val)\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for ConstErrVisitor<'a, 'tcx> {\n+    fn visit_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &Terminator<'tcx>,\n+                        location: Location) {\n+        self.super_terminator(block, terminator, location);\n+        match terminator.kind {\n+            TerminatorKind::Assert { cond: Operand::Constant(box Constant {\n+                literal: Literal::Value {\n+                    value: &ty::Const {\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(cond))),\n+                    .. }\n+                }, ..\n+            }), expected, ref msg, .. } if (cond == 1) != expected => {\n+                assert!(cond <= 1);\n+                // If we know we always panic, and the error message\n+                // is also constant, then we can produce a warning.\n+\n+                let kind = match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        let len = match self.eval_op(len) {\n+                            Some(val) => val,\n+                            None => return,\n+                        };\n+                        let index = match self.eval_op(index) {\n+                            Some(val) => val,\n+                            None => return,\n+                        };\n+                        ErrKind::IndexOutOfBounds {\n+                            len: len as u64,\n+                            index: index as u64\n+                        }\n+                    }\n+                    AssertMessage::Math(ref err) => ErrKind::Math(err.clone()),\n+                    AssertMessage::GeneratorResumedAfterReturn |\n+                    // FIXME(oli-obk): can we report a const_err warning here?\n+                    AssertMessage::GeneratorResumedAfterPanic => return,\n+                };\n+                let span = terminator.source_info.span;\n+                let msg = ConstEvalErr{ span, kind };\n+                let scope_info = match self.mir.visibility_scope_info {\n+                    ClearCrossCrate::Set(ref data) => data,\n+                    ClearCrossCrate::Clear => return,\n+                };\n+                let node_id = scope_info[terminator.source_info.scope].lint_root;\n+                self.tcx.lint_node(::rustc::lint::builtin::CONST_ERR,\n+                            node_id,\n+                            msg.span,\n+                            &msg.description().into_oneline().into_owned());\n+            },\n+            _ => {},\n+        }\n+    }\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        self.super_rvalue(rvalue, location);\n+        use rustc::mir::BinOp;\n+        match *rvalue {\n+            Rvalue::BinaryOp(BinOp::Shr, ref lop, ref rop) |\n+            Rvalue::BinaryOp(BinOp::Shl, ref lop, ref rop) => {\n+                let val = match self.eval_op(rop) {\n+                    Some(val) => val,\n+                    None => return,\n+                };\n+                let ty = lop.ty(self.mir, self.tcx);\n+                let param_env = ParamEnv::empty(traits::Reveal::All);\n+                let bits = (self.tcx, param_env).layout_of(ty).unwrap().size.bits();\n+                if val >= bits as u128 {\n+                    let data = &self.mir[location.block];\n+                    let stmt_idx = location.statement_index;\n+                    let source_info = if stmt_idx < data.statements.len() {\n+                        data.statements[stmt_idx].source_info\n+                    } else {\n+                        data.terminator().source_info\n+                    };\n+                    let span = source_info.span;\n+                    let scope_info = match self.mir.visibility_scope_info {\n+                        ClearCrossCrate::Set(ref data) => data,\n+                        ClearCrossCrate::Clear => return,\n+                    };\n+                    let node_id = scope_info[source_info.scope].lint_root;\n+                    self.tcx.lint_node(\n+                        ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                        node_id,\n+                        span,\n+                        \"bitshift exceeds the type's number of bits\");\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "370b8681ba648a501122bb668cd994bac061c378", "filename": "src/librustc_mir/const_eval/eval.rs", "status": "modified", "additions": 86, "deletions": 621, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -9,41 +9,18 @@\n // except according to those terms.\n \n use rustc::middle::const_val::ConstVal::*;\n-use rustc::middle::const_val::ConstAggregate::*;\n use rustc::middle::const_val::ErrKind::*;\n-use rustc::middle::const_val::{ByteArray, ConstVal, ConstEvalErr, EvalResult, ErrKind};\n+use rustc::middle::const_val::{ConstVal, ErrKind};\n \n-use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::util::IntTypeExt;\n-use rustc::ty::subst::{Substs, Subst};\n-use rustc::util::common::ErrorReported;\n-use rustc::util::nodemap::NodeMap;\n+use rustc::ty::subst::Substs;\n \n-use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::attr;\n-use rustc::hir::{self, Expr};\n \n use std::cmp::Ordering;\n \n use rustc_const_math::*;\n-macro_rules! signal {\n-    ($e:expr, $exn:expr) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n-    }\n-}\n-\n-macro_rules! math {\n-    ($e:expr, $op:expr) => {\n-        match $op {\n-            Ok(val) => val,\n-            Err(e) => signal!($e, ErrKind::from(e)),\n-        }\n-    }\n-}\n \n /// * `DefId` is the id of the constant.\n /// * `Substs` is the monomorphized substitutions for the expression.\n@@ -58,591 +35,94 @@ pub fn lookup_const_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ).map(|instance| (instance.def_id(), instance.substs))\n }\n \n-pub struct ConstContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    substs: &'tcx Substs<'tcx>,\n-    fn_args: Option<NodeMap<&'tcx ty::Const<'tcx>>>\n-}\n-\n-impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n-               tables: &'a ty::TypeckTables<'tcx>)\n-               -> Self {\n-        ConstContext {\n-            tcx,\n-            param_env: param_env_and_substs.param_env,\n-            tables,\n-            substs: param_env_and_substs.value,\n-            fn_args: None\n-        }\n-    }\n-\n-    /// Evaluate a constant expression in a context where the expression isn't\n-    /// guaranteed to be evaluable.\n-    pub fn eval(&self, e: &'tcx Expr) -> EvalResult<'tcx> {\n-        if self.tables.tainted_by_errors {\n-            signal!(e, TypeckError);\n-        }\n-        eval_const_expr_partial(self, e)\n-    }\n-}\n-\n-type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n-\n-fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &'tcx Expr) -> EvalResult<'tcx> {\n-    trace!(\"eval_const_expr_partial: {:?}\", e);\n-    let tcx = cx.tcx;\n-    let ty = cx.tables.expr_ty(e).subst(tcx, cx.substs);\n-    let mk_const = |val| tcx.mk_const(ty::Const { val, ty });\n-\n-    let result = match e.node {\n-      hir::ExprUnary(hir::UnNeg, ref inner) => {\n-        // unary neg literals already got their sign during creation\n-        if let hir::ExprLit(ref lit) = inner.node {\n-            return match lit_to_const(&lit.node, tcx, ty, true) {\n-                Ok(val) => Ok(mk_const(val)),\n-                Err(err) => signal!(e, err),\n-            };\n-        }\n-        mk_const(match cx.eval(inner)?.val {\n-          Float(f) => Float(-f),\n-          Integral(i) => Integral(math!(e, -i)),\n-          _ => signal!(e, TypeckError)\n-        })\n-      }\n-      hir::ExprUnary(hir::UnNot, ref inner) => {\n-        mk_const(match cx.eval(inner)?.val {\n-          Integral(i) => Integral(math!(e, !i)),\n-          Bool(b) => Bool(!b),\n-          _ => signal!(e, TypeckError)\n-        })\n-      }\n-      hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n-      hir::ExprBinary(op, ref a, ref b) => {\n-        // technically, if we don't have type hints, but integral eval\n-        // gives us a type through a type-suffix, cast or const def type\n-        // we need to re-eval the other value of the BinOp if it was\n-        // not inferred\n-        mk_const(match (cx.eval(a)?.val, cx.eval(b)?.val) {\n-          (Float(a), Float(b)) => {\n-            use std::cmp::Ordering::*;\n-            match op.node {\n-              hir::BiAdd => Float(math!(e, a + b)),\n-              hir::BiSub => Float(math!(e, a - b)),\n-              hir::BiMul => Float(math!(e, a * b)),\n-              hir::BiDiv => Float(math!(e, a / b)),\n-              hir::BiRem => Float(math!(e, a % b)),\n-              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n-              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n-              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n-              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n-              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n-              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => span_bug!(e.span, \"typeck error\"),\n-            }\n-          }\n-          (Integral(a), Integral(b)) => {\n-            use std::cmp::Ordering::*;\n-            match op.node {\n-              hir::BiAdd => Integral(math!(e, a + b)),\n-              hir::BiSub => Integral(math!(e, a - b)),\n-              hir::BiMul => Integral(math!(e, a * b)),\n-              hir::BiDiv => Integral(math!(e, a / b)),\n-              hir::BiRem => Integral(math!(e, a % b)),\n-              hir::BiBitAnd => Integral(math!(e, a & b)),\n-              hir::BiBitOr => Integral(math!(e, a | b)),\n-              hir::BiBitXor => Integral(math!(e, a ^ b)),\n-              hir::BiShl => Integral(math!(e, a << b)),\n-              hir::BiShr => Integral(math!(e, a >> b)),\n-              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n-              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n-              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n-              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n-              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n-              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => span_bug!(e.span, \"typeck error\"),\n-            }\n-          }\n-          (Bool(a), Bool(b)) => {\n-            Bool(match op.node {\n-              hir::BiAnd => a && b,\n-              hir::BiOr => a || b,\n-              hir::BiBitXor => a ^ b,\n-              hir::BiBitAnd => a & b,\n-              hir::BiBitOr => a | b,\n-              hir::BiEq => a == b,\n-              hir::BiNe => a != b,\n-              hir::BiLt => a < b,\n-              hir::BiLe => a <= b,\n-              hir::BiGe => a >= b,\n-              hir::BiGt => a > b,\n-              _ => span_bug!(e.span, \"typeck error\"),\n-             })\n-          }\n-          (Char(a), Char(b)) => {\n-            Bool(match op.node {\n-              hir::BiEq => a == b,\n-              hir::BiNe => a != b,\n-              hir::BiLt => a < b,\n-              hir::BiLe => a <= b,\n-              hir::BiGe => a >= b,\n-              hir::BiGt => a > b,\n-              _ => span_bug!(e.span, \"typeck error\"),\n-             })\n-          }\n-\n-          _ => signal!(e, MiscBinaryOp),\n-        })\n-      }\n-      hir::ExprCast(ref base, _) => {\n-        let base_val = cx.eval(base)?;\n-        let base_ty = cx.tables.expr_ty(base).subst(tcx, cx.substs);\n-        if ty == base_ty {\n-            base_val\n-        } else {\n-            match cast_const(tcx, base_val.val, ty) {\n-                Ok(val) => mk_const(val),\n-                Err(kind) => signal!(e, kind),\n-            }\n-        }\n-      }\n-      hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_substs(e.hir_id).subst(tcx, cx.substs);\n-          match cx.tables.qpath_def(qpath, e.hir_id) {\n-              Def::Const(def_id) |\n-              Def::AssociatedConst(def_id) => {\n-                    let substs = tcx.normalize_associated_type_in_env(&substs, cx.param_env);\n-                    match tcx.at(e.span).const_eval(cx.param_env.and((def_id, substs))) {\n-                        Ok(val) => val,\n-                        Err(ConstEvalErr { kind: TypeckError, .. }) => {\n-                            signal!(e, TypeckError);\n-                        }\n-                        Err(err) => {\n-                            debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n-                            signal!(e, ErroneousReferencedConstant(box err))\n-                        },\n-                    }\n-              },\n-              Def::VariantCtor(variant_def, CtorKind::Const) => {\n-                mk_const(Variant(variant_def))\n-              }\n-              Def::VariantCtor(_, CtorKind::Fn) => {\n-                  signal!(e, UnimplementedConstVal(\"enum variants\"));\n-              }\n-              Def::StructCtor(_, CtorKind::Const) => {\n-                  mk_const(Aggregate(Struct(&[])))\n-              }\n-              Def::StructCtor(_, CtorKind::Fn) => {\n-                  signal!(e, UnimplementedConstVal(\"tuple struct constructors\"))\n-              }\n-              Def::Local(id) => {\n-                  debug!(\"Def::Local({:?}): {:?}\", id, cx.fn_args);\n-                  if let Some(&val) = cx.fn_args.as_ref().and_then(|args| args.get(&id)) {\n-                      val\n-                  } else {\n-                      signal!(e, NonConstPath);\n-                  }\n-              },\n-              Def::Method(id) | Def::Fn(id) => mk_const(Function(id, substs)),\n-              Def::Err => span_bug!(e.span, \"typeck error\"),\n-              _ => signal!(e, NonConstPath),\n-          }\n-      }\n-      hir::ExprCall(ref callee, ref args) => {\n-          let (def_id, substs) = match cx.eval(callee)?.val {\n-              Function(def_id, substs) => (def_id, substs),\n-              _ => signal!(e, TypeckError),\n-          };\n-\n-          if tcx.fn_sig(def_id).abi() == Abi::RustIntrinsic {\n-            let layout_of = |ty: Ty<'tcx>| {\n-                let ty = tcx.erase_regions(&ty);\n-                tcx.at(e.span).layout_of(cx.param_env.and(ty)).map_err(|err| {\n-                    ConstEvalErr { span: e.span, kind: LayoutError(err) }\n-                })\n-            };\n-            match &tcx.item_name(def_id)[..] {\n-                \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size.bytes();\n-                    return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n-                        tcx.sess.target.usize_ty).unwrap()))));\n-                }\n-                \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align.abi();\n-                    return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n-                        tcx.sess.target.usize_ty).unwrap()))));\n-                }\n-                \"type_id\" => {\n-                    let type_id = tcx.type_id_hash(substs.type_at(0));\n-                    return Ok(mk_const(Integral(U64(type_id))));\n-                }\n-                _ => signal!(e, TypeckError)\n-            }\n-          }\n-\n-          let body = if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-            if let Some(fn_like) = FnLikeNode::from_node(tcx.hir.get(node_id)) {\n-                if fn_like.constness() == hir::Constness::Const {\n-                    tcx.hir.body(fn_like.body())\n-                } else {\n-                    signal!(e, TypeckError)\n-                }\n-            } else {\n-                signal!(e, TypeckError)\n-            }\n-          } else {\n-            if tcx.is_const_fn(def_id) {\n-                tcx.extern_const_body(def_id).body\n-            } else {\n-                signal!(e, TypeckError)\n-            }\n-          };\n-\n-          let arg_ids = body.arguments.iter().map(|arg| match arg.pat.node {\n-               hir::PatKind::Binding(_, canonical_id, _, _) => Some(canonical_id),\n-               _ => None\n-           }).collect::<Vec<_>>();\n-          assert_eq!(arg_ids.len(), args.len());\n-\n-          let mut call_args = NodeMap();\n-          for (arg, arg_expr) in arg_ids.into_iter().zip(args.iter()) {\n-              let arg_val = cx.eval(arg_expr)?;\n-              debug!(\"const call arg: {:?}\", arg);\n-              if let Some(id) = arg {\n-                assert!(call_args.insert(id, arg_val).is_none());\n-              }\n-          }\n-          debug!(\"const call({:?})\", call_args);\n-          let callee_cx = ConstContext {\n-            tcx,\n-            param_env: cx.param_env,\n-            tables: tcx.typeck_tables_of(def_id),\n-            substs,\n-            fn_args: Some(call_args)\n-          };\n-          callee_cx.eval(&body.value)?\n-      },\n-      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ty, false) {\n-          Ok(val) => mk_const(val),\n-          Err(err) => signal!(e, err),\n-      },\n-      hir::ExprBlock(ref block) => {\n-        match block.expr {\n-            Some(ref expr) => cx.eval(expr)?,\n-            None => mk_const(Aggregate(Tuple(&[]))),\n-        }\n-      }\n-      hir::ExprType(ref e, _) => cx.eval(e)?,\n-      hir::ExprTup(ref fields) => {\n-        let values = fields.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n-        mk_const(Aggregate(Tuple(tcx.alloc_const_slice(&values))))\n-      }\n-      hir::ExprStruct(_, ref fields, _) => {\n-        mk_const(Aggregate(Struct(tcx.alloc_name_const_slice(&fields.iter().map(|f| {\n-            cx.eval(&f.expr).map(|v| (f.name.node, v))\n-        }).collect::<Result<Vec<_>, _>>()?))))\n-      }\n-      hir::ExprIndex(ref arr, ref idx) => {\n-        if !tcx.features().const_indexing {\n-            signal!(e, IndexOpFeatureGated);\n-        }\n-        let arr = cx.eval(arr)?;\n-        let idx = match cx.eval(idx)?.val {\n-            Integral(Usize(i)) => i.as_u64(),\n-            _ => signal!(idx, IndexNotUsize),\n-        };\n-        assert_eq!(idx as usize as u64, idx);\n-        match arr.val {\n-            Aggregate(Array(v)) => {\n-                if let Some(&elem) = v.get(idx as usize) {\n-                    elem\n-                } else {\n-                    let n = v.len() as u64;\n-                    signal!(e, IndexOutOfBounds { len: n, index: idx })\n-                }\n-            }\n-\n-            Aggregate(Repeat(.., n)) if idx >= n => {\n-                signal!(e, IndexOutOfBounds { len: n, index: idx })\n-            }\n-            Aggregate(Repeat(elem, _)) => elem,\n-\n-            ByteStr(b) if idx >= b.data.len() as u64 => {\n-                signal!(e, IndexOutOfBounds { len: b.data.len() as u64, index: idx })\n-            }\n-            ByteStr(b) => {\n-                mk_const(Integral(U8(b.data[idx as usize])))\n-            },\n-\n-            _ => signal!(e, IndexedNonVec),\n-        }\n-      }\n-      hir::ExprArray(ref v) => {\n-        let values = v.iter().map(|e| cx.eval(e)).collect::<Result<Vec<_>, _>>()?;\n-        mk_const(Aggregate(Array(tcx.alloc_const_slice(&values))))\n-      }\n-      hir::ExprRepeat(ref elem, _) => {\n-          let n = match ty.sty {\n-            ty::TyArray(_, n) => n.val.unwrap_u64(),\n-            _ => span_bug!(e.span, \"typeck error\")\n-          };\n-          mk_const(Aggregate(Repeat(cx.eval(elem)?, n)))\n-      },\n-      hir::ExprTupField(ref base, index) => {\n-        if let Aggregate(Tuple(fields)) = cx.eval(base)?.val {\n-            fields[index.node]\n-        } else {\n-            span_bug!(base.span, \"{:#?}\", cx.eval(base)?.val);\n-            //signal!(base, ExpectedConstTuple);\n-        }\n-      }\n-      hir::ExprField(ref base, field_name) => {\n-        if let Aggregate(Struct(fields)) = cx.eval(base)?.val {\n-            if let Some(&(_, f)) = fields.iter().find(|&&(name, _)| name == field_name.node) {\n-                f\n-            } else {\n-                signal!(e, MissingStructField);\n-            }\n-        } else {\n-            signal!(base, ExpectedConstStruct);\n-        }\n-      }\n-      hir::ExprAddrOf(..) => signal!(e, UnimplementedConstVal(\"address operator\")),\n-      _ => signal!(e, MiscCatchAll)\n-    };\n-\n-    Ok(result)\n-}\n-\n-fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            val: ConstInt,\n-                            ty: Ty<'tcx>)\n-                            -> CastResult<'tcx> {\n-    let v = val.to_u128_unchecked();\n-    match ty.sty {\n-        ty::TyBool if v == 0 => Ok(Bool(false)),\n-        ty::TyBool if v == 1 => Ok(Bool(true)),\n-        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i128 as i8))),\n-        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i128 as i16))),\n-        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i128 as i32))),\n-        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n-        ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n-        ty::TyInt(ast::IntTy::Isize) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.isize_ty))))\n-        },\n-        ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n-        ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n-        ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n-        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n-        ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n-        ty::TyUint(ast::UintTy::Usize) => {\n-            Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.usize_ty))))\n-        },\n-        ty::TyFloat(fty) => {\n-            if let Some(i) = val.to_u128() {\n-                Ok(Float(ConstFloat::from_u128(i, fty)))\n-            } else {\n-                // The value must be negative, go through signed integers.\n-                let i = val.to_u128_unchecked() as i128;\n-                Ok(Float(ConstFloat::from_i128(i, fty)))\n-            }\n-        }\n-        ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n-        ty::TyChar => match val {\n-            U8(u) => Ok(Char(u as char)),\n-            _ => bug!(),\n-        },\n-        _ => Err(CannotCast),\n-    }\n-}\n-\n-fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              val: ConstFloat,\n-                              ty: Ty<'tcx>) -> CastResult<'tcx> {\n-    let int_width = |ty| {\n-        ty::layout::Integer::from_attr(tcx, ty).size().bits() as usize\n-    };\n-    match ty.sty {\n-        ty::TyInt(ity) => {\n-            if let Some(i) = val.to_i128(int_width(attr::SignedInt(ity))) {\n-                cast_const_int(tcx, I128(i), ty)\n-            } else {\n-                Err(CannotCast)\n-            }\n-        }\n-        ty::TyUint(uty) => {\n-            if let Some(i) = val.to_u128(int_width(attr::UnsignedInt(uty))) {\n-                cast_const_int(tcx, U128(i), ty)\n-            } else {\n-                Err(CannotCast)\n-            }\n-        }\n-        ty::TyFloat(fty) => Ok(Float(val.convert(fty))),\n-        _ => Err(CannotCast),\n-    }\n-}\n-\n-fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        val: ConstVal<'tcx>,\n-                        ty: Ty<'tcx>)\n-                        -> CastResult<'tcx> {\n-    match val {\n-        Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, U8(b as u8), ty),\n-        Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n-        Variant(v) => {\n-            let adt = tcx.adt_def(tcx.parent_def_id(v).unwrap());\n-            let idx = adt.variant_index_with_id(v);\n-            cast_const_int(tcx, adt.discriminant_for_variant(tcx, idx), ty)\n-        }\n-        Function(..) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n-        ByteStr(b) => match ty.sty {\n-            ty::TyRawPtr(_) => {\n-                Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n-            },\n-            ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyArray(ty, n) => {\n-                    let n = n.val.unwrap_u64();\n-                    if ty == tcx.types.u8 && n == b.data.len() as u64 {\n-                        Ok(val)\n-                    } else {\n-                        Err(CannotCast)\n-                    }\n-                }\n-                ty::TySlice(_) => {\n-                    Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to slice\"))\n-                },\n-                _ => Err(CannotCast),\n-            },\n-            _ => Err(CannotCast),\n-        },\n-        Str(s) => match ty.sty {\n-            ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting a str to a raw ptr\")),\n-            ty::TyRef(_, ty::TypeAndMut { ref ty, mutbl: hir::MutImmutable }) => match ty.sty {\n-                ty::TyStr => Ok(Str(s)),\n-                _ => Err(CannotCast),\n-            },\n-            _ => Err(CannotCast),\n-        },\n-        _ => Err(CannotCast),\n-    }\n-}\n-\n pub fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          mut ty: Ty<'tcx>,\n+                          ty: Ty<'tcx>,\n                           neg: bool)\n                           -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n     use syntax::ast::*;\n-    use syntax::ast::LitIntType::*;\n \n-    if tcx.sess.opts.debugging_opts.miri {\n-        use rustc::mir::interpret::*;\n-        let lit = match *lit {\n-            LitKind::Str(ref s, _) => {\n-                let s = s.as_str();\n-                let id = tcx.allocate_cached(s.as_bytes());\n-                let ptr = MemoryPointer::new(AllocId(id), 0);\n-                Value::ByValPair(\n-                    PrimVal::Ptr(ptr),\n-                    PrimVal::from_u128(s.len() as u128),\n-                )\n-            },\n-            LitKind::ByteStr(ref data) => {\n-                let id = tcx.allocate_cached(data);\n-                let ptr = MemoryPointer::new(AllocId(id), 0);\n-                Value::ByVal(PrimVal::Ptr(ptr))\n-            },\n-            LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n-            LitKind::Int(n, _) if neg => {\n-                let n = n as i128;\n-                let n = n.overflowing_neg().0;\n-                Value::ByVal(PrimVal::Bytes(n as u128))\n-            },\n-            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(n as u128)),\n-            LitKind::Float(n, fty) => {\n-                let n = n.as_str();\n-                let mut f = parse_float(&n, fty)?;\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n-            }\n-            LitKind::FloatUnsuffixed(n) => {\n-                let fty = match ty.sty {\n-                    ty::TyFloat(fty) => fty,\n-                    _ => bug!()\n-                };\n-                let n = n.as_str();\n-                let mut f = parse_float(&n, fty)?;\n-                if neg {\n-                    f = -f;\n-                }\n-                let bits = f.bits;\n-                Value::ByVal(PrimVal::Bytes(bits))\n-            }\n-            LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n-            LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n-        };\n-        return Ok(ConstVal::Value(lit));\n-    }\n-\n-    if let ty::TyAdt(adt, _) = ty.sty {\n-        if adt.is_enum() {\n-            ty = adt.repr.discr_type().to_ty(tcx)\n-        }\n-    }\n-\n-    match *lit {\n-        LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n-        LitKind::ByteStr(ref data) => Ok(ByteStr(ByteArray { data })),\n-        LitKind::Byte(n) => Ok(Integral(U8(n))),\n-        LitKind::Int(n, hint) => {\n-            match (&ty.sty, hint) {\n-                (&ty::TyInt(ity), _) |\n-                (_, Signed(ity)) => {\n-                    let mut n = n as i128;\n-                    if neg {\n-                        n = n.overflowing_neg().0;\n-                    }\n-                    Ok(Integral(ConstInt::new_signed_truncating(n,\n-                        ity, tcx.sess.target.isize_ty)))\n-                }\n-                (&ty::TyUint(uty), _) |\n-                (_, Unsigned(uty)) => {\n-                    Ok(Integral(ConstInt::new_unsigned_truncating(n,\n-                        uty, tcx.sess.target.usize_ty)))\n-                }\n-                _ => bug!()\n-            }\n-        }\n+    use rustc::mir::interpret::*;\n+    let lit = match *lit {\n+        LitKind::Str(ref s, _) => {\n+            let s = s.as_str();\n+            let id = tcx.allocate_cached(s.as_bytes());\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByValPair(\n+                PrimVal::Ptr(ptr),\n+                PrimVal::from_u128(s.len() as u128),\n+            )\n+        },\n+        LitKind::ByteStr(ref data) => {\n+            let id = tcx.allocate_cached(data);\n+            let ptr = MemoryPointer::new(id, 0);\n+            Value::ByVal(PrimVal::Ptr(ptr))\n+        },\n+        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+        LitKind::Int(n, _) => {\n+            enum Int {\n+                Signed(IntTy),\n+                Unsigned(UintTy),\n+            }\n+            let ty = match ty.sty {\n+                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n+                ty::TyInt(other) => Int::Signed(other),\n+                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n+                ty::TyUint(other) => Int::Unsigned(other),\n+                _ => bug!(),\n+            };\n+            let n = match ty {\n+                // FIXME(oli-obk): are these casts correct?\n+                Int::Signed(IntTy::I8) if neg =>\n+                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I16) if neg =>\n+                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I32) if neg =>\n+                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I64) if neg =>\n+                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n+                Int::Signed(IntTy::I128) if neg =>\n+                    (n as i128).overflowing_neg().0 as u128,\n+                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n+                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n+                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n+                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n+                Int::Signed(IntTy::I128) => n,\n+                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n+                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n+                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n+                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n+                Int::Unsigned(UintTy::U128) => n,\n+                _ => bug!(),\n+            };\n+            Value::ByVal(PrimVal::Bytes(n))\n+        },\n         LitKind::Float(n, fty) => {\n-            let mut f = parse_float(&n.as_str(), fty)?;\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n             if neg {\n                 f = -f;\n             }\n-            Ok(Float(f))\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n         }\n         LitKind::FloatUnsuffixed(n) => {\n             let fty = match ty.sty {\n                 ty::TyFloat(fty) => fty,\n                 _ => bug!()\n             };\n-            let mut f = parse_float(&n.as_str(), fty)?;\n+            let n = n.as_str();\n+            let mut f = parse_float(&n, fty)?;\n             if neg {\n                 f = -f;\n             }\n-            Ok(Float(f))\n+            let bits = f.bits;\n+            Value::ByVal(PrimVal::Bytes(bits))\n         }\n-        LitKind::Bool(b) => Ok(Bool(b)),\n-        LitKind::Char(c) => Ok(Char(c)),\n-    }\n+        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n+    };\n+    Ok(ConstVal::Value(lit))\n }\n \n fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n@@ -657,41 +137,26 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n     use rustc::mir::interpret::{Value, PrimVal};\n     match (a, b) {\n-        (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n-        (&Char(a), &Char(b)) => Some(a.cmp(&b)),\n         (&Value(Value::ByVal(PrimVal::Bytes(a))),\n          &Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n-            Some(if ty.is_signed() {\n-                (a as i128).cmp(&(b as i128))\n-            } else {\n-                a.cmp(&b)\n-            })\n+            match ty.sty {\n+                ty::TyFloat(ty) => {\n+                    let l = ConstFloat {\n+                        bits: a,\n+                        ty,\n+                    };\n+                    let r = ConstFloat {\n+                        bits: b,\n+                        ty,\n+                    };\n+                    // FIXME(oli-obk): report cmp errors?\n+                    l.try_cmp(r).ok()\n+                },\n+                ty::TyInt(_) => Some((a as i128).cmp(&(b as i128))),\n+                _ => Some(a.cmp(&b)),\n+            }\n         },\n         _ if a == b => Some(Ordering::Equal),\n         _ => None,\n     }\n }\n-\n-impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n-    pub fn compare_lit_exprs(&self,\n-                             a: &'tcx Expr,\n-                             b: &'tcx Expr) -> Result<Option<Ordering>, ErrorReported> {\n-        let tcx = self.tcx;\n-        let ty = self.tables.expr_ty(a);\n-        let a = match self.eval(a) {\n-            Ok(a) => a,\n-            Err(e) => {\n-                e.report(tcx, a.span, \"expression\");\n-                return Err(ErrorReported);\n-            }\n-        };\n-        let b = match self.eval(b) {\n-            Ok(b) => b,\n-            Err(e) => {\n-                e.report(tcx, b.span, \"expression\");\n-                return Err(ErrorReported);\n-            }\n-        };\n-        Ok(compare_const_vals(&a.val, &b.val, ty))\n-    }\n-}"}, {"sha": "f47dc61c27c4d86808a56955a74067f9d2eb97f5", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -14,5 +14,6 @@ mod eval;\n mod _match;\n pub mod check_match;\n pub mod pattern;\n+pub mod check;\n \n pub use self::eval::*;"}, {"sha": "48438e7dbfd58ee1cdce92156598a55262380059", "filename": "src/librustc_mir/const_eval/pattern.rs", "status": "modified", "additions": 99, "deletions": 116, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use const_eval::eval;\n use interpret::{const_val_field, const_discr};\n \n-use rustc::middle::const_val::{ConstEvalErr, ConstVal, ConstAggregate};\n+use rustc::middle::const_val::{ConstEvalErr, ErrKind, ConstVal};\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{Value, PrimVal};\n use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+use const_eval::eval::compare_const_vals;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -114,16 +114,7 @@ pub enum PatternKind<'tcx> {\n \n fn print_const_val(value: &ty::Const, f: &mut fmt::Formatter) -> fmt::Result {\n     match value.val {\n-        ConstVal::Float(ref x) => write!(f, \"{}\", x),\n-        ConstVal::Integral(ref i) => write!(f, \"{}\", i),\n-        ConstVal::Str(ref s) => write!(f, \"{:?}\", &s[..]),\n-        ConstVal::ByteStr(b) => write!(f, \"{:?}\", b.data),\n-        ConstVal::Bool(b) => write!(f, \"{:?}\", b),\n-        ConstVal::Char(c) => write!(f, \"{:?}\", c),\n         ConstVal::Value(v) => print_miri_value(v, value.ty, f),\n-        ConstVal::Variant(_) |\n-        ConstVal::Function(..) |\n-        ConstVal::Aggregate(_) |\n         ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n }\n@@ -366,10 +357,27 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Lit(ref value) => self.lower_lit(value),\n \n-            PatKind::Range(ref lo, ref hi, end) => {\n-                match (self.lower_lit(lo), self.lower_lit(hi)) {\n+            PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n+                match (self.lower_lit(lo_expr), self.lower_lit(hi_expr)) {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n+                        use std::cmp::Ordering;\n+                        match (end, compare_const_vals(&lo.val, &hi.val, ty).unwrap()) {\n+                            (RangeEnd::Excluded, Ordering::Less) => {},\n+                            (RangeEnd::Excluded, _) => span_err!(\n+                                self.tcx.sess,\n+                                lo_expr.span,\n+                                E0579,\n+                                \"lower range bound must be less than upper\",\n+                            ),\n+                            (RangeEnd::Included, Ordering::Greater) => {\n+                                struct_span_err!(self.tcx.sess, lo_expr.span, E0030,\n+                                    \"lower range bound must be less than or equal to upper\")\n+                                    .span_label(lo_expr.span, \"lower bound larger than upper bound\")\n+                                    .emit();\n+                            },\n+                            (RangeEnd::Included, _) => {}\n+                        }\n                         PatternKind::Range { lo, hi, end }\n                     }\n                     _ => PatternKind::Wild\n@@ -487,7 +495,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(def, ty, subpatterns)\n+                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n@@ -519,7 +527,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(def, ty, subpatterns)\n+                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n             }\n         };\n \n@@ -610,6 +618,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn lower_variant_or_leaf(\n         &mut self,\n         def: Def,\n+        span: Span,\n         ty: Ty<'tcx>,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n@@ -640,7 +649,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            _ => bug!()\n+            _ => {\n+                self.errors.push(PatternError::ConstEval(ConstEvalErr {\n+                    span,\n+                    kind: ErrKind::NonConstPath,\n+                }));\n+                PatternKind::Wild\n+            }\n         }\n     }\n \n@@ -660,26 +675,21 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 let substs = self.tables.node_substs(id);\n                 match self.tcx.at(span).const_eval(self.param_env.and((def_id, substs))) {\n                     Ok(value) => {\n-                        if self.tcx.sess.opts.debugging_opts.miri {\n-                            if let ConstVal::Value(_) = value.val {} else {\n-                                panic!(\"const eval produced non-miri value: {:#?}\", value);\n-                            }\n-                        }\n                         let instance = ty::Instance::resolve(\n                             self.tcx,\n                             self.param_env,\n                             def_id,\n                             substs,\n                         ).unwrap();\n-                        return self.const_to_pat(instance, value, span)\n+                        return self.const_to_pat(instance, value, id, span)\n                     },\n                     Err(e) => {\n                         self.errors.push(PatternError::ConstEval(e));\n                         PatternKind::Wild\n                     }\n                 }\n             }\n-            _ => self.lower_variant_or_leaf(def, ty, vec![]),\n+            _ => self.lower_variant_or_leaf(def, span, ty, vec![]),\n         };\n \n         Pattern {\n@@ -690,83 +700,75 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n-        if self.tcx.sess.opts.debugging_opts.miri {\n-            return match expr.node {\n-                hir::ExprLit(ref lit) => {\n-                    let ty = self.tables.expr_ty(expr);\n-                    match super::eval::lit_to_const(&lit.node, self.tcx, ty, false) {\n-                        Ok(value) => PatternKind::Constant {\n-                            value: self.tcx.mk_const(ty::Const {\n-                                ty,\n-                                val: value,\n-                            }),\n-                        },\n-                        Err(e) => {\n-                            self.errors.push(PatternError::ConstEval(ConstEvalErr {\n-                                span: lit.span,\n-                                kind: e,\n-                            }));\n-                            PatternKind::Wild\n-                        },\n-                    }\n-                },\n-                hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n-                hir::ExprUnary(hir::UnNeg, ref expr) => {\n-                    let ty = self.tables.expr_ty(expr);\n-                    let lit = match expr.node {\n-                        hir::ExprLit(ref lit) => lit,\n-                        _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n-                    };\n-                    match super::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n-                        Ok(value) => PatternKind::Constant {\n-                            value: self.tcx.mk_const(ty::Const {\n-                                ty,\n-                                val: value,\n-                            }),\n-                        },\n-                        Err(e) => {\n-                            self.errors.push(PatternError::ConstEval(ConstEvalErr {\n-                                span: lit.span,\n-                                kind: e,\n-                            }));\n-                            PatternKind::Wild\n-                        },\n-                    }\n+        match expr.node {\n+            hir::ExprLit(ref lit) => {\n+                let ty = self.tables.expr_ty(expr);\n+                match super::eval::lit_to_const(&lit.node, self.tcx, ty, false) {\n+                    Ok(val) => {\n+                        let instance = ty::Instance::new(\n+                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n+                            self.substs,\n+                        );\n+                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n+                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n+                    },\n+                    Err(e) => {\n+                        self.errors.push(PatternError::ConstEval(ConstEvalErr {\n+                            span: lit.span,\n+                            kind: e,\n+                        }));\n+                        PatternKind::Wild\n+                    },\n                 }\n-                _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n-            }\n-        }\n-        let const_cx = eval::ConstContext::new(self.tcx,\n-                                               self.param_env.and(self.substs),\n-                                               self.tables);\n-        match const_cx.eval(expr) {\n-            Ok(value) => {\n-                if let ConstVal::Variant(def_id) = value.val {\n-                    let ty = self.tables.expr_ty(expr);\n-                    self.lower_variant_or_leaf(Def::Variant(def_id), ty, vec![])\n-                } else {\n-                    PatternKind::Constant { value }\n+            },\n+            hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n+            hir::ExprUnary(hir::UnNeg, ref expr) => {\n+                let ty = self.tables.expr_ty(expr);\n+                let lit = match expr.node {\n+                    hir::ExprLit(ref lit) => lit,\n+                    _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n+                };\n+                match super::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n+                    Ok(value) => PatternKind::Constant {\n+                        value: self.tcx.mk_const(ty::Const {\n+                            ty,\n+                            val: value,\n+                        }),\n+                    },\n+                    Err(e) => {\n+                        self.errors.push(PatternError::ConstEval(ConstEvalErr {\n+                            span: lit.span,\n+                            kind: e,\n+                        }));\n+                        PatternKind::Wild\n+                    },\n                 }\n             }\n-            Err(e) => {\n-                self.errors.push(PatternError::ConstEval(e));\n-                PatternKind::Wild\n-            }\n+            _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n         }\n     }\n \n     fn const_to_pat(\n         &self,\n         instance: ty::Instance<'tcx>,\n         cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n         debug!(\"const_to_pat: cv={:#?}\", cv);\n         let kind = match cv.ty.sty {\n             ty::TyFloat(_) => {\n-                self.tcx.sess.span_err(span, \"floating point constants cannot be used in patterns\");\n-                PatternKind::Wild\n-            }\n+                let id = self.tcx.hir.hir_to_node_id(id);\n+                self.tcx.lint_node(\n+                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                    id,\n+                    span,\n+                    \"floating-point types cannot be used in patterns\",\n+                );\n+                PatternKind::Constant {\n+                    value: cv,\n+                }\n+            },\n             ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n@@ -803,30 +805,18 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 let field = Field::new(i);\n                                 let val = match cv.val {\n                                     ConstVal::Value(miri) => const_val_field(\n-                                        self.tcx, self.param_env, instance, Some(variant_index), field, miri, cv.ty,\n+                                        self.tcx, self.param_env, instance,\n+                                        Some(variant_index), field, miri, cv.ty,\n                                     ).unwrap(),\n                                     _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                                 };\n                                 FieldPattern {\n                                     field,\n-                                    pattern: self.const_to_pat(instance, val, span),\n+                                    pattern: self.const_to_pat(instance, val, id, span),\n                                 }\n                             }).collect(),\n                         }\n                     },\n-                    ConstVal::Variant(var_did) => {\n-                        let variant_index = adt_def\n-                            .variants\n-                            .iter()\n-                            .position(|var| var.did == var_did)\n-                            .unwrap();\n-                        PatternKind::Variant {\n-                            adt_def,\n-                            substs,\n-                            variant_index,\n-                            subpatterns: Vec::new(),\n-                        }\n-                    }\n                     _ => return Pattern {\n                         span,\n                         ty: cv.ty,\n@@ -839,20 +829,17 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             ty::TyAdt(adt_def, _) => {\n                 let struct_var = adt_def.struct_variant();\n                 PatternKind::Leaf {\n-                    subpatterns: struct_var.fields.iter().enumerate().map(|(i, f)| {\n+                    subpatterns: struct_var.fields.iter().enumerate().map(|(i, _)| {\n                         let field = Field::new(i);\n                         let val = match cv.val {\n-                            ConstVal::Aggregate(ConstAggregate::Struct(consts)) => {\n-                                consts.iter().find(|&&(name, _)| name == f.name).unwrap().1\n-                            },\n                             ConstVal::Value(miri) => const_val_field(\n                                 self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n                             ).unwrap(),\n                             _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                         };\n                         FieldPattern {\n                             field,\n-                            pattern: self.const_to_pat(instance, val, span),\n+                            pattern: self.const_to_pat(instance, val, id, span),\n                         }\n                     }).collect()\n                 }\n@@ -862,37 +849,33 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     subpatterns: (0..fields.len()).map(|i| {\n                         let field = Field::new(i);\n                         let val = match cv.val {\n-                            ConstVal::Aggregate(ConstAggregate::Tuple(consts)) => consts[i],\n                             ConstVal::Value(miri) => const_val_field(\n                                 self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n                             ).unwrap(),\n                             _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                         };\n                         FieldPattern {\n                             field,\n-                            pattern: self.const_to_pat(instance, val, span),\n+                            pattern: self.const_to_pat(instance, val, id, span),\n                         }\n                     }).collect()\n                 }\n             }\n             ty::TyArray(_, n) => {\n-                PatternKind::Leaf {\n-                    subpatterns: (0..n.val.unwrap_u64()).map(|i| {\n+                PatternKind::Array {\n+                    prefix: (0..n.val.unwrap_u64()).map(|i| {\n                         let i = i as usize;\n                         let field = Field::new(i);\n                         let val = match cv.val {\n-                            ConstVal::Aggregate(ConstAggregate::Array(consts)) => consts[i],\n-                            ConstVal::Aggregate(ConstAggregate::Repeat(cv, _)) => cv,\n                             ConstVal::Value(miri) => const_val_field(\n                                 self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n                             ).unwrap(),\n                             _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                         };\n-                        FieldPattern {\n-                            field,\n-                            pattern: self.const_to_pat(instance, val, span),\n-                        }\n-                    }).collect()\n+                        self.const_to_pat(instance, val, id, span)\n+                    }).collect(),\n+                    slice: None,\n+                    suffix: Vec::new(),\n                 }\n             }\n             _ => {"}, {"sha": "f2533276645972a3c769d9ba83a0d016c98a9751", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -325,6 +325,24 @@ match x {\n ```\n \"##,\n \n+E0030: r##\"\n+When matching against a range, the compiler verifies that the range is\n+non-empty.  Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+For example:\n+\n+```compile_fail\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ... 1 => {}\n+    // This range is empty, and the compiler can tell.\n+    1000 ... 5 => {}\n+}\n+```\n+\"##,\n+\n E0158: r##\"\n `const` and `static` mean different things. A `const` is a compile-time\n constant, an alias for a literal value. This property means you can match it\n@@ -2160,6 +2178,24 @@ fn main() {\n ```\n \"##,\n \n+E0579: r##\"\n+When matching against an exclusive range, the compiler verifies that the range\n+is non-empty. Exclusive range patterns include the start point but not the end\n+point, so this is equivalent to requiring the start of the range to be less\n+than the end of the range.\n+\n+For example:\n+\n+```compile_fail\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 .. 2 => {}\n+    // This range is empty, and the compiler can tell.\n+    5 .. 5 => {}\n+}\n+```\n+\"##,\n+\n E0595: r##\"\n Closures cannot mutate immutable captured variables.\n "}, {"sha": "e65f8f3f683f194440ad04d6e3ddeeec8a2bdf4a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -637,7 +637,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         kind: ExprKind::Literal {\n             literal: Literal::Value {\n                 value: cx.tcx().mk_const(ty::Const {\n-                    val: const_fn(cx.tcx, def_id, substs),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty\n                 }),\n             },\n@@ -677,42 +677,20 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>, arm: &'tcx hir::Arm)\n     }\n }\n \n-fn const_fn<'a, 'gcx, 'tcx>(\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    def_id: DefId,\n-    substs: &'tcx Substs<'tcx>,\n-) -> ConstVal<'tcx> {\n-    if tcx.sess.opts.debugging_opts.miri {\n-        /*\n-        let inst = ty::Instance::new(def_id, substs);\n-        let ptr = tcx\n-            .interpret_interner\n-            .borrow_mut()\n-            .create_fn_alloc(inst);\n-        let ptr = MemoryPointer::new(AllocId(ptr), 0);\n-        ConstVal::Value(Value::ByVal(PrimVal::Ptr(ptr)))\n-        */\n-        // ZST function type\n-        ConstVal::Value(Value::ByVal(PrimVal::Undef))\n-    } else {\n-        ConstVal::Function(def_id, substs)\n-    }\n-}\n-\n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n     let substs = cx.tables().node_substs(expr.hir_id);\n     match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(def_id) |\n-        Def::Method(def_id) |\n-        Def::StructCtor(def_id, CtorKind::Fn) |\n-        Def::VariantCtor(def_id, CtorKind::Fn) => ExprKind::Literal {\n+        Def::Fn(_) |\n+        Def::Method(_) |\n+        Def::StructCtor(_, CtorKind::Fn) |\n+        Def::VariantCtor(_, CtorKind::Fn) => ExprKind::Literal {\n             literal: Literal::Value {\n                 value: cx.tcx.mk_const(ty::Const {\n-                    val: const_fn(cx.tcx.global_tcx(), def_id, substs),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty: cx.tables().node_id_to_type(expr.hir_id)\n                 }),\n             },"}, {"sha": "6fda4703d1cbc7cb0121a3ff370012a5b94052e9", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 40, "deletions": 132, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -25,7 +25,7 @@ use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n-use syntax::ast;\n+use syntax::ast::{self, LitKind};\n use syntax::attr;\n use syntax::symbol::Symbol;\n use rustc::hir;\n@@ -119,11 +119,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             Ok(val) => {\n                 Literal::Value {\n                     value: self.tcx.mk_const(ty::Const {\n-                        val: if self.tcx.sess.opts.debugging_opts.miri {\n-                            ConstVal::Value(Value::ByVal(PrimVal::Bytes(value as u128)))\n-                        } else {\n-                            ConstVal::Integral(ConstInt::Usize(val))\n-                        },\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.as_u64() as u128))),\n                         ty: self.tcx.types.usize\n                     })\n                 }\n@@ -143,11 +139,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn true_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n             value: self.tcx.mk_const(ty::Const {\n-                val: if self.tcx.sess.opts.debugging_opts.miri {\n-                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(1)))\n-                } else {\n-                    ConstVal::Bool(true)\n-                },\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(1))),\n                 ty: self.tcx.types.bool\n             })\n         }\n@@ -156,11 +148,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn false_literal(&mut self) -> Literal<'tcx> {\n         Literal::Value {\n             value: self.tcx.mk_const(ty::Const {\n-                val: if self.tcx.sess.opts.debugging_opts.miri {\n-                    ConstVal::Value(Value::ByVal(PrimVal::Bytes(0)))\n-                } else {\n-                    ConstVal::Bool(false)\n-                },\n+                val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                 ty: self.tcx.types.bool\n             })\n         }\n@@ -175,142 +163,66 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     ) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n \n-        let mut repr_ty = ty;\n-        if let ty::TyAdt(adt, _) = ty.sty {\n-            if adt.is_enum() {\n-                repr_ty = adt.repr.discr_type().to_ty(tcx)\n-            }\n-        }\n-\n         let parse_float = |num: &str, fty| -> ConstFloat {\n             ConstFloat::from_str(num, fty).unwrap_or_else(|_| {\n                 // FIXME(#31407) this is only necessary because float parsing is buggy\n                 tcx.sess.span_fatal(sp, \"could not evaluate float literal (see issue #31407)\");\n             })\n         };\n \n-        if tcx.sess.opts.debugging_opts.miri {\n-            use rustc::mir::interpret::*;\n-            let lit = match *lit {\n-                LitKind::Str(ref s, _) => {\n-                    let s = s.as_str();\n-                    let id = self.tcx.allocate_cached(s.as_bytes());\n-                    let ptr = MemoryPointer::new(AllocId(id), 0);\n-                    Value::ByValPair(\n-                        PrimVal::Ptr(ptr),\n-                        PrimVal::from_u128(s.len() as u128),\n-                    )\n-                },\n-                LitKind::ByteStr(ref data) => {\n-                    let id = self.tcx.allocate_cached(data);\n-                    let ptr = MemoryPointer::new(AllocId(id), 0);\n-                    Value::ByVal(PrimVal::Ptr(ptr))\n-                },\n-                LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n-                LitKind::Int(n, _) if neg => {\n-                    let n = n as i128;\n-                    let n = n.overflowing_neg().0;\n-                    Value::ByVal(PrimVal::Bytes(n as u128))\n-                },\n-                LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(n)),\n-                LitKind::Float(n, fty) => {\n-                    let n = n.as_str();\n-                    let mut f = parse_float(&n, fty);\n-                    if neg {\n-                        f = -f;\n-                    }\n-                    let bits = f.bits;\n-                    Value::ByVal(PrimVal::Bytes(bits))\n-                }\n-                LitKind::FloatUnsuffixed(n) => {\n-                    let fty = match ty.sty {\n-                        ty::TyFloat(fty) => fty,\n-                        _ => bug!()\n-                    };\n-                    let n = n.as_str();\n-                    let mut f = parse_float(&n, fty);\n-                    if neg {\n-                        f = -f;\n-                    }\n-                    let bits = f.bits;\n-                    Value::ByVal(PrimVal::Bytes(bits))\n-                }\n-                LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n-                LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n-            };\n-            return Literal::Value {\n-                value: self.tcx.mk_const(ty::Const {\n-                    val: Value(lit),\n-                    ty,\n-                }),\n-            };\n-        }\n-\n-        use syntax::ast::*;\n-        use syntax::ast::LitIntType::*;\n-        use rustc::middle::const_val::ConstVal::*;\n-        use rustc_const_math::ConstInt::*;\n-        use rustc::ty::util::IntTypeExt;\n-        use rustc::middle::const_val::ByteArray;\n-        use rustc_const_math::ConstFloat;\n-\n+        use rustc::mir::interpret::*;\n         let lit = match *lit {\n-            LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n+            LitKind::Str(ref s, _) => {\n+                let s = s.as_str();\n+                let id = self.tcx.allocate_cached(s.as_bytes());\n+                let ptr = MemoryPointer::new(id, 0);\n+                Value::ByValPair(\n+                    PrimVal::Ptr(ptr),\n+                    PrimVal::from_u128(s.len() as u128),\n+                )\n+            },\n             LitKind::ByteStr(ref data) => {\n-                let data: &'tcx [u8] = data;\n-                Ok(ByteStr(ByteArray { data }))\n+                let id = self.tcx.allocate_cached(data);\n+                let ptr = MemoryPointer::new(id, 0);\n+                Value::ByVal(PrimVal::Ptr(ptr))\n             },\n-            LitKind::Byte(n) => Ok(Integral(U8(n))),\n-            LitKind::Int(n, hint) => {\n-                match (&repr_ty.sty, hint) {\n-                    (&ty::TyInt(ity), _) |\n-                    (_, Signed(ity)) => {\n-                        let mut n = n as i128;\n-                        if neg {\n-                            n = n.overflowing_neg().0;\n-                        }\n-                        Ok(Integral(ConstInt::new_signed_truncating(n,\n-                            ity, tcx.sess.target.isize_ty)))\n-                    }\n-                    (&ty::TyUint(uty), _) |\n-                    (_, Unsigned(uty)) => {\n-                        Ok(Integral(ConstInt::new_unsigned_truncating(n,\n-                            uty, tcx.sess.target.usize_ty)))\n-                    }\n-                    _ => bug!()\n-                }\n-            }\n+            LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n+            LitKind::Int(n, _) if neg => {\n+                let n = n as i128;\n+                let n = n.overflowing_neg().0;\n+                Value::ByVal(PrimVal::Bytes(n as u128))\n+            },\n+            LitKind::Int(n, _) => Value::ByVal(PrimVal::Bytes(n)),\n             LitKind::Float(n, fty) => {\n-                let mut f = parse_float(&n.as_str(), fty);\n+                let n = n.as_str();\n+                let mut f = parse_float(&n, fty);\n                 if neg {\n                     f = -f;\n                 }\n-                Ok(ConstVal::Float(f))\n+                let bits = f.bits;\n+                Value::ByVal(PrimVal::Bytes(bits))\n             }\n             LitKind::FloatUnsuffixed(n) => {\n                 let fty = match ty.sty {\n                     ty::TyFloat(fty) => fty,\n                     _ => bug!()\n                 };\n-                let mut f = parse_float(&n.as_str(), fty);\n+                let n = n.as_str();\n+                let mut f = parse_float(&n, fty);\n                 if neg {\n                     f = -f;\n                 }\n-                Ok(ConstVal::Float(f))\n+                let bits = f.bits;\n+                Value::ByVal(PrimVal::Bytes(bits))\n             }\n-            LitKind::Bool(b) => Ok(Bool(b)),\n-            LitKind::Char(c) => Ok(Char(c)),\n+            LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n+            LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n         };\n-\n-        match lit {\n-            Ok(value) => Literal::Value { value: self.tcx.mk_const(ty::Const {\n-                val: value,\n+        Literal::Value {\n+            value: self.tcx.mk_const(ty::Const {\n+                val: ConstVal::Value(lit),\n                 ty,\n-            }) },\n-            Err(kind) => self.fatal_const_eval_err(&ConstEvalErr {\n-                span: sp,\n-                kind,\n-            }, sp, \"expression\")\n+            }),\n         }\n     }\n \n@@ -352,12 +264,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                 return (method_ty,\n                         Literal::Value {\n                             value: self.tcx.mk_const(ty::Const {\n-                                val: if self.tcx.sess.opts.debugging_opts.miri {\n-                                    // ZST function type\n-                                    ConstVal::Value(Value::ByVal(PrimVal::Undef))\n-                                } else {\n-                                    ConstVal::Function(item.def_id, substs)\n-                                },\n+                                // ZST function type\n+                                val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                                 ty: method_ty\n                             }),\n                         });"}, {"sha": "6929bccaa9500e5e7c7116a8be594dbed779f99c", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 77, "deletions": 320, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -5,17 +5,13 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::middle::const_val::ErrKind::{CheckMatchError, TypeckError};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n-use const_eval::{lookup_const_by_id, ConstContext};\n-use rustc::mir::Field;\n-use rustc_data_structures::indexed_vec::Idx;\n+use const_eval::lookup_const_by_id;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n \n use rustc::mir::interpret::{EvalResult, EvalError, EvalErrorKind, GlobalId, Value, MemoryPointer, Pointer, PrimVal};\n-use super::{Place, EvalContext, StackPopCleanup, ValTy, HasMemory, PlaceExtra};\n-\n-use rustc_const_math::ConstInt;\n+use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra};\n \n use std::fmt;\n use std::error::Error;\n@@ -43,93 +39,89 @@ pub fn mk_eval_cx<'a, 'tcx>(\n pub fn eval_body<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n+    promoted: Option<mir::Promoted>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)> {\n+    eval_body_and_ecx(tcx, instance, promoted, param_env).0\n+}\n+\n+pub fn check_body<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    promoted: Option<mir::Promoted>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) {\n+    let (res, ecx) = eval_body_and_ecx(tcx, instance, promoted, param_env);\n+    if let Err(mut err) = res {\n+        ecx.report(&mut err);\n+    }\n+}\n+\n+fn eval_body_and_ecx<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    instance: Instance<'tcx>,\n+    promoted: Option<mir::Promoted>,\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> (EvalResult<'tcx, (Value, Pointer, Ty<'tcx>)>, EvalContext<'a, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body: {:?}, {:?}\", instance, param_env);\n     let limits = super::ResourceLimits::default();\n     let mut ecx = EvalContext::new(tcx, param_env, limits, CompileTimeEvaluator, ());\n     let cid = GlobalId {\n         instance,\n-        promoted: None,\n+        promoted,\n     };\n \n-    if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n-        return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n-    }\n-    let instance_ty = instance.ty(tcx);\n-    if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n-        let mir = ecx.load_mir(instance.def)?;\n-        let layout = ecx.layout_of(instance_ty)?;\n-        assert!(!layout.is_unsized());\n-        let ptr = ecx.memory.allocate(\n-            layout.size.bytes(),\n-            layout.align,\n-            None,\n-        )?;\n-        tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n-        let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n-        let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n-        trace!(\"const_eval: pushing stack frame for global: {}\", name);\n-        ecx.push_stack_frame(\n-            instance,\n-            mir.span,\n-            mir,\n-            Place::from_ptr(ptr, layout.align),\n-            cleanup.clone(),\n-        )?;\n-\n-        while ecx.step()? {}\n-    }\n-    let alloc = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n-    let align = ecx.layout_of(instance_ty)?.align;\n-    let ptr = MemoryPointer::new(alloc, 0).into();\n-    let value = match ecx.try_read_value(ptr, align, instance_ty)? {\n-        Some(val) => val,\n-        _ => Value::ByRef(ptr, align),\n-    };\n-    Ok((value, ptr, instance_ty))\n+    let res = (|| {\n+        if ecx.tcx.has_attr(instance.def_id(), \"linkage\") {\n+            return Err(ConstEvalError::NotConst(\"extern global\".to_string()).into());\n+        }\n+        let instance_ty = instance.ty(tcx);\n+        if tcx.interpret_interner.borrow().get_cached(cid).is_none() {\n+            let mir = ecx.load_mir(instance.def)?;\n+            let layout = ecx.layout_of(instance_ty)?;\n+            assert!(!layout.is_unsized());\n+            let ptr = ecx.memory.allocate(\n+                layout.size.bytes(),\n+                layout.align,\n+                None,\n+            )?;\n+            tcx.interpret_interner.borrow_mut().cache(cid, ptr.alloc_id);\n+            let cleanup = StackPopCleanup::MarkStatic(Mutability::Immutable);\n+            let name = ty::tls::with(|tcx| tcx.item_path_str(instance.def_id()));\n+            trace!(\"const_eval: pushing stack frame for global: {}\", name);\n+            ecx.push_stack_frame(\n+                instance,\n+                mir.span,\n+                mir,\n+                Place::from_ptr(ptr, layout.align),\n+                cleanup.clone(),\n+            )?;\n+\n+            while ecx.step()? {}\n+        }\n+        let alloc = tcx.interpret_interner.borrow().get_cached(cid).expect(\"global not cached\");\n+        let align = ecx.layout_of(instance_ty)?.align;\n+        let ptr = MemoryPointer::new(alloc, 0).into();\n+        let value = match ecx.try_read_value(ptr, align, instance_ty)? {\n+            Some(val) => val,\n+            _ => Value::ByRef(ptr, align),\n+        };\n+        Ok((value, ptr, instance_ty))\n+    })();\n+    (res, ecx)\n }\n \n pub fn eval_body_as_integer<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: Instance<'tcx>,\n-) -> EvalResult<'tcx, ConstInt> {\n-    let (value, _, ty) = eval_body(tcx, instance, param_env)?;\n-    let prim = match value {\n-        Value::ByVal(prim) => prim.to_bytes()?,\n-        _ => return err!(TypeNotPrimitive(ty)),\n-    };\n-    use syntax::ast::{IntTy, UintTy};\n-    use rustc::ty::TypeVariants::*;\n-    use rustc_const_math::{ConstIsize, ConstUsize};\n-    Ok(match ty.sty {\n-        TyInt(IntTy::I8) => ConstInt::I8(prim as i128 as i8),\n-        TyInt(IntTy::I16) => ConstInt::I16(prim as i128 as i16),\n-        TyInt(IntTy::I32) => ConstInt::I32(prim as i128 as i32),\n-        TyInt(IntTy::I64) => ConstInt::I64(prim as i128 as i64),\n-        TyInt(IntTy::I128) => ConstInt::I128(prim as i128),\n-        TyInt(IntTy::Isize) => ConstInt::Isize(\n-            ConstIsize::new(prim as i128 as i64, tcx.sess.target.isize_ty)\n-                .expect(\"miri should already have errored\"),\n-        ),\n-        TyUint(UintTy::U8) => ConstInt::U8(prim as u8),\n-        TyUint(UintTy::U16) => ConstInt::U16(prim as u16),\n-        TyUint(UintTy::U32) => ConstInt::U32(prim as u32),\n-        TyUint(UintTy::U64) => ConstInt::U64(prim as u64),\n-        TyUint(UintTy::U128) => ConstInt::U128(prim),\n-        TyUint(UintTy::Usize) => ConstInt::Usize(\n-            ConstUsize::new(prim as u64, tcx.sess.target.usize_ty)\n-                .expect(\"miri should already have errored\"),\n-        ),\n-        _ => {\n-            return Err(\n-                ConstEvalError::NeedsRfc(\n-                    \"evaluating anything other than isize/usize during typeck\".to_string(),\n-                ).into(),\n-            )\n-        }\n-    })\n+    promoted: Option<mir::Promoted>,\n+) -> EvalResult<'tcx, u128> {\n+    let (value, _, ty) = eval_body(tcx, instance, promoted, param_env)?;\n+    match value {\n+        Value::ByVal(prim) => prim.to_bytes(),\n+        _ => err!(TypeNotPrimitive(ty)),\n+    }\n }\n \n pub struct CompileTimeEvaluator;\n@@ -337,7 +329,7 @@ fn const_val_field_inner<'a, 'tcx>(\n     trace!(\"const_val_field: {:?}, {:?}, {:?}, {:?}\", instance, field, value, ty);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let (mut field, ty) = match value {\n-        Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, field, ty)?.expect(\"const_val_field on non-field\"),\n+        Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, variant, field, ty)?.expect(\"const_val_field on non-field\"),\n         Value::ByRef(ptr, align) => {\n             let place = Place::Ptr {\n                 ptr,\n@@ -422,248 +414,13 @@ pub fn const_eval_provider<'a, 'tcx>(\n \n \n     let instance = ty::Instance::new(def_id, substs);\n-    if tcx.sess.opts.debugging_opts.miri {\n-        return match ::interpret::eval_body(tcx, instance, key.param_env) {\n-            Ok((miri_value, _, miri_ty)) => Ok(tcx.mk_const(ty::Const {\n-                val: ConstVal::Value(miri_value),\n-                ty: miri_ty,\n-            })),\n-            Err(err) => {\n-                Err(ConstEvalErr { span: body.value.span, kind: err.into() })\n-            }\n-        };\n-    }\n-\n-    trace!(\"running old const eval\");\n-    let old_result = ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value);\n-    trace!(\"old const eval produced {:?}\", old_result);\n-    trace!(\"const eval instance: {:?}, {:?}\", instance, key.param_env);\n-    let miri_result = ::interpret::eval_body(tcx, instance, key.param_env);\n-    match (miri_result, old_result) {\n-        (Err(err), Ok(ok)) => {\n-            trace!(\"miri failed, ctfe returned {:?}\", ok);\n-            tcx.sess.span_warn(\n-                tcx.def_span(key.value.0),\n-                \"miri failed to eval, while ctfe succeeded\",\n-            );\n-            let ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-            let () = unwrap_miri(&ecx, Err(err));\n-            Ok(ok)\n-        },\n-        (Ok((value, _, ty)), Err(_)) => Ok(tcx.mk_const(ty::Const {\n-            val: ConstVal::Value(value),\n-            ty,\n+    match ::interpret::eval_body(tcx, instance, None, key.param_env) {\n+        Ok((miri_value, _, miri_ty)) => Ok(tcx.mk_const(ty::Const {\n+            val: ConstVal::Value(miri_value),\n+            ty: miri_ty,\n         })),\n-        (Err(_), Err(err)) => Err(err),\n-        (Ok((_, miri_ptr, miri_ty)), Ok(ctfe)) => {\n-            let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            let miri_place = Place::from_primval_ptr(miri_ptr, layout.align);\n-            check_ctfe_against_miri(&mut ecx, miri_place, miri_ty, ctfe.val);\n-            Ok(ctfe)\n-        }\n-    }\n-}\n-\n-fn check_ctfe_against_miri<'a, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    miri_place: Place,\n-    miri_ty: Ty<'tcx>,\n-    ctfe: ConstVal<'tcx>,\n-) {\n-    use rustc::middle::const_val::ConstAggregate::*;\n-    use rustc_const_math::ConstFloat;\n-    use rustc::ty::TypeVariants::*;\n-    let miri_val = ValTy {\n-        value: ecx.read_place(miri_place).unwrap(),\n-        ty: miri_ty\n-    };\n-    match miri_ty.sty {\n-        TyInt(int_ty) => {\n-            let prim = get_prim(ecx, miri_val);\n-            let c = ConstInt::new_signed_truncating(prim as i128,\n-                                                    int_ty,\n-                                                    ecx.tcx.sess.target.isize_ty);\n-            let c = ConstVal::Integral(c);\n-            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n-        },\n-        TyUint(uint_ty) => {\n-            let prim = get_prim(ecx, miri_val);\n-            let c = ConstInt::new_unsigned_truncating(prim,\n-                                                     uint_ty,\n-                                                     ecx.tcx.sess.target.usize_ty);\n-            let c = ConstVal::Integral(c);\n-            assert_eq!(c, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", c, ctfe);\n-        },\n-        TyFloat(ty) => {\n-            let prim = get_prim(ecx, miri_val);\n-            let f = ConstVal::Float(ConstFloat { bits: prim, ty });\n-            assert_eq!(f, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", f, ctfe);\n-        },\n-        TyBool => {\n-            let bits = get_prim(ecx, miri_val);\n-            if bits > 1 {\n-                bug!(\"miri evaluated to {}, but expected a bool {:?}\", bits, ctfe);\n-            }\n-            let b = ConstVal::Bool(bits == 1);\n-            assert_eq!(b, ctfe, \"miri evaluated to {:?}, but ctfe yielded {:?}\", b, ctfe);\n-        },\n-        TyChar => {\n-            let bits = get_prim(ecx, miri_val);\n-            if let Some(cm) = ::std::char::from_u32(bits as u32) {\n-                assert_eq!(\n-                    ConstVal::Char(cm), ctfe,\n-                    \"miri evaluated to {:?}, but expected {:?}\", cm, ctfe,\n-                );\n-            } else {\n-                bug!(\"miri evaluated to {}, but expected a char {:?}\", bits, ctfe);\n-            }\n-        },\n-        TyStr => {\n-            let value = ecx.follow_by_ref_value(miri_val.value, miri_val.ty);\n-            if let Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) = value {\n-                let bytes = ecx\n-                    .memory\n-                    .read_bytes(ptr.into(), len as u64)\n-                    .expect(\"bad miri memory for str\");\n-                if let Ok(s) = ::std::str::from_utf8(bytes) {\n-                    if let ConstVal::Str(s2) = ctfe {\n-                        assert_eq!(s, s2, \"miri produced {:?}, but expected {:?}\", s, s2);\n-                    } else {\n-                        bug!(\"miri produced {:?}, but expected {:?}\", s, ctfe);\n-                    }\n-                } else {\n-                    bug!(\n-                        \"miri failed to produce valid utf8 {:?}, while ctfe produced {:?}\",\n-                        bytes,\n-                        ctfe,\n-                    );\n-                }\n-            } else {\n-                bug!(\"miri evaluated to {:?}, but expected a str {:?}\", value, ctfe);\n-            }\n-        },\n-        TyArray(elem_ty, n) => {\n-            let n = n.val.unwrap_u64();\n-            let vec: Vec<(ConstVal, Ty<'tcx>)> = match ctfe {\n-                ConstVal::ByteStr(arr) => arr.data.iter().map(|&b| {\n-                    (ConstVal::Integral(ConstInt::U8(b)), ecx.tcx.types.u8)\n-                }).collect(),\n-                ConstVal::Aggregate(Array(v)) => {\n-                    v.iter().map(|c| (c.val, c.ty)).collect()\n-                },\n-                ConstVal::Aggregate(Repeat(v, n)) => {\n-                    vec![(v.val, v.ty); n as usize]\n-                },\n-                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for (i, elem) in vec.into_iter().enumerate() {\n-                assert!((i as u64) < n);\n-                let (field_place, _) =\n-                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n-                check_ctfe_against_miri(ecx, field_place, elem_ty, elem.0);\n-            }\n-        },\n-        TyTuple(..) => {\n-            let vec = match ctfe {\n-                ConstVal::Aggregate(Tuple(v)) => v,\n-                _ => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for (i, elem) in vec.into_iter().enumerate() {\n-                let (field_place, _) =\n-                    ecx.place_field(miri_place, Field::new(i), layout).unwrap();\n-                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n-            }\n-        },\n-        TyAdt(def, _) => {\n-            let mut miri_place = miri_place;\n-            let struct_variant = if def.is_enum() {\n-                let discr = ecx.read_discriminant_value(miri_place, miri_ty).unwrap();\n-                let variant = def.discriminants(ecx.tcx).position(|variant_discr| {\n-                    variant_discr.to_u128_unchecked() == discr\n-                }).expect(\"miri produced invalid enum discriminant\");\n-                miri_place = ecx.place_downcast(miri_place, variant).unwrap();\n-                &def.variants[variant]\n-            } else {\n-                def.non_enum_variant()\n-            };\n-            let vec = match ctfe {\n-                ConstVal::Aggregate(Struct(v)) => v,\n-                ConstVal::Variant(did) => {\n-                    assert_eq!(struct_variant.fields.len(), 0);\n-                    assert_eq!(did, struct_variant.did);\n-                    return;\n-                },\n-                ctfe => bug!(\"miri produced {:?}, but ctfe yielded {:?}\", miri_ty, ctfe),\n-            };\n-            let layout = ecx.layout_of(miri_ty).unwrap();\n-            for &(name, elem) in vec.into_iter() {\n-                let field = struct_variant.fields.iter().position(|f| f.name == name).unwrap();\n-                let (field_place, _) =\n-                    ecx.place_field(miri_place, Field::new(field), layout).unwrap();\n-                check_ctfe_against_miri(ecx, field_place, elem.ty, elem.val);\n-            }\n-        },\n-        TySlice(_) => bug!(\"miri produced a slice?\"),\n-        // not supported by ctfe\n-        TyRawPtr(_) |\n-        TyRef(..) => {}\n-        TyDynamic(..) => bug!(\"miri produced a trait object\"),\n-        TyClosure(..) => bug!(\"miri produced a closure\"),\n-        TyGenerator(..) => bug!(\"miri produced a generator\"),\n-        TyGeneratorWitness(..) => bug!(\"miri produced a generator witness\"),\n-        TyNever => bug!(\"miri produced a value of the never type\"),\n-        TyProjection(_) => bug!(\"miri produced a projection\"),\n-        TyAnon(..) => bug!(\"miri produced an impl Trait type\"),\n-        TyParam(_) => bug!(\"miri produced an unmonomorphized type\"),\n-        TyInfer(_) => bug!(\"miri produced an uninferred type\"),\n-        TyError => bug!(\"miri produced a type error\"),\n-        TyForeign(_) => bug!(\"miri produced an extern type\"),\n-        // should be fine\n-        TyFnDef(..) => {}\n-        TyFnPtr(_) => {\n-            let value = ecx.value_to_primval(miri_val);\n-            let ptr = match value {\n-                Ok(PrimVal::Ptr(ptr)) => ptr,\n-                value => bug!(\"expected fn ptr, got {:?}\", value),\n-            };\n-            let inst = ecx.memory.get_fn(ptr).unwrap();\n-            match ctfe {\n-                ConstVal::Function(did, substs) => {\n-                    let ctfe = ty::Instance::resolve(\n-                        ecx.tcx,\n-                        ecx.param_env,\n-                        did,\n-                        substs,\n-                    ).unwrap();\n-                    assert_eq!(inst, ctfe, \"expected fn ptr {:?}, but got {:?}\", ctfe, inst);\n-                },\n-                _ => bug!(\"ctfe produced {:?}, but miri produced function {:?}\", ctfe, inst),\n-            }\n-        },\n-    }\n-}\n-\n-fn get_prim<'a, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    val: ValTy<'tcx>,\n-) -> u128 {\n-    let res = ecx.value_to_primval(val).and_then(|prim| prim.to_bytes());\n-    unwrap_miri(ecx, res)\n-}\n-\n-fn unwrap_miri<'a, 'tcx, T>(\n-    ecx: &EvalContext<'a, 'tcx, CompileTimeEvaluator>,\n-    res: Result<T, EvalError<'tcx>>,\n-) -> T {\n-    match res {\n-        Ok(val) => val,\n-        Err(mut err) => {\n-            ecx.report(&mut err);\n-            ecx.tcx.sess.abort_if_errors();\n-            bug!(\"{:#?}\", err);\n+        Err(err) => {\n+            Err(ConstEvalErr { span: body.value.span, kind: err.into() })\n         }\n     }\n }"}, {"sha": "63939f7e03817e16f059ed893693e21201bc6d92", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -241,39 +241,16 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub(super) fn const_to_value(&mut self, const_val: &ConstVal<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        use rustc::middle::const_val::ConstVal;\n-\n-        let primval = match *const_val {\n-            ConstVal::Integral(const_int) => PrimVal::Bytes(const_int.to_u128_unchecked()),\n-\n-            ConstVal::Float(val) => PrimVal::Bytes(val.bits),\n-\n-            ConstVal::Bool(b) => PrimVal::from_bool(b),\n-            ConstVal::Char(c) => PrimVal::from_char(c),\n-\n-            ConstVal::Str(ref s) => return self.str_to_value(s),\n-\n-            ConstVal::ByteStr(ref bs) => {\n-                let ptr = self.memory.allocate_cached(bs.data);\n-                PrimVal::Ptr(ptr)\n-            }\n-\n+        match *const_val {\n             ConstVal::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                return Ok(self.read_global_as_value(GlobalId {\n+                Ok(self.read_global_as_value(GlobalId {\n                     instance,\n                     promoted: None,\n-                }, self.layout_of(ty)?));\n+                }, self.layout_of(ty)?))\n             }\n-\n-            ConstVal::Aggregate(..) |\n-            ConstVal::Variant(_) => bug!(\"should not have aggregate or variant constants in MIR\"),\n-            // function items are zero sized and thus have no readable value\n-            ConstVal::Function(..) => PrimVal::Undef,\n-            ConstVal::Value(val) => return Ok(val),\n-        };\n-\n-        Ok(Value::ByVal(primval))\n+            ConstVal::Value(val) => Ok(val),\n+        }\n     }\n \n     pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {"}, {"sha": "ba894a1728a9b1624282a63dec941a3329efe647", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -18,6 +18,6 @@ pub use self::place::{Place, PlaceExtra};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n-pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider, const_val_field, const_discr};\n+pub use self::const_eval::{eval_body_as_integer, eval_body, CompileTimeEvaluator, const_eval_provider, const_val_field, const_discr, check_body};\n \n pub use self::machine::Machine;"}, {"sha": "4a2b4547cb051bd48810dcf38e82c1626629e503", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -118,10 +118,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn read_field(\n         &self,\n         base: Value,\n+        variant: Option<usize>,\n         field: mir::Field,\n         base_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Value, Ty<'tcx>)>> {\n-        let base_layout = self.layout_of(base_ty)?;\n+        let mut base_layout = self.layout_of(base_ty)?;\n+        if let Some(variant_index) = variant {\n+            base_layout = base_layout.for_variant(self, variant_index);\n+        }\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         let offset = base_layout.fields.offset(field_index);\n@@ -149,7 +153,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         };\n         let base_ty = self.place_ty(&proj.base);\n         match proj.elem {\n-            Field(field, _) => Ok(self.read_field(base, field, base_ty)?.map(|(f, _)| f)),\n+            Field(field, _) => Ok(self.read_field(base, None, field, base_ty)?.map(|(f, _)| f)),\n             // The NullablePointer cases should work fine, need to take care for normal enums\n             Downcast(..) |\n             Subslice { .. } |"}, {"sha": "ae790971ec8632482f59dac2fc31d93981faa261", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::*;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n-use rustc_const_math::{ConstInt, ConstUsize};\n+use rustc_const_math::ConstUsize;\n use rustc::mir::interpret::{Value, PrimVal};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -444,12 +444,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ty: func_ty,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: if tcx.sess.opts.debugging_opts.miri {\n-                        // ZST function type\n-                        ConstVal::Value(Value::ByVal(PrimVal::Undef))\n-                    } else {\n-                        ConstVal::Function(self.def_id, substs)\n-                    },\n+                    // ZST function type\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                     ty: func_ty\n                 }),\n             },\n@@ -512,14 +508,12 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             ty: self.tcx.types.usize,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: if self.tcx.sess.opts.debugging_opts.miri {\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into())))\n-                    } else {\n+                    val: {\n                         let value = ConstUsize::new(\n                             value,\n                             self.tcx.sess.target.usize_ty,\n-                        ).unwrap();\n-                        ConstVal::Integral(ConstInt::Usize(value))\n+                        ).unwrap().as_u64();\n+                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(value.into())))\n                     },\n                     ty: self.tcx.types.usize,\n                 })\n@@ -752,12 +746,8 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 ty,\n                 literal: Literal::Value {\n                     value: tcx.mk_const(ty::Const {\n-                        val: if tcx.sess.opts.debugging_opts.miri {\n-                            // ZST function type\n-                            ConstVal::Value(Value::ByVal(PrimVal::Undef))\n-                        } else {\n-                            ConstVal::Function(def_id, Substs::identity_for_item(tcx, def_id))\n-                        },\n+                        // ZST function type\n+                        val: ConstVal::Value(Value::ByVal(PrimVal::Undef)),\n                         ty\n                     }),\n                 },"}, {"sha": "2e8dd623d744d4a406efb540b09bf0e4accabba7", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -19,6 +19,7 @@ use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::middle::const_val::ConstVal;\n+use rustc::mir::interpret::{Value, PrimVal};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -541,7 +542,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             ty: self.tcx.types.bool,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(val),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val as u128))),\n                     ty: self.tcx.types.bool\n                 })\n             }"}, {"sha": "0ff735694338808f6af2b7007c2589426432b53e", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -68,7 +68,6 @@ use rustc::ty::{self, TyCtxt, AdtDef, Ty, GeneratorInterior};\n use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, LivenessMode};\n-use rustc_const_math::ConstInt;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use std::collections::HashMap;\n@@ -182,11 +181,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             ty: self.tcx.types.u32,\n             literal: Literal::Value {\n                 value: self.tcx.mk_const(ty::Const {\n-                    val: if self.tcx.sess.opts.debugging_opts.miri {\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(state_disc.into())))\n-                    } else {\n-                        ConstVal::Integral(ConstInt::U32(state_disc))\n-                    },\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(state_disc.into()))),\n                     ty: self.tcx.types.u32\n                 }),\n             },\n@@ -703,7 +698,7 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ty: tcx.types.bool,\n             literal: Literal::Value {\n                 value: tcx.mk_const(ty::Const {\n-                    val: ConstVal::Bool(false),\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(0))),\n                     ty: tcx.types.bool\n                 }),\n             },"}, {"sha": "e39f5412355bf0dbccf5c6806923478405374a22", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -13,6 +13,7 @@\n use rustc::ty::{self, TyCtxt};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n+use rustc::mir::interpret::{Value, PrimVal};\n use transform::{MirPass, MirSource};\n \n use std::borrow::Cow;\n@@ -56,9 +57,12 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(box Constant {\n                     literal: Literal::Value {\n-                        value: &ty::Const { val: ConstVal::Bool(cond), .. }\n+                        value: &ty::Const {\n+                            val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(cond))),\n+                        .. }\n                     }, ..\n-                }), expected, .. } if cond == expected => {\n+                }), expected, .. } if (cond == 1) == expected => {\n+                    assert!(cond <= 1);\n                     TerminatorKind::Goto { target: target }\n                 },\n                 TerminatorKind::FalseEdges { real_target, .. } => {"}, {"sha": "2ad1580f75dcd59c747c3becc1083b80afd45b2f", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -950,11 +950,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty: self.tcx().types.usize,\n             literal: Literal::Value {\n                 value: self.tcx().mk_const(ty::Const {\n-                    val: if self.tcx().sess.opts.debugging_opts.miri {\n-                        ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.into())))\n-                    } else {\n-                        ConstVal::Integral(self.tcx().const_usize(val))\n-                    },\n+                    val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(val.into()))),\n                     ty: self.tcx().types.usize\n                 })\n             }"}, {"sha": "013bc07d8e9a78308560b6a1bd389e10761cdfa6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 112, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -25,12 +25,6 @@\n // by borrowck::gather_loans\n \n use rustc::ty::cast::CastKind;\n-use rustc_mir::const_eval::ConstContext;\n-use rustc::middle::const_val::ConstEvalErr;\n-use rustc::middle::const_val::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll};\n-use rustc::middle::const_val::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n-use rustc::middle::const_val::ErrKind::{TypeckError, Math, LayoutError};\n-use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -41,17 +35,13 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::{queries, Providers};\n use rustc::ty::subst::Substs;\n use rustc::traits::Reveal;\n-use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::{ItemLocalSet, NodeSet};\n-use rustc::lint::builtin::CONST_ERR;\n-use rustc::hir::{self, PatKind, RangeEnd};\n+use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n-use std::cmp::Ordering;\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         rvalue_promotable_map,\n@@ -124,32 +114,6 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n-    fn const_cx(&self) -> ConstContext<'a, 'gcx> {\n-        ConstContext::new(self.tcx, self.param_env.and(self.identity_substs), self.tables)\n-    }\n-\n-    fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n-        if self.tcx.sess.opts.debugging_opts.miri {\n-            return;\n-        }\n-        if let Err(err) = self.const_cx().eval(expr) {\n-            match err.kind {\n-                UnimplementedConstVal(_) => {}\n-                IndexOpFeatureGated => {}\n-                ErroneousReferencedConstant(_) => {}\n-                TypeckError => {}\n-                MiscCatchAll => {}\n-                _ => {\n-                    self.tcx.lint_node(CONST_ERR,\n-                                       expr.id,\n-                                       expr.span,\n-                                       &format!(\"constant evaluation error: {}\",\n-                                                err.description().into_oneline()));\n-                }\n-            }\n-        }\n-    }\n-\n     // Returns true iff all the values of the type are promotable.\n     fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n         ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n@@ -199,9 +163,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         self.identity_substs = Substs::identity_for_item(self.tcx, item_def_id);\n \n         let body = self.tcx.hir.body(body_id);\n-        if !self.in_fn {\n-            self.check_const_eval(&body.value);\n-        }\n \n         let tcx = self.tcx;\n         let param_env = self.param_env;\n@@ -217,54 +178,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         self.identity_substs = outer_identity_substs;\n     }\n \n-    fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        match p.node {\n-            PatKind::Lit(ref lit) => {\n-                self.check_const_eval(lit);\n-            }\n-            PatKind::Range(ref start, ref end, RangeEnd::Excluded) => {\n-                match self.const_cx().compare_lit_exprs(start, end) {\n-                    Ok(Some(Ordering::Less)) => {}\n-                    Ok(Some(Ordering::Equal)) |\n-                    Ok(Some(Ordering::Greater)) => {\n-                        span_err!(self.tcx.sess,\n-                                  start.span,\n-                                  E0579,\n-                                  \"lower range bound must be less than upper\");\n-                    }\n-                    Ok(None) => bug!(\"ranges must be char or int\"),\n-                    Err(ErrorReported) => {}\n-                }\n-            }\n-            PatKind::Range(ref start, ref end, RangeEnd::Included) => {\n-                match self.const_cx().compare_lit_exprs(start, end) {\n-                    Ok(Some(Ordering::Less)) |\n-                    Ok(Some(Ordering::Equal)) => {}\n-                    Ok(Some(Ordering::Greater)) => {\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            start.span,\n-                            E0030,\n-                            \"lower range bound must be less than or equal to upper\"\n-                        );\n-                        err.span_label(start.span, \"lower bound larger than upper bound\");\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\"When matching against a range, the compiler verifies that \\\n-                                      the range is non-empty. Range patterns include both \\\n-                                      end-points, so this is equivalent to requiring the start of \\\n-                                      the range to be less than or equal to the end of the range.\");\n-                        }\n-                        err.emit();\n-                    }\n-                    Ok(None) => bug!(\"ranges must be char or int\"),\n-                    Err(ErrorReported) => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_pat(self, p);\n-    }\n-\n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => {\n@@ -313,30 +226,6 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.promotable = false;\n         }\n \n-        if self.in_fn && self.promotable && !self.tcx.sess.opts.debugging_opts.miri {\n-            match self.const_cx().eval(ex) {\n-                Ok(_) => {}\n-                Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n-                Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n-                Err(ConstEvalErr { kind: MiscBinaryOp, .. }) |\n-                Err(ConstEvalErr { kind: NonConstPath, .. }) |\n-                Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), .. }) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n-                Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n-                Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n-                Err(ConstEvalErr { kind: TypeckError, .. }) => {}\n-                Err(ConstEvalErr {\n-                    kind: LayoutError(ty::layout::LayoutError::Unknown(_)), ..\n-                }) => {}\n-                Err(msg) => {\n-                    self.tcx.lint_node(CONST_ERR,\n-                                       ex.id,\n-                                       msg.span,\n-                                       &msg.description().into_oneline().into_owned());\n-                }\n-            }\n-        }\n-\n         if self.promotable {\n             self.result.insert(ex.hir_id.local_id);\n         }"}, {"sha": "7a54fc72d53cc68a54aa3bd28c012b4df49a759b", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -31,23 +31,6 @@ const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n */\n-E0030: r##\"\n-When matching against a range, the compiler verifies that the range is\n-non-empty.  Range patterns include both end-points, so this is equivalent to\n-requiring the start of the range to be less than or equal to the end of the\n-range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 ... 1 => {}\n-    // This range is empty, and the compiler can tell.\n-    1000 ... 5 => {}\n-}\n-```\n-\"##,\n \n E0130: r##\"\n You declared a pattern as an argument in a foreign function declaration.\n@@ -228,24 +211,6 @@ impl Foo for Bar {\n \"##,\n \n \n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-For example:\n-\n-```compile_fail\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 .. 2 => {}\n-    // This range is empty, and the compiler can tell.\n-    5 .. 5 => {}\n-}\n-```\n-\"##,\n-\n E0590: r##\"\n `break` or `continue` must include a label when used in the condition of a\n `while` loop."}, {"sha": "da10fcffb4c64509fb468c762d8b203fe8d5b58e", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -119,7 +119,6 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 }),\n                 ref args, ..\n             } => match val {\n-                ConstVal::Function(def_id, _) => Some((def_id, args)),\n                 ConstVal::Value(Value::ByVal(PrimVal::Undef)) => match ty.sty {\n                     ty::TyFnDef(did, _) => Some((did, args)),\n                     _ => None,"}, {"sha": "66173cfef920393f6575d1854fc0f4bc6b17a34f", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 42, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -10,7 +10,6 @@\n \n use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n-use rustc_const_math::ConstInt::*;\n use rustc_const_math::{ConstInt, ConstMathErr, MAX_F32_PLUS_HALF_ULP};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n@@ -64,25 +63,6 @@ impl<'a, 'tcx> Const<'tcx> {\n         }\n     }\n \n-    pub fn from_constint(cx: &CodegenCx<'a, 'tcx>, ci: &ConstInt) -> Const<'tcx> {\n-        let tcx = cx.tcx;\n-        let (llval, ty) = match *ci {\n-            I8(v) => (C_int(Type::i8(cx), v as i64), tcx.types.i8),\n-            I16(v) => (C_int(Type::i16(cx), v as i64), tcx.types.i16),\n-            I32(v) => (C_int(Type::i32(cx), v as i64), tcx.types.i32),\n-            I64(v) => (C_int(Type::i64(cx), v as i64), tcx.types.i64),\n-            I128(v) => (C_uint_big(Type::i128(cx), v as u128), tcx.types.i128),\n-            Isize(v) => (C_int(Type::isize(cx), v.as_i64()), tcx.types.isize),\n-            U8(v) => (C_uint(Type::i8(cx), v as u64), tcx.types.u8),\n-            U16(v) => (C_uint(Type::i16(cx), v as u64), tcx.types.u16),\n-            U32(v) => (C_uint(Type::i32(cx), v as u64), tcx.types.u32),\n-            U64(v) => (C_uint(Type::i64(cx), v), tcx.types.u64),\n-            U128(v) => (C_uint_big(Type::i128(cx), v), tcx.types.u128),\n-            Usize(v) => (C_uint(Type::isize(cx), v.as_u64()), tcx.types.usize),\n-        };\n-        Const { llval: llval, ty: ty }\n-    }\n-\n     pub fn from_bytes(ccx: &CrateContext<'a, 'tcx>, b: u128, ty: Ty<'tcx>) -> Const<'tcx> {\n         let llval = match ty.sty {\n             ty::TyInt(ast::IntTy::I128) |\n@@ -124,26 +104,7 @@ impl<'a, 'tcx> Const<'tcx> {\n         let llty = cx.layout_of(ty).llvm_type(cx);\n         trace!(\"from_constval: {:#?}: {}\", cv, ty);\n         let val = match *cv {\n-            ConstVal::Float(v) => {\n-                let bits = match v.ty {\n-                    ast::FloatTy::F32 => C_u32(cx, v.bits as u32),\n-                    ast::FloatTy::F64 => C_u64(cx, v.bits as u64)\n-                };\n-                consts::bitcast(bits, llty)\n-            }\n-            ConstVal::Bool(v) => C_bool(cx, v),\n-            ConstVal::Integral(ref i) => return Const::from_constint(cx, i),\n-            ConstVal::Str(ref v) => C_str_slice(cx, v.clone()),\n-            ConstVal::ByteStr(v) => {\n-                consts::addr_of(cx, C_bytes(cx, v.data), cx.align_of(ty), \"byte_str\")\n-            }\n-            ConstVal::Char(c) => C_uint(Type::char(cx), c as u64),\n-            ConstVal::Function(..) => C_undef(llty),\n-            ConstVal::Variant(_) |\n-            ConstVal::Aggregate(..) |\n-            ConstVal::Unevaluated(..) => {\n-                bug!(\"MIR must not use `{:?}` (aggregates are expanded to MIR rvalues)\", cv)\n-            }\n+            ConstVal::Unevaluated(..) => unimplemented!(\"const val `{:?}`\", cv),\n             ConstVal::Value(MiriValue::ByRef(..)) => unimplemented!(\"{:#?}:{}\", cv, ty),\n             ConstVal::Value(MiriValue::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(len))) => {\n                 match ty.sty {\n@@ -157,7 +118,7 @@ impl<'a, 'tcx> Const<'tcx> {\n                     .tcx()\n                     .interpret_interner\n                     .borrow()\n-                    .get_alloc(ptr.alloc_id.0)\n+                    .get_alloc(ptr.alloc_id)\n                     .expect(\"miri alloc not found\");\n                 assert_eq!(len as usize as u128, len);\n                 let slice = &alloc.bytes[(ptr.offset as usize)..][..(len as usize)];\n@@ -174,7 +135,7 @@ impl<'a, 'tcx> Const<'tcx> {\n                     .tcx()\n                     .interpret_interner\n                     .borrow()\n-                    .get_alloc(ptr.alloc_id.0)\n+                    .get_alloc(ptr.alloc_id)\n                     .expect(\"miri alloc not found\");\n                 let data = &alloc.bytes[(ptr.offset as usize)..];\n                 consts::addr_of(ccx, C_bytes(ccx, data), ccx.align_of(ty), \"byte_str\")"}, {"sha": "595ae463ab0f1d4bb547a728a5cd3b72a993b7cb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -533,7 +533,6 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             match result {\n-                Ok(&ty::Const { val: ConstVal::Integral(x), .. }) => Some(x),\n                 Ok(&ty::Const {\n                     val: ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))),\n                     .."}, {"sha": "74121e3a420f9f74c941a812c548eec20ca36cd5", "filename": "src/test/compile-fail/issue-31109.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fissue-31109.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fissue-31109.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31109.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -12,6 +12,5 @@ fn main() {\n     // FIXME(#31407) this error should go away, but in the meantime we test that it\n     // is accompanied by a somewhat useful error message.\n     let _: f64 = 1234567890123456789012345678901234567890e-340;\n-    //~^ ERROR constant evaluation error\n-    //~| unimplemented constant expression: could not evaluate float literal\n+    //~^ ERROR could not evaluate float literal (see issue #31407)\n }"}, {"sha": "f01fd1fd8f1442571c9a7cfa6f9005f647b335a2", "filename": "src/test/compile-fail/issue-39559-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fissue-39559-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fissue-39559-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559-2.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -22,7 +22,9 @@ impl Dim for Dim3 {\n \n fn main() {\n     let array: [usize; Dim3::dim()]\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR E0015\n+    //~| ERROR E0080\n         = [0; Dim3::dim()];\n-        //~^ ERROR calls in constants are limited to constant functions\n+        //~^ ERROR E0015\n+        //~| ERROR E0080\n }"}, {"sha": "823ece2bdca01d38b5c0279360f664c57851b826", "filename": "src/test/compile-fail/issue-41255.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41255.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -18,33 +18,33 @@\n fn main() {\n     let x = 42.0;\n     match x {\n-        5.0 => {}, //~ ERROR floating-point literals cannot be used\n+        5.0 => {}, //~ ERROR floating-point cannot be used\n                    //~| WARNING hard error\n-        5.0f32 => {}, //~ ERROR floating-point literals cannot be used\n+        5.0f32 => {}, //~ ERROR floating-point cannot be used\n                       //~| WARNING hard error\n-        -5.0 => {}, //~ ERROR floating-point literals cannot be used\n+        -5.0 => {}, //~ ERROR floating-point cannot be used\n                     //~| WARNING hard error\n-        1.0 .. 33.0 => {}, //~ ERROR floating-point literals cannot be used\n+        1.0 .. 33.0 => {}, //~ ERROR floating-point cannot be used\n                            //~| WARNING hard error\n-                           //~| ERROR floating-point literals cannot be used\n+                           //~| ERROR floating-point cannot be used\n                            //~| WARNING hard error\n-        39.0 ... 70.0 => {}, //~ ERROR floating-point literals cannot be used\n+        39.0 ... 70.0 => {}, //~ ERROR floating-point cannot be used\n                              //~| WARNING hard error\n-                             //~| ERROR floating-point literals cannot be used\n+                             //~| ERROR floating-point cannot be used\n                              //~| WARNING hard error\n         _ => {},\n     };\n     let y = 5.0;\n     // Same for tuples\n     match (x, 5) {\n-        (3.14, 1) => {}, //~ ERROR floating-point literals cannot be used\n+        (3.14, 1) => {}, //~ ERROR floating-point cannot be used\n                          //~| WARNING hard error\n         _ => {},\n     }\n     // Or structs\n     struct Foo { x: f32 };\n     match (Foo { x }) {\n-        Foo { x: 2.0 } => {}, //~ ERROR floating-point literals cannot be used\n+        Foo { x: 2.0 } => {}, //~ ERROR floating-point cannot be used\n                               //~| WARNING hard error\n         _ => {},\n     }"}, {"sha": "e94d1ff779367e20dcf3c30b0b4e04d82f1b24ad", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -53,7 +53,7 @@ fn main() {\n       let n = n << 8; //~ ERROR: bitshift exceeds the type's number of bits\n \n       let n = 1u8 << -8; //~ ERROR: bitshift exceeds the type's number of bits\n-      //~^ WARN: attempt to shift by a negative amount\n+\n \n       let n = 1u8 << (4+3);\n       let n = 1u8 << (4+4); //~ ERROR: bitshift exceeds the type's number of bits"}, {"sha": "f7cf8a68d568446119a63c5b9d74cd05794589d7", "filename": "src/test/compile-fail/lint-type-overflow2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-type-overflow2.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -17,7 +17,6 @@\n #[rustc_error]\n fn main() { //~ ERROR: compilation successful\n     let x2: i8 = --128; //~ warn: literal out of range for i8\n-    //~^ warn: attempt to negate with overflow\n \n     let x = -3.40282357e+38_f32; //~ warn: literal out of range for f32\n     let x =  3.40282357e+38_f32; //~ warn: literal out of range for f32"}, {"sha": "fd888b659f14262813460c2185f6ae246bd03b71", "filename": "src/test/compile-fail/rfc1445/match-forbidden-without-eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc1445%2Fmatch-forbidden-without-eq.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -28,7 +28,8 @@ fn main() {\n     let x = 0.0;\n     match x {\n         f32::INFINITY => { }\n-        //~^ ERROR floating point constants cannot be used in patterns\n+        //~^ WARNING floating-point cannot be used in patterns\n+        //~| WARNING will become a hard error in a future release\n         _ => { }\n     }\n }"}, {"sha": "dc220bd1cc94fbfa81432109dbf7e16e32493fe8", "filename": "src/test/compile-fail/thread-local-in-ctfe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs?ref=28572d2c1fae5ab4c6bcade0c1a9fa485da0ec61", "patch": "@@ -16,15 +16,13 @@ static A: u32 = 1;\n static B: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n //~| ERROR cannot refer to other statics by value\n-//~| WARN non-constant path in constant expression\n \n static C: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n \n const D: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n //~| ERROR cannot refer to statics by value\n-//~| WARN non-constant path in constant expression\n \n const E: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time"}]}