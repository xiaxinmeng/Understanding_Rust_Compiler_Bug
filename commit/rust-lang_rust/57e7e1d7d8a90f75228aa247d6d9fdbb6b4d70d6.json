{"sha": "57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "node_id": "C_kwDOAAsO6NoAKDU3ZTdlMWQ3ZDhhOTBmNzUyMjhhYTI0N2Q2ZDlmZGJiNmI0ZDcwZDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-27T00:32:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-27T00:32:22Z"}, "message": "Auto merge of #8871 - Serial-ATA:cargo-dev-deprecate, r=giraffate\n\nAdd `cargo dev deprecate`\n\nchangelog: none\n\nI wrote this awhile ago when `regex` was still a dependency. Is it alright to add it back?", "tree": {"sha": "aeeb3ee71314aee0c5c8e5257b302e6a75eca20d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeeb3ee71314aee0c5c8e5257b302e6a75eca20d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "html_url": "https://github.com/rust-lang/rust/commit/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88da5f2bb3c4218005f59e7bbdd5c3865069ac77", "url": "https://api.github.com/repos/rust-lang/rust/commits/88da5f2bb3c4218005f59e7bbdd5c3865069ac77", "html_url": "https://github.com/rust-lang/rust/commit/88da5f2bb3c4218005f59e7bbdd5c3865069ac77"}, {"sha": "aec465cabdeb9a126446ccf791a9cf5ae045c185", "url": "https://api.github.com/repos/rust-lang/rust/commits/aec465cabdeb9a126446ccf791a9cf5ae045c185", "html_url": "https://github.com/rust-lang/rust/commit/aec465cabdeb9a126446ccf791a9cf5ae045c185"}], "stats": {"total": 600, "additions": 530, "deletions": 70}, "files": [{"sha": "2ac3b4fe2ed4f456f91188385e6e4aa3638ccc2b", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -5,7 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n aho-corasick = \"0.7\"\n-clap = \"3.1\"\n+clap = \"3.2\"\n indoc = \"1.0\"\n itertools = \"0.10.1\"\n opener = \"0.5\""}, {"sha": "243a901503f160f617718e30e16b2242ab99ace6", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -5,6 +5,7 @@\n use clap::{Arg, ArgAction, ArgMatches, Command, PossibleValue};\n use clippy_dev::{bless, fmt, lint, new_lint, serve, setup, update_lints};\n use indoc::indoc;\n+\n fn main() {\n     let matches = get_clap_config();\n \n@@ -85,6 +86,11 @@ fn main() {\n             let uplift = matches.contains_id(\"uplift\");\n             update_lints::rename(old_name, new_name, uplift);\n         },\n+        Some((\"deprecate\", matches)) => {\n+            let name = matches.get_one::<String>(\"name\").unwrap();\n+            let reason = matches.get_one(\"reason\");\n+            update_lints::deprecate(name, reason);\n+        },\n         _ => {},\n     }\n }\n@@ -266,6 +272,18 @@ fn get_clap_config() -> ArgMatches {\n                     .long(\"uplift\")\n                     .help(\"This lint will be uplifted into rustc\"),\n             ]),\n+            Command::new(\"deprecate\").about(\"Deprecates the given lint\").args([\n+                Arg::new(\"name\")\n+                    .index(1)\n+                    .required(true)\n+                    .help(\"The name of the lint to deprecate\"),\n+                Arg::new(\"reason\")\n+                    .long(\"reason\")\n+                    .short('r')\n+                    .required(false)\n+                    .takes_value(true)\n+                    .help(\"The reason for deprecation\"),\n+            ]),\n         ])\n         .get_matches()\n }"}, {"sha": "7d7e760ef446c3b925b3f1eb47b1e1aaf9a50d71", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -138,7 +138,7 @@ fn to_camel_case(name: &str) -> String {\n         .collect()\n }\n \n-fn get_stabilization_version() -> String {\n+pub(crate) fn get_stabilization_version() -> String {\n     fn parse_manifest(contents: &str) -> Option<String> {\n         let version = contents\n             .lines()"}, {"sha": "115f5f0064fea9bcd741f820ae1492e77edf7485", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 354, "deletions": 41, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -1,16 +1,17 @@\n+use crate::clippy_project_root;\n use aho_corasick::AhoCorasickBuilder;\n-use core::fmt::Write as _;\n+use indoc::writedoc;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n use std::collections::{HashMap, HashSet};\n use std::ffi::OsStr;\n-use std::fs;\n-use std::io::{self, Read as _, Seek as _, Write as _};\n+use std::fmt::Write;\n+use std::fs::{self, OpenOptions};\n+use std::io::{self, Read, Seek, SeekFrom, Write as _};\n+use std::ops::Range;\n use std::path::{Path, PathBuf};\n use walkdir::{DirEntry, WalkDir};\n \n-use crate::clippy_project_root;\n-\n const GENERATED_FILE_COMMENT: &str = \"// This file was generated by `cargo dev update_lints`.\\n\\\n      // Use that command to update this file and do not edit by hand.\\n\\\n      // Manual edits will be overwritten.\\n\\n\";\n@@ -326,6 +327,200 @@ pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n     println!(\"note: `cargo uitest` still needs to be run to update the test results\");\n }\n \n+const DEFAULT_DEPRECATION_REASON: &str = \"default deprecation note\";\n+/// Runs the `deprecate` command\n+///\n+/// This does the following:\n+/// * Adds an entry to `deprecated_lints.rs`.\n+/// * Removes the lint declaration (and the entire file if applicable)\n+///\n+/// # Panics\n+///\n+/// If a file path could not read from or written to\n+pub fn deprecate(name: &str, reason: Option<&String>) {\n+    fn finish(\n+        (lints, mut deprecated_lints, renamed_lints): (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>),\n+        name: &str,\n+        reason: &str,\n+    ) {\n+        deprecated_lints.push(DeprecatedLint {\n+            name: name.to_string(),\n+            reason: reason.to_string(),\n+            declaration_range: Range::default(),\n+        });\n+\n+        generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n+        println!(\"info: `{}` has successfully been deprecated\", name);\n+\n+        if reason == DEFAULT_DEPRECATION_REASON {\n+            println!(\"note: the deprecation reason must be updated in `clippy_lints/src/deprecated_lints.rs`\");\n+        }\n+        println!(\"note: you must run `cargo uitest` to update the test results\");\n+    }\n+\n+    let reason = reason.map_or(DEFAULT_DEPRECATION_REASON, String::as_str);\n+    let name_lower = name.to_lowercase();\n+    let name_upper = name.to_uppercase();\n+\n+    let (mut lints, deprecated_lints, renamed_lints) = gather_all();\n+    let Some(lint) = lints.iter().find(|l| l.name == name_lower) else { eprintln!(\"error: failed to find lint `{}`\", name); return; };\n+\n+    let mod_path = {\n+        let mut mod_path = PathBuf::from(format!(\"clippy_lints/src/{}\", lint.module));\n+        if mod_path.is_dir() {\n+            mod_path = mod_path.join(\"mod\");\n+        }\n+\n+        mod_path.set_extension(\"rs\");\n+        mod_path\n+    };\n+\n+    let deprecated_lints_path = &*clippy_project_root().join(\"clippy_lints/src/deprecated_lints.rs\");\n+\n+    if remove_lint_declaration(&name_lower, &mod_path, &mut lints).unwrap_or(false) {\n+        declare_deprecated(&name_upper, deprecated_lints_path, reason).unwrap();\n+        finish((lints, deprecated_lints, renamed_lints), name, reason);\n+        return;\n+    }\n+\n+    eprintln!(\"error: lint not found\");\n+}\n+\n+fn remove_lint_declaration(name: &str, path: &Path, lints: &mut Vec<Lint>) -> io::Result<bool> {\n+    fn remove_lint(name: &str, lints: &mut Vec<Lint>) {\n+        lints.iter().position(|l| l.name == name).map(|pos| lints.remove(pos));\n+    }\n+\n+    fn remove_test_assets(name: &str) {\n+        let test_file_stem = format!(\"tests/ui/{}\", name);\n+        let path = Path::new(&test_file_stem);\n+\n+        // Some lints have their own directories, delete them\n+        if path.is_dir() {\n+            fs::remove_dir_all(path).ok();\n+            return;\n+        }\n+\n+        // Remove all related test files\n+        fs::remove_file(path.with_extension(\"rs\")).ok();\n+        fs::remove_file(path.with_extension(\"stderr\")).ok();\n+        fs::remove_file(path.with_extension(\"fixed\")).ok();\n+    }\n+\n+    fn remove_impl_lint_pass(lint_name_upper: &str, content: &mut String) {\n+        let impl_lint_pass_start = content.find(\"impl_lint_pass!\").unwrap_or_else(|| {\n+            content\n+                .find(\"declare_lint_pass!\")\n+                .unwrap_or_else(|| panic!(\"failed to find `impl_lint_pass`\"))\n+        });\n+        let mut impl_lint_pass_end = (&content[impl_lint_pass_start..])\n+            .find(']')\n+            .expect(\"failed to find `impl_lint_pass` terminator\");\n+\n+        impl_lint_pass_end += impl_lint_pass_start;\n+        if let Some(lint_name_pos) = content[impl_lint_pass_start..impl_lint_pass_end].find(&lint_name_upper) {\n+            let mut lint_name_end = impl_lint_pass_start + (lint_name_pos + lint_name_upper.len());\n+            for c in content[lint_name_end..impl_lint_pass_end].chars() {\n+                // Remove trailing whitespace\n+                if c == ',' || c.is_whitespace() {\n+                    lint_name_end += 1;\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            content.replace_range(impl_lint_pass_start + lint_name_pos..lint_name_end, \"\");\n+        }\n+    }\n+\n+    if path.exists() {\n+        if let Some(lint) = lints.iter().find(|l| l.name == name) {\n+            if lint.module == name {\n+                // The lint name is the same as the file, we can just delete the entire file\n+                fs::remove_file(path)?;\n+            } else {\n+                // We can't delete the entire file, just remove the declaration\n+\n+                if let Some(Some(\"mod.rs\")) = path.file_name().map(OsStr::to_str) {\n+                    // Remove clippy_lints/src/some_mod/some_lint.rs\n+                    let mut lint_mod_path = path.to_path_buf();\n+                    lint_mod_path.set_file_name(name);\n+                    lint_mod_path.set_extension(\"rs\");\n+\n+                    fs::remove_file(lint_mod_path).ok();\n+                }\n+\n+                let mut content =\n+                    fs::read_to_string(&path).unwrap_or_else(|_| panic!(\"failed to read `{}`\", path.to_string_lossy()));\n+\n+                eprintln!(\n+                    \"warn: you will have to manually remove any code related to `{}` from `{}`\",\n+                    name,\n+                    path.display()\n+                );\n+\n+                assert!(\n+                    content[lint.declaration_range.clone()].contains(&name.to_uppercase()),\n+                    \"error: `{}` does not contain lint `{}`'s declaration\",\n+                    path.display(),\n+                    lint.name\n+                );\n+\n+                // Remove lint declaration (declare_clippy_lint!)\n+                content.replace_range(lint.declaration_range.clone(), \"\");\n+\n+                // Remove the module declaration (mod xyz;)\n+                let mod_decl = format!(\"\\nmod {};\", name);\n+                content = content.replacen(&mod_decl, \"\", 1);\n+\n+                remove_impl_lint_pass(&lint.name.to_uppercase(), &mut content);\n+                fs::write(path, content).unwrap_or_else(|_| panic!(\"failed to write to `{}`\", path.to_string_lossy()));\n+            }\n+\n+            remove_test_assets(name);\n+            remove_lint(name, lints);\n+            return Ok(true);\n+        }\n+    }\n+\n+    Ok(false)\n+}\n+\n+fn declare_deprecated(name: &str, path: &Path, reason: &str) -> io::Result<()> {\n+    let mut file = OpenOptions::new().write(true).open(path)?;\n+\n+    file.seek(SeekFrom::End(0))?;\n+\n+    let version = crate::new_lint::get_stabilization_version();\n+    let deprecation_reason = if reason == DEFAULT_DEPRECATION_REASON {\n+        \"TODO\"\n+    } else {\n+        reason\n+    };\n+\n+    writedoc!(\n+        file,\n+        \"\n+\n+        declare_deprecated_lint! {{\n+            /// ### What it does\n+            /// Nothing. This lint has been deprecated.\n+            ///\n+            /// ### Deprecation reason\n+            /// {}\n+            #[clippy::version = \\\"{}\\\"]\n+            pub {},\n+            \\\"{}\\\"\n+        }}\n+\n+        \",\n+        deprecation_reason,\n+        version,\n+        name,\n+        reason,\n+    )\n+}\n+\n /// Replace substrings if they aren't bordered by identifier characters. Returns `None` if there\n /// were no replacements.\n fn replace_ident_like(contents: &str, replacements: &[(&str, &str)]) -> Option<String> {\n@@ -393,16 +588,18 @@ struct Lint {\n     group: String,\n     desc: String,\n     module: String,\n+    declaration_range: Range<usize>,\n }\n \n impl Lint {\n     #[must_use]\n-    fn new(name: &str, group: &str, desc: &str, module: &str) -> Self {\n+    fn new(name: &str, group: &str, desc: &str, module: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             group: group.into(),\n             desc: remove_line_splices(desc),\n             module: module.into(),\n+            declaration_range,\n         }\n     }\n \n@@ -433,12 +630,14 @@ impl Lint {\n struct DeprecatedLint {\n     name: String,\n     reason: String,\n+    declaration_range: Range<usize>,\n }\n impl DeprecatedLint {\n-    fn new(name: &str, reason: &str) -> Self {\n+    fn new(name: &str, reason: &str, declaration_range: Range<usize>) -> Self {\n         Self {\n             name: name.to_lowercase(),\n             reason: remove_line_splices(reason),\n+            declaration_range,\n         }\n     }\n }\n@@ -610,7 +809,11 @@ fn clippy_lints_src_files() -> impl Iterator<Item = (PathBuf, DirEntry)> {\n macro_rules! match_tokens {\n     ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {\n          {\n-            $($(let $capture =)? if let Some((TokenKind::$token $({$($fields)*})?, _x)) = $iter.next() {\n+            $($(let $capture =)? if let Some(LintDeclSearchResult {\n+                    token_kind: TokenKind::$token $({$($fields)*})?,\n+                    content: _x,\n+                    ..\n+            }) = $iter.next() {\n                 _x\n             } else {\n                 continue;\n@@ -621,40 +824,72 @@ macro_rules! match_tokens {\n     }\n }\n \n+struct LintDeclSearchResult<'a> {\n+    token_kind: TokenKind,\n+    content: &'a str,\n+    range: Range<usize>,\n+}\n+\n /// Parse a source file looking for `declare_clippy_lint` macro invocations.\n fn parse_contents(contents: &str, module: &str, lints: &mut Vec<Lint>) {\n     let mut offset = 0usize;\n     let mut iter = tokenize(contents).map(|t| {\n         let range = offset..offset + t.len;\n         offset = range.end;\n-        (t.kind, &contents[range])\n+\n+        LintDeclSearchResult {\n+            token_kind: t.kind,\n+            content: &contents[range.clone()],\n+            range,\n+        }\n     });\n \n-    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_clippy_lint\") {\n+    while let Some(LintDeclSearchResult { range, .. }) = iter.find(\n+        |LintDeclSearchResult {\n+             token_kind, content, ..\n+         }| token_kind == &TokenKind::Ident && *content == \"declare_clippy_lint\",\n+    ) {\n+        let start = range.start;\n+\n         let mut iter = iter\n             .by_ref()\n-            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+            .filter(|t| !matches!(t.token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n         // matches `!{`\n         match_tokens!(iter, Bang OpenBrace);\n         match iter.next() {\n             // #[clippy::version = \"version\"] pub\n-            Some((TokenKind::Pound, _)) => {\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Pound,\n+                ..\n+            }) => {\n                 match_tokens!(iter, OpenBracket Ident Colon Colon Ident Eq Literal{..} CloseBracket Ident);\n             },\n             // pub\n-            Some((TokenKind::Ident, _)) => (),\n+            Some(LintDeclSearchResult {\n+                token_kind: TokenKind::Ident,\n+                ..\n+            }) => (),\n             _ => continue,\n         }\n+\n         let (name, group, desc) = match_tokens!(\n             iter,\n             // LINT_NAME\n             Ident(name) Comma\n             // group,\n             Ident(group) Comma\n-            // \"description\" }\n-            Literal{..}(desc) CloseBrace\n+            // \"description\"\n+            Literal{..}(desc)\n         );\n-        lints.push(Lint::new(name, group, desc, module));\n+\n+        if let Some(LintDeclSearchResult {\n+            token_kind: TokenKind::CloseBrace,\n+            range,\n+            ..\n+        }) = iter.next()\n+        {\n+            lints.push(Lint::new(name, group, desc, module, start..range.end));\n+        }\n     }\n }\n \n@@ -664,12 +899,24 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n     let mut iter = tokenize(contents).map(|t| {\n         let range = offset..offset + t.len;\n         offset = range.end;\n-        (t.kind, &contents[range])\n+\n+        LintDeclSearchResult {\n+            token_kind: t.kind,\n+            content: &contents[range.clone()],\n+            range,\n+        }\n     });\n-    while iter.any(|(kind, s)| kind == TokenKind::Ident && s == \"declare_deprecated_lint\") {\n-        let mut iter = iter\n-            .by_ref()\n-            .filter(|&(kind, _)| !matches!(kind, TokenKind::Whitespace | TokenKind::LineComment { .. }));\n+\n+    while let Some(LintDeclSearchResult { range, .. }) = iter.find(\n+        |LintDeclSearchResult {\n+             token_kind, content, ..\n+         }| token_kind == &TokenKind::Ident && *content == \"declare_deprecated_lint\",\n+    ) {\n+        let start = range.start;\n+\n+        let mut iter = iter.by_ref().filter(|LintDeclSearchResult { ref token_kind, .. }| {\n+            !matches!(token_kind, TokenKind::Whitespace | TokenKind::LineComment { .. })\n+        });\n         let (name, reason) = match_tokens!(\n             iter,\n             // !{\n@@ -680,10 +927,16 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n             Ident Ident(name) Comma\n             // \"description\"\n             Literal{kind: LiteralKind::Str{..},..}(reason)\n-            // }\n-            CloseBrace\n         );\n-        lints.push(DeprecatedLint::new(name, reason));\n+\n+        if let Some(LintDeclSearchResult {\n+            token_kind: TokenKind::CloseBrace,\n+            range,\n+            ..\n+        }) = iter.next()\n+        {\n+            lints.push(DeprecatedLint::new(name, reason, start..range.end));\n+        }\n     }\n }\n \n@@ -693,8 +946,14 @@ fn parse_renamed_contents(contents: &str, lints: &mut Vec<RenamedLint>) {\n         let mut iter = tokenize(line).map(|t| {\n             let range = offset..offset + t.len;\n             offset = range.end;\n-            (t.kind, &line[range])\n+\n+            LintDeclSearchResult {\n+                token_kind: t.kind,\n+                content: &line[range.clone()],\n+                range,\n+            }\n         });\n+\n         let (old_name, new_name) = match_tokens!(\n             iter,\n             // (\"old_name\",\n@@ -844,10 +1103,25 @@ mod tests {\n         \"#;\n         let mut result = Vec::new();\n         parse_contents(CONTENTS, \"module_name\", &mut result);\n+        for r in &mut result {\n+            r.declaration_range = Range::default();\n+        }\n \n         let expected = vec![\n-            Lint::new(\"ptr_arg\", \"style\", \"\\\"really long text\\\"\", \"module_name\"),\n-            Lint::new(\"doc_markdown\", \"pedantic\", \"\\\"single line\\\"\", \"module_name\"),\n+            Lint::new(\n+                \"ptr_arg\",\n+                \"style\",\n+                \"\\\"really long text\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"doc_markdown\",\n+                \"pedantic\",\n+                \"\\\"single line\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n         ];\n         assert_eq!(expected, result);\n     }\n@@ -865,57 +1139,96 @@ mod tests {\n \n         let mut result = Vec::new();\n         parse_deprecated_contents(DEPRECATED_CONTENTS, &mut result);\n+        for r in &mut result {\n+            r.declaration_range = Range::default();\n+        }\n \n         let expected = vec![DeprecatedLint::new(\n             \"should_assert_eq\",\n             \"\\\"`assert!()` will be more flexible with RFC 2011\\\"\",\n+            Range::default(),\n         )];\n         assert_eq!(expected, result);\n     }\n \n     #[test]\n     fn test_usable_lints() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq2\", \"Not Deprecated\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"Not Deprecated\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"internal\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"internal_style\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n         ];\n         let expected = vec![Lint::new(\n             \"should_assert_eq2\",\n             \"Not Deprecated\",\n             \"\\\"abc\\\"\",\n             \"module_name\",\n+            Range::default(),\n         )];\n         assert_eq!(expected, Lint::usable_lints(&lints));\n     }\n \n     #[test]\n     fn test_by_lint_group() {\n         let lints = vec![\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\n+                \"should_assert_eq2\",\n+                \"group2\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            ),\n+            Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let mut expected: HashMap<String, Vec<Lint>> = HashMap::new();\n         expected.insert(\n             \"group1\".to_string(),\n             vec![\n-                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n+                Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+                Lint::new(\"incorrect_match\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n             ],\n         );\n         expected.insert(\n             \"group2\".to_string(),\n-            vec![Lint::new(\"should_assert_eq2\", \"group2\", \"\\\"abc\\\"\", \"module_name\")],\n+            vec![Lint::new(\n+                \"should_assert_eq2\",\n+                \"group2\",\n+                \"\\\"abc\\\"\",\n+                \"module_name\",\n+                Range::default(),\n+            )],\n         );\n         assert_eq!(expected, Lint::by_lint_group(lints.into_iter()));\n     }\n \n     #[test]\n     fn test_gen_deprecated() {\n         let lints = vec![\n-            DeprecatedLint::new(\"should_assert_eq\", \"\\\"has been superseded by should_assert_eq2\\\"\"),\n-            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\"),\n+            DeprecatedLint::new(\n+                \"should_assert_eq\",\n+                \"\\\"has been superseded by should_assert_eq2\\\"\",\n+                Range::default(),\n+            ),\n+            DeprecatedLint::new(\"another_deprecated\", \"\\\"will be removed\\\"\", Range::default()),\n         ];\n \n         let expected = GENERATED_FILE_COMMENT.to_string()\n@@ -940,9 +1253,9 @@ mod tests {\n     #[test]\n     fn test_gen_lint_group_list() {\n         let lints = vec![\n-            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\"),\n-            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\"),\n+            Lint::new(\"abc\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\"should_assert_eq\", \"group1\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n+            Lint::new(\"internal\", \"internal_style\", \"\\\"abc\\\"\", \"module_name\", Range::default()),\n         ];\n         let expected = GENERATED_FILE_COMMENT.to_string()\n             + &["}, {"sha": "9aa5af3190fb2bd240c3b8ae10e36f9e9e59ae55", "filename": "clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -1,16 +1,21 @@\n-// NOTE: if you add a deprecated lint in this file, please add a corresponding test in\n-// tests/ui/deprecated.rs\n+// NOTE: Entries should be created with `cargo dev deprecate`\n \n /// This struct fakes the `Lint` declaration that is usually created by `declare_lint!`. This\n /// enables the simple extraction of the metadata without changing the current deprecation\n /// declaration.\n-pub struct ClippyDeprecatedLint;\n+pub struct ClippyDeprecatedLint {\n+    #[allow(dead_code)]\n+    pub desc: &'static str,\n+}\n \n+#[macro_export]\n macro_rules! declare_deprecated_lint {\n-    { $(#[$attr:meta])* pub $name: ident, $_reason: expr} => {\n+    { $(#[$attr:meta])* pub $name: ident, $reason: literal} => {\n         $(#[$attr])*\n         #[allow(dead_code)]\n-        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {};\n+        pub static $name: ClippyDeprecatedLint = ClippyDeprecatedLint {\n+            desc: $reason\n+        };\n     }\n }\n "}, {"sha": "be63646a12f51dca756146bb026884dea50b4cc8", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -6,6 +6,7 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n     LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n     LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n+    LintId::of(utils::internal_lints::DEFAULT_DEPRECATION_REASON),\n     LintId::of(utils::internal_lints::DEFAULT_LINT),\n     LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n     LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),"}, {"sha": "cd308a80f466c35d4748b24deba566debb3c166a", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -10,6 +10,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::DEFAULT_DEPRECATION_REASON,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::DEFAULT_LINT,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::IF_CHAIN_STYLE,"}, {"sha": "078df64a1e1f4c5c4cd36235712077b9d55d505a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -159,7 +159,7 @@ macro_rules! declare_clippy_lint {\n }\n \n #[cfg(feature = \"internal\")]\n-mod deprecated_lints;\n+pub mod deprecated_lints;\n #[cfg_attr(feature = \"internal\", allow(clippy::missing_clippy_version_attribute))]\n mod utils;\n "}, {"sha": "a94f0357977eab8766bea03e03d1eee36b0b003f", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 86, "deletions": 20, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -1,3 +1,4 @@\n+use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n@@ -338,6 +339,46 @@ declare_clippy_lint! {\n     \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n+    /// i.e. `\"default deprecation note\"`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the documentation is incomplete.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// TODO\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"default deprecation note\"\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// This lint has been replaced by `cooler_lint`\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"this lint has been replaced by `cooler_lint`\"\n+    /// }\n+    /// ```\n+    pub DEFAULT_DEPRECATION_REASON,\n+    internal,\n+    \"found 'default deprecation note' in a deprecated lint declaration\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -375,42 +416,67 @@ pub struct LintWithoutLintPass {\n     registered_lints: FxHashSet<Symbol>,\n }\n \n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE]);\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n \n impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id()) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n+            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n+        {\n             return;\n         }\n \n         if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n-            if is_lint_ref_type(cx, ty) {\n+            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n+            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n                 check_invalid_clippy_version_attribute(cx, item);\n \n                 let expr = &cx.tcx.hir().body(body_id).value;\n-                if_chain! {\n-                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind;\n-                    if let ExprKind::Struct(_, fields, _) = inner_exp.kind;\n-                    let field = fields\n-                        .iter()\n-                        .find(|f| f.ident.as_str() == \"desc\")\n-                        .expect(\"lints must have a description field\");\n-                    if let ExprKind::Lit(Spanned {\n-                        node: LitKind::Str(ref sym, _),\n-                        ..\n-                    }) = field.expr.kind;\n-                    if sym.as_str() == \"default lint description\";\n-\n-                    then {\n+                let fields;\n+                if is_lint_ref_ty {\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n+                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n+                            fields = struct_fields;\n+                    } else {\n+                        return;\n+                    }\n+                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n+                    fields = struct_fields;\n+                } else {\n+                    return;\n+                }\n+\n+                let field = fields\n+                    .iter()\n+                    .find(|f| f.ident.as_str() == \"desc\")\n+                    .expect(\"lints must have a description field\");\n+\n+                if let ExprKind::Lit(Spanned {\n+                    node: LitKind::Str(ref sym, _),\n+                    ..\n+                }) = field.expr.kind\n+                {\n+                    let sym_str = sym.as_str();\n+                    if is_lint_ref_ty {\n+                        if sym_str == \"default lint description\" {\n+                            span_lint(\n+                                cx,\n+                                DEFAULT_LINT,\n+                                item.span,\n+                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            );\n+                        }\n+\n+                        self.declared_lints.insert(item.ident.name, item.span);\n+                    } else if sym_str == \"default deprecation note\" {\n                         span_lint(\n                             cx,\n-                            DEFAULT_LINT,\n+                            DEFAULT_DEPRECATION_REASON,\n                             item.span,\n-                            &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n                         );\n                     }\n                 }\n-                self.declared_lints.insert(item.ident.name, item.span);\n             }\n         } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n             if !matches!("}, {"sha": "c97a1f1e258032315c80d23a1cd696f898555194", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -847,7 +847,7 @@ fn get_lint_level_from_group(lint_group: &str) -> Option<&'static str> {\n         .find_map(|(group_name, group_level)| (*group_name == lint_group).then(|| *group_level))\n }\n \n-fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n+pub(super) fn is_deprecated_lint(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     if let hir::TyKind::Path(ref path) = ty.kind {\n         if let hir::def::Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, ty.hir_id) {\n             return match_def_path(cx, def_id, &DEPRECATED_LINT_TYPE);"}, {"sha": "a303d90d953eda243920d1f3d5c55db90cd1741f", "filename": "tests/compile-test.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -24,6 +24,7 @@ const RUN_INTERNAL_TESTS: bool = cfg!(feature = \"internal\");\n /// All crates used in UI tests are listed here\n static TEST_DEPENDENCIES: &[&str] = &[\n     \"clap\",\n+    \"clippy_lints\",\n     \"clippy_utils\",\n     \"derive_new\",\n     \"futures\",\n@@ -44,6 +45,8 @@ static TEST_DEPENDENCIES: &[&str] = &[\n #[allow(unused_extern_crates)]\n extern crate clap;\n #[allow(unused_extern_crates)]\n+extern crate clippy_lints;\n+#[allow(unused_extern_crates)]\n extern crate clippy_utils;\n #[allow(unused_extern_crates)]\n extern crate derive_new;"}, {"sha": "c8961d5e1f0bd6fc8780707c23f690176787bab0", "filename": "tests/ui-internal/default_deprecation_reason.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/tests%2Fui-internal%2Fdefault_deprecation_reason.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/tests%2Fui-internal%2Fdefault_deprecation_reason.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fdefault_deprecation_reason.rs?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -0,0 +1,30 @@\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+#[macro_use]\n+extern crate clippy_lints;\n+use clippy_lints::deprecated_lints::ClippyDeprecatedLint;\n+\n+declare_deprecated_lint! {\n+    /// ### What it does\n+    /// Nothing. This lint has been deprecated.\n+    ///\n+    /// ### Deprecation reason\n+    /// TODO\n+    #[clippy::version = \"1.63.0\"]\n+    pub COOL_LINT_DEFAULT,\n+    \"default deprecation note\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// ### What it does\n+    /// Nothing. This lint has been deprecated.\n+    ///\n+    /// ### Deprecation reason\n+    /// This lint has been replaced by `cooler_lint`\n+    #[clippy::version = \"1.63.0\"]\n+    pub COOL_LINT,\n+    \"this lint has been replaced by `cooler_lint`\"\n+}\n+\n+fn main() {}"}, {"sha": "ca26b649f986a6ca8d880f4dade94605b1941b2b", "filename": "tests/ui-internal/default_deprecation_reason.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/tests%2Fui-internal%2Fdefault_deprecation_reason.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6/tests%2Fui-internal%2Fdefault_deprecation_reason.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fdefault_deprecation_reason.stderr?ref=57e7e1d7d8a90f75228aa247d6d9fdbb6b4d70d6", "patch": "@@ -0,0 +1,22 @@\n+error: the lint `COOL_LINT_DEFAULT` has the default deprecation reason\n+  --> $DIR/default_deprecation_reason.rs:8:1\n+   |\n+LL | / declare_deprecated_lint! {\n+LL | |     /// ### What it does\n+LL | |     /// Nothing. This lint has been deprecated.\n+LL | |     ///\n+...  |\n+LL | |     \"default deprecation note\"\n+LL | | }\n+   | |_^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/default_deprecation_reason.rs:1:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::default_deprecation_reason)]` implied by `#[deny(clippy::internal)]`\n+   = note: this error originates in the macro `declare_deprecated_lint` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}]}