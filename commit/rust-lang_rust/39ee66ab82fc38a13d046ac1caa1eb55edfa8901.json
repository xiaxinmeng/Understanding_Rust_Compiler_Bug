{"sha": "39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZWU2NmFiODJmYzM4YTEzZDA0NmFjMWNhYTFlYjU1ZWRmYTg5MDE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-03-09T21:59:13Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-03-15T13:49:28Z"}, "message": "Consider well-formed predicates in min-specialization", "tree": {"sha": "ec044a401a4ba3008aa0f440698f3b52d0ec45f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec044a401a4ba3008aa0f440698f3b52d0ec45f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "html_url": "https://github.com/rust-lang/rust/commit/39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4377ac3e2f58f923062e6e945f06a9a93fcc70df", "url": "https://api.github.com/repos/rust-lang/rust/commits/4377ac3e2f58f923062e6e945f06a9a93fcc70df", "html_url": "https://github.com/rust-lang/rust/commit/4377ac3e2f58f923062e6e945f06a9a93fcc70df"}], "stats": {"total": 86, "additions": 82, "deletions": 4}, "files": [{"sha": "e96a8c454b8c7b60fc47ae20dbadbe32c42b9666", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "patch": "@@ -21,8 +21,9 @@\n //!    in the *unconstrained* substs for `impl2`. A parameter is constrained if\n //!    its value is completely determined by an associated type projection\n //!    predicate.\n-//! 4. Check that all predicates on `impl1` also exist on `impl2` (after\n-//!    matching substs).\n+//! 4. Check that all predicates on `impl1` either exist on `impl2` (after\n+//!    matching substs), or are well-formed predicates for the trait's type\n+//!    arguments.\n //!\n //! ## Example\n //!\n@@ -129,7 +130,7 @@ fn check_always_applicable(\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n \n-        check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n+        check_predicates(infcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n@@ -282,14 +283,17 @@ fn check_static_lifetimes<'tcx>(\n /// * on the base `impl impl2`\n ///     * Currently this check is done using syntactic equality, which is\n ///       conservative but generally sufficient.\n+/// * a well-formed predicate of a type argument of the trait being implemented,\n+///   including the `Self`-type.\n fn check_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+    infcx: &InferCtxt<'_, 'tcx>,\n     impl1_def_id: DefId,\n     impl1_substs: SubstsRef<'tcx>,\n     impl2_node: Node,\n     impl2_substs: SubstsRef<'tcx>,\n     span: Span,\n ) {\n+    let tcx = infcx.tcx;\n     let impl1_predicates = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n@@ -329,6 +333,21 @@ fn check_predicates<'tcx>(\n         })\n         .copied()\n         .collect();\n+\n+    // Include the well-formed predicates of the type parameters of the impl.\n+    for ty in tcx.impl_trait_ref(impl1_def_id).unwrap().substs.types() {\n+        if let Some(obligations) = wf::obligations(\n+            infcx,\n+            tcx.param_env(impl1_def_id),\n+            tcx.hir().as_local_hir_id(impl1_def_id).unwrap(),\n+            ty,\n+            span,\n+        ) {\n+            impl2_predicates\n+                .predicates\n+                .extend(obligations.into_iter().map(|obligation| obligation.predicate))\n+        }\n+    }\n     impl2_predicates.predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n \n     for predicate in impl1_predicates.predicates {"}, {"sha": "98d7f9194351c078e6696e7bb5ae14b8e8b81d81", "filename": "src/test/ui/specialization/min_specialization/implcit-well-formed-bounds.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimplcit-well-formed-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimplcit-well-formed-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fimplcit-well-formed-bounds.rs?ref=39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "patch": "@@ -0,0 +1,30 @@\n+// Test that specializing on the well-formed predicates of the trait and\n+// self-type of an impl is allowed.\n+\n+// check-pass\n+\n+#![feature(min_specialization)]\n+\n+struct OrdOnly<T: Ord>(T);\n+\n+trait SpecTrait<U> {\n+    fn f();\n+}\n+\n+impl<T, U> SpecTrait<U> for T {\n+    default fn f() {}\n+}\n+\n+impl<T: Ord> SpecTrait<()> for OrdOnly<T> {\n+    fn f() {}\n+}\n+\n+impl<T: Ord> SpecTrait<OrdOnly<T>> for () {\n+    fn f() {}\n+}\n+\n+impl<T: Ord, U: Ord, V: Ord> SpecTrait<(OrdOnly<T>, OrdOnly<U>)> for &[OrdOnly<V>] {\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "145f376edf938cf3e17bb7f3ff7a8d79e89b8c90", "filename": "src/test/ui/specialization/min_specialization/specialization_super_trait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.rs?ref=39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "patch": "@@ -0,0 +1,18 @@\n+// Test that supertraits can't be assumed in impls of\n+// `rustc_specialization_trait`, as such impls would\n+// allow specializing on the supertrait.\n+\n+#![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_specialization_trait]\n+trait SpecMarker: Default {\n+    fn f();\n+}\n+\n+impl<T: Default> SpecMarker for T {\n+    //~^ ERROR cannot specialize\n+    fn f() {}\n+}\n+\n+fn main() {}"}, {"sha": "154c839c6da6e81eb5ab8a43b5e93fd41ad5fefe", "filename": "src/test/ui/specialization/min_specialization/specialization_super_trait.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39ee66ab82fc38a13d046ac1caa1eb55edfa8901/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Fspecialization_super_trait.stderr?ref=39ee66ab82fc38a13d046ac1caa1eb55edfa8901", "patch": "@@ -0,0 +1,11 @@\n+error: cannot specialize on trait `std::default::Default`\n+  --> $DIR/specialization_super_trait.rs:13:1\n+   |\n+LL | / impl<T: Default> SpecMarker for T {\n+LL | |\n+LL | |     fn f() {}\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+"}]}