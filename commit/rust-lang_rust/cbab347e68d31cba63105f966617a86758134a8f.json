{"sha": "cbab347e68d31cba63105f966617a86758134a8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYWIzNDdlNjhkMzFjYmE2MzEwNWY5NjY2MTdhODY3NTgxMzRhOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-13T14:42:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-13T14:42:37Z"}, "message": "Auto merge of #79376 - ssomers:btree_choose_parent_kv, r=Mark-Simulacrum\n\nBTreeMap: clarify comments and panics around choose_parent_kv\n\nFixes a lie in recent code: `unreachable!(\"empty non-root node\")` should shout \"empty internal node\", but it might as well be good and keep quiet\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "0ad410cccb981b965ce1cd6fa4be9fc0b57a091c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ad410cccb981b965ce1cd6fa4be9fc0b57a091c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbab347e68d31cba63105f966617a86758134a8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbab347e68d31cba63105f966617a86758134a8f", "html_url": "https://github.com/rust-lang/rust/commit/cbab347e68d31cba63105f966617a86758134a8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbab347e68d31cba63105f966617a86758134a8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "057937bddac3f43a46dfc07ee2d9fa59de7b7ca9", "url": "https://api.github.com/repos/rust-lang/rust/commits/057937bddac3f43a46dfc07ee2d9fa59de7b7ca9", "html_url": "https://github.com/rust-lang/rust/commit/057937bddac3f43a46dfc07ee2d9fa59de7b7ca9"}, {"sha": "50576420f559be3c681e6833327845d6cf3217b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/50576420f559be3c681e6833327845d6cf3217b4", "html_url": "https://github.com/rust-lang/rust/commit/50576420f559be3c681e6833327845d6cf3217b4"}], "stats": {"total": 26, "additions": 14, "deletions": 12}, "files": [{"sha": "07667fa2288b1f634536dd7aa7cbb55f4e29a5ec", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbab347e68d31cba63105f966617a86758134a8f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbab347e68d31cba63105f966617a86758134a8f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=cbab347e68d31cba63105f966617a86758134a8f", "patch": "@@ -1288,30 +1288,32 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Chooses a balancing context involving the node as a child, thus between\n     /// the KV immediately to the left or to the right in the parent node.\n     /// Returns an `Err` if there is no parent.\n+    /// Panics if the parent is empty.\n     ///\n-    /// This method optimizes for a node that has fewer elements than its left\n-    /// and right siblings, if they exist, by preferring the left parent KV.\n-    /// Merging with the left sibling is faster, since we only need to move\n+    /// Prefers the left side, to be optimal if the given node is somehow\n+    /// underfull, meaning here only that it has fewer elements than its left\n+    /// sibling and than its right sibling, if they exist. In that case,\n+    /// merging with the left sibling is faster, since we only need to move\n     /// the node's N elements, instead of shifting them to the right and moving\n     /// more than N elements in front. Stealing from the left sibling is also\n     /// typically faster, since we only need to shift the node's N elements to\n     /// the right, instead of shifting at least N of the sibling's elements to\n     /// the left.\n     pub fn choose_parent_kv(self) -> Result<LeftOrRight<BalancingContext<'a, K, V>>, Self> {\n         match unsafe { ptr::read(&self) }.ascend() {\n-            Ok(parent) => match parent.left_kv() {\n+            Ok(parent_edge) => match parent_edge.left_kv() {\n                 Ok(left_parent_kv) => Ok(LeftOrRight::Left(BalancingContext {\n                     parent: unsafe { ptr::read(&left_parent_kv) },\n                     left_child: left_parent_kv.left_edge().descend(),\n                     right_child: self,\n                 })),\n-                Err(parent) => match parent.right_kv() {\n+                Err(parent_edge) => match parent_edge.right_kv() {\n                     Ok(right_parent_kv) => Ok(LeftOrRight::Right(BalancingContext {\n                         parent: unsafe { ptr::read(&right_parent_kv) },\n                         left_child: self,\n                         right_child: right_parent_kv.right_edge().descend(),\n                     })),\n-                    Err(_) => unreachable!(\"empty non-root node\"),\n+                    Err(_) => unreachable!(\"empty internal node\"),\n                 },\n             },\n             Err(root) => Err(root),"}, {"sha": "7aeb39cbc320f2001ea5b6e20475de7f8f3f2afe", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbab347e68d31cba63105f966617a86758134a8f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbab347e68d31cba63105f966617a86758134a8f/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=cbab347e68d31cba63105f966617a86758134a8f", "patch": "@@ -54,12 +54,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             pos = unsafe { new_pos.cast_to_leaf_unchecked() };\n \n             // Only if we merged, the parent (if any) has shrunk, but skipping\n-            // the following step does not pay off in benchmarks.\n+            // the following step otherwise does not pay off in benchmarks.\n             //\n             // SAFETY: We won't destroy or rearrange the leaf where `pos` is at\n             // by handling its parent recursively; at worst we will destroy or\n             // rearrange the parent through the grandparent, thus change the\n-            // leaf's parent pointer.\n+            // link to the parent inside the leaf.\n             if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n                 parent.into_node().handle_shrunk_node_recursively(handle_emptied_internal_root);\n             }\n@@ -90,8 +90,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n }\n \n impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Stocks up a possibly underfull internal node, recursively.\n-    /// Climbs up until it reaches an ancestor that has elements to spare or the root.\n+    /// Stocks up a possibly underfull internal node and its ancestors,\n+    /// until it reaches an ancestor that has elements to spare or is the root.\n     fn handle_shrunk_node_recursively<F: FnOnce()>(mut self, handle_emptied_internal_root: F) {\n         loop {\n             self = match self.len() {\n@@ -122,7 +122,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     ) -> Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>> {\n         match self.forget_type().choose_parent_kv() {\n             Ok(Left(left_parent_kv)) => {\n-                debug_assert!(left_parent_kv.right_child_len() == MIN_LEN - 1);\n+                debug_assert_eq!(left_parent_kv.right_child_len(), MIN_LEN - 1);\n                 if left_parent_kv.can_merge() {\n                     let pos = left_parent_kv.merge(None);\n                     let parent_edge = unsafe { unwrap_unchecked(pos.into_node().ascend().ok()) };\n@@ -134,7 +134,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n                 }\n             }\n             Ok(Right(right_parent_kv)) => {\n-                debug_assert!(right_parent_kv.left_child_len() == MIN_LEN - 1);\n+                debug_assert_eq!(right_parent_kv.left_child_len(), MIN_LEN - 1);\n                 if right_parent_kv.can_merge() {\n                     let pos = right_parent_kv.merge(None);\n                     let parent_edge = unsafe { unwrap_unchecked(pos.into_node().ascend().ok()) };"}]}