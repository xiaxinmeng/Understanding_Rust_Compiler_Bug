{"sha": "c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YmNkMGE0NGQ2NGQ0M2E1YzFkZmRlNzNkNGUzZjk0ZTI0MTlkYTc=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-19T00:26:37Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-19T19:01:13Z"}, "message": "Move collect_upvars into its own file.", "tree": {"sha": "c5aadad104a507ad50ff8a4744ec21bd0db7560c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5aadad104a507ad50ff8a4744ec21bd0db7560c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "html_url": "https://github.com/rust-lang/rust/commit/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e6197aa959126ac882bc8db2f44d32a4af34f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6197aa959126ac882bc8db2f44d32a4af34f0f", "html_url": "https://github.com/rust-lang/rust/commit/2e6197aa959126ac882bc8db2f44d32a4af34f0f"}], "stats": {"total": 168, "additions": 96, "deletions": 72}, "files": [{"sha": "bf2a8f7e2c92c95f4b48419e03eb3302c2ac8e20", "filename": "src/comp/middle/freevars.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "patch": "@@ -0,0 +1,91 @@\n+// A pass that annotates for each loops with the free variables that\n+// they contain.\n+\n+import std::map;\n+import std::map::*;\n+import syntax::ast;\n+import syntax::walk;\n+import driver::session;\n+import middle::ty;\n+import syntax::codemap::span;\n+\n+\n+\n+// Searches through part of the AST for all references to locals or\n+// upvars in this frame and returns the list of definition IDs thus found.\n+// Since we want to be able to collect upvars in some arbitrary piece\n+// of the AST, we take a walker function that we invoke with a visitor\n+// in order to start the search.\n+fn collect_upvars(&ty::ctxt tcx, &fn (&walk::ast_visitor) walker,\n+                  ast::node_id[] initial_decls) -> ast::node_id[] {\n+    type env =\n+        @rec(mutable ast::node_id[] refs,\n+             hashmap[ast::node_id, ()] decls,\n+             resolve::def_map def_map,\n+             session::session sess);\n+\n+    fn walk_fn(env e, &ast::_fn f, &ast::ty_param[] tps, &span sp,\n+               &ast::fn_ident i, ast::node_id nid) {\n+        for (ast::arg a in f.decl.inputs) { e.decls.insert(a.id, ()); }\n+    }\n+    fn walk_expr(env e, &@ast::expr expr) {\n+        alt (expr.node) {\n+            case (ast::expr_path(?path)) {\n+                if (! e.def_map.contains_key(expr.id)) {\n+                    e.sess.span_fatal(expr.span,\n+                       \"internal error in collect_upvars\");\n+                }\n+                alt (e.def_map.get(expr.id)) {\n+                    case (ast::def_arg(?did)) { e.refs += ~[did._1]; }\n+                    case (ast::def_local(?did)) { e.refs += ~[did._1]; }\n+                    case (ast::def_binding(?did)) { e.refs += ~[did._1]; }\n+                    case (_) { /* no-op */ }\n+                }\n+            }\n+            case (_) { }\n+        }\n+    }\n+    fn walk_local(env e, &@ast::local local) {\n+        e.decls.insert(local.node.id, ());\n+    }\n+    fn walk_pat(env e, &@ast::pat p) {\n+        alt (p.node) {\n+            case (ast::pat_bind(_)) {\n+                e.decls.insert(p.id, ());\n+            }\n+            case (_) {}\n+        }\n+    }\n+    let hashmap[ast::node_id, ()] decls = new_int_hash[()]();\n+    for (ast::node_id decl in initial_decls) { decls.insert(decl, ()); }\n+\n+    let env e =\n+        @rec(mutable refs=~[],\n+             decls=decls,\n+             def_map=tcx.def_map,\n+             sess=tcx.sess);\n+    auto visitor =\n+        @rec(visit_fn_pre=bind walk_fn(e, _, _, _, _, _),\n+             visit_local_pre=bind walk_local(e, _),\n+             visit_expr_pre=bind walk_expr(e, _),\n+             visit_pat_pre=bind walk_pat(e, _)\n+             with walk::default_visitor());\n+    walker(*visitor);\n+    // Calculate (refs - decls). This is the set of captured upvars.\n+\n+    let ast::node_id[] result = ~[];\n+    for (ast::node_id ref_id_ in e.refs) {\n+        auto ref_id = ref_id_;\n+        if (!decls.contains_key(ref_id)) { result += ~[ref_id]; }\n+    }\n+    ret result;\n+}\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "710b91a18a9ef74475f87f5e75453e3ae24f5f1a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 72, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "patch": "@@ -27,6 +27,7 @@ import syntax::ast;\n import syntax::walk;\n import driver::session;\n import middle::ty;\n+import middle::freevars;\n import back::link;\n import back::x86;\n import back::abi;\n@@ -4107,76 +4108,6 @@ fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n \n // Iterator translation\n \n-// Searches through part of the AST for all references to locals or\n-// upvars in this frame and returns the list of definition IDs thus found.\n-// Since we want to be able to collect upvars in some arbitrary piece\n-// of the AST, we take a walker function that we invoke with a visitor\n-// in order to start the search.\n-fn collect_upvars(&@block_ctxt cx, &fn (&walk::ast_visitor) walker,\n-                  ast::node_id[] initial_decls) -> ast::node_id[] {\n-    type env =\n-        @rec(mutable ast::node_id[] refs,\n-             hashmap[ast::node_id, ()] decls,\n-             resolve::def_map def_map,\n-             session::session sess);\n-\n-    fn walk_fn(env e, &ast::_fn f, &ast::ty_param[] tps, &span sp,\n-               &ast::fn_ident i, ast::node_id nid) {\n-        for (ast::arg a in f.decl.inputs) { e.decls.insert(a.id, ()); }\n-    }\n-    fn walk_expr(env e, &@ast::expr expr) {\n-        alt (expr.node) {\n-            case (ast::expr_path(?path)) {\n-                if (! e.def_map.contains_key(expr.id)) {\n-                    e.sess.span_fatal(expr.span,\n-                       \"internal error in collect_upvars\");\n-                }\n-                alt (e.def_map.get(expr.id)) {\n-                    case (ast::def_arg(?did)) { e.refs += ~[did._1]; }\n-                    case (ast::def_local(?did)) { e.refs += ~[did._1]; }\n-                    case (ast::def_binding(?did)) { e.refs += ~[did._1]; }\n-                    case (_) { /* no-op */ }\n-                }\n-            }\n-            case (_) { }\n-        }\n-    }\n-    fn walk_local(env e, &@ast::local local) {\n-        e.decls.insert(local.node.id, ());\n-    }\n-    fn walk_pat(env e, &@ast::pat p) {\n-        alt (p.node) {\n-            case (ast::pat_bind(_)) {\n-                e.decls.insert(p.id, ());\n-            }\n-            case (_) {}\n-        }\n-    }\n-    let hashmap[ast::node_id, ()] decls = new_int_hash[()]();\n-    for (ast::node_id decl in initial_decls) { decls.insert(decl, ()); }\n-\n-    let env e =\n-        @rec(mutable refs=~[],\n-             decls=decls,\n-             def_map=cx.fcx.lcx.ccx.tcx.def_map,\n-             sess=cx.fcx.lcx.ccx.tcx.sess);\n-    auto visitor =\n-        @rec(visit_fn_pre=bind walk_fn(e, _, _, _, _, _),\n-             visit_local_pre=bind walk_local(e, _),\n-             visit_expr_pre=bind walk_expr(e, _),\n-             visit_pat_pre=bind walk_pat(e, _)\n-             with walk::default_visitor());\n-    walker(*visitor);\n-    // Calculate (refs - decls). This is the set of captured upvars.\n-\n-    let ast::node_id[] result = ~[];\n-    for (ast::node_id ref_id_ in e.refs) {\n-        auto ref_id = ref_id_;\n-        if (!decls.contains_key(ref_id)) { result += ~[ref_id]; }\n-    }\n-    ret result;\n-}\n-\n // Finds the ValueRef associated with a variable in a function\n // context. It checks locals, upvars, and args.\n fn find_variable(&@fn_ctxt fcx, ast::node_id nid) -> ValueRef {\n@@ -4353,8 +4284,9 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     // FIXME: possibly support alias-mode here?\n     auto decl_ty = node_id_type(lcx.ccx, local.node.id);\n     auto decl_id = local.node.id;\n-    auto upvars = collect_upvars(cx, bind walk::walk_block(_, body),\n-                                 ~[decl_id]);\n+    auto upvars = freevars::collect_upvars(cx.fcx.lcx.ccx.tcx,\n+                                           bind walk::walk_block(_, body),\n+                                           ~[decl_id]);\n \n     auto environment_data = build_environment(cx, upvars);\n     auto llenvptr = environment_data._0;"}, {"sha": "1970aa66cd29d4d9b56a32ffcd33956e9d613337", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=c4bcd0a44d64d43a5c1dfde73d4e3f94e2419da7", "patch": "@@ -26,6 +26,7 @@ mod middle {\n     mod resolve;\n     mod typeck;\n     mod alias;\n+    mod freevars;\n \n     mod tstate {\n         mod ck;"}]}