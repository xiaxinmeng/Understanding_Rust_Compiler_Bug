{"sha": "b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZDMwYjcyYmZhYTFmMzY4MDgxNTFlNTgyNTA3M2NkZmYyZTdlYTc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-02-06T22:38:33Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-02-06T22:38:33Z"}, "message": "Removed @self and @Trait.", "tree": {"sha": "14ff6b505eeee456236727940e5804e3e812b1b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14ff6b505eeee456236727940e5804e3e812b1b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "html_url": "https://github.com/rust-lang/rust/commit/b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "html_url": "https://github.com/rust-lang/rust/commit/c13a929d58c3f866687ccf12cc33b2b59a2e10b8"}], "stats": {"total": 2321, "additions": 627, "deletions": 1694}, "files": [{"sha": "ff2e2b5236998bb148bfc60494b5b753754cf7f3", "filename": "src/doc/rust.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -1335,7 +1335,7 @@ to pointers to the trait name, used as a type.\n # impl Shape for int { }\n # let mycircle = 0;\n \n-let myshape: @Shape = @mycircle as @Shape;\n+let myshape: ~Shape = ~mycircle as ~Shape;\n ~~~~\n \n The resulting value is a managed box containing the value that was cast,\n@@ -1396,7 +1396,7 @@ Likewise, supertrait methods may also be called on trait objects.\n # impl Circle for int { fn radius(&self) -> f64 { 0.0 } }\n # let mycircle = 0;\n \n-let mycircle: Circle = @mycircle as @Circle;\n+let mycircle: Circle = ~mycircle as ~Circle;\n let nonsense = mycircle.radius() * mycircle.area();\n ~~~~\n \n@@ -3290,8 +3290,8 @@ Whereas most calls to trait methods are \"early bound\" (statically resolved) to s\n a call to a method on an object type is only resolved to a vtable entry at compile time.\n The actual implementation for each vtable entry can vary on an object-by-object basis.\n \n-Given a pointer-typed expression `E` of type `&T`, `~T` or `@T`, where `T` implements trait `R`,\n-casting `E` to the corresponding pointer type `&R`, `~R` or `@R` results in a value of the _object type_ `R`.\n+Given a pointer-typed expression `E` of type `&T` or `~T`, where `T` implements trait `R`,\n+casting `E` to the corresponding pointer type `&R` or `~R` results in a value of the _object type_ `R`.\n This result is represented as a pair of pointers:\n the vtable pointer for the `T` implementation of `R`, and the pointer value of `E`.\n \n@@ -3306,12 +3306,12 @@ impl Printable for int {\n   fn to_string(&self) -> ~str { self.to_str() }\n }\n \n-fn print(a: @Printable) {\n+fn print(a: ~Printable) {\n    println!(\"{}\", a.to_string());\n }\n \n fn main() {\n-   print(@10 as @Printable);\n+   print(~10 as ~Printable);\n }\n ~~~~\n "}, {"sha": "5d60b90a8f36c2f36b3e73b7f7b2e935bc3288d7", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -1857,7 +1857,7 @@ like any other function, except for the name `self`.\n \n The type of `self` is the type on which the method is implemented,\n or a pointer thereof. As an argument it is written either `self`,\n-`&self`, `@self`, or `~self`.\n+`&self`, or `~self`.\n A caller must in turn have a compatible pointer type to call the method.\n \n ~~~\n@@ -1870,14 +1870,12 @@ A caller must in turn have a compatible pointer type to call the method.\n # }\n impl Shape {\n     fn draw_reference(&self) { ... }\n-    fn draw_managed(@self) { ... }\n     fn draw_owned(~self) { ... }\n     fn draw_value(self) { ... }\n }\n \n let s = Circle(Point { x: 1.0, y: 2.0 }, 3.0);\n \n-(@s).draw_managed();\n (~s).draw_owned();\n (&s).draw_reference();\n s.draw_value();\n@@ -1897,7 +1895,6 @@ to a reference.\n # }\n # impl Shape {\n #    fn draw_reference(&self) { ... }\n-#    fn draw_managed(@self) { ... }\n #    fn draw_owned(~self) { ... }\n #    fn draw_value(self) { ... }\n # }\n@@ -2368,29 +2365,29 @@ an _object_.\n \n ~~~~\n # trait Drawable { fn draw(&self); }\n-fn draw_all(shapes: &[@Drawable]) {\n+fn draw_all(shapes: &[~Drawable]) {\n     for shape in shapes.iter() { shape.draw(); }\n }\n ~~~~\n \n-In this example, there is no type parameter. Instead, the `@Drawable`\n-type denotes any managed box value that implements the `Drawable`\n-trait. To construct such a value, you use the `as` operator to cast a\n-value to an object:\n+In this example, there is no type parameter. Instead, the `~Drawable`\n+type denotes any owned box value that implements the `Drawable` trait.\n+To construct such a value, you use the `as` operator to cast a value\n+to an object:\n \n ~~~~\n # type Circle = int; type Rectangle = bool;\n # trait Drawable { fn draw(&self); }\n # fn new_circle() -> Circle { 1 }\n # fn new_rectangle() -> Rectangle { true }\n-# fn draw_all(shapes: &[@Drawable]) {}\n+# fn draw_all(shapes: &[~Drawable]) {}\n \n impl Drawable for Circle { fn draw(&self) { ... } }\n impl Drawable for Rectangle { fn draw(&self) { ... } }\n \n-let c: @Circle = @new_circle();\n-let r: @Rectangle = @new_rectangle();\n-draw_all([c as @Drawable, r as @Drawable]);\n+let c: ~Circle = ~new_circle();\n+let r: ~Rectangle = ~new_rectangle();\n+draw_all([c as ~Drawable, r as ~Drawable]);\n ~~~~\n \n We omit the code for `new_circle` and `new_rectangle`; imagine that\n@@ -2407,8 +2404,6 @@ for example, an `@Circle` may not be cast to an `~Drawable`.\n # impl Drawable for int { fn draw(&self) {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n-// A managed object\n-let boxy: @Drawable = @new_circle() as @Drawable;\n // An owned object\n let owny: ~Drawable = ~new_circle() as ~Drawable;\n // A borrowed object\n@@ -2427,7 +2422,6 @@ particular set of built-in kinds that their contents must fulfill in\n order to be packaged up in a trait object of that storage class.\n \n * The contents of owned traits (`~Trait`) must fulfill the `Send` bound.\n-* The contents of managed traits (`@Trait`) must fulfill the `'static` bound.\n * The contents of reference traits (`&Trait`) are not constrained by any bound.\n \n Consequently, the trait objects themselves automatically fulfill their\n@@ -2439,7 +2433,6 @@ to fulfilling `Send`, contents must also fulfill `Freeze`, and as a consequence,\n the trait itself fulfills `Freeze`.\n \n * `~Trait:Send` is equivalent to `~Trait`.\n-* `@Trait:'static` is equivalent to `@Trait`.\n * `&Trait:` is equivalent to `&Trait`.\n \n Builtin kind bounds can also be specified on closure types in the same way (for"}, {"sha": "d2c2763eab1ac24949c5d4377f73429417284ed8", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -42,6 +42,7 @@ use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::codemap;\n use syntax::diagnostic;\n+use syntax::diagnostic::Emitter;\n use syntax::ext::base::CrateLoader;\n use syntax::parse;\n use syntax::parse::token::InternedString;\n@@ -136,10 +137,10 @@ pub fn build_configuration(sess: Session) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: ~[~str], demitter: @diagnostic::Emitter)\n+fn parse_cfgspecs(cfgspecs: ~[~str])\n                   -> ast::CrateConfig {\n     cfgspecs.move_iter().map(|s| {\n-        let sess = parse::new_parse_sess(Some(demitter));\n+        let sess = parse::new_parse_sess();\n         parse::parse_meta_from_source_str(\"cfgspec\".to_str(), s, ~[], sess)\n     }).collect::<ast::CrateConfig>()\n }\n@@ -539,9 +540,7 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &Input,\n     phase_6_link_output(sess, &trans, &outputs);\n }\n \n-struct IdentifiedAnnotation {\n-    contents: (),\n-}\n+struct IdentifiedAnnotation;\n \n impl pprust::PpAnn for IdentifiedAnnotation {\n     fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -619,18 +618,16 @@ pub fn pretty_print_input(sess: Session,\n \n     let annotation = match ppm {\n         PpmIdentified | PpmExpandedIdentified => {\n-            @IdentifiedAnnotation {\n-                contents: (),\n-            } as @pprust::PpAnn\n+            ~IdentifiedAnnotation as ~pprust::PpAnn\n         }\n         PpmTyped => {\n             let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n             let analysis = phase_3_run_analysis_passes(sess, &crate, ast_map);\n-            @TypedAnnotation {\n+            ~TypedAnnotation {\n                 analysis: analysis\n-            } as @pprust::PpAnn\n+            } as ~pprust::PpAnn:\n         }\n-        _ => @pprust::NoAnn as @pprust::PpAnn,\n+        _ => ~pprust::NoAnn as ~pprust::PpAnn:,\n     };\n \n     let src = &sess.codemap.get_filemap(source_name(input)).src;\n@@ -682,17 +679,15 @@ static architecture_abis : &'static [(&'static str, abi::Architecture)] = &'stat\n \n     (\"mips\",   abi::Mips)];\n \n-pub fn build_target_config(sopts: @session::Options,\n-                           demitter: @diagnostic::Emitter)\n+pub fn build_target_config(sopts: @session::Options)\n                            -> @session::Config {\n     let os = match get_os(sopts.target_triple) {\n       Some(os) => os,\n-      None => early_error(demitter, \"unknown operating system\")\n+      None => early_error(\"unknown operating system\")\n     };\n     let arch = match get_arch(sopts.target_triple) {\n       Some(arch) => arch,\n-      None => early_error(demitter,\n-                          \"unknown architecture: \" + sopts.target_triple)\n+      None => early_error(\"unknown architecture: \" + sopts.target_triple)\n     };\n     let (int_type, uint_type) = match arch {\n       abi::X86 => (ast::TyI32, ast::TyU32),\n@@ -730,8 +725,7 @@ pub fn host_triple() -> ~str {\n }\n \n pub fn build_session_options(binary: ~str,\n-                             matches: &getopts::Matches,\n-                             demitter: @diagnostic::Emitter)\n+                             matches: &getopts::Matches)\n                              -> @session::Options {\n     let crate_types = matches.opt_strs(\"crate-type\").flat_map(|s| {\n         s.split(',').map(|part| {\n@@ -741,8 +735,7 @@ pub fn build_session_options(binary: ~str,\n                 \"staticlib\" => session::CrateTypeStaticlib,\n                 \"dylib\"     => session::CrateTypeDylib,\n                 \"bin\"       => session::CrateTypeExecutable,\n-                _ => early_error(demitter,\n-                                 format!(\"unknown crate type: `{}`\", part))\n+                _ => early_error(format!(\"unknown crate type: `{}`\", part))\n             }\n         }).collect()\n     });\n@@ -767,8 +760,8 @@ pub fn build_session_options(binary: ~str,\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n               None => {\n-                early_error(demitter, format!(\"unknown {} flag: {}\",\n-                                           level_name, lint_name));\n+                early_error(format!(\"unknown {} flag: {}\",\n+                                    level_name, lint_name));\n               }\n               Some(lint) => {\n                 lint_opts.push((lint.lint, *level));\n@@ -787,7 +780,7 @@ pub fn build_session_options(binary: ~str,\n             if *name == *debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0 {\n-            early_error(demitter, format!(\"unknown debug flag: {}\", *debug_flag))\n+            early_error(format!(\"unknown debug flag: {}\", *debug_flag))\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -807,9 +800,7 @@ pub fn build_session_options(binary: ~str,\n                     \"bc\"   => link::OutputTypeBitcode,\n                     \"obj\"  => link::OutputTypeObject,\n                     \"link\" => link::OutputTypeExe,\n-                    _ => early_error(demitter,\n-                                     format!(\"unknown emission type: `{}`\",\n-                                             part))\n+                    _ => early_error(format!(\"unknown emission type: `{}`\", part))\n                 }\n             }).collect()\n         })\n@@ -830,7 +821,7 @@ pub fn build_session_options(binary: ~str,\n             No\n         } else if matches.opt_present(\"O\") {\n             if matches.opt_present(\"opt-level\") {\n-                early_error(demitter, \"-O and --opt-level both provided\");\n+                early_error(\"-O and --opt-level both provided\");\n             }\n             Default\n         } else if matches.opt_present(\"opt-level\") {\n@@ -840,7 +831,7 @@ pub fn build_session_options(binary: ~str,\n               ~\"2\" => Default,\n               ~\"3\" => Aggressive,\n               _ => {\n-                early_error(demitter, \"optimization level needs to be between 0-3\")\n+                early_error(\"optimization level needs to be between 0-3\")\n               }\n             }\n         } else { No }\n@@ -865,7 +856,7 @@ pub fn build_session_options(binary: ~str,\n         }).collect()\n     });\n \n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"), demitter);\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let test = matches.opt_present(\"test\");\n     let android_cross_path = matches.opt_str(\"android-cross-path\");\n     let write_dependency_info = (matches.opt_present(\"dep-info\"),\n@@ -926,25 +917,23 @@ pub fn build_session_options(binary: ~str,\n }\n \n pub fn build_session(sopts: @session::Options,\n-                     local_crate_source_file: Option<Path>,\n-                     demitter: @diagnostic::Emitter)\n+                     local_crate_source_file: Option<Path>)\n                      -> Session {\n     let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::mk_handler(Some(demitter));\n+        diagnostic::mk_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    build_session_(sopts, local_crate_source_file, codemap, demitter, span_diagnostic_handler)\n+    build_session_(sopts, local_crate_source_file, codemap, span_diagnostic_handler)\n }\n \n pub fn build_session_(sopts: @session::Options,\n                       local_crate_source_file: Option<Path>,\n                       codemap: @codemap::CodeMap,\n-                      demitter: @diagnostic::Emitter,\n                       span_diagnostic_handler: @diagnostic::SpanHandler)\n                       -> Session {\n-    let target_cfg = build_target_config(sopts, demitter);\n+    let target_cfg = build_target_config(sopts);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler, codemap);\n     let cstore = @CStore::new(token::get_ident_interner());\n     let filesearch = @filesearch::FileSearch::new(\n@@ -1167,8 +1156,8 @@ pub fn build_output_filenames(input: &Input,\n     }\n }\n \n-pub fn early_error(emitter: &diagnostic::Emitter, msg: &str) -> ! {\n-    emitter.emit(None, msg, diagnostic::Fatal);\n+pub fn early_error(msg: &str) -> ! {\n+    diagnostic::DefaultEmitter.emit(None, msg, diagnostic::Fatal);\n     fail!(diagnostic::FatalError);\n }\n \n@@ -1198,8 +1187,8 @@ mod test {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n-        let sessopts = build_session_options(~\"rustc\", matches, @diagnostic::DefaultEmitter);\n-        let sess = build_session(sessopts, None, @diagnostic::DefaultEmitter);\n+        let sessopts = build_session_options(~\"rustc\", matches);\n+        let sess = build_session(sessopts, None);\n         let cfg = build_configuration(sess);\n         assert!((attr::contains_name(cfg, \"test\")));\n     }\n@@ -1216,8 +1205,8 @@ mod test {\n                        f.to_err_msg());\n               }\n             };\n-        let sessopts = build_session_options(~\"rustc\", matches, @diagnostic::DefaultEmitter);\n-        let sess = build_session(sessopts, None, @diagnostic::DefaultEmitter);\n+        let sessopts = build_session_options(~\"rustc\", matches);\n+        let sess = build_session(sessopts, None);\n         let cfg = build_configuration(sess);\n         let mut test_items = cfg.iter().filter(|m| m.name().equiv(&(\"test\")));\n         assert!(test_items.next().is_some());"}, {"sha": "452499af7cff9e42283ae8eed5993633d92c1ccf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -193,7 +193,7 @@ pub fn describe_debug_flags() {\n     }\n }\n \n-pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n+pub fn run_compiler(args: &[~str]) {\n     let mut args = args.to_owned();\n     let binary = args.shift().unwrap();\n \n@@ -203,7 +203,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n         &match getopts::getopts(args, d::optgroups()) {\n           Ok(m) => m,\n           Err(f) => {\n-            d::early_error(demitter, f.to_err_msg());\n+            d::early_error(f.to_err_msg());\n           }\n         };\n \n@@ -235,7 +235,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n         return;\n     }\n     let (input, input_file_path) = match matches.free.len() {\n-      0u => d::early_error(demitter, \"no input filename given\"),\n+      0u => d::early_error(\"no input filename given\"),\n       1u => {\n         let ifile = matches.free[0].as_slice();\n         if ifile == \"-\" {\n@@ -246,11 +246,11 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n             (d::FileInput(Path::new(ifile)), Some(Path::new(ifile)))\n         }\n       }\n-      _ => d::early_error(demitter, \"multiple input filenames provided\")\n+      _ => d::early_error(\"multiple input filenames provided\")\n     };\n \n-    let sopts = d::build_session_options(binary, matches, demitter);\n-    let sess = d::build_session(sopts, input_file_path, demitter);\n+    let sopts = d::build_session_options(binary, matches);\n+    let sess = d::build_session(sopts, input_file_path);\n     let odir = matches.opt_str(\"out-dir\").map(|o| Path::new(o));\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n     let cfg = d::build_configuration(sess);\n@@ -273,7 +273,7 @@ pub fn run_compiler(args: &[~str], demitter: @diagnostic::Emitter) {\n                              &mut stdout as &mut io::Writer).unwrap();\n           }\n           d::StrInput(_) => {\n-            d::early_error(demitter, \"can not list metadata for stdin\");\n+            d::early_error(\"can not list metadata for stdin\");\n           }\n         }\n         return;\n@@ -337,7 +337,7 @@ fn parse_crate_attrs(sess: session::Session,\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor(f: proc(@diagnostic::Emitter)) {\n+pub fn monitor(f: proc()) {\n     // FIXME: This is a hack for newsched since it doesn't support split stacks.\n     // rustc needs a lot of stack! When optimizations are disabled, it needs\n     // even *more* stack than usual as well.\n@@ -361,7 +361,7 @@ pub fn monitor(f: proc(@diagnostic::Emitter)) {\n \n     match task_builder.try(proc() {\n         io::stdio::set_stderr(~w as ~io::Writer);\n-        f(@diagnostic::DefaultEmitter)\n+        f()\n     }) {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n@@ -400,6 +400,6 @@ pub fn main() {\n \n pub fn main_args(args: &[~str]) -> int {\n     let owned_args = args.to_owned();\n-    monitor(proc(demitter) run_compiler(owned_args, demitter));\n+    monitor(proc() run_compiler(owned_args));\n     0\n }"}, {"sha": "029682d93159b95de8b9d92fac75862c18f60196", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -772,7 +772,6 @@ fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n     match explicit_self_kind as char {\n         's' => ast::SelfStatic,\n         'v' => ast::SelfValue,\n-        '@' => ast::SelfBox,\n         '~' => ast::SelfUniq,\n         // FIXME(#4846) expl. region\n         '&' => ast::SelfRegion(None, get_mutability(string[1])),"}, {"sha": "07997577a9ff6d8083496eccc93c734287392928", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -671,7 +671,6 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n     match explicit_self {\n         SelfStatic => { ebml_w.writer.write(&[ 's' as u8 ]); }\n         SelfValue  => { ebml_w.writer.write(&[ 'v' as u8 ]); }\n-        SelfBox    => { ebml_w.writer.write(&[ '@' as u8 ]); }\n         SelfUniq   => { ebml_w.writer.write(&[ '~' as u8 ]); }\n         SelfRegion(_, m) => {\n             // FIXME(#4846) encode custom lifetime"}, {"sha": "8da097a1b6a2da25d87f664979af5990701c8106", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -164,7 +164,6 @@ fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::vstore {\n fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n-        '@' => ty::BoxTraitStore,\n         '&' => ty::RegionTraitStore(parse_region(st, conv)),\n         c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n     }"}, {"sha": "4f6ac8607ee1b055a179e75379a6840e992733d5", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -236,7 +236,6 @@ pub fn enc_trait_ref(w: &mut MemWriter, cx: @ctxt, s: &ty::TraitRef) {\n pub fn enc_trait_store(w: &mut MemWriter, cx: @ctxt, s: ty::TraitStore) {\n     match s {\n         ty::UniqTraitStore => mywrite!(w, \"~\"),\n-        ty::BoxTraitStore => mywrite!(w, \"@\"),\n         ty::RegionTraitStore(re) => {\n             mywrite!(w, \"&\");\n             enc_region(w, cx, re);"}, {"sha": "d59ec370e07b5cdef64f43471c0a81db287bea5f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -1427,10 +1427,7 @@ trait fake_ext_ctxt {\n }\n \n #[cfg(test)]\n-type fake_session = @parse::ParseSess;\n-\n-#[cfg(test)]\n-impl fake_ext_ctxt for fake_session {\n+impl fake_ext_ctxt for @parse::ParseSess {\n     fn cfg(&self) -> ast::CrateConfig { ~[] }\n     fn parse_sess(&self) -> @parse::ParseSess { *self }\n     fn call_site(&self) -> Span {\n@@ -1446,8 +1443,8 @@ impl fake_ext_ctxt for fake_session {\n }\n \n #[cfg(test)]\n-fn mk_ctxt() -> @fake_ext_ctxt {\n-    @parse::new_parse_sess(None) as @fake_ext_ctxt\n+fn mk_ctxt() -> @parse::ParseSess {\n+    parse::new_parse_sess()\n }\n \n #[cfg(test)]"}, {"sha": "38d54ddfb4201de115fa84dfefef55cd375c0f49", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -416,7 +416,7 @@ impl<'a> GatherLoanCtxt<'a> {\n             }\n \n             ty::AutoObject(..) => {\n-                // FIXME: Handle @Trait to &Trait casts here?\n+                // FIXME: Handle ~Trait to &Trait casts here?\n             }\n         }\n     }"}, {"sha": "6645450a970bc79754a38129ba29e611692611a1", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -347,16 +347,15 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n \n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n-            let this = @(*self).clone();\n-            this.pretty_print_to(~io::stderr() as ~io::Writer, blk).unwrap();\n+            self.pretty_print_to(~io::stderr(), blk).unwrap();\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(@self, wr: ~io::Writer,\n+    fn pretty_print_to(&self, wr: ~io::Writer,\n                        blk: &ast::Block) -> io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self.tcx.sess.intr(),\n-                                                    self as @pprust::PpAnn);\n+                                                    self as &pprust::PpAnn);\n         if_ok!(pprust::cbox(&mut ps, pprust::indent_unit));\n         if_ok!(pprust::ibox(&mut ps, 0u));\n         if_ok!(pprust::print_block(&mut ps, blk));"}, {"sha": "3568f59d9a2ded2f6620ecafaa698bb1664e80f9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -660,17 +660,15 @@ impl<'a> AstConv for Context<'a>{\n     }\n \n     fn ty_infer(&self, _span: Span) -> ty::t {\n-        let infcx: @infer::InferCtxt = infer::new_infer_ctxt(self.tcx);\n-        infcx.next_ty_var()\n+        infer::new_infer_ctxt(self.tcx).next_ty_var()\n     }\n }\n \n \n fn check_unused_casts(cx: &Context, e: &ast::Expr) {\n     return match e.node {\n         ast::ExprCast(expr, ty) => {\n-            let infcx: @infer::InferCtxt = infer::new_infer_ctxt(cx.tcx);\n-            let t_t = ast_ty_to_ty(cx, &infcx, ty);\n+            let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n             if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n                 cx.span_lint(UnnecessaryTypecast, ty.span,\n                              \"unnecessary type cast\");\n@@ -887,8 +885,7 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n         let mut n_uniq = 0;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {\n-                ty::ty_box(_) |\n-                ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n+                ty::ty_box(_) => {\n                     n_box += 1;\n                 }\n                 ty::ty_uniq(_) | ty::ty_str(ty::vstore_uniq) |"}, {"sha": "7c5d1439edfcbe02b3066afcbc9a28fd0e289a30", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -177,8 +177,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n-        ty::ty_box(_) |\n-        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n+        ty::ty_box(_) => {\n             Some(deref_ptr(gc_ptr))\n         }\n \n@@ -1105,7 +1104,7 @@ pub enum AliasableReason {\n }\n \n impl cmt_ {\n-    pub fn guarantor(@self) -> cmt {\n+    pub fn guarantor(self) -> cmt {\n         //! Returns `self` after stripping away any owned pointer derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live.\n@@ -1119,7 +1118,7 @@ impl cmt_ {\n             cat_deref(_, _, unsafe_ptr(..)) |\n             cat_deref(_, _, gc_ptr) |\n             cat_deref(_, _, region_ptr(..)) => {\n-                self\n+                @self\n             }\n             cat_downcast(b) |\n             cat_stack_upvar(b) |"}, {"sha": "e54b2ab29b2e96faba91936326670cd56d19d072", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -34,7 +34,7 @@ pub fn check_not_terminated(cx: &Block) {\n     }\n }\n \n-pub fn B(cx: &Block) -> Builder {\n+pub fn B<'a>(cx: &'a Block) -> Builder<'a> {\n     let b = cx.fcx.ccx.builder();\n     b.position_at_end(cx.llbb);\n     b"}, {"sha": "e4eeaa5fded7f7fbb500cf657bd1fc5e1ba0b2fb", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -23,9 +23,9 @@ use std::libc::{c_uint, c_ulonglong, c_char};\n use syntax::codemap::Span;\n use std::ptr::is_not_null;\n \n-pub struct Builder {\n+pub struct Builder<'a> {\n     llbuilder: BuilderRef,\n-    ccx: @CrateContext,\n+    ccx: &'a CrateContext,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -37,8 +37,8 @@ pub fn noname() -> *c_char {\n     }\n }\n \n-impl Builder {\n-    pub fn new(ccx: @CrateContext) -> Builder {\n+impl<'a> Builder<'a> {\n+    pub fn new(ccx: &'a CrateContext) -> Builder<'a> {\n         Builder {\n             llbuilder: ccx.builder.B,\n             ccx: ccx,"}, {"sha": "93d874cf83ee4a06ecd512b6f4084993ca45dd1e", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -237,7 +237,7 @@ impl CrateContext {\n         }\n     }\n \n-    pub fn builder(@self) -> Builder {\n+    pub fn builder<'a>(&'a self) -> Builder<'a> {\n         Builder::new(self)\n     }\n "}, {"sha": "ed233142238dcd6002b4f3de82fa97cd2cd8fb42", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -1130,17 +1130,39 @@ fn pointer_type_metadata(cx: &CrateContext,\n     return ptr_metadata;\n }\n \n-trait MemberDescriptionFactory {\n+enum MemberDescriptionFactory {\n+    StructMD(StructMemberDescriptionFactory),\n+    TupleMD(TupleMemberDescriptionFactory),\n+    GeneralMD(GeneralMemberDescriptionFactory),\n+    EnumVariantMD(EnumVariantMemberDescriptionFactory)\n+}\n+\n+impl MemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n-                                  -> ~[MemberDescription];\n+                                  -> ~[MemberDescription] {\n+        match *self {\n+            StructMD(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            TupleMD(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            GeneralMD(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+            EnumVariantMD(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n+        }\n+    }\n }\n \n struct StructMemberDescriptionFactory {\n     fields: ~[ty::field],\n     span: Span,\n }\n \n-impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n+impl StructMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.fields.map(|field| {\n@@ -1189,10 +1211,10 @@ fn prepare_struct_metadata(cx: &CrateContext,\n         metadata_stub: struct_metadata_stub,\n         llvm_type: struct_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: @StructMemberDescriptionFactory {\n+        member_description_factory: StructMD(StructMemberDescriptionFactory {\n             fields: fields,\n             span: span,\n-        } as @MemberDescriptionFactory,\n+        }),\n     }\n }\n \n@@ -1202,7 +1224,7 @@ enum RecursiveTypeDescription {\n         metadata_stub: DICompositeType,\n         llvm_type: Type,\n         file_metadata: DIFile,\n-        member_description_factory: @MemberDescriptionFactory,\n+        member_description_factory: MemberDescriptionFactory,\n     },\n     FinalMetadata(DICompositeType)\n }\n@@ -1217,7 +1239,7 @@ impl RecursiveTypeDescription {\n                 metadata_stub,\n                 llvm_type,\n                 file_metadata,\n-                member_description_factory\n+                ref member_description_factory\n             } => {\n                 // Insert the stub into the cache in order to allow recursive references ...\n                 {\n@@ -1246,7 +1268,7 @@ struct TupleMemberDescriptionFactory {\n     span: Span,\n }\n \n-impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n+impl TupleMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.component_types.map(|&component_type| {\n@@ -1281,10 +1303,10 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                                           span),\n         llvm_type: tuple_llvm_type,\n         file_metadata: file_metadata,\n-        member_description_factory: @TupleMemberDescriptionFactory {\n+        member_description_factory: TupleMD(TupleMemberDescriptionFactory {\n             component_types: component_types.to_owned(),\n             span: span,\n-        } as @MemberDescriptionFactory\n+        })\n     }\n }\n \n@@ -1297,7 +1319,7 @@ struct GeneralMemberDescriptionFactory {\n     span: Span,\n }\n \n-impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n+impl GeneralMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n@@ -1344,7 +1366,7 @@ struct EnumVariantMemberDescriptionFactory {\n     span: Span,\n }\n \n-impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n+impl EnumVariantMemberDescriptionFactory {\n     fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.args.iter().enumerate().map(|(i, &(ref name, ty))| {\n@@ -1368,7 +1390,7 @@ fn describe_enum_variant(cx: &CrateContext,\n                          containing_scope: DIScope,\n                          file_metadata: DIFile,\n                          span: Span)\n-                      -> (DICompositeType, Type, @MemberDescriptionFactory) {\n+                      -> (DICompositeType, Type, MemberDescriptionFactory) {\n     let variant_info_string = token::get_ident(variant_info.name.name);\n     let variant_name = variant_info_string.get();\n     let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n@@ -1424,11 +1446,11 @@ fn describe_enum_variant(cx: &CrateContext,\n         .collect();\n \n     let member_description_factory =\n-        @EnumVariantMemberDescriptionFactory {\n+        EnumVariantMD(EnumVariantMemberDescriptionFactory {\n             args: args,\n             discriminant_type_metadata: discriminant_type_metadata,\n             span: span,\n-        } as @MemberDescriptionFactory;\n+        });\n \n     (metadata_stub, variant_llvm_type, member_description_factory)\n }\n@@ -1556,14 +1578,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                 metadata_stub: enum_metadata,\n                 llvm_type: enum_llvm_type,\n                 file_metadata: file_metadata,\n-                member_description_factory: @GeneralMemberDescriptionFactory {\n+                member_description_factory: GeneralMD(GeneralMemberDescriptionFactory {\n                     type_rep: type_rep,\n                     variants: variants,\n                     discriminant_type_metadata: discriminant_type_metadata,\n                     containing_scope: containing_scope,\n                     file_metadata: file_metadata,\n                     span: span,\n-                } as @MemberDescriptionFactory,\n+                }),\n             }\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {"}, {"sha": "8f0101efb168cebc14915d324d014a38f043e3da", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 9, "deletions": 81, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -213,8 +213,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n                 }\n                 Some(AutoBorrowObj(..)) => {\n-                    unpack_datum!(bcx, auto_borrow_obj(\n-                        bcx, adj.autoderefs, expr, datum))\n+                    unpack_datum!(bcx, auto_borrow_obj(bcx, expr, datum))\n                 }\n             };\n         }\n@@ -326,88 +325,17 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         auto_ref(bcx, datum, expr)\n     }\n \n-    fn auto_borrow_obj<'a>(\n-                       mut bcx: &'a Block<'a>,\n-                       autoderefs: uint,\n-                       expr: &ast::Expr,\n-                       source_datum: Datum<Expr>)\n-                       -> DatumBlock<'a, Expr> {\n+    fn auto_borrow_obj<'a>(bcx: &'a Block<'a>,\n+                           expr: &ast::Expr,\n+                           source_datum: Datum<Expr>)\n+                           -> DatumBlock<'a, Expr> {\n         let tcx = bcx.tcx();\n         let target_obj_ty = expr_ty_adjusted(bcx, expr);\n-        debug!(\"auto_borrow_obj(target={})\",\n-               target_obj_ty.repr(tcx));\n-\n-        // Extract source store information\n-        let (source_store, source_mutbl) = match ty::get(source_datum.ty).sty {\n-            ty::ty_trait(_, _, s, m, _) => (s, m),\n-            _ => {\n-                bcx.sess().span_bug(\n-                    expr.span,\n-                    format!(\"auto_borrow_trait_obj expected a trait, found {}\",\n-                         source_datum.ty.repr(bcx.tcx())));\n-            }\n-        };\n-\n-        // check if any borrowing is really needed or we could reuse\n-        // the source_datum instead\n-        match ty::get(target_obj_ty).sty {\n-            ty::ty_trait(_, _, ty::RegionTraitStore(target_scope), target_mutbl, _) => {\n-                if target_mutbl == ast::MutImmutable && target_mutbl == source_mutbl {\n-                    match source_store {\n-                        ty::RegionTraitStore(source_scope) => {\n-                            if tcx.region_maps.is_subregion_of(target_scope, source_scope) {\n-                                return DatumBlock { bcx: bcx, datum: source_datum };\n-                            }\n-                        },\n-                        _ => {}\n+        debug!(\"auto_borrow_obj(target={})\", target_obj_ty.repr(tcx));\n \n-                    };\n-                }\n-            },\n-            _ => {}\n-        }\n-\n-        let scratch = rvalue_scratch_datum(bcx, target_obj_ty,\n-                                           \"__auto_borrow_obj\");\n-\n-        // Convert a @Object, ~Object, or &Object pair into an &Object pair.\n-\n-        // Get a pointer to the source object, which is represented as\n-        // a (vtable, data) pair.\n-        let source_datum = unpack_datum!(\n-            bcx, source_datum.to_lvalue_datum(bcx, \"auto_borrow_obj\", expr.id));\n-        let source_llval = source_datum.to_llref();\n-\n-        // Set the vtable field of the new pair\n-        let vtable_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_vtable]);\n-        let vtable = Load(bcx, vtable_ptr);\n-        Store(bcx, vtable, GEPi(bcx, scratch.val, [0u, abi::trt_field_vtable]));\n-\n-        // Load the data for the source, which is either an @T,\n-        // ~T, or &T, depending on source_obj_ty.\n-        let source_data_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_box]);\n-        let target_data = match source_store {\n-            ty::BoxTraitStore(..) => {\n-                // For deref of @T, create a dummy datum and use the\n-                // datum's deref method. This is more work than just\n-                // calling GEPi ourselves, but it ensures that any\n-                // necessary rooting is performed. Note that we don't\n-                // know the type T, so just substitute `i8`-- it\n-                // doesn't really matter for our purposes right now.\n-                let source_ty = ty::mk_box(tcx, ty::mk_i8());\n-                let source_datum = Datum(source_data_ptr, source_ty, LvalueExpr);\n-                let derefd_datum = unpack_datum!(\n-                    bcx, deref_once(bcx, expr, source_datum, autoderefs));\n-                derefd_datum.assert_lvalue(bcx).to_llref()\n-            }\n-            ty::UniqTraitStore(..) | ty::RegionTraitStore(..) => {\n-                Load(bcx, source_data_ptr)\n-            }\n-        };\n-        Store(bcx, target_data,\n-              GEPi(bcx, scratch.val, [0u, abi::trt_field_box]));\n-\n-        DatumBlock(bcx, scratch.to_expr_datum())\n+        let mut datum = source_datum.to_expr_datum();\n+        datum.ty = target_obj_ty;\n+        DatumBlock(bcx, datum)\n     }\n }\n "}, {"sha": "abf77b4b5fa950a55363e308f62d2d159a8525ac", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -65,9 +65,6 @@ pub fn take_ty<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     let _icx = push_ctxt(\"take_ty\");\n     match ty::get(t).sty {\n         ty::ty_box(_) => incr_refcnt_of_boxed(bcx, v),\n-        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n-            incr_refcnt_of_boxed(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]))\n-        }\n         _ if ty::type_is_structural(t)\n           && ty::type_needs_drop(bcx.tcx(), t) => {\n             iter_structural_ty(bcx, v, t, take_ty)\n@@ -323,7 +320,7 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n     let ccx = bcx.ccx();\n     match ty::get(t).sty {\n         ty::ty_box(body_ty) => {\n-            decr_refcnt_maybe_free(bcx, v0, Some(body_ty))\n+            decr_refcnt_maybe_free(bcx, v0, body_ty)\n         }\n         ty::ty_uniq(content_ty) => {\n             let llbox = Load(bcx, v0);\n@@ -354,10 +351,6 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n                 }\n             }\n         }\n-        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n-            let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n-            decr_refcnt_maybe_free(bcx, llbox_ptr, None)\n-        }\n         ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n             let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n             // Only drop the value when it is non-null\n@@ -400,8 +393,9 @@ fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t) -> &'a Block<'\n     }\n }\n \n-fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>, box_ptr_ptr: ValueRef,\n-                              t: Option<ty::t>) -> &'a Block<'a> {\n+fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>,\n+                              box_ptr_ptr: ValueRef,\n+                              t: ty::t) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let fcx = bcx.fcx;\n     let ccx = bcx.ccx();\n@@ -421,16 +415,7 @@ fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>, box_ptr_ptr: ValueRef,\n \n     let v = Load(free_bcx, box_ptr_ptr);\n     let body = GEPi(free_bcx, v, [0u, abi::box_field_body]);\n-    let free_bcx = match t {\n-        Some(t) => drop_ty(free_bcx, body, t),\n-        None => {\n-            // Generate code that, dynamically, indexes into the\n-            // tydesc and calls the drop glue that got set dynamically\n-            let td = Load(free_bcx, GEPi(free_bcx, v, [0u, abi::box_field_tydesc]));\n-            call_tydesc_glue_full(free_bcx, body, td, abi::tydesc_field_drop_glue, None);\n-            free_bcx\n-        }\n-    };\n+    let free_bcx = drop_ty(free_bcx, body, t);\n     let free_bcx = trans_free(free_bcx, v);\n     Br(free_bcx, next_bcx.llbb);\n "}, {"sha": "5d1c67a27ba2e6969628125d588f5d73f6032ba8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -350,7 +350,7 @@ fn trans_trait_callee<'a>(bcx: &'a Block<'a>,\n                           -> Callee<'a> {\n     /*!\n      * Create a method callee where the method is coming from a trait\n-     * object (e.g., @Trait type).  In this case, we must pull the fn\n+     * object (e.g., ~Trait type).  In this case, we must pull the fn\n      * pointer out of the vtable that is packaged up with the object.\n      * Objects are represented as a pair, so we first evaluate the self\n      * expression and then extract the self data and vtable out of the"}, {"sha": "8eccbf8d956a7420293cfb057504413d744a4c0d", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -13,8 +13,6 @@\n use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n use lib::llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n-use middle::ty;\n-\n use middle::trans::context::CrateContext;\n use middle::trans::base;\n \n@@ -245,14 +243,9 @@ impl Type {\n         ], false)\n     }\n \n-    pub fn opaque_trait(ctx: &CrateContext, store: ty::TraitStore) -> Type {\n+    pub fn opaque_trait() -> Type {\n         let vtable = Type::glue_fn(Type::i8p()).ptr_to().ptr_to();\n-        let box_ty = match store {\n-            ty::BoxTraitStore => Type::at_box(ctx, Type::i8()),\n-            ty::UniqTraitStore => Type::i8(),\n-            ty::RegionTraitStore(..) => Type::i8()\n-        };\n-        Type::struct_([vtable, box_ty.ptr_to()], false)\n+        Type::struct_([vtable, Type::i8p()], false)\n     }\n \n     pub fn kind(&self) -> TypeKind {"}, {"sha": "00d67a60ac4831cb2a2c4a37b16a7f0e1e0bfd41", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -129,7 +129,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n \n         ty::ty_bare_fn(..) => Type::i8p(),\n         ty::ty_closure(..) => Type::struct_([Type::i8p(), Type::i8p()], false),\n-        ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n+        ty::ty_trait(..) => Type::opaque_trait(),\n \n         ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n         ty::ty_vec(mt, ty::vstore_fixed(size)) => {\n@@ -262,7 +262,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n           Type::struct_([fn_ty, Type::i8p()], false)\n       }\n-      ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n+      ty::ty_trait(..) => Type::opaque_trait(),\n       ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);"}, {"sha": "1ff6da63fea24681f2717d42c44c32c388fbc39b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -135,7 +135,6 @@ pub enum vstore {\n \n #[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum TraitStore {\n-    BoxTraitStore,              // @Trait\n     UniqTraitStore,             // ~Trait\n     RegionTraitStore(Region),   // &Trait\n }\n@@ -238,7 +237,7 @@ pub enum AutoRef {\n     /// Convert from T to *T\n     AutoUnsafe(ast::Mutability),\n \n-    /// Convert from @Trait/~Trait/&Trait to &Trait\n+    /// Convert from ~Trait/&Trait to &Trait\n     AutoBorrowObj(Region, ast::Mutability),\n }\n \n@@ -2156,10 +2155,9 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         let st = match cty.sigil {\n             ast::BorrowedSigil =>\n                 object_contents(cx, RegionTraitStore(cty.region), MutMutable, cty.bounds),\n-            ast::ManagedSigil =>\n-                object_contents(cx, BoxTraitStore, MutImmutable, cty.bounds),\n             ast::OwnedSigil =>\n                 object_contents(cx, UniqTraitStore, MutImmutable, cty.bounds),\n+            ast::ManagedSigil => unreachable!()\n         };\n \n         // FIXME(#3569): This borrowed_contents call should be taken care of in\n@@ -2190,9 +2188,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             UniqTraitStore => {\n                 contents.owned_pointer()\n             }\n-            BoxTraitStore => {\n-                contents.managed_pointer()\n-            }\n             RegionTraitStore(r) => {\n                 contents.reference(borrowed_contents(r, mutbl))\n             }\n@@ -3060,7 +3055,7 @@ pub fn trait_adjustment_to_ty(cx: ctxt, sigil: &ast::Sigil, region: &Option<Regi\n     let trait_store = match *sigil {\n         BorrowedSigil => RegionTraitStore(region.expect(\"expected valid region\")),\n         OwnedSigil => UniqTraitStore,\n-        ManagedSigil => BoxTraitStore\n+        ManagedSigil => unreachable!()\n     };\n \n     mk_trait(cx, def_id, substs.clone(), trait_store, m, bounds)\n@@ -4935,10 +4930,9 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: ~str) -> u64 {\n                 hash.input([17]);\n                 did(&mut hash, d);\n                 match store {\n-                    BoxTraitStore => hash.input([0]),\n-                    UniqTraitStore => hash.input([1]),\n+                    UniqTraitStore => hash.input([0]),\n                     RegionTraitStore(r) => {\n-                        hash.input([2]);\n+                        hash.input([1]);\n                         region(&mut hash, r);\n                     }\n                 }"}, {"sha": "9c923077d7d60fda8d519e2d54f1595cd1c03378", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -211,7 +211,6 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n                                             -> ty::TraitStore {\n     match trait_store {\n         ty::UniqTraitStore      => ty::UniqTraitStore,\n-        ty::BoxTraitStore       => ty::BoxTraitStore,\n         ty::RegionTraitStore(r) => ty::RegionTraitStore(this.fold_region(r)),\n     }\n }"}, {"sha": "f80658e8ac20bf168900fe3f958de4fa4e6edabc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -409,7 +409,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         }\n     }\n \n-    // Handle @, ~, and & being able to mean strs and vecs.\n+    // Handle ~, and & being able to mean strs and vecs.\n     // If a_seq_ty is a str or a vec, make it a str/vec.\n     // Also handle first-class trait types.\n     fn mk_pointer<AC:AstConv,\n@@ -449,17 +449,16 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                         let result = ast_path_to_trait_ref(\n                             this, rscope, trait_def_id, None, path);\n                         let trait_store = match ptr_ty {\n-                            Box => ty::BoxTraitStore,\n                             VStore(ty::vstore_uniq) => ty::UniqTraitStore,\n                             VStore(ty::vstore_slice(r)) => {\n                                 ty::RegionTraitStore(r)\n                             }\n-                            VStore(ty::vstore_fixed(..)) => {\n+                            _ => {\n                                 tcx.sess.span_err(\n                                     path.span,\n-                                    \"@trait, ~trait or &trait are the only supported \\\n+                                    \"~trait or &trait are the only supported \\\n                                      forms of casting-to-trait\");\n-                                ty::BoxTraitStore\n+                                return ty::mk_err();\n                             }\n                         };\n                         let bounds = conv_builtin_bounds(this.tcx(), bounds, trait_store);\n@@ -546,7 +545,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                         // if none were specified.\n                         ast::BorrowedSigil => ty::RegionTraitStore(ty::ReEmpty), // dummy region\n                         ast::OwnedSigil    => ty::UniqTraitStore,\n-                        ast::ManagedSigil  => ty::BoxTraitStore,\n+                        ast::ManagedSigil  => return ty::mk_err()\n                     });\n                 let fn_decl = ty_of_closure(this,\n                                             rscope,\n@@ -718,9 +717,6 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::SelfBox => {\n-                Some(ty::mk_box(this.tcx(), self_info.untransformed_self_ty))\n-            }\n             ast::SelfUniq => {\n                 Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty))\n             }\n@@ -868,9 +864,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n         (&None, ty::UniqTraitStore) => {\n             let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundSend); set\n         }\n-        // @Trait is sugar for @Trait:'static.\n         // &'static Trait is sugar for &'static Trait:'static.\n-        (&None, ty::BoxTraitStore) |\n         (&None, ty::RegionTraitStore(ty::ReStatic)) => {\n             let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n         }"}, {"sha": "2463bf679d08f5cdc80bc543da40237c93a154b6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -72,9 +72,9 @@ Both the inherent candidate collection and the candidate selection\n proceed by progressively deref'ing the receiver type, after all.  The\n answer is that two phases are needed to elegantly deal with explicit\n self.  After all, if there is an impl for the type `Foo`, it can\n-define a method with the type `@self`, which means that it expects a\n-receiver of type `@Foo`.  If we have a receiver of type `@Foo`, but we\n-waited to search for that impl until we have deref'd the `@` away and\n+define a method with the type `~self`, which means that it expects a\n+receiver of type `~Foo`.  If we have a receiver of type `~Foo`, but we\n+waited to search for that impl until we have deref'd the `~` away and\n obtained the type `Foo`, we would never match this method.\n \n */\n@@ -101,7 +101,7 @@ use std::cell::RefCell;\n use std::hashmap::HashSet;\n use std::result;\n use std::vec;\n-use syntax::ast::{DefId, SelfValue, SelfRegion, SelfBox};\n+use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n use syntax::ast;\n@@ -201,8 +201,8 @@ pub struct Candidate {\n /// considered to \"match\" a given method candidate. Typically the test\n /// is whether the receiver is of a particular type. However, this\n /// type is the type of the receiver *after accounting for the\n-/// method's self type* (e.g., if the method is an `@self` method, we\n-/// have *already verified* that the receiver is of some type `@T` and\n+/// method's self type* (e.g., if the method is an `~self` method, we\n+/// have *already verified* that the receiver is of some type `~T` and\n /// now we must check that the type `T` is correct).  Unfortunately,\n /// because traits are not types, this is a pain to do.\n #[deriving(Clone)]\n@@ -1081,19 +1081,14 @@ impl<'a> LookupContext<'a> {\n             ast::SelfValue => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n-            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq => {\n+            ast::SelfRegion(..) | ast::SelfUniq => {\n                 let transformed_self_ty = method_ty.fty.sig.inputs[0];\n                 match ty::get(transformed_self_ty).sty {\n                     ty::ty_rptr(r, mt) => { // must be SelfRegion\n                         ty::mk_trait(self.tcx(), trait_def_id,\n                                      substs, RegionTraitStore(r), mt.mutbl,\n                                      ty::EmptyBuiltinBounds())\n                     }\n-                    ty::ty_box(_) => { // must be SelfBox\n-                        ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, BoxTraitStore, ast::MutImmutable,\n-                                     ty::EmptyBuiltinBounds())\n-                    }\n                     ty::ty_uniq(_) => { // must be SelfUniq\n                         ty::mk_trait(self.tcx(), trait_def_id,\n                                      substs, UniqTraitStore, ast::MutImmutable,\n@@ -1140,7 +1135,7 @@ impl<'a> LookupContext<'a> {\n                      through an object\");\n             }\n \n-            ast::SelfRegion(..) | ast::SelfBox | ast::SelfUniq => {}\n+            ast::SelfRegion(..) | ast::SelfUniq => {}\n         }\n \n         // reason (a) above\n@@ -1232,21 +1227,6 @@ impl<'a> LookupContext<'a> {\n                 }\n             }\n \n-            SelfBox => {\n-                debug!(\"(is relevant?) explicit self is a box\");\n-                match ty::get(rcvr_ty).sty {\n-                    ty::ty_box(typ) => {\n-                        rcvr_matches_ty(self.fcx, typ, candidate)\n-                    }\n-\n-                    ty::ty_trait(self_did, _, BoxTraitStore, ast::MutImmutable, _) => {\n-                        rcvr_matches_object(self_did, candidate)\n-                    }\n-\n-                    _ => false\n-                }\n-            }\n-\n             SelfUniq => {\n                 debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n@@ -1360,8 +1340,8 @@ impl<'a> LookupContext<'a> {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&self) -> @infer::InferCtxt {\n-        self.fcx.inh.infcx\n+    fn infcx(&'a self) -> &'a infer::InferCtxt {\n+        &self.fcx.inh.infcx\n     }\n \n     fn tcx(&self) -> ty::ctxt {"}, {"sha": "42d9e6f88e2897ad171dbe817c13d1efa37f4b12", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -154,7 +154,7 @@ pub mod method;\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct Inherited {\n-    infcx: @infer::InferCtxt,\n+    infcx: infer::InferCtxt,\n     locals: @RefCell<HashMap<ast::NodeId, ty::t>>,\n     param_env: ty::ParameterEnvironment,\n \n@@ -936,7 +936,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n     };\n     debug!(\"trait_fty (post-subst): {}\", trait_fty.repr(tcx));\n \n-    match infer::mk_subty(infcx, false, infer::MethodCompatCheck(impl_m_span),\n+    match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n                           impl_fty, trait_fty) {\n         result::Ok(()) => {}\n         result::Err(ref terr) => {\n@@ -967,8 +967,8 @@ impl AstConv for FnCtxt {\n }\n \n impl FnCtxt {\n-    pub fn infcx(&self) -> @infer::InferCtxt {\n-        self.inh.infcx\n+    pub fn infcx<'a>(&'a self) -> &'a infer::InferCtxt {\n+        &self.inh.infcx\n     }\n \n     pub fn err_count_since_creation(&self) -> uint {\n@@ -983,13 +983,12 @@ impl FnCtxt {\n     }\n }\n \n-impl RegionScope for @infer::InferCtxt {\n-    fn anon_regions(&self,\n-                    span: Span,\n-                    count: uint) -> Result<~[ty::Region], ()> {\n-        Ok(vec::from_fn(\n-                count,\n-                |_| self.next_region_var(infer::MiscVariable(span))))\n+impl RegionScope for infer::InferCtxt {\n+    fn anon_regions(&self, span: Span, count: uint)\n+                    -> Result<~[ty::Region], ()> {\n+        Ok(vec::from_fn(count, |_| {\n+            self.next_region_var(infer::MiscVariable(span))\n+        }))\n     }\n }\n \n@@ -1076,7 +1075,7 @@ impl FnCtxt {\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n-        ast_ty_to_ty(self, &self.infcx(), ast_t)\n+        ast_ty_to_ty(self, self.infcx(), ast_t)\n     }\n \n     pub fn pat_to_str(&self, pat: &ast::Pat) -> ~str {\n@@ -2243,7 +2242,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           &fcx.infcx(),\n+                                           fcx.infcx(),\n                                            expr.id,\n                                            sigil,\n                                            purity,"}, {"sha": "1a45a1d549137d2c6d95c2c6df354d81644d1827", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -1213,9 +1213,7 @@ pub mod guarantor {\n             ty::ty_vec(_, ty::vstore_uniq) => {\n                 OwnedPointer\n             }\n-            ty::ty_box(..) |\n-            ty::ty_ptr(..) |\n-            ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n+            ty::ty_box(..) | ty::ty_ptr(..) => {\n                 OtherPointer\n             }\n             ty::ty_closure(ref closure_ty) => {"}, {"sha": "64589e64f9837e2a83324435331870aea670c575", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -73,7 +73,7 @@ pub struct LocationInfo {\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext<'a> {\n-    infcx: @infer::InferCtxt,\n+    infcx: &'a infer::InferCtxt,\n     param_env: &'a ty::ParameterEnvironment,\n }\n \n@@ -578,11 +578,10 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n               // Look up vtables for the type we're casting to,\n               // passing in the source and target type.  The source\n               // must be a pointer type suitable to the object sigil,\n-              // e.g.: `@x as @Trait`, `&x as &Trait` or `~x as ~Trait`\n+              // e.g.: `&x as &Trait` or `~x as ~Trait`\n               let ty = structurally_resolved_type(fcx, ex.span,\n                                                   fcx.expr_ty(src));\n               match (&ty::get(ty).sty, store) {\n-                  (&ty::ty_box(..), ty::BoxTraitStore) |\n                   (&ty::ty_uniq(..), ty::UniqTraitStore)\n                     if !mutability_allowed(ast::MutImmutable,\n                                            target_mutbl) => {\n@@ -596,7 +595,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n                                               format!(\"types differ in mutability\"));\n                   }\n \n-                  (&ty::ty_box(..), ty::BoxTraitStore) |\n                   (&ty::ty_uniq(..), ty::UniqTraitStore) |\n                   (&ty::ty_rptr(..), ty::RegionTraitStore(..)) => {\n                     let typ = match &ty::get(ty).sty {\n@@ -657,14 +655,6 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: @FnCtxt, is_early: bool) {\n                                ty::ty_sort_str(fcx.tcx(), ty)));\n                   }\n \n-                  (_, ty::BoxTraitStore) => {\n-                      fcx.ccx.tcx.sess.span_err(\n-                          ex.span,\n-                          format!(\"can only cast an @-pointer \\\n-                                to an @-object, not a {}\",\n-                               ty::ty_sort_str(fcx.tcx(), ty)));\n-                  }\n-\n                   (_, ty::RegionTraitStore(_)) => {\n                       fcx.ccx.tcx.sess.span_err(\n                           ex.span,\n@@ -791,7 +781,7 @@ pub fn resolve_impl(ccx: @CrateCtxt,\n \n     let impl_trait_ref = @impl_trait_ref.subst(ccx.tcx, &param_env.free_substs);\n \n-    let infcx = infer::new_infer_ctxt(ccx.tcx);\n+    let infcx = &infer::new_infer_ctxt(ccx.tcx);\n     let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n     let loc_info = location_info_for_item(impl_item);\n "}, {"sha": "27d52aade93e608a6eb220c71d0d41196a1fb0a5", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 66, "deletions": 74, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -50,16 +50,16 @@ use std::hashmap::HashSet;\n use std::rc::Rc;\n use std::vec;\n \n-pub struct UniversalQuantificationResult {\n+struct UniversalQuantificationResult {\n     monotype: t,\n     type_variables: ~[ty::t],\n     type_param_defs: Rc<~[ty::TypeParameterDef]>\n }\n \n-pub fn get_base_type(inference_context: @InferCtxt,\n-                     span: Span,\n-                     original_type: t)\n-                  -> Option<t> {\n+fn get_base_type(inference_context: &InferCtxt,\n+                 span: Span,\n+                 original_type: t)\n+                 -> Option<t> {\n     let resolved_type;\n     match resolve_type(inference_context,\n                        original_type,\n@@ -92,7 +92,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n     }\n }\n \n-pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n+fn type_is_defined_in_local_crate(original_type: t) -> bool {\n     /*!\n      *\n      * For coherence, when we have `impl Trait for Type`, we need to\n@@ -119,10 +119,10 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n }\n \n // Returns the def ID of the base type, if there is one.\n-pub fn get_base_type_def_id(inference_context: @InferCtxt,\n-                            span: Span,\n-                            original_type: t)\n-                         -> Option<DefId> {\n+fn get_base_type_def_id(inference_context: &InferCtxt,\n+                        span: Span,\n+                        original_type: t)\n+                        -> Option<DefId> {\n     match get_base_type(inference_context, span, original_type) {\n         None => {\n             return None;\n@@ -143,21 +143,16 @@ pub fn get_base_type_def_id(inference_context: @InferCtxt,\n     }\n }\n \n-pub fn CoherenceChecker(crate_context: @CrateCtxt) -> CoherenceChecker {\n-    CoherenceChecker {\n-        crate_context: crate_context,\n-        inference_context: new_infer_ctxt(crate_context.tcx),\n-    }\n-}\n-\n-pub struct CoherenceChecker {\n+struct CoherenceChecker {\n     crate_context: @CrateCtxt,\n-    inference_context: @InferCtxt,\n+    inference_context: InferCtxt,\n }\n \n-struct CoherenceCheckVisitor { cc: CoherenceChecker }\n+struct CoherenceCheckVisitor<'a> {\n+    cc: &'a CoherenceChecker\n+}\n \n-impl visit::Visitor<()> for CoherenceCheckVisitor {\n+impl<'a> visit::Visitor<()> for CoherenceCheckVisitor<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n //      debug!(\"(checking coherence) item '{}'\",\n@@ -181,9 +176,9 @@ impl visit::Visitor<()> for CoherenceCheckVisitor {\n     }\n }\n \n-struct PrivilegedScopeVisitor { cc: CoherenceChecker }\n+struct PrivilegedScopeVisitor<'a> { cc: &'a CoherenceChecker }\n \n-impl visit::Visitor<()> for PrivilegedScopeVisitor {\n+impl<'a> visit::Visitor<()> for PrivilegedScopeVisitor<'a> {\n     fn visit_item(&mut self, item: &Item, _: ()) {\n \n         match item.node {\n@@ -232,11 +227,17 @@ impl visit::Visitor<()> for PrivilegedScopeVisitor {\n }\n \n impl CoherenceChecker {\n-    pub fn check_coherence(self, crate: &Crate) {\n+    fn new(crate_context: @CrateCtxt) -> CoherenceChecker {\n+        CoherenceChecker {\n+            crate_context: crate_context,\n+            inference_context: new_infer_ctxt(crate_context.tcx),\n+        }\n+    }\n+\n+    fn check(&self, crate: &Crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-\n         let mut visitor = CoherenceCheckVisitor { cc: self };\n         visit::walk_crate(&mut visitor, crate, ());\n \n@@ -257,9 +258,8 @@ impl CoherenceChecker {\n         self.populate_destructor_table();\n     }\n \n-    pub fn check_implementation(&self,\n-                                item: &Item,\n-                                associated_traits: &[TraitRef]) {\n+    fn check_implementation(&self, item: &Item,\n+                            associated_traits: &[TraitRef]) {\n         let tcx = self.crate_context.tcx;\n         let self_type = ty::lookup_item_type(tcx, local_def(item.id));\n \n@@ -271,7 +271,7 @@ impl CoherenceChecker {\n                     '{}'\",\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n-            match get_base_type_def_id(self.inference_context,\n+            match get_base_type_def_id(&self.inference_context,\n                                        item.span,\n                                        self_type.ty) {\n                 None => {\n@@ -301,7 +301,7 @@ impl CoherenceChecker {\n         // Add the implementation to the mapping from implementation to base\n         // type def ID, if there is a base type for this implementation and\n         // the implementation does not have any associated traits.\n-        match get_base_type_def_id(self.inference_context,\n+        match get_base_type_def_id(&self.inference_context,\n                                    item.span,\n                                    self_type.ty) {\n             None => {\n@@ -322,10 +322,9 @@ impl CoherenceChecker {\n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    pub fn instantiate_default_methods(&self,\n-                                       impl_id: ast::DefId,\n-                                       trait_ref: &ty::TraitRef,\n-                                       all_methods: &mut ~[@Method]) {\n+    fn instantiate_default_methods(&self, impl_id: ast::DefId,\n+                                   trait_ref: &ty::TraitRef,\n+                                   all_methods: &mut ~[@Method]) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id={:?}, trait_ref={})\",\n                impl_id, trait_ref.repr(tcx));\n@@ -385,9 +384,8 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn add_inherent_impl(&self,\n-                             base_def_id: DefId,\n-                             implementation: @Impl) {\n+    fn add_inherent_impl(&self, base_def_id: DefId,\n+                         implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n         let mut inherent_impls = tcx.inherent_impls.borrow_mut();\n@@ -405,9 +403,8 @@ impl CoherenceChecker {\n         implementation_list.get().push(implementation);\n     }\n \n-    pub fn add_trait_impl(&self,\n-                          base_def_id: DefId,\n-                          implementation: @Impl) {\n+    fn add_trait_impl(&self, base_def_id: DefId,\n+                      implementation: @Impl) {\n         let tcx = self.crate_context.tcx;\n         let implementation_list;\n         let mut trait_impls = tcx.trait_impls.borrow_mut();\n@@ -425,14 +422,14 @@ impl CoherenceChecker {\n         implementation_list.get().push(implementation);\n     }\n \n-    pub fn check_implementation_coherence(&self) {\n+    fn check_implementation_coherence(&self) {\n         let trait_impls = self.crate_context.tcx.trait_impls.borrow();\n         for &trait_id in trait_impls.get().keys() {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n \n-    pub fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n+    fn check_implementation_coherence_of(&self, trait_def_id: DefId) {\n         // Unify pairs of polytypes.\n         self.iter_impls_of_trait_local(trait_def_id, |a| {\n             let implementation_a = a;\n@@ -471,7 +468,7 @@ impl CoherenceChecker {\n         })\n     }\n \n-    pub fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n+    fn iter_impls_of_trait(&self, trait_def_id: DefId, f: |@Impl|) {\n         self.iter_impls_of_trait_local(trait_def_id, |x| f(x));\n \n         if trait_def_id.crate == LOCAL_CRATE {\n@@ -486,7 +483,7 @@ impl CoherenceChecker {\n         });\n     }\n \n-    pub fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |@Impl|) {\n+    fn iter_impls_of_trait_local(&self, trait_def_id: DefId, f: |@Impl|) {\n         let trait_impls = self.crate_context.tcx.trait_impls.borrow();\n         match trait_impls.get().find(&trait_def_id) {\n             Some(impls) => {\n@@ -499,10 +496,10 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn polytypes_unify(&self,\n-                           polytype_a: ty_param_bounds_and_ty,\n-                           polytype_b: ty_param_bounds_and_ty)\n-                           -> bool {\n+    fn polytypes_unify(&self,\n+                       polytype_a: ty_param_bounds_and_ty,\n+                       polytype_b: ty_param_bounds_and_ty)\n+                       -> bool {\n         let universally_quantified_a =\n             self.universally_quantify_polytype(polytype_a);\n         let universally_quantified_b =\n@@ -516,9 +513,8 @@ impl CoherenceChecker {\n \n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables. Returns the monotype and the type variables created.\n-    pub fn universally_quantify_polytype(&self,\n-                                         polytype: ty_param_bounds_and_ty)\n-                                         -> UniversalQuantificationResult {\n+    fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n+                                     -> UniversalQuantificationResult {\n         let region_parameter_count = polytype.generics.region_param_defs().len();\n         let region_parameters =\n             self.inference_context.next_region_vars(\n@@ -544,30 +540,28 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn can_unify_universally_quantified<'a>(&self,\n-                                                a: &'a\n-                                                UniversalQuantificationResult,\n-                                                b: &'a\n-                                                UniversalQuantificationResult)\n-                                                -> bool {\n-        infer::can_mk_subty(self.inference_context,\n+    fn can_unify_universally_quantified<'a>(&self,\n+                                            a: &'a UniversalQuantificationResult,\n+                                            b: &'a UniversalQuantificationResult)\n+                                            -> bool {\n+        infer::can_mk_subty(&self.inference_context,\n                             a.monotype,\n                             b.monotype).is_ok()\n     }\n \n-    pub fn get_self_type_for_implementation(&self, implementation: @Impl)\n-                                            -> ty_param_bounds_and_ty {\n+    fn get_self_type_for_implementation(&self, implementation: @Impl)\n+                                        -> ty_param_bounds_and_ty {\n         let tcache = self.crate_context.tcx.tcache.borrow();\n         return tcache.get().get_copy(&implementation.did);\n     }\n \n     // Privileged scope checking\n-    pub fn check_privileged_scopes(self, crate: &Crate) {\n-        let mut visitor = PrivilegedScopeVisitor{ cc: self };\n+    fn check_privileged_scopes(&self, crate: &Crate) {\n+        let mut visitor = PrivilegedScopeVisitor { cc: self };\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n \n-    pub fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n+    fn trait_ref_to_trait_def_id(&self, trait_ref: &TraitRef) -> DefId {\n         let def_map = self.crate_context.tcx.def_map;\n         let def_map = def_map.borrow();\n         let trait_def = def_map.get().get_copy(&trait_ref.ref_id);\n@@ -578,8 +572,7 @@ impl CoherenceChecker {\n     /// For coherence, when we have `impl Type`, we need to guarantee that\n     /// `Type` is \"local\" to the crate. For our purposes, this means that it\n     /// must precisely name some nominal type defined in this crate.\n-    pub fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty)\n-                                              -> bool {\n+    fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty) -> bool {\n         match original_type.node {\n             TyPath(_, _, path_id) => {\n                 let def_map = self.crate_context.tcx.def_map.borrow();\n@@ -614,7 +607,7 @@ impl CoherenceChecker {\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n-    pub fn create_impl_from_item(&self, item: &Item) -> @Impl {\n+    fn create_impl_from_item(&self, item: &Item) -> @Impl {\n         let tcx = self.crate_context.tcx;\n         match item.node {\n             ItemImpl(_, ref trait_refs, _, ref ast_methods) => {\n@@ -646,7 +639,7 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn span_of_impl(&self, implementation: @Impl) -> Span {\n+    fn span_of_impl(&self, implementation: @Impl) -> Span {\n         assert_eq!(implementation.did.crate, LOCAL_CRATE);\n         match self.crate_context.tcx.items.find(implementation.did.node) {\n             Some(NodeItem(item, _)) => {\n@@ -661,9 +654,9 @@ impl CoherenceChecker {\n \n     // External crate handling\n \n-    pub fn add_external_impl(&self,\n-                             impls_seen: &mut HashSet<DefId>,\n-                             impl_def_id: DefId) {\n+    fn add_external_impl(&self,\n+                         impls_seen: &mut HashSet<DefId>,\n+                         impl_def_id: DefId) {\n         let tcx = self.crate_context.tcx;\n         let implementation = @csearch::get_impl(tcx, impl_def_id);\n \n@@ -701,7 +694,7 @@ impl CoherenceChecker {\n \n     // Adds implementations and traits from external crates to the coherence\n     // info.\n-    pub fn add_external_crates(&self) {\n+    fn add_external_crates(&self) {\n         let mut impls_seen = HashSet::new();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n@@ -717,7 +710,7 @@ impl CoherenceChecker {\n     // Destructors\n     //\n \n-    pub fn populate_destructor_table(&self) {\n+    fn populate_destructor_table(&self) {\n         let tcx = self.crate_context.tcx;\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n@@ -853,6 +846,5 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n }\n \n pub fn check_coherence(crate_context: @CrateCtxt, crate: &Crate) {\n-    let coherence_checker = CoherenceChecker(crate_context);\n-    coherence_checker.check_coherence(crate);\n+    CoherenceChecker::new(crate_context).check(crate);\n }"}, {"sha": "0db17c8148e8087db3308378dd31930633f4ad8b", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -83,10 +83,10 @@ use syntax::ast;\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-pub struct Coerce(CombineFields);\n+pub struct Coerce<'f>(CombineFields<'f>);\n \n-impl Coerce {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields {\n+impl<'f> Coerce<'f> {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> {\n         let Coerce(ref v) = *self; v\n     }\n \n@@ -131,23 +131,6 @@ impl Coerce {\n                 });\n             }\n \n-            ty::ty_trait(def_id, ref substs, ty::BoxTraitStore, m, bounds) => {\n-                let result = self.unpack_actual_value(a, |sty_a| {\n-                    match *sty_a {\n-                        ty::ty_box(..) => {\n-                            self.coerce_object(a, sty_a, b, def_id, substs,\n-                                               ty::BoxTraitStore, m, bounds)\n-                        }\n-                        _ => Err(ty::terr_mismatch)\n-                    }\n-                });\n-\n-                match result {\n-                    Ok(t) => return Ok(t),\n-                    Err(..) => {}\n-                }\n-            }\n-\n             ty::ty_trait(def_id, ref substs, ty::UniqTraitStore, m, bounds) => {\n                 let result = self.unpack_actual_value(a, |sty_a| {\n                     match *sty_a {\n@@ -462,7 +445,6 @@ impl Coerce {\n                b.inf_str(self.get_ref().infcx));\n \n         let (sigil, region) = match trait_store {\n-            ty::BoxTraitStore => (ast::ManagedSigil, None),\n             ty::UniqTraitStore => (ast::OwnedSigil, None),\n             ty::RegionTraitStore(region) => (ast::BorrowedSigil, Some(region))\n         };"}, {"sha": "eb45065952da3f404a492b0057c897cef761ba58", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -69,14 +69,14 @@ use syntax::opt_vec;\n use syntax::abi::AbiSet;\n \n pub trait Combine {\n-    fn infcx(&self) -> @InferCtxt;\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt;\n     fn tag(&self) -> ~str;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n \n-    fn sub(&self) -> Sub;\n-    fn lub(&self) -> Lub;\n-    fn glb(&self) -> Glb;\n+    fn sub<'a>(&'a self) -> Sub<'a>;\n+    fn lub<'a>(&'a self) -> Lub<'a>;\n+    fn glb<'a>(&'a self) -> Glb<'a>;\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt>;\n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n@@ -329,8 +329,8 @@ pub trait Combine {\n     }\n }\n \n-pub struct CombineFields {\n-    infcx: @InferCtxt,\n+pub struct CombineFields<'a> {\n+    infcx: &'a InferCtxt,\n     a_is_expected: bool,\n     trace: TypeTrace,\n }"}, {"sha": "657b75a44ed305bbbbf50f3b08e330c739e324d4", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -77,33 +77,33 @@ use util::ppaux::bound_region_to_str;\n use util::ppaux::note_and_explain_region;\n \n pub trait ErrorReporting {\n-    fn report_region_errors(@self,\n+    fn report_region_errors(&self,\n                             errors: &OptVec<RegionResolutionError>);\n \n-    fn report_and_explain_type_error(@self,\n+    fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err);\n \n-    fn values_str(@self, values: &ValuePairs) -> Option<~str>;\n+    fn values_str(&self, values: &ValuePairs) -> Option<~str>;\n \n     fn expected_found_str<T:UserString+Resolvable>(\n-        @self,\n+        &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<~str>;\n \n-    fn report_concrete_failure(@self,\n+    fn report_concrete_failure(&self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n                                sup: Region);\n \n-    fn report_sub_sup_conflict(@self,\n+    fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n                                sub_region: Region,\n                                sup_origin: SubregionOrigin,\n                                sup_region: Region);\n \n-    fn report_sup_sup_conflict(@self,\n+    fn report_sup_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                origin1: SubregionOrigin,\n                                region1: Region,\n@@ -112,15 +112,15 @@ pub trait ErrorReporting {\n }\n \n trait ErrorReportingHelpers {\n-    fn report_inference_failure(@self,\n+    fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin);\n \n-    fn note_region_origin(@self,\n+    fn note_region_origin(&self,\n                           origin: SubregionOrigin);\n }\n \n impl ErrorReporting for InferCtxt {\n-    fn report_region_errors(@self,\n+    fn report_region_errors(&self,\n                             errors: &OptVec<RegionResolutionError>) {\n         for error in errors.iter() {\n             match *error {\n@@ -147,11 +147,9 @@ impl ErrorReporting for InferCtxt {\n         }\n     }\n \n-    fn report_and_explain_type_error(@self,\n+    fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace,\n                                      terr: &ty::type_err) {\n-        let tcx = self.tcx;\n-\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n@@ -174,12 +172,12 @@ impl ErrorReporting for InferCtxt {\n             format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(tcx, terr)));\n+                 ty::type_err_to_str(self.tcx, terr)));\n \n         ty::note_and_explain_type_err(self.tcx, terr);\n     }\n \n-    fn values_str(@self, values: &ValuePairs) -> Option<~str> {\n+    fn values_str(&self, values: &ValuePairs) -> Option<~str> {\n         /*!\n          * Returns a string of the form \"expected `{}` but found `{}`\",\n          * or None if this is a derived error.\n@@ -195,7 +193,7 @@ impl ErrorReporting for InferCtxt {\n     }\n \n     fn expected_found_str<T:UserString+Resolvable>(\n-        @self,\n+        &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<~str>\n     {\n@@ -214,7 +212,7 @@ impl ErrorReporting for InferCtxt {\n                   found.user_string(self.tcx)))\n     }\n \n-    fn report_concrete_failure(@self,\n+    fn report_concrete_failure(&self,\n                                origin: SubregionOrigin,\n                                sub: Region,\n                                sup: Region) {\n@@ -400,7 +398,7 @@ impl ErrorReporting for InferCtxt {\n         }\n     }\n \n-    fn report_sub_sup_conflict(@self,\n+    fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin,\n                                sub_region: Region,\n@@ -425,7 +423,7 @@ impl ErrorReporting for InferCtxt {\n         self.note_region_origin(sub_origin);\n     }\n \n-    fn report_sup_sup_conflict(@self,\n+    fn report_sup_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                origin1: SubregionOrigin,\n                                region1: Region,\n@@ -452,7 +450,7 @@ impl ErrorReporting for InferCtxt {\n }\n \n impl ErrorReportingHelpers for InferCtxt {\n-    fn report_inference_failure(@self,\n+    fn report_inference_failure(&self,\n                                 var_origin: RegionVariableOrigin) {\n         let var_description = match var_origin {\n             infer::MiscVariable(_) => ~\"\",\n@@ -484,7 +482,7 @@ impl ErrorReportingHelpers for InferCtxt {\n                     var_description));\n     }\n \n-    fn note_region_origin(@self, origin: SubregionOrigin) {\n+    fn note_region_origin(&self, origin: SubregionOrigin) {\n         match origin {\n             infer::Subtype(ref trace) => {\n                 let desc = match trace.origin {\n@@ -611,12 +609,12 @@ impl ErrorReportingHelpers for InferCtxt {\n }\n \n trait Resolvable {\n-    fn resolve(&self, infcx: @InferCtxt) -> Self;\n+    fn resolve(&self, infcx: &InferCtxt) -> Self;\n     fn contains_error(&self) -> bool;\n }\n \n impl Resolvable for ty::t {\n-    fn resolve(&self, infcx: @InferCtxt) -> ty::t {\n+    fn resolve(&self, infcx: &InferCtxt) -> ty::t {\n         infcx.resolve_type_vars_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {\n@@ -625,7 +623,7 @@ impl Resolvable for ty::t {\n }\n \n impl Resolvable for @ty::TraitRef {\n-    fn resolve(&self, infcx: @InferCtxt) -> @ty::TraitRef {\n+    fn resolve(&self, infcx: &InferCtxt) -> @ty::TraitRef {\n         @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n     }\n     fn contains_error(&self) -> bool {"}, {"sha": "4af6364642e8a1a4a0ed4d37d1be212c4ff743fd", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -28,21 +28,21 @@ use std::hashmap::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n-pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n+pub struct Glb<'f>(CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n \n-impl Glb {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields { let Glb(ref v) = *self; v }\n+impl<'f> Glb<'f> {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Glb(ref v) = *self; v }\n }\n \n-impl Combine for Glb {\n-    fn infcx(&self) -> @InferCtxt { self.get_ref().infcx }\n+impl<'f> Combine for Glb<'f> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"glb\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }\n \n-    fn sub(&self) -> Sub { Sub(*self.get_ref()) }\n-    fn lub(&self) -> Lub { Lub(*self.get_ref()) }\n-    fn glb(&self) -> Glb { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.get_ref().infcx.tcx;"}, {"sha": "d96cf84eb13633845e18df98987f6c70e4954bb5", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -109,7 +109,7 @@ pub trait CombineFieldsLatticeMethods {\n             -> ures;\n }\n \n-impl CombineFieldsLatticeMethods for CombineFields {\n+impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n     fn var_sub_var<T:Clone + InferStr + LatticeValue,\n                    V:Clone + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n                    &self,\n@@ -326,7 +326,7 @@ impl CombineFieldsLatticeMethods for CombineFields {\n // for pairs of variables or for variables and values.\n \n pub trait LatticeDir {\n-    fn combine_fields(&self) -> CombineFields;\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a>;\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T>;\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T>;\n }\n@@ -335,29 +335,29 @@ pub trait TyLatticeDir {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t>;\n }\n \n-impl LatticeDir for Lub {\n-    fn combine_fields(&self) -> CombineFields { *self.get_ref() }\n+impl<'f> LatticeDir for Lub<'f> {\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { *self.get_ref() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..(*b).clone() }\n     }\n }\n \n-impl TyLatticeDir for Lub {\n+impl<'f> TyLatticeDir for Lub<'f> {\n     fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n }\n \n-impl LatticeDir for Glb {\n-    fn combine_fields(&self) -> CombineFields { *self.get_ref() }\n+impl<'f> LatticeDir for Glb<'f> {\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { *self.get_ref() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..(*b).clone() }\n     }\n }\n \n-impl TyLatticeDir for Glb {\n+impl<'f> TyLatticeDir for Glb<'f> {\n     fn ty_bot(&self, _t: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot())\n     }"}, {"sha": "dc6df33327693f98e151b4aacabd37a43d2ae698", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -27,25 +27,25 @@ use syntax::ast::{ExternFn, ImpureFn, UnsafeFn};\n use syntax::ast::{Onceness, Purity};\n use util::ppaux::mt_to_str;\n \n-pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n+pub struct Lub<'f>(CombineFields<'f>);  // least-upper-bound: common supertype\n \n-impl Lub {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields { let Lub(ref v) = *self; v }\n+impl<'f> Lub<'f> {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Lub(ref v) = *self; v }\n     pub fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }\n     pub fn ty_bot(&self, b: ty::t) -> cres<ty::t> {\n         self.bot_ty(b) // commutative\n     }\n }\n \n-impl Combine for Lub {\n-    fn infcx(&self) -> @InferCtxt { self.get_ref().infcx }\n+impl<'f> Combine for Lub<'f> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"lub\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }\n \n-    fn sub(&self) -> Sub { Sub(*self.get_ref()) }\n-    fn lub(&self) -> Lub { Lub(*self.get_ref()) }\n-    fn glb(&self) -> Glb { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.get_ref().infcx.tcx;"}, {"sha": "abaeefd516720a8faeb2322deaeef84aabcba834", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -258,8 +258,8 @@ fn new_ValsAndBindings<V:Clone,T:Clone>() -> ValsAndBindings<V, T> {\n     }\n }\n \n-pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n-    @InferCtxt {\n+pub fn new_infer_ctxt(tcx: ty::ctxt) -> InferCtxt {\n+    InferCtxt {\n         tcx: tcx,\n \n         ty_var_bindings: RefCell::new(new_ValsAndBindings()),\n@@ -275,7 +275,7 @@ pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n     }\n }\n \n-pub fn common_supertype(cx: @InferCtxt,\n+pub fn common_supertype(cx: &InferCtxt,\n                         origin: TypeOrigin,\n                         a_is_expected: bool,\n                         a: ty::t,\n@@ -303,7 +303,7 @@ pub fn common_supertype(cx: @InferCtxt,\n     }\n }\n \n-pub fn mk_subty(cx: @InferCtxt,\n+pub fn mk_subty(cx: &InferCtxt,\n                 a_is_expected: bool,\n                 origin: TypeOrigin,\n                 a: ty::t,\n@@ -321,7 +321,7 @@ pub fn mk_subty(cx: @InferCtxt,\n     }).to_ures()\n }\n \n-pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty({} <: {})\", a.inf_str(cx), b.inf_str(cx));\n     indent(|| {\n         cx.probe(|| {\n@@ -334,7 +334,7 @@ pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     }).to_ures()\n }\n \n-pub fn mk_subr(cx: @InferCtxt,\n+pub fn mk_subr(cx: &InferCtxt,\n                _a_is_expected: bool,\n                origin: SubregionOrigin,\n                a: ty::Region,\n@@ -345,7 +345,7 @@ pub fn mk_subr(cx: @InferCtxt,\n     cx.region_vars.commit();\n }\n \n-pub fn mk_eqty(cx: @InferCtxt,\n+pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n                a: ty::t,\n@@ -364,7 +364,7 @@ pub fn mk_eqty(cx: @InferCtxt,\n     }).to_ures()\n }\n \n-pub fn mk_sub_trait_refs(cx: @InferCtxt,\n+pub fn mk_sub_trait_refs(cx: &InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n                          a: @ty::TraitRef,\n@@ -395,7 +395,7 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-pub fn mk_coercety(cx: @InferCtxt,\n+pub fn mk_coercety(cx: &InferCtxt,\n                    a_is_expected: bool,\n                    origin: TypeOrigin,\n                    a: ty::t,\n@@ -413,7 +413,7 @@ pub fn mk_coercety(cx: @InferCtxt,\n     })\n }\n \n-pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_coercety(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety({} -> {})\", a.inf_str(cx), b.inf_str(cx));\n     indent(|| {\n         cx.probe(|| {\n@@ -427,15 +427,15 @@ pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n // See comment on the type `resolve_state` below\n-pub fn resolve_type(cx: @InferCtxt,\n+pub fn resolve_type(cx: &InferCtxt,\n                     a: ty::t,\n                     modes: uint)\n                  -> fres<ty::t> {\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_type_chk(a)\n }\n \n-pub fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n+pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n                    -> fres<ty::Region> {\n     let mut resolver = resolver(cx, modes);\n     resolver.resolve_region_chk(r)\n@@ -502,18 +502,18 @@ struct Snapshot {\n }\n \n impl InferCtxt {\n-    pub fn combine_fields(@self, a_is_expected: bool, trace: TypeTrace)\n-                          -> CombineFields {\n+    pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n+                              -> CombineFields<'a> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn sub(@self, a_is_expected: bool, trace: TypeTrace) -> Sub {\n+    pub fn sub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Sub<'a> {\n         Sub(self.combine_fields(a_is_expected, trace))\n     }\n \n-    pub fn lub(@self, a_is_expected: bool, trace: TypeTrace) -> Lub {\n+    pub fn lub<'a>(&'a self, a_is_expected: bool, trace: TypeTrace) -> Lub<'a> {\n         Lub(self.combine_fields(a_is_expected, trace))\n     }\n \n@@ -547,7 +547,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` and commit the bindings if successful\n-    pub fn commit<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn commit<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n         assert!(!self.in_snapshot());\n \n         debug!(\"commit()\");\n@@ -564,7 +564,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f`, unroll bindings on failure\n-    pub fn try<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn try<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -579,7 +579,7 @@ impl InferCtxt {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(@self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n         debug!(\"probe()\");\n         indent(|| {\n             let snapshot = self.start_snapshot();\n@@ -661,34 +661,34 @@ impl InferCtxt {\n         self.region_vars.new_bound(binder_id)\n     }\n \n-    pub fn resolve_regions(@self) {\n+    pub fn resolve_regions(&self) {\n         let errors = self.region_vars.resolve_regions();\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n \n-    pub fn ty_to_str(@self, t: ty::t) -> ~str {\n+    pub fn ty_to_str(&self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    pub fn tys_to_str(@self, ts: &[ty::t]) -> ~str {\n+    pub fn tys_to_str(&self, ts: &[ty::t]) -> ~str {\n         let tstrs = ts.map(|t| self.ty_to_str(*t));\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_str(@self, t: &ty::TraitRef) -> ~str {\n+    pub fn trait_ref_to_str(&self, t: &ty::TraitRef) -> ~str {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)\n     }\n \n-    pub fn resolve_type_vars_if_possible(@self, typ: ty::t) -> ty::t {\n+    pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n-    pub fn resolve_type_vars_in_trait_ref_if_possible(@self,\n+    pub fn resolve_type_vars_in_trait_ref_if_possible(&self,\n                                                       trait_ref:\n                                                       &ty::TraitRef)\n                                                       -> ty::TraitRef {\n@@ -728,15 +728,15 @@ impl InferCtxt {\n     // in this case. The typechecker should only ever report type errors involving mismatched\n     // types using one of these four methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str(@self,\n+    pub fn type_error_message_str(&self,\n                                   sp: Span,\n                                   mk_msg: |Option<~str>, ~str| -> ~str,\n                                   actual_ty: ~str,\n                                   err: Option<&ty::type_err>) {\n         self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n     }\n \n-    pub fn type_error_message_str_with_expected(@self,\n+    pub fn type_error_message_str_with_expected(&self,\n                                                 sp: Span,\n                                                 mk_msg: |Option<~str>,\n                                                          ~str|\n@@ -767,7 +767,7 @@ impl InferCtxt {\n         }\n     }\n \n-    pub fn type_error_message(@self,\n+    pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: |~str| -> ~str,\n                               actual_ty: ty::t,\n@@ -782,7 +782,7 @@ impl InferCtxt {\n         self.type_error_message_str(sp, |_e, a| { mk_msg(a) }, self.ty_to_str(actual_ty), err);\n     }\n \n-    pub fn report_mismatched_types(@self,\n+    pub fn report_mismatched_types(&self,\n                                    sp: Span,\n                                    e: ty::t,\n                                    a: ty::t,"}, {"sha": "fec6e357e5ac07dfef3e812fcc61e541b70fa3ee", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -79,15 +79,15 @@ pub static try_resolve_tvar_shallow: uint = 0;\n pub static resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n-pub struct ResolveState {\n-    infcx: @InferCtxt,\n+pub struct ResolveState<'a> {\n+    infcx: &'a InferCtxt,\n     modes: uint,\n     err: Option<fixup_err>,\n     v_seen: ~[TyVid],\n     type_depth: uint\n }\n \n-pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n+pub fn resolver<'a>(infcx: &'a InferCtxt, modes: uint) -> ResolveState<'a> {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n@@ -97,7 +97,7 @@ pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n     }\n }\n \n-impl ty_fold::TypeFolder for ResolveState {\n+impl<'a> ty_fold::TypeFolder for ResolveState<'a> {\n     fn tcx(&self) -> ty::ctxt {\n         self.infcx.tcx\n     }\n@@ -111,7 +111,7 @@ impl ty_fold::TypeFolder for ResolveState {\n     }\n }\n \n-impl ResolveState {\n+impl<'a> ResolveState<'a> {\n     pub fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }"}, {"sha": "57953313324bca9a76da0204f893b3a8192cfbf2", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -27,21 +27,21 @@ use util::ppaux::bound_region_to_str;\n \n use syntax::ast::{Onceness, Purity};\n \n-pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n+pub struct Sub<'f>(CombineFields<'f>);  // \"subtype\", \"subregion\" etc\n \n-impl Sub {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields { let Sub(ref v) = *self; v }\n+impl<'f> Sub<'f> {\n+    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Sub(ref v) = *self; v }\n }\n \n-impl Combine for Sub {\n-    fn infcx(&self) -> @InferCtxt { self.get_ref().infcx }\n+impl<'f> Combine for Sub<'f> {\n+    fn infcx<'a>(&'a self) -> &'a InferCtxt { self.get_ref().infcx }\n     fn tag(&self) -> ~str { ~\"sub\" }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n     fn trace(&self) -> TypeTrace { self.get_ref().trace }\n \n-    fn sub(&self) -> Sub { Sub(*self.get_ref()) }\n-    fn lub(&self) -> Lub { Lub(*self.get_ref()) }\n-    fn glb(&self) -> Glb { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         let opp = CombineFields {"}, {"sha": "6d2e06c34ca8158645b69c40fc6af7aadb8baa86", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -71,7 +71,6 @@ use util::ppaux;\n use std::cell::RefCell;\n use std::hashmap::HashMap;\n use std::rc::Rc;\n-use std::result;\n use extra::list::List;\n use extra::list;\n use syntax::codemap::Span;\n@@ -279,32 +278,29 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n }\n \n pub fn require_same_types(tcx: ty::ctxt,\n-                          maybe_infcx: Option<@infer::InferCtxt>,\n+                          maybe_infcx: Option<&infer::InferCtxt>,\n                           t1_is_expected: bool,\n                           span: Span,\n                           t1: ty::t,\n                           t2: ty::t,\n                           msg: || -> ~str)\n                           -> bool {\n-    let l_tcx;\n-    let l_infcx;\n-    match maybe_infcx {\n-      None => {\n-        l_tcx = tcx;\n-        l_infcx = infer::new_infer_ctxt(tcx);\n-      }\n-      Some(i) => {\n-        l_tcx = i.tcx;\n-        l_infcx = i;\n-      }\n-    }\n+    let result = match maybe_infcx {\n+        None => {\n+            let infcx = infer::new_infer_ctxt(tcx);\n+            infer::mk_eqty(&infcx, t1_is_expected, infer::Misc(span), t1, t2)\n+        }\n+        Some(infcx) => {\n+            infer::mk_eqty(infcx, t1_is_expected, infer::Misc(span), t1, t2)\n+        }\n+    };\n \n-    match infer::mk_eqty(l_infcx, t1_is_expected, infer::Misc(span), t1, t2) {\n-        result::Ok(()) => true,\n-        result::Err(ref terr) => {\n-            l_tcx.sess.span_err(span, msg() + \": \" +\n-                                ty::type_err_to_str(l_tcx, terr));\n-            ty::note_and_explain_type_err(l_tcx, terr);\n+    match result {\n+        Ok(_) => true,\n+        Err(ref terr) => {\n+            tcx.sess.span_err(span, msg() + \": \" +\n+                              ty::type_err_to_str(tcx, terr));\n+            ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n     }"}, {"sha": "5a9c3fd031dc47b7a6591ed42ad4b2d38cc5ee94", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -267,7 +267,6 @@ pub fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n pub fn trait_store_to_str(cx: ctxt, s: ty::TraitStore) -> ~str {\n     match s {\n       ty::UniqTraitStore => ~\"~\",\n-      ty::BoxTraitStore => ~\"@\",\n       ty::RegionTraitStore(r) => region_ptr_to_str(cx, r)\n     }\n }\n@@ -918,7 +917,6 @@ impl Repr for ty::RegionVid {\n impl Repr for ty::TraitStore {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n-            &ty::BoxTraitStore => ~\"@Trait\",\n             &ty::UniqTraitStore => ~\"~Trait\",\n             &ty::RegionTraitStore(r) => format!(\"&{} Trait\", r.repr(tcx))\n         }"}, {"sha": "ca7f502a2e82d95c8f01b00651aceeb064c9c973", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -404,7 +404,6 @@ pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n-    SelfManaged,\n     SelfOwned,\n }\n \n@@ -415,7 +414,6 @@ impl Clean<SelfTy> for ast::ExplicitSelf {\n             ast::SelfValue => SelfValue,\n             ast::SelfUniq => SelfOwned,\n             ast::SelfRegion(lt, mt) => SelfBorrowed(lt.clean(), mt.clean()),\n-            ast::SelfBox => SelfManaged,\n         }\n     }\n }"}, {"sha": "9ac0e1acec53cf652d5fcadfedb9b503097a24e0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -14,7 +14,6 @@ use rustc::metadata::creader::Loader;\n use rustc::middle::privacy;\n \n use syntax::ast;\n-use syntax::diagnostic;\n use syntax::parse::token;\n use syntax::parse;\n use syntax;\n@@ -48,7 +47,7 @@ fn get_ast_and_resolve(cpath: &Path,\n                                 phase_2_configure_and_expand,\n                                 phase_3_run_analysis_passes};\n \n-    let parsesess = parse::new_parse_sess(None);\n+    let parsesess = parse::new_parse_sess();\n     let input = FileInput(cpath.clone());\n \n     let sessopts = @driver::session::Options {\n@@ -60,14 +59,13 @@ fn get_ast_and_resolve(cpath: &Path,\n     };\n \n \n-    let diagnostic_handler = syntax::diagnostic::mk_handler(None);\n+    let diagnostic_handler = syntax::diagnostic::mk_handler();\n     let span_diagnostic_handler =\n         syntax::diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n \n     let sess = driver::driver::build_session_(sessopts,\n                                               Some(cpath.clone()),\n                                               parsesess.cm,\n-                                              @diagnostic::DefaultEmitter,\n                                               span_diagnostic_handler);\n \n     let mut cfg = build_configuration(sess);"}, {"sha": "a1a6a173ede981a81add2faddbbe29dc8caf37f8", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -435,7 +435,6 @@ impl<'a> fmt::Show for Method<'a> {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n             clean::SelfOwned => args.push_str(\"~self\"),\n-            clean::SelfManaged => args.push_str(\"@self\"),\n             clean::SelfBorrowed(Some(ref lt), clean::Immutable) => {\n                 args.push_str(format!(\"&amp;{} self\", *lt));\n             }"}, {"sha": "58c89d6aa4a7c3663531d2107a27e044ef83b96a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -34,7 +34,7 @@ use passes;\n use visit_ast::RustdocVisitor;\n \n pub fn run(input: &str, matches: &getopts::Matches) -> int {\n-    let parsesess = parse::new_parse_sess(None);\n+    let parsesess = parse::new_parse_sess();\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n     let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n@@ -49,14 +49,13 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     };\n \n \n-    let diagnostic_handler = diagnostic::mk_handler(None);\n+    let diagnostic_handler = diagnostic::mk_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n \n     let sess = driver::build_session_(sessopts,\n                                       Some(input_path),\n                                       parsesess.cm,\n-                                      @diagnostic::DefaultEmitter,\n                                       span_diagnostic_handler);\n \n     let cfg = driver::build_configuration(sess);\n@@ -98,7 +97,7 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n \n fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n     let test = maketest(test, cratename);\n-    let parsesess = parse::new_parse_sess(None);\n+    let parsesess = parse::new_parse_sess();\n     let input = driver::StrInput(test);\n \n     let sessopts = @session::Options {\n@@ -111,14 +110,13 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n         .. (*session::basic_options()).clone()\n     };\n \n-    let diagnostic_handler = diagnostic::mk_handler(None);\n+    let diagnostic_handler = diagnostic::mk_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n \n     let sess = driver::build_session_(sessopts,\n                                       None,\n                                       parsesess.cm,\n-                                      @diagnostic::DefaultEmitter,\n                                       span_diagnostic_handler);\n \n     let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");"}, {"sha": "4433bd9096f4bdd33743c7ffec4c1eb0b842b903", "filename": "src/libstd/any.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -177,15 +177,6 @@ mod tests {\n         assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n         assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n \n-        let (a, b, c) = (@5u as @Any, @TEST as @Any, @Test as @Any);\n-        let a_r: &Any = a;\n-        let b_r: &Any = b;\n-        let c_r: &Any = c;\n-\n-        assert_eq!(a.as_void_ptr(), a_r.as_void_ptr());\n-        assert_eq!(b.as_void_ptr(), b_r.as_void_ptr());\n-        assert_eq!(c.as_void_ptr(), c_r.as_void_ptr());\n-\n         let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n         let a_r: &Any = a;\n         let b_r: &Any = b;\n@@ -303,23 +294,6 @@ mod tests {\n         assert!(c.is::<Test>());\n     }\n \n-    #[test]\n-    fn any_managed() {\n-        let (a, b, c) = (@5u as @Any, @TEST as @Any, @Test as @Any);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n     #[test]\n     fn any_as_ref() {\n         let a = &5u as &Any;"}, {"sha": "e441ea6ec74ebbc9b8c6a914aea5c98f5c5e2bb6", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -424,9 +424,9 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n     }\n \n     fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<@TyVisitor>();\n+        self.align_to::<~TyVisitor>();\n         if ! self.inner.visit_trait(name) { return false; }\n-        self.bump_past::<@TyVisitor>();\n+        self.bump_past::<~TyVisitor>();\n         true\n     }\n "}, {"sha": "ca876054fa866f642a27e5e243c3a749d20f5bdb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -964,7 +964,6 @@ pub enum ExplicitSelf_ {\n     SelfStatic,                                // no self\n     SelfValue,                                 // `self`\n     SelfRegion(Option<Lifetime>, Mutability),  // `&'lt self`, `&'lt mut self`\n-    SelfBox,                                   // `@self`\n     SelfUniq                                   // `~self`\n }\n \n@@ -1231,6 +1230,6 @@ mod test {\n             },\n         };\n         // doesn't matter which encoder we use....\n-        let _f = (@e as @serialize::Encodable<extra::json::Encoder>);\n+        let _f = (&e as &serialize::Encodable<extra::json::Encoder>);\n     }\n }"}, {"sha": "3f6540570b0ef7b6f741b2240771c5ee65f3a808", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -24,10 +24,8 @@ static BUG_REPORT_URL: &'static str =\n static MAX_LINES: uint = 6u;\n \n pub trait Emitter {\n-    fn emit(&self,\n-            cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str,\n-            lvl: Level);\n+    fn emit(&self, cmsp: Option<(&codemap::CodeMap, Span)>,\n+            msg: &str, lvl: Level);\n     fn custom_emit(&self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level);\n }\n@@ -46,30 +44,30 @@ pub struct SpanHandler {\n }\n \n impl SpanHandler {\n-    pub fn span_fatal(@self, sp: Span, msg: &str) -> ! {\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Fatal);\n         fail!(FatalError);\n     }\n-    pub fn span_err(@self, sp: Span, msg: &str) {\n+    pub fn span_err(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();\n     }\n-    pub fn span_warn(@self, sp: Span, msg: &str) {\n+    pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Warning);\n     }\n-    pub fn span_note(@self, sp: Span, msg: &str) {\n+    pub fn span_note(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&*self.cm, sp)), msg, Note);\n     }\n-    pub fn span_end_note(@self, sp: Span, msg: &str) {\n+    pub fn span_end_note(&self, sp: Span, msg: &str) {\n         self.handler.custom_emit(&*self.cm, sp, msg, Note);\n     }\n-    pub fn span_bug(@self, sp: Span, msg: &str) -> ! {\n+    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    pub fn span_unimpl(@self, sp: Span, msg: &str) -> ! {\n+    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    pub fn handler(@self) -> @Handler {\n+    pub fn handler(&self) -> @Handler {\n         self.handler\n     }\n }\n@@ -79,28 +77,28 @@ impl SpanHandler {\n // others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<uint>,\n-    emit: @Emitter,\n+    emit: DefaultEmitter,\n }\n \n impl Handler {\n-    pub fn fatal(@self, msg: &str) -> ! {\n+    pub fn fatal(&self, msg: &str) -> ! {\n         self.emit.emit(None, msg, Fatal);\n         fail!(FatalError);\n     }\n-    pub fn err(@self, msg: &str) {\n+    pub fn err(&self, msg: &str) {\n         self.emit.emit(None, msg, Error);\n         self.bump_err_count();\n     }\n-    pub fn bump_err_count(@self) {\n+    pub fn bump_err_count(&self) {\n         self.err_count.set(self.err_count.get() + 1u);\n     }\n-    pub fn err_count(@self) -> uint {\n+    pub fn err_count(&self) -> uint {\n         self.err_count.get()\n     }\n-    pub fn has_errors(@self) -> bool {\n+    pub fn has_errors(&self) -> bool {\n         self.err_count.get()> 0u\n     }\n-    pub fn abort_if_errors(@self) {\n+    pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n           0u => return,\n@@ -112,25 +110,25 @@ impl Handler {\n         }\n         self.fatal(s);\n     }\n-    pub fn warn(@self, msg: &str) {\n+    pub fn warn(&self, msg: &str) {\n         self.emit.emit(None, msg, Warning);\n     }\n-    pub fn note(@self, msg: &str) {\n+    pub fn note(&self, msg: &str) {\n         self.emit.emit(None, msg, Note);\n     }\n-    pub fn bug(@self, msg: &str) -> ! {\n+    pub fn bug(&self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n-    pub fn unimpl(@self, msg: &str) -> ! {\n+    pub fn unimpl(&self, msg: &str) -> ! {\n         self.bug(~\"unimplemented \" + msg);\n     }\n-    pub fn emit(@self,\n-            cmsp: Option<(&codemap::CodeMap, Span)>,\n-            msg: &str,\n-            lvl: Level) {\n+    pub fn emit(&self,\n+                cmsp: Option<(&codemap::CodeMap, Span)>,\n+                msg: &str,\n+                lvl: Level) {\n         self.emit.emit(cmsp, msg, lvl);\n     }\n-    pub fn custom_emit(@self, cm: &codemap::CodeMap,\n+    pub fn custom_emit(&self, cm: &codemap::CodeMap,\n                        sp: Span, msg: &str, lvl: Level) {\n         self.emit.custom_emit(cm, sp, msg, lvl);\n     }\n@@ -149,15 +147,10 @@ pub fn mk_span_handler(handler: @Handler, cm: @codemap::CodeMap)\n     }\n }\n \n-pub fn mk_handler(emitter: Option<@Emitter>) -> @Handler {\n-    let emit: @Emitter = match emitter {\n-        Some(e) => e,\n-        None => @DefaultEmitter as @Emitter\n-    };\n-\n+pub fn mk_handler() -> @Handler {\n     @Handler {\n         err_count: Cell::new(0),\n-        emit: emit,\n+        emit: DefaultEmitter,\n     }\n }\n "}, {"sha": "800eda64d5198d717309d40163ca093a002285e3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -105,7 +105,7 @@ pub trait AnyMacro {\n pub enum MacResult {\n     MRExpr(@ast::Expr),\n     MRItem(@ast::Item),\n-    MRAny(@AnyMacro),\n+    MRAny(~AnyMacro:),\n     MRDef(MacroDef),\n }\n impl MacResult {"}, {"sha": "e41decbd8ef280f1789067c2a5cf70034b8168a3", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -56,7 +56,6 @@ pub trait AstBuilder {\n                lifetime: Option<ast::Lifetime>,\n                mutbl: ast::Mutability) -> P<ast::Ty>;\n     fn ty_uniq(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n-    fn ty_box(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty>;\n \n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty>;\n     fn ty_infer(&self, sp: Span) -> P<ast::Ty>;\n@@ -329,10 +328,6 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.ty(span, ast::TyUniq(ty))\n     }\n \n-    fn ty_box(&self, span: Span, ty: P<ast::Ty>) -> P<ast::Ty> {\n-        self.ty(span, ast::TyBox(ty))\n-    }\n-\n     fn ty_option(&self, ty: P<ast::Ty>) -> P<ast::Ty> {\n         self.ty_path(\n             self.path_all(DUMMY_SP,"}, {"sha": "a44e4af5b6b4fd36333b012c249efcb6aa133eb7", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -75,7 +75,7 @@ would yield functions like:\n     }\n */\n \n-use ast::{MetaItem, Item, Expr, MutImmutable, MutMutable};\n+use ast::{MetaItem, Item, Expr, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -100,7 +100,7 @@ pub fn expand_deriving_encodable(cx: &ExtCtxt,\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds::empty(),\n-                explicit_self: Some(Some(Borrowed(None, MutImmutable))),\n+                explicit_self: borrowed_explicit_self(),\n                 args: ~[Ptr(~Literal(Path::new_local(\"__E\")),\n                             Borrowed(None, MutMutable))],\n                 ret_ty: nil_ty(),"}, {"sha": "f37abbe1ef4192a9a5e434be4f343741b0ed7c2a", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -24,7 +24,6 @@ use opt_vec::OptVec;\n /// The types of pointers\n pub enum PtrTy<'a> {\n     Send, // ~\n-    Managed, // @\n     Borrowed(Option<&'a str>, ast::Mutability), // &['lifetime] [mut]\n }\n \n@@ -138,9 +137,6 @@ impl<'a> Ty<'a> {\n                     Send => {\n                         cx.ty_uniq(span, raw_ty)\n                     }\n-                    Managed => {\n-                        cx.ty_box(span, raw_ty)\n-                    }\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n                         cx.ty_rptr(span, raw_ty, lt, mutbl)\n@@ -251,7 +247,6 @@ pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n                 span,\n                 match *ptr {\n                     Send => ast::SelfUniq,\n-                    Managed => ast::SelfBox,\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s)));\n                         ast::SelfRegion(lt, mutbl)"}, {"sha": "5dc16b9b6b6a1ebbbfe0a8e8b86657bec8ee35fb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 22, "deletions": 118, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{P, Block, Crate, DeclLocal, ExprMac, SyntaxContext};\n+use ast::{P, Block, Crate, DeclLocal, ExprMac};\n use ast::{Local, Ident, MacInvocTT};\n use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n use ast::{TokenTree};\n@@ -134,7 +134,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n \n         // Desugar expr_for_loop\n         // From: `['<ident>:] for <src_pat> in <src_expr> <src_loop_block>`\n-        // FIXME #6993 : change type of opt_ident to Option<Name>\n+        // FIXME #6993: change type of opt_ident to Option<Name>\n         ast::ExprForLoop(src_pat, src_expr, src_loop_block, opt_ident) => {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n@@ -818,67 +818,24 @@ pub fn expand_crate(parse_sess: @parse::ParseSess,\n // element that has one. a CtxtFn is a trait-ified\n // version of a closure in (SyntaxContext -> SyntaxContext).\n // the ones defined here include:\n-// Renamer - add a rename to a context\n-// MultiRenamer - add a set of renames to a context\n // Marker - add a mark to a context\n-// Repainter - replace a context (maybe Replacer would be a better name?)\n \n-// a function in SyntaxContext -> SyntaxContext\n-pub trait CtxtFn{\n-    fn f(&self, ast::SyntaxContext) -> ast::SyntaxContext;\n-}\n-\n-// a renamer adds a rename to the syntax context\n-pub struct Renamer {\n-    from : ast::Ident,\n-    to : ast::Name\n-}\n+// A Marker adds the given mark to the syntax context\n+struct Marker { mark: Mrk }\n \n-impl CtxtFn for Renamer {\n-    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n-        new_rename(self.from,self.to,ctxt)\n-    }\n-}\n-\n-// a marker adds the given mark to the syntax context\n-pub struct Marker { mark : Mrk }\n-\n-impl CtxtFn for Marker {\n-    fn f(&self, ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n-        new_mark(self.mark,ctxt)\n-    }\n-}\n-\n-// a repainter just replaces the given context with the one it's closed over\n-pub struct Repainter { ctxt : SyntaxContext }\n-\n-impl CtxtFn for Repainter {\n-    fn f(&self, _ctxt : ast::SyntaxContext) -> ast::SyntaxContext {\n-        self.ctxt\n-    }\n-}\n-\n-pub struct ContextWrapper {\n-    context_function: @CtxtFn,\n-}\n-\n-impl Folder for ContextWrapper {\n+impl Folder for Marker {\n     fn fold_ident(&mut self, id: ast::Ident) -> ast::Ident {\n-        let ast::Ident {\n-            name,\n-            ctxt\n-        } = id;\n         ast::Ident {\n-            name: name,\n-            ctxt: self.context_function.f(ctxt),\n+            name: id.name,\n+            ctxt: new_mark(self.mark, id.ctxt)\n         }\n     }\n     fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n         let macro = match m.node {\n             MacInvocTT(ref path, ref tts, ctxt) => {\n                 MacInvocTT(self.fold_path(path),\n                            fold_tts(*tts, self),\n-                           self.context_function.f(ctxt))\n+                           new_mark(self.mark, ctxt))\n             }\n         };\n         Spanned {\n@@ -888,50 +845,32 @@ impl Folder for ContextWrapper {\n     }\n }\n \n-// given a function from ctxts to ctxts, produce\n-// a Folder that applies that function to all ctxts:\n-pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> ContextWrapper {\n-    ContextWrapper {\n-        context_function: cf as @CtxtFn,\n-    }\n-}\n-\n // just a convenience:\n-pub fn new_mark_folder(m: Mrk) -> ContextWrapper {\n-    fun_to_ctxt_folder(@Marker{mark:m})\n-}\n-\n-pub fn new_rename_folder(from: ast::Ident, to: ast::Name) -> ContextWrapper {\n-    fun_to_ctxt_folder(@Renamer{from:from,to:to})\n+fn new_mark_folder(m: Mrk) -> Marker {\n+    Marker {mark: m}\n }\n \n // apply a given mark to the given token trees. Used prior to expansion of a macro.\n-fn mark_tts(tts : &[TokenTree], m : Mrk) -> ~[TokenTree] {\n+fn mark_tts(tts: &[TokenTree], m: Mrk) -> ~[TokenTree] {\n     fold_tts(tts, &mut new_mark_folder(m))\n }\n \n // apply a given mark to the given expr. Used following the expansion of a macro.\n-fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n+fn mark_expr(expr: @ast::Expr, m: Mrk) -> @ast::Expr {\n     new_mark_folder(m).fold_expr(expr)\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n+fn mark_stmt(expr: &ast::Stmt, m: Mrk) -> @ast::Stmt {\n     new_mark_folder(m).fold_stmt(expr)\n             .expect_one(\"marking a stmt didn't return a stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro.\n-fn mark_item(expr : @ast::Item, m : Mrk) -> SmallVector<@ast::Item> {\n+fn mark_item(expr: @ast::Item, m: Mrk) -> SmallVector<@ast::Item> {\n     new_mark_folder(m).fold_item(expr)\n }\n \n-// replace all contexts in a given expr with the given mark. Used\n-// for capturing macros\n-pub fn replace_ctxts(expr : @ast::Expr, ctxt : SyntaxContext) -> @ast::Expr {\n-    fun_to_ctxt_folder(@Repainter{ctxt:ctxt}).fold_expr(expr)\n-}\n-\n fn original_span(cx: &ExtCtxt) -> @codemap::ExpnInfo {\n     let mut relevant_info = cx.backtrace();\n     let mut einfo = relevant_info.unwrap();\n@@ -1025,7 +964,7 @@ mod test {\n     #[test] fn macros_cant_escape_fns_test () {\n         let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n-        let sess = parse::new_parse_sess(None);\n+        let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n@@ -1040,7 +979,7 @@ mod test {\n     #[test] fn macros_cant_escape_mods_test () {\n         let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n-        let sess = parse::new_parse_sess(None);\n+        let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n@@ -1054,7 +993,7 @@ mod test {\n     #[test] fn macros_can_escape_flattened_mods_test () {\n         let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n-        let sess = parse::new_parse_sess(None);\n+        let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             ~\"<test>\",\n             src,\n@@ -1089,41 +1028,6 @@ mod test {\n         }\n     }\n \n-    #[test]\n-    fn renaming () {\n-        let item_ast = string_to_crate(~\"fn f() -> int { a }\");\n-        let a_name = intern(\"a\");\n-        let a2_name = gensym(\"a2\");\n-        let mut renamer = new_rename_folder(ast::Ident{name:a_name,ctxt:EMPTY_CTXT},\n-                                        a2_name);\n-        let renamed_ast = renamer.fold_crate(item_ast.clone());\n-        let mut path_finder = new_path_finder(~[]);\n-        visit::walk_crate(&mut path_finder, &renamed_ast, ());\n-\n-        match path_finder.path_accumulator {\n-            [ast::Path{segments:[ref seg],..}] =>\n-                assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n-            _ => assert_eq!(0,1)\n-        }\n-\n-        // try a double-rename, with pending_renames.\n-        let a3_name = gensym(\"a3\");\n-        // a context that renames from (\"a\",empty) to \"a2\" :\n-        let ctxt2 = new_rename(ast::Ident::new(a_name),a2_name,EMPTY_CTXT);\n-        let mut pending_renames = ~[\n-            (ast::Ident::new(a_name),a2_name),\n-            (ast::Ident{name:a_name,ctxt:ctxt2},a3_name)\n-        ];\n-        let double_renamed = renames_to_fold(&mut pending_renames).fold_crate(item_ast);\n-        let mut path_finder = new_path_finder(~[]);\n-        visit::walk_crate(&mut path_finder, &double_renamed, ());\n-        match path_finder.path_accumulator {\n-            [ast::Path{segments:[ref seg],..}] =>\n-                assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n-            _ => assert_eq!(0,1)\n-        }\n-    }\n-\n     //fn fake_print_crate(crate: &ast::Crate) {\n     //    let mut out = ~std::io::stderr() as ~std::io::Writer;\n     //    let mut s = pprust::rust_printer(out, get_ident_interner());\n@@ -1142,7 +1046,7 @@ mod test {\n         // println!(\"expanded: {:?}\\n\",expanded_ast);\n         //mtwt_resolve_crate(expanded_ast)\n     //}\n-    //fn expand_and_resolve_and_pretty_print (crate_str : @str) -> ~str {\n+    //fn expand_and_resolve_and_pretty_print (crate_str: @str) -> ~str {\n         //let resolved_ast = expand_and_resolve(crate_str);\n         //pprust::to_str(&resolved_ast,fake_print_crate,get_ident_interner())\n     //}\n@@ -1175,12 +1079,12 @@ mod test {\n \n     #[test]\n     fn automatic_renaming () {\n-        let tests : ~[RenamingTest] =\n+        let tests: ~[RenamingTest] =\n             ~[// b & c should get new names throughout, in the expr too:\n                 (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n                  ~[~[0,1],~[2]], false),\n                 // both x's should be renamed (how is this causing a bug?)\n-                (\"fn main () {let x : int = 13;x;}\",\n+                (\"fn main () {let x: int = 13;x;}\",\n                  ~[~[0]], false),\n                 // the use of b after the + should be renamed, the other one not:\n                 (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n@@ -1300,7 +1204,7 @@ foo_module!()\n         visit::walk_crate(&mut name_finder, &cr, ());\n         let bindings = name_finder.ident_accumulator;\n \n-        let cxbinds : ~[&ast::Ident] =\n+        let cxbinds: ~[&ast::Ident] =\n             bindings.iter().filter(|b| {\n                 let string = token::get_ident(b.name);\n                 \"xx\" == string.get()\n@@ -1337,7 +1241,7 @@ foo_module!()\n                 {\n                     let table = table.table.borrow();\n                     for (idx,val) in table.get().iter().enumerate() {\n-                        println!(\"{:4u} : {:?}\",idx,val);\n+                        println!(\"{:4u}: {:?}\",idx,val);\n                     }\n                 }\n             }"}, {"sha": "4189ea6a967a82ec1c653b34236499425996cb0e", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -25,8 +25,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n     let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n                                tt.to_owned());\n-    let rdr = tt_rdr as @Reader;\n-    let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n+    let mut rust_parser = Parser(sess, cfg.clone(), tt_rdr.dup());\n \n     if rust_parser.is_keyword(keywords::True) {\n         cx.set_trace_macros(true);\n@@ -39,7 +38,7 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n \n     rust_parser.bump();\n \n-    let mut rust_parser = Parser(sess, cfg, rdr.dup());\n+    let mut rust_parser = Parser(sess, cfg, tt_rdr.dup());\n     let result = rust_parser.parse_expr();\n     base::MRExpr(result)\n }"}, {"sha": "a18f80ad4c9f6d6d53db76c9c4f5751a83d8bfb6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -202,11 +202,11 @@ pub enum ParseResult {\n     Error(codemap::Span, ~str)\n }\n \n-pub fn parse_or_else(sess: @ParseSess,\n-                     cfg: ast::CrateConfig,\n-                     rdr: @Reader,\n-                     ms: ~[Matcher])\n-                     -> HashMap<Ident, @NamedMatch> {\n+pub fn parse_or_else<R: Reader>(sess: @ParseSess,\n+                                cfg: ast::CrateConfig,\n+                                rdr: R,\n+                                ms: ~[Matcher])\n+                                -> HashMap<Ident, @NamedMatch> {\n     match parse(sess, cfg, rdr, ms) {\n         Success(m) => m,\n         Failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),\n@@ -223,11 +223,11 @@ pub fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n     }\n }\n \n-pub fn parse(sess: @ParseSess,\n-             cfg: ast::CrateConfig,\n-             rdr: @Reader,\n-             ms: &[Matcher])\n-             -> ParseResult {\n+pub fn parse<R: Reader>(sess: @ParseSess,\n+                        cfg: ast::CrateConfig,\n+                        rdr: R,\n+                        ms: &[Matcher])\n+                        -> ParseResult {\n     let mut cur_eis = ~[];\n     cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n "}, {"sha": "e196bdccfe34b621af1dc7906aed81ec3a438526", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -18,7 +18,7 @@ use ext::base;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else};\n-use parse::lexer::{new_tt_reader, Reader};\n+use parse::lexer::new_tt_reader;\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n use parse::token::{get_ident_interner, special_idents, gensym_ident};\n@@ -129,8 +129,8 @@ fn generic_extension(cx: &ExtCtxt,\n     for (i, lhs) in lhses.iter().enumerate() { // try each arm's matchers\n         match **lhs {\n           MatchedNonterminal(NtMatchers(ref mtcs)) => {\n-            // `none` is because we're not interpolating\n-            let arg_rdr = new_tt_reader(s_d, None, arg.to_owned()) as @Reader;\n+            // `None` is because we're not interpolating\n+            let arg_rdr = new_tt_reader(s_d, None, arg.to_owned());\n             match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n               Success(named_matches) => {\n                 let rhs = match *rhses[i] {\n@@ -150,12 +150,12 @@ fn generic_extension(cx: &ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(s_d, Some(named_matches),\n                                            rhs);\n-                let p = Parser(cx.parse_sess(), cx.cfg(), trncbr as @Reader);\n+                let p = Parser(cx.parse_sess(), cx.cfg(), ~trncbr);\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n-                return MRAny(@ParserAnyMacro {\n+                return MRAny(~ParserAnyMacro {\n                     parser: RefCell::new(p),\n-                } as @AnyMacro)\n+                })\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n@@ -210,7 +210,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n                                    arg.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n-                                     arg_reader as @Reader,\n+                                     arg_reader,\n                                      argument_gram);\n \n     // Extract the arguments:"}, {"sha": "430bd02119a03b95870f57bf1656f1dd764b6be7", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -49,8 +49,8 @@ pub struct TtReader {\n pub fn new_tt_reader(sp_diag: @SpanHandler,\n                      interp: Option<HashMap<Ident, @NamedMatch>>,\n                      src: ~[ast::TokenTree])\n-                     -> @TtReader {\n-    let r = @TtReader {\n+                     -> TtReader {\n+    let r = TtReader {\n         sp_diag: sp_diag,\n         stack: RefCell::new(@TtFrame {\n             forest: @src,\n@@ -69,7 +69,7 @@ pub fn new_tt_reader(sp_diag: @SpanHandler,\n         cur_tok: RefCell::new(EOF),\n         cur_span: RefCell::new(DUMMY_SP),\n     };\n-    tt_next_token(r); /* get cur_tok and cur_span set up */\n+    tt_next_token(&r); /* get cur_tok and cur_span set up */\n     return r;\n }\n \n@@ -86,8 +86,8 @@ fn dup_tt_frame(f: @TtFrame) -> @TtFrame {\n     }\n }\n \n-pub fn dup_tt_reader(r: @TtReader) -> @TtReader {\n-    @TtReader {\n+pub fn dup_tt_reader(r: &TtReader) -> TtReader {\n+    TtReader {\n         sp_diag: r.sp_diag,\n         stack: RefCell::new(dup_tt_frame(r.stack.get())),\n         repeat_idx: r.repeat_idx.clone(),"}, {"sha": "8fbaea7ac1ee01b086fd44f105c38785951c624a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -306,7 +306,7 @@ pub trait Folder {\n \n     fn fold_explicit_self_(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n         match *es {\n-            SelfStatic | SelfValue | SelfUniq | SelfBox => *es,\n+            SelfStatic | SelfValue | SelfUniq => *es,\n             SelfRegion(ref lifetime, m) => {\n                 SelfRegion(fold_opt_lifetime(lifetime, self), m)\n             }"}, {"sha": "77b047a63c3866946c6a3f968b66264ac0ed2489", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -134,7 +134,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     fail!(\"not a doc-comment: {}\", comment);\n }\n \n-fn read_to_eol(rdr: @StringReader) -> ~str {\n+fn read_to_eol(rdr: &StringReader) -> ~str {\n     let mut val = ~\"\";\n     while rdr.curr.get() != '\\n' && !is_eof(rdr) {\n         val.push_char(rdr.curr.get());\n@@ -144,21 +144,21 @@ fn read_to_eol(rdr: @StringReader) -> ~str {\n     return val;\n }\n \n-fn read_one_line_comment(rdr: @StringReader) -> ~str {\n+fn read_one_line_comment(rdr: &StringReader) -> ~str {\n     let val = read_to_eol(rdr);\n     assert!((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n                  (val[0] == '#' as u8 && val[1] == '!' as u8));\n     return val;\n }\n \n-fn consume_non_eol_whitespace(rdr: @StringReader) {\n+fn consume_non_eol_whitespace(rdr: &StringReader) {\n     while is_whitespace(rdr.curr.get()) && rdr.curr.get() != '\\n' &&\n             !is_eof(rdr) {\n         bump(rdr);\n     }\n }\n \n-fn push_blank_line_comment(rdr: @StringReader, comments: &mut ~[Comment]) {\n+fn push_blank_line_comment(rdr: &StringReader, comments: &mut ~[Comment]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n     comments.push(Comment {\n@@ -168,7 +168,7 @@ fn push_blank_line_comment(rdr: @StringReader, comments: &mut ~[Comment]) {\n     });\n }\n \n-fn consume_whitespace_counting_blank_lines(rdr: @StringReader,\n+fn consume_whitespace_counting_blank_lines(rdr: &StringReader,\n                                            comments: &mut ~[Comment]) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) {\n         if rdr.col.get() == CharPos(0u) && rdr.curr.get() == '\\n' {\n@@ -179,7 +179,7 @@ fn consume_whitespace_counting_blank_lines(rdr: @StringReader,\n }\n \n \n-fn read_shebang_comment(rdr: @StringReader, code_to_the_left: bool,\n+fn read_shebang_comment(rdr: &StringReader, code_to_the_left: bool,\n                                             comments: &mut ~[Comment]) {\n     debug!(\">>> shebang comment\");\n     let p = rdr.last_pos.get();\n@@ -191,7 +191,7 @@ fn read_shebang_comment(rdr: @StringReader, code_to_the_left: bool,\n     });\n }\n \n-fn read_line_comments(rdr: @StringReader, code_to_the_left: bool,\n+fn read_line_comments(rdr: &StringReader, code_to_the_left: bool,\n                                           comments: &mut ~[Comment]) {\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos.get();\n@@ -248,7 +248,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     lines.push(s1);\n }\n \n-fn read_block_comment(rdr: @StringReader,\n+fn read_block_comment(rdr: &StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut ~[Comment]) {\n     debug!(\">>> block comment\");\n@@ -279,7 +279,7 @@ fn read_block_comment(rdr: @StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if is_eof(rdr) {\n-                (rdr as @Reader).fatal(~\"unterminated block comment\");\n+                rdr.fatal(~\"unterminated block comment\");\n             }\n             if rdr.curr.get() == '\\n' {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n@@ -317,13 +317,13 @@ fn read_block_comment(rdr: @StringReader,\n     comments.push(Comment {style: style, lines: lines, pos: p});\n }\n \n-fn peeking_at_comment(rdr: @StringReader) -> bool {\n+fn peeking_at_comment(rdr: &StringReader) -> bool {\n     return ((rdr.curr.get() == '/' && nextch(rdr) == '/') ||\n          (rdr.curr.get() == '/' && nextch(rdr) == '*')) ||\n          (rdr.curr.get() == '#' && nextch(rdr) == '!');\n }\n \n-fn consume_comment(rdr: @StringReader,\n+fn consume_comment(rdr: &StringReader,\n                    code_to_the_left: bool,\n                    comments: &mut ~[Comment]) {\n     debug!(\">>> consume comment\");\n@@ -359,17 +359,17 @@ pub fn gather_comments_and_literals(span_diagnostic:\n     let mut comments: ~[Comment] = ~[];\n     let mut literals: ~[Literal] = ~[];\n     let mut first_read: bool = true;\n-    while !is_eof(rdr) {\n+    while !is_eof(&rdr) {\n         loop {\n             let mut code_to_the_left = !first_read;\n-            consume_non_eol_whitespace(rdr);\n+            consume_non_eol_whitespace(&rdr);\n             if rdr.curr.get() == '\\n' {\n                 code_to_the_left = false;\n-                consume_whitespace_counting_blank_lines(rdr, &mut comments);\n+                consume_whitespace_counting_blank_lines(&rdr, &mut comments);\n             }\n-            while peeking_at_comment(rdr) {\n-                consume_comment(rdr, code_to_the_left, &mut comments);\n-                consume_whitespace_counting_blank_lines(rdr, &mut comments);\n+            while peeking_at_comment(&rdr) {\n+                consume_comment(&rdr, code_to_the_left, &mut comments);\n+                consume_whitespace_counting_blank_lines(&rdr, &mut comments);\n             }\n             break;\n         }\n@@ -380,7 +380,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n         //discard, and look ahead; we're working with internal state\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n         if token::is_lit(&tok) {\n-            with_str_from(rdr, bstart, |s| {\n+            with_str_from(&rdr, bstart, |s| {\n                 debug!(\"tok lit: {}\", s);\n                 literals.push(Literal {lit: s.to_owned(), pos: sp.lo});\n             })"}, {"sha": "1bcff324e082f968f04793f71aed820090f2a9ed", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 49, "deletions": 51, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -12,8 +12,7 @@ use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n use diagnostic::SpanHandler;\n-use ext::tt::transcribe::{tt_next_token};\n-use ext::tt::transcribe::{dup_tt_reader};\n+use ext::tt::transcribe::{dup_tt_reader, tt_next_token};\n use parse::token;\n use parse::token::{str_to_ident};\n \n@@ -26,12 +25,12 @@ use std::util;\n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n pub trait Reader {\n-    fn is_eof(@self) -> bool;\n-    fn next_token(@self) -> TokenAndSpan;\n-    fn fatal(@self, ~str) -> !;\n-    fn span_diag(@self) -> @SpanHandler;\n-    fn peek(@self) -> TokenAndSpan;\n-    fn dup(@self) -> @Reader;\n+    fn is_eof(&self) -> bool;\n+    fn next_token(&self) -> TokenAndSpan;\n+    fn fatal(&self, ~str) -> !;\n+    fn span_diag(&self) -> @SpanHandler;\n+    fn peek(&self) -> TokenAndSpan;\n+    fn dup(&self) -> ~Reader:;\n }\n \n #[deriving(Clone, Eq)]\n@@ -58,19 +57,19 @@ pub struct StringReader {\n \n pub fn new_string_reader(span_diagnostic: @SpanHandler,\n                          filemap: @codemap::FileMap)\n-                      -> @StringReader {\n+                      -> StringReader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap);\n-    string_advance_token(r); /* fill in peek_* */\n-    return r;\n+    string_advance_token(&r); /* fill in peek_* */\n+    r\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n                                    filemap: @codemap::FileMap)\n-                                -> @StringReader {\n+                                -> StringReader {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n-    let r = @StringReader {\n+    let r = StringReader {\n         span_diagnostic: span_diagnostic,\n         pos: Cell::new(filemap.start_pos),\n         last_pos: Cell::new(filemap.start_pos),\n@@ -81,15 +80,15 @@ pub fn new_low_level_string_reader(span_diagnostic: @SpanHandler,\n         peek_tok: RefCell::new(token::EOF),\n         peek_span: RefCell::new(codemap::DUMMY_SP),\n     };\n-    bump(r);\n-    return r;\n+    bump(&r);\n+    r\n }\n \n // duplicating the string reader is probably a bad idea, in\n // that using them will cause interleaved pushes of line\n // offsets to the underlying filemap...\n-fn dup_string_reader(r: @StringReader) -> @StringReader {\n-    @StringReader {\n+fn dup_string_reader(r: &StringReader) -> StringReader {\n+    StringReader {\n         span_diagnostic: r.span_diagnostic,\n         pos: Cell::new(r.pos.get()),\n         last_pos: Cell::new(r.last_pos.get()),\n@@ -102,9 +101,9 @@ fn dup_string_reader(r: @StringReader) -> @StringReader {\n }\n \n impl Reader for StringReader {\n-    fn is_eof(@self) -> bool { is_eof(self) }\n+    fn is_eof(&self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n-    fn next_token(@self) -> TokenAndSpan {\n+    fn next_token(&self) -> TokenAndSpan {\n         let ret_val = {\n             let mut peek_tok = self.peek_tok.borrow_mut();\n             TokenAndSpan {\n@@ -115,45 +114,45 @@ impl Reader for StringReader {\n         string_advance_token(self);\n         ret_val\n     }\n-    fn fatal(@self, m: ~str) -> ! {\n+    fn fatal(&self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(self.peek_span.get(), m)\n     }\n-    fn span_diag(@self) -> @SpanHandler { self.span_diagnostic }\n-    fn peek(@self) -> TokenAndSpan {\n+    fn span_diag(&self) -> @SpanHandler { self.span_diagnostic }\n+    fn peek(&self) -> TokenAndSpan {\n         // FIXME(pcwalton): Bad copy!\n         TokenAndSpan {\n             tok: self.peek_tok.get(),\n             sp: self.peek_span.get(),\n         }\n     }\n-    fn dup(@self) -> @Reader { dup_string_reader(self) as @Reader }\n+    fn dup(&self) -> ~Reader: { ~dup_string_reader(self) as ~Reader: }\n }\n \n impl Reader for TtReader {\n-    fn is_eof(@self) -> bool {\n+    fn is_eof(&self) -> bool {\n         let cur_tok = self.cur_tok.borrow();\n         *cur_tok.get() == token::EOF\n     }\n-    fn next_token(@self) -> TokenAndSpan {\n+    fn next_token(&self) -> TokenAndSpan {\n         let r = tt_next_token(self);\n         debug!(\"TtReader: r={:?}\", r);\n         return r;\n     }\n-    fn fatal(@self, m: ~str) -> ! {\n+    fn fatal(&self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span.get(), m);\n     }\n-    fn span_diag(@self) -> @SpanHandler { self.sp_diag }\n-    fn peek(@self) -> TokenAndSpan {\n+    fn span_diag(&self) -> @SpanHandler { self.sp_diag }\n+    fn peek(&self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: self.cur_tok.get(),\n             sp: self.cur_span.get(),\n         }\n     }\n-    fn dup(@self) -> @Reader { dup_tt_reader(self) as @Reader }\n+    fn dup(&self) -> ~Reader: { ~dup_tt_reader(self) as ~Reader: }\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`)\n-fn fatal_span(rdr: @StringReader,\n+fn fatal_span(rdr: &StringReader,\n               from_pos: BytePos,\n               to_pos: BytePos,\n               m: ~str)\n@@ -164,7 +163,7 @@ fn fatal_span(rdr: @StringReader,\n \n // report a lexical error spanning [`from_pos`, `to_pos`), appending an\n // escaped character to the error message\n-fn fatal_span_char(rdr: @StringReader,\n+fn fatal_span_char(rdr: &StringReader,\n                    from_pos: BytePos,\n                    to_pos: BytePos,\n                    m: ~str,\n@@ -178,7 +177,7 @@ fn fatal_span_char(rdr: @StringReader,\n \n // report a lexical error spanning [`from_pos`, `to_pos`), appending the\n // offending string to the error message\n-fn fatal_span_verbose(rdr: @StringReader,\n+fn fatal_span_verbose(rdr: &StringReader,\n                       from_pos: BytePos,\n                       to_pos: BytePos,\n                       m: ~str)\n@@ -194,7 +193,7 @@ fn fatal_span_verbose(rdr: @StringReader,\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n // EFFECT: update the interner, maybe.\n-fn string_advance_token(r: @StringReader) {\n+fn string_advance_token(r: &StringReader) {\n     match consume_whitespace_and_comments(r) {\n         Some(comment) => {\n             r.peek_span.set(comment.sp);\n@@ -221,7 +220,7 @@ fn byte_offset(rdr: &StringReader, pos: BytePos) -> BytePos {\n /// up to but excluding `rdr.last_pos`, meaning the slice does not include\n /// the character `rdr.curr`.\n pub fn with_str_from<T>(\n-                     rdr: @StringReader,\n+                     rdr: &StringReader,\n                      start: BytePos,\n                      f: |s: &str| -> T)\n                      -> T {\n@@ -231,7 +230,7 @@ pub fn with_str_from<T>(\n /// Calls `f` with astring slice of the source text spanning from `start`\n /// up to but excluding `end`.\n fn with_str_from_to<T>(\n-                    rdr: @StringReader,\n+                    rdr: &StringReader,\n                     start: BytePos,\n                     end: BytePos,\n                     f: |s: &str| -> T)\n@@ -269,10 +268,10 @@ pub fn bump(rdr: &StringReader) {\n         rdr.curr.set(unsafe { transmute(-1u32) }); // FIXME: #8971: unsound\n     }\n }\n-pub fn is_eof(rdr: @StringReader) -> bool {\n+pub fn is_eof(rdr: &StringReader) -> bool {\n     rdr.curr.get() == unsafe { transmute(-1u32) } // FIXME: #8971: unsound\n }\n-pub fn nextch(rdr: @StringReader) -> char {\n+pub fn nextch(rdr: &StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos.get()).to_uint();\n     if offset < (rdr.filemap.src).len() {\n         return rdr.filemap.src.char_at(offset);\n@@ -303,7 +302,7 @@ fn is_hex_digit(c: char) -> bool {\n \n // EFFECT: eats whitespace and comments.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n-fn consume_whitespace_and_comments(rdr: @StringReader)\n+fn consume_whitespace_and_comments(rdr: &StringReader)\n                                 -> Option<TokenAndSpan> {\n     while is_whitespace(rdr.curr.get()) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n@@ -316,7 +315,7 @@ pub fn is_line_non_doc_comment(s: &str) -> bool {\n // PRECONDITION: rdr.curr is not whitespace\n // EFFECT: eats any kind of comment.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n-fn consume_any_line_comment(rdr: @StringReader)\n+fn consume_any_line_comment(rdr: &StringReader)\n                          -> Option<TokenAndSpan> {\n     if rdr.curr.get() == '/' {\n         match nextch(rdr) {\n@@ -377,7 +376,7 @@ pub fn is_block_non_doc_comment(s: &str) -> bool {\n }\n \n // might return a sugared-doc-attr\n-fn consume_block_comment(rdr: @StringReader) -> Option<TokenAndSpan> {\n+fn consume_block_comment(rdr: &StringReader) -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     let is_doc_comment = rdr.curr.get() == '*' || rdr.curr.get() == '!';\n     let start_bpos = rdr.pos.get() - BytePos(if is_doc_comment {3} else {2});\n@@ -424,7 +423,7 @@ fn consume_block_comment(rdr: @StringReader) -> Option<TokenAndSpan> {\n     if res.is_some() { res } else { consume_whitespace_and_comments(rdr) }\n }\n \n-fn scan_exponent(rdr: @StringReader, start_bpos: BytePos) -> Option<~str> {\n+fn scan_exponent(rdr: &StringReader, start_bpos: BytePos) -> Option<~str> {\n     let mut c = rdr.curr.get();\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n@@ -445,7 +444,7 @@ fn scan_exponent(rdr: @StringReader, start_bpos: BytePos) -> Option<~str> {\n     } else { return None::<~str>; }\n }\n \n-fn scan_digits(rdr: @StringReader, radix: uint) -> ~str {\n+fn scan_digits(rdr: &StringReader, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n         let c = rdr.curr.get();\n@@ -460,7 +459,7 @@ fn scan_digits(rdr: @StringReader, radix: uint) -> ~str {\n     };\n }\n \n-fn check_float_base(rdr: @StringReader, start_bpos: BytePos, last_bpos: BytePos,\n+fn check_float_base(rdr: &StringReader, start_bpos: BytePos, last_bpos: BytePos,\n                     base: uint) {\n     match base {\n       16u => fatal_span(rdr, start_bpos, last_bpos,\n@@ -473,7 +472,7 @@ fn check_float_base(rdr: @StringReader, start_bpos: BytePos, last_bpos: BytePos,\n     }\n }\n \n-fn scan_number(c: char, rdr: @StringReader) -> token::Token {\n+fn scan_number(c: char, rdr: &StringReader) -> token::Token {\n     let mut num_str;\n     let mut base = 10u;\n     let mut c = c;\n@@ -599,7 +598,7 @@ fn scan_number(c: char, rdr: @StringReader) -> token::Token {\n     }\n }\n \n-fn scan_numeric_escape(rdr: @StringReader, n_hex_digits: uint) -> char {\n+fn scan_numeric_escape(rdr: &StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n     let start_bpos = rdr.last_pos.get();\n@@ -640,7 +639,7 @@ fn ident_continue(c: char) -> bool {\n // return the next token from the string\n // EFFECT: advances the input past that token\n // EFFECT: updates the interner\n-fn next_token_inner(rdr: @StringReader) -> token::Token {\n+fn next_token_inner(rdr: &StringReader) -> token::Token {\n     let c = rdr.curr.get();\n     if ident_start(c) && nextch(rdr) != '\"' && nextch(rdr) != '#' {\n         // Note: r as in r\" or r#\" is part of a raw string literal,\n@@ -665,7 +664,7 @@ fn next_token_inner(rdr: @StringReader) -> token::Token {\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n     }\n-    fn binop(rdr: @StringReader, op: token::BinOp) -> token::Token {\n+    fn binop(rdr: &StringReader, op: token::BinOp) -> token::Token {\n         bump(rdr);\n         if rdr.curr.get() == '=' {\n             bump(rdr);\n@@ -953,7 +952,7 @@ fn next_token_inner(rdr: @StringReader) -> token::Token {\n     }\n }\n \n-fn consume_whitespace(rdr: @StringReader) {\n+fn consume_whitespace(rdr: &StringReader) {\n     while is_whitespace(rdr.curr.get()) && !is_eof(rdr) { bump(rdr); }\n }\n \n@@ -968,15 +967,14 @@ mod test {\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n-        string_reader: @StringReader\n+        string_reader: StringReader\n     }\n \n     // open a string reader for the given string\n     fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"zebra.rs\", teststr);\n-        let span_handler =\n-            diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n+        let span_handler = diagnostic::mk_span_handler(diagnostic::mk_handler(), @cm);\n         Env {\n             string_reader: new_string_reader(span_handler,fm)\n         }"}, {"sha": "6ddb4bbc11fb767121e9f66fda8e3e5237386289", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -14,7 +14,7 @@\n use ast;\n use codemap::{Span, CodeMap, FileMap};\n use codemap;\n-use diagnostic::{SpanHandler, mk_span_handler, mk_handler, Emitter};\n+use diagnostic::{SpanHandler, mk_span_handler, mk_handler};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n@@ -45,11 +45,11 @@ pub struct ParseSess {\n     included_mod_stack: RefCell<~[Path]>,\n }\n \n-pub fn new_parse_sess(demitter: Option<@Emitter>) -> @ParseSess {\n+pub fn new_parse_sess() -> @ParseSess {\n     let cm = @CodeMap::new();\n     @ParseSess {\n         cm: cm,\n-        span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n+        span_diagnostic: mk_span_handler(mk_handler(), cm),\n         included_mod_stack: RefCell::new(~[]),\n     }\n }\n@@ -261,7 +261,7 @@ pub fn filemap_to_tts(sess: @ParseSess, filemap: @FileMap)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n-    let mut p1 = Parser(sess, cfg, srdr as @lexer::Reader);\n+    let mut p1 = Parser(sess, cfg, ~srdr);\n     p1.parse_all_token_trees()\n }\n \n@@ -270,7 +270,7 @@ pub fn tts_to_parser(sess: @ParseSess,\n                      tts: ~[ast::TokenTree],\n                      cfg: ast::CrateConfig) -> Parser {\n     let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n-    Parser(sess, cfg, trdr as @lexer::Reader)\n+    Parser(sess, cfg, ~trdr)\n }\n \n // abort if necessary"}, {"sha": "e1cbdd12bd320784ae65a8fa0272a1d15c78c4ab", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -48,7 +48,7 @@ use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n-use ast::{SelfBox, SelfRegion, SelfStatic, SelfUniq, SelfValue};\n+use ast::{SelfRegion, SelfStatic, SelfUniq, SelfValue};\n use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyBareFn, TyTypeof};\n@@ -285,7 +285,7 @@ struct ParsedItemsAndViewItems {\n \n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: @Reader)\n+pub fn Parser(sess: @ParseSess, cfg: ast::CrateConfig, rdr: ~Reader:)\n               -> Parser {\n     let tok0 = rdr.next_token();\n     let interner = get_ident_interner();\n@@ -339,7 +339,7 @@ pub struct Parser {\n     tokens_consumed: uint,\n     restriction: restriction,\n     quote_depth: uint, // not (yet) related to the quasiquoter\n-    reader: @Reader,\n+    reader: ~Reader:,\n     interner: @token::IdentInterner,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n     /// extra detail when the same error is seen twice\n@@ -3580,19 +3580,6 @@ impl Parser {\n     // that may have a self type.\n     fn parse_fn_decl_with_self(&mut self, parse_arg_fn: |&mut Parser| -> Arg)\n                                -> (ExplicitSelf, P<FnDecl>) {\n-        fn maybe_parse_explicit_self(explicit_self: ast::ExplicitSelf_,\n-                                     p: &mut Parser)\n-                                     -> ast::ExplicitSelf_ {\n-            // We need to make sure it isn't a type\n-            if p.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n-                p.bump();\n-                p.expect_self_ident();\n-                explicit_self\n-            } else {\n-                SelfStatic\n-            }\n-        }\n-\n         fn maybe_parse_borrowed_explicit_self(this: &mut Parser)\n                                               -> ast::ExplicitSelf_ {\n             // The following things are possible to see here:\n@@ -3650,11 +3637,15 @@ impl Parser {\n             token::BINOP(token::AND) => {\n                 maybe_parse_borrowed_explicit_self(self)\n             }\n-            token::AT => {\n-                maybe_parse_explicit_self(SelfBox, self)\n-            }\n             token::TILDE => {\n-                maybe_parse_explicit_self(SelfUniq, self)\n+                // We need to make sure it isn't a type\n+                if self.look_ahead(1, |t| token::is_keyword(keywords::Self, t)) {\n+                    self.bump();\n+                    self.expect_self_ident();\n+                    SelfUniq\n+                } else {\n+                    SelfStatic\n+                }\n             }\n             token::IDENT(..) if self.is_self_ident() => {\n                 self.bump();"}, {"sha": "7f7f57b13a94a75cdd999880e4118b2683a40b03", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -35,11 +35,11 @@ use std::io;\n use std::io::MemWriter;\n \n // The &mut State is stored here to prevent recursive type.\n-pub enum AnnNode<'a,'b> {\n-    NodeBlock(&'b mut State, &'a ast::Block),\n-    NodeItem(&'b mut State, &'a ast::Item),\n-    NodeExpr(&'b mut State, &'a ast::Expr),\n-    NodePat(&'b mut State, &'a ast::Pat),\n+pub enum AnnNode<'a, 'b> {\n+    NodeBlock(&'a mut State<'a>, &'b ast::Block),\n+    NodeItem(&'a mut State<'a>, &'b ast::Item),\n+    NodeExpr(&'a mut State<'a>, &'b ast::Expr),\n+    NodePat(&'a mut State<'a>, &'b ast::Pat),\n }\n \n pub trait PpAnn {\n@@ -56,15 +56,15 @@ pub struct CurrentCommentAndLiteral {\n     cur_lit: uint,\n }\n \n-pub struct State {\n+pub struct State<'a> {\n     s: pp::Printer,\n     cm: Option<@CodeMap>,\n     intr: @token::IdentInterner,\n     comments: Option<~[comments::Comment]>,\n     literals: Option<~[comments::Literal]>,\n     cur_cmnt_and_lit: CurrentCommentAndLiteral,\n     boxes: RefCell<~[pp::Breaks]>,\n-    ann: @PpAnn\n+    ann: &'a PpAnn\n }\n \n pub fn ibox(s: &mut State, u: uint) -> io::IoResult<()> {\n@@ -83,15 +83,15 @@ pub fn end(s: &mut State) -> io::IoResult<()> {\n     pp::end(&mut s.s)\n }\n \n-pub fn rust_printer(writer: ~io::Writer, intr: @IdentInterner) -> State {\n-    return rust_printer_annotated(writer, intr, @NoAnn as @PpAnn);\n+pub fn rust_printer(writer: ~io::Writer, intr: @IdentInterner) -> State<'static> {\n+    rust_printer_annotated(writer, intr, &NoAnn)\n }\n \n-pub fn rust_printer_annotated(writer: ~io::Writer,\n-                              intr: @IdentInterner,\n-                              ann: @PpAnn)\n-                              -> State {\n-    return State {\n+pub fn rust_printer_annotated<'a>(writer: ~io::Writer,\n+                                  intr: @IdentInterner,\n+                                  ann: &'a PpAnn)\n+                                  -> State<'a> {\n+    State {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None,\n         intr: intr,\n@@ -103,7 +103,7 @@ pub fn rust_printer_annotated(writer: ~io::Writer,\n         },\n         boxes: RefCell::new(~[]),\n         ann: ann\n-    };\n+    }\n }\n \n pub static indent_unit: uint = 4u;\n@@ -120,7 +120,7 @@ pub fn print_crate(cm: @CodeMap,\n                    filename: ~str,\n                    input: &mut io::Reader,\n                    out: ~io::Writer,\n-                   ann: @PpAnn,\n+                   ann: &PpAnn,\n                    is_expanded: bool) -> io::IoResult<()> {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n@@ -1844,9 +1844,6 @@ fn print_explicit_self(s: &mut State,\n             if_ok!(print_mutability(s, m));\n             if_ok!(word(&mut s.s, \"self\"));\n         }\n-        ast::SelfBox => {\n-            if_ok!(word(&mut s.s, \"@self\"));\n-        }\n     }\n     return Ok(true);\n }"}, {"sha": "8c7ad028a8ee06a787015583f1fc7c3760c38590", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -18,7 +18,7 @@ use parse::token;\n // map a string to tts, using a made-up filename: return both the TokenTree's\n // and the ParseSess\n pub fn string_to_tts_and_sess (source_str : ~str) -> (~[ast::TokenTree], @ParseSess) {\n-    let ps = new_parse_sess(None);\n+    let ps = new_parse_sess();\n     (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n }\n \n@@ -29,7 +29,7 @@ pub fn string_to_tts(source_str : ~str) -> ~[ast::TokenTree] {\n }\n \n pub fn string_to_parser_and_sess(source_str: ~str) -> (Parser,@ParseSess) {\n-    let ps = new_parse_sess(None);\n+    let ps = new_parse_sess();\n     (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n }\n "}, {"sha": "0c6ecf73f6a938e268a4794d536d2f570ba9f601", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -186,7 +186,7 @@ fn walk_explicit_self<E: Clone, V: Visitor<E>>(visitor: &mut V,\n                                                explicit_self: &ExplicitSelf,\n                                                env: E) {\n     match explicit_self.node {\n-        SelfStatic | SelfValue | SelfBox | SelfUniq => {}\n+        SelfStatic | SelfValue | SelfUniq => {}\n         SelfRegion(ref lifetime, _) => {\n             visitor.visit_opt_lifetime_ref(explicit_self.span, lifetime, env)\n         }"}, {"sha": "cb0eac704d965bd80ab27f7b8cfc1436ba05f0d4", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n #[crate_id=\"a\"];\n #[crate_type = \"lib\"];\n \n pub trait i<T> { }\n \n-pub fn f<T>() -> @i<T> {\n+pub fn f<T>() -> ~i<T> {\n     impl<T> i<T> for () { }\n \n-    @() as @i<T>\n+    ~() as ~i<T>\n }"}, {"sha": "daeb5b728571663425c87be3ea05bf72756d7864", "filename": "src/test/compile-fail/borrowck-object-lifetime.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait Foo {\n     fn borrowed<'a>(&'a self) -> &'a ();\n }\n@@ -18,14 +16,6 @@ fn borrowed_receiver<'a>(x: &'a Foo) -> &'a () {\n     x.borrowed()\n }\n \n-fn managed_receiver(x: @Foo) -> &() {\n-    x.borrowed() //~ ERROR cannot root managed value long enough\n-}\n-\n-fn managed_receiver_1(x: @Foo) {\n-    *x.borrowed()\n-}\n-\n fn owned_receiver(x: ~Foo) -> &() {\n     x.borrowed() //~ ERROR borrowed value does not live long enough\n }"}, {"sha": "d4203dc9916ab41ea36a2846723160af47e050ea", "filename": "src/test/compile-fail/borrowck-object-mutability.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-mutability.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait Foo {\n     fn borrowed(&self);\n     fn borrowed_mut(&mut self);\n@@ -25,11 +23,6 @@ fn borrowed_mut_receiver(x: &mut Foo) {\n     x.borrowed_mut();\n }\n \n-fn managed_receiver(x: @Foo) {\n-    x.borrowed();\n-    x.borrowed_mut(); //~ ERROR cannot borrow\n-}\n-\n fn owned_receiver(x: ~Foo) {\n     x.borrowed();\n     x.borrowed_mut(); //~ ERROR cannot borrow"}, {"sha": "18f6fc25149bf89da3dadce114ec1b9595d492d5", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait noisy {\n   fn speak(&self);\n }\n@@ -59,6 +57,6 @@ fn cat(in_x : uint, in_y : int, in_name: ~str) -> cat {\n }\n \n fn main() {\n-  let nyan : @noisy  = @cat(0, 2, ~\"nyan\") as @noisy;\n+  let nyan: ~noisy = ~cat(0, 2, ~\"nyan\") as ~noisy;\n   nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n }"}, {"sha": "5228e03b8bd82aee71d0212a902e9077a591fcc2", "filename": "src/test/compile-fail/issue-5153.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-// error-pattern: type `@Foo:'static` does not implement any method in scope named `foo`\n+// error-pattern: type `&Foo<no-bounds>` does not implement any method in scope named `foo`\n \n trait Foo {\n     fn foo(~self);\n@@ -21,5 +19,5 @@ impl Foo for int {\n }\n \n fn main() {\n-    (@5 as @Foo).foo();\n+    (&5 as &Foo).foo();\n }"}, {"sha": "87e9769d97e4bc2d3abe417216c91152845ce254", "filename": "src/test/compile-fail/kindck-owned-trait.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-trait foo { fn foo(&self); }\n-\n-fn to_foo<T:Clone + foo>(t: T) -> @foo {\n-    @t as @foo\n-    //~^ ERROR value may contain references; add `'static` bound\n-    //~^^ ERROR cannot pack type\n-    //~^^^ ERROR value may contain references\n-}\n-\n-fn to_foo2<T:Clone + foo + 'static>(t: T) -> @foo {\n-    @t as @foo\n-}\n-\n-fn main() {}"}, {"sha": "fa359dcd538f7f4c7e7834f8fab11a1d25f3025c", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -23,8 +23,6 @@ fn main() {\n \n     @2; //~ ERROR type uses managed\n \n-    fn f(_: @Clone) {} //~ ERROR type uses managed\n-\n     ~2; //~ ERROR type uses owned\n     ~[1]; //~ ERROR type uses owned\n     //~^ ERROR type uses owned"}, {"sha": "697678e286d82ec2020cefe71d8664f09c7b1288", "filename": "src/test/compile-fail/map-types.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fmap-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmap-types.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n use std::container::Map;\n use std::hashmap::HashMap;\n \n // Test that trait types printed in error msgs include the type arguments.\n \n fn main() {\n-    let x: @HashMap<~str, ~str> = @HashMap::new();\n-    let x: @Map<~str, ~str> = x;\n-    let y: @Map<uint, ~str> = @x;\n-    //~^ ERROR failed to find an implementation of trait std::container::Map<uint,~str> for @std::container::Map<~str,~str>:'static\n+    let x: ~HashMap<~str, ~str> = ~HashMap::new();\n+    let x: ~Map<~str, ~str> = x;\n+    let y: ~Map<uint, ~str> = ~x;\n+    //~^ ERROR failed to find an implementation of trait std::container::Map<uint,~str> for ~std::container::Map<~str,~str>:Send\n }"}, {"sha": "95f92380816657bd029ffdc8e61854fbb5f80ee9", "filename": "src/test/compile-fail/object-does-not-impl-trait.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-does-not-impl-trait.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-// Test that an object type `@Foo` is not considered to implement the\n+// Test that an object type `~Foo` is not considered to implement the\n // trait `Foo`. Issue #5087.\n \n trait Foo {}\n fn take_foo<F:Foo>(f: F) {}\n-fn take_object(f: @Foo) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n+fn take_object(f: ~Foo) { take_foo(f); } //~ ERROR failed to find an implementation of trait\n fn main() {}"}, {"sha": "ab2aa928c263925b01b7c47a3c419e5ce627aef5", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,35 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait Foo {\n     fn borrowed(&self);\n     fn borrowed_mut(&mut self);\n \n-    fn managed(@self);\n-\n     fn owned(~self);\n }\n \n fn borrowed_receiver(x: &Foo) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n-    x.managed(); //~ ERROR does not implement any method\n     x.owned(); //~ ERROR does not implement any method\n }\n \n fn borrowed_mut_receiver(x: &mut Foo) {\n     x.borrowed();\n     x.borrowed_mut();\n-    x.managed(); //~ ERROR does not implement any method\n-    x.owned(); //~ ERROR does not implement any method\n-}\n-\n-fn managed_receiver(x: @Foo) {\n-    x.borrowed();\n-    x.borrowed_mut(); // See [1]\n-    x.managed();\n     x.owned(); //~ ERROR does not implement any method\n }\n "}, {"sha": "7aa545ab1b940378f296d2a824987b2e73241a11", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n struct ctxt { v: uint }\n \n trait get_ctxt {\n@@ -29,12 +27,12 @@ impl<'a> get_ctxt for has_ctxt<'a> {\n \n }\n \n-fn get_v(gc: @get_ctxt) -> uint {\n+fn get_v(gc: ~get_ctxt) -> uint {\n     gc.get_ctxt().v\n }\n \n fn main() {\n     let ctxt = ctxt { v: 22u };\n     let hc = has_ctxt { c: &ctxt };\n-    assert_eq!(get_v(@hc as @get_ctxt), 22u);\n+    assert_eq!(get_v(~hc as ~get_ctxt), 22u);\n }"}, {"sha": "73df5c3967c0918f5dde6208d92151ad36ad2108", "filename": "src/test/compile-fail/selftype-traittype.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fselftype-traittype.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait add {\n     fn plus(&self, x: Self) -> Self;\n }\n \n-fn do_add(x: @add, y: @add) -> @add {\n+fn do_add(x: ~add, y: ~add) -> ~add {\n     x.plus(y) //~ ERROR cannot call a method whose type contains a self-type through an object\n }\n "}, {"sha": "b9fb94e09ed5a37d747124ebc99514d7389dc883", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,32 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // Tests for \"default\" bounds inferred for traits with no bounds list.\n \n-trait Foo {\n-}\n+trait Foo {}\n \n fn a(_x: ~Foo) { // should be same as ~Foo:Send\n }\n \n-fn b(_x: @Foo) { // should be same as ~Foo:'static\n-}\n-\n-fn c(_x: &'static Foo) { // should be same as &'static Foo:'static\n+fn b(_x: &'static Foo) { // should be same as &'static Foo:'static\n }\n \n-fn d(x: ~Foo:Freeze) {\n+fn c(x: ~Foo:Freeze) {\n     a(x); //~ ERROR expected bounds `Send`\n }\n \n-fn e(x: @Foo:Freeze) {\n+fn d(x: &'static Foo:Freeze) {\n     b(x); //~ ERROR expected bounds `'static`\n }\n \n-fn f(x: &'static Foo:Freeze) {\n-    c(x); //~ ERROR expected bounds `'static`\n-}\n-\n-fn main() { }\n+fn main() {}"}, {"sha": "f04770409a2858bd08d9dfe3812ee0369620a91c", "filename": "src/test/compile-fail/trait-coercion-generic-bad.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-bad.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n struct Struct {\n     person: &'static str\n }\n@@ -25,7 +23,7 @@ impl Trait<&'static str> for Struct {\n }\n \n fn main() {\n-    let s: @Trait<int> = @Struct { person: \"Fred\" };    //~ ERROR expected Trait<int>, but found Trait<&'static str>\n+    let s: ~Trait<int> = ~Struct { person: \"Fred\" };    //~ ERROR expected Trait<int>, but found Trait<&'static str>\n     //~^ ERROR expected Trait<int>, but found Trait<&'static str>\n     s.f(1);\n }"}, {"sha": "2aeebc0f1a8dc0badacd0019243137d3733e5631", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n struct Struct {\n     person: &'static str\n }\n@@ -27,6 +25,6 @@ impl Trait<&'static str> for Struct {\n fn main() {\n     let person = ~\"Fred\";\n     let person: &str = person;  //~ ERROR borrowed value does not live long enough\n-    let s: @Trait<&'static str> = @Struct { person: person };\n+    let s: ~Trait<&'static str> = ~Struct { person: person };\n }\n "}, {"sha": "acac7ae9556cd89b84616485f6789ae706713bd8", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait bar { fn dup(&self) -> Self; fn blah<X>(&self); }\n impl bar for int { fn dup(&self) -> int { *self } fn blah<X>(&self) {} }\n impl bar for uint { fn dup(&self) -> uint { *self } fn blah<X>(&self) {} }\n \n fn main() {\n     10i.dup::<int>(); //~ ERROR does not take type parameters\n     10i.blah::<int, int>(); //~ ERROR incorrect number of type parameters\n-    (@10 as @bar).dup(); //~ ERROR contains a self-type\n+    (~10 as ~bar).dup(); //~ ERROR contains a self-type\n }"}, {"sha": "f71106cacb161b2750771b8ee51572e64337ec6f", "filename": "src/test/debug-info/generic-method-on-generic-struct.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10.5\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {x = -1}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12.5\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {x = -1}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print *arg2\n-// check:$21 = {-14, 14}\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {x = -1}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print *arg2\n-// check:$24 = {-16, 16.5}\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct Struct<T> {\n     x: T\n }\n@@ -116,11 +84,6 @@ impl<T1> Struct<T1> {\n         zzz();\n         arg1\n     }\n-\n-    fn self_managed<T2>(@self, arg1: int, arg2: T2) -> int {\n-        zzz();\n-        arg1\n-    }\n }\n \n fn main() {\n@@ -132,11 +95,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6_i32);\n     let _ = owned.self_by_val(-7, -8_i64);\n     let _ = owned.self_owned(-9, -10.5_f32);\n-\n-    let managed = @Struct { x: -1_i16 };\n-    let _ = managed.self_by_ref(-11, -12.5_f64);\n-    let _ = managed.self_by_val(-13, &(-14, 14));\n-    let _ = managed.self_managed(-15, &(-16, 16.5));\n }\n \n fn zzz() {()}"}, {"sha": "79594c5d3895d8d12f441ff84c08e24d9ba39e66", "filename": "src/test/debug-info/method-on-enum.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,37 +64,6 @@\n // check:$15 = -10\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {{Variant2, [...]}, {Variant2, 117901063}}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {{Variant2, [...]}, {Variant2, 117901063}}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print arg2\n-// check:$21 = -14\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {{Variant2, [...]}, {Variant2, 117901063}}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print arg2\n-// check:$24 = -16\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n #[feature(struct_variant)];\n \n enum Enum {\n@@ -118,11 +87,6 @@ impl Enum {\n         zzz();\n         arg1 + arg2\n     }\n-\n-    fn self_managed(@self, arg1: int, arg2: int) -> int {\n-        zzz();\n-        arg1 + arg2\n-    }\n }\n \n fn main() {\n@@ -134,11 +98,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);\n-\n-    let managed = @Variant2(117901063);\n-    let _ = managed.self_by_ref(-11, -12);\n-    let _ = managed.self_by_val(-13, -14);\n-    let _ = managed.self_managed(-15, -16);\n }\n \n fn zzz() {()}"}, {"sha": "fc78aba707fe5eed966ca513a4339de1014f0ed9", "filename": "src/test/debug-info/method-on-generic-struct.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-generic-struct.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {x = -1}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {x = -1}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print arg2\n-// check:$21 = -14\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {x = -1}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print arg2\n-// check:$24 = -16\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct Struct<T> {\n     x: T\n }\n@@ -116,11 +84,6 @@ impl<T> Struct<T> {\n         zzz();\n         arg1 + arg2\n     }\n-\n-    fn self_managed(@self, arg1: int, arg2: int) -> int {\n-        zzz();\n-        arg1 + arg2\n-    }\n }\n \n fn main() {\n@@ -132,11 +95,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);\n-\n-    let managed = @Struct { x: -1_i16 };\n-    let _ = managed.self_by_ref(-11, -12);\n-    let _ = managed.self_by_val(-13, -14);\n-    let _ = managed.self_managed(-15, -16);\n }\n \n fn zzz() {()}"}, {"sha": "035ebf9caebd3fecc5e35acfd477c32b27040325", "filename": "src/test/debug-info/method-on-struct.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-struct.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {x = 300}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {x = 300}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print arg2\n-// check:$21 = -14\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {x = 300}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print arg2\n-// check:$24 = -16\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct Struct {\n     x: int\n }\n@@ -116,11 +84,6 @@ impl Struct {\n         zzz();\n         self.x + arg1 + arg2\n     }\n-\n-    fn self_managed(@self, arg1: int, arg2: int) -> int {\n-        zzz();\n-        self.x + arg1 + arg2\n-    }\n }\n \n fn main() {\n@@ -132,11 +95,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);\n-\n-    let managed = @Struct { x: 300 };\n-    let _ = managed.self_by_ref(-11, -12);\n-    let _ = managed.self_by_val(-13, -14);\n-    let _ = managed.self_managed(-15, -16);\n }\n \n fn zzz() {()}"}, {"sha": "7cd5a845cba149849979a0510589c2a4ec7645b9", "filename": "src/test/debug-info/method-on-trait.rs", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-trait.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {x = 300}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {x = 300}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print arg2\n-// check:$21 = -14\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {x = 300}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print arg2\n-// check:$24 = -16\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct Struct {\n     x: int\n }\n@@ -104,7 +72,6 @@ trait Trait {\n     fn self_by_ref(&self, arg1: int, arg2: int) -> int;\n     fn self_by_val(self, arg1: int, arg2: int) -> int;\n     fn self_owned(~self, arg1: int, arg2: int) -> int;\n-    fn self_managed(@self, arg1: int, arg2: int) -> int;\n }\n \n impl Trait for Struct {\n@@ -123,11 +90,6 @@ impl Trait for Struct {\n         zzz();\n         self.x + arg1 + arg2\n     }\n-\n-    fn self_managed(@self, arg1: int, arg2: int) -> int {\n-        zzz();\n-        self.x + arg1 + arg2\n-    }\n }\n \n fn main() {\n@@ -139,11 +101,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);\n-\n-    let managed = @Struct { x: 300 };\n-    let _ = managed.self_by_ref(-11, -12);\n-    let _ = managed.self_by_val(-13, -14);\n-    let _ = managed.self_managed(-15, -16);\n }\n \n fn zzz() {()}"}, {"sha": "029a5cd4c913a470e0e59c790aedb85056ab6396", "filename": "src/test/debug-info/method-on-tuple-struct.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {300, -300.5}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {300, -300.5}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print arg2\n-// check:$21 = -14\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {300, -300.5}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print arg2\n-// check:$24 = -16\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct TupleStruct(int, f64);\n \n impl TupleStruct {\n@@ -114,11 +82,6 @@ impl TupleStruct {\n         zzz();\n         arg1 + arg2\n     }\n-\n-    fn self_managed(@self, arg1: int, arg2: int) -> int {\n-        zzz();\n-        arg1 + arg2\n-    }\n }\n \n fn main() {\n@@ -130,11 +93,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);\n-\n-    let managed = @TupleStruct(300, -300.5);\n-    let _ = managed.self_by_ref(-11, -12);\n-    let _ = managed.self_by_val(-13, -14);\n-    let _ = managed.self_managed(-15, -16);\n }\n \n fn zzz() {()}"}, {"sha": "9f0b0ea84142d1e8b6244c31f37d7db7d6c974d2", "filename": "src/test/debug-info/self-in-default-method.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {x = 300}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {x = 300}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print arg2\n-// check:$21 = -14\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {x = 300}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print arg2\n-// check:$24 = -16\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct Struct {\n     x: int\n }\n@@ -115,11 +83,6 @@ trait Trait {\n         zzz();\n         arg1 + arg2\n     }\n-\n-    fn self_managed(@self, arg1: int, arg2: int) -> int {\n-        zzz();\n-        arg1 + arg2\n-    }\n }\n \n impl Trait for Struct {}\n@@ -133,11 +96,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6);\n     let _ = owned.self_by_val(-7, -8);\n     let _ = owned.self_owned(-9, -10);\n-\n-    let managed = @Struct { x: 300 };\n-    let _ = managed.self_by_ref(-11, -12);\n-    let _ = managed.self_by_val(-13, -14);\n-    let _ = managed.self_managed(-15, -16);\n }\n \n fn zzz() {()}"}, {"sha": "5ae88b3d0ce385934f4b3245a8c28bbe30439c19", "filename": "src/test/debug-info/self-in-generic-default-method.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fself-in-generic-default-method.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -64,38 +64,6 @@\n // check:$15 = -10.5\n // debugger:continue\n \n-// MANAGED BY REF\n-// debugger:finish\n-// debugger:print *self\n-// check:$16 = {x = 897}\n-// debugger:print arg1\n-// check:$17 = -11\n-// debugger:print arg2\n-// check:$18 = -12.5\n-// debugger:continue\n-\n-// MANAGED BY VAL\n-// debugger:finish\n-// debugger:print self\n-// check:$19 = {x = 897}\n-// debugger:print arg1\n-// check:$20 = -13\n-// debugger:print *arg2\n-// check:$21 = {-14, 14}\n-// debugger:continue\n-\n-// MANAGED SELF\n-// debugger:finish\n-// debugger:print self->val\n-// check:$22 = {x = 897}\n-// debugger:print arg1\n-// check:$23 = -15\n-// debugger:print *arg2\n-// check:$24 = {-16, 16.5}\n-// debugger:continue\n-\n-#[feature(managed_boxes)];\n-\n struct Struct {\n     x: int\n }\n@@ -116,11 +84,6 @@ trait Trait {\n         zzz();\n         arg1\n     }\n-\n-    fn self_managed<T>(@self, arg1: int, arg2: T) -> int {\n-        zzz();\n-        arg1\n-    }\n }\n \n impl Trait for Struct {}\n@@ -134,11 +97,6 @@ fn main() {\n     let _ = owned.self_by_ref(-5, -6_i32);\n     let _ = owned.self_by_val(-7, -8_i64);\n     let _ = owned.self_owned(-9, -10.5_f32);\n-\n-    let managed = @Struct { x: 897 };\n-    let _ = managed.self_by_ref(-11, -12.5_f64);\n-    let _ = managed.self_by_val(-13, &(-14, 14));\n-    let _ = managed.self_managed(-15, &(-16, 16.5));\n }\n \n fn zzz() {()}"}, {"sha": "de46e1aea5822be7219341a63c274ea44084fb17", "filename": "src/test/debug-info/trait-pointers.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-pointers.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // xfail-android: FIXME(#10381)\n \n // compile-flags:-Z extra-debug-info\n@@ -32,6 +30,5 @@ impl Trait for Struct {}\n fn main() {\n     let stack_struct = Struct { a:0, b: 1.0 };\n     let reference: &Trait = &stack_struct as &Trait;\n-    let managed: @Trait = @Struct { a:2, b: 3.0 } as @Trait;\n     let unique: ~Trait = ~Struct { a:2, b: 3.0 } as ~Trait;\n }"}, {"sha": "2139508c9e406f5aeb163d255fdabb468395c0b2", "filename": "src/test/run-fail/unwind-box-trait.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-fail%2Funwind-box-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-fail%2Funwind-box-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-trait.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// error-pattern:fail\n-\n-fn failfn() {\n-    fail!();\n-}\n-\n-trait i {\n-    fn foo(&self);\n-}\n-\n-impl i for ~int {\n-    fn foo(&self) { }\n-}\n-\n-fn main() {\n-    let x = @~0 as @i;\n-    failfn();\n-    error!(\"{:?}\", x);\n-}"}, {"sha": "5683a2b66986118b7613260cd0494559a57bda24", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n struct pair<A,B> {\n     a: A, b: B\n }\n@@ -29,11 +27,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> @Invokable<A> {\n-    @Invoker {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> ~Invokable:<A> {\n+    ~Invoker {\n         a: a,\n         b: b,\n-    } as @Invokable<A>\n+    } as ~Invokable:<A>\n }\n \n pub fn main() {"}, {"sha": "e00f41426438cf43ecd6e322cac76621003d0910", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,70 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-use std::cell::RefCell;\n-\n-struct Pair<A,B> {\n-    a: A, b: B\n-}\n-\n-struct RecEnum<A>(Rec<A>);\n-struct Rec<A> {\n-    val: A,\n-    rec: Option<@RefCell<RecEnum<A>>>\n-}\n-\n-fn make_cycle<A:'static>(a: A) {\n-    let g: @RefCell<RecEnum<A>> = @RefCell::new(RecEnum(Rec {val: a, rec: None}));\n-    {\n-        let mut gb = g.borrow_mut();\n-        let gg = gb.get();\n-        let RecEnum(ref mut gg) = *gg;\n-        gg.rec = Some(g);\n-    }\n-}\n-\n-struct Invoker<A,B> {\n-    a: A,\n-    b: B,\n-}\n-\n-trait Invokable<A,B> {\n-    fn f(&self) -> (A, B);\n-}\n-\n-impl<A:Clone,B:Clone> Invokable<A,B> for Invoker<A,B> {\n-    fn f(&self) -> (A, B) {\n-        (self.a.clone(), self.b.clone())\n-    }\n-}\n-\n-fn f<A:Send + Clone + 'static,\n-     B:Send + Clone + 'static>(\n-     a: A,\n-     b: B)\n-     -> @Invokable<A,B> {\n-    @Invoker {\n-        a: a,\n-        b: b,\n-    } as @Invokable<A,B>\n-}\n-\n-pub fn main() {\n-    let x = 22_u8;\n-    let y = 44_u64;\n-    let z = f(~x, y);\n-    make_cycle(z);\n-    let (a, b) = z.f();\n-    info!(\"a={} b={}\", *a as uint, b as uint);\n-    assert_eq!(*a, x);\n-    assert_eq!(b, y);\n-}"}, {"sha": "6f0bba72025f481f6563dd9ac7f7f088c293fa3e", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait double {\n-    fn double(@self) -> uint;\n+    fn double(~self) -> uint;\n }\n \n impl double for uint {\n-    fn double(@self) -> uint { *self * 2u }\n+    fn double(~self) -> uint { *self * 2u }\n }\n \n pub fn main() {\n-    let x = @(@3u as @double);\n+    let x = ~(~3u as ~double);\n     assert_eq!(x.double(), 6u);\n }"}, {"sha": "a03ac80a3f16b111499316bc304f8576f3e9411b", "filename": "src/test/run-pass/autoderef-method-twice-but-not-thrice.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice-but-not-thrice.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait double {\n-    fn double(@self) -> uint;\n+    fn double(~self) -> uint;\n }\n \n-impl double for @uint {\n-    fn double(@self) -> uint { **self * 2u }\n+impl double for ~uint {\n+    fn double(~self) -> uint { **self * 2u }\n }\n \n pub fn main() {\n-    let x = @@@@@3u;\n+    let x = ~~~~~3u;\n     assert_eq!(x.double(), 6u);\n }"}, {"sha": "7835eaae510d36a9127818d12be7cd3f5594c3f1", "filename": "src/test/run-pass/autoderef-method-twice.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-twice.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait double {\n-    fn double(@self) -> uint;\n+    fn double(~self) -> uint;\n }\n \n impl double for uint {\n-    fn double(@self) -> uint { *self * 2u }\n+    fn double(~self) -> uint { *self * 2u }\n }\n \n pub fn main() {\n-    let x = @@3u;\n+    let x = ~~3u;\n     assert_eq!(x.double(), 6u);\n }"}, {"sha": "81469e5454a880c7490f1f8b4db78863e7b0330c", "filename": "src/test/run-pass/autoderef-method.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait double {\n-    fn double(@self) -> uint;\n+    fn double(~self) -> uint;\n }\n \n impl double for uint {\n-    fn double(@self) -> uint { *self * 2u }\n+    fn double(~self) -> uint { *self * 2u }\n }\n \n pub fn main() {\n-    let x = @3u;\n+    let x = ~3u;\n     assert_eq!(x.double(), 6u);\n }"}, {"sha": "aab5053693c96650359bfa9143ae5c428f170187", "filename": "src/test/run-pass/boxed-trait-with-vstore.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fboxed-trait-with-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fboxed-trait-with-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fboxed-trait-with-vstore.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-trait Foo {\n-    fn foo(@self);\n-}\n-\n-impl Foo for int {\n-    fn foo(@self) {\n-        println!(\"Hello world!\");\n-    }\n-}\n-\n-pub fn main() {\n-    let x = @3 as @Foo;\n-    x.foo();\n-}"}, {"sha": "bfc6550523b1b9ac160d840ae5c977aa4c6e591c", "filename": "src/test/run-pass/class-cast-to-trait-cross-crate-2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-cross-crate-2.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,21 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // xfail-fast\n // aux-build:cci_class_cast.rs\n extern mod cci_class_cast;\n use std::to_str::ToStr;\n use cci_class_cast::kitty::cat;\n \n-fn print_out(thing: @ToStr, expected: ~str) {\n+fn print_out(thing: ~ToStr, expected: ~str) {\n   let actual = thing.to_str();\n   info!(\"{}\", actual);\n   assert_eq!(actual, expected);\n }\n \n pub fn main() {\n-  let nyan : @ToStr = @cat(0u, 2, ~\"nyan\") as @ToStr;\n+  let nyan: ~ToStr = ~cat(0u, 2, ~\"nyan\") as ~ToStr;\n   print_out(nyan, ~\"nyan\");\n }"}, {"sha": "e93b3266b254ee04be8d1cd0a53b69b17939399d", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // xfail-fast\n struct cat {\n     meows : uint,\n@@ -58,13 +56,13 @@ impl ToStr for cat {\n     }\n }\n \n-fn print_out(thing: @ToStr, expected: ~str) {\n+fn print_out(thing: ~ToStr, expected: ~str) {\n   let actual = thing.to_str();\n   info!(\"{}\", actual);\n   assert_eq!(actual, expected);\n }\n \n pub fn main() {\n-  let nyan : @ToStr = @cat(0u, 2, ~\"nyan\") as @ToStr;\n+  let nyan: ~ToStr = ~cat(0u, 2, ~\"nyan\") as ~ToStr;\n   print_out(nyan, ~\"nyan\");\n }"}, {"sha": "6ba665e4005f556aae1a5003e0e4af085b6f09fb", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // If we use GEPi rathern than GEP_tup_like when\n // storing closure data (as we used to do), the u64 would\n // overwrite the u16.\n@@ -33,11 +31,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> @Invokable<A> {\n-    @Invoker {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> ~Invokable:<A> {\n+    ~Invoker {\n         a: a,\n         b: b,\n-    } as @Invokable<A>\n+    } as ~Invokable:<A>\n }\n \n pub fn main() {"}, {"sha": "faf2a61ca788e816f7b8e869e624c86450df8b2f", "filename": "src/test/run-pass/explicit-self-objects-box.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-box.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-trait Foo {\n-    fn f(@self);\n-}\n-\n-struct S {\n-    x: int\n-}\n-\n-impl Foo for S {\n-    fn f(@self) {\n-        assert_eq!(self.x, 3);\n-    }\n-}\n-\n-pub fn main() {\n-    let x = @S { x: 3 };\n-    let y = x as @Foo;\n-    y.f();\n-    y.f();\n-    y.f();\n-    y.f();\n-}"}, {"sha": "ca64516a7efe73a8c2eb1cc20042702c7cc92a4f", "filename": "src/test/run-pass/explicit-self-objects-simple.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-simple.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-trait Foo {\n-    fn f(&self);\n-}\n-\n-struct S {\n-    x: int\n-}\n-\n-impl Foo for S {\n-    fn f(&self) {\n-        assert_eq!(self.x, 3);\n-    }\n-}\n-\n-pub fn main() {\n-    let x = @S { x: 3 };\n-    let y = x as @Foo;\n-    y.f();\n-}"}, {"sha": "1076fc1662fa2e71c888d42c3c6d42c0799ee4bd", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n static tau: f64 = 2.0*3.14159265358979323;\n \n struct Point {x: f64, y: f64}\n@@ -49,7 +47,7 @@ struct thing {\n \n #[deriving(Clone)]\n struct A {\n-    a: @int\n+    a: int\n }\n \n fn thing(x: A) -> thing {\n@@ -59,26 +57,20 @@ fn thing(x: A) -> thing {\n }\n \n impl thing {\n-    pub fn foo(@self) -> int { *self.x.a }\n-    pub fn bar(~self) -> int { *self.x.a }\n-    pub fn quux(&self) -> int { *self.x.a }\n+    pub fn bar(~self) -> int { self.x.a }\n+    pub fn quux(&self) -> int { self.x.a }\n     pub fn baz<'a>(&'a self) -> &'a A { &self.x }\n-    pub fn spam(self) -> int { *self.x.a }\n+    pub fn spam(self) -> int { self.x.a }\n }\n \n trait Nus { fn f(&self); }\n impl Nus for thing { fn f(&self) {} }\n \n pub fn main() {\n-\n-    let x = @thing(A {a: @10});\n-    assert_eq!(x.foo(), 10);\n-    assert_eq!(x.quux(), 10);\n-\n-    let y = ~thing(A {a: @10});\n+    let y = ~thing(A {a: 10});\n     assert_eq!(y.clone().bar(), 10);\n     assert_eq!(y.quux(), 10);\n \n-    let z = thing(A {a: @11});\n+    let z = thing(A {a: 11});\n     assert_eq!(z.spam(), 11);\n }"}, {"sha": "76db4a01829abe006a1eb5084593fa166d340e95", "filename": "src/test/run-pass/generic-object.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fgeneric-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fgeneric-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-object.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait Foo<T> {\n     fn get(&self) -> T;\n }\n@@ -25,7 +23,7 @@ impl Foo<int> for S {\n }\n \n pub fn main() {\n-    let x = @S { x: 1 };\n-    let y = x as @Foo<int>;\n+    let x = ~S { x: 1 };\n+    let y = x as ~Foo<int>;\n     assert_eq!(y.get(), 1);\n }"}, {"sha": "9e03023a9e9bac9c6392762f3d6034dc180849bb", "filename": "src/test/run-pass/issue-2288.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2288.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2288.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait clam<A> {\n   fn chowder(&self, y: A);\n }\n@@ -28,13 +26,13 @@ fn foo<A>(b: A) -> foo<A> {\n     }\n }\n \n-fn f<A>(x: @clam<A>, a: A) {\n+fn f<A>(x: ~clam<A>, a: A) {\n   x.chowder(a);\n }\n \n pub fn main() {\n \n   let c = foo(42);\n-  let d: @clam<int> = @c as @clam<int>;\n+  let d: ~clam<int> = ~c as ~clam<int>;\n   f(d, c.x);\n }"}, {"sha": "d61622e6b0fca99d0fb2d54d7e516eefca72899f", "filename": "src/test/run-pass/issue-2380-b.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2380-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2380-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2380-b.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // xfail-fast\n // aux-build:issue-2380.rs\n "}, {"sha": "a2a9228091e93de5b01a6ebe2fbd8bf5f7d57b0e", "filename": "src/test/run-pass/issue-2734.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2734.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,19 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait hax { }\n impl<A> hax for A { }\n \n-fn perform_hax<T:'static>(x: @T) -> @hax {\n-    @x as @hax\n+fn perform_hax<T: 'static>(x: ~T) -> ~hax: {\n+    ~x as ~hax:\n }\n \n fn deadcode() {\n-    perform_hax(@~\"deadcode\");\n+    perform_hax(~~\"deadcode\");\n }\n \n pub fn main() {\n-    let _ = perform_hax(@42);\n+    let _ = perform_hax(~42);\n }"}, {"sha": "327f2cb897fd026bc5bcb0e077bd40e2f271a056", "filename": "src/test/run-pass/issue-2735.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2735.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2735.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,19 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait hax { }\n impl<A> hax for A { }\n \n-fn perform_hax<T:'static>(x: @T) -> @hax {\n-    @x as @hax\n+fn perform_hax<T: 'static>(x: ~T) -> ~hax: {\n+    ~x as ~hax:\n }\n \n fn deadcode() {\n-    perform_hax(@~\"deadcode\");\n+    perform_hax(~~\"deadcode\");\n }\n \n pub fn main() {\n-    perform_hax(@42);\n+    perform_hax(~42);\n }"}, {"sha": "8cf9436ef5134ec4c406de8d2be7a0ca8c0cd1ad", "filename": "src/test/run-pass/issue-2935.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-2935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2935.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n //type t = { a: int };\n // type t = { a: bool };\n type t = bool;\n@@ -24,10 +22,10 @@ impl it for t {\n \n pub fn main() {\n   //    let x = ({a: 4i} as it);\n-  //   let y = @({a: 4i});\n-  //    let z = @({a: 4i} as it);\n-  //    let z = @({a: true} as it);\n-    let z = @(@true as @it);\n+  //   let y = ~({a: 4i});\n+  //    let z = ~({a: 4i} as it);\n+  //    let z = ~({a: true} as it);\n+    let z = ~(~true as ~it);\n     //  x.f();\n     // y.f();\n     // (*z).f();"}, {"sha": "43f2e764e69027de8fc1d4b6997acf629a499d95", "filename": "src/test/run-pass/issue-3702.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-3702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3702.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n pub fn main() {\n   trait Text {\n     fn to_str(&self) -> ~str;\n   }\n \n-  fn to_string(t: @Text) {\n+  fn to_string(t: ~Text) {\n     println!(\"{}\", t.to_str());\n   }\n "}, {"sha": "8cc7d275789e979e959d9df9bfae9147debaa5c5", "filename": "src/test/run-pass/issue-3794.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-3794.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-3794.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3794.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait T {\n     fn print(&self);\n }\n@@ -33,9 +31,9 @@ fn print_s(s: &S) {\n }\n \n pub fn main() {\n-    let s: @S = @S { s: 5 };\n+    let s: ~S = ~S { s: 5 };\n     print_s(s);\n-    let t: @T = s as @T;\n+    let t: ~T = s as ~T;\n     print_t(t);\n \n }"}, {"sha": "cf1f979acb4b01f9e3bcc5d31d5a5f105f4f378d", "filename": "src/test/run-pass/issue-7673-cast-generically-implemented-trait.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-7673-cast-generically-implemented-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-7673-cast-generically-implemented-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7673-cast-generically-implemented-trait.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n /*\n \n #7673 Polymorphically creating traits barely works\n@@ -24,7 +22,3 @@ impl<T: 'static> A for T {}\n fn owned1<T: 'static>(a: T) { ~a as ~A:; } /* note `:` */\n fn owned2<T: 'static>(a: ~T) { a as ~A:; }\n fn owned3<T: 'static>(a: ~T) { ~a as ~A:; }\n-\n-fn managed1<T: 'static>(a: T) { @a as @A; }\n-fn managed2<T: 'static>(a: @T) { a as @A; }\n-fn managed3<T: 'static>(a: @T) { @a as @A; }"}, {"sha": "3cb6f525cbcc02d7f5969e0f8d32cbc6a316af9b", "filename": "src/test/run-pass/issue-9129.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9129.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -10,11 +10,11 @@\n \n // xfail-pretty\n \n-#[feature(managed_boxes, macro_rules)];\n+#[feature(macro_rules)];\n \n-pub trait bomb { fn boom(@self, Ident); }\n+pub trait bomb { fn boom(&self, Ident); }\n pub struct S;\n-impl bomb for S { fn boom(@self, _: Ident) { } }\n+impl bomb for S { fn boom(&self, _: Ident) { } }\n \n pub struct Ident { name: uint }\n \n@@ -26,7 +26,7 @@ fn Ident_new() -> Ident {\n     Ident {name: 0x6789ABCD }\n }\n \n-pub fn light_fuse(fld: @bomb) {\n+pub fn light_fuse(fld: ~bomb) {\n     int3!();\n     let f = || {\n         int3!();\n@@ -36,6 +36,6 @@ pub fn light_fuse(fld: @bomb) {\n }\n \n pub fn main() {\n-    let b = @S as @bomb;\n+    let b = ~S as ~bomb;\n     light_fuse(b);\n }"}, {"sha": "0a7e164ca5b985ad46ba04907a8dbb11a09be163", "filename": "src/test/run-pass/kindck-owned-trait-contains-1.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-owned-trait-contains-1.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,23 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n trait repeat<A> { fn get(&self) -> A; }\n \n-impl<A:Clone + 'static> repeat<A> for @A {\n+impl<A:Clone + 'static> repeat<A> for ~A {\n     fn get(&self) -> A {\n         (**self).clone()\n     }\n }\n \n-fn repeater<A:Clone + 'static>(v: @A) -> @repeat:<A> {\n+fn repeater<A:Clone + 'static>(v: ~A) -> ~repeat:<A> {\n     // Note: owned kind is not necessary as A appears in the trait type\n-    @v as @repeat:<A> // No\n+    ~v as ~repeat:<A> // No\n }\n \n pub fn main() {\n     let x = 3;\n-    let y = repeater(@x);\n+    let y = repeater(~x);\n     assert_eq!(x, y.get());\n }"}, {"sha": "52792c8c4279391ee7ac64e658dde4e7a4ca3139", "filename": "src/test/run-pass/objects-coerce-from-managed-to-borrowed.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fobjects-coerce-from-managed-to-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c13a929d58c3f866687ccf12cc33b2b59a2e10b8/src%2Ftest%2Frun-pass%2Fobjects-coerce-from-managed-to-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-coerce-from-managed-to-borrowed.rs?ref=c13a929d58c3f866687ccf12cc33b2b59a2e10b8", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[feature(managed_boxes)];\n-\n-// Test that we can coerce an `@Object` to an `&Object`\n-\n-trait Foo {\n-    fn foo(&self) -> uint;\n-}\n-\n-impl Foo for uint {\n-    fn foo(&self) -> uint {\n-        *self\n-    }\n-}\n-\n-fn do_it_imm(obj: &Foo, v: uint) {\n-    let y = obj.foo();\n-    assert_eq!(v, y);\n-}\n-\n-pub fn main() {\n-    let x = @22u as @Foo;\n-    do_it_imm(x, 22u);\n-}"}, {"sha": "fbd58de1a7eb3d1f3f6d72d2828a26ecc0875f7d", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -408,9 +408,9 @@ impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n     }\n \n     fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<@TyVisitor>();\n+        self.align_to::<~TyVisitor>();\n         if ! self.inner().visit_trait(name) { return false; }\n-        self.bump_past::<@TyVisitor>();\n+        self.bump_past::<~TyVisitor>();\n         true\n     }\n "}, {"sha": "2d8a42005df4dda4a3dd2e704a8aebe67b4a9c74", "filename": "src/test/run-pass/trait-coercion-generic.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion-generic.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n-use std::io::println;\n-\n trait Trait<T> {\n     fn f(&self, x: T);\n }\n@@ -27,18 +23,11 @@ impl Trait<&'static str> for Struct {\n     }\n }\n \n-fn f(x: @Trait<&'static str>) {\n-    x.f(\"Sue\");\n-}\n-\n pub fn main() {\n     let a = Struct { x: 1, y: 2 };\n-    let b: @Trait<&'static str> = @a;\n-    b.f(\"Fred\");\n-    let c: ~Trait<&'static str> = ~a;\n-    c.f(\"Mary\");\n-    let d: &Trait<&'static str> = &a;\n-    d.f(\"Joe\");\n-    f(@a);\n+    let b: ~Trait<&'static str> = ~a;\n+    b.f(\"Mary\");\n+    let c: &Trait<&'static str> = &a;\n+    c.f(\"Joe\");\n }\n "}, {"sha": "ea6d59a906809af9febd3b050a50e809c4077301", "filename": "src/test/run-pass/trait-coercion.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n use std::io;\n \n trait Trait {\n@@ -27,23 +25,16 @@ impl Trait for Struct {\n     }\n }\n \n-fn f(x: @Trait) {\n-    x.f();\n-}\n-\n fn foo(mut a: ~Writer) {\n     a.write(bytes!(\"Hello\\n\"));\n }\n \n pub fn main() {\n     let a = Struct { x: 1, y: 2 };\n-    let b: @Trait = @a;\n+    let b: ~Trait = ~a;\n     b.f();\n-    let c: ~Trait = ~a;\n+    let c: &Trait = &a;\n     c.f();\n-    let d: &Trait = &a;\n-    d.f();\n-    f(@a);\n \n     let out = io::stdout();\n     foo(~out);"}, {"sha": "e8387458ab60fea1b0ddc2e00256222855cfff48", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -1,5 +1,3 @@\n-#[feature(managed_boxes)];\n-\n // xfail-fast\n // aux-build:trait_default_method_xc_aux.rs\n \n@@ -66,7 +64,7 @@ pub fn main () {\n     assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n     assert_eq!(g(false, 3.14, 1), (3.14, 1));\n \n-    let obj = @0i as @A;\n+    let obj = ~0i as ~A;\n     assert_eq!(obj.h(), 11);\n \n "}, {"sha": "ebde7e787e41e4928b2f1fd5d8a7a97453c0ace6", "filename": "src/test/run-pass/trait-object-generics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-object-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d30b72bfaa1f36808151e5825073cdff2e7ea7/src%2Ftest%2Frun-pass%2Ftrait-object-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-object-generics.rs?ref=b2d30b72bfaa1f36808151e5825073cdff2e7ea7", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[feature(managed_boxes)];\n-\n // test for #8664\n \n pub trait Trait2<A> {\n@@ -42,7 +40,7 @@ impl<V> Trait<u8,V> for () {\n     fn method(&self, _x: Type<(u8,V)>) -> int { 0 }\n }\n \n-pub fn main () {\n-    let a = @() as @Trait<u8, u8>;\n+pub fn main() {\n+    let a = ~() as ~Trait<u8, u8>;\n     assert_eq!(a.method(Constant), 0);\n }"}]}