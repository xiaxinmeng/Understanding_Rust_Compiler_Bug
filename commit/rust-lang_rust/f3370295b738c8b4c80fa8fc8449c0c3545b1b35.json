{"sha": "f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzMzcwMjk1YjczOGM4YjRjODBmYThmYzg0NDljMGMzNTQ1YjFiMzU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-29T03:32:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-29T03:44:02Z"}, "message": "Implement a Once primitive for initialization\n\nOf the 8 static mutexes that are currently in-use by the compiler and its\nlibraries, 4 of them are currently used for one-time initialization. The\nunforunate side effect of using a static mutex is that the mutex is leaked.\n\nThis primitive should provide the basis for efficiently keeping track of\none-time initialization as well as ensuring that it does not leak the internal\nmutex that is used.\n\nI have chosen to put this in libstd because libstd is currently making use of a\nstatic initialization mutex (rt::local_ptr), but I can also see a more refined\nversion of this type being suitable to initialize FFI bindings (such as\ninitializing LLVM and initializing winsock networking on windows). I also intend\non adding \"helper threads\" to libnative, and those will greatly benefit from a\nsimple \"once\" primitive rather than always reinventing the wheel by using\nmutexes and bools.\n\nI would much rather see this primitive built on a mutex that blocks green\nthreads appropriately, but that does not exist at this time, so it does not\nbelong outside of `std::unstable`.", "tree": {"sha": "af7e479999400cf75e414583e9b5edd4fa553f34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af7e479999400cf75e414583e9b5edd4fa553f34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "html_url": "https://github.com/rust-lang/rust/commit/f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3370295b738c8b4c80fa8fc8449c0c3545b1b35/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0d4abf8c5d368fb6861fb015c82811e94b7566b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d4abf8c5d368fb6861fb015c82811e94b7566b", "html_url": "https://github.com/rust-lang/rust/commit/c0d4abf8c5d368fb6861fb015c82811e94b7566b"}], "stats": {"total": 146, "additions": 145, "deletions": 1}, "files": [{"sha": "0361296ff38cf2b638363c6d47ffc1c8a3483628", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 145, "deletions": 1, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f3370295b738c8b4c80fa8fc8449c0c3545b1b35/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3370295b738c8b4c80fa8fc8449c0c3545b1b35/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=f3370295b738c8b4c80fa8fc8449c0c3545b1b35", "patch": "@@ -315,10 +315,154 @@ mod imp {\n     }\n }\n \n+/// A type which can be used to run a one-time global initialization. This type\n+/// is *unsafe* to use because it is built on top of the `Mutex` in this module.\n+/// It does not know whether the currently running task is in a green or native\n+/// context, and a blocking mutex should *not* be used under normal\n+/// circumstances on a green task.\n+///\n+/// Despite its unsafety, it is often useful to have a one-time initialization\n+/// routine run for FFI bindings or related external functionality. This type\n+/// can only be statically constructed with the `ONCE_INIT` value.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::unstable::mutex::{Once, ONCE_INIT};\n+///\n+/// static mut START: Once = ONCE_INIT;\n+/// unsafe {\n+///     START.doit(|| {\n+///         // run initialization here\n+///     });\n+/// }\n+/// ```\n+pub struct Once {\n+    priv mutex: Mutex,\n+    priv cnt: AtomicInt,\n+    priv lock_cnt: AtomicInt,\n+}\n+\n+/// Initialization value for static `Once` values.\n+pub static ONCE_INIT: Once = Once {\n+    mutex: MUTEX_INIT,\n+    cnt: INIT_ATOMIC_INT,\n+    lock_cnt: INIT_ATOMIC_INT,\n+};\n+\n+impl Once {\n+    /// Perform an initialization routine once and only once. The given closure\n+    /// will be executed if this is the first time `doit` has been called, and\n+    /// otherwise the routine will *not* be invoked.\n+    ///\n+    /// This method will block the calling *os thread* if another initialization\n+    /// routine is currently running.\n+    ///\n+    /// When this function returns, it is guaranteed that some initialization\n+    /// has run and completed (it may not be the closure specified).\n+    pub fn doit(&mut self, f: ||) {\n+        // Implementation-wise, this would seem like a fairly trivial primitive.\n+        // The stickler part is where our mutexes currently require an\n+        // allocation, and usage of a `Once` should't leak this allocation.\n+        //\n+        // This means that there must be a deterministic destroyer of the mutex\n+        // contained within (because it's not needed after the initialization\n+        // has run).\n+        //\n+        // The general scheme here is to gate all future threads once\n+        // initialization has completed with a \"very negative\" count, and to\n+        // allow through threads to lock the mutex if they see a non negative\n+        // count. For all threads grabbing the mutex, exactly one of them should\n+        // be responsible for unlocking the mutex, and this should only be done\n+        // once everyone else is done with the mutex.\n+        //\n+        // This atomicity is achieved by swapping a very negative value into the\n+        // shared count when the initialization routine has completed. This will\n+        // read the number of threads which will at some point attempt to\n+        // acquire the mutex. This count is then squirreled away in a separate\n+        // variable, and the last person on the way out of the mutex is then\n+        // responsible for destroying the mutex.\n+        //\n+        // It is crucial that the negative value is swapped in *after* the\n+        // initialization routine has completed because otherwise new threads\n+        // calling `doit` will return immediately before the initialization has\n+        // completed.\n+\n+        let prev = self.cnt.fetch_add(1, SeqCst);\n+        if prev < 0 {\n+            // Make sure we never overflow, we'll never have int::min_value\n+            // simultaneous calls to `doit` to make this value go back to 0\n+            self.cnt.store(int::min_value, SeqCst);\n+            return\n+        }\n+\n+        // If the count is negative, then someone else finished the job,\n+        // otherwise we run the job and record how many people will try to grab\n+        // this lock\n+        unsafe { self.mutex.lock() }\n+        if self.cnt.load(SeqCst) > 0 {\n+            f();\n+            let prev = self.cnt.swap(int::min_value, SeqCst);\n+            self.lock_cnt.store(prev, SeqCst);\n+        }\n+        unsafe { self.mutex.unlock() }\n+\n+        // Last one out cleans up after everyone else, no leaks!\n+        if self.lock_cnt.fetch_add(-1, SeqCst) == 1 {\n+            unsafe { self.mutex.destroy() }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n-    use super::{Mutex, MUTEX_INIT};\n     use rt::thread::Thread;\n+    use super::{ONCE_INIT, Once, Mutex, MUTEX_INIT};\n+    use task;\n+\n+    #[test]\n+    fn smoke_once() {\n+        static mut o: Once = ONCE_INIT;\n+        let mut a = 0;\n+        unsafe { o.doit(|| a += 1); }\n+        assert_eq!(a, 1);\n+        unsafe { o.doit(|| a += 1); }\n+        assert_eq!(a, 1);\n+    }\n+\n+    #[test]\n+    fn stampede_once() {\n+        static mut o: Once = ONCE_INIT;\n+        static mut run: bool = false;\n+\n+        let (p, c) = SharedChan::new();\n+        for _ in range(0, 10) {\n+            let c = c.clone();\n+            do spawn {\n+                for _ in range(0, 4) { task::deschedule() }\n+                unsafe {\n+                    o.doit(|| {\n+                        assert!(!run);\n+                        run = true;\n+                    });\n+                    assert!(run);\n+                }\n+                c.send(());\n+            }\n+        }\n+\n+        unsafe {\n+            o.doit(|| {\n+                assert!(!run);\n+                run = true;\n+            });\n+            assert!(run);\n+        }\n+\n+        for _ in range(0, 10) {\n+            p.recv();\n+        }\n+    }\n \n     #[test]\n     fn somke_lock() {"}]}