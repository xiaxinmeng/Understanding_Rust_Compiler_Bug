{"sha": "b9306c231a9ffaf83d420ec09f165f58444d142e", "node_id": "C_kwDOAAsO6NoAKGI5MzA2YzIzMWE5ZmZhZjgzZDQyMGVjMDlmMTY1ZjU4NDQ0ZDE0MmU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-28T07:35:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-28T07:35:11Z"}, "message": "Rollup merge of #97015 - nrc:read-buf-cursor, r=Mark-Simulacrum\n\nstd::io: migrate ReadBuf to BorrowBuf/BorrowCursor\n\nThis PR replaces `ReadBuf` (used by the `Read::read_buf` family of methods) with `BorrowBuf` and `BorrowCursor`.\n\nThe general idea is to split `ReadBuf` because its API is large and confusing. `BorrowBuf` represents a borrowed buffer which is mostly read-only and (other than for construction) deals only with filled vs unfilled segments. a `BorrowCursor` is a mostly write-only view of the unfilled part of a `BorrowBuf` which distinguishes between initialized and uninitialized segments. For `Read::read_buf`, the caller would create a `BorrowBuf`, then pass a `BorrowCursor` to `read_buf`.\n\nIn addition to the major API split, I've made the following smaller changes:\n\n* Removed some methods entirely from the API (mostly the functionality can be replicated with two calls rather than a single one)\n* Unified naming, e.g., by replacing initialized with init and assume_init with set_init\n* Added an easy way to get the number of bytes written to a cursor (`written` method)\n\nAs well as simplifying the API (IMO), this approach has the following advantages:\n\n* Since we pass the cursor by value, we remove the 'unsoundness footgun' where a malicious `read_buf` could swap out the `ReadBuf`.\n* Since `read_buf` cannot write into the filled part of the buffer, we prevent the filled part shrinking or changing which could cause underflow for the caller or unexpected behaviour.\n\n## Outline\n\n```rust\npub struct BorrowBuf<'a>\n\nimpl Debug for BorrowBuf<'_>\n\nimpl<'a> From<&'a mut [u8]> for BorrowBuf<'a>\nimpl<'a> From<&'a mut [MaybeUninit<u8>]> for BorrowBuf<'a>\n\nimpl<'a> BorrowBuf<'a> {\n    pub fn capacity(&self) -> usize\n    pub fn len(&self) -> usize\n    pub fn init_len(&self) -> usize\n    pub fn filled(&self) -> &[u8]\n    pub fn unfilled<'this>(&'this mut self) -> BorrowCursor<'this, 'a>\n    pub fn clear(&mut self) -> &mut Self\n    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self\n}\n\npub struct BorrowCursor<'buf, 'data>\n\nimpl<'buf, 'data> BorrowCursor<'buf, 'data> {\n    pub fn clone<'this>(&'this mut self) -> BorrowCursor<'this, 'data>\n    pub fn capacity(&self) -> usize\n    pub fn written(&self) -> usize\n    pub fn init_ref(&self) -> &[u8]\n    pub fn init_mut(&mut self) -> &mut [u8]\n    pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>]\n    pub unsafe fn as_mut(&mut self) -> &mut [MaybeUninit<u8>]\n    pub unsafe fn advance(&mut self, n: usize) -> &mut Self\n    pub fn ensure_init(&mut self) -> &mut Self\n    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self\n    pub fn append(&mut self, buf: &[u8])\n}\n```\n\n## TODO\n\n* ~~Migrate non-unix libs and tests~~\n* ~~Naming~~\n  * ~~`BorrowBuf` or `BorrowedBuf` or `SliceBuf`? (We might want an owned equivalent for the async IO traits)~~\n  * ~~Should we rename the `readbuf` module? We might keep the name indicate it includes both the buf and cursor variations and someday the owned version too. Or we could change it. It is not publicly exposed, so it is not that important~~.\n  * ~~`read_buf` method: we read into the cursor now, so the `_buf` suffix is a bit weird.~~\n* ~~Documentation~~\n* Tests are incomplete (I adjusted existing tests, but did not add new ones).\n\ncc https://github.com/rust-lang/rust/issues/78485, https://github.com/rust-lang/rust/issues/94741\nsupersedes: https://github.com/rust-lang/rust/pull/95770, https://github.com/rust-lang/rust/pull/93359\nfixes #93305", "tree": {"sha": "94de45df1e1e09e43ddeb4bcecc929af3e21d5d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94de45df1e1e09e43ddeb4bcecc929af3e21d5d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9306c231a9ffaf83d420ec09f165f58444d142e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjCxqvCRBK7hj4Ov3rIwAAvIwIAKRSwDFoMhvzWNMGQR9CPuN1\nH0kxP8+XRt1u/pGDhk5w45OPg5Mv4GnrQd/4Bplxy3nP0M0iJ3JortrQ4BWCQgOe\nqdJwBU9S/mVQn7nwkYfzJxb55D4jr5JlmiLelx757emLnA+rW9a54/fqpJba1x8O\nLd6lDMLtnGyKydsddthCj9JQXIX4+PjrJBEbPGDucGnHKNdUOLWkMCj1su+XUYAo\n0lECziPBBWAqijCc1ZZLOaS0rnmHGchbNvmhv79hLNFk4ywWcJ6CYvNsJI9ZLqgm\nw3YRDUrhSsFPq3n8CqPrxC6HrFU0Lo0dxnkllvZDBmlZWYK0cOwIkl2yN1GKGY0=\n=igVd\n-----END PGP SIGNATURE-----\n", "payload": "tree 94de45df1e1e09e43ddeb4bcecc929af3e21d5d4\nparent 91f128baf7704a477ab7c499143a160fb069b3ad\nparent ac70aea98509c33ec75208f7b42c8d905c74ebaf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661672111 +0200\ncommitter GitHub <noreply@github.com> 1661672111 +0200\n\nRollup merge of #97015 - nrc:read-buf-cursor, r=Mark-Simulacrum\n\nstd::io: migrate ReadBuf to BorrowBuf/BorrowCursor\n\nThis PR replaces `ReadBuf` (used by the `Read::read_buf` family of methods) with `BorrowBuf` and `BorrowCursor`.\n\nThe general idea is to split `ReadBuf` because its API is large and confusing. `BorrowBuf` represents a borrowed buffer which is mostly read-only and (other than for construction) deals only with filled vs unfilled segments. a `BorrowCursor` is a mostly write-only view of the unfilled part of a `BorrowBuf` which distinguishes between initialized and uninitialized segments. For `Read::read_buf`, the caller would create a `BorrowBuf`, then pass a `BorrowCursor` to `read_buf`.\n\nIn addition to the major API split, I've made the following smaller changes:\n\n* Removed some methods entirely from the API (mostly the functionality can be replicated with two calls rather than a single one)\n* Unified naming, e.g., by replacing initialized with init and assume_init with set_init\n* Added an easy way to get the number of bytes written to a cursor (`written` method)\n\nAs well as simplifying the API (IMO), this approach has the following advantages:\n\n* Since we pass the cursor by value, we remove the 'unsoundness footgun' where a malicious `read_buf` could swap out the `ReadBuf`.\n* Since `read_buf` cannot write into the filled part of the buffer, we prevent the filled part shrinking or changing which could cause underflow for the caller or unexpected behaviour.\n\n## Outline\n\n```rust\npub struct BorrowBuf<'a>\n\nimpl Debug for BorrowBuf<'_>\n\nimpl<'a> From<&'a mut [u8]> for BorrowBuf<'a>\nimpl<'a> From<&'a mut [MaybeUninit<u8>]> for BorrowBuf<'a>\n\nimpl<'a> BorrowBuf<'a> {\n    pub fn capacity(&self) -> usize\n    pub fn len(&self) -> usize\n    pub fn init_len(&self) -> usize\n    pub fn filled(&self) -> &[u8]\n    pub fn unfilled<'this>(&'this mut self) -> BorrowCursor<'this, 'a>\n    pub fn clear(&mut self) -> &mut Self\n    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self\n}\n\npub struct BorrowCursor<'buf, 'data>\n\nimpl<'buf, 'data> BorrowCursor<'buf, 'data> {\n    pub fn clone<'this>(&'this mut self) -> BorrowCursor<'this, 'data>\n    pub fn capacity(&self) -> usize\n    pub fn written(&self) -> usize\n    pub fn init_ref(&self) -> &[u8]\n    pub fn init_mut(&mut self) -> &mut [u8]\n    pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>]\n    pub unsafe fn as_mut(&mut self) -> &mut [MaybeUninit<u8>]\n    pub unsafe fn advance(&mut self, n: usize) -> &mut Self\n    pub fn ensure_init(&mut self) -> &mut Self\n    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self\n    pub fn append(&mut self, buf: &[u8])\n}\n```\n\n## TODO\n\n* ~~Migrate non-unix libs and tests~~\n* ~~Naming~~\n  * ~~`BorrowBuf` or `BorrowedBuf` or `SliceBuf`? (We might want an owned equivalent for the async IO traits)~~\n  * ~~Should we rename the `readbuf` module? We might keep the name indicate it includes both the buf and cursor variations and someday the owned version too. Or we could change it. It is not publicly exposed, so it is not that important~~.\n  * ~~`read_buf` method: we read into the cursor now, so the `_buf` suffix is a bit weird.~~\n* ~~Documentation~~\n* Tests are incomplete (I adjusted existing tests, but did not add new ones).\n\ncc https://github.com/rust-lang/rust/issues/78485, https://github.com/rust-lang/rust/issues/94741\nsupersedes: https://github.com/rust-lang/rust/pull/95770, https://github.com/rust-lang/rust/pull/93359\nfixes #93305\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9306c231a9ffaf83d420ec09f165f58444d142e", "html_url": "https://github.com/rust-lang/rust/commit/b9306c231a9ffaf83d420ec09f165f58444d142e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9306c231a9ffaf83d420ec09f165f58444d142e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91f128baf7704a477ab7c499143a160fb069b3ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/91f128baf7704a477ab7c499143a160fb069b3ad", "html_url": "https://github.com/rust-lang/rust/commit/91f128baf7704a477ab7c499143a160fb069b3ad"}, {"sha": "ac70aea98509c33ec75208f7b42c8d905c74ebaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac70aea98509c33ec75208f7b42c8d905c74ebaf", "html_url": "https://github.com/rust-lang/rust/commit/ac70aea98509c33ec75208f7b42c8d905c74ebaf"}], "stats": {"total": 890, "additions": 472, "deletions": 418}, "files": [{"sha": "e1ab06b0d0f69fc8eb77fc65e838970ce7c191a7", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -13,7 +13,7 @@ mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n use crate::sys::fs as fs_imp;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n@@ -703,8 +703,8 @@ impl Read for File {\n         self.inner.read_vectored(bufs)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.inner.read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(cursor)\n     }\n \n     #[inline]\n@@ -755,8 +755,8 @@ impl Read for &File {\n         self.inner.read(buf)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.inner.read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(cursor)\n     }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {"}, {"sha": "88ad92d8a985971134ba3171a952547fa6003e9e", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -2,7 +2,7 @@ mod buffer;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n+    self, BorrowedCursor, BufRead, IoSliceMut, Read, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n };\n use buffer::Buffer;\n \n@@ -266,21 +266,21 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.pos() == self.buf.filled() && buf.remaining() >= self.capacity() {\n+        if self.buf.pos() == self.buf.filled() && cursor.capacity() >= self.capacity() {\n             self.discard_buffer();\n-            return self.inner.read_buf(buf);\n+            return self.inner.read_buf(cursor);\n         }\n \n-        let prev = buf.filled_len();\n+        let prev = cursor.written();\n \n         let mut rem = self.fill_buf()?;\n-        rem.read_buf(buf)?;\n+        rem.read_buf(cursor.reborrow())?;\n \n-        self.consume(buf.filled_len() - prev); //slice impl of read_buf known to never unfill buf\n+        self.consume(cursor.written() - prev); //slice impl of read_buf known to never unfill buf\n \n         Ok(())\n     }"}, {"sha": "867c22c6041e73b560f2298c48cf51821e9d7947", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -9,7 +9,7 @@\n /// that user code which wants to do reads from a `BufReader` via `buffer` + `consume` can do so\n /// without encountering any runtime bounds checks.\n use crate::cmp;\n-use crate::io::{self, Read, ReadBuf};\n+use crate::io::{self, BorrowedBuf, Read};\n use crate::mem::MaybeUninit;\n \n pub struct Buffer {\n@@ -93,11 +93,15 @@ impl Buffer {\n         if self.pos >= self.filled {\n             debug_assert!(self.pos == self.filled);\n \n-            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n+            let mut buf = BorrowedBuf::from(&mut *self.buf);\n+            // SAFETY: `self.filled` bytes will always have been initialized.\n+            unsafe {\n+                buf.set_init(self.filled);\n+            }\n \n-            reader.read_buf(&mut readbuf)?;\n+            reader.read_buf(buf.unfilled())?;\n \n-            self.filled = readbuf.filled_len();\n+            self.filled = buf.len();\n             self.pos = 0;\n         }\n         Ok(self.buffer())"}, {"sha": "bd6d95242ad94e4b04bfda9951c624da84a2ef23", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -1,5 +1,7 @@\n use crate::io::prelude::*;\n-use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, ReadBuf, SeekFrom};\n+use crate::io::{\n+    self, BorrowedBuf, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom,\n+};\n use crate::mem::MaybeUninit;\n use crate::panic;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n@@ -61,48 +63,48 @@ fn test_buffered_reader_read_buf() {\n     let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n     let mut reader = BufReader::with_capacity(2, inner);\n \n-    let mut buf = [MaybeUninit::uninit(); 3];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 3];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [5, 6, 7]);\n     assert_eq!(reader.buffer(), []);\n \n-    let mut buf = [MaybeUninit::uninit(); 2];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 2];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [0, 1]);\n     assert_eq!(reader.buffer(), []);\n \n-    let mut buf = [MaybeUninit::uninit(); 1];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [2]);\n     assert_eq!(reader.buffer(), [3]);\n \n-    let mut buf = [MaybeUninit::uninit(); 3];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 3];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [3]);\n     assert_eq!(reader.buffer(), []);\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [3, 4]);\n     assert_eq!(reader.buffer(), []);\n \n     buf.clear();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n-    assert_eq!(buf.filled_len(), 0);\n+    assert!(buf.filled().is_empty());\n }\n \n #[test]"}, {"sha": "38b98afffa16887c40adc1d3d279ab767aec8a9c", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -1,4 +1,4 @@\n-use super::{BufWriter, ErrorKind, Read, ReadBuf, Result, Write, DEFAULT_BUF_SIZE};\n+use super::{BorrowedBuf, BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -97,37 +97,39 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n \n         loop {\n             let buf = writer.buffer_mut();\n-            let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+            let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n \n-            // SAFETY: init is either 0 or the initialized_len of the previous iteration\n             unsafe {\n-                read_buf.assume_init(init);\n+                // SAFETY: init is either 0 or the init_len from the previous iteration.\n+                read_buf.set_init(init);\n             }\n \n             if read_buf.capacity() >= DEFAULT_BUF_SIZE {\n-                match reader.read_buf(&mut read_buf) {\n+                let mut cursor = read_buf.unfilled();\n+                match reader.read_buf(cursor.reborrow()) {\n                     Ok(()) => {\n-                        let bytes_read = read_buf.filled_len();\n+                        let bytes_read = cursor.written();\n \n                         if bytes_read == 0 {\n                             return Ok(len);\n                         }\n \n-                        init = read_buf.initialized_len() - bytes_read;\n+                        init = read_buf.init_len() - bytes_read;\n+                        len += bytes_read as u64;\n \n-                        // SAFETY: ReadBuf guarantees all of its filled bytes are init\n+                        // SAFETY: BorrowedBuf guarantees all of its filled bytes are init\n                         unsafe { buf.set_len(buf.len() + bytes_read) };\n-                        len += bytes_read as u64;\n+\n                         // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                         // This will occur if the reader returns short reads\n-                        continue;\n                     }\n-                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                     Err(e) => return Err(e),\n                 }\n+            } else {\n+                writer.flush_buf()?;\n+                init = 0;\n             }\n-\n-            writer.flush_buf()?;\n         }\n     }\n }\n@@ -136,13 +138,13 @@ fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n     reader: &mut R,\n     writer: &mut W,\n ) -> Result<u64> {\n-    let mut buf = [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n     let mut len = 0;\n \n     loop {\n-        match reader.read_buf(&mut buf) {\n+        match reader.read_buf(buf.unfilled()) {\n             Ok(()) => {}\n             Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),"}, {"sha": "d98ab021cadb156b58d35276b475ed9109fb6d71", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -5,7 +5,7 @@ use crate::io::prelude::*;\n \n use crate::alloc::Allocator;\n use crate::cmp;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n \n /// A `Cursor` wraps an in-memory buffer and provides it with a\n /// [`Seek`] implementation.\n@@ -323,12 +323,12 @@ where\n         Ok(n)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let prev_filled = buf.filled_len();\n+    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        let prev_written = cursor.written();\n \n-        Read::read_buf(&mut self.fill_buf()?, buf)?;\n+        Read::read_buf(&mut self.fill_buf()?, cursor.reborrow())?;\n \n-        self.pos += (buf.filled_len() - prev_filled) as u64;\n+        self.pos += (cursor.written() - prev_written) as u64;\n \n         Ok(())\n     }"}, {"sha": "e5048dcc8acd91ec86e424bdcef3bedec0ad6de7", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -6,7 +6,7 @@ use crate::cmp;\n use crate::collections::VecDeque;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n+    self, BorrowedCursor, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n };\n use crate::mem;\n \n@@ -21,8 +21,8 @@ impl<R: Read + ?Sized> Read for &mut R {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        (**self).read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n     }\n \n     #[inline]\n@@ -125,8 +125,8 @@ impl<R: Read + ?Sized> Read for Box<R> {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        (**self).read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n     }\n \n     #[inline]\n@@ -249,11 +249,11 @@ impl Read for &[u8] {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let amt = cmp::min(buf.remaining(), self.len());\n+    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        let amt = cmp::min(cursor.capacity(), self.len());\n         let (a, b) = self.split_at(amt);\n \n-        buf.append(a);\n+        cursor.append(a);\n \n         *self = b;\n         Ok(())\n@@ -427,10 +427,10 @@ impl<A: Allocator> Read for VecDeque<u8, A> {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         let (ref mut front, _) = self.as_slices();\n-        let n = cmp::min(buf.remaining(), front.len());\n-        Read::read_buf(front, buf)?;\n+        let n = cmp::min(cursor.capacity(), front.len());\n+        Read::read_buf(front, cursor)?;\n         self.drain(..n);\n         Ok(())\n     }"}, {"sha": "8b8ec32bf5b634a48ee5e60ef82740638e1a304f", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -278,7 +278,7 @@ pub use self::{\n };\n \n #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-pub use self::readbuf::ReadBuf;\n+pub use self::readbuf::{BorrowedBuf, BorrowedCursor};\n pub(crate) use error::const_io_error;\n \n mod buffered;\n@@ -362,29 +362,30 @@ pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>\n             buf.reserve(32); // buf is full, need more space\n         }\n \n-        let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+        let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n \n         // SAFETY: These bytes were initialized but not filled in the previous loop\n         unsafe {\n-            read_buf.assume_init(initialized);\n+            read_buf.set_init(initialized);\n         }\n \n-        match r.read_buf(&mut read_buf) {\n+        let mut cursor = read_buf.unfilled();\n+        match r.read_buf(cursor.reborrow()) {\n             Ok(()) => {}\n             Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         }\n \n-        if read_buf.filled_len() == 0 {\n+        if cursor.written() == 0 {\n             return Ok(buf.len() - start_len);\n         }\n \n         // store how much was initialized but not filled\n-        initialized = read_buf.initialized_len() - read_buf.filled_len();\n-        let new_len = read_buf.filled_len() + buf.len();\n+        initialized = cursor.init_ref().len();\n \n-        // SAFETY: ReadBuf's invariants mean this much memory is init\n+        // SAFETY: BorrowedBuf's invariants mean this much memory is initialized.\n         unsafe {\n+            let new_len = read_buf.filled().len() + buf.len();\n             buf.set_len(new_len);\n         }\n \n@@ -461,12 +462,15 @@ pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [\n     }\n }\n \n-pub(crate) fn default_read_buf<F>(read: F, buf: &mut ReadBuf<'_>) -> Result<()>\n+pub(crate) fn default_read_buf<F>(read: F, mut cursor: BorrowedCursor<'_>) -> Result<()>\n where\n     F: FnOnce(&mut [u8]) -> Result<usize>,\n {\n-    let n = read(buf.initialize_unfilled())?;\n-    buf.add_filled(n);\n+    let n = read(cursor.ensure_init().init_mut())?;\n+    unsafe {\n+        // SAFETY: we initialised using `ensure_init` so there is no uninit data to advance to.\n+        cursor.advance(n);\n+    }\n     Ok(())\n }\n \n@@ -803,30 +807,30 @@ pub trait Read {\n \n     /// Pull some bytes from this source into the specified buffer.\n     ///\n-    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to allow use\n+    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to allow use\n     /// with uninitialized buffers. The new data will be appended to any existing contents of `buf`.\n     ///\n     /// The default implementation delegates to `read`.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> Result<()> {\n         default_read_buf(|b| self.read(b), buf)\n     }\n \n-    /// Read the exact number of bytes required to fill `buf`.\n+    /// Read the exact number of bytes required to fill `cursor`.\n     ///\n-    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to\n+    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to\n     /// allow use with uninitialized buffers.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-    fn read_buf_exact(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n-        while buf.remaining() > 0 {\n-            let prev_filled = buf.filled().len();\n-            match self.read_buf(buf) {\n+    fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> Result<()> {\n+        while cursor.capacity() > 0 {\n+            let prev_written = cursor.written();\n+            match self.read_buf(cursor.reborrow()) {\n                 Ok(()) => {}\n                 Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n                 Err(e) => return Err(e),\n             }\n \n-            if buf.filled().len() == prev_filled {\n+            if cursor.written() == prev_written {\n                 return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill buffer\"));\n             }\n         }\n@@ -2582,50 +2586,48 @@ impl<T: Read> Read for Take<T> {\n         Ok(n)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+    fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> Result<()> {\n         // Don't call into inner reader at all at EOF because it may still block\n         if self.limit == 0 {\n             return Ok(());\n         }\n \n-        let prev_filled = buf.filled_len();\n-\n-        if self.limit <= buf.remaining() as u64 {\n+        if self.limit <= buf.capacity() as u64 {\n             // if we just use an as cast to convert, limit may wrap around on a 32 bit target\n             let limit = cmp::min(self.limit, usize::MAX as u64) as usize;\n \n-            let extra_init = cmp::min(limit as usize, buf.initialized_len() - buf.filled_len());\n+            let extra_init = cmp::min(limit as usize, buf.init_ref().len());\n \n             // SAFETY: no uninit data is written to ibuf\n-            let ibuf = unsafe { &mut buf.unfilled_mut()[..limit] };\n+            let ibuf = unsafe { &mut buf.as_mut()[..limit] };\n \n-            let mut sliced_buf = ReadBuf::uninit(ibuf);\n+            let mut sliced_buf: BorrowedBuf<'_> = ibuf.into();\n \n             // SAFETY: extra_init bytes of ibuf are known to be initialized\n             unsafe {\n-                sliced_buf.assume_init(extra_init);\n+                sliced_buf.set_init(extra_init);\n             }\n \n-            self.inner.read_buf(&mut sliced_buf)?;\n+            let mut cursor = sliced_buf.unfilled();\n+            self.inner.read_buf(cursor.reborrow())?;\n \n-            let new_init = sliced_buf.initialized_len();\n-            let filled = sliced_buf.filled_len();\n+            let new_init = cursor.init_ref().len();\n+            let filled = sliced_buf.len();\n \n-            // sliced_buf / ibuf must drop here\n+            // cursor / sliced_buf / ibuf must drop here\n \n-            // SAFETY: new_init bytes of buf's unfilled buffer have been initialized\n             unsafe {\n-                buf.assume_init(new_init);\n+                // SAFETY: filled bytes have been filled and therefore initialized\n+                buf.advance(filled);\n+                // SAFETY: new_init bytes of buf's unfilled buffer have been initialized\n+                buf.set_init(new_init);\n             }\n \n-            buf.add_filled(filled);\n-\n             self.limit -= filled as u64;\n         } else {\n-            self.inner.read_buf(buf)?;\n-\n-            //inner may unfill\n-            self.limit -= buf.filled_len().saturating_sub(prev_filled) as u64;\n+            let written = buf.written();\n+            self.inner.read_buf(buf.reborrow())?;\n+            self.limit -= (buf.written() - written) as u64;\n         }\n \n         Ok(())"}, {"sha": "b1a84095f13fa7e9b1823935998794fa3713f481", "filename": "library/std/src/io/readbuf.rs", "status": "modified", "additions": 182, "deletions": 125, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -5,9 +5,10 @@ mod tests;\n \n use crate::cmp;\n use crate::fmt::{self, Debug, Formatter};\n-use crate::mem::MaybeUninit;\n+use crate::io::{Result, Write};\n+use crate::mem::{self, MaybeUninit};\n \n-/// A wrapper around a byte buffer that is incrementally filled and initialized.\n+/// A borrowed byte buffer which is incrementally filled and initialized.\n ///\n /// This type is a sort of \"double cursor\". It tracks three regions in the buffer: a region at the beginning of the\n /// buffer that has been logically filled with data, a region that has been initialized at some point but not yet\n@@ -20,230 +21,286 @@ use crate::mem::MaybeUninit;\n /// [ filled |         unfilled         ]\n /// [    initialized    | uninitialized ]\n /// ```\n-pub struct ReadBuf<'a> {\n-    buf: &'a mut [MaybeUninit<u8>],\n+///\n+/// A `BorrowedBuf` is created around some existing data (or capacity for data) via a unique reference\n+/// (`&mut`). The `BorrowedBuf` can be configured (e.g., using `clear` or `set_init`), but cannot be\n+/// directly written. To write into the buffer, use `unfilled` to create a `BorrowedCursor`. The cursor\n+/// has write-only access to the unfilled portion of the buffer (you can think of it as a\n+/// write-only iterator).\n+///\n+/// The lifetime `'data` is a bound on the lifetime of the underlying data.\n+pub struct BorrowedBuf<'data> {\n+    /// The buffer's underlying data.\n+    buf: &'data mut [MaybeUninit<u8>],\n+    /// The length of `self.buf` which is known to be filled.\n     filled: usize,\n-    initialized: usize,\n+    /// The length of `self.buf` which is known to be initialized.\n+    init: usize,\n }\n \n-impl Debug for ReadBuf<'_> {\n+impl Debug for BorrowedBuf<'_> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"ReadBuf\")\n-            .field(\"init\", &self.initialized())\n+        f.debug_struct(\"BorrowedBuf\")\n+            .field(\"init\", &self.init)\n             .field(\"filled\", &self.filled)\n             .field(\"capacity\", &self.capacity())\n             .finish()\n     }\n }\n \n-impl<'a> ReadBuf<'a> {\n-    /// Creates a new `ReadBuf` from a fully initialized buffer.\n+/// Create a new `BorrowedBuf` from a fully initialized slice.\n+impl<'data> From<&'data mut [u8]> for BorrowedBuf<'data> {\n     #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> ReadBuf<'a> {\n-        let len = buf.len();\n+    fn from(slice: &'data mut [u8]) -> BorrowedBuf<'data> {\n+        let len = slice.len();\n \n-        ReadBuf {\n-            //SAFETY: initialized data never becoming uninitialized is an invariant of ReadBuf\n-            buf: unsafe { (buf as *mut [u8]).as_uninit_slice_mut().unwrap() },\n+        BorrowedBuf {\n+            // SAFETY: initialized data never becoming uninitialized is an invariant of BorrowedBuf\n+            buf: unsafe { (slice as *mut [u8]).as_uninit_slice_mut().unwrap() },\n             filled: 0,\n-            initialized: len,\n+            init: len,\n         }\n     }\n+}\n \n-    /// Creates a new `ReadBuf` from a fully uninitialized buffer.\n-    ///\n-    /// Use `assume_init` if part of the buffer is known to be already initialized.\n+/// Create a new `BorrowedBuf` from an uninitialized buffer.\n+///\n+/// Use `set_init` if part of the buffer is known to be already initialized.\n+impl<'data> From<&'data mut [MaybeUninit<u8>]> for BorrowedBuf<'data> {\n     #[inline]\n-    pub fn uninit(buf: &'a mut [MaybeUninit<u8>]) -> ReadBuf<'a> {\n-        ReadBuf { buf, filled: 0, initialized: 0 }\n+    fn from(buf: &'data mut [MaybeUninit<u8>]) -> BorrowedBuf<'data> {\n+        BorrowedBuf { buf, filled: 0, init: 0 }\n     }\n+}\n \n+impl<'data> BorrowedBuf<'data> {\n     /// Returns the total capacity of the buffer.\n     #[inline]\n     pub fn capacity(&self) -> usize {\n         self.buf.len()\n     }\n \n+    /// Returns the length of the filled part of the buffer.\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.filled\n+    }\n+\n+    /// Returns the length of the initialized part of the buffer.\n+    #[inline]\n+    pub fn init_len(&self) -> usize {\n+        self.init\n+    }\n+\n     /// Returns a shared reference to the filled portion of the buffer.\n     #[inline]\n     pub fn filled(&self) -> &[u8] {\n-        //SAFETY: We only slice the filled part of the buffer, which is always valid\n+        // SAFETY: We only slice the filled part of the buffer, which is always valid\n         unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.filled]) }\n     }\n \n-    /// Returns a mutable reference to the filled portion of the buffer.\n+    /// Returns a cursor over the unfilled part of the buffer.\n     #[inline]\n-    pub fn filled_mut(&mut self) -> &mut [u8] {\n-        //SAFETY: We only slice the filled part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.filled]) }\n+    pub fn unfilled<'this>(&'this mut self) -> BorrowedCursor<'this> {\n+        BorrowedCursor {\n+            start: self.filled,\n+            // SAFETY: we never assign into `BorrowedCursor::buf`, so treating its\n+            // lifetime covariantly is safe.\n+            buf: unsafe {\n+                mem::transmute::<&'this mut BorrowedBuf<'data>, &'this mut BorrowedBuf<'this>>(self)\n+            },\n+        }\n     }\n \n-    /// Returns a shared reference to the initialized portion of the buffer.\n+    /// Clears the buffer, resetting the filled region to empty.\n     ///\n-    /// This includes the filled portion.\n+    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n     #[inline]\n-    pub fn initialized(&self) -> &[u8] {\n-        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.initialized]) }\n+    pub fn clear(&mut self) -> &mut Self {\n+        self.filled = 0;\n+        self\n     }\n \n-    /// Returns a mutable reference to the initialized portion of the buffer.\n+    /// Asserts that the first `n` bytes of the buffer are initialized.\n     ///\n-    /// This includes the filled portion.\n-    #[inline]\n-    pub fn initialized_mut(&mut self) -> &mut [u8] {\n-        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.initialized]) }\n-    }\n-\n-    /// Returns a mutable reference to the unfilled part of the buffer without ensuring that it has been fully\n-    /// initialized.\n+    /// `BorrowedBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n+    /// bytes than are already known to be initialized.\n     ///\n     /// # Safety\n     ///\n-    /// The caller must not de-initialize portions of the buffer that have already been initialized.\n+    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n     #[inline]\n-    pub unsafe fn unfilled_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n-        &mut self.buf[self.filled..]\n+    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {\n+        self.init = cmp::max(self.init, n);\n+        self\n     }\n+}\n \n-    /// Returns a mutable reference to the uninitialized part of the buffer.\n+/// A writeable view of the unfilled portion of a [`BorrowedBuf`](BorrowedBuf).\n+///\n+/// Provides access to the initialized and uninitialized parts of the underlying `BorrowedBuf`.\n+/// Data can be written directly to the cursor by using [`append`](BorrowedCursor::append) or\n+/// indirectly by getting a slice of part or all of the cursor and writing into the slice. In the\n+/// indirect case, the caller must call [`advance`](BorrowedCursor::advance) after writing to inform\n+/// the cursor how many bytes have been written.\n+///\n+/// Once data is written to the cursor, it becomes part of the filled portion of the underlying\n+/// `BorrowedBuf` and can no longer be accessed or re-written by the cursor. I.e., the cursor tracks\n+/// the unfilled part of the underlying `BorrowedBuf`.\n+///\n+/// The lifetime `'a` is a bound on the lifetime of the underlying buffer (which means it is a bound\n+/// on the data in that buffer by transitivity).\n+#[derive(Debug)]\n+pub struct BorrowedCursor<'a> {\n+    /// The underlying buffer.\n+    // Safety invariant: we treat the type of buf as covariant in the lifetime of `BorrowedBuf` when\n+    // we create a `BorrowedCursor`. This is only safe if we never replace `buf` by assigning into\n+    // it, so don't do that!\n+    buf: &'a mut BorrowedBuf<'a>,\n+    /// The length of the filled portion of the underlying buffer at the time of the cursor's\n+    /// creation.\n+    start: usize,\n+}\n+\n+impl<'a> BorrowedCursor<'a> {\n+    /// Reborrow this cursor by cloning it with a smaller lifetime.\n     ///\n-    /// It is safe to uninitialize any of these bytes.\n+    /// Since a cursor maintains unique access to its underlying buffer, the borrowed cursor is\n+    /// not accessible while the new cursor exists.\n     #[inline]\n-    pub fn uninitialized_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n-        &mut self.buf[self.initialized..]\n+    pub fn reborrow<'this>(&'this mut self) -> BorrowedCursor<'this> {\n+        BorrowedCursor {\n+            // SAFETY: we never assign into `BorrowedCursor::buf`, so treating its\n+            // lifetime covariantly is safe.\n+            buf: unsafe {\n+                mem::transmute::<&'this mut BorrowedBuf<'a>, &'this mut BorrowedBuf<'this>>(\n+                    self.buf,\n+                )\n+            },\n+            start: self.start,\n+        }\n     }\n \n-    /// Returns a mutable reference to the unfilled part of the buffer, ensuring it is fully initialized.\n-    ///\n-    /// Since `ReadBuf` tracks the region of the buffer that has been initialized, this is effectively \"free\" after\n-    /// the first use.\n+    /// Returns the available space in the cursor.\n     #[inline]\n-    pub fn initialize_unfilled(&mut self) -> &mut [u8] {\n-        // should optimize out the assertion\n-        self.initialize_unfilled_to(self.remaining())\n+    pub fn capacity(&self) -> usize {\n+        self.buf.capacity() - self.buf.filled\n     }\n \n-    /// Returns a mutable reference to the first `n` bytes of the unfilled part of the buffer, ensuring it is\n-    /// fully initialized.\n-    ///\n-    /// # Panics\n+    /// Returns the number of bytes written to this cursor since it was created from a `BorrowedBuf`.\n     ///\n-    /// Panics if `self.remaining()` is less than `n`.\n+    /// Note that if this cursor is a reborrowed clone of another, then the count returned is the\n+    /// count written via either cursor, not the count since the cursor was reborrowed.\n     #[inline]\n-    pub fn initialize_unfilled_to(&mut self, n: usize) -> &mut [u8] {\n-        assert!(self.remaining() >= n);\n-\n-        let extra_init = self.initialized - self.filled;\n-        // If we don't have enough initialized, do zeroing\n-        if n > extra_init {\n-            let uninit = n - extra_init;\n-            let unfilled = &mut self.uninitialized_mut()[0..uninit];\n-\n-            for byte in unfilled.iter_mut() {\n-                byte.write(0);\n-            }\n-\n-            // SAFETY: we just initialized uninit bytes, and the previous bytes were already init\n-            unsafe {\n-                self.assume_init(n);\n-            }\n-        }\n-\n-        let filled = self.filled;\n+    pub fn written(&self) -> usize {\n+        self.buf.filled - self.start\n+    }\n \n-        &mut self.initialized_mut()[filled..filled + n]\n+    /// Returns a shared reference to the initialized portion of the cursor.\n+    #[inline]\n+    pub fn init_ref(&self) -> &[u8] {\n+        // SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf.buf[self.buf.filled..self.buf.init]) }\n     }\n \n-    /// Returns the number of bytes at the end of the slice that have not yet been filled.\n+    /// Returns a mutable reference to the initialized portion of the cursor.\n     #[inline]\n-    pub fn remaining(&self) -> usize {\n-        self.capacity() - self.filled\n+    pub fn init_mut(&mut self) -> &mut [u8] {\n+        // SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe {\n+            MaybeUninit::slice_assume_init_mut(&mut self.buf.buf[self.buf.filled..self.buf.init])\n+        }\n     }\n \n-    /// Clears the buffer, resetting the filled region to empty.\n+    /// Returns a mutable reference to the uninitialized part of the cursor.\n     ///\n-    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n+    /// It is safe to uninitialize any of these bytes.\n     #[inline]\n-    pub fn clear(&mut self) -> &mut Self {\n-        self.set_filled(0) // The assertion in `set_filled` is optimized out\n+    pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf.buf[self.buf.init..]\n     }\n \n-    /// Increases the size of the filled region of the buffer.\n-    ///\n-    /// The number of initialized bytes is not changed.\n+    /// Returns a mutable reference to the whole cursor.\n     ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    /// The caller must not uninitialize any bytes in the initialized portion of the cursor.\n     #[inline]\n-    pub fn add_filled(&mut self, n: usize) -> &mut Self {\n-        self.set_filled(self.filled + n)\n+    pub unsafe fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf.buf[self.buf.filled..]\n     }\n \n-    /// Sets the size of the filled region of the buffer.\n+    /// Advance the cursor by asserting that `n` bytes have been filled.\n     ///\n-    /// The number of initialized bytes is not changed.\n+    /// After advancing, the `n` bytes are no longer accessible via the cursor and can only be\n+    /// accessed via the underlying buffer. I.e., the buffer's filled portion grows by `n` elements\n+    /// and its unfilled portion (and the capacity of this cursor) shrinks by `n` elements.\n     ///\n-    /// Note that this can be used to *shrink* the filled region of the buffer in addition to growing it (for\n-    /// example, by a `Read` implementation that compresses data in-place).\n-    ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    /// The caller must ensure that the first `n` bytes of the cursor have been properly\n+    /// initialised.\n+    #[inline]\n+    pub unsafe fn advance(&mut self, n: usize) -> &mut Self {\n+        self.buf.filled += n;\n+        self.buf.init = cmp::max(self.buf.init, self.buf.filled);\n+        self\n+    }\n+\n+    /// Initializes all bytes in the cursor.\n     #[inline]\n-    pub fn set_filled(&mut self, n: usize) -> &mut Self {\n-        assert!(n <= self.initialized);\n+    pub fn ensure_init(&mut self) -> &mut Self {\n+        for byte in self.uninit_mut() {\n+            byte.write(0);\n+        }\n+        self.buf.init = self.buf.capacity();\n \n-        self.filled = n;\n         self\n     }\n \n-    /// Asserts that the first `n` unfilled bytes of the buffer are initialized.\n+    /// Asserts that the first `n` unfilled bytes of the cursor are initialized.\n     ///\n-    /// `ReadBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n-    /// bytes than are already known to be initialized.\n+    /// `BorrowedBuf` assumes that bytes are never de-initialized, so this method does nothing when\n+    /// called with fewer bytes than are already known to be initialized.\n     ///\n     /// # Safety\n     ///\n-    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n+    /// The caller must ensure that the first `n` bytes of the buffer have already been initialized.\n     #[inline]\n-    pub unsafe fn assume_init(&mut self, n: usize) -> &mut Self {\n-        self.initialized = cmp::max(self.initialized, self.filled + n);\n+    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {\n+        self.buf.init = cmp::max(self.buf.init, self.buf.filled + n);\n         self\n     }\n \n-    /// Appends data to the buffer, advancing the written position and possibly also the initialized position.\n+    /// Appends data to the cursor, advancing position within its buffer.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `self.remaining()` is less than `buf.len()`.\n+    /// Panics if `self.capacity()` is less than `buf.len()`.\n     #[inline]\n     pub fn append(&mut self, buf: &[u8]) {\n-        assert!(self.remaining() >= buf.len());\n+        assert!(self.capacity() >= buf.len());\n \n         // SAFETY: we do not de-initialize any of the elements of the slice\n         unsafe {\n-            MaybeUninit::write_slice(&mut self.unfilled_mut()[..buf.len()], buf);\n+            MaybeUninit::write_slice(&mut self.as_mut()[..buf.len()], buf);\n         }\n \n         // SAFETY: We just added the entire contents of buf to the filled section.\n         unsafe {\n-            self.assume_init(buf.len());\n+            self.set_init(buf.len());\n         }\n-        self.add_filled(buf.len());\n+        self.buf.filled += buf.len();\n     }\n+}\n \n-    /// Returns the amount of bytes that have been filled.\n-    #[inline]\n-    pub fn filled_len(&self) -> usize {\n-        self.filled\n+impl<'a> Write for BorrowedCursor<'a> {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n+        self.append(buf);\n+        Ok(buf.len())\n     }\n \n-    /// Returns the amount of bytes that have been initialized.\n-    #[inline]\n-    pub fn initialized_len(&self) -> usize {\n-        self.initialized\n+    fn flush(&mut self) -> Result<()> {\n+        Ok(())\n     }\n }"}, {"sha": "cc1b423f2dd0d32fecbf4d7d150af926d6dba2d0", "filename": "library/std/src/io/readbuf/tests.rs", "status": "modified", "additions": 107, "deletions": 113, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -1,181 +1,175 @@\n-use super::ReadBuf;\n+use super::BorrowedBuf;\n use crate::mem::MaybeUninit;\n \n-/// Test that ReadBuf has the correct numbers when created with new\n+/// Test that BorrowedBuf has the correct numbers when created with new\n #[test]\n fn new() {\n-    let mut buf = [0; 16];\n-    let rbuf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [0; 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.init_len(), 16);\n     assert_eq!(rbuf.capacity(), 16);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n }\n \n-/// Test that ReadBuf has the correct numbers when created with uninit\n+/// Test that BorrowedBuf has the correct numbers when created with uninit\n #[test]\n fn uninit() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.initialized_len(), 0);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.init_len(), 0);\n     assert_eq!(rbuf.capacity(), 16);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n }\n \n #[test]\n fn initialize_unfilled() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.initialize_unfilled();\n+    rbuf.unfilled().ensure_init();\n \n-    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.init_len(), 16);\n }\n \n #[test]\n-fn initialize_unfilled_to() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+fn addvance_filled() {\n+    let buf: &mut [_] = &mut [0; 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.initialize_unfilled_to(8);\n-\n-    assert_eq!(rbuf.initialized_len(), 8);\n-\n-    rbuf.initialize_unfilled_to(4);\n-\n-    assert_eq!(rbuf.initialized_len(), 8);\n-\n-    rbuf.set_filled(8);\n-\n-    rbuf.initialize_unfilled_to(6);\n-\n-    assert_eq!(rbuf.initialized_len(), 14);\n-\n-    rbuf.initialize_unfilled_to(8);\n-\n-    assert_eq!(rbuf.initialized_len(), 16);\n-}\n-\n-#[test]\n-fn add_filled() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.add_filled(1);\n-\n-    assert_eq!(rbuf.filled_len(), 1);\n-    assert_eq!(rbuf.remaining(), 15);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn add_filled_panic() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n-\n-    rbuf.add_filled(1);\n-}\n-\n-#[test]\n-fn set_filled() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.set_filled(16);\n-\n-    assert_eq!(rbuf.filled_len(), 16);\n-    assert_eq!(rbuf.remaining(), 0);\n-\n-    rbuf.set_filled(6);\n-\n-    assert_eq!(rbuf.filled_len(), 6);\n-    assert_eq!(rbuf.remaining(), 10);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn set_filled_panic() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    unsafe {\n+        rbuf.unfilled().advance(1);\n+    }\n \n-    rbuf.set_filled(16);\n+    assert_eq!(rbuf.filled().len(), 1);\n+    assert_eq!(rbuf.unfilled().capacity(), 15);\n }\n \n #[test]\n fn clear() {\n-    let mut buf = [255; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [255; 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.set_filled(16);\n+    unsafe {\n+        rbuf.unfilled().advance(16);\n+    }\n \n-    assert_eq!(rbuf.filled_len(), 16);\n-    assert_eq!(rbuf.remaining(), 0);\n+    assert_eq!(rbuf.filled().len(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 0);\n \n     rbuf.clear();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n \n-    assert_eq!(rbuf.initialized(), [255; 16]);\n+    assert_eq!(rbuf.unfilled().init_ref(), [255; 16]);\n }\n \n #[test]\n-fn assume_init() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+fn set_init() {\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n     unsafe {\n-        rbuf.assume_init(8);\n+        rbuf.set_init(8);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n \n-    rbuf.add_filled(4);\n+    unsafe {\n+        rbuf.unfilled().advance(4);\n+    }\n \n     unsafe {\n-        rbuf.assume_init(2);\n+        rbuf.set_init(2);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n \n     unsafe {\n-        rbuf.assume_init(8);\n+        rbuf.set_init(8);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 12);\n+    assert_eq!(rbuf.init_len(), 8);\n }\n \n #[test]\n fn append() {\n-    let mut buf = [MaybeUninit::new(255); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::new(255); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.append(&[0; 8]);\n+    rbuf.unfilled().append(&[0; 8]);\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n-    assert_eq!(rbuf.filled_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n+    assert_eq!(rbuf.filled().len(), 8);\n     assert_eq!(rbuf.filled(), [0; 8]);\n \n     rbuf.clear();\n \n-    rbuf.append(&[1; 16]);\n+    rbuf.unfilled().append(&[1; 16]);\n \n-    assert_eq!(rbuf.initialized_len(), 16);\n-    assert_eq!(rbuf.filled_len(), 16);\n+    assert_eq!(rbuf.init_len(), 16);\n+    assert_eq!(rbuf.filled().len(), 16);\n     assert_eq!(rbuf.filled(), [1; 16]);\n }\n \n #[test]\n-fn filled_mut() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n+fn reborrow_written() {\n+    let buf: &mut [_] = &mut [MaybeUninit::new(0); 32];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+\n+    let mut cursor = buf.unfilled();\n+    cursor.append(&[1; 16]);\n+\n+    let mut cursor2 = cursor.reborrow();\n+    cursor2.append(&[2; 16]);\n+\n+    assert_eq!(cursor2.written(), 32);\n+    assert_eq!(cursor.written(), 32);\n+\n+    assert_eq!(buf.unfilled().written(), 0);\n+    assert_eq!(buf.init_len(), 32);\n+    assert_eq!(buf.filled().len(), 32);\n+    let filled = buf.filled();\n+    assert_eq!(&filled[..16], [1; 16]);\n+    assert_eq!(&filled[16..], [2; 16]);\n+}\n+\n+#[test]\n+fn cursor_set_init() {\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n+\n+    unsafe {\n+        rbuf.unfilled().set_init(8);\n+    }\n \n-    rbuf.add_filled(8);\n+    assert_eq!(rbuf.init_len(), 8);\n+    assert_eq!(rbuf.unfilled().init_ref().len(), 8);\n+    assert_eq!(rbuf.unfilled().init_mut().len(), 8);\n+    assert_eq!(rbuf.unfilled().uninit_mut().len(), 8);\n+    assert_eq!(unsafe { rbuf.unfilled().as_mut() }.len(), 16);\n+\n+    unsafe {\n+        rbuf.unfilled().advance(4);\n+    }\n \n-    let filled = rbuf.filled().to_vec();\n+    unsafe {\n+        rbuf.unfilled().set_init(2);\n+    }\n+\n+    assert_eq!(rbuf.init_len(), 8);\n+\n+    unsafe {\n+        rbuf.unfilled().set_init(8);\n+    }\n \n-    assert_eq!(&*filled, &*rbuf.filled_mut());\n+    assert_eq!(rbuf.init_len(), 12);\n+    assert_eq!(rbuf.unfilled().init_ref().len(), 8);\n+    assert_eq!(rbuf.unfilled().init_mut().len(), 8);\n+    assert_eq!(rbuf.unfilled().uninit_mut().len(), 4);\n+    assert_eq!(unsafe { rbuf.unfilled().as_mut() }.len(), 12);\n }"}, {"sha": "f4a886d889a99a1b655b444bfbfacde2ae904733", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -1,4 +1,4 @@\n-use super::{repeat, Cursor, ReadBuf, SeekFrom};\n+use super::{repeat, BorrowedBuf, Cursor, SeekFrom};\n use crate::cmp::{self, min};\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::io::{BufRead, BufReader, Read, Seek, Write};\n@@ -159,24 +159,24 @@ fn read_exact_slice() {\n \n #[test]\n fn read_buf_exact() {\n-    let mut buf = [0; 4];\n-    let mut buf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [0; 4];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n     let mut c = Cursor::new(&b\"\"[..]);\n-    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    assert_eq!(c.read_buf_exact(buf.unfilled()).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n     let mut c = Cursor::new(&b\"123456789\"[..]);\n-    c.read_buf_exact(&mut buf).unwrap();\n+    c.read_buf_exact(buf.unfilled()).unwrap();\n     assert_eq!(buf.filled(), b\"1234\");\n \n     buf.clear();\n \n-    c.read_buf_exact(&mut buf).unwrap();\n+    c.read_buf_exact(buf.unfilled()).unwrap();\n     assert_eq!(buf.filled(), b\"5678\");\n \n     buf.clear();\n \n-    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    assert_eq!(c.read_buf_exact(buf.unfilled()).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n }\n \n #[test]\n@@ -615,10 +615,10 @@ fn bench_take_read(b: &mut test::Bencher) {\n #[bench]\n fn bench_take_read_buf(b: &mut test::Bencher) {\n     b.iter(|| {\n-        let mut buf = [MaybeUninit::uninit(); 64];\n+        let buf: &mut [_] = &mut [MaybeUninit::uninit(); 64];\n \n-        let mut rbuf = ReadBuf::uninit(&mut buf);\n+        let mut buf: BorrowedBuf<'_> = buf.into();\n \n-        [255; 128].take(64).read_buf(&mut rbuf).unwrap();\n+        [255; 128].take(64).read_buf(buf.unfilled()).unwrap();\n     });\n }"}, {"sha": "f076ee0923c80ff0d675e0a5df9e3d5573940e58", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -5,7 +5,7 @@ mod tests;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, Write,\n+    self, BorrowedCursor, BufRead, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n };\n \n /// A reader which is always at EOF.\n@@ -47,7 +47,7 @@ impl Read for Empty {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, _buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -130,21 +130,19 @@ impl Read for Repeat {\n         Ok(buf.len())\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n         // SAFETY: No uninit bytes are being written\n-        for slot in unsafe { buf.unfilled_mut() } {\n+        for slot in unsafe { buf.as_mut() } {\n             slot.write(self.byte);\n         }\n \n-        let remaining = buf.remaining();\n+        let remaining = buf.capacity();\n \n         // SAFETY: the entire unfilled portion of buf has been initialized\n         unsafe {\n-            buf.assume_init(remaining);\n+            buf.advance(remaining);\n         }\n \n-        buf.add_filled(remaining);\n-\n         Ok(())\n     }\n "}, {"sha": "ce5e2c9da1dbf15694197e6fc161152a52a92f16", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp::{max, min};\n use crate::io::prelude::*;\n use crate::io::{\n-    copy, empty, repeat, sink, BufWriter, Empty, ReadBuf, Repeat, Result, SeekFrom, Sink,\n+    copy, empty, repeat, sink, BorrowedBuf, BufWriter, Empty, Repeat, Result, SeekFrom, Sink,\n     DEFAULT_BUF_SIZE,\n };\n \n@@ -79,29 +79,29 @@ fn empty_reads() {\n     assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n     assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n \n-    let mut buf = [];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit()];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit(); 1024];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit(); 1024];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.by_ref().read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n+    let buf: &mut [MaybeUninit<_>] = &mut [];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit()];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1024];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1024];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.by_ref().read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n }\n \n #[test]"}, {"sha": "1c5efa94bd36ac50fed582ff2fee5da2a7cd23c0", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -2,7 +2,7 @@ use crate::ffi::{CStr, CString, OsString};\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::io::{self, Error, ErrorKind};\n-use crate::io::{IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n use crate::sys::cvt;\n@@ -312,8 +312,8 @@ impl File {\n         false\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        crate::io::default_read_buf(|buf| self.read(buf), buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        crate::io::default_read_buf(|buf| self.read(buf), cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "9692222534eaa2a43bbd2ec5870e804949b68064", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -2,7 +2,7 @@ use super::{abi, error};\n use crate::{\n     ffi::{CStr, CString, OsStr, OsString},\n     fmt,\n-    io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom},\n+    io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom},\n     mem::MaybeUninit,\n     os::raw::{c_int, c_short},\n     os::solid::ffi::OsStrExt,\n@@ -366,13 +366,13 @@ impl File {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         unsafe {\n-            let len = buf.remaining();\n+            let len = cursor.capacity();\n             let mut out_num_bytes = MaybeUninit::uninit();\n             error::SolidError::err_if_negative(abi::SOLID_FS_Read(\n                 self.fd.raw(),\n-                buf.unfilled_mut().as_mut_ptr() as *mut u8,\n+                cursor.as_mut().as_mut_ptr() as *mut u8,\n                 len,\n                 out_num_bytes.as_mut_ptr(),\n             ))\n@@ -384,9 +384,7 @@ impl File {\n \n             // Safety: `num_bytes_read` bytes were written to the unfilled\n             // portion of the buffer\n-            buf.assume_init(num_bytes_read);\n-\n-            buf.add_filled(num_bytes_read);\n+            cursor.advance(num_bytes_read);\n \n             Ok(())\n         }"}, {"sha": "dbaa3c33e2e577f13afb6c98181648bef6e7cf54", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -4,7 +4,7 @@\n mod tests;\n \n use crate::cmp;\n-use crate::io::{self, IoSlice, IoSliceMut, Read, ReadBuf};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read};\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -131,20 +131,19 @@ impl FileDesc {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         let ret = cvt(unsafe {\n             libc::read(\n                 self.as_raw_fd(),\n-                buf.unfilled_mut().as_mut_ptr() as *mut libc::c_void,\n-                cmp::min(buf.remaining(), READ_LIMIT),\n+                cursor.as_mut().as_mut_ptr() as *mut libc::c_void,\n+                cmp::min(cursor.capacity(), READ_LIMIT),\n             )\n         })?;\n \n         // Safety: `ret` bytes were written to the initialized portion of the buffer\n         unsafe {\n-            buf.assume_init(ret as usize);\n+            cursor.advance(ret as usize);\n         }\n-        buf.add_filled(ret as usize);\n         Ok(())\n     }\n "}, {"sha": "cc347e3586ae337fdcd6d45592f39f1e261e17c8", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -2,7 +2,7 @@ use crate::os::unix::prelude::*;\n \n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n@@ -1037,8 +1037,8 @@ impl File {\n         self.0.read_at(buf, offset)\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.0.read_buf(buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "6ac1b5d2bcfcaf6e6db9e7e678db2e476deb7a0c", "filename": "library/std/src/sys/unsupported/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n@@ -214,7 +214,7 @@ impl File {\n         self.0\n     }\n \n-    pub fn read_buf(&self, _buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         self.0\n     }\n "}, {"sha": "510cf36b1bf48efca38f05d122e59ecf2bc8d456", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -3,7 +3,7 @@\n use super::fd::WasiFd;\n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::iter;\n use crate::mem::{self, ManuallyDrop};\n use crate::os::raw::c_int;\n@@ -439,8 +439,8 @@ impl File {\n         true\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        crate::io::default_read_buf(|buf| self.read(buf), buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        crate::io::default_read_buf(|buf| self.read(buf), cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "9653b1abfc3d88a4bb43ab37385ec5fd7e4da3ee", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -2,7 +2,7 @@ use crate::os::windows::prelude::*;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, Error, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::os::windows::io::{AsHandle, BorrowedHandle};\n use crate::path::{Path, PathBuf};\n@@ -415,8 +415,8 @@ impl File {\n         self.handle.read_at(buf, offset)\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.handle.read_buf(buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.handle.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "ae33d48c612eeb9460144cccd6f13b5fb56035c9", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9306c231a9ffaf83d420ec09f165f58444d142e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=b9306c231a9ffaf83d420ec09f165f58444d142e", "patch": "@@ -4,7 +4,7 @@\n mod tests;\n \n use crate::cmp;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf};\n+use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::os::windows::io::{\n     AsHandle, AsRawHandle, BorrowedHandle, FromRawHandle, IntoRawHandle, OwnedHandle, RawHandle,\n@@ -112,18 +112,16 @@ impl Handle {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let res = unsafe {\n-            self.synchronous_read(buf.unfilled_mut().as_mut_ptr(), buf.remaining(), None)\n-        };\n+    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        let res =\n+            unsafe { self.synchronous_read(cursor.as_mut().as_mut_ptr(), cursor.capacity(), None) };\n \n         match res {\n             Ok(read) => {\n                 // Safety: `read` bytes were written to the initialized portion of the buffer\n                 unsafe {\n-                    buf.assume_init(read as usize);\n+                    cursor.advance(read as usize);\n                 }\n-                buf.add_filled(read as usize);\n                 Ok(())\n             }\n "}]}