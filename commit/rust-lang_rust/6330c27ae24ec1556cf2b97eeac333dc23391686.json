{"sha": "6330c27ae24ec1556cf2b97eeac333dc23391686", "node_id": "C_kwDOAAsO6NoAKDYzMzBjMjdhZTI0ZWMxNTU2Y2YyYjk3ZWVhYzMzM2RjMjMzOTE2ODY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T13:47:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T13:47:37Z"}, "message": "Auto merge of #103962 - matthiaskrgr:rollup-9av8i6k, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103680 (CStr: add some doc links)\n - #103780 (Fix late-bound lifetime closure ICEs in HIR typeck and MIR borrowck)\n - #103845 (Add track_caller to some Lock methods)\n - #103935 (Remove rustdoc clean::Visibility type)\n - #103941 (Fixed typos)\n - #103950 (Fix ICE when negative impl is collected during eager mono)\n - #103953 (Remove unused argument from `throw_unresolved_import_error`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "34c67e4f7d04b0aa0ef23b9c9a6dcb2ab947e3b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34c67e4f7d04b0aa0ef23b9c9a6dcb2ab947e3b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6330c27ae24ec1556cf2b97eeac333dc23391686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6330c27ae24ec1556cf2b97eeac333dc23391686", "html_url": "https://github.com/rust-lang/rust/commit/6330c27ae24ec1556cf2b97eeac333dc23391686", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6330c27ae24ec1556cf2b97eeac333dc23391686/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47c008e440e59d793c2883f7dd712481dc965045", "url": "https://api.github.com/repos/rust-lang/rust/commits/47c008e440e59d793c2883f7dd712481dc965045", "html_url": "https://github.com/rust-lang/rust/commit/47c008e440e59d793c2883f7dd712481dc965045"}, {"sha": "1edd63f1e78a50906e6709b146ca0ce2dc5b9e96", "url": "https://api.github.com/repos/rust-lang/rust/commits/1edd63f1e78a50906e6709b146ca0ce2dc5b9e96", "html_url": "https://github.com/rust-lang/rust/commit/1edd63f1e78a50906e6709b146ca0ce2dc5b9e96"}], "stats": {"total": 547, "additions": 334, "deletions": 213}, "files": [{"sha": "0e7f243bcf36ced6c9a1889d797b98839f0d8a8a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -2314,7 +2314,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             tcx,\n             closure_substs,\n             self.num_external_vids,\n-            tcx.typeck_root_def_id(closure_def_id),\n+            closure_def_id.expect_local(),\n         );\n         debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n "}, {"sha": "618da9e3253252886807c2413eb32a57a5d55af4", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -22,7 +22,9 @@ use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n+};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use std::iter;\n \n@@ -241,15 +243,15 @@ impl<'tcx> UniversalRegions<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         closure_substs: SubstsRef<'tcx>,\n         expected_num_vars: usize,\n-        typeck_root_def_id: DefId,\n+        closure_def_id: LocalDefId,\n     ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n         let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n         region_mapping.push(tcx.lifetimes.re_static);\n         tcx.for_each_free_region(&closure_substs, |fr| {\n             region_mapping.push(fr);\n         });\n \n-        for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n+        for_each_late_bound_region_in_recursive_scope(tcx, tcx.local_parent(closure_def_id), |r| {\n             region_mapping.push(r);\n         });\n \n@@ -339,9 +341,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // tests, and the resulting print-outs include def-ids\n                 // and other things that are not stable across tests!\n                 // So we just include the region-vid. Annoying.\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-                for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r),));\n+                for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n+                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::Generator(def_id, substs, _) => {\n@@ -354,9 +355,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // FIXME: As above, we'd like to print out the region\n                 // `r` but doing so is not stable across architectures\n                 // and so forth.\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-                for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r),));\n+                for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n+                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::FnDef(def_id, substs) => {\n@@ -421,13 +421,24 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             first_extern_index\n         } else {\n             // If this is a closure, generator, or inline-const, then the late-bound regions from the enclosing\n-            // function are actually external regions to us. For example, here, 'a is not local\n+            // function/closures are actually external regions to us. For example, here, 'a is not local\n             // to the closure c (although it is local to the fn foo):\n             // fn foo<'a>() {\n             //     let c = || { let x: &'a u32 = ...; }\n             // }\n-            self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n+            for_each_late_bound_region_in_recursive_scope(\n+                self.infcx.tcx,\n+                self.infcx.tcx.local_parent(self.mir_def.did),\n+                |r| {\n+                    debug!(?r);\n+                    if !indices.indices.contains_key(&r) {\n+                        let region_vid = self.infcx.next_nll_region_var(FR);\n+                        debug!(?region_vid);\n+                        indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                    }\n+                },\n+            );\n+\n             // Any regions created during the execution of `defining_ty` or during the above\n             // late-bound region replacement are all considered 'extern' regions\n             self.infcx.num_region_vars()\n@@ -444,12 +455,16 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             bound_inputs_and_output,\n             &mut indices,\n         );\n-        // Converse of above, if this is a function then the late-bound regions declared on its\n-        // signature are local to the fn.\n-        if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-            self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n-        }\n+        // Converse of above, if this is a function/closure then the late-bound regions declared on its\n+        // signature are local.\n+        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let region_vid = self.infcx.next_nll_region_var(FR);\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n \n         let (unnormalized_output_ty, mut unnormalized_input_tys) =\n             inputs_and_output.split_last().unwrap();\n@@ -692,7 +707,13 @@ trait InferCtxtExt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>;\n \n-    fn replace_late_bound_regions_with_nll_infer_vars(\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    );\n+\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_item(\n         &self,\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n@@ -746,13 +767,28 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n     #[instrument(skip(self, indices))]\n-    fn replace_late_bound_regions_with_nll_infer_vars(\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    ) {\n+        for_each_late_bound_region_in_recursive_scope(self.tcx, mir_def_id, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let region_vid = self.next_nll_region_var(FR);\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n+    }\n+\n+    #[instrument(skip(self, indices))]\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_item(\n         &self,\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n-        let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n-        for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n+        for_each_late_bound_region_in_item(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n@@ -803,21 +839,44 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n }\n \n-/// Iterates over the late-bound regions defined on fn_def_id and\n-/// invokes `f` with the liberated form of each one.\n-fn for_each_late_bound_region_defined_on<'tcx>(\n+/// Iterates over the late-bound regions defined on `mir_def_id` and all of its\n+/// parents, up to the typeck root, and invokes `f` with the liberated form\n+/// of each one.\n+fn for_each_late_bound_region_in_recursive_scope<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    fn_def_id: DefId,\n+    mut mir_def_id: LocalDefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n-        for &region_def_id in late_bounds.iter() {\n-            let name = tcx.item_name(region_def_id.to_def_id());\n-            let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: fn_def_id,\n-                bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n-            }));\n-            f(liberated_region);\n+    let typeck_root_def_id = tcx.typeck_root_def_id(mir_def_id.to_def_id());\n+\n+    // Walk up the tree, collecting late-bound regions until we hit the typeck root\n+    loop {\n+        for_each_late_bound_region_in_item(tcx, mir_def_id, &mut f);\n+\n+        if mir_def_id.to_def_id() == typeck_root_def_id {\n+            break;\n+        } else {\n+            mir_def_id = tcx.local_parent(mir_def_id);\n         }\n     }\n }\n+\n+/// Iterates over the late-bound regions defined on `mir_def_id` and all of its\n+/// parents, up to the typeck root, and invokes `f` with the liberated form\n+/// of each one.\n+fn for_each_late_bound_region_in_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mir_def_id: LocalDefId,\n+    mut f: impl FnMut(ty::Region<'tcx>),\n+) {\n+    if !tcx.def_kind(mir_def_id).is_fn_like() {\n+        return;\n+    }\n+\n+    for bound_var in tcx.late_bound_vars(tcx.hir().local_def_id_to_hir_id(mir_def_id)) {\n+        let ty::BoundVariableKind::Region(bound_region) = bound_var else { continue; };\n+        let liberated_region = tcx\n+            .mk_region(ty::ReFree(ty::FreeRegion { scope: mir_def_id.to_def_id(), bound_region }));\n+        f(liberated_region);\n+    }\n+}"}, {"sha": "c550f246e094aa77358d0010610e108226caf5af", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -410,6 +410,7 @@ impl<T> Lock<T> {\n \n     #[cfg(parallel_compiler)]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn lock(&self) -> LockGuard<'_, T> {\n         if ERROR_CHECKING {\n             self.0.try_lock().expect(\"lock was already held\")\n@@ -420,21 +421,25 @@ impl<T> Lock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn lock(&self) -> LockGuard<'_, T> {\n         self.0.borrow_mut()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n         f(&mut *self.lock())\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow(&self) -> LockGuard<'_, T> {\n         self.lock()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> LockGuard<'_, T> {\n         self.lock()\n     }\n@@ -476,6 +481,7 @@ impl<T> RwLock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn read(&self) -> ReadGuard<'_, T> {\n         self.0.borrow()\n     }\n@@ -491,6 +497,7 @@ impl<T> RwLock<T> {\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n         f(&*self.read())\n     }\n@@ -509,6 +516,7 @@ impl<T> RwLock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn write(&self) -> WriteGuard<'_, T> {\n         self.0.borrow_mut()\n     }\n@@ -524,16 +532,19 @@ impl<T> RwLock<T> {\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n         f(&mut *self.write())\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow(&self) -> ReadGuard<'_, T> {\n         self.read()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> WriteGuard<'_, T> {\n         self.write()\n     }"}, {"sha": "3d07f3fbc674dbb3d32ba541a95cf0c5c0309698", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -1377,11 +1377,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n-                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                    | Node::TraitItem(&hir::TraitItem {\n+                    Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    | Node::TraitItem(hir::TraitItem {\n                         kind: hir::TraitItemKind::Fn(..), ..\n                     })\n-                    | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n+                    | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. })\n+                    | Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope.to_def_id(), def.id().unwrap());\n                     }"}, {"sha": "58ddb807059ae37fb3313d7953b68241522ea0c8", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -1336,6 +1336,10 @@ fn create_mono_items_for_default_impls<'tcx>(\n ) {\n     match item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n+            if matches!(impl_.polarity, hir::ImplPolarity::Negative(_)) {\n+                return;\n+            }\n+\n             for param in impl_.generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}"}, {"sha": "4c899a5ff2d7eea409ce980dd2d9e4c77beac438", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 {\n                     // In the case of a new import line, throw a diagnostic message\n                     // for the previous line.\n-                    self.throw_unresolved_import_error(errors, None);\n+                    self.throw_unresolved_import_error(errors);\n                     errors = vec![];\n                 }\n                 if seen_spans.insert(err.span) {\n@@ -505,29 +505,21 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         if !errors.is_empty() {\n-            self.throw_unresolved_import_error(errors, None);\n+            self.throw_unresolved_import_error(errors);\n         }\n     }\n \n-    fn throw_unresolved_import_error(\n-        &self,\n-        errors: Vec<(String, UnresolvedImportError)>,\n-        span: Option<MultiSpan>,\n-    ) {\n+    fn throw_unresolved_import_error(&self, errors: Vec<(String, UnresolvedImportError)>) {\n+        if errors.is_empty() {\n+            return;\n+        }\n+\n         /// Upper limit on the number of `span_label` messages.\n         const MAX_LABEL_COUNT: usize = 10;\n \n-        let (span, msg) = if errors.is_empty() {\n-            (span.unwrap(), \"unresolved import\".to_string())\n-        } else {\n-            let span = MultiSpan::from_spans(errors.iter().map(|(_, err)| err.span).collect());\n-\n-            let paths = errors.iter().map(|(path, _)| format!(\"`{}`\", path)).collect::<Vec<_>>();\n-\n-            let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n-\n-            (span, msg)\n-        };\n+        let span = MultiSpan::from_spans(errors.iter().map(|(_, err)| err.span).collect());\n+        let paths = errors.iter().map(|(path, _)| format!(\"`{}`\", path)).collect::<Vec<_>>();\n+        let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n         let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n "}, {"sha": "834c8f58cb2a97f4f94d54c8de1ac112bc62e92e", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -2588,7 +2588,7 @@ impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         let (this, spare, len) = unsafe { self.split_at_spare_mut_with_len() };\n \n         // SAFETY:\n-        // - caller guaratees that src is a valid index\n+        // - caller guarantees that src is a valid index\n         let to_clone = unsafe { this.get_unchecked(src) };\n \n         iter::zip(to_clone, spare)\n@@ -2607,7 +2607,7 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n             let (init, spare) = self.split_at_spare_mut();\n \n             // SAFETY:\n-            // - caller guaratees that `src` is a valid index\n+            // - caller guarantees that `src` is a valid index\n             let source = unsafe { init.get_unchecked(src) };\n \n             // SAFETY:"}, {"sha": "15dd9ea7e803657d9122f63c95fd2db806b1fb04", "filename": "library/core/src/ffi/c_str.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -13,9 +13,9 @@ use crate::str;\n /// array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n /// slice, or unsafely from a raw `*const c_char`. It can then be\n /// converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or\n-/// into an owned `CString`.\n+/// into an owned [`CString`].\n ///\n-/// `&CStr` is to `CString` as <code>&[str]</code> is to `String`: the former\n+/// `&CStr` is to [`CString`] as <code>&[str]</code> is to [`String`]: the former\n /// in each pair are borrowed references; the latter are owned\n /// strings.\n ///\n@@ -24,6 +24,9 @@ use crate::str;\n /// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n /// a safe interface to other consumers.\n ///\n+/// [`CString`]: ../../std/ffi/struct.CString.html\n+/// [`String`]: ../../std/string/struct.String.html\n+///\n /// # Examples\n ///\n /// Inspecting a foreign C string:"}, {"sha": "841c4f9d530051526ab9a2a885f08b27cf19d38e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -19,8 +19,7 @@ use rustc_span::symbol::{kw, sym, Symbol};\n use crate::clean::{\n     self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_assoc_item,\n     clean_middle_field, clean_middle_ty, clean_trait_ref_with_bindings, clean_ty,\n-    clean_ty_generics, clean_variant_def, clean_visibility, utils, Attributes, AttributesExt,\n-    ImplKind, ItemId, Type,\n+    clean_ty_generics, clean_variant_def, utils, Attributes, AttributesExt, ImplKind, ItemId, Type,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -654,7 +653,7 @@ fn build_macro(\n     match CStore::from_tcx(cx.tcx).load_macro_untracked(def_id, cx.sess()) {\n         LoadedMacro::MacroDef(item_def, _) => {\n             if let ast::ItemKind::MacroDef(ref def) = item_def.kind {\n-                let vis = clean_visibility(cx.tcx.visibility(import_def_id.unwrap_or(def_id)));\n+                let vis = cx.tcx.visibility(import_def_id.unwrap_or(def_id));\n                 clean::MacroItem(clean::Macro {\n                     source: utils::display_macro_source(cx, name, def, def_id, vis),\n                 })"}, {"sha": "8d38f2df0d85c7f8f06c0ccc2acba3d1dc4d3121", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -1799,13 +1799,6 @@ pub(crate) fn clean_field_with_def_id(\n     Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx)\n }\n \n-pub(crate) fn clean_visibility(vis: ty::Visibility<DefId>) -> Visibility {\n-    match vis {\n-        ty::Visibility::Public => Visibility::Public,\n-        ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n-    }\n-}\n-\n pub(crate) fn clean_variant_def<'tcx>(variant: &ty::VariantDef, cx: &mut DocContext<'tcx>) -> Item {\n     let kind = match variant.ctor_kind {\n         CtorKind::Const => Variant::CLike(match variant.discr {\n@@ -1962,7 +1955,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n             }\n             ItemKind::Macro(ref macro_def, _) => {\n-                let ty_vis = clean_visibility(cx.tcx.visibility(def_id));\n+                let ty_vis = cx.tcx.visibility(def_id);\n                 MacroItem(Macro {\n                     source: display_macro_source(cx, name, macro_def, def_id, ty_vis),\n                 })"}, {"sha": "fea3690e50a2149b79f49186b174b02bbc027455", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -24,7 +24,7 @@ use rustc_hir::{BodyId, Mutability};\n use rustc_hir_analysis::check::intrinsic::intrinsic_operation_unsafety;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt, Visibility};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n@@ -34,7 +34,6 @@ use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::cfg::Cfg;\n-use crate::clean::clean_visibility;\n use crate::clean::external_path;\n use crate::clean::inline::{self, print_inlined_const};\n use crate::clean::utils::{is_literal_expr, print_const_expr, print_evaluated_const};\n@@ -51,7 +50,6 @@ pub(crate) use self::Type::{\n     Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive, QPath,\n     RawPointer, Slice, Tuple,\n };\n-pub(crate) use self::Visibility::{Inherited, Public};\n \n #[cfg(test)]\n mod tests;\n@@ -703,26 +701,28 @@ impl Item {\n         Some(header)\n     }\n \n-    pub(crate) fn visibility(&self, tcx: TyCtxt<'_>) -> Visibility {\n+    /// Returns the visibility of the current item. If the visibility is \"inherited\", then `None`\n+    /// is returned.\n+    pub(crate) fn visibility(&self, tcx: TyCtxt<'_>) -> Option<Visibility<DefId>> {\n         let def_id = match self.item_id {\n             // Anything but DefId *shouldn't* matter, but return a reasonable value anyway.\n-            ItemId::Auto { .. } | ItemId::Blanket { .. } => return Visibility::Inherited,\n+            ItemId::Auto { .. } | ItemId::Blanket { .. } => return None,\n             // Primitives and Keywords are written in the source code as private modules.\n             // The modules need to be private so that nobody actually uses them, but the\n             // keywords and primitives that they are documenting are public.\n-            ItemId::Primitive(..) => return Visibility::Public,\n+            ItemId::Primitive(..) => return Some(Visibility::Public),\n             ItemId::DefId(def_id) => def_id,\n         };\n \n         match *self.kind {\n             // Explication on `ItemId::Primitive` just above.\n-            ItemKind::KeywordItem | ItemKind::PrimitiveItem(_) => return Visibility::Public,\n+            ItemKind::KeywordItem | ItemKind::PrimitiveItem(_) => return Some(Visibility::Public),\n             // Variant fields inherit their enum's visibility.\n             StructFieldItem(..) if is_field_vis_inherited(tcx, def_id) => {\n-                return Visibility::Inherited;\n+                return None;\n             }\n             // Variants always inherit visibility\n-            VariantItem(..) => return Visibility::Inherited,\n+            VariantItem(..) => return None,\n             // Trait items inherit the trait's visibility\n             AssocConstItem(..) | TyAssocConstItem(..) | AssocTypeItem(..) | TyAssocTypeItem(..)\n             | TyMethodItem(..) | MethodItem(..) => {\n@@ -736,7 +736,7 @@ impl Item {\n                     }\n                 };\n                 if is_trait_item {\n-                    return Visibility::Inherited;\n+                    return None;\n                 }\n             }\n             _ => {}\n@@ -745,7 +745,7 @@ impl Item {\n             Some(inlined) => inlined,\n             None => def_id,\n         };\n-        clean_visibility(tcx.visibility(def_id))\n+        Some(tcx.visibility(def_id))\n     }\n }\n \n@@ -2075,24 +2075,6 @@ impl From<hir::PrimTy> for PrimitiveType {\n     }\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(crate) enum Visibility {\n-    /// `pub`\n-    Public,\n-    /// Visibility inherited from parent.\n-    ///\n-    /// For example, this is the visibility of private items and of enum variants.\n-    Inherited,\n-    /// `pub(crate)`, `pub(super)`, or `pub(in path::to::somewhere)`\n-    Restricted(DefId),\n-}\n-\n-impl Visibility {\n-    pub(crate) fn is_public(&self) -> bool {\n-        matches!(self, Visibility::Public)\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub(crate) struct Struct {\n     pub(crate) struct_type: CtorKind,"}, {"sha": "df20dc3fc3f7e995e2e42fbce662da3830859da5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -4,9 +4,10 @@ use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n     clean_doc_module, clean_middle_const, clean_middle_region, clean_middle_ty, inline, Crate,\n     ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path,\n-    PathSegment, Primitive, PrimitiveType, Type, TypeBinding, Visibility,\n+    PathSegment, Primitive, PrimitiveType, Type, TypeBinding,\n };\n use crate::core::DocContext;\n+use crate::html::format::visibility_to_src_with_space;\n \n use rustc_ast as ast;\n use rustc_ast::tokenstream::TokenTree;\n@@ -583,7 +584,7 @@ pub(super) fn display_macro_source(\n     name: Symbol,\n     def: &ast::MacroDef,\n     def_id: DefId,\n-    vis: Visibility,\n+    vis: ty::Visibility<DefId>,\n ) -> String {\n     let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n     // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n@@ -595,14 +596,14 @@ pub(super) fn display_macro_source(\n         if matchers.len() <= 1 {\n             format!(\n                 \"{}macro {}{} {{\\n    ...\\n}}\",\n-                vis.to_src_with_space(cx.tcx, def_id),\n+                visibility_to_src_with_space(Some(vis), cx.tcx, def_id),\n                 name,\n                 matchers.map(|matcher| render_macro_matcher(cx.tcx, matcher)).collect::<String>(),\n             )\n         } else {\n             format!(\n                 \"{}macro {} {{\\n{}}}\",\n-                vis.to_src_with_space(cx.tcx, def_id),\n+                visibility_to_src_with_space(Some(vis), cx.tcx, def_id),\n                 name,\n                 render_macro_arms(cx.tcx, matchers, \",\"),\n             )"}, {"sha": "06db3fb0ec4000794de001220a0feceffb0b390b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 74, "deletions": 77, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -1420,87 +1420,84 @@ impl clean::FnDecl {\n     }\n }\n \n-impl clean::Visibility {\n-    pub(crate) fn print_with_space<'a, 'tcx: 'a>(\n-        self,\n-        item_did: ItemId,\n-        cx: &'a Context<'tcx>,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        use std::fmt::Write as _;\n-\n-        let to_print: Cow<'static, str> = match self {\n-            clean::Public => \"pub \".into(),\n-            clean::Inherited => \"\".into(),\n-            clean::Visibility::Restricted(vis_did) => {\n-                // FIXME(camelid): This may not work correctly if `item_did` is a module.\n-                //                 However, rustdoc currently never displays a module's\n-                //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n-\n-                if vis_did.is_crate_root() {\n-                    \"pub(crate) \".into()\n-                } else if parent_module == Some(vis_did) {\n-                    // `pub(in foo)` where `foo` is the parent module\n-                    // is the same as no visibility modifier\n-                    \"\".into()\n-                } else if parent_module\n-                    .and_then(|parent| find_nearest_parent_module(cx.tcx(), parent))\n-                    == Some(vis_did)\n-                {\n-                    \"pub(super) \".into()\n-                } else {\n-                    let path = cx.tcx().def_path(vis_did);\n-                    debug!(\"path={:?}\", path);\n-                    // modified from `resolved_path()` to work with `DefPathData`\n-                    let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                    let anchor = anchor(vis_did, last_name, cx).to_string();\n-\n-                    let mut s = \"pub(in \".to_owned();\n-                    for seg in &path.data[..path.data.len() - 1] {\n-                        let _ = write!(s, \"{}::\", seg.data.get_opt_name().unwrap());\n-                    }\n-                    let _ = write!(s, \"{}) \", anchor);\n-                    s.into()\n+pub(crate) fn visibility_print_with_space<'a, 'tcx: 'a>(\n+    visibility: Option<ty::Visibility<DefId>>,\n+    item_did: ItemId,\n+    cx: &'a Context<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    use std::fmt::Write as _;\n+\n+    let to_print: Cow<'static, str> = match visibility {\n+        None => \"\".into(),\n+        Some(ty::Visibility::Public) => \"pub \".into(),\n+        Some(ty::Visibility::Restricted(vis_did)) => {\n+            // FIXME(camelid): This may not work correctly if `item_did` is a module.\n+            //                 However, rustdoc currently never displays a module's\n+            //                 visibility, so it shouldn't matter.\n+            let parent_module = find_nearest_parent_module(cx.tcx(), item_did.expect_def_id());\n+\n+            if vis_did.is_crate_root() {\n+                \"pub(crate) \".into()\n+            } else if parent_module == Some(vis_did) {\n+                // `pub(in foo)` where `foo` is the parent module\n+                // is the same as no visibility modifier\n+                \"\".into()\n+            } else if parent_module.and_then(|parent| find_nearest_parent_module(cx.tcx(), parent))\n+                == Some(vis_did)\n+            {\n+                \"pub(super) \".into()\n+            } else {\n+                let path = cx.tcx().def_path(vis_did);\n+                debug!(\"path={:?}\", path);\n+                // modified from `resolved_path()` to work with `DefPathData`\n+                let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n+                let anchor = anchor(vis_did, last_name, cx).to_string();\n+\n+                let mut s = \"pub(in \".to_owned();\n+                for seg in &path.data[..path.data.len() - 1] {\n+                    let _ = write!(s, \"{}::\", seg.data.get_opt_name().unwrap());\n                 }\n+                let _ = write!(s, \"{}) \", anchor);\n+                s.into()\n             }\n-        };\n-        display_fn(move |f| write!(f, \"{}\", to_print))\n-    }\n+        }\n+    };\n+    display_fn(move |f| write!(f, \"{}\", to_print))\n+}\n \n-    /// This function is the same as print_with_space, except that it renders no links.\n-    /// It's used for macros' rendered source view, which is syntax highlighted and cannot have\n-    /// any HTML in it.\n-    pub(crate) fn to_src_with_space<'a, 'tcx: 'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        item_did: DefId,\n-    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-        let to_print = match self {\n-            clean::Public => \"pub \".to_owned(),\n-            clean::Inherited => String::new(),\n-            clean::Visibility::Restricted(vis_did) => {\n-                // FIXME(camelid): This may not work correctly if `item_did` is a module.\n-                //                 However, rustdoc currently never displays a module's\n-                //                 visibility, so it shouldn't matter.\n-                let parent_module = find_nearest_parent_module(tcx, item_did);\n-\n-                if vis_did.is_crate_root() {\n-                    \"pub(crate) \".to_owned()\n-                } else if parent_module == Some(vis_did) {\n-                    // `pub(in foo)` where `foo` is the parent module\n-                    // is the same as no visibility modifier\n-                    String::new()\n-                } else if parent_module.and_then(|parent| find_nearest_parent_module(tcx, parent))\n-                    == Some(vis_did)\n-                {\n-                    \"pub(super) \".to_owned()\n-                } else {\n-                    format!(\"pub(in {}) \", tcx.def_path_str(vis_did))\n-                }\n+/// This function is the same as print_with_space, except that it renders no links.\n+/// It's used for macros' rendered source view, which is syntax highlighted and cannot have\n+/// any HTML in it.\n+pub(crate) fn visibility_to_src_with_space<'a, 'tcx: 'a>(\n+    visibility: Option<ty::Visibility<DefId>>,\n+    tcx: TyCtxt<'tcx>,\n+    item_did: DefId,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    let to_print = match visibility {\n+        None => String::new(),\n+        Some(ty::Visibility::Public) => \"pub \".to_owned(),\n+        Some(ty::Visibility::Restricted(vis_did)) => {\n+            // FIXME(camelid): This may not work correctly if `item_did` is a module.\n+            //                 However, rustdoc currently never displays a module's\n+            //                 visibility, so it shouldn't matter.\n+            let parent_module = find_nearest_parent_module(tcx, item_did);\n+\n+            if vis_did.is_crate_root() {\n+                \"pub(crate) \".to_owned()\n+            } else if parent_module == Some(vis_did) {\n+                // `pub(in foo)` where `foo` is the parent module\n+                // is the same as no visibility modifier\n+                String::new()\n+            } else if parent_module.and_then(|parent| find_nearest_parent_module(tcx, parent))\n+                == Some(vis_did)\n+            {\n+                \"pub(super) \".to_owned()\n+            } else {\n+                format!(\"pub(in {}) \", tcx.def_path_str(vis_did))\n             }\n-        };\n-        display_fn(move |f| f.write_str(&to_print))\n-    }\n+        }\n+    };\n+    display_fn(move |f| f.write_str(&to_print))\n }\n \n pub(crate) trait PrintWithSpace {"}, {"sha": "3a041ae15d6185904cb8de0d4d9c2b7ed4ca26af", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -70,8 +70,8 @@ use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n-    print_default_space, print_generic_bounds, print_where_clause, Buffer, Ending, HrefError,\n-    PrintWithSpace,\n+    print_default_space, print_generic_bounds, print_where_clause, visibility_print_with_space,\n+    Buffer, Ending, HrefError, PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::markdown::{\n@@ -752,7 +752,7 @@ fn assoc_const(\n         w,\n         \"{extra}{vis}const <a{href} class=\\\"constant\\\">{name}</a>: {ty}\",\n         extra = extra,\n-        vis = it.visibility(tcx).print_with_space(it.item_id, cx),\n+        vis = visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n         href = assoc_href_attr(it, link, cx),\n         name = it.name.as_ref().unwrap(),\n         ty = ty.print(cx),\n@@ -809,7 +809,7 @@ fn assoc_method(\n     let tcx = cx.tcx();\n     let header = meth.fn_header(tcx).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n-    let vis = meth.visibility(tcx).print_with_space(meth.item_id, cx).to_string();\n+    let vis = visibility_print_with_space(meth.visibility(tcx), meth.item_id, cx).to_string();\n     // FIXME: Once https://github.com/rust-lang/rust/issues/67792 is implemented, we can remove\n     // this condition.\n     let constness = match render_mode {"}, {"sha": "3225ddabe2e75e429afca4a151df27411e46547d", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::stability;\n use rustc_middle::span_bug;\n use rustc_middle::ty::layout::LayoutError;\n-use rustc_middle::ty::{Adt, TyCtxt};\n+use rustc_middle::ty::{self, Adt, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::abi::{Layout, Primitive, TagEncoding, Variants};\n@@ -28,7 +28,7 @@ use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n     join_with_double_colon, print_abi_with_space, print_constness_with_space, print_where_clause,\n-    Buffer, Ending, PrintWithSpace,\n+    visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::layout::Page;\n@@ -328,14 +328,14 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                     Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n-                        myitem.visibility(tcx).print_with_space(myitem.item_id, cx),\n+                        visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), src, cx),\n                         myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n-                        myitem.visibility(tcx).print_with_space(myitem.item_id, cx),\n+                        visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                         anchor(myitem.item_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n@@ -385,7 +385,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                      </div>\\\n                      {stab_tags_before}{stab_tags}{stab_tags_after}\",\n                     stab = stab.unwrap_or_default(),\n-                    vis = myitem.visibility(tcx).print_with_space(myitem.item_id, cx),\n+                    vis = visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                     imp = import.print(cx),\n                 );\n                 w.write_str(ITEM_TABLE_ROW_CLOSE);\n@@ -410,7 +410,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 let add = if stab.is_some() { \" \" } else { \"\" };\n \n                 let visibility_emoji = match myitem.visibility(tcx) {\n-                    clean::Visibility::Restricted(_) => {\n+                    Some(ty::Visibility::Restricted(_)) => {\n                         \"<span title=\\\"Restricted Visibility\\\">&nbsp;\ud83d\udd12</span> \"\n                     }\n                     _ => \"\",\n@@ -503,7 +503,7 @@ fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &cle\n     let unsafety = header.unsafety.print_with_space();\n     let abi = print_abi_with_space(header.abi).to_string();\n     let asyncness = header.asyncness.print_with_space();\n-    let visibility = it.visibility(tcx).print_with_space(it.item_id, cx).to_string();\n+    let visibility = visibility_print_with_space(it.visibility(tcx), it.item_id, cx).to_string();\n     let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n@@ -561,7 +561,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             write!(\n                 w,\n                 \"{}{}{}trait {}{}{}\",\n-                it.visibility(tcx).print_with_space(it.item_id, cx),\n+                visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n                 t.unsafety(tcx).print_with_space(),\n                 if t.is_auto(tcx) { \"auto \" } else { \"\" },\n                 it.name.unwrap(),\n@@ -1086,7 +1086,7 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, \"typedef\", |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            write!(w, \"{}\", it.visibility(cx.tcx()).print_with_space(it.item_id, cx));\n+            write!(w, \"{}\", visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx));\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n@@ -1183,7 +1183,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             write!(\n                 w,\n                 \"{}enum {}{}\",\n-                it.visibility(tcx).print_with_space(it.item_id, cx),\n+                visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n                 it.name.unwrap(),\n                 e.generics.print(cx),\n             );\n@@ -1398,7 +1398,7 @@ fn item_constant(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, c: &cle\n             write!(\n                 w,\n                 \"{vis}const {name}: {typ}\",\n-                vis = it.visibility(tcx).print_with_space(it.item_id, cx),\n+                vis = visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n                 name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n@@ -1499,7 +1499,7 @@ fn item_static(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n             write!(\n                 w,\n                 \"{vis}static {mutability}{name}: {typ}\",\n-                vis = it.visibility(cx.tcx()).print_with_space(it.item_id, cx),\n+                vis = visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n                 mutability = s.mutability.print_with_space(),\n                 name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n@@ -1517,7 +1517,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {\n             write!(\n                 w,\n                 \"    {}type {};\\n}}\",\n-                it.visibility(cx.tcx()).print_with_space(it.item_id, cx),\n+                visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n                 it.name.unwrap(),\n             );\n         });\n@@ -1671,7 +1671,12 @@ fn render_union(\n     cx: &Context<'_>,\n ) {\n     let tcx = cx.tcx();\n-    write!(w, \"{}union {}\", it.visibility(tcx).print_with_space(it.item_id, cx), it.name.unwrap(),);\n+    write!(\n+        w,\n+        \"{}union {}\",\n+        visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n+        it.name.unwrap(),\n+    );\n \n     let where_displayed = g\n         .map(|g| {\n@@ -1698,7 +1703,7 @@ fn render_union(\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n-                field.visibility(tcx).print_with_space(field.item_id, cx),\n+                visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n                 field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n@@ -1729,7 +1734,7 @@ fn render_struct(\n     write!(\n         w,\n         \"{}{}{}\",\n-        it.visibility(tcx).print_with_space(it.item_id, cx),\n+        visibility_print_with_space(it.visibility(tcx), it.item_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n         it.name.unwrap()\n     );\n@@ -1759,7 +1764,7 @@ fn render_struct(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n-                        field.visibility(tcx).print_with_space(field.item_id, cx),\n+                        visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n                         field.name.unwrap(),\n                         ty.print(cx),\n                     );\n@@ -1791,7 +1796,7 @@ fn render_struct(\n                         write!(\n                             w,\n                             \"{}{}\",\n-                            field.visibility(tcx).print_with_space(field.item_id, cx),\n+                            visibility_print_with_space(field.visibility(tcx), field.item_id, cx),\n                             ty.print(cx),\n                         )\n                     }"}, {"sha": "cb8b7c18029f02e7812873f1fde215885d211428", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -100,13 +100,12 @@ impl JsonRenderer<'_> {\n         }\n     }\n \n-    fn convert_visibility(&self, v: clean::Visibility) -> Visibility {\n-        use clean::Visibility::*;\n+    fn convert_visibility(&self, v: Option<ty::Visibility<DefId>>) -> Visibility {\n         match v {\n-            Public => Visibility::Public,\n-            Inherited => Visibility::Default,\n-            Restricted(did) if did.is_crate_root() => Visibility::Crate,\n-            Restricted(did) => Visibility::Restricted {\n+            None => Visibility::Default,\n+            Some(ty::Visibility::Public) => Visibility::Public,\n+            Some(ty::Visibility::Restricted(did)) if did.is_crate_root() => Visibility::Crate,\n+            Some(ty::Visibility::Restricted(did)) => Visibility::Restricted {\n                 parent: from_item_id(did.into(), self.tcx),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },"}, {"sha": "995fb5dcc1c86de89b780320701190eb25c3790d", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -1,6 +1,6 @@\n //! A collection of utility functions for the `strip_*` passes.\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{TyCtxt, Visibility};\n use rustc_span::symbol::sym;\n use std::mem;\n \n@@ -81,13 +81,13 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n             }\n \n             clean::StructFieldItem(..) => {\n-                if !i.visibility(self.tcx).is_public() {\n+                if i.visibility(self.tcx) != Some(Visibility::Public) {\n                     return Some(strip_item(i));\n                 }\n             }\n \n             clean::ModuleItem(..) => {\n-                if i.item_id.is_local() && !i.visibility(self.tcx).is_public() {\n+                if i.item_id.is_local() && i.visibility(self.tcx) != Some(Visibility::Public) {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = strip_item(self.fold_item_recur(i));\n@@ -246,7 +246,7 @@ impl<'tcx> DocFolder for ImportStripper<'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match *i.kind {\n             clean::ExternCrateItem { .. } | clean::ImportItem(..)\n-                if !i.visibility(self.tcx).is_public() =>\n+                if i.visibility(self.tcx) != Some(Visibility::Public) =>\n             {\n                 None\n             }"}, {"sha": "bb5c7552fdaa8530d002e15c560b71f102538218", "filename": "src/test/ui/closures/binder/late-bound-in-body.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Flate-bound-in-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Flate-bound-in-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Flate-bound-in-body.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#![feature(closure_lifetime_binder)]\n+\n+fn main() {\n+    let _ = for<'a> || -> () {\n+        let _: &'a bool = &true;\n+    };\n+}"}, {"sha": "6bfc6c80b78822ad06ebea3ac9cb07a4fe60766d", "filename": "src/test/ui/closures/binder/nested-closures-regions.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures-regions.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+\n+#![feature(closure_lifetime_binder)]\n+#![feature(rustc_attrs)]\n+\n+#[rustc_regions]\n+fn main() {\n+    for<'a> || -> () { for<'c> |_: &'a ()| -> () {}; };\n+}"}, {"sha": "b385e0ed6e0a5a0fef103a79ee5818ab83257572", "filename": "src/test/ui/closures/binder/nested-closures-regions.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures-regions.stderr?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -0,0 +1,38 @@\n+note: external requirements\n+  --> $DIR/nested-closures-regions.rs:8:24\n+   |\n+LL |     for<'a> || -> () { for<'c> |_: &'a ()| -> () {}; };\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: main::{closure#0}::{closure#0} with closure substs [\n+               i8,\n+               extern \"rust-call\" fn((&(),)),\n+               (),\n+           ]\n+   = note: late-bound region is '_#4r\n+   = note: late-bound region is '_#2r\n+   = note: number of external vids: 3\n+   = note: where '_#1r: '_#2r\n+   = note: where '_#2r: '_#1r\n+\n+note: no external requirements\n+  --> $DIR/nested-closures-regions.rs:8:5\n+   |\n+LL |     for<'a> || -> () { for<'c> |_: &'a ()| -> () {}; };\n+   |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: defining type: main::{closure#0} with closure substs [\n+               i8,\n+               extern \"rust-call\" fn(()),\n+               (),\n+           ]\n+   = note: late-bound region is '_#2r\n+\n+note: no external requirements\n+  --> $DIR/nested-closures-regions.rs:7:1\n+   |\n+LL | fn main() {\n+   | ^^^^^^^^^\n+   |\n+   = note: defining type: main\n+"}, {"sha": "b3c36e7eebb7aa37ccd8963a501be6a961d2a5e1", "filename": "src/test/ui/closures/binder/nested-closures.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fbinder%2Fnested-closures.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+\n+#![feature(closure_lifetime_binder)]\n+\n+fn main() {\n+    for<'a> || -> () { for<'c> |_: &'a ()| -> () {}; };\n+}"}, {"sha": "ce770376c0b2fe1cf641154d28ecb3a0f9ca98a8", "filename": "src/test/ui/traits/negative-impls/eager-mono.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Feager-mono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330c27ae24ec1556cf2b97eeac333dc23391686/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Feager-mono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnegative-impls%2Feager-mono.rs?ref=6330c27ae24ec1556cf2b97eeac333dc23391686", "patch": "@@ -0,0 +1,12 @@\n+// build-pass\n+// compile-flags:-C link-dead-code=y\n+\n+#![feature(negative_impls)]\n+\n+trait Foo {\n+    fn foo() {}\n+}\n+\n+impl !Foo for () {}\n+\n+fn main() {}"}]}