{"sha": "ee4755afdbd8123333513931747d295021561b97", "node_id": "C_kwDOAAsO6NoAKGVlNDc1NWFmZGJkODEyMzMzMzUxMzkzMTc0N2QyOTUwMjE1NjFiOTc", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-10T01:11:30Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-10T01:11:30Z"}, "message": "Add more SIMD", "tree": {"sha": "6b605d0a05a32eb317cac1b0138553c1b26523d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b605d0a05a32eb317cac1b0138553c1b26523d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee4755afdbd8123333513931747d295021561b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee4755afdbd8123333513931747d295021561b97", "html_url": "https://github.com/rust-lang/rust/commit/ee4755afdbd8123333513931747d295021561b97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee4755afdbd8123333513931747d295021561b97/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba5845c520c3fe6558b7047097a89003284bf9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba5845c520c3fe6558b7047097a89003284bf9a", "html_url": "https://github.com/rust-lang/rust/commit/2ba5845c520c3fe6558b7047097a89003284bf9a"}], "stats": {"total": 32, "additions": 24, "deletions": 8}, "files": [{"sha": "5bbd29fceba2a8051e0d082b290d608997c38773", "filename": "Readme.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee4755afdbd8123333513931747d295021561b97/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/ee4755afdbd8123333513931747d295021561b97/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=ee4755afdbd8123333513931747d295021561b97", "patch": "@@ -127,6 +127,10 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n \n+### How to use [mem-trace](https://github.com/antoyo/mem-trace)\n+\n+`rustc` needs to be built without `jemalloc` so that `mem-trace` can overload `malloc` since `jemalloc` is linked statically, so a `LD_PRELOAD`-ed library won't a chance to intercept the calls to `malloc`.\n+\n ### How to build a cross-compiling libgccjit\n \n #### Building libgccjit"}, {"sha": "19c981309d759cdd4a61e2e6c7c857811952f064", "filename": "src/base.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee4755afdbd8123333513931747d295021561b97/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4755afdbd8123333513931747d295021561b97/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=ee4755afdbd8123333513931747d295021561b97", "patch": "@@ -81,11 +81,17 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol, supports_\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n         context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n-        context.add_command_line_option(\"-msha\");\n-        context.add_command_line_option(\"-mpclmul\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n+        /*context.add_command_line_option(\"-mavx512f\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        context.add_command_line_option(\"-mfma\");\n+        context.add_command_line_option(\"-mfma4\");\n+        context.add_command_line_option(\"-mavx512vpopcntdq\");\n+        context.add_command_line_option(\"-mavx512vl\");\n+        context.add_command_line_option(\"-m64\");\n+        context.add_command_line_option(\"-mbmi\");*/\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }"}, {"sha": "3804a958e6916b9db53fd890c443b5973ab6673e", "filename": "src/builder.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee4755afdbd8123333513931747d295021561b97/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4755afdbd8123333513931747d295021561b97/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=ee4755afdbd8123333513931747d295021561b97", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -1390,18 +1390,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let mask_element_type = self.type_ix(element_type.get_size() as u64 * 8);\n         let element_count = vector_type.get_num_units();\n         let mut vector_elements = vec![];\n         for i in 0..element_count {\n             vector_elements.push(i);\n         }\n-        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mask_type = self.context.new_vector_type(mask_element_type, element_count as u64);\n         let mut shift = 1;\n         let mut res = src;\n         while shift < element_count {\n             let vector_elements: Vec<_> =\n                 vector_elements.iter()\n-                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .map(|i| self.context.new_rvalue_from_int(mask_element_type, ((i + shift) % element_count) as i32))\n                     .collect();\n             let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n             let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);"}, {"sha": "f2faae070284ad731092707e56daa9f4f242f3c1", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ee4755afdbd8123333513931747d295021561b97/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4755afdbd8123333513931747d295021561b97/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=ee4755afdbd8123333513931747d295021561b97", "patch": "@@ -288,7 +288,10 @@ pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc,\n     match func_name {\n         \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n             let zero = builder.context.new_rvalue_zero(builder.int_type);\n-            return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            #[cfg(feature=\"master\")]\n+            {\n+                return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            }\n         },\n         \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n             // Both llvm.x86.addcarry.32 and llvm.x86.addcarryx.u32 points to the same GCC builtin,"}, {"sha": "8f9862414e60a97c2e91e419939f9c5edcab40f8", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ee4755afdbd8123333513931747d295021561b97/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee4755afdbd8123333513931747d295021561b97/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=ee4755afdbd8123333513931747d295021561b97", "patch": "@@ -216,7 +216,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n         bx.llbb().add_assignment(None, variable, vector);\n         let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n-        // TODO: si simd_insert est constant, utiliser BIT_REF\u2026\n+        // TODO: if simd_insert is constant, use BIT_REF.\n         bx.llbb().add_assignment(None, lvalue, value);\n         return Ok(variable.to_rvalue());\n     }\n@@ -252,6 +252,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n \n+    #[cfg(feature=\"master\")]\n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());"}]}