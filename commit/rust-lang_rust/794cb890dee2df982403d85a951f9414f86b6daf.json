{"sha": "794cb890dee2df982403d85a951f9414f86b6daf", "node_id": "C_kwDOAAsO6NoAKDc5NGNiODkwZGVlMmRmOTgyNDAzZDg1YTk1MWY5NDE0Zjg2YjZkYWY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-22T03:54:33Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-24T18:59:42Z"}, "message": "Consider polarity in new solver", "tree": {"sha": "0ba9e925e8c0e9d50ece5adcdf2d02d863c88cb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ba9e925e8c0e9d50ece5adcdf2d02d863c88cb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/794cb890dee2df982403d85a951f9414f86b6daf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/794cb890dee2df982403d85a951f9414f86b6daf", "html_url": "https://github.com/rust-lang/rust/commit/794cb890dee2df982403d85a951f9414f86b6daf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/794cb890dee2df982403d85a951f9414f86b6daf/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b72460fe46a873da0c40582636c26e7675e92288", "url": "https://api.github.com/repos/rust-lang/rust/commits/b72460fe46a873da0c40582636c26e7675e92288", "html_url": "https://github.com/rust-lang/rust/commit/b72460fe46a873da0c40582636c26e7675e92288"}], "stats": {"total": 77, "additions": 74, "deletions": 3}, "files": [{"sha": "8025697d6d1e0ffeee7a213659f7d9f8e91e9bbb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/794cb890dee2df982403d85a951f9414f86b6daf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794cb890dee2df982403d85a951f9414f86b6daf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=794cb890dee2df982403d85a951f9414f86b6daf", "patch": "@@ -861,6 +861,11 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn is_const_if_const(self) -> bool {\n         self.skip_binder().is_const_if_const()\n     }\n+\n+    #[inline]\n+    pub fn polarity(self) -> ImplPolarity {\n+        self.skip_binder().polarity\n+    }\n }\n \n /// `A: B`"}, {"sha": "c97473e6241f28dd3f9dc2db949b5200369bede6", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/794cb890dee2df982403d85a951f9414f86b6daf/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/794cb890dee2df982403d85a951f9414f86b6daf/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=794cb890dee2df982403d85a951f9414f86b6daf", "patch": "@@ -86,8 +86,9 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n+            && poly_trait_pred.polarity() == goal.predicate.polarity\n         {\n-            // FIXME: Constness and polarity\n+            // FIXME: Constness\n             ecx.probe(|ecx| {\n                 let assumption_trait_pred =\n                     ecx.instantiate_binder_with_infer(poly_trait_pred);\n@@ -111,6 +112,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n+            && poly_trait_pred.polarity() == goal.predicate.polarity\n         {\n             // FIXME: Constness and polarity\n             ecx.probe(|ecx| {\n@@ -147,6 +149,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if let Some(result) = ecx.disqualify_auto_trait_candidate_due_to_possible_impl(goal) {\n             return result;\n         }\n@@ -161,6 +167,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let tcx = ecx.tcx();\n \n         ecx.probe(|ecx| {\n@@ -176,6 +186,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         ecx.probe_and_evaluate_goal_for_constituent_tys(\n             goal,\n             structural_traits::instantiate_constituent_tys_for_sized_trait,\n@@ -186,6 +200,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         ecx.probe_and_evaluate_goal_for_constituent_tys(\n             goal,\n             structural_traits::instantiate_constituent_tys_for_copy_clone_trait,\n@@ -196,6 +214,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if goal.predicate.self_ty().has_non_region_infer() {\n             return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n@@ -217,6 +239,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if let ty::FnPtr(..) = goal.predicate.self_ty().kind() {\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n@@ -229,6 +255,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         goal: Goal<'tcx, Self>,\n         goal_kind: ty::ClosureKind,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let tcx = ecx.tcx();\n         let tupled_inputs_and_output =\n             match structural_traits::extract_tupled_inputs_and_output_from_callable(\n@@ -259,6 +289,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if let ty::Tuple(..) = goal.predicate.self_ty().kind() {\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         } else {\n@@ -268,15 +302,23 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n     fn consider_builtin_pointee_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n     fn consider_builtin_future_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let ty::Generator(def_id, _, _) = *goal.predicate.self_ty().kind() else {\n             return Err(NoSolution);\n         };\n@@ -297,6 +339,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let self_ty = goal.predicate.self_ty();\n         let ty::Generator(def_id, substs, _) = *self_ty.kind() else {\n             return Err(NoSolution);\n@@ -326,6 +372,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         let tcx = ecx.tcx();\n         let a_ty = goal.predicate.self_ty();\n         let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n@@ -447,6 +497,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> Vec<CanonicalResponse<'tcx>> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return vec![];\n+        }\n+\n         let tcx = ecx.tcx();\n \n         let a_ty = goal.predicate.self_ty();\n@@ -521,8 +575,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n \n     fn consider_builtin_discriminant_kind_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         // `DiscriminantKind` is automatically implemented for every type.\n         ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n@@ -531,6 +589,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         if !goal.param_env.is_const() {\n             // `Destruct` is automatically implemented for every type in\n             // non-const environments.\n@@ -545,6 +607,10 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n+        if goal.predicate.polarity != ty::ImplPolarity::Positive {\n+            return Err(NoSolution);\n+        }\n+\n         // `rustc_transmute` does not have support for type or const params\n         if goal.has_non_region_placeholders() {\n             return Err(NoSolution);"}]}