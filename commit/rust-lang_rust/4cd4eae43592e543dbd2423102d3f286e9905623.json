{"sha": "4cd4eae43592e543dbd2423102d3f286e9905623", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZDRlYWU0MzU5MmU1NDNkYmQyNDIzMTAyZDNmMjg2ZTk5MDU2MjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-07T13:46:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-04T15:02:40Z"}, "message": "rename skolemized to placeholder", "tree": {"sha": "e7db56768066c15617f026cf8d5b473e3623517d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7db56768066c15617f026cf8d5b473e3623517d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cd4eae43592e543dbd2423102d3f286e9905623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cd4eae43592e543dbd2423102d3f286e9905623", "html_url": "https://github.com/rust-lang/rust/commit/4cd4eae43592e543dbd2423102d3f286e9905623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cd4eae43592e543dbd2423102d3f286e9905623/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a96510d0663bb0bc7f3dd47b7b17aa2c3618a6c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96510d0663bb0bc7f3dd47b7b17aa2c3618a6c3", "html_url": "https://github.com/rust-lang/rust/commit/a96510d0663bb0bc7f3dd47b7b17aa2c3618a6c3"}], "stats": {"total": 437, "additions": 226, "deletions": 211}, "files": [{"sha": "3ff0034fbbee7d850988e443c87c9922861c36e0", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -131,7 +131,7 @@ for ty::RegionKind {\n             }\n             ty::ReLateBound(..) |\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) => {\n+            ty::RePlaceholder(..) => {\n                 bug!(\"StableHasher: unexpected region {:?}\", *self)\n             }\n         }"}, {"sha": "1119c928a89aeaf557b0e843909f116f1325d44e", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -224,7 +224,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n-            | ty::ReSkolemized(..)\n+            | ty::RePlaceholder(..)\n             | ty::ReEmpty\n             | ty::ReErased => {\n                 if self.canonicalize_region_mode.other_free_regions {"}, {"sha": "de8f57ee796661446670dad90ec2804b6663e0f3", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -458,9 +458,10 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 return Ok(r);\n             }\n \n-            // Always make a fresh region variable for skolemized regions;\n-            // the higher-ranked decision procedures rely on this.\n-            ty::ReSkolemized(..) => { }\n+            // Always make a fresh region variable for placeholder\n+            // regions; the higher-ranked decision procedures rely on\n+            // this.\n+            ty::RePlaceholder(..) => { }\n \n             // For anything else, we make a region variable, unless we\n             // are *equating*, in which case it's just wasteful."}, {"sha": "8b4669c89fe83598161d4114d72d6f7465f17f23", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -142,12 +142,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            // FIXME(#13998) ReSkolemized should probably print like\n+            // FIXME(#13998) RePlaceholder should probably print like\n             // ReFree rather than dumping Debug output on the user.\n             //\n             // We shouldn't really be having unification failures with ReVar\n             // and ReLateBound though.\n-            ty::ReSkolemized(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+            ty::RePlaceholder(..) | ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n                 (format!(\"lifetime {:?}\", region), None)\n             }\n "}, {"sha": "969d260d97e218d2989717c604682c9f9234e438", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::ReFree(_) |\n             ty::ReScope(_) |\n             ty::ReVar(_) |\n-            ty::ReSkolemized(..) |\n+            ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // replace all free regions with 'erased"}, {"sha": "c5c07da1ad0676c718050e2f438ae85aad11974d", "filename": "src/librustc/infer/higher_ranked/README.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -72,11 +72,11 @@ the same lifetime, but not the reverse.\n Here is the algorithm we use to perform the subtyping check:\n \n 1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with skolemized\n-   equivalents. A \"skolemized\" region is just a new fresh region\n+2. Replace all bound regions in the supertype with placeholder\n+   equivalents. A \"placeholder\" region is just a new fresh region\n    name.\n 3. Check that the parameter and return types match as normal\n-4. Ensure that no skolemized regions 'leak' into region variables\n+4. Ensure that no placeholder regions 'leak' into region variables\n    visible from \"the outside\"\n \n Let's walk through some examples and see how this algorithm plays out.\n@@ -95,7 +95,7 @@ like so:\n Here the upper case `&A` indicates a *region variable*, that is, a\n region whose value is being inferred by the system. I also replaced\n `&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate skolemized region names. We can assume they don't appear\n+to indicate placeholder region names. We can assume they don't appear\n elsewhere. Note that neither the sub- nor the supertype bind any\n region names anymore (as indicated by the absence of `<` and `>`).\n \n@@ -181,15 +181,15 @@ the first example, you had two functions:\n     for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n \n and hence `&A` and `&x` were created \"together\". In general, the\n-intention of the skolemized names is that they are supposed to be\n+intention of the placeholder names is that they are supposed to be\n fresh names that could never be equal to anything from the outside.\n But when inference comes into play, we might not be respecting this\n rule.\n \n So the way we solve this is to add a fourth step that examines the\n-constraints that refer to skolemized names. Basically, consider a\n+constraints that refer to placeholder names. Basically, consider a\n non-directed version of the constraint graph. Let `Tainted(x)` be the\n-set of all things reachable from a skolemized variable `x`.\n+set of all things reachable from a placeholder variable `x`.\n `Tainted(x)` should not contain any regions that existed before the\n step at which the skolemization was performed. So this case here\n would fail because `&x` was created alone, but is relatable to `&A`."}, {"sha": "e05b88feb34a233e9956f2f1c1ff29604f1616f7", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 72, "deletions": 66, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -15,7 +15,7 @@ use super::{CombinedSnapshot,\n             InferCtxt,\n             HigherRankedType,\n             SubregionOrigin,\n-            SkolemizationMap};\n+            PlaceholderMap};\n use super::combine::CombineFields;\n use super::region_constraints::{TaintDirections};\n \n@@ -61,8 +61,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n-            let (b_prime, skol_map) =\n-                self.infcx.skolemize_late_bound_regions(b);\n+            let (b_prime, placeholder_map) =\n+                self.infcx.replace_late_bound_regions_with_placeholders(b);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n@@ -71,12 +71,12 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n \n             // Presuming type comparison succeeds, we need to check\n-            // that the skolemized regions do not \"leak\".\n-            self.infcx.leak_check(!a_is_expected, span, &skol_map, snapshot)?;\n+            // that the placeholder regions do not \"leak\".\n+            self.infcx.leak_check(!a_is_expected, span, &placeholder_map, snapshot)?;\n \n-            // We are finished with the skolemized regions now so pop\n+            // We are finished with the placeholder regions now so pop\n             // them off.\n-            self.infcx.pop_skolemized(skol_map, snapshot);\n+            self.infcx.pop_placeholders(placeholder_map, snapshot);\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n@@ -112,29 +112,29 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the matcher\n-            // with a skolemized region.\n-            let ((a_match, a_value), skol_map) =\n-                self.infcx.skolemize_late_bound_regions(a_pair);\n+            // with a placeholder region.\n+            let ((a_match, a_value), placeholder_map) =\n+                self.infcx.replace_late_bound_regions_with_placeholders(a_pair);\n \n             debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n-            debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n+            debug!(\"higher_ranked_match: placeholder_map={:?}\", placeholder_map);\n \n             // Equate types now that bound regions have been replaced.\n             self.equate(a_is_expected).relate(&a_match, &b_match)?;\n \n-            // Map each skolemized region to a vector of other regions that it\n+            // Map each placeholder region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n-            // skolemized regions from `skol_map`.)\n+            // placeholder regions from `placeholder_map`.)\n             let skol_resolution_map: FxHashMap<_, _> =\n-                skol_map\n+                placeholder_map\n                 .iter()\n                 .map(|(&br, &skol)| {\n                     let tainted_regions =\n                         self.infcx.tainted_regions(snapshot,\n                                                    skol,\n                                                    TaintDirections::incoming()); // [1]\n \n-                    // [1] this routine executes after the skolemized\n+                    // [1] this routine executes after the placeholder\n                     // regions have been *equated* with something\n                     // else, so examining the incoming edges ought to\n                     // be enough to collect all constraints\n@@ -143,9 +143,9 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 })\n                 .collect();\n \n-            // For each skolemized region, pick a representative -- which can\n+            // For each placeholder region, pick a representative -- which can\n             // be any region from the sets above, except for other members of\n-            // `skol_map`. There should always be a representative if things\n+            // `placeholder_map`. There should always be a representative if things\n             // are properly well-formed.\n             let skol_representatives: FxHashMap<_, _> =\n                 skol_resolution_map\n@@ -184,7 +184,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            // Replace the skolemized regions appearing in value with\n+            // Replace the placeholder regions appearing in value with\n             // their representatives\n             let a_value =\n                 fold_regions_in(\n@@ -194,8 +194,8 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             debug!(\"higher_ranked_match: value={:?}\", a_value);\n \n-            // We are now done with these skolemized variables.\n-            self.infcx.pop_skolemized(skol_map, snapshot);\n+            // We are now done with these placeholder variables.\n+            self.infcx.pop_placeholders(placeholder_map, snapshot);\n \n             Ok(HrMatchResult { value: a_value })\n         });\n@@ -500,7 +500,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          * started. This is used in the sub/lub/glb computations. The\n          * idea here is that when we are computing lub/glb of two\n          * regions, we sometimes create intermediate region variables.\n-         * Those region variables may touch some of the skolemized or\n+         * Those region variables may touch some of the placeholder or\n          * other \"forbidden\" regions we created to replace bound\n          * regions, but they don't really represent an \"external\"\n          * constraint.\n@@ -527,10 +527,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n          * we're not careful, it will succeed.\n          *\n          * The reason is that when we walk through the subtyping\n-         * algorithm, we begin by replacing `'a` with a skolemized\n+         * algorithm, we begin by replacing `'a` with a placeholder\n          * variable `'1`. We then have `fn(_#0t) <: fn(&'1 int)`. This\n          * can be made true by unifying `_#0t` with `&'1 int`. In the\n-         * process, we create a fresh variable for the skolemized\n+         * process, we create a fresh variable for the placeholder\n          * region, `'$2`, and hence we have that `_#0t == &'$2\n          * int`. However, because `'$2` was created during the sub\n          * computation, if we're not careful we will erroneously\n@@ -568,14 +568,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_vars\n     }\n \n-    /// Replace all regions bound by `binder` with skolemized regions and\n+    /// Replace all regions bound by `binder` with placeholder regions and\n     /// return a map indicating which bound-region was replaced with what\n-    /// skolemized region. This is the first step of checking subtyping\n+    /// placeholder region. This is the first step of checking subtyping\n     /// when higher-ranked things are involved.\n     ///\n     /// **Important:** you must call this function from within a snapshot.\n     /// Moreover, before committing the snapshot, you must eventually call\n-    /// either `plug_leaks` or `pop_skolemized` to remove the skolemized\n+    /// either `plug_leaks` or `pop_placeholders` to remove the placeholder\n     /// regions. If you rollback the snapshot (or are using a probe), then\n     /// the pop occurs as part of the rollback, so an explicit call is not\n     /// needed (but is also permitted).\n@@ -584,14 +584,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the [rustc guide].\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/traits/hrtb.html\n-    pub fn skolemize_late_bound_regions<T>(&self,\n+    pub fn replace_late_bound_regions_with_placeholders<T>(&self,\n                                            binder: &ty::Binder<T>)\n-                                           -> (T, SkolemizationMap<'tcx>)\n+                                           -> (T, PlaceholderMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n             self.universe.set(self.universe().subuniverse());\n-            self.tcx.mk_region(ty::ReSkolemized(self.universe(), br))\n+            self.tcx.mk_region(ty::RePlaceholder(self.universe(), br))\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -603,19 +603,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Searches the region constraints created since `snapshot` was started\n-    /// and checks to determine whether any of the skolemized regions created\n-    /// in `skol_map` would \"escape\" -- meaning that they are related to\n+    /// and checks to determine whether any of the placeholder regions created\n+    /// in `placeholder_map` would \"escape\" -- meaning that they are related to\n     /// other regions in some way. If so, the higher-ranked subtyping doesn't\n     /// hold. See `README.md` for more details.\n     pub fn leak_check(&self,\n                       overly_polymorphic: bool,\n                       _span: Span,\n-                      skol_map: &SkolemizationMap<'tcx>,\n+                      placeholder_map: &PlaceholderMap<'tcx>,\n                       snapshot: &CombinedSnapshot<'a, 'tcx>)\n                       -> RelateResult<'tcx, ()>\n     {\n-        debug!(\"leak_check: skol_map={:?}\",\n-               skol_map);\n+        debug!(\"leak_check: placeholder_map={:?}\",\n+               placeholder_map);\n \n         // If the user gave `-Zno-leak-check`, then skip the leak\n         // check completely. This is wildly unsound and also not\n@@ -630,14 +630,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n-        for (&skol_br, &skol) in skol_map {\n-            // The inputs to a skolemized variable can only\n+        for (&skol_br, &skol) in placeholder_map {\n+            // The inputs to a placeholder variable can only\n             // be itself or other new variables.\n             let incoming_taints = self.tainted_regions(snapshot,\n                                                        skol,\n                                                        TaintDirections::both());\n             for &tainted_region in &incoming_taints {\n-                // Each skolemized should only be relatable to itself\n+                // Each placeholder should only be relatable to itself\n                 // or new variables:\n                 match *tainted_region {\n                     ty::ReVar(vid) => {\n@@ -668,9 +668,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    /// This code converts from skolemized regions back to late-bound\n+    /// This code converts from placeholder regions back to late-bound\n     /// regions. It works by replacing each region in the taint set of a\n-    /// skolemized region with a bound-region. The bound region will be bound\n+    /// placeholder region with a bound-region. The bound region will be bound\n     /// by the outer-most binder in `value`; the caller must ensure that there is\n     /// such a binder and it is the right place.\n     ///\n@@ -687,7 +687,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///         where A : Clone\n     ///     { ... }\n     ///\n-    /// Here we will have replaced `'a` with a skolemized region\n+    /// Here we will have replaced `'a` with a placeholder region\n     /// `'0`. This means that our substitution will be `{A=>&'0\n     /// int, R=>&'0 int}`.\n     ///\n@@ -697,25 +697,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// to the depth of the predicate, in this case 1, so that the final\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n-                         skol_map: SkolemizationMap<'tcx>,\n+                         placeholder_map: PlaceholderMap<'tcx>,\n                          snapshot: &CombinedSnapshot<'a, 'tcx>,\n                          value: T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n-               skol_map,\n+        debug!(\"plug_leaks(placeholder_map={:?}, value={:?})\",\n+               placeholder_map,\n                value);\n \n-        if skol_map.is_empty() {\n+        if placeholder_map.is_empty() {\n             return value;\n         }\n \n-        // Compute a mapping from the \"taint set\" of each skolemized\n+        // Compute a mapping from the \"taint set\" of each placeholder\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n-            skol_map\n+        let inv_placeholder_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n+            placeholder_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {\n                 self.tainted_regions(snapshot, skol, TaintDirections::both())\n@@ -724,8 +724,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             })\n             .collect();\n \n-        debug!(\"plug_leaks: inv_skol_map={:?}\",\n-               inv_skol_map);\n+        debug!(\"plug_leaks: inv_placeholder_map={:?}\",\n+               inv_placeholder_map);\n \n         // Remove any instantiated type variables from `value`; those can hide\n         // references to regions from the `fold_regions` code below.\n@@ -737,25 +737,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // responsible for ensuring that (a) `value` contains at least one\n         // binder and (b) that binder is the one we want to use.\n         let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n-            match inv_skol_map.get(&r) {\n+            match inv_placeholder_map.get(&r) {\n                 None => r,\n                 Some(br) => {\n                     // It is the responsibility of the caller to ensure\n-                    // that each skolemized region appears within a\n+                    // that each placeholder region appears within a\n                     // binder. In practice, this routine is only used by\n-                    // trait checking, and all of the skolemized regions\n+                    // trait checking, and all of the placeholder regions\n                     // appear inside predicates, which always have\n                     // binders, so this assert is satisfied.\n                     assert!(current_depth > ty::INNERMOST);\n \n-                    // since leak-check passed, this skolemized region\n+                    // since leak-check passed, this placeholder region\n                     // should only have incoming edges from variables\n                     // (which ought not to escape the snapshot, but we\n                     // don't check that) or itself\n                     assert!(\n                         match *r {\n                             ty::ReVar(_) => true,\n-                            ty::ReSkolemized(_, ref br1) => br == br1,\n+                            ty::RePlaceholder(_, ref br1) => br == br1,\n                             _ => false,\n                         },\n                         \"leak-check would have us replace {:?} with {:?}\",\n@@ -769,31 +769,37 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        self.pop_skolemized(skol_map, snapshot);\n+        self.pop_placeholders(placeholder_map, snapshot);\n \n         debug!(\"plug_leaks: result={:?}\", result);\n \n         result\n     }\n \n-    /// Pops the skolemized regions found in `skol_map` from the region\n-    /// inference context. Whenever you create skolemized regions via\n-    /// `skolemize_late_bound_regions`, they must be popped before you\n+    /// Pops the placeholder regions found in `placeholder_map` from the region\n+    /// inference context. Whenever you create placeholder regions via\n+    /// `replace_late_bound_regions_with_placeholders`, they must be popped before you\n     /// commit the enclosing snapshot (if you do not commit, e.g. within a\n     /// probe or as a result of an error, then this is not necessary, as\n     /// popping happens as part of the rollback).\n     ///\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n-    pub fn pop_skolemized(&self,\n-                          skol_map: SkolemizationMap<'tcx>,\n-                          snapshot: &CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"pop_skolemized({:?})\", skol_map);\n-        let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n+    pub fn pop_placeholders(\n+        &self,\n+        placeholder_map: PlaceholderMap<'tcx>,\n+        snapshot: &CombinedSnapshot<'a, 'tcx>,\n+    ) {\n+        debug!(\"pop_placeholders({:?})\", placeholder_map);\n+        let skol_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n         self.borrow_region_constraints()\n-            .pop_skolemized(self.universe(), &skol_regions, &snapshot.region_constraints_snapshot);\n+            .pop_placeholders(\n+                self.universe(),\n+                &skol_regions,\n+                &snapshot.region_constraints_snapshot,\n+            );\n         self.universe.set(snapshot.universe);\n-        if !skol_map.is_empty() {\n-            self.projection_cache.borrow_mut().rollback_skolemized(\n+        if !placeholder_map.is_empty() {\n+            self.projection_cache.borrow_mut().rollback_placeholder(\n                 &snapshot.projection_cache_snapshot);\n         }\n     }"}, {"sha": "caba8b514f7972498bf54aa3623312ae2d374840", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -28,7 +28,7 @@ use std::u32;\n use ty::fold::TypeFoldable;\n use ty::{self, Ty, TyCtxt};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n+use ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n use ty::{Region, RegionVid};\n \n mod graphviz;\n@@ -341,7 +341,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n+            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => if a == b {\n                 a\n             } else {\n                 tcx.types.re_static"}, {"sha": "0634e4017d1c396b27eb852cbe988f75a6b945f4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -229,9 +229,10 @@ pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     universe: Cell<ty::UniverseIndex>,\n }\n \n-/// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n-/// region that each late-bound region was replaced with.\n-pub type SkolemizationMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n+/// A map returned by `replace_late_bound_regions_with_placeholders()`\n+/// indicating the placeholder region that each late-bound region was\n+/// replaced with.\n+pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n \n /// See `error_reporting` module for more details\n #[derive(Clone, Debug)]\n@@ -913,13 +914,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     a,\n                     b,\n                 },\n-                skol_map,\n-            ) = self.skolemize_late_bound_regions(predicate);\n+                placeholder_map,\n+            ) = self.replace_late_bound_regions_with_placeholders(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n-            self.leak_check(false, cause_span, &skol_map, snapshot)?;\n-            self.pop_skolemized(skol_map, snapshot);\n+            self.leak_check(false, cause_span, &placeholder_map, snapshot)?;\n+            self.pop_placeholders(placeholder_map, snapshot);\n             Ok(ok.unit())\n         }))\n     }\n@@ -930,14 +931,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n     ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n-                self.skolemize_late_bound_regions(predicate);\n+            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n+                self.replace_late_bound_regions_with_placeholders(predicate);\n             let origin = SubregionOrigin::from_obligation_cause(cause, || {\n                 RelateRegionParamBound(cause.span)\n             });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, cause.span, &skol_map, snapshot)?;\n-            Ok(self.pop_skolemized(skol_map, snapshot))\n+            self.leak_check(false, cause.span, &placeholder_map, snapshot)?;\n+            Ok(self.pop_placeholders(placeholder_map, snapshot))\n         })\n     }\n "}, {"sha": "4be031efcfe5c6844b5b50a715af7a4bbd40e9e3", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -306,9 +306,9 @@ pub struct RegionSnapshot {\n     any_unifications: bool,\n }\n \n-/// When working with skolemized regions, we often wish to find all of\n-/// the regions that are either reachable from a skolemized region, or\n-/// which can reach a skolemized region, or both. We call such regions\n+/// When working with placeholder regions, we often wish to find all of\n+/// the regions that are either reachable from a placeholder region, or\n+/// which can reach a placeholder region, or both. We call such regions\n /// *tained* regions.  This struct allows you to decide what set of\n /// tainted regions you want.\n #[derive(Debug)]\n@@ -527,23 +527,23 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         self.var_infos[vid].origin\n     }\n \n-    /// Removes all the edges to/from the skolemized regions that are\n+    /// Removes all the edges to/from the placeholder regions that are\n     /// in `skols`. This is used after a higher-ranked operation\n-    /// completes to remove all trace of the skolemized regions\n+    /// completes to remove all trace of the placeholder regions\n     /// created in that time.\n-    pub fn pop_skolemized(\n+    pub fn pop_placeholders(\n         &mut self,\n         skolemization_count: ty::UniverseIndex,\n         skols: &FxHashSet<ty::Region<'tcx>>,\n         snapshot: &RegionSnapshot,\n     ) {\n-        debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n+        debug!(\"pop_placeholders(skols={:?})\", skols);\n \n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n             skolemization_count.as_usize() >= skols.len(),\n-            \"popping more skolemized variables than actually exist, \\\n+            \"popping more placeholder variables than actually exist, \\\n              sc now = {:?}, skols.len = {:?}\",\n             skolemization_count,\n             skols.len()\n@@ -555,7 +555,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(universe, _) =>\n+                     ty::RePlaceholder(universe, _) =>\n                          universe >= first_to_pop &&\n                          universe < last_to_pop,\n                      _ =>\n@@ -860,7 +860,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             ty::ReErased |\n             ty::ReFree(..) |\n             ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n-            ty::ReSkolemized(universe, _) => universe,\n+            ty::RePlaceholder(universe, _) => universe,\n             ty::ReClosureBound(vid) |\n             ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) =>\n@@ -886,7 +886,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// relations are considered. For example, one can say that only\n     /// \"incoming\" edges to `r0` are desired, in which case one will\n     /// get the set of regions `{r|r <= r0}`. This is used when\n-    /// checking whether skolemized regions are being improperly\n+    /// checking whether placeholder regions are being improperly\n     /// related to other regions.\n     pub fn tainted(\n         &self,"}, {"sha": "7add8ef05ee78377340d2bc9bfe6f90ea68f582a", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -117,7 +117,7 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n-    // For the purposes of this check, we don't bring any skolemized\n+    // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n     // empty environment."}, {"sha": "9cad9a06c635cd979cbce75cabb2263e3ea17ea3", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -206,15 +206,15 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n \n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n-        let (skol_predicate, skol_map) =\n-            infcx.skolemize_late_bound_regions(&obligation.predicate);\n+        let (skol_predicate, placeholder_map) =\n+            infcx.replace_late_bound_regions_with_placeholders(&obligation.predicate);\n \n         let skol_obligation = obligation.with(skol_predicate);\n         let r = match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n                 let span = obligation.cause.span;\n-                match infcx.leak_check(false, span, &skol_map, snapshot) {\n-                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, result)),\n+                match infcx.leak_check(false, span, &placeholder_map, snapshot) {\n+                    Ok(()) => Ok(infcx.plug_leaks(placeholder_map, snapshot, result)),\n                     Err(e) => {\n                         debug!(\"poly_project_and_unify_type: leak check encountered error {:?}\", e);\n                         Err(MismatchedProjectionTypes { err: e })\n@@ -1571,11 +1571,11 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n \n // # Cache\n \n-/// The projection cache. Unlike the standard caches, this can\n-/// include infcx-dependent type variables - therefore, we have to roll\n-/// the cache back each time we roll a snapshot back, to avoid assumptions\n-/// on yet-unresolved inference variables. Types with skolemized regions\n-/// also have to be removed when the respective snapshot ends.\n+/// The projection cache. Unlike the standard caches, this can include\n+/// infcx-dependent type variables - therefore, we have to roll the\n+/// cache back each time we roll a snapshot back, to avoid assumptions\n+/// on yet-unresolved inference variables. Types with placeholder\n+/// regions also have to be removed when the respective snapshot ends.\n ///\n /// Because of that, projection cache entries can be \"stranded\" and left\n /// inaccessible when type variables inside the key are resolved. We make no\n@@ -1661,7 +1661,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n         self.map.rollback_to(&snapshot.snapshot);\n     }\n \n-    pub fn rollback_skolemized(&mut self, snapshot: &ProjectionCacheSnapshot) {\n+    pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n         self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_skol());\n     }\n "}, {"sha": "9c7283e6d9fcdf1f6d5721f7869aaa4bc3a340ec", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -62,11 +62,11 @@ use util::nodemap::{FxHashMap, FxHashSet};\n pub struct SelectionContext<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n-    /// Freshener used specifically for skolemizing entries on the\n-    /// obligation stack. This ensures that all entries on the stack\n-    /// at one time will have the same set of skolemized entries,\n-    /// which is important for checking for trait bounds that\n-    /// recursively require themselves.\n+    /// Freshener used specifically for entries on the obligation\n+    /// stack. This ensures that all entries on the stack at one time\n+    /// will have the same set of placeholder entries, which is\n+    /// important for checking for trait bounds that recursively\n+    /// require themselves.\n     freshener: TypeFreshener<'cx, 'gcx, 'tcx>,\n \n     /// If true, indicates that the evaluation should be conservative\n@@ -159,7 +159,7 @@ impl IntercrateAmbiguityCause {\n struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     obligation: &'prev TraitObligation<'tcx>,\n \n-    /// Trait ref from `obligation` but skolemized with the\n+    /// Trait ref from `obligation` but \"freshened\" with the\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n@@ -1008,11 +1008,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // `Send`.\n         //\n         // Note that we do this comparison using the `fresh_trait_ref`\n-        // fields. Because these have all been skolemized using\n+        // fields. Because these have all been freshened using\n         // `self.freshener`, we can be sure that (a) this will not\n         // affect the inferencer state and (b) that if we see two\n-        // skolemized types with the same index, they refer to the\n-        // same unbound type variable.\n+        // fresh regions with the same index, they refer to the same\n+        // unbound type variable.\n         if let Some(rec_index) = stack.iter()\n                  .skip(1) // skip top-most frame\n                  .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n@@ -1191,9 +1191,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n-        // separately rather than using `stack.fresh_trait_ref` -- this\n-        // is because we want the unbound variables to be replaced\n-        // with fresh skolemized types starting from index 0.\n+        // separately rather than using `stack.fresh_trait_ref` --\n+        // this is because we want the unbound variables to be\n+        // replaced with fresh types starting from index 0.\n         let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate.clone());\n         debug!(\n             \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n@@ -1687,12 +1687,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> bool {\n         let poly_trait_predicate = self.infcx()\n             .resolve_type_vars_if_possible(&obligation.predicate);\n-        let (skol_trait_predicate, skol_map) = self.infcx()\n-            .skolemize_late_bound_regions(&poly_trait_predicate);\n+        let (skol_trait_predicate, placeholder_map) = self.infcx()\n+            .replace_late_bound_regions_with_placeholders(&poly_trait_predicate);\n         debug!(\n             \"match_projection_obligation_against_definition_bounds: \\\n-             skol_trait_predicate={:?} skol_map={:?}\",\n-            skol_trait_predicate, skol_map\n+             skol_trait_predicate={:?} placeholder_map={:?}\",\n+            skol_trait_predicate, placeholder_map\n         );\n \n         let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n@@ -1729,7 +1729,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         obligation,\n                         bound.clone(),\n                         skol_trait_predicate.trait_ref.clone(),\n-                        &skol_map,\n+                        &placeholder_map,\n                         snapshot,\n                     )\n                 })\n@@ -1748,11 +1748,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     obligation,\n                     bound,\n                     skol_trait_predicate.trait_ref.clone(),\n-                    &skol_map,\n+                    &placeholder_map,\n                     snapshot,\n                 );\n \n-                self.infcx.pop_skolemized(skol_map, snapshot);\n+                self.infcx.pop_placeholders(placeholder_map, snapshot);\n \n                 assert!(result);\n                 true\n@@ -1765,7 +1765,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n         skol_trait_ref: ty::TraitRef<'tcx>,\n-        skol_map: &infer::SkolemizationMap<'tcx>,\n+        placeholder_map: &infer::PlaceholderMap<'tcx>,\n         snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n         debug_assert!(!skol_trait_ref.has_escaping_regions());\n@@ -1778,7 +1778,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         self.infcx\n-            .leak_check(false, obligation.cause.span, skol_map, snapshot)\n+            .leak_check(false, obligation.cause.span, placeholder_map, snapshot)\n             .is_ok()\n     }\n \n@@ -1981,12 +1981,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.predicate.skip_binder().trait_ref.self_ty(),\n             |impl_def_id| {\n                 self.probe(|this, snapshot| /* [1] */\n-                    if let Ok(skol_map) = this.match_impl(impl_def_id, obligation, snapshot) {\n+                    if let Ok(placeholder_map) = this.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n \n-                        // NB: we can safely drop the skol map\n+                        // NB: we can safely drop the placeholder map\n                         // since we are in a probe [1]\n-                        mem::drop(skol_map);\n+                        mem::drop(placeholder_map);\n                     }\n                 );\n             },\n@@ -2630,7 +2630,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         //\n         // The strategy is to:\n         //\n-        // 1. Instantiate those regions to skolemized regions (e.g.,\n+        // 1. Instantiate those regions to placeholder regions (e.g.,\n         //    `for<'a> &'a int` becomes `&0 int`.\n         // 2. Produce something like `&'0 int : Copy`\n         // 3. Re-bind the regions back to `for<'a> &'a int : Copy`\n@@ -2643,7 +2643,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n                 self.in_snapshot(|this, snapshot| {\n-                    let (skol_ty, skol_map) = this.infcx().skolemize_late_bound_regions(&ty);\n+                    let (skol_ty, placeholder_map) = this.infcx()\n+                        .replace_late_bound_regions_with_placeholders(&ty);\n                     let Normalized {\n                         value: normalized_ty,\n                         mut obligations,\n@@ -2663,7 +2664,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         &[],\n                     );\n                     obligations.push(skol_obligation);\n-                    this.infcx().plug_leaks(skol_map, snapshot, obligations)\n+                    this.infcx()\n+                        .plug_leaks(placeholder_map, snapshot, obligations)\n                 })\n             })\n             .collect()\n@@ -2870,15 +2872,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let trait_obligations: Vec<PredicateObligation<'_>> = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let (trait_ref, skol_map) = this.infcx().skolemize_late_bound_regions(&poly_trait_ref);\n+            let (trait_ref, placeholder_map) = this.infcx()\n+                .replace_late_bound_regions_with_placeholders(&poly_trait_ref);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(\n                 cause,\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n                 trait_def_id,\n                 &trait_ref.substs,\n-                skol_map,\n+                placeholder_map,\n                 snapshot,\n             )\n         });\n@@ -2905,7 +2908,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n         self.in_snapshot(|this, snapshot| {\n-            let (substs, skol_map) = this.rematch_impl(impl_def_id, obligation, snapshot);\n+            let (substs, placeholder_map) = this.rematch_impl(impl_def_id, obligation, snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.vtable_impl(\n@@ -2914,7 +2917,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 cause,\n                 obligation.recursion_depth + 1,\n                 obligation.param_env,\n-                skol_map,\n+                placeholder_map,\n                 snapshot,\n             )\n         })\n@@ -2927,12 +2930,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n-        skol_map: infer::SkolemizationMap<'tcx>,\n+        placeholder_map: infer::PlaceholderMap<'tcx>,\n         snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> VtableImplData<'tcx, PredicateObligation<'tcx>> {\n         debug!(\n-            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, skol_map={:?})\",\n-            impl_def_id, substs, recursion_depth, skol_map\n+            \"vtable_impl(impl_def_id={:?}, substs={:?}, recursion_depth={}, placeholder_map={:?})\",\n+            impl_def_id, substs, recursion_depth, placeholder_map\n         );\n \n         let mut impl_obligations = self.impl_or_trait_obligations(\n@@ -2941,7 +2944,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             param_env,\n             impl_def_id,\n             &substs.value,\n-            skol_map,\n+            placeholder_map,\n             snapshot,\n         );\n \n@@ -3465,10 +3468,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> (\n         Normalized<'tcx, &'tcx Substs<'tcx>>,\n-        infer::SkolemizationMap<'tcx>,\n+        infer::PlaceholderMap<'tcx>,\n     ) {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n-            Ok((substs, skol_map)) => (substs, skol_map),\n+            Ok((substs, placeholder_map)) => (substs, placeholder_map),\n             Err(()) => {\n                 bug!(\n                     \"Impl {:?} was matchable against {:?} but now is not\",\n@@ -3487,7 +3490,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> Result<\n         (\n             Normalized<'tcx, &'tcx Substs<'tcx>>,\n-            infer::SkolemizationMap<'tcx>,\n+            infer::PlaceholderMap<'tcx>,\n         ),\n         (),\n     > {\n@@ -3500,8 +3503,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Err(());\n         }\n \n-        let (skol_obligation, skol_map) = self.infcx()\n-            .skolemize_late_bound_regions(&obligation.predicate);\n+        let (skol_obligation, placeholder_map) = self.infcx()\n+            .replace_late_bound_regions_with_placeholders(&obligation.predicate);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n         let impl_substs = self.infcx\n@@ -3532,8 +3535,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n         nested_obligations.extend(obligations);\n \n-        if let Err(e) = self.infcx\n-            .leak_check(false, obligation.cause.span, &skol_map, snapshot)\n+        if let Err(e) =\n+            self.infcx\n+                .leak_check(false, obligation.cause.span, &placeholder_map, snapshot)\n         {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n@@ -3545,7 +3549,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 value: impl_substs,\n                 obligations: nested_obligations,\n             },\n-            skol_map,\n+            placeholder_map,\n         ))\n     }\n \n@@ -3692,7 +3696,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,         // of impl or trait\n         substs: &Substs<'tcx>, // for impl or trait\n-        skol_map: infer::SkolemizationMap<'tcx>,\n+        placeholder_map: infer::PlaceholderMap<'tcx>,\n         snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n         debug!(\"impl_or_trait_obligations(def_id={:?})\", def_id);\n@@ -3755,7 +3759,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let mut seen = FxHashSet();\n             predicates.retain(|i| seen.insert(i.clone()));\n         }\n-        self.infcx().plug_leaks(skol_map, snapshot, predicates)\n+        self.infcx()\n+            .plug_leaks(placeholder_map, snapshot, predicates)\n     }\n }\n "}, {"sha": "2c713c0f7f1aacba204236ff10315f49a859e62c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -184,7 +184,7 @@ pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return false;\n     }\n \n-    // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n     let penv = tcx.param_env(impl1_def_id);\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n "}, {"sha": "a1edf67e47552215e02420ed32196b145feb5d36", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -218,9 +218,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::IntVar(_)) => \"integral variable\".to_string(),\n             ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".to_string(),\n             ty::Infer(ty::CanonicalTy(_)) |\n-            ty::Infer(ty::FreshTy(_)) => \"skolemized type\".to_string(),\n-            ty::Infer(ty::FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n-            ty::Infer(ty::FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n+            ty::Infer(ty::FreshTy(_)) => \"fresh type\".to_string(),\n+            ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".to_string(),\n+            ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".to_string(),\n             ty::Projection(_) => \"associated type\".to_string(),\n             ty::UnnormalizedProjection(_) => \"non-normalized associated type\".to_string(),\n             ty::Param(ref p) => {"}, {"sha": "1c5ff85d69ba6d0428d4471bc16589a249cbd145", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -667,12 +667,14 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n /// we already use the term \"free region\". It refers to the regions that we use to represent bound\n /// regions on a fn definition while we are typechecking its body.\n ///\n-/// To clarify, conceptually there is no particular difference between an \"escaping\" region and a\n-/// \"free\" region. However, there is a big difference in practice. Basically, when \"entering\" a\n-/// binding level, one is generally required to do some sort of processing to a bound region, such\n-/// as replacing it with a fresh/skolemized region, or making an entry in the environment to\n-/// represent the scope to which it is attached, etc. An escaping region represents a bound region\n-/// for which this processing has not yet been done.\n+/// To clarify, conceptually there is no particular difference between\n+/// an \"escaping\" region and a \"free\" region. However, there is a big\n+/// difference in practice. Basically, when \"entering\" a binding\n+/// level, one is generally required to do some sort of processing to\n+/// a bound region, such as replacing it with a fresh/placeholder\n+/// region, or making an entry in the environment to represent the\n+/// scope to which it is attached, etc. An escaping region represents\n+/// a bound region for which this processing has not yet been done.\n struct HasEscapingRegionsVisitor {\n     /// Anything bound by `outer_index` or \"above\" is escaping\n     outer_index: ty::DebruijnIndex,"}, {"sha": "1fed4467d3227efbb57fc95990064de6999f8021", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -1485,10 +1485,10 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// the body of `bar`, we refer to `T` as a type, we aren't referring\n /// to any type in particular, but rather a kind of \"fresh\" type that\n /// is distinct from all other types we have actually declared. This\n-/// is called a **skolemized** type, and we use universes to talk\n+/// is called a **placeholder** type, and we use universes to talk\n /// about this. In other words, a type name in universe 0 always\n /// corresponds to some \"ground\" type that the user declared, but a\n-/// type name in a non-zero universe is a skolemized type -- an\n+/// type name in a non-zero universe is a placeholder type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "f9174ece0024a173853b8e15a878d358bca60479", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -709,7 +709,7 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// Object types don't have a self-type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n+    /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>  {\n         // otherwise the escaping regions would be captured by the binder\n@@ -732,7 +732,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     /// Object types don't have a self-type specified. Therefore, when\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n-    /// or some skolemized type.\n+    /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'_, '_, 'tcx>,\n                         self_ty: Ty<'tcx>)\n                         -> ty::PolyTraitRef<'tcx>  {\n@@ -1066,10 +1066,10 @@ pub type Region<'tcx> = &'tcx RegionKind;\n ///\n /// Unlike Param-s, bound regions are not supposed to exist \"in the wild\"\n /// outside their binder, e.g. in types passed to type inference, and\n-/// should first be substituted (by skolemized regions, free regions,\n+/// should first be substituted (by placeholder regions, free regions,\n /// or region variables).\n ///\n-/// ## Skolemized and Free Regions\n+/// ## Placeholder and Free Regions\n ///\n /// One often wants to work with bound regions without knowing their precise\n /// identity. For example, when checking a function, the lifetime of a borrow\n@@ -1078,11 +1078,11 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// assumed without being checked.\n ///\n /// The process of doing that is called \"skolemization\". The bound regions\n-/// are replaced by skolemized markers, which don't satisfy any relation\n+/// are replaced by placeholder markers, which don't satisfy any relation\n /// not explicitly provided.\n ///\n-/// There are 2 kinds of skolemized regions in rustc: `ReFree` and\n-/// `ReSkolemized`. When checking an item's body, `ReFree` is supposed\n+/// There are 2 kinds of placeholder regions in rustc: `ReFree` and\n+/// `RePlaceholder`. When checking an item's body, `ReFree` is supposed\n /// to be used. These also support explicit bounds: both the internally-stored\n /// *scope*, which the region is assumed to outlive, as well as other\n /// relations stored in the `FreeRegionMap`. Note that these relations\n@@ -1091,14 +1091,14 @@ pub type Region<'tcx> = &'tcx RegionKind;\n ///\n /// When working with higher-ranked types, some region relations aren't\n /// yet known, so you can't just call `resolve_regions_and_report_errors`.\n-/// `ReSkolemized` is designed for this purpose. In these contexts,\n+/// `RePlaceholder` is designed for this purpose. In these contexts,\n /// there's also the risk that some inference variable laying around will\n-/// get unified with your skolemized region: if you want to check whether\n+/// get unified with your placeholder region: if you want to check whether\n /// `for<'a> Foo<'_>: 'a`, and you substitute your bound region `'a`\n-/// with a skolemized region `'%a`, the variable `'_` would just be\n-/// instantiated to the skolemized region `'%a`, which is wrong because\n+/// with a placeholder region `'%a`, the variable `'_` would just be\n+/// instantiated to the placeholder region `'%a`, which is wrong because\n /// the inference variable is supposed to satisfy the relation\n-/// *for every value of the skolemized region*. To ensure that doesn't\n+/// *for every value of the placeholder region*. To ensure that doesn't\n /// happen, you can use `leak_check`. This is more clearly explained\n /// by the [rustc guide].\n ///\n@@ -1132,9 +1132,9 @@ pub enum RegionKind {\n     /// A region variable.  Should not exist after typeck.\n     ReVar(RegionVid),\n \n-    /// A skolemized region - basically the higher-ranked version of ReFree.\n+    /// A placeholder region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(ty::UniverseIndex, BoundRegion),\n+    RePlaceholder(ty::UniverseIndex, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1338,7 +1338,7 @@ impl RegionKind {\n             RegionKind::ReScope(..) => false,\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n-            RegionKind::ReSkolemized(_, br) => br.is_named(),\n+            RegionKind::RePlaceholder(_, br) => br.is_named(),\n             RegionKind::ReEmpty => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,\n@@ -1410,7 +1410,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n             }\n-            ty::ReSkolemized(..) => {\n+            ty::RePlaceholder(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_SKOL;\n             }"}, {"sha": "8c1482652ee29908053c4db23fc76a42b294ddb4", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -520,7 +520,7 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n+    // a placeholder type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n     let predicates = existential_predicates.iter().filter_map(|predicate| {"}, {"sha": "b588b798f2b5bdb87af3cd2a9bd905d569c49e27", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -803,7 +803,7 @@ define_print! {\n                 }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-                ty::ReSkolemized(_, br) => {\n+                ty::RePlaceholder(_, br) => {\n                     write!(f, \"{}\", br)\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n@@ -872,8 +872,8 @@ define_print! {\n                     write!(f, \"'?{}\", c.index())\n                 }\n \n-                ty::ReSkolemized(universe, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({:?}, {:?})\", universe, bound_region)\n+                ty::RePlaceholder(universe, ref bound_region) => {\n+                    write!(f, \"RePlaceholder({:?}, {:?})\", universe, bound_region)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),"}, {"sha": "34ee03b895f9f6615522f5a4cf5e54f558950dd6", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // These cannot exist in borrowck\n             RegionKind::ReVar(..) |\n             RegionKind::ReCanonical(..) |\n-            RegionKind::ReSkolemized(..) |\n+            RegionKind::RePlaceholder(..) |\n             RegionKind::ReClosureBound(..) |\n             RegionKind::ReErased => span_bug!(borrow_span,\n                                               \"unexpected region in borrowck {:?}\","}, {"sha": "1f83c30a3876a215b7a9c8fa584bc334bea2496a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReClosureBound(..) |\n                     ty::ReLateBound(..) |\n                     ty::ReVar(..) |\n-                    ty::ReSkolemized(..) |\n+                    ty::RePlaceholder(..) |\n                     ty::ReErased => {\n                         span_bug!(\n                             cmt.span,"}, {"sha": "95bb4f8fdb2d8eb1d57ddba1dbd3dabd0ed924be", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -1780,7 +1780,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.sty {\n             ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n-            | ty::TyKind::Ref(ty::RegionKind::ReSkolemized(_, br), _, _) => {\n+            | ty::TyKind::Ref(ty::RegionKind::RePlaceholder(_, br), _, _) => {\n                 with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", ty))\n             }\n             _ => format!(\"{}\", ty),\n@@ -1792,7 +1792,7 @@ impl<'tcx> AnnotatedBorrowFnSignature<'tcx> {\n     fn get_region_name_for_ty(&self, ty: ty::Ty<'tcx>, counter: usize) -> String {\n         match ty.sty {\n             ty::TyKind::Ref(region, _, _) => match region {\n-                ty::RegionKind::ReLateBound(_, br) | ty::RegionKind::ReSkolemized(_, br) => {\n+                ty::RegionKind::ReLateBound(_, br) | ty::RegionKind::RePlaceholder(_, br) => {\n                     with_highlight_region_for_bound_region(*br, counter, || format!(\"{}\", region))\n                 }\n                 _ => format!(\"{}\", region),"}, {"sha": "3a545d9adbfcee457a062295a505d9f1803f9f83", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -274,7 +274,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ty::ReLateBound(..)\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n-            | ty::ReSkolemized(..)\n+            | ty::RePlaceholder(..)\n             | ty::ReEmpty\n             | ty::ReErased\n             | ty::ReClosureBound(..)"}, {"sha": "695812faafff10bed688e8c16ff30c80b2215fa8", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -128,14 +128,14 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We create a mapping `dummy_substs` that maps from the impl type\n     // parameters to fresh types and regions. For type parameters,\n     // this is the identity transform, but we could as well use any\n-    // skolemized types. For regions, we convert from bound to free\n+    // placeholder types. For regions, we convert from bound to free\n     // regions (Note: but only early-bound regions, i.e., those\n     // declared on the impl or used in type parameter bounds).\n     //\n     //     impl_to_skol_substs = {'i => 'i0, U => U0, N => N0 }\n     //\n     // Now we can apply skol_substs to the type of the impl method\n-    // to yield a new function type in terms of our fresh, skolemized\n+    // to yield a new function type in terms of our fresh, placeholder\n     // types:\n     //\n     //     <'b> fn(t: &'i0 U0, m: &'b) -> Foo\n@@ -163,15 +163,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // We do this by creating a parameter environment which contains a\n     // substitution corresponding to impl_to_skol_substs. We then build\n     // trait_to_skol_substs and use it to convert the predicates contained\n-    // in the trait_m.generics to the skolemized form.\n+    // in the trait_m.generics to the placeholder form.\n     //\n     // Finally we register each of these predicates as an obligation in\n     // a fresh FulfillmentCtxt, and invoke select_all_or_error.\n \n-    // Create mapping from impl to skolemized.\n+    // Create mapping from impl to placeholder.\n     let impl_to_skol_substs = Substs::identity_for_item(tcx, impl_m.def_id);\n \n-    // Create mapping from trait to skolemized.\n+    // Create mapping from trait to placeholder.\n     let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n                                                                impl_m.container.id(),\n                                                                trait_to_impl_substs);\n@@ -212,7 +212,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hybrid_preds.predicates.extend(\n         trait_m_predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n \n-    // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n+    // Construct trait parameter environment and then shift it into the placeholder viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n@@ -259,7 +259,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // any associated types appearing in the fn arguments or return\n         // type.\n \n-        // Compute skolemized form of impl and trait method tys.\n+        // Compute placeholder form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n         let (impl_sig, _) =\n@@ -894,7 +894,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // method.\n         let impl_c_node_id = tcx.hir.as_local_node_id(impl_c.def_id).unwrap();\n \n-        // Compute skolemized form of impl and trait const tys.\n+        // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n         let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);"}, {"sha": "96b75c4792d759486f8966789592149271d3a2d3", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -170,7 +170,7 @@ fn is_free_region<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, region: Region<'_>) -> bool\n         | RegionKind::ReCanonical(..)\n         | RegionKind::ReScope(..)\n         | RegionKind::ReVar(..)\n-        | RegionKind::ReSkolemized(..)\n+        | RegionKind::RePlaceholder(..)\n         | RegionKind::ReFree(..) => {\n             bug!(\"unexpected region in outlives inference: {:?}\", region);\n         }"}, {"sha": "32a591777db5b57362ea53be5499f71d118d1cd6", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -431,7 +431,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             ty::ReClosureBound(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) |\n+            ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound"}, {"sha": "28f8ebff6ffdd385d15f7aa777da0b500aa3ffc2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -1258,7 +1258,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             ty::ReFree(..) |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) |\n+            ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReClosureBound(_) |\n             ty::ReCanonical(_) |"}, {"sha": "3dac45139ac0febb500f6faf6c54ff2e839c9675", "filename": "src/test/run-pass/project-cache-issue-37154.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Ftest%2Frun-pass%2Fproject-cache-issue-37154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd4eae43592e543dbd2423102d3f286e9905623/src%2Ftest%2Frun-pass%2Fproject-cache-issue-37154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fproject-cache-issue-37154.rs?ref=4cd4eae43592e543dbd2423102d3f286e9905623", "patch": "@@ -10,8 +10,8 @@\n \n #![allow(dead_code)]\n // Regression test for #37154: the problem here was that the cache\n-// results in a false error because it was caching skolemized results\n-// even after those skolemized regions had been popped.\n+// results in a false error because it was caching placeholder results\n+// even after those placeholder regions had been popped.\n \n trait Foo {\n     fn method(&self) {}"}]}