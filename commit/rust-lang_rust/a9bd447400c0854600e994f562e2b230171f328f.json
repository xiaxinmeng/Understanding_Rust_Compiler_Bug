{"sha": "a9bd447400c0854600e994f562e2b230171f328f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YmQ0NDc0MDBjMDg1NDYwMGU5OTRmNTYyZTJiMjMwMTcxZjMyOGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-18T20:04:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-24T05:51:17Z"}, "message": "Roll std::run into std::io::process\n\nThe std::run module is a relic from a standard library long since past, and\nthere's not much use to having two modules to execute processes with where one\nis slightly more convenient. This commit merges the two modules, moving lots of\nfunctionality from std::run into std::io::process and then deleting\nstd::run.\n\nNew things you can find in std::io::process are:\n\n* Process::new() now only takes prog/args\n* Process::configure() takes a ProcessConfig\n* Process::status() is the same as run::process_status\n* Process::output() is the same as run::process_output\n* I/O for spawned tasks is now defaulted to captured in pipes instead of ignored\n* Process::kill() was added (plus an associated green/native implementation)\n* Process::wait_with_output() is the same as the old finish_with_output()\n* destroy() is now signal_exit()\n* force_destroy() is now signal_kill()\n\nCloses #2625\nCloses #10016", "tree": {"sha": "09a6faa8d9f40a5dbf491b215e749c8dca4df0be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09a6faa8d9f40a5dbf491b215e749c8dca4df0be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9bd447400c0854600e994f562e2b230171f328f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bd447400c0854600e994f562e2b230171f328f", "html_url": "https://github.com/rust-lang/rust/commit/a9bd447400c0854600e994f562e2b230171f328f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9bd447400c0854600e994f562e2b230171f328f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8786405047cadcfb5ec3a2d711ca264d74843c13", "url": "https://api.github.com/repos/rust-lang/rust/commits/8786405047cadcfb5ec3a2d711ca264d74843c13", "html_url": "https://github.com/rust-lang/rust/commit/8786405047cadcfb5ec3a2d711ca264d74843c13"}], "stats": {"total": 1491, "additions": 674, "deletions": 817}, "files": [{"sha": "56cdc31090e861de4fe59eae39e4db243666482e", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -9,9 +9,8 @@\n // except according to those terms.\n \n use std::os;\n-use std::run;\n use std::str;\n-use std::io::process::ProcessExit;\n+use std::io::process::{ProcessExit, Process, ProcessConfig, ProcessOutput};\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n@@ -49,17 +48,19 @@ pub fn run(lib_path: &str,\n            input: Option<~str>) -> Option<Result> {\n \n     let env = env + target_env(lib_path, prog);\n-    let mut opt_process = run::Process::new(prog, args, run::ProcessOptions {\n-        env: Some(env),\n-        .. run::ProcessOptions::new()\n+    let mut opt_process = Process::configure(ProcessConfig {\n+        program: prog,\n+        args: args,\n+        env: Some(env.as_slice()),\n+        .. ProcessConfig::new()\n     });\n \n     match opt_process {\n         Ok(ref mut process) => {\n             for input in input.iter() {\n-                process.input().write(input.as_bytes()).unwrap();\n+                process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n             }\n-            let run::ProcessOutput { status, output, error } = process.finish_with_output();\n+            let ProcessOutput { status, output, error } = process.wait_with_output();\n \n             Some(Result {\n                 status: status,\n@@ -75,18 +76,20 @@ pub fn run_background(lib_path: &str,\n            prog: &str,\n            args: &[~str],\n            env: ~[(~str, ~str)],\n-           input: Option<~str>) -> Option<run::Process> {\n+           input: Option<~str>) -> Option<Process> {\n \n     let env = env + target_env(lib_path, prog);\n-    let opt_process = run::Process::new(prog, args, run::ProcessOptions {\n-        env: Some(env),\n-        .. run::ProcessOptions::new()\n+    let opt_process = Process::configure(ProcessConfig {\n+        program: prog,\n+        args: args,\n+        env: Some(env.as_slice()),\n+        .. ProcessConfig::new()\n     });\n \n     match opt_process {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.input().write(input.as_bytes()).unwrap();\n+                process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n             }\n \n             Some(process)"}, {"sha": "ac0042682df404804e0278710fb0d333901f2fe2", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -360,7 +360,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n                                stdout: out,\n                                stderr: err,\n                                cmdline: cmdline};\n-            process.force_destroy().unwrap();\n+            process.signal_kill().unwrap();\n         }\n \n         _=> {"}, {"sha": "133e5bc71f8f7d47cdf974ea00cee5bb821737bd", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -464,8 +464,8 @@ impl<'a, T:Send +\n #[test]\n #[cfg(not(target_os=\"android\"))] // FIXME(#10455)\n fn test() {\n-    use std::{os, run};\n-    use std::io::fs;\n+    use std::os;\n+    use std::io::{fs, Process};\n     use std::str::from_utf8_owned;\n \n     // Create a path to a new file 'filename' in the directory in which\n@@ -499,9 +499,9 @@ fn test() {\n         prep.exec(proc(_exe) {\n             let out = make_path(~\"foo.o\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n-            run::process_status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n-                                        ~\"-o\",\n-                                        out.as_str().unwrap().to_owned()]).unwrap();\n+            Process::status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n+                                    ~\"-o\",\n+                                    out.as_str().unwrap().to_owned()]).unwrap();\n \n             let _proof_of_concept = subcx.prep(\"subfn\");\n             // Could run sub-rules inside here."}, {"sha": "2f4dc7817d353ba6f1ca17fea8d1c437e0c45ccb", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -287,6 +287,9 @@ impl rtio::IoFactory for IoFactory {\n              io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe)).collect())\n         })\n     }\n+    fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n+        process::Process::kill(pid, signum)\n+    }\n     fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe> {\n         Ok(~file::FileDesc::new(fd, true) as ~RtioPipe)\n     }"}, {"sha": "0b833f473955eaf7e22ac7a116c64b60d75bd7e1", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 62, "deletions": 36, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -66,35 +66,33 @@ impl Process {\n         -> Result<(Process, ~[Option<file::FileDesc>]), io::IoError>\n     {\n         // right now we only handle stdin/stdout/stderr.\n-        if config.io.len() > 3 {\n+        if config.extra_io.len() > 0 {\n             return Err(super::unimpl());\n         }\n \n-        fn get_io(io: &[p::StdioContainer],\n-                  ret: &mut ~[Option<file::FileDesc>],\n-                  idx: uint) -> (Option<os::Pipe>, c_int) {\n-            if idx >= io.len() { return (None, -1); }\n-            ret.push(None);\n-            match io[idx] {\n-                p::Ignored => (None, -1),\n-                p::InheritFd(fd) => (None, fd),\n+        fn get_io(io: p::StdioContainer, ret: &mut ~[Option<file::FileDesc>])\n+            -> (Option<os::Pipe>, c_int)\n+        {\n+            match io {\n+                p::Ignored => { ret.push(None); (None, -1) }\n+                p::InheritFd(fd) => { ret.push(None); (None, fd) }\n                 p::CreatePipe(readable, _writable) => {\n                     let pipe = os::pipe();\n                     let (theirs, ours) = if readable {\n                         (pipe.input, pipe.out)\n                     } else {\n                         (pipe.out, pipe.input)\n                     };\n-                    ret[idx] = Some(file::FileDesc::new(ours, true));\n+                    ret.push(Some(file::FileDesc::new(ours, true)));\n                     (Some(pipe), theirs)\n                 }\n             }\n         }\n \n         let mut ret_io = ~[];\n-        let (in_pipe, in_fd) = get_io(config.io, &mut ret_io, 0);\n-        let (out_pipe, out_fd) = get_io(config.io, &mut ret_io, 1);\n-        let (err_pipe, err_fd) = get_io(config.io, &mut ret_io, 2);\n+        let (in_pipe, in_fd) = get_io(config.stdin, &mut ret_io);\n+        let (out_pipe, out_fd) = get_io(config.stdout, &mut ret_io);\n+        let (err_pipe, err_fd) = get_io(config.stderr, &mut ret_io);\n \n         let env = config.env.map(|a| a.to_owned());\n         let cwd = config.cwd.map(|a| Path::new(a));\n@@ -115,6 +113,10 @@ impl Process {\n             Err(e) => Err(e)\n         }\n     }\n+\n+    pub fn kill(pid: libc::pid_t, signum: int) -> IoResult<()> {\n+        unsafe { killpid(pid, signum) }\n+    }\n }\n \n impl rtio::RtioProcess for Process {\n@@ -144,34 +146,58 @@ impl rtio::RtioProcess for Process {\n             None => {}\n         }\n         return unsafe { killpid(self.pid, signum) };\n+    }\n+}\n \n-        #[cfg(windows)]\n-        unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n-            match signal {\n-                io::process::PleaseExitSignal | io::process::MustDieSignal => {\n-                    let ret = libc::TerminateProcess(pid as libc::HANDLE, 1);\n-                    super::mkerr_winbool(ret)\n-                }\n-                _ => Err(io::IoError {\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        free_handle(self.handle);\n+    }\n+}\n+\n+#[cfg(windows)]\n+unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+    let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n+                                   libc::PROCESS_QUERY_INFORMATION,\n+                                   libc::FALSE, pid as libc::DWORD);\n+    if handle.is_null() {\n+        return Err(super::last_error())\n+    }\n+    let ret = match signal {\n+        // test for existence on signal 0\n+        0 => {\n+            let mut status = 0;\n+            let ret = libc::GetExitCodeProcess(handle, &mut status);\n+            if ret == 0 {\n+                Err(super::last_error())\n+            } else if status != libc::STILL_ACTIVE {\n+                Err(io::IoError {\n                     kind: io::OtherIoError,\n-                    desc: \"unsupported signal on windows\",\n+                    desc: \"process no longer alive\",\n                     detail: None,\n                 })\n+            } else {\n+                Ok(())\n             }\n         }\n-\n-        #[cfg(not(windows))]\n-        unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n-            let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            super::mkerr_libc(r)\n+        io::process::PleaseExitSignal | io::process::MustDieSignal => {\n+            let ret = libc::TerminateProcess(handle, 1);\n+            super::mkerr_winbool(ret)\n         }\n-    }\n+        _ => Err(io::IoError {\n+            kind: io::OtherIoError,\n+            desc: \"unsupported signal on windows\",\n+            detail: None,\n+        })\n+    };\n+    let _ = libc::CloseHandle(handle);\n+    return ret;\n }\n \n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        free_handle(self.handle);\n-    }\n+#[cfg(not(windows))]\n+unsafe fn killpid(pid: pid_t, signal: int) -> Result<(), io::IoError> {\n+    let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n+    super::mkerr_libc(r)\n }\n \n struct SpawnProcessResult {\n@@ -536,10 +562,10 @@ fn spawn_process_os(config: p::ProcessConfig,\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-        });\n-        with_argv(config.program, config.args, |argv| {\n-            let _ = execvp(*argv, argv);\n-            fail(&mut output);\n+            with_argv(config.program, config.args, |argv| {\n+                let _ = execvp(*argv, argv);\n+                fail(&mut output);\n+            })\n         })\n     }\n }"}, {"sha": "1df34576c3e6e01654aeb1a0d43af30e7c5dba02", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -20,7 +20,7 @@ use std::io::fs;\n use std::io;\n use std::libc;\n use std::os;\n-use std::run::{ProcessOptions, Process, ProcessOutput};\n+use std::io::process::{ProcessConfig, Process, ProcessOutput};\n use std::str;\n use std::raw;\n use extra::tempfile::TempDir;\n@@ -44,16 +44,19 @@ fn run_ar(sess: Session, args: &str, cwd: Option<&Path>,\n     let mut args = ~[args.to_owned()];\n     let mut paths = paths.iter().map(|p| p.as_str().unwrap().to_owned());\n     args.extend(&mut paths);\n-    let mut opts = ProcessOptions::new();\n-    opts.dir = cwd;\n     debug!(\"{} {}\", ar, args.connect(\" \"));\n     match cwd {\n         Some(p) => { debug!(\"inside {}\", p.display()); }\n         None => {}\n     }\n-    match Process::new(ar, args.as_slice(), opts) {\n+    match Process::configure(ProcessConfig {\n+        program: ar.as_slice(),\n+        args: args.as_slice(),\n+        cwd: cwd.map(|a| &*a),\n+        .. ProcessConfig::new()\n+    }) {\n         Ok(mut prog) => {\n-            let o = prog.finish_with_output();\n+            let o = prog.wait_with_output();\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n                                  o.status));"}, {"sha": "89cdd4dbe779c4ff3b1266ad3acd28a6df4ca453", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -30,9 +30,9 @@ use std::c_str::ToCStr;\n use std::char;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::ptr;\n-use std::run;\n use std::str;\n use std::io;\n+use std::io::Process;\n use std::io::fs;\n use flate;\n use serialize::hex::ToHex;\n@@ -101,8 +101,8 @@ pub mod write {\n     use syntax::abi;\n \n     use std::c_str::ToCStr;\n+    use std::io::Process;\n     use std::libc::{c_uint, c_int};\n-    use std::run;\n     use std::str;\n \n     // On android, we by default compile for armv7 processors. This enables\n@@ -333,7 +333,7 @@ pub mod write {\n             assembly.as_str().unwrap().to_owned()];\n \n         debug!(\"{} '{}'\", cc, args.connect(\"' '\"));\n-        match run::process_output(cc, args) {\n+        match Process::output(cc, args) {\n             Ok(prog) => {\n                 if !prog.status.success() {\n                     sess.err(format!(\"linking with `{}` failed: {}\", cc, prog.status));\n@@ -1033,7 +1033,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n     let prog = time(sess.time_passes(), \"running linker\", (), |()|\n-                    run::process_output(cc_prog, cc_args));\n+                    Process::output(cc_prog, cc_args));\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n@@ -1054,7 +1054,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     // the symbols\n     if sess.targ_cfg.os == abi::OsMacos && sess.opts.debuginfo {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        match run::process_status(\"dsymutil\",\n+        match Process::status(\"dsymutil\",\n                                   [out_filename.as_str().unwrap().to_owned()]) {\n             Ok(..) => {}\n             Err(e) => {"}, {"sha": "ae22d9c84dccc7205a201b7b127904e5bd5d3756", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use collections::HashSet;\n+use std::io::Process;\n use std::local_data;\n use std::os;\n-use std::run;\n use std::str;\n \n+use collections::HashSet;\n use testing;\n use extra::tempfile::TempDir;\n use rustc::back::link;\n@@ -126,7 +126,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool)\n     driver::compile_input(sess, cfg, &input, &out, &None);\n \n     let exe = outdir.path().join(\"rust_out\");\n-    let out = run::process_output(exe.as_str().unwrap(), []);\n+    let out = Process::output(exe.as_str().unwrap(), []);\n     match out {\n         Err(e) => fail!(\"couldn't run the test: {}\", e),\n         Ok(out) => {"}, {"sha": "8a6b4d3150eb8828840b6cff3f1e22a9b695b64d", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -44,7 +44,10 @@ impl Process {\n                 -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n-        let io = config.io;\n+        let mut io = ~[config.stdin, config.stdout, config.stderr];\n+        for slot in config.extra_io.iter() {\n+            io.push(*slot);\n+        }\n         let mut stdio = vec::with_capacity::<uvll::uv_stdio_container_t>(io.len());\n         let mut ret_io = vec::with_capacity(io.len());\n         unsafe {\n@@ -105,6 +108,15 @@ impl Process {\n             Err(e) => Err(e),\n         }\n     }\n+\n+    pub fn kill(pid: libc::pid_t, signum: int) -> Result<(), UvError> {\n+        match unsafe {\n+            uvll::uv_kill(pid as libc::c_int, signum as libc::c_int)\n+        } {\n+            0 => Ok(()),\n+            n => Err(UvError(n))\n+        }\n+    }\n }\n \n extern fn on_exit(handle: *uvll::uv_process_t,"}, {"sha": "c49a24889a14ca38d14c611eba06cdba956ee8ab", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -277,6 +277,10 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n+    fn kill(&mut self, pid: libc::pid_t, signum: int) -> Result<(), IoError> {\n+        Process::kill(pid, signum).map_err(uv_error_to_io_error)\n+    }\n+\n     fn unix_bind(&mut self, path: &CString) -> Result<~rtio::RtioUnixListener, IoError>\n     {\n         match PipeListener::bind(self, path) {"}, {"sha": "039f2e8bc85de848eb81d33ae6815bf458529966", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -645,6 +645,7 @@ extern {\n     pub fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,\n                     options: *uv_process_options_t) -> c_int;\n     pub fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n+    pub fn uv_kill(pid: c_int, signum: c_int) -> c_int;\n \n     // pipes\n     pub fn uv_pipe_init(l: *uv_loop_t, p: *uv_pipe_t, ipc: c_int) -> c_int;"}, {"sha": "58c0caa34026f90300a2f0a8a9db371698a1950e", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -1108,6 +1108,7 @@ mod test {\n         drop(file);\n     })\n \n+    #[ignore(cfg(windows))] // FIXME(#11638)\n     iotest!(fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");"}, {"sha": "14d5fabeaa1bfa6fc157089bd347f32cca484fde", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -293,7 +293,7 @@ pub use self::net::tcp::TcpListener;\n pub use self::net::tcp::TcpStream;\n pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n-pub use self::process::Process;\n+pub use self::process::{Process, ProcessConfig};\n \n pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n pub use self::buffered::{BufferedReader, BufferedWriter, BufferedStream,"}, {"sha": "b3365726465417352e6bb3c1c17dd33a25ec9125", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 519, "deletions": 78, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -10,29 +10,82 @@\n \n //! Bindings for executing child processes\n \n+#[deny(missing_doc)];\n+\n use prelude::*;\n \n-use libc;\n-use io;\n+use fmt;\n use io::IoResult;\n+use io;\n+use libc;\n use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n \n-use fmt;\n-\n-// windows values don't matter as long as they're at least one of unix's\n-// TERM/KILL/INT signals\n+/// Signal a process to exit, without forcibly killing it. Corresponds to\n+/// SIGTERM on unix platforms.\n #[cfg(windows)] pub static PleaseExitSignal: int = 15;\n+/// Signal a process to exit immediately, forcibly killing it. Corresponds to\n+/// SIGKILL on unix platforms.\n #[cfg(windows)] pub static MustDieSignal: int = 9;\n+/// Signal a process to exit, without forcibly killing it. Corresponds to\n+/// SIGTERM on unix platforms.\n #[cfg(not(windows))] pub static PleaseExitSignal: int = libc::SIGTERM as int;\n+/// Signal a process to exit immediately, forcibly killing it. Corresponds to\n+/// SIGKILL on unix platforms.\n #[cfg(not(windows))] pub static MustDieSignal: int = libc::SIGKILL as int;\n \n+/// Representation of a running or exited child process.\n+///\n+/// This structure is used to create, run, and manage child processes. A process\n+/// is configured with the `ProcessConfig` struct which contains specific\n+/// options for dictating how the child is spawned.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// use std::io::Process;\n+///\n+/// let mut child = match Process::new(\"/bin/cat\", [~\"file.txt\"]) {\n+///     Ok(child) => child,\n+///     Err(e) => fail!(\"failed to execute child: {}\", e),\n+/// };\n+///\n+/// let contents = child.stdout.get_mut_ref().read_to_end();\n+/// assert!(child.wait().success());\n+/// ```\n pub struct Process {\n     priv handle: ~RtioProcess,\n-    io: ~[Option<io::PipeStream>],\n+\n+    /// Handle to the child's stdin, if the `stdin` field of this process's\n+    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n+    stdin: Option<io::PipeStream>,\n+\n+    /// Handle to the child's stdout, if the `stdout` field of this process's\n+    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n+    stdout: Option<io::PipeStream>,\n+\n+    /// Handle to the child's stderr, if the `stderr` field of this process's\n+    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n+    stderr: Option<io::PipeStream>,\n+\n+    /// Extra I/O handles as configured by the original `ProcessConfig` when\n+    /// this process was created. This is by default empty.\n+    extra_io: ~[Option<io::PipeStream>],\n }\n \n-/// This configuration describes how a new process should be spawned. This is\n-/// translated to libuv's own configuration\n+/// This configuration describes how a new process should be spawned. A blank\n+/// configuration can be created with `ProcessConfig::new()`. It is also\n+/// recommented to use a functional struct update pattern when creating process\n+/// configuration:\n+///\n+/// ```\n+/// use std::io::ProcessConfig;\n+///\n+/// let config = ProcessConfig {\n+///     program: \"/bin/sh\",\n+///     args: &[~\"-c\", ~\"true\"],\n+///     .. ProcessConfig::new()\n+/// };\n+/// ```\n pub struct ProcessConfig<'a> {\n     /// Path to the program to run\n     program: &'a str,\n@@ -46,19 +99,30 @@ pub struct ProcessConfig<'a> {\n \n     /// Optional working directory for the new process. If this is None, then\n     /// the current directory of the running process is inherited.\n-    cwd: Option<&'a str>,\n+    cwd: Option<&'a Path>,\n+\n+    /// Configuration for the child process's stdin handle (file descriptor 0).\n+    /// This field defaults to `CreatePipe(true, false)` so the input can be\n+    /// written to.\n+    stdin: StdioContainer,\n+\n+    /// Configuration for the child process's stdout handle (file descriptor 1).\n+    /// This field defaults to `CreatePipe(false, true)` so the output can be\n+    /// collected.\n+    stdout: StdioContainer,\n+\n+    /// Configuration for the child process's stdout handle (file descriptor 2).\n+    /// This field defaults to `CreatePipe(false, true)` so the output can be\n+    /// collected.\n+    stderr: StdioContainer,\n \n     /// Any number of streams/file descriptors/pipes may be attached to this\n     /// process. This list enumerates the file descriptors and such for the\n     /// process to be spawned, and the file descriptors inherited will start at\n-    /// 0 and go to the length of this array.\n-    ///\n-    /// Standard file descriptors are:\n-    ///\n-    ///     0 - stdin\n-    ///     1 - stdout\n-    ///     2 - stderr\n-    io: &'a [StdioContainer],\n+    /// 3 and go to the length of this array. The first three file descriptors\n+    /// (stdin/stdout/stderr) are configured with the `stdin`, `stdout`, and\n+    /// `stderr` fields.\n+    extra_io: &'a [StdioContainer],\n \n     /// Sets the child process's user id. This translates to a `setuid` call in\n     /// the child process. Setting this value on windows will cause the spawn to\n@@ -75,6 +139,16 @@ pub struct ProcessConfig<'a> {\n     detach: bool,\n }\n \n+/// The output of a finished process.\n+pub struct ProcessOutput {\n+    /// The status (exit code) of the process.\n+    status: ProcessExit,\n+    /// The data that the process wrote to stdout.\n+    output: ~[u8],\n+    /// The data that the process wrote to stderr.\n+    error: ~[u8],\n+}\n+\n /// Describes what to do with a standard io stream for a child process.\n pub enum StdioContainer {\n     /// This stream will be ignored. This is the equivalent of attaching the\n@@ -138,20 +212,23 @@ impl<'a> ProcessConfig<'a> {\n     ///\n     /// let config = ProcessConfig {\n     ///     program: \"/bin/sh\",\n-    ///     args: &'static [~\"-c\", ~\"echo hello\"],\n+    ///     args: &[~\"-c\", ~\"echo hello\"],\n     ///     .. ProcessConfig::new()\n     /// };\n     ///\n-    /// let p = Process::new(config);\n+    /// let p = Process::configure(config);\n     /// ```\n     ///\n-    pub fn new() -> ProcessConfig<'static> {\n+    pub fn new<'a>() -> ProcessConfig<'a> {\n         ProcessConfig {\n             program: \"\",\n-            args: &'static [],\n+            args: &[],\n             env: None,\n             cwd: None,\n-            io: &'static [],\n+            stdin: CreatePipe(true, false),\n+            stdout: CreatePipe(false, true),\n+            stderr: CreatePipe(false, true),\n+            extra_io: &[],\n             uid: None,\n             gid: None,\n             detach: false,\n@@ -160,22 +237,105 @@ impl<'a> ProcessConfig<'a> {\n }\n \n impl Process {\n-    /// Creates a new pipe initialized, but not bound to any particular\n-    /// source/destination\n-    pub fn new(config: ProcessConfig) -> IoResult<Process> {\n+    /// Creates a new process for the specified program/arguments, using\n+    /// otherwise default configuration.\n+    ///\n+    /// By default, new processes have their stdin/stdout/stderr handles created\n+    /// as pipes the can be manipulated through the respective fields of the\n+    /// returned `Process`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::io::Process;\n+    ///\n+    /// let mut process = match Process::new(\"sh\", &[~\"c\", ~\"echo hello\"]) {\n+    ///     Ok(p) => p,\n+    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    /// };\n+    ///\n+    /// let output = process.stdout.get_mut_ref().read_to_end();\n+    /// ```\n+    pub fn new(prog: &str, args: &[~str]) -> IoResult<Process> {\n+        Process::configure(ProcessConfig {\n+            program: prog,\n+            args: args,\n+            .. ProcessConfig::new()\n+        })\n+    }\n+\n+    /// Executes the specified program with arguments, waiting for it to finish\n+    /// and collecting all of its output.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::io::Process;\n+    /// use std::str;\n+    ///\n+    /// let output = match Process::output(\"cat\", [~\"foo.txt\"]) {\n+    ///     Ok(output) => output,\n+    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    /// };\n+    ///\n+    /// println!(\"status: {}\", output.status);\n+    /// println!(\"stdout: {}\", str::from_utf8_lossy(output.output));\n+    /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error));\n+    /// ```\n+    pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {\n+        Process::new(prog, args).map(|mut p| p.wait_with_output())\n+    }\n+\n+    /// Executes a child process and collects its exit status. This will block\n+    /// waiting for the child to exit.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::io::Process;\n+    ///\n+    /// let status = match Process::status(\"ls\", []) {\n+    ///     Ok(status) => status,\n+    ///     Err(e) => fail!(\"failed to execute process: {}\", e),\n+    /// };\n+    ///\n+    /// println!(\"process exited with: {}\", status);\n+    /// ```\n+    pub fn status(prog: &str, args: &[~str]) -> IoResult<ProcessExit> {\n+        Process::new(prog, args).map(|mut p| p.wait())\n+    }\n+\n+    /// Creates a new process with the specified configuration.\n+    pub fn configure(config: ProcessConfig) -> IoResult<Process> {\n         let mut config = Some(config);\n         LocalIo::maybe_raise(|io| {\n             io.spawn(config.take_unwrap()).map(|(p, io)| {\n+                let mut io = io.move_iter().map(|p| {\n+                    p.map(|p| io::PipeStream::new(p))\n+                });\n                 Process {\n                     handle: p,\n-                    io: io.move_iter().map(|p| {\n-                        p.map(|p| io::PipeStream::new(p))\n-                    }).collect()\n+                    stdin: io.next().unwrap(),\n+                    stdout: io.next().unwrap(),\n+                    stderr: io.next().unwrap(),\n+                    extra_io: io.collect(),\n                 }\n             })\n         })\n     }\n \n+    /// Sends `signal` to another process in the system identified by `id`.\n+    ///\n+    /// Note that windows doesn't quite have the same model as unix, so some\n+    /// unix signals are mapped to windows signals. Notably, unix termination\n+    /// signals (SIGTERM/SIGKILL/SIGINT) are translated to `TerminateProcess`.\n+    ///\n+    /// Additionally, a signal number of 0 can check for existence of the target\n+    /// process.\n+    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n+        LocalIo::maybe_raise(|io| io.kill(id, signal))\n+    }\n+\n     /// Returns the process id of this child process\n     pub fn id(&self) -> libc::pid_t { self.handle.id() }\n \n@@ -190,18 +350,66 @@ impl Process {\n         self.handle.kill(signal)\n     }\n \n+    /// Sends a signal to this child requesting that it exits. This is\n+    /// equivalent to sending a SIGTERM on unix platforms.\n+    pub fn signal_exit(&mut self) -> IoResult<()> {\n+        self.signal(PleaseExitSignal)\n+    }\n+\n+    /// Sends a signal to this child forcing it to exit. This is equivalent to\n+    /// sending a SIGKILL on unix platforms.\n+    pub fn signal_kill(&mut self) -> IoResult<()> {\n+        self.signal(MustDieSignal)\n+    }\n+\n     /// Wait for the child to exit completely, returning the status that it\n     /// exited with. This function will continue to have the same return value\n     /// after it has been called at least once.\n-    pub fn wait(&mut self) -> ProcessExit { self.handle.wait() }\n+    ///\n+    /// The stdin handle to the child process will be closed before waiting.\n+    pub fn wait(&mut self) -> ProcessExit {\n+        drop(self.stdin.take());\n+        self.handle.wait()\n+    }\n+\n+    /// Simultaneously wait for the child to exit and collect all remaining\n+    /// output on the stdout/stderr handles, returning a `ProcessOutput`\n+    /// instance.\n+    ///\n+    /// The stdin handle to the child is closed before waiting.\n+    pub fn wait_with_output(&mut self) -> ProcessOutput {\n+        drop(self.stdin.take());\n+        fn read(stream: Option<io::PipeStream>) -> Port<IoResult<~[u8]>> {\n+            let (p, c) = Chan::new();\n+            match stream {\n+                Some(stream) => spawn(proc() {\n+                    let mut stream = stream;\n+                    c.send(stream.read_to_end())\n+                }),\n+                None => c.send(Ok(~[]))\n+            }\n+            p\n+        }\n+        let stdout = read(self.stdout.take());\n+        let stderr = read(self.stderr.take());\n+\n+        let status = self.wait();\n+\n+        ProcessOutput { status: status,\n+                        output: stdout.recv().ok().unwrap_or(~[]),\n+                        error:  stderr.recv().ok().unwrap_or(~[]) }\n+    }\n }\n \n impl Drop for Process {\n     fn drop(&mut self) {\n         // Close all I/O before exiting to ensure that the child doesn't wait\n         // forever to print some text or something similar.\n+        drop(self.stdin.take());\n+        drop(self.stdout.take());\n+        drop(self.stderr.take());\n         loop {\n-            match self.io.pop() {\n+            match self.extra_io.pop() {\n                 Some(_) => (),\n                 None => break,\n             }\n@@ -216,42 +424,39 @@ mod tests {\n     use io::process::{ProcessConfig, Process};\n     use prelude::*;\n \n-    // FIXME(#10380)\n-    #[cfg(unix, not(target_os=\"android\"))]\n+    // FIXME(#10380) these tests should not all be ignored on android.\n+\n+    #[cfg(not(target_os=\"android\"))]\n     iotest!(fn smoke() {\n         let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"true\"],\n+            program: \"true\",\n             .. ProcessConfig::new()\n         };\n-        let p = Process::new(args);\n+        let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().success());\n     })\n \n-    // FIXME(#10380)\n-    #[cfg(unix, not(target_os=\"android\"))]\n+    #[cfg(not(target_os=\"android\"))]\n     iotest!(fn smoke_failure() {\n         let args = ProcessConfig {\n             program: \"if-this-is-a-binary-then-the-world-has-ended\",\n             .. ProcessConfig::new()\n         };\n-        match Process::new(args) {\n+        match Process::configure(args) {\n             Ok(..) => fail!(),\n             Err(..) => {}\n         }\n     })\n \n-    // FIXME(#10380)\n-    #[cfg(unix, not(target_os=\"android\"))]\n+    #[cfg(not(target_os=\"android\"))]\n     iotest!(fn exit_reported_right() {\n         let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"exit 1\"],\n+            program: \"false\",\n             .. ProcessConfig::new()\n         };\n-        let p = Process::new(args);\n+        let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         assert!(p.wait().matches_exit_status(1));\n@@ -264,7 +469,7 @@ mod tests {\n             args: &[~\"-c\", ~\"kill -1 $$\"],\n             .. ProcessConfig::new()\n         };\n-        let p = Process::new(args);\n+        let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n         match p.wait() {\n@@ -278,73 +483,64 @@ mod tests {\n     }\n \n     pub fn run_output(args: ProcessConfig) -> ~str {\n-        let p = Process::new(args);\n+        let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        assert!(p.io[0].is_none());\n-        assert!(p.io[1].is_some());\n-        let ret = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        assert!(p.stdout.is_some());\n+        let ret = read_all(p.stdout.get_mut_ref() as &mut Reader);\n         assert!(p.wait().success());\n         return ret;\n     }\n \n-    // FIXME(#10380)\n-    #[cfg(unix, not(target_os=\"android\"))]\n+    #[cfg(not(target_os=\"android\"))]\n     iotest!(fn stdout_works() {\n-        let io = ~[Ignored, CreatePipe(false, true)];\n         let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"echo foobar\"],\n-            io: io,\n+            program: \"echo\",\n+            args: &[~\"foobar\"],\n+            stdout: CreatePipe(false, true),\n             .. ProcessConfig::new()\n         };\n         assert_eq!(run_output(args), ~\"foobar\\n\");\n     })\n \n-    // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn set_cwd_works() {\n-        let io = ~[Ignored, CreatePipe(false, true)];\n-        let cwd = Some(\"/\");\n+        let cwd = Path::new(\"/\");\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"pwd\"],\n-            cwd: cwd,\n-            io: io,\n+            cwd: Some(&cwd),\n+            stdout: CreatePipe(false, true),\n             .. ProcessConfig::new()\n         };\n         assert_eq!(run_output(args), ~\"/\\n\");\n     })\n \n-    // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn stdin_works() {\n-        let io = ~[CreatePipe(true, false),\n-                   CreatePipe(false, true)];\n         let args = ProcessConfig {\n             program: \"/bin/sh\",\n             args: &[~\"-c\", ~\"read line; echo $line\"],\n-            io: io,\n+            stdin: CreatePipe(true, false),\n+            stdout: CreatePipe(false, true),\n             .. ProcessConfig::new()\n         };\n-        let mut p = Process::new(args).unwrap();\n-        p.io[0].get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n-        p.io[0] = None; // close stdin;\n-        let out = read_all(p.io[1].get_mut_ref() as &mut Reader);\n+        let mut p = Process::configure(args).unwrap();\n+        p.stdin.get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n+        drop(p.stdin.take());\n+        let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n         assert!(p.wait().success());\n         assert_eq!(out, ~\"foobar\\n\");\n     })\n \n-    // FIXME(#10380)\n-    #[cfg(unix, not(target_os=\"android\"))]\n+    #[cfg(not(target_os=\"android\"))]\n     iotest!(fn detach_works() {\n         let args = ProcessConfig {\n-            program: \"/bin/sh\",\n-            args: &[~\"-c\", ~\"true\"],\n+            program: \"true\",\n             detach: true,\n             .. ProcessConfig::new()\n         };\n-        let mut p = Process::new(args).unwrap();\n+        let mut p = Process::configure(args).unwrap();\n         assert!(p.wait().success());\n     })\n \n@@ -355,10 +551,9 @@ mod tests {\n             uid: Some(10),\n             .. ProcessConfig::new()\n         };\n-        assert!(Process::new(args).is_err());\n+        assert!(Process::configure(args).is_err());\n     })\n \n-    // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn uid_works() {\n         use libc;\n@@ -369,11 +564,10 @@ mod tests {\n             gid: Some(unsafe { libc::getgid() as uint }),\n             .. ProcessConfig::new()\n         };\n-        let mut p = Process::new(args).unwrap();\n+        let mut p = Process::configure(args).unwrap();\n         assert!(p.wait().success());\n     })\n \n-    // FIXME(#10380)\n     #[cfg(unix, not(target_os=\"android\"))]\n     iotest!(fn uid_to_root_fails() {\n         use libc;\n@@ -387,6 +581,253 @@ mod tests {\n             gid: Some(0),\n             .. ProcessConfig::new()\n         };\n-        assert!(Process::new(args).is_err());\n+        assert!(Process::configure(args).is_err());\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_process_status() {\n+        let mut status = Process::status(\"false\", []).unwrap();\n+        assert!(status.matches_exit_status(1));\n+\n+        status = Process::status(\"true\", []).unwrap();\n+        assert!(status.success());\n+    })\n+\n+    iotest!(fn test_process_output_fail_to_start() {\n+        match Process::output(\"/no-binary-by-this-name-should-exist\", []) {\n+            Err(e) => assert_eq!(e.kind, FileNotFound),\n+            Ok(..) => fail!()\n+        }\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_process_output_output() {\n+\n+        let ProcessOutput {status, output, error}\n+             = Process::output(\"echo\", [~\"hello\"]).unwrap();\n+        let output_str = str::from_utf8_owned(output).unwrap();\n+\n+        assert!(status.success());\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_process_output_error() {\n+        let ProcessOutput {status, output, error}\n+             = Process::output(\"mkdir\", [~\".\"]).unwrap();\n+\n+        assert!(status.matches_exit_status(1));\n+        assert_eq!(output, ~[]);\n+        assert!(!error.is_empty());\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_finish_once() {\n+        let mut prog = Process::new(\"false\", []).unwrap();\n+        assert!(prog.wait().matches_exit_status(1));\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_finish_twice() {\n+        let mut prog = Process::new(\"false\", []).unwrap();\n+        assert!(prog.wait().matches_exit_status(1));\n+        assert!(prog.wait().matches_exit_status(1));\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_wait_with_output_once() {\n+\n+        let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n+        let ProcessOutput {status, output, error} = prog.wait_with_output();\n+        let output_str = str::from_utf8_owned(output).unwrap();\n+\n+        assert!(status.success());\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+    })\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_wait_with_output_twice() {\n+        let mut prog = Process::new(\"echo\", [~\"hello\"]).unwrap();\n+        let ProcessOutput {status, output, error} = prog.wait_with_output();\n+\n+        let output_str = str::from_utf8_owned(output).unwrap();\n+\n+        assert!(status.success());\n+        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+\n+        let ProcessOutput {status, output, error} = prog.wait_with_output();\n+\n+        assert!(status.success());\n+        assert_eq!(output, ~[]);\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(error, ~[]);\n+        }\n+    })\n+\n+    #[cfg(unix,not(target_os=\"android\"))]\n+    pub fn run_pwd(dir: Option<&Path>) -> Process {\n+        Process::configure(ProcessConfig {\n+            program: \"pwd\",\n+            cwd: dir,\n+            .. ProcessConfig::new()\n+        }).unwrap()\n+    }\n+    #[cfg(target_os=\"android\")]\n+    pub fn run_pwd(dir: Option<&Path>) -> Process {\n+        Process::configure(ProcessConfig {\n+            program: \"/system/bin/sh\",\n+            args: &[~\"-c\",~\"pwd\"],\n+            cwd: dir.map(|a| &*a),\n+            .. ProcessConfig::new()\n+        }).unwrap()\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn run_pwd(dir: Option<&Path>) -> Process {\n+        Process::configure(ProcessConfig {\n+            program: \"cmd\",\n+            args: &[~\"/c\", ~\"cd\"],\n+            cwd: dir.map(|a| &*a),\n+            .. ProcessConfig::new()\n+        }).unwrap()\n+    }\n+\n+    iotest!(fn test_keep_current_working_dir() {\n+        use os;\n+        let mut prog = run_pwd(None);\n+\n+        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let parent_dir = os::getcwd();\n+        let child_dir = Path::new(output.trim());\n+\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n+\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n+    })\n+\n+    iotest!(fn test_change_working_directory() {\n+        use os;\n+        // test changing to the parent of os::getcwd() because we know\n+        // the path exists (and os::getcwd() is not expected to be root)\n+        let parent_dir = os::getcwd().dir_path();\n+        let mut prog = run_pwd(Some(&parent_dir));\n+\n+        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+        let child_dir = Path::new(output.trim());\n+\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n+\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n+    })\n+\n+    #[cfg(unix,not(target_os=\"android\"))]\n+    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n+        Process::configure(ProcessConfig {\n+            program: \"env\",\n+            env: env.as_ref().map(|e| e.as_slice()),\n+            .. ProcessConfig::new()\n+        }).unwrap()\n+    }\n+    #[cfg(target_os=\"android\")]\n+    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n+        Process::configure(ProcessConfig {\n+            program: \"/system/bin/sh\",\n+            args: &[~\"-c\",~\"set\"],\n+            env: env.as_ref().map(|e| e.as_slice()),\n+            .. ProcessConfig::new()\n+        }).unwrap()\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn run_env(env: Option<~[(~str, ~str)]>) -> Process {\n+        Process::configure(ProcessConfig {\n+            program: \"cmd\",\n+            args: &[~\"/c\", ~\"set\"],\n+            env: env.as_ref().map(|e| e.as_slice()),\n+            .. ProcessConfig::new()\n+        }).unwrap()\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    iotest!(fn test_inherit_env() {\n+        use os;\n+        if running_on_valgrind() { return; }\n+\n+        let mut prog = run_env(None);\n+        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+\n+        let r = os::env();\n+        for &(ref k, ref v) in r.iter() {\n+            // don't check windows magical empty-named variables\n+            assert!(k.is_empty() || output.contains(format!(\"{}={}\", *k, *v)));\n+        }\n+    })\n+    #[cfg(target_os=\"android\")]\n+    iotest!(fn test_inherit_env() {\n+        use os;\n+        if running_on_valgrind() { return; }\n+\n+        let mut prog = run_env(None);\n+        let output = str::from_utf8_owned(prog.wait_with_output().output).unwrap();\n+\n+        let r = os::env();\n+        for &(ref k, ref v) in r.iter() {\n+            // don't check android RANDOM variables\n+            if *k != ~\"RANDOM\" {\n+                assert!(output.contains(format!(\"{}={}\", *k, *v)) ||\n+                        output.contains(format!(\"{}=\\'{}\\'\", *k, *v)));\n+            }\n+        }\n+    })\n+\n+    iotest!(fn test_add_to_env() {\n+        let new_env = ~[(~\"RUN_TEST_NEW_ENV\", ~\"123\")];\n+\n+        let mut prog = run_env(Some(new_env));\n+        let result = prog.wait_with_output();\n+        let output = str::from_utf8_lossy(result.output).into_owned();\n+\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+    })\n+\n+    #[cfg(unix)]\n+    pub fn sleeper() -> Process {\n+        Process::new(\"sleep\", [~\"1000\"]).unwrap()\n+    }\n+    #[cfg(windows)]\n+    pub fn sleeper() -> Process {\n+        Process::new(\"timeout\", [~\"1000\"]).unwrap()\n+    }\n+\n+    iotest!(fn test_kill() {\n+        let mut p = sleeper();\n+        Process::kill(p.id(), PleaseExitSignal).unwrap();\n+        assert!(!p.wait().success());\n+    })\n+\n+    #[ignore(cfg(windows))]\n+    iotest!(fn test_exists() {\n+        let mut p = sleeper();\n+        assert!(Process::kill(p.id(), 0).is_ok());\n+        p.signal_kill().unwrap();\n+        assert!(!p.wait().success());\n     })\n }"}, {"sha": "4b499aa5c12ce01daa15e49149062b5d3decda69", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -36,6 +36,7 @@ macro_rules! iotest (\n             use io::net::unix::*;\n             use io::timer::*;\n             use io::process::*;\n+            use unstable::running_on_valgrind;\n             use str;\n             use util;\n "}, {"sha": "28f21a76dcb03e57cd941cdbc8fedc75cede740b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -176,7 +176,6 @@ pub mod os;\n pub mod io;\n pub mod path;\n pub mod rand;\n-pub mod run;\n pub mod cast;\n pub mod fmt;\n pub mod cleanup;"}, {"sha": "edb480fe4cb331109617df5c03fb4a1656210465", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -179,6 +179,7 @@ pub trait IoFactory {\n     fn timer_init(&mut self) -> Result<~RtioTimer, IoError>;\n     fn spawn(&mut self, config: ProcessConfig)\n             -> Result<(~RtioProcess, ~[Option<~RtioPipe>]), IoError>;\n+    fn kill(&mut self, pid: libc::pid_t, signal: int) -> Result<(), IoError>;\n     fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError>;"}, {"sha": "9ea8f6447dd6a96828bb4dbcb4140fcc0a4b42f4", "filename": "src/libstd/run.rs", "status": "removed", "additions": 0, "deletions": 634, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8786405047cadcfb5ec3a2d711ca264d74843c13/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=8786405047cadcfb5ec3a2d711ca264d74843c13", "patch": "@@ -1,634 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utilities for spawning and managing processes\n-\n-#[allow(missing_doc)];\n-#[deny(unused_must_use)];\n-\n-use comm::Chan;\n-use io::Reader;\n-use io::process::ProcessExit;\n-use io::process;\n-use io;\n-use libc::{pid_t, c_int};\n-use libc;\n-use option::{None, Option, Some};\n-use task::spawn;\n-use path::{Path, GenericPath};\n-use result::Ok;\n-use str::Str;\n-use vec::Vector;\n-use clone::Clone;\n-\n-/**\n- * A value representing a child process.\n- *\n- * The lifetime of this value is linked to the lifetime of the actual\n- * process - the Process destructor calls self.finish() which waits\n- * for the process to terminate.\n- */\n-pub struct Process {\n-    priv inner: process::Process,\n-}\n-\n-/// Options that can be given when starting a Process.\n-pub struct ProcessOptions<'a> {\n-    /**\n-     * If this is None then the new process will have the same initial\n-     * environment as the parent process.\n-     *\n-     * If this is Some(vec-of-names-and-values) then the new process will\n-     * have an environment containing the given named values only.\n-     */\n-    env: Option<~[(~str, ~str)]>,\n-\n-    /**\n-     * If this is None then the new process will use the same initial working\n-     * directory as the parent process.\n-     *\n-     * If this is Some(path) then the new process will use the given path\n-     * for its initial working directory.\n-     */\n-    dir: Option<&'a Path>,\n-\n-    /**\n-     * If this is None then a new pipe will be created for the new process's\n-     * input and Process.input() will provide a Writer to write to this pipe.\n-     *\n-     * If this is Some(file-descriptor) then the new process will read its input\n-     * from the given file descriptor, Process.input_redirected() will return\n-     * true, and Process.input() will fail.\n-     */\n-    in_fd: Option<c_int>,\n-\n-    /**\n-     * If this is None then a new pipe will be created for the new program's\n-     * output and Process.output() will provide a Reader to read from this pipe.\n-     *\n-     * If this is Some(file-descriptor) then the new process will write its output\n-     * to the given file descriptor, Process.output_redirected() will return\n-     * true, and Process.output() will fail.\n-     */\n-    out_fd: Option<c_int>,\n-\n-    /**\n-     * If this is None then a new pipe will be created for the new program's\n-     * error stream and Process.error() will provide a Reader to read from this pipe.\n-     *\n-     * If this is Some(file-descriptor) then the new process will write its error output\n-     * to the given file descriptor, Process.error_redirected() will return true, and\n-     * and Process.error() will fail.\n-     */\n-    err_fd: Option<c_int>,\n-\n-    /// The uid to assume for the child process. For more information, see the\n-    /// documentation in `io::process::ProcessConfig` about this field.\n-    uid: Option<uint>,\n-\n-    /// The gid to assume for the child process. For more information, see the\n-    /// documentation in `io::process::ProcessConfig` about this field.\n-    gid: Option<uint>,\n-\n-    /// Flag as to whether the child process will be the leader of a new process\n-    /// group or not. This allows the parent process to exit while the child is\n-    /// still running. For more information, see the documentation in\n-    /// `io::process::ProcessConfig` about this field.\n-    detach: bool,\n-}\n-\n-impl <'a> ProcessOptions<'a> {\n-    /// Return a ProcessOptions that has None in every field.\n-    pub fn new<'a>() -> ProcessOptions<'a> {\n-        ProcessOptions {\n-            env: None,\n-            dir: None,\n-            in_fd: None,\n-            out_fd: None,\n-            err_fd: None,\n-            uid: None,\n-            gid: None,\n-            detach: false,\n-        }\n-    }\n-}\n-\n-/// The output of a finished process.\n-pub struct ProcessOutput {\n-    /// The status (exit code) of the process.\n-    status: ProcessExit,\n-\n-    /// The data that the process wrote to stdout.\n-    output: ~[u8],\n-\n-    /// The data that the process wrote to stderr.\n-    error: ~[u8],\n-}\n-\n-impl Process {\n-    /**\n-     * Spawns a new Process.\n-     *\n-     * # Arguments\n-     *\n-     * * prog - The path to an executable.\n-     * * args - Vector of arguments to pass to the child process.\n-     * * options - Options to configure the environment of the process,\n-     *             the working directory and the standard IO streams.\n-     */\n-    pub fn new(prog: &str, args: &[~str],\n-               options: ProcessOptions) -> io::IoResult<Process> {\n-        let ProcessOptions {\n-            env, dir, in_fd, out_fd, err_fd, uid, gid, detach\n-        } = options;\n-        let env = env.as_ref().map(|a| a.as_slice());\n-        let cwd = dir.as_ref().map(|a| a.as_str().unwrap());\n-        fn rtify(fd: Option<c_int>, input: bool) -> process::StdioContainer {\n-            match fd {\n-                Some(fd) => process::InheritFd(fd),\n-                None => process::CreatePipe(input, !input),\n-            }\n-        }\n-        let rtio = [rtify(in_fd, true), rtify(out_fd, false),\n-                    rtify(err_fd, false)];\n-        let rtconfig = process::ProcessConfig {\n-            program: prog,\n-            args: args,\n-            env: env,\n-            cwd: cwd,\n-            io: rtio,\n-            uid: uid,\n-            gid: gid,\n-            detach: detach,\n-        };\n-        process::Process::new(rtconfig).map(|p| Process { inner: p })\n-    }\n-\n-    /// Returns the unique id of the process\n-    pub fn get_id(&self) -> pid_t { self.inner.id() }\n-\n-    /**\n-     * Returns an io::Writer that can be used to write to this Process's stdin.\n-     *\n-     * Fails if there is no stdin available (it's already been removed by\n-     * take_input)\n-     */\n-    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer {\n-        self.inner.io[0].get_mut_ref() as &mut io::Writer\n-    }\n-\n-    /**\n-     * Returns an io::Reader that can be used to read from this Process's stdout.\n-     *\n-     * Fails if there is no stdout available (it's already been removed by\n-     * take_output)\n-     */\n-    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader {\n-        self.inner.io[1].get_mut_ref() as &mut io::Reader\n-    }\n-\n-    /**\n-     * Returns an io::Reader that can be used to read from this Process's stderr.\n-     *\n-     * Fails if there is no stderr available (it's already been removed by\n-     * take_error)\n-     */\n-    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader {\n-        self.inner.io[2].get_mut_ref() as &mut io::Reader\n-    }\n-\n-    /**\n-     * Closes the handle to the child process's stdin.\n-     */\n-    pub fn close_input(&mut self) {\n-        self.inner.io[0].take();\n-    }\n-\n-    /**\n-     * Closes the handle to stdout and stderr.\n-     */\n-    pub fn close_outputs(&mut self) {\n-        self.inner.io[1].take();\n-        self.inner.io[2].take();\n-    }\n-\n-    /**\n-     * Closes the handle to stdin, waits for the child process to terminate,\n-     * and returns the exit code.\n-     *\n-     * If the child has already been finished then the exit code is returned.\n-     */\n-    pub fn finish(&mut self) -> ProcessExit { self.inner.wait() }\n-\n-    /**\n-     * Closes the handle to stdin, waits for the child process to terminate, and\n-     * reads and returns all remaining output of stdout and stderr, along with\n-     * the exit code.\n-     *\n-     * If the child has already been finished then the exit code and any\n-     * remaining unread output of stdout and stderr will be returned.\n-     *\n-     * This method will fail if the child process's stdout or stderr streams\n-     * were redirected to existing file descriptors.\n-     */\n-    pub fn finish_with_output(&mut self) -> ProcessOutput {\n-        self.close_input();\n-        let output = self.inner.io[1].take();\n-        let error = self.inner.io[2].take();\n-\n-        // Spawn two entire schedulers to read both stdout and sterr\n-        // in parallel so we don't deadlock while blocking on one\n-        // or the other. FIXME (#2625): Surely there's a much more\n-        // clever way to do this.\n-        let (p, ch) = Chan::new();\n-        let ch_clone = ch.clone();\n-\n-        spawn(proc() {\n-            let mut error = error;\n-            match error {\n-                Some(ref mut e) => ch.send((2, e.read_to_end())),\n-                None => ch.send((2, Ok(~[])))\n-            }\n-        });\n-        spawn(proc() {\n-            let mut output = output;\n-            match output {\n-                Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n-                None => ch_clone.send((1, Ok(~[])))\n-            }\n-        });\n-\n-        let status = self.finish();\n-\n-        let (errs, outs) = match (p.recv(), p.recv()) {\n-            ((1, o), (2, e)) => (e, o),\n-            ((2, e), (1, o)) => (e, o),\n-            ((x, _), (y, _)) => {\n-                fail!(\"unexpected file numbers: {}, {}\", x, y);\n-            }\n-        };\n-\n-        return ProcessOutput {status: status,\n-                              output: outs.ok().unwrap_or(~[]),\n-                              error: errs.ok().unwrap_or(~[]) };\n-    }\n-\n-    /**\n-     * Terminates the process, giving it a chance to clean itself up if\n-     * this is supported by the operating system.\n-     *\n-     * On Posix OSs SIGTERM will be sent to the process. On Win32\n-     * TerminateProcess(..) will be called.\n-     */\n-    pub fn destroy(&mut self) -> io::IoResult<()> {\n-        let ret = self.inner.signal(io::process::PleaseExitSignal);\n-        self.finish();\n-        return ret;\n-    }\n-\n-    /**\n-     * Terminates the process as soon as possible without giving it a\n-     * chance to clean itself up.\n-     *\n-     * On Posix OSs SIGKILL will be sent to the process. On Win32\n-     * TerminateProcess(..) will be called.\n-     */\n-    pub fn force_destroy(&mut self) -> io::IoResult<()> {\n-        // This should never fail because we own the process\n-        let ret = self.inner.signal(io::process::MustDieSignal);\n-        self.finish();\n-        return ret;\n-\n-    }\n-}\n-\n-/**\n- * Spawns a process and waits for it to terminate. The process will\n- * inherit the current stdin/stdout/stderr file descriptors.\n- *\n- * # Arguments\n- *\n- * * prog - The path to an executable\n- * * args - Vector of arguments to pass to the child process\n- *\n- * # Return value\n- *\n- * The process's exit code, or None if the child process could not be started\n- */\n-pub fn process_status(prog: &str, args: &[~str]) -> io::IoResult<ProcessExit> {\n-    Process::new(prog, args, ProcessOptions {\n-        in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n-        out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n-        err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) }),\n-        .. ProcessOptions::new()\n-    }).map(|mut p| p.finish())\n-}\n-\n-/**\n- * Spawns a process, records all its output, and waits for it to terminate.\n- *\n- * # Arguments\n- *\n- * * prog - The path to an executable\n- * * args - Vector of arguments to pass to the child process\n- *\n- * # Return value\n- *\n- * The process's stdout/stderr output and exit code, or None if the child process could not be\n- * started.\n- */\n-pub fn process_output(prog: &str, args: &[~str]) -> io::IoResult<ProcessOutput> {\n-    Process::new(prog, args, ProcessOptions::new()).map(|mut p| {\n-        p.finish_with_output()\n-    })\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use os;\n-    use run;\n-    use str;\n-    use task::spawn;\n-    use unstable::running_on_valgrind;\n-    use io::pipe::PipeStream;\n-    use io::{FileNotFound};\n-    use libc::c_int;\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_process_status() {\n-        let mut status = run::process_status(\"false\", []).unwrap();\n-        assert!(status.matches_exit_status(1));\n-\n-        status = run::process_status(\"true\", []).unwrap();\n-        assert!(status.success());\n-    }\n-\n-    #[test]\n-    fn test_process_output_fail_to_start() {\n-        match run::process_output(\"/no-binary-by-this-name-should-exist\", []) {\n-            Err(e) => assert_eq!(e.kind, FileNotFound),\n-            Ok(..) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_process_output_output() {\n-\n-        let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"echo\", [~\"hello\"]).unwrap();\n-        let output_str = str::from_utf8_owned(output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_process_output_error() {\n-\n-        let run::ProcessOutput {status, output, error}\n-             = run::process_output(\"mkdir\", [~\".\"]).unwrap();\n-\n-        assert!(status.matches_exit_status(1));\n-        assert_eq!(output, ~[]);\n-        assert!(!error.is_empty());\n-    }\n-\n-    #[test]\n-    #[ignore] // FIXME(#10016) cat never sees stdin close\n-    fn test_pipes() {\n-\n-        let pipe_in = os::pipe();\n-        let pipe_out = os::pipe();\n-        let pipe_err = os::pipe();\n-\n-        let mut process = run::Process::new(\"cat\", [], run::ProcessOptions {\n-            in_fd: Some(pipe_in.input),\n-            out_fd: Some(pipe_out.out),\n-            err_fd: Some(pipe_err.out),\n-            .. run::ProcessOptions::new()\n-        }).unwrap();\n-\n-        os::close(pipe_in.input as int);\n-        os::close(pipe_out.out as int);\n-        os::close(pipe_err.out as int);\n-\n-        spawn(proc() {\n-            writeclose(pipe_in.out, \"test\");\n-        });\n-        let actual = readclose(pipe_out.input);\n-        readclose(pipe_err.input);\n-        process.finish();\n-\n-        assert_eq!(~\"test\", actual);\n-    }\n-\n-    fn writeclose(fd: c_int, s: &str) {\n-        let mut writer = PipeStream::open(fd);\n-        writer.write(s.as_bytes()).unwrap();\n-    }\n-\n-    fn readclose(fd: c_int) -> ~str {\n-        PipeStream::open(fd).read_to_str().unwrap()\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_finish_once() {\n-        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n-            .unwrap();\n-        assert!(prog.finish().matches_exit_status(1));\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_finish_twice() {\n-        let mut prog = run::Process::new(\"false\", [], run::ProcessOptions::new())\n-            .unwrap();\n-        assert!(prog.finish().matches_exit_status(1));\n-        assert!(prog.finish().matches_exit_status(1));\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_finish_with_output_once() {\n-\n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n-            .unwrap();\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-        let output_str = str::from_utf8_owned(output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n-    fn test_finish_with_output_twice() {\n-\n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions::new())\n-            .unwrap();\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-\n-        let output_str = str::from_utf8_owned(output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), ~\"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-\n-        let run::ProcessOutput {status, output, error}\n-            = prog.finish_with_output();\n-\n-        assert!(status.success());\n-        assert_eq!(output, ~[]);\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, ~[]);\n-        }\n-    }\n-\n-    #[cfg(unix,not(target_os=\"android\"))]\n-    fn run_pwd(dir: Option<&Path>) -> run::Process {\n-        run::Process::new(\"pwd\", [], run::ProcessOptions {\n-            dir: dir,\n-            .. run::ProcessOptions::new()\n-        }).unwrap()\n-    }\n-    #[cfg(unix,target_os=\"android\")]\n-    fn run_pwd(dir: Option<&Path>) -> run::Process {\n-        run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"pwd\"], run::ProcessOptions {\n-            dir: dir,\n-            .. run::ProcessOptions::new()\n-        }).unwrap()\n-    }\n-\n-    #[cfg(windows)]\n-    fn run_pwd(dir: Option<&Path>) -> run::Process {\n-        run::Process::new(\"cmd\", [~\"/c\", ~\"cd\"], run::ProcessOptions {\n-            dir: dir,\n-            .. run::ProcessOptions::new()\n-        }).unwrap()\n-    }\n-\n-    #[test]\n-    fn test_keep_current_working_dir() {\n-        let mut prog = run_pwd(None);\n-\n-        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n-        let parent_dir = os::getcwd();\n-        let child_dir = Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[test]\n-    fn test_change_working_directory() {\n-        // test changing to the parent of os::getcwd() because we know\n-        // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().dir_path();\n-        let mut prog = run_pwd(Some(&parent_dir));\n-\n-        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n-        let child_dir = Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[cfg(unix,not(target_os=\"android\"))]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n-        run::Process::new(\"env\", [], run::ProcessOptions {\n-            env: env,\n-            .. run::ProcessOptions::new()\n-        }).unwrap()\n-    }\n-    #[cfg(unix,target_os=\"android\")]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n-        run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"set\"], run::ProcessOptions {\n-            env: env,\n-            .. run::ProcessOptions::new()\n-        }).unwrap()\n-    }\n-\n-    #[cfg(windows)]\n-    fn run_env(env: Option<~[(~str, ~str)]>) -> run::Process {\n-        run::Process::new(\"cmd\", [~\"/c\", ~\"set\"], run::ProcessOptions {\n-            env: env,\n-            .. run::ProcessOptions::new()\n-        }).unwrap()\n-    }\n-\n-    #[test]\n-    #[cfg(not(target_os=\"android\"))]\n-    fn test_inherit_env() {\n-        if running_on_valgrind() { return; }\n-\n-        let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n-\n-        let r = os::env();\n-        for &(ref k, ref v) in r.iter() {\n-            // don't check windows magical empty-named variables\n-            assert!(k.is_empty() || output.contains(format!(\"{}={}\", *k, *v)));\n-        }\n-    }\n-    #[test]\n-    #[cfg(target_os=\"android\")]\n-    fn test_inherit_env() {\n-        if running_on_valgrind() { return; }\n-\n-        let mut prog = run_env(None);\n-        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n-\n-        let r = os::env();\n-        for &(ref k, ref v) in r.iter() {\n-            // don't check android RANDOM variables\n-            if *k != ~\"RANDOM\" {\n-                assert!(output.contains(format!(\"{}={}\", *k, *v)) ||\n-                        output.contains(format!(\"{}=\\'{}\\'\", *k, *v)));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_add_to_env() {\n-\n-        let mut new_env = os::env();\n-        new_env.push((~\"RUN_TEST_NEW_ENV\", ~\"123\"));\n-\n-        let mut prog = run_env(Some(new_env));\n-        let output = str::from_utf8_owned(prog.finish_with_output().output).unwrap();\n-\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"));\n-    }\n-}"}, {"sha": "360f94564b7489417010073547279e6089b52358", "filename": "src/test/run-pass/cleanup-arm-conditional.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fcleanup-arm-conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fcleanup-arm-conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-arm-conditional.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -21,8 +21,7 @@\n // Test that cleanup scope for temporaries created in a match\n // arm is confined to the match arm itself.\n \n-use std::{os, run};\n-use std::io::process;\n+use std::os;\n \n struct Test { x: int }\n "}, {"sha": "825f699601f42e75882bba4c2cb644628c51775c", "filename": "src/test/run-pass/cleanup-shortcircuit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-shortcircuit.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -20,8 +20,7 @@\n \n // Test that cleanups for the RHS of shorcircuiting operators work.\n \n-use std::{os, run};\n-use std::io::process;\n+use std::os;\n \n pub fn main() {\n     let args = os::args();"}, {"sha": "60f98b1075a47d6e9a528e3df94660a33e1f5ec5", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -15,10 +15,10 @@\n // memory, which makes for some *confusing* logs. That's why these are here\n // instead of in std.\n \n+use std::io::timer;\n use std::libc;\n-use std::run;\n use std::str;\n-use std::io;\n+use std::io::process::{Process, ProcessOutput};\n \n #[test]\n fn test_destroy_once() {\n@@ -27,8 +27,8 @@ fn test_destroy_once() {\n     #[cfg(target_os=\"android\")]\n     static PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = run::Process::new(PROG, [], run::ProcessOptions::new()).unwrap();\n-    p.destroy(); // this shouldn't crash (and nor should the destructor)\n+    let mut p = Process::new(PROG, []).unwrap();\n+    p.signal_exit().unwrap(); // this shouldn't crash (and nor should the destructor)\n }\n \n #[test]\n@@ -38,12 +38,12 @@ fn test_destroy_twice() {\n     #[cfg(target_os=\"android\")]\n     static PROG: &'static str = \"ls\"; // android don't have echo binary\n \n-    let mut p = match run::Process::new(PROG, [], run::ProcessOptions::new()) {\n+    let mut p = match Process::new(PROG, []) {\n         Ok(p) => p,\n         Err(e) => fail!(\"wut: {}\", e),\n     };\n-    p.destroy(); // this shouldnt crash...\n-    p.destroy(); // ...and nor should this (and nor should the destructor)\n+    p.signal_exit().unwrap(); // this shouldnt crash...\n+    p.signal_exit().unwrap(); // ...and nor should this (and nor should the destructor)\n }\n \n fn test_destroy_actually_kills(force: bool) {\n@@ -59,14 +59,14 @@ fn test_destroy_actually_kills(force: bool) {\n \n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()])\n+        let ProcessOutput {output, ..} = Process::output(\"ps\", [~\"-p\", pid.to_str()])\n             .unwrap();\n         str::from_utf8_owned(output).unwrap().contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()])\n+        let ProcessOutput {output, ..} = Process::output(\"/system/bin/ps\", [pid.to_str()])\n             .unwrap();\n         str::from_utf8_owned(output).unwrap().contains(~\"root\")\n     }\n@@ -91,18 +91,20 @@ fn test_destroy_actually_kills(force: bool) {\n     }\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let mut p = run::Process::new(BLOCK_COMMAND, [], run::ProcessOptions::new())\n-        .unwrap();\n+    let mut p = Process::new(BLOCK_COMMAND, []).unwrap();\n \n-    assert!(process_exists(p.get_id()));\n+    assert!(process_exists(p.id()));\n \n     if force {\n-        p.force_destroy();\n+        p.signal_kill().unwrap();\n     } else {\n-        p.destroy();\n+        p.signal_exit().unwrap();\n     }\n \n-    assert!(!process_exists(p.get_id()));\n+    if process_exists(p.id()) {\n+        timer::sleep(500);\n+        assert!(!process_exists(p.id()));\n+    }\n }\n \n #[test]"}, {"sha": "14115fa52daa272bf418502b4974dca1e15aa678", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -31,14 +31,11 @@ pub fn main () {\n     let config = process::ProcessConfig {\n         program : args[0].as_slice(),\n         args : &[~\"child\"],\n-        env : None,\n-        cwd : None,\n-        io : &[],\n-        uid: None,\n-        gid: None,\n-        detach: false,\n+        stdout: process::Ignored,\n+        stderr: process::Ignored,\n+        .. process::ProcessConfig::new()\n     };\n \n-    let mut p = process::Process::new(config).unwrap();\n+    let mut p = process::Process::configure(config).unwrap();\n     println!(\"{}\", p.wait());\n }"}, {"sha": "ffb446d1b33849bb25e7a5b0fe6a8ec95a7dff0e", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -29,8 +29,7 @@ fn main() {\n \n     let config = process::ProcessConfig {\n         program : \"/bin/sh\",\n-        args : &[~\"-c\", ~\"read a\"],\n-        io : &[process::CreatePipe(true, false)],\n+        args: &[~\"-c\", ~\"read a\"],\n         detach: true,\n         .. process::ProcessConfig::new()\n     };\n@@ -40,14 +39,14 @@ fn main() {\n     l.register(Interrupt).unwrap();\n \n     // spawn the child\n-    let mut p = process::Process::new(config).unwrap();\n+    let mut p = process::Process::configure(config).unwrap();\n \n     // send an interrupt to everyone in our process group\n     unsafe { libc::funcs::posix88::signal::kill(0, libc::SIGINT); }\n \n     // Wait for the child process to die (terminate it's stdin and the read\n     // should fail).\n-    drop(p.io[0].take());\n+    drop(p.stdin.take());\n     match p.wait() {\n         process::ExitStatus(..) => {}\n         process::ExitSignal(..) => fail!()"}, {"sha": "2658755cea119e97ef2391ebd6f5d9acbd4ed362", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bd447400c0854600e994f562e2b230171f328f/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=a9bd447400c0854600e994f562e2b230171f328f", "patch": "@@ -20,20 +20,20 @@\n \n // ignore-fast calling itself doesn't work on check-fast\n \n-use std::{os, run};\n-use std::io::process;\n+use std::os;\n+use std::io::process::{Process, ExitSignal, ExitStatus};\n \n pub fn main() {\n     let args = os::args();\n     if args.len() >= 2 && args[1] == ~\"signal\" {\n         // Raise a segfault.\n         unsafe { *(0 as *mut int) = 0; }\n     } else {\n-        let status = run::process_status(args[0], [~\"signal\"]).unwrap();\n+        let status = Process::status(args[0], [~\"signal\"]).unwrap();\n         // Windows does not have signal, so we get exit status 0xC0000028 (STATUS_BAD_STACK).\n         match status {\n-            process::ExitSignal(_) if cfg!(unix) => {},\n-            process::ExitStatus(0xC0000028) if cfg!(windows) => {},\n+            ExitSignal(_) if cfg!(unix) => {},\n+            ExitStatus(0xC0000028) if cfg!(windows) => {},\n             _ => fail!(\"invalid termination (was not signalled): {:?}\", status)\n         }\n     }"}]}