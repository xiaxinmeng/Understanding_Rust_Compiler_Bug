{"sha": "bbd6d9cd555d9b35677086bc93e66212ea173cc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZDZkOWNkNTU1ZDliMzU2NzcwODZiYzkzZTY2MjEyZWExNzNjYzU=", "commit": {"author": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-02-26T14:41:38Z"}, "committer": {"name": "David Lukes", "email": "dafydd.lukes@gmail.com", "date": "2018-03-05T12:18:27Z"}, "message": "Refactor parsing code into struct\n\nThis also splits the giant state machine match expression into separate\nmethods.", "tree": {"sha": "6afd02c25ba935bf20647b42298ec0255e2c5520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6afd02c25ba935bf20647b42298ec0255e2c5520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbd6d9cd555d9b35677086bc93e66212ea173cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbd6d9cd555d9b35677086bc93e66212ea173cc5", "html_url": "https://github.com/rust-lang/rust/commit/bbd6d9cd555d9b35677086bc93e66212ea173cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbd6d9cd555d9b35677086bc93e66212ea173cc5/comments", "author": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dlukes", "id": 2734517, "node_id": "MDQ6VXNlcjI3MzQ1MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/2734517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dlukes", "html_url": "https://github.com/dlukes", "followers_url": "https://api.github.com/users/dlukes/followers", "following_url": "https://api.github.com/users/dlukes/following{/other_user}", "gists_url": "https://api.github.com/users/dlukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dlukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dlukes/subscriptions", "organizations_url": "https://api.github.com/users/dlukes/orgs", "repos_url": "https://api.github.com/users/dlukes/repos", "events_url": "https://api.github.com/users/dlukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dlukes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "html_url": "https://github.com/rust-lang/rust/commit/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7"}], "stats": {"total": 390, "additions": 215, "deletions": 175}, "files": [{"sha": "4563f8a7809faa9e49a943495515188be4eed8d0", "filename": "rustfmt-config/src/license.rs", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/rustfmt-config%2Fsrc%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310c1146f28eab02595e3308cdb2c3d8dbbeb3a7/rustfmt-config%2Fsrc%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-config%2Fsrc%2Flicense.rs?ref=310c1146f28eab02595e3308cdb2c3d8dbbeb3a7", "patch": "@@ -1,174 +0,0 @@\n-use regex;\n-\n-/// Convert the license template into a string which can be turned into a regex.\n-///\n-/// The license template could use regex syntax directly, but that would require a lot of manual\n-/// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n-/// subparts delimited by `{` and `}`. Additionally:\n-///\n-/// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n-/// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n-///\n-/// This function parses this input format and builds a properly escaped *string* representation of\n-/// the equivalent regular expression. It **does not** however guarantee that the returned string is\n-/// a syntactically valid regular expression.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # use rustfmt_config::license;\n-/// assert_eq!(\n-///     license::parse_template(\n-///         r\"\n-/// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n-/// // file at the top-level directory of this distribution and at\n-/// // {}.\n-/// //\n-/// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-/// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-/// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-/// // option. This file may not be copied, modified, or distributed\n-/// // except according to those terms.\n-/// \"\n-///     ).unwrap(),\n-///     r\"^\n-/// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n-/// // file at the top\\-level directory of this distribution and at\n-/// // .*?\\.\n-/// //\n-/// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n-/// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n-/// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n-/// // option\\. This file may not be copied, modified, or distributed\n-/// // except according to those terms\\.\n-/// \"\n-/// );\n-/// ```\n-pub fn parse_template(template: &str) -> Result<String, String> {\n-    // the template is parsed using a state machine\n-    enum State {\n-        Lit,\n-        LitEsc,\n-        // the u32 keeps track of brace nesting\n-        Re(u32),\n-        ReEsc(u32),\n-    }\n-\n-    let mut parsed = String::from(\"^\");\n-    let mut buffer = String::new();\n-    let mut state = State::Lit;\n-    let mut linum = 1;\n-    // keeps track of last line on which a regex placeholder was started\n-    let mut open_brace_line = 0;\n-    for chr in template.chars() {\n-        if chr == '\\n' {\n-            linum += 1;\n-        }\n-        state = match state {\n-            State::Lit => match chr {\n-                '{' => {\n-                    parsed.push_str(&regex::escape(&buffer));\n-                    buffer.clear();\n-                    open_brace_line = linum;\n-                    State::Re(1)\n-                }\n-                '}' => return Err(format!(\"escape or balance closing brace on l. {}\", linum)),\n-                '\\\\' => State::LitEsc,\n-                _ => {\n-                    buffer.push(chr);\n-                    State::Lit\n-                }\n-            },\n-            State::LitEsc => {\n-                buffer.push(chr);\n-                State::Lit\n-            }\n-            State::Re(brace_nesting) => {\n-                match chr {\n-                    '{' => {\n-                        buffer.push(chr);\n-                        State::Re(brace_nesting + 1)\n-                    }\n-                    '}' => {\n-                        match brace_nesting {\n-                            1 => {\n-                                // default regex for empty placeholder {}\n-                                if buffer.is_empty() {\n-                                    buffer = \".*?\".to_string();\n-                                }\n-                                parsed.push_str(&buffer);\n-                                buffer.clear();\n-                                State::Lit\n-                            }\n-                            _ => {\n-                                buffer.push(chr);\n-                                State::Re(brace_nesting - 1)\n-                            }\n-                        }\n-                    }\n-                    '\\\\' => {\n-                        buffer.push(chr);\n-                        State::ReEsc(brace_nesting)\n-                    }\n-                    _ => {\n-                        buffer.push(chr);\n-                        State::Re(brace_nesting)\n-                    }\n-                }\n-            }\n-            State::ReEsc(brace_nesting) => {\n-                buffer.push(chr);\n-                State::Re(brace_nesting)\n-            }\n-        }\n-    }\n-    match state {\n-        State::Re(_) | State::ReEsc(_) => {\n-            return Err(format!(\n-                \"escape or balance opening brace on l. {}\",\n-                open_brace_line\n-            ));\n-        }\n-        State::LitEsc => return Err(format!(\"incomplete escape sequence on l. {}\", linum)),\n-        _ => (),\n-    }\n-    parsed.push_str(&regex::escape(&buffer));\n-\n-    Ok(parsed)\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::parse_template;\n-\n-    #[test]\n-    fn test_parse_license_template() {\n-        assert_eq!(\n-            parse_template(\"literal (.*)\").unwrap(),\n-            r\"^literal \\(\\.\\*\\)\"\n-        );\n-        assert_eq!(parse_template(r\"escaping \\}\").unwrap(), r\"^escaping \\}\");\n-        assert!(parse_template(\"unbalanced } without escape\").is_err());\n-        assert_eq!(\n-            parse_template(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n-            r\"^\\d+ place-?holders?\"\n-        );\n-        assert_eq!(parse_template(\"default {}\").unwrap(), \"^default .*?\");\n-        assert_eq!(\n-            parse_template(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n-            r\"^unbalanced nested braces \\{{3}\"\n-        );\n-        assert_eq!(\n-            parse_template(\"parsing error }\").unwrap_err(),\n-            \"escape or balance closing brace on l. 1\"\n-        );\n-        assert_eq!(\n-            parse_template(\"parsing error {\\nsecond line\").unwrap_err(),\n-            \"escape or balance opening brace on l. 1\"\n-        );\n-        assert_eq!(\n-            parse_template(r\"parsing error \\\").unwrap_err(),\n-            \"incomplete escape sequence on l. 1\"\n-        );\n-    }\n-}"}, {"sha": "8b9a6b2d84dc3f7407e8fd2502bbe6f67aeb7dc9", "filename": "src/config/config_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbd6d9cd555d9b35677086bc93e66212ea173cc5/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbd6d9cd555d9b35677086bc93e66212ea173cc5/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=bbd6d9cd555d9b35677086bc93e66212ea173cc5", "patch": "@@ -408,7 +408,7 @@ macro_rules! create_config {\n                                 license_template_path, e);\n                         return;\n                     };\n-                    let license_template_parsed = match license::parse_template(&license_template_str) {\n+                    let license_template_parsed = match TemplateParser::parse(&license_template_str) {\n                         Ok(string) => string,\n                         Err(e) => {\n                             eprintln!(\"Warning: unable to parse license template file {:?}: {}\","}, {"sha": "3de04599129251fc3352b43f0932507aaba1ce67", "filename": "src/config/license.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/bbd6d9cd555d9b35677086bc93e66212ea173cc5/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbd6d9cd555d9b35677086bc93e66212ea173cc5/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=bbd6d9cd555d9b35677086bc93e66212ea173cc5", "patch": "@@ -0,0 +1,213 @@\n+use regex;\n+\n+// the template is parsed using a state machine\n+enum ParsingState {\n+    Lit,\n+    LitEsc,\n+    // the u32 keeps track of brace nesting\n+    Re(u32),\n+    ReEsc(u32),\n+    Abort(String),\n+}\n+\n+use self::ParsingState::*;\n+\n+pub struct TemplateParser {\n+    parsed: String,\n+    buffer: String,\n+    state: ParsingState,\n+    linum: u32,\n+    open_brace_line: u32,\n+}\n+\n+impl TemplateParser {\n+    fn new() -> Self {\n+        Self {\n+            parsed: \"^\".to_owned(),\n+            buffer: String::new(),\n+            state: Lit,\n+            linum: 1,\n+            // keeps track of last line on which a regex placeholder was started\n+            open_brace_line: 0,\n+        }\n+    }\n+\n+    /// Convert a license template into a string which can be turned into a regex.\n+    ///\n+    /// The license template could use regex syntax directly, but that would require a lot of manual\n+    /// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n+    /// subparts delimited by `{` and `}`. Additionally:\n+    ///\n+    /// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n+    /// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n+    ///\n+    /// This function parses this input format and builds a properly escaped *string* representation\n+    /// of the equivalent regular expression. It **does not** however guarantee that the returned\n+    /// string is a syntactically valid regular expression.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # use rustfmt_config::license::TemplateParser;\n+    /// assert_eq!(\n+    ///     TemplateParser::parse(\n+    ///         r\"\n+    /// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n+    /// // file at the top-level directory of this distribution and at\n+    /// // {}.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+    /// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+    /// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+    /// // option. This file may not be copied, modified, or distributed\n+    /// // except according to those terms.\n+    /// \"\n+    ///     ).unwrap(),\n+    ///     r\"^\n+    /// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n+    /// // file at the top\\-level directory of this distribution and at\n+    /// // .*?\\.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n+    /// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n+    /// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n+    /// // option\\. This file may not be copied, modified, or distributed\n+    /// // except according to those terms\\.\n+    /// \"\n+    /// );\n+    /// ```\n+    pub fn parse(template: &str) -> Result<String, String> {\n+        let mut parser = Self::new();\n+        for chr in template.chars() {\n+            if chr == '\\n' {\n+                parser.linum += 1;\n+            }\n+            parser.state = match parser.state {\n+                Lit => parser.trans_from_lit(chr),\n+                LitEsc => parser.trans_from_litesc(chr),\n+                Re(brace_nesting) => parser.trans_from_re(chr, brace_nesting),\n+                ReEsc(brace_nesting) => parser.trans_from_reesc(chr, brace_nesting),\n+                Abort(msg) => return Err(msg),\n+            };\n+        }\n+        // check if we've ended parsing in a valid state\n+        match parser.state {\n+            Abort(msg) => return Err(msg),\n+            Re(_) | ReEsc(_) => {\n+                return Err(format!(\n+                    \"escape or balance opening brace on l. {}\",\n+                    parser.open_brace_line\n+                ));\n+            }\n+            LitEsc => return Err(format!(\"incomplete escape sequence on l. {}\", parser.linum)),\n+            _ => (),\n+        }\n+        parser.parsed.push_str(&regex::escape(&parser.buffer));\n+\n+        Ok(parser.parsed)\n+    }\n+\n+    fn trans_from_lit(&mut self, chr: char) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.parsed.push_str(&regex::escape(&self.buffer));\n+                self.buffer.clear();\n+                self.open_brace_line = self.linum;\n+                Re(1)\n+            }\n+            '}' => Abort(format!(\n+                \"escape or balance closing brace on l. {}\",\n+                self.linum\n+            )),\n+            '\\\\' => LitEsc,\n+            _ => {\n+                self.buffer.push(chr);\n+                Lit\n+            }\n+        }\n+    }\n+\n+    fn trans_from_litesc(&mut self, chr: char) -> ParsingState {\n+        self.buffer.push(chr);\n+        Lit\n+    }\n+\n+    fn trans_from_re(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting + 1)\n+            }\n+            '}' => {\n+                match brace_nesting {\n+                    1 => {\n+                        // default regex for empty placeholder {}\n+                        if self.buffer.is_empty() {\n+                            self.parsed.push_str(\".*?\");\n+                        } else {\n+                            self.parsed.push_str(&self.buffer);\n+                        }\n+                        self.buffer.clear();\n+                        Lit\n+                    }\n+                    _ => {\n+                        self.buffer.push(chr);\n+                        Re(brace_nesting - 1)\n+                    }\n+                }\n+            }\n+            '\\\\' => {\n+                self.buffer.push(chr);\n+                ReEsc(brace_nesting)\n+            }\n+            _ => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting)\n+            }\n+        }\n+    }\n+\n+    fn trans_from_reesc(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        self.buffer.push(chr);\n+        Re(brace_nesting)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::TemplateParser;\n+\n+    #[test]\n+    fn test_parse_license_template() {\n+        assert_eq!(\n+            TemplateParser::parse(\"literal (.*)\").unwrap(),\n+            r\"^literal \\(\\.\\*\\)\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(r\"escaping \\}\").unwrap(),\n+            r\"^escaping \\}\"\n+        );\n+        assert!(TemplateParser::parse(\"unbalanced } without escape\").is_err());\n+        assert_eq!(\n+            TemplateParser::parse(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n+            r\"^\\d+ place-?holders?\"\n+        );\n+        assert_eq!(TemplateParser::parse(\"default {}\").unwrap(), \"^default .*?\");\n+        assert_eq!(\n+            TemplateParser::parse(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n+            r\"^unbalanced nested braces \\{{3}\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(\"parsing error }\").unwrap_err(),\n+            \"escape or balance closing brace on l. 1\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(\"parsing error {\\nsecond line\").unwrap_err(),\n+            \"escape or balance opening brace on l. 1\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(r\"parsing error \\\").unwrap_err(),\n+            \"incomplete escape sequence on l. 1\"\n+        );\n+    }\n+}"}, {"sha": "8b93743ec4d8e42f0442da8fa8700c6a559f30c9", "filename": "src/config/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbd6d9cd555d9b35677086bc93e66212ea173cc5/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbd6d9cd555d9b35677086bc93e66212ea173cc5/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=bbd6d9cd555d9b35677086bc93e66212ea173cc5", "patch": "@@ -29,6 +29,7 @@ pub mod license;\n \n use config::config_type::ConfigType;\n use config::file_lines::FileLines;\n+use config::license::TemplateParser;\n pub use config::lists::*;\n pub use config::options::*;\n use config::summary::Summary;"}]}