{"sha": "c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9", "node_id": "C_kwDOAAsO6NoAKGM0ODc1NmNkYmZiMTcyNTI1MWNiZmE2ZmU3NjBiMmNiNGU0N2IyZDk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-28T11:23:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-06T21:55:05Z"}, "message": "Limit creation of tracked place directly.", "tree": {"sha": "4299e16d44b0ce5316c014c67ab0488f787bf2f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4299e16d44b0ce5316c014c67ab0488f787bf2f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9", "html_url": "https://github.com/rust-lang/rust/commit/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "html_url": "https://github.com/rust-lang/rust/commit/9a6c04f5d0e6ec47bf150187cffcb7f737799db4"}], "stats": {"total": 33, "additions": 22, "deletions": 11}, "files": [{"sha": "f587f17f12a1b1bc9458f979b98c37044201d1e7", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9", "patch": "@@ -599,10 +599,11 @@ impl Map {\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         filter: impl FnMut(Ty<'tcx>) -> bool,\n+        place_limit: Option<usize>,\n     ) -> Self {\n         let mut map = Self::new();\n         let exclude = excluded_locals(body);\n-        map.register_with_filter(tcx, body, filter, exclude);\n+        map.register_with_filter(tcx, body, filter, exclude, place_limit);\n         debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n         map\n     }\n@@ -614,12 +615,20 @@ impl Map {\n         body: &Body<'tcx>,\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n         exclude: BitSet<Local>,\n+        place_limit: Option<usize>,\n     ) {\n         // We use this vector as stack, pushing and popping projections.\n         let mut projection = Vec::new();\n         for (local, decl) in body.local_decls.iter_enumerated() {\n             if !exclude.contains(local) {\n-                self.register_with_filter_rec(tcx, local, &mut projection, decl.ty, &mut filter);\n+                self.register_with_filter_rec(\n+                    tcx,\n+                    local,\n+                    &mut projection,\n+                    decl.ty,\n+                    &mut filter,\n+                    place_limit,\n+                );\n             }\n         }\n     }\n@@ -634,7 +643,12 @@ impl Map {\n         projection: &mut Vec<PlaceElem<'tcx>>,\n         ty: Ty<'tcx>,\n         filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n+        place_limit: Option<usize>,\n     ) {\n+        if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n+            return\n+        }\n+\n         // We know that the projection only contains trackable elements.\n         let place = self.make_place(local, projection).unwrap();\n \n@@ -672,13 +686,13 @@ impl Map {\n                 projection.push(PlaceElem::Downcast(None, variant));\n                 let _ = self.make_place(local, projection);\n                 projection.push(PlaceElem::Field(field, ty));\n-                self.register_with_filter_rec(tcx, local, projection, ty, filter);\n+                self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n                 projection.pop();\n                 projection.pop();\n                 return;\n             }\n             projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, local, projection, ty, filter);\n+            self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n             projection.pop();\n         });\n     }"}, {"sha": "bfb1eb8b5fb79c2743f82ff1db0402c2b5a1a1c4", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=c48756cdbfb1725251cbfa6fe760b2cb4e47b2d9", "patch": "@@ -37,9 +37,6 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n             return;\n         }\n \n-        // Decide which places to track during the analysis.\n-        let map = Map::from_filter(tcx, body, Ty::is_scalar);\n-\n         // We want to have a somewhat linear runtime w.r.t. the number of statements/terminators.\n         // Let's call this number `n`. Dataflow analysis has `O(h*n)` transfer function\n         // applications, where `h` is the height of the lattice. Because the height of our lattice\n@@ -48,10 +45,10 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n         // `O(num_nodes * tracked_places * n)` in terms of time complexity. Since the number of\n         // map nodes is strongly correlated to the number of tracked places, this becomes more or\n         // less `O(n)` if we place a constant limit on the number of tracked places.\n-        if tcx.sess.mir_opt_level() < 4 && map.tracked_places() > PLACE_LIMIT {\n-            debug!(\"aborted dataflow const prop due to too many tracked places\");\n-            return;\n-        }\n+        let place_limit = if tcx.sess.mir_opt_level() < 4 { Some(PLACE_LIMIT) } else { None };\n+\n+        // Decide which places to track during the analysis.\n+        let map = Map::from_filter(tcx, body, Ty::is_scalar, place_limit);\n \n         // Perform the actual dataflow analysis.\n         let analysis = ConstAnalysis::new(tcx, body, map);"}]}