{"sha": "a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "node_id": "C_kwDOAAsO6NoAKGEzYTVkODNlNjY1ZDM3ZWJmZmNlOTRlMGQ1YzZjZGFlNWYyODUyZTM", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2022-02-18T14:21:56Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2022-03-11T10:33:59Z"}, "message": "Classify BinaryHeap & LinkedList unit tests as such", "tree": {"sha": "6077e8b38069f6bf8752240c30424c90dbd4b700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6077e8b38069f6bf8752240c30424c90dbd4b700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "html_url": "https://github.com/rust-lang/rust/commit/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f58d51b3c00b1e30acd75aead202eb2248bb33f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f58d51b3c00b1e30acd75aead202eb2248bb33f9", "html_url": "https://github.com/rust-lang/rust/commit/f58d51b3c00b1e30acd75aead202eb2248bb33f9"}], "stats": {"total": 1386, "additions": 692, "deletions": 694}, "files": [{"sha": "37fb901b463230ae90ae94edd99fccf94809cf84", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "patch": "@@ -155,6 +155,9 @@ use crate::vec::{self, AsIntoIter, Vec};\n \n use super::SpecExtend;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A priority queue implemented with a binary heap.\n ///\n /// This will be a max-heap."}, {"sha": "7c758dbb3ab8a23079625ceed193741b2bbb9f11", "filename": "library/alloc/src/collections/binary_heap/tests.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap%2Ftests.rs?ref=a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "patch": "@@ -1,5 +1,5 @@\n-use std::collections::binary_heap::{Drain, PeekMut};\n-use std::collections::BinaryHeap;\n+use super::*;\n+use crate::boxed::Box;\n use std::iter::TrustedLen;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicU32, Ordering};", "previous_filename": "library/alloc/tests/binary_heap.rs"}, {"sha": "38c702aa387bd1a46c74b719482b4e6358145416", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 687, "deletions": 8, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "patch": "@@ -1,10 +1,55 @@\n use super::*;\n+use crate::vec::Vec;\n \n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::thread;\n-use std::vec::Vec;\n \n use rand::{thread_rng, RngCore};\n \n+#[test]\n+fn test_basic() {\n+    let mut m = LinkedList::<Box<_>>::new();\n+    assert_eq!(m.pop_front(), None);\n+    assert_eq!(m.pop_back(), None);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_front(box 1);\n+    assert_eq!(m.pop_front(), Some(box 1));\n+    m.push_back(box 2);\n+    m.push_back(box 3);\n+    assert_eq!(m.len(), 2);\n+    assert_eq!(m.pop_front(), Some(box 2));\n+    assert_eq!(m.pop_front(), Some(box 3));\n+    assert_eq!(m.len(), 0);\n+    assert_eq!(m.pop_front(), None);\n+    m.push_back(box 1);\n+    m.push_back(box 3);\n+    m.push_back(box 5);\n+    m.push_back(box 7);\n+    assert_eq!(m.pop_front(), Some(box 1));\n+\n+    let mut n = LinkedList::new();\n+    n.push_front(2);\n+    n.push_front(3);\n+    {\n+        assert_eq!(n.front().unwrap(), &3);\n+        let x = n.front_mut().unwrap();\n+        assert_eq!(*x, 3);\n+        *x = 0;\n+    }\n+    {\n+        assert_eq!(n.back().unwrap(), &2);\n+        let y = n.back_mut().unwrap();\n+        assert_eq!(*y, 2);\n+        *y = 1;\n+    }\n+    assert_eq!(n.pop_front(), Some(0));\n+    assert_eq!(n.pop_front(), Some(1));\n+}\n+\n+fn generate_test() -> LinkedList<i32> {\n+    list_from(&[0, 1, 2, 3, 4, 5, 6])\n+}\n+\n fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n     v.iter().cloned().collect()\n }\n@@ -110,6 +155,123 @@ fn test_append() {\n     check_links(&n);\n }\n \n+#[test]\n+fn test_iterator() {\n+    let m = generate_test();\n+    for (i, elt) in m.iter().enumerate() {\n+        assert_eq!(i as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_clone() {\n+    let mut n = LinkedList::new();\n+    n.push_back(2);\n+    n.push_back(3);\n+    n.push_back(4);\n+    let mut it = n.iter();\n+    it.next();\n+    let mut jt = it.clone();\n+    assert_eq!(it.next(), jt.next());\n+    assert_eq!(it.next_back(), jt.next_back());\n+    assert_eq!(it.next(), jt.next());\n+}\n+\n+#[test]\n+fn test_iterator_double_end() {\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().next(), None);\n+    n.push_front(4);\n+    n.push_front(5);\n+    n.push_front(6);\n+    let mut it = n.iter();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(it.next().unwrap(), &6);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next_back().unwrap(), &5);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_rev_iter() {\n+    let m = generate_test();\n+    for (i, elt) in m.iter().rev().enumerate() {\n+        assert_eq!((6 - i) as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert_eq!(n.iter().rev().next(), None);\n+    n.push_front(4);\n+    let mut it = n.iter().rev();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next().unwrap(), &4);\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let mut m = generate_test();\n+    let mut len = m.len();\n+    for (i, elt) in m.iter_mut().enumerate() {\n+        assert_eq!(i as i32, *elt);\n+        len -= 1;\n+    }\n+    assert_eq!(len, 0);\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().next().is_none());\n+    n.push_front(4);\n+    n.push_back(5);\n+    let mut it = n.iter_mut();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_some());\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iterator_mut_double_end() {\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().next_back().is_none());\n+    n.push_front(4);\n+    n.push_front(5);\n+    n.push_front(6);\n+    let mut it = n.iter_mut();\n+    assert_eq!(it.size_hint(), (3, Some(3)));\n+    assert_eq!(*it.next().unwrap(), 6);\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+    assert_eq!(*it.next_back().unwrap(), 4);\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(*it.next_back().unwrap(), 5);\n+    assert!(it.next_back().is_none());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_mut_rev_iter() {\n+    let mut m = generate_test();\n+    for (i, elt) in m.iter_mut().rev().enumerate() {\n+        assert_eq!((6 - i) as i32, *elt);\n+    }\n+    let mut n = LinkedList::new();\n+    assert!(n.iter_mut().rev().next().is_none());\n+    n.push_front(4);\n+    let mut it = n.iter_mut().rev();\n+    assert!(it.next().is_some());\n+    assert!(it.next().is_none());\n+}\n+\n #[test]\n fn test_clone_from() {\n     // Short cloned from long\n@@ -168,13 +330,60 @@ fn test_send() {\n }\n \n #[test]\n-fn test_fuzz() {\n-    for _ in 0..25 {\n-        fuzz_test(3);\n-        fuzz_test(16);\n-        #[cfg(not(miri))] // Miri is too slow\n-        fuzz_test(189);\n-    }\n+fn test_eq() {\n+    let mut n = list_from(&[]);\n+    let mut m = list_from(&[]);\n+    assert!(n == m);\n+    n.push_front(1);\n+    assert!(n != m);\n+    m.push_back(1);\n+    assert!(n == m);\n+\n+    let n = list_from(&[2, 3, 4]);\n+    let m = list_from(&[1, 2, 3]);\n+    assert!(n != m);\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let n = list_from(&[]);\n+    let m = list_from(&[1, 2, 3]);\n+    assert!(n < m);\n+    assert!(m > n);\n+    assert!(n <= n);\n+    assert!(n >= n);\n+}\n+\n+#[test]\n+fn test_ord_nan() {\n+    let nan = 0.0f64 / 0.0;\n+    let n = list_from(&[nan]);\n+    let m = list_from(&[nan]);\n+    assert!(!(n < m));\n+    assert!(!(n > m));\n+    assert!(!(n <= m));\n+    assert!(!(n >= m));\n+\n+    let n = list_from(&[nan]);\n+    let one = list_from(&[1.0f64]);\n+    assert!(!(n < one));\n+    assert!(!(n > one));\n+    assert!(!(n <= one));\n+    assert!(!(n >= one));\n+\n+    let u = list_from(&[1.0f64, 2.0, nan]);\n+    let v = list_from(&[1.0f64, 2.0, 3.0]);\n+    assert!(!(u < v));\n+    assert!(!(u > v));\n+    assert!(!(u <= v));\n+    assert!(!(u >= v));\n+\n+    let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);\n+    let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);\n+    assert!(!(s < t));\n+    assert!(s > one);\n+    assert!(!(s <= one));\n+    assert!(s >= one);\n }\n \n #[test]\n@@ -215,6 +424,62 @@ fn test_split_off() {\n     }\n }\n \n+#[test]\n+fn test_split_off_2() {\n+    // singleton\n+    {\n+        let mut m = LinkedList::new();\n+        m.push_back(1);\n+\n+        let p = m.split_off(0);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(p.len(), 1);\n+        assert_eq!(p.back(), Some(&1));\n+        assert_eq!(p.front(), Some(&1));\n+    }\n+\n+    // not singleton, forwards\n+    {\n+        let u = vec![1, 2, 3, 4, 5];\n+        let mut m = list_from(&u);\n+        let mut n = m.split_off(2);\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(n.len(), 3);\n+        for elt in 1..3 {\n+            assert_eq!(m.pop_front(), Some(elt));\n+        }\n+        for elt in 3..6 {\n+            assert_eq!(n.pop_front(), Some(elt));\n+        }\n+    }\n+    // not singleton, backwards\n+    {\n+        let u = vec![1, 2, 3, 4, 5];\n+        let mut m = list_from(&u);\n+        let mut n = m.split_off(4);\n+        assert_eq!(m.len(), 4);\n+        assert_eq!(n.len(), 1);\n+        for elt in 1..5 {\n+            assert_eq!(m.pop_front(), Some(elt));\n+        }\n+        for elt in 5..6 {\n+            assert_eq!(n.pop_front(), Some(elt));\n+        }\n+    }\n+\n+    // no-op on the last index\n+    {\n+        let mut m = LinkedList::new();\n+        m.push_back(1);\n+\n+        let p = m.split_off(1);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(p.len(), 0);\n+        assert_eq!(m.back(), Some(&1));\n+        assert_eq!(m.front(), Some(&1));\n+    }\n+}\n+\n fn fuzz_test(sz: i32) {\n     let mut m: LinkedList<_> = LinkedList::new();\n     let mut v = vec![];\n@@ -253,6 +518,25 @@ fn fuzz_test(sz: i32) {\n     assert_eq!(i, v.len());\n }\n \n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        #[cfg(not(miri))] // Miri is too slow\n+        fuzz_test(189);\n+    }\n+}\n+\n+#[test]\n+fn test_show() {\n+    let list: LinkedList<_> = (0..10).collect();\n+    assert_eq!(format!(\"{list:?}\"), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+\n+    let list: LinkedList<_> = [\"just\", \"one\", \"test\", \"more\"].into_iter().collect();\n+    assert_eq!(format!(\"{list:?}\"), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+}\n+\n #[test]\n fn drain_filter_test() {\n     let mut m: LinkedList<u32> = LinkedList::new();\n@@ -475,3 +759,398 @@ fn test_cursor_pop_front_back() {\n     assert_eq!(c.current(), None);\n     assert_eq!(c.index, 2);\n }\n+\n+#[test]\n+fn test_extend_ref() {\n+    let mut a = LinkedList::new();\n+    a.push_back(1);\n+\n+    a.extend(&[2, 3, 4]);\n+\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(a, list_from(&[1, 2, 3, 4]));\n+\n+    let mut b = LinkedList::new();\n+    b.push_back(5);\n+    b.push_back(6);\n+    a.extend(&b);\n+\n+    assert_eq!(a.len(), 6);\n+    assert_eq!(a, list_from(&[1, 2, 3, 4, 5, 6]));\n+}\n+\n+#[test]\n+fn test_extend() {\n+    let mut a = LinkedList::new();\n+    a.push_back(1);\n+    a.extend(vec![2, 3, 4]); // uses iterator\n+\n+    assert_eq!(a.len(), 4);\n+    assert!(a.iter().eq(&[1, 2, 3, 4]));\n+\n+    let b: LinkedList<_> = [5, 6, 7].into_iter().collect();\n+    a.extend(b); // specializes to `append`\n+\n+    assert_eq!(a.len(), 7);\n+    assert!(a.iter().eq(&[1, 2, 3, 4, 5, 6, 7]));\n+}\n+\n+#[test]\n+fn test_contains() {\n+    let mut l = LinkedList::new();\n+    l.extend(&[2, 3, 4]);\n+\n+    assert!(l.contains(&3));\n+    assert!(!l.contains(&1));\n+\n+    l.clear();\n+\n+    assert!(!l.contains(&3));\n+}\n+\n+#[test]\n+fn drain_filter_empty() {\n+    let mut list: LinkedList<i32> = LinkedList::new();\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_zst() {\n+    let mut list: LinkedList<_> = [(), (), (), (), ()].into_iter().collect();\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_false() {\n+    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| false);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        for _ in iter.by_ref() {\n+            count += 1;\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, 0);\n+    assert_eq!(list.len(), initial_len);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+}\n+\n+#[test]\n+fn drain_filter_true() {\n+    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n+\n+    let initial_len = list.len();\n+    let mut count = 0;\n+\n+    {\n+        let mut iter = list.drain_filter(|_| true);\n+        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n+        while let Some(_) = iter.next() {\n+            count += 1;\n+            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n+        }\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+        assert_eq!(iter.next(), None);\n+        assert_eq!(iter.size_hint(), (0, Some(0)));\n+    }\n+\n+    assert_eq!(count, initial_len);\n+    assert_eq!(list.len(), 0);\n+    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n+}\n+\n+#[test]\n+fn drain_filter_complex() {\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n+        let mut list = [\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 14);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {\n+        // [xxx++++++xxxxx++++x+x++]\n+        let mut list =\n+            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 13);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n+        );\n+    }\n+\n+    {\n+        // [xxx++++++xxxxx++++x+x]\n+        let mut list =\n+            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n+\n+        assert_eq!(list.len(), 11);\n+        assert_eq!(\n+            list.into_iter().collect::<Vec<_>>(),\n+            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n+        );\n+    }\n+\n+    {\n+        // [xxxxxxxxxx+++++++++++]\n+        let mut list = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+\n+    {\n+        // [+++++++++++xxxxxxxxxx]\n+        let mut list = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n+\n+        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n+        assert_eq!(removed.len(), 10);\n+        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n+\n+        assert_eq!(list.len(), 10);\n+        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n+    }\n+}\n+\n+#[test]\n+fn drain_filter_drop_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+    q.push_front(D(false));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+    assert!(q.is_empty());\n+}\n+\n+#[test]\n+fn drain_filter_pred_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug)]\n+    struct D(u32);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(3));\n+    q.push_back(D(4));\n+    q.push_back(D(5));\n+    q.push_back(D(6));\n+    q.push_back(D(7));\n+    q.push_front(D(2));\n+    q.push_front(D(1));\n+    q.push_front(D(0));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 2); // 0 and 1\n+    assert_eq!(q.len(), 6);\n+}\n+\n+#[test]\n+fn test_drop() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    drop(ring);\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_with_pop() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+\n+    drop(ring.pop_back());\n+    drop(ring.pop_front());\n+    assert_eq!(unsafe { DROPS }, 2);\n+\n+    drop(ring);\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_clear() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.clear();\n+    assert_eq!(unsafe { DROPS }, 4);\n+\n+    drop(ring);\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_panic() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+\n+    catch_unwind(move || drop(q)).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+}"}, {"sha": "fb6468ef30f2d5e025895ce14ab4b58f0de06c1c", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "patch": "@@ -44,7 +44,6 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};\n \n mod arc;\n-mod binary_heap;\n mod borrow;\n mod boxed;\n mod btree_set_hash;"}, {"sha": "65b09cb00c45ddeb06a951f9c7e2037178ed35d3", "filename": "library/alloc/tests/linked_list.rs", "status": "modified", "additions": 0, "deletions": 683, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3/library%2Falloc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flinked_list.rs?ref=a3a5d83e665d37ebffce94e0d5c6cdae5f2852e3", "patch": "@@ -1,241 +1,4 @@\n use std::collections::LinkedList;\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n-\n-#[test]\n-fn test_basic() {\n-    let mut m = LinkedList::<Box<_>>::new();\n-    assert_eq!(m.pop_front(), None);\n-    assert_eq!(m.pop_back(), None);\n-    assert_eq!(m.pop_front(), None);\n-    m.push_front(box 1);\n-    assert_eq!(m.pop_front(), Some(box 1));\n-    m.push_back(box 2);\n-    m.push_back(box 3);\n-    assert_eq!(m.len(), 2);\n-    assert_eq!(m.pop_front(), Some(box 2));\n-    assert_eq!(m.pop_front(), Some(box 3));\n-    assert_eq!(m.len(), 0);\n-    assert_eq!(m.pop_front(), None);\n-    m.push_back(box 1);\n-    m.push_back(box 3);\n-    m.push_back(box 5);\n-    m.push_back(box 7);\n-    assert_eq!(m.pop_front(), Some(box 1));\n-\n-    let mut n = LinkedList::new();\n-    n.push_front(2);\n-    n.push_front(3);\n-    {\n-        assert_eq!(n.front().unwrap(), &3);\n-        let x = n.front_mut().unwrap();\n-        assert_eq!(*x, 3);\n-        *x = 0;\n-    }\n-    {\n-        assert_eq!(n.back().unwrap(), &2);\n-        let y = n.back_mut().unwrap();\n-        assert_eq!(*y, 2);\n-        *y = 1;\n-    }\n-    assert_eq!(n.pop_front(), Some(0));\n-    assert_eq!(n.pop_front(), Some(1));\n-}\n-\n-fn generate_test() -> LinkedList<i32> {\n-    list_from(&[0, 1, 2, 3, 4, 5, 6])\n-}\n-\n-fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-    v.iter().cloned().collect()\n-}\n-\n-#[test]\n-fn test_split_off() {\n-    // singleton\n-    {\n-        let mut m = LinkedList::new();\n-        m.push_back(1);\n-\n-        let p = m.split_off(0);\n-        assert_eq!(m.len(), 0);\n-        assert_eq!(p.len(), 1);\n-        assert_eq!(p.back(), Some(&1));\n-        assert_eq!(p.front(), Some(&1));\n-    }\n-\n-    // not singleton, forwards\n-    {\n-        let u = vec![1, 2, 3, 4, 5];\n-        let mut m = list_from(&u);\n-        let mut n = m.split_off(2);\n-        assert_eq!(m.len(), 2);\n-        assert_eq!(n.len(), 3);\n-        for elt in 1..3 {\n-            assert_eq!(m.pop_front(), Some(elt));\n-        }\n-        for elt in 3..6 {\n-            assert_eq!(n.pop_front(), Some(elt));\n-        }\n-    }\n-    // not singleton, backwards\n-    {\n-        let u = vec![1, 2, 3, 4, 5];\n-        let mut m = list_from(&u);\n-        let mut n = m.split_off(4);\n-        assert_eq!(m.len(), 4);\n-        assert_eq!(n.len(), 1);\n-        for elt in 1..5 {\n-            assert_eq!(m.pop_front(), Some(elt));\n-        }\n-        for elt in 5..6 {\n-            assert_eq!(n.pop_front(), Some(elt));\n-        }\n-    }\n-\n-    // no-op on the last index\n-    {\n-        let mut m = LinkedList::new();\n-        m.push_back(1);\n-\n-        let p = m.split_off(1);\n-        assert_eq!(m.len(), 1);\n-        assert_eq!(p.len(), 0);\n-        assert_eq!(m.back(), Some(&1));\n-        assert_eq!(m.front(), Some(&1));\n-    }\n-}\n-\n-#[test]\n-fn test_iterator() {\n-    let m = generate_test();\n-    for (i, elt) in m.iter().enumerate() {\n-        assert_eq!(i as i32, *elt);\n-    }\n-    let mut n = LinkedList::new();\n-    assert_eq!(n.iter().next(), None);\n-    n.push_front(4);\n-    let mut it = n.iter();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_iterator_clone() {\n-    let mut n = LinkedList::new();\n-    n.push_back(2);\n-    n.push_back(3);\n-    n.push_back(4);\n-    let mut it = n.iter();\n-    it.next();\n-    let mut jt = it.clone();\n-    assert_eq!(it.next(), jt.next());\n-    assert_eq!(it.next_back(), jt.next_back());\n-    assert_eq!(it.next(), jt.next());\n-}\n-\n-#[test]\n-fn test_iterator_double_end() {\n-    let mut n = LinkedList::new();\n-    assert_eq!(n.iter().next(), None);\n-    n.push_front(4);\n-    n.push_front(5);\n-    n.push_front(6);\n-    let mut it = n.iter();\n-    assert_eq!(it.size_hint(), (3, Some(3)));\n-    assert_eq!(it.next().unwrap(), &6);\n-    assert_eq!(it.size_hint(), (2, Some(2)));\n-    assert_eq!(it.next_back().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next_back().unwrap(), &5);\n-    assert_eq!(it.next_back(), None);\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_rev_iter() {\n-    let m = generate_test();\n-    for (i, elt) in m.iter().rev().enumerate() {\n-        assert_eq!((6 - i) as i32, *elt);\n-    }\n-    let mut n = LinkedList::new();\n-    assert_eq!(n.iter().rev().next(), None);\n-    n.push_front(4);\n-    let mut it = n.iter().rev();\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(it.next().unwrap(), &4);\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert_eq!(it.next(), None);\n-}\n-\n-#[test]\n-fn test_mut_iter() {\n-    let mut m = generate_test();\n-    let mut len = m.len();\n-    for (i, elt) in m.iter_mut().enumerate() {\n-        assert_eq!(i as i32, *elt);\n-        len -= 1;\n-    }\n-    assert_eq!(len, 0);\n-    let mut n = LinkedList::new();\n-    assert!(n.iter_mut().next().is_none());\n-    n.push_front(4);\n-    n.push_back(5);\n-    let mut it = n.iter_mut();\n-    assert_eq!(it.size_hint(), (2, Some(2)));\n-    assert!(it.next().is_some());\n-    assert!(it.next().is_some());\n-    assert_eq!(it.size_hint(), (0, Some(0)));\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_iterator_mut_double_end() {\n-    let mut n = LinkedList::new();\n-    assert!(n.iter_mut().next_back().is_none());\n-    n.push_front(4);\n-    n.push_front(5);\n-    n.push_front(6);\n-    let mut it = n.iter_mut();\n-    assert_eq!(it.size_hint(), (3, Some(3)));\n-    assert_eq!(*it.next().unwrap(), 6);\n-    assert_eq!(it.size_hint(), (2, Some(2)));\n-    assert_eq!(*it.next_back().unwrap(), 4);\n-    assert_eq!(it.size_hint(), (1, Some(1)));\n-    assert_eq!(*it.next_back().unwrap(), 5);\n-    assert!(it.next_back().is_none());\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_mut_rev_iter() {\n-    let mut m = generate_test();\n-    for (i, elt) in m.iter_mut().rev().enumerate() {\n-        assert_eq!((6 - i) as i32, *elt);\n-    }\n-    let mut n = LinkedList::new();\n-    assert!(n.iter_mut().rev().next().is_none());\n-    n.push_front(4);\n-    let mut it = n.iter_mut().rev();\n-    assert!(it.next().is_some());\n-    assert!(it.next().is_none());\n-}\n-\n-#[test]\n-fn test_eq() {\n-    let mut n = list_from(&[]);\n-    let mut m = list_from(&[]);\n-    assert!(n == m);\n-    n.push_front(1);\n-    assert!(n != m);\n-    m.push_back(1);\n-    assert!(n == m);\n-\n-    let n = list_from(&[2, 3, 4]);\n-    let m = list_from(&[1, 2, 3]);\n-    assert!(n != m);\n-}\n \n #[test]\n fn test_hash() {\n@@ -256,449 +19,3 @@ fn test_hash() {\n \n     assert!(hash(&x) == hash(&y));\n }\n-\n-#[test]\n-fn test_ord() {\n-    let n = list_from(&[]);\n-    let m = list_from(&[1, 2, 3]);\n-    assert!(n < m);\n-    assert!(m > n);\n-    assert!(n <= n);\n-    assert!(n >= n);\n-}\n-\n-#[test]\n-fn test_ord_nan() {\n-    let nan = 0.0f64 / 0.0;\n-    let n = list_from(&[nan]);\n-    let m = list_from(&[nan]);\n-    assert!(!(n < m));\n-    assert!(!(n > m));\n-    assert!(!(n <= m));\n-    assert!(!(n >= m));\n-\n-    let n = list_from(&[nan]);\n-    let one = list_from(&[1.0f64]);\n-    assert!(!(n < one));\n-    assert!(!(n > one));\n-    assert!(!(n <= one));\n-    assert!(!(n >= one));\n-\n-    let u = list_from(&[1.0f64, 2.0, nan]);\n-    let v = list_from(&[1.0f64, 2.0, 3.0]);\n-    assert!(!(u < v));\n-    assert!(!(u > v));\n-    assert!(!(u <= v));\n-    assert!(!(u >= v));\n-\n-    let s = list_from(&[1.0f64, 2.0, 4.0, 2.0]);\n-    let t = list_from(&[1.0f64, 2.0, 3.0, 2.0]);\n-    assert!(!(s < t));\n-    assert!(s > one);\n-    assert!(!(s <= one));\n-    assert!(s >= one);\n-}\n-\n-#[test]\n-fn test_show() {\n-    let list: LinkedList<_> = (0..10).collect();\n-    assert_eq!(format!(\"{list:?}\"), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n-\n-    let list: LinkedList<_> = [\"just\", \"one\", \"test\", \"more\"].into_iter().collect();\n-    assert_eq!(format!(\"{list:?}\"), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n-}\n-\n-#[test]\n-fn test_extend_ref() {\n-    let mut a = LinkedList::new();\n-    a.push_back(1);\n-\n-    a.extend(&[2, 3, 4]);\n-\n-    assert_eq!(a.len(), 4);\n-    assert_eq!(a, list_from(&[1, 2, 3, 4]));\n-\n-    let mut b = LinkedList::new();\n-    b.push_back(5);\n-    b.push_back(6);\n-    a.extend(&b);\n-\n-    assert_eq!(a.len(), 6);\n-    assert_eq!(a, list_from(&[1, 2, 3, 4, 5, 6]));\n-}\n-\n-#[test]\n-fn test_extend() {\n-    let mut a = LinkedList::new();\n-    a.push_back(1);\n-    a.extend(vec![2, 3, 4]); // uses iterator\n-\n-    assert_eq!(a.len(), 4);\n-    assert!(a.iter().eq(&[1, 2, 3, 4]));\n-\n-    let b: LinkedList<_> = [5, 6, 7].into_iter().collect();\n-    a.extend(b); // specializes to `append`\n-\n-    assert_eq!(a.len(), 7);\n-    assert!(a.iter().eq(&[1, 2, 3, 4, 5, 6, 7]));\n-}\n-\n-#[test]\n-fn test_contains() {\n-    let mut l = LinkedList::new();\n-    l.extend(&[2, 3, 4]);\n-\n-    assert!(l.contains(&3));\n-    assert!(!l.contains(&1));\n-\n-    l.clear();\n-\n-    assert!(!l.contains(&3));\n-}\n-\n-#[test]\n-fn drain_filter_empty() {\n-    let mut list: LinkedList<i32> = LinkedList::new();\n-\n-    {\n-        let mut iter = list.drain_filter(|_| true);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(list.len(), 0);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n-}\n-\n-#[test]\n-fn drain_filter_zst() {\n-    let mut list: LinkedList<_> = [(), (), (), (), ()].into_iter().collect();\n-    let initial_len = list.len();\n-    let mut count = 0;\n-\n-    {\n-        let mut iter = list.drain_filter(|_| true);\n-        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n-        while let Some(_) = iter.next() {\n-            count += 1;\n-            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n-        }\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(count, initial_len);\n-    assert_eq!(list.len(), 0);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n-}\n-\n-#[test]\n-fn drain_filter_false() {\n-    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n-\n-    let initial_len = list.len();\n-    let mut count = 0;\n-\n-    {\n-        let mut iter = list.drain_filter(|_| false);\n-        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n-        for _ in iter.by_ref() {\n-            count += 1;\n-        }\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(count, 0);\n-    assert_eq!(list.len(), initial_len);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n-}\n-\n-#[test]\n-fn drain_filter_true() {\n-    let mut list: LinkedList<_> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n-\n-    let initial_len = list.len();\n-    let mut count = 0;\n-\n-    {\n-        let mut iter = list.drain_filter(|_| true);\n-        assert_eq!(iter.size_hint(), (0, Some(initial_len)));\n-        while let Some(_) = iter.next() {\n-            count += 1;\n-            assert_eq!(iter.size_hint(), (0, Some(initial_len - count)));\n-        }\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-        assert_eq!(iter.next(), None);\n-        assert_eq!(iter.size_hint(), (0, Some(0)));\n-    }\n-\n-    assert_eq!(count, initial_len);\n-    assert_eq!(list.len(), 0);\n-    assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![]);\n-}\n-\n-#[test]\n-fn drain_filter_complex() {\n-    {\n-        //                [+xxx++++++xxxxx++++x+x++]\n-        let mut list = [\n-            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n-            39,\n-        ]\n-        .into_iter()\n-        .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n-\n-        assert_eq!(list.len(), 14);\n-        assert_eq!(\n-            list.into_iter().collect::<Vec<_>>(),\n-            vec![1, 7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n-        );\n-    }\n-\n-    {\n-        // [xxx++++++xxxxx++++x+x++]\n-        let mut list =\n-            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39]\n-                .into_iter()\n-                .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n-\n-        assert_eq!(list.len(), 13);\n-        assert_eq!(\n-            list.into_iter().collect::<Vec<_>>(),\n-            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35, 37, 39]\n-        );\n-    }\n-\n-    {\n-        // [xxx++++++xxxxx++++x+x]\n-        let mut list =\n-            [2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n-                .into_iter()\n-                .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 18, 20, 22, 24, 26, 34, 36]);\n-\n-        assert_eq!(list.len(), 11);\n-        assert_eq!(\n-            list.into_iter().collect::<Vec<_>>(),\n-            vec![7, 9, 11, 13, 15, 17, 27, 29, 31, 33, 35]\n-        );\n-    }\n-\n-    {\n-        // [xxxxxxxxxx+++++++++++]\n-        let mut list = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n-            .into_iter()\n-            .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n-\n-        assert_eq!(list.len(), 10);\n-        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n-    }\n-\n-    {\n-        // [+++++++++++xxxxxxxxxx]\n-        let mut list = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n-            .into_iter()\n-            .collect::<LinkedList<_>>();\n-\n-        let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n-        assert_eq!(removed.len(), 10);\n-        assert_eq!(removed, vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20]);\n-\n-        assert_eq!(list.len(), 10);\n-        assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n-    }\n-}\n-\n-#[test]\n-fn drain_filter_drop_panic_leak() {\n-    static mut DROPS: i32 = 0;\n-\n-    struct D(bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-\n-            if self.0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n-    let mut q = LinkedList::new();\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(true));\n-    q.push_front(D(false));\n-\n-    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n-\n-    assert_eq!(unsafe { DROPS }, 8);\n-    assert!(q.is_empty());\n-}\n-\n-#[test]\n-fn drain_filter_pred_panic_leak() {\n-    static mut DROPS: i32 = 0;\n-\n-    #[derive(Debug)]\n-    struct D(u32);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut q = LinkedList::new();\n-    q.push_back(D(3));\n-    q.push_back(D(4));\n-    q.push_back(D(5));\n-    q.push_back(D(6));\n-    q.push_back(D(7));\n-    q.push_front(D(2));\n-    q.push_front(D(1));\n-    q.push_front(D(0));\n-\n-    catch_unwind(AssertUnwindSafe(|| {\n-        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n-    }))\n-    .ok();\n-\n-    assert_eq!(unsafe { DROPS }, 2); // 0 and 1\n-    assert_eq!(q.len(), 6);\n-}\n-\n-#[test]\n-fn test_drop() {\n-    static mut DROPS: i32 = 0;\n-    struct Elem;\n-    impl Drop for Elem {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut ring = LinkedList::new();\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    drop(ring);\n-\n-    assert_eq!(unsafe { DROPS }, 4);\n-}\n-\n-#[test]\n-fn test_drop_with_pop() {\n-    static mut DROPS: i32 = 0;\n-    struct Elem;\n-    impl Drop for Elem {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut ring = LinkedList::new();\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-\n-    drop(ring.pop_back());\n-    drop(ring.pop_front());\n-    assert_eq!(unsafe { DROPS }, 2);\n-\n-    drop(ring);\n-    assert_eq!(unsafe { DROPS }, 4);\n-}\n-\n-#[test]\n-fn test_drop_clear() {\n-    static mut DROPS: i32 = 0;\n-    struct Elem;\n-    impl Drop for Elem {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-        }\n-    }\n-\n-    let mut ring = LinkedList::new();\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.push_back(Elem);\n-    ring.push_front(Elem);\n-    ring.clear();\n-    assert_eq!(unsafe { DROPS }, 4);\n-\n-    drop(ring);\n-    assert_eq!(unsafe { DROPS }, 4);\n-}\n-\n-#[test]\n-fn test_drop_panic() {\n-    static mut DROPS: i32 = 0;\n-\n-    struct D(bool);\n-\n-    impl Drop for D {\n-        fn drop(&mut self) {\n-            unsafe {\n-                DROPS += 1;\n-            }\n-\n-            if self.0 {\n-                panic!(\"panic in `drop`\");\n-            }\n-        }\n-    }\n-\n-    let mut q = LinkedList::new();\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_back(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(false));\n-    q.push_front(D(true));\n-\n-    catch_unwind(move || drop(q)).ok();\n-\n-    assert_eq!(unsafe { DROPS }, 8);\n-}"}]}