{"sha": "819acb51412ef328542edafc02d233280dbcf26b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxOWFjYjUxNDEyZWYzMjg1NDJlZGFmYzAyZDIzMzI4MGRiY2YyNmI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-05-22T14:55:00Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-05-22T21:23:27Z"}, "message": "Add missing links for CStr and CString", "tree": {"sha": "e232f82cba22694f428691558fbccde31237192e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e232f82cba22694f428691558fbccde31237192e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/819acb51412ef328542edafc02d233280dbcf26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/819acb51412ef328542edafc02d233280dbcf26b", "html_url": "https://github.com/rust-lang/rust/commit/819acb51412ef328542edafc02d233280dbcf26b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/819acb51412ef328542edafc02d233280dbcf26b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81734e0e06d24cf580dd5352c64d10110e4d3b7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/81734e0e06d24cf580dd5352c64d10110e4d3b7b", "html_url": "https://github.com/rust-lang/rust/commit/81734e0e06d24cf580dd5352c64d10110e4d3b7b"}], "stats": {"total": 104, "additions": 74, "deletions": 30}, "files": [{"sha": "1167c39dba8eef63c9589777b6a0928b4de61029", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 74, "deletions": 30, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/819acb51412ef328542edafc02d233280dbcf26b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/819acb51412ef328542edafc02d233280dbcf26b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=819acb51412ef328542edafc02d233280dbcf26b", "patch": "@@ -23,18 +23,20 @@ use ptr;\n use slice;\n use str::{self, Utf8Error};\n \n-/// A type representing an owned C-compatible string\n+/// A type representing an owned C-compatible string.\n ///\n /// This type serves the primary purpose of being able to safely generate a\n /// C-compatible string from a Rust byte slice or vector. An instance of this\n /// type is a static guarantee that the underlying bytes contain no interior 0\n /// bytes and the final byte is 0.\n ///\n-/// A `CString` is created from either a byte slice or a byte vector.  A `u8`\n-/// slice can be obtained with the `as_bytes` method.  Slices produced from a\n+/// A `CString` is created from either a byte slice or a byte vector. A [`u8`]\n+/// slice can be obtained with the `as_bytes` method. Slices produced from a\n /// `CString` do *not* contain the trailing nul terminator unless otherwise\n /// specified.\n ///\n+/// [`u8`]: ../primitive.u8.html\n+///\n /// # Examples\n ///\n /// ```no_run\n@@ -81,12 +83,14 @@ pub struct CString {\n ///\n /// Note that this structure is **not** `repr(C)` and is not recommended to be\n /// placed in the signatures of FFI functions. Instead safe wrappers of FFI\n-/// functions may leverage the unsafe `from_ptr` constructor to provide a safe\n+/// functions may leverage the unsafe [`from_ptr`] constructor to provide a safe\n /// interface to other consumers.\n ///\n+/// [`from_ptr`]: #method.from_ptr\n+///\n /// # Examples\n ///\n-/// Inspecting a foreign C string\n+/// Inspecting a foreign C string:\n ///\n /// ```no_run\n /// use std::ffi::CStr;\n@@ -100,7 +104,7 @@ pub struct CString {\n /// }\n /// ```\n ///\n-/// Passing a Rust-originating C string\n+/// Passing a Rust-originating C string:\n ///\n /// ```no_run\n /// use std::ffi::{CString, CStr};\n@@ -116,7 +120,9 @@ pub struct CString {\n /// work(&s);\n /// ```\n ///\n-/// Converting a foreign C string into a Rust `String`\n+/// Converting a foreign C string into a Rust [`String`]:\n+///\n+/// [`String`]: ../string/struct.String.html\n ///\n /// ```no_run\n /// use std::ffi::CStr;\n@@ -142,14 +148,18 @@ pub struct CStr {\n     inner: [c_char]\n }\n \n-/// An error returned from `CString::new` to indicate that a nul byte was found\n+/// An error returned from [`CString::new`] to indicate that a nul byte was found\n /// in the vector provided.\n+///\n+/// [`CString::new`]: struct.CString.html#method.new\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// An error returned from `CStr::from_bytes_with_nul` to indicate that a nul\n+/// An error returned from [`CStr::from_bytes_with_nul`] to indicate that a nul\n /// byte was found too early in the slice provided or one wasn't found at all.\n+///\n+/// [`CStr::from_bytes_with_nul`]: struct.CStr.html#method.from_bytes_with_nul\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n pub struct FromBytesWithNulError {\n@@ -175,8 +185,10 @@ impl FromBytesWithNulError {\n     }\n }\n \n-/// An error returned from `CString::into_string` to indicate that a UTF-8 error\n+/// An error returned from [`CString::into_string`] to indicate that a UTF-8 error\n /// was encountered during the conversion.\n+///\n+/// [`CString::into_string`]: struct.CString.html#method.into_string\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n pub struct IntoStringError {\n@@ -224,10 +236,12 @@ impl CString {\n     /// Creates a C-compatible string from a byte vector without checking for\n     /// interior 0 bytes.\n     ///\n-    /// This method is equivalent to `new` except that no runtime assertion\n+    /// This method is equivalent to [`new`] except that no runtime assertion\n     /// is made that `v` contains no 0 bytes, and it requires an actual\n     /// byte vector, not anything that can be converted to one with Into.\n     ///\n+    /// [`new`]: #method.new\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -252,9 +266,11 @@ impl CString {\n     /// # Safety\n     ///\n     /// This should only ever be called with a pointer that was earlier\n-    /// obtained by calling `into_raw` on a `CString`. Other usage (e.g. trying to take\n+    /// obtained by calling [`into_raw`] on a `CString`. Other usage (e.g. trying to take\n     /// ownership of a string that was allocated by foreign code) is likely to lead\n     /// to undefined behavior or allocator corruption.\n+    ///\n+    /// [`into_raw`]: #method.into_raw\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n@@ -265,19 +281,23 @@ impl CString {\n     /// Transfers ownership of the string to a C caller.\n     ///\n     /// The pointer must be returned to Rust and reconstituted using\n-    /// `from_raw` to be properly deallocated. Specifically, one\n+    /// [`from_raw`] to be properly deallocated. Specifically, one\n     /// should *not* use the standard C `free` function to deallocate\n     /// this string.\n     ///\n-    /// Failure to call `from_raw` will lead to a memory leak.\n+    /// Failure to call [`from_raw`] will lead to a memory leak.\n+    ///\n+    /// [`from_raw`]: #method.from_raw\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub fn into_raw(self) -> *mut c_char {\n         Box::into_raw(self.into_inner()) as *mut c_char\n     }\n \n-    /// Converts the `CString` into a `String` if it contains valid Unicode data.\n+    /// Converts the `CString` into a [`String`] if it contains valid Unicode data.\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n+    ///\n+    /// [`String`]: ../string/struct.String.html\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes())\n@@ -299,8 +319,10 @@ impl CString {\n         vec\n     }\n \n-    /// Equivalent to the `into_bytes` function except that the returned vector\n+    /// Equivalent to the [`into_bytes`] function except that the returned vector\n     /// includes the trailing nul byte.\n+    ///\n+    /// [`into_bytes`]: #method.into_bytes\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes_with_nul(self) -> Vec<u8> {\n         self.into_inner().into_vec()\n@@ -315,26 +337,34 @@ impl CString {\n         &self.inner[..self.inner.len() - 1]\n     }\n \n-    /// Equivalent to the `as_bytes` function except that the returned slice\n+    /// Equivalent to the [`as_bytes`] function except that the returned slice\n     /// includes the trailing nul byte.\n+    ///\n+    /// [`as_bytes`]: #method.as_bytes\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_bytes_with_nul(&self) -> &[u8] {\n         &self.inner\n     }\n \n-    /// Extracts a `CStr` slice containing the entire string.\n+    /// Extracts a [`CStr`] slice containing the entire string.\n+    ///\n+    /// [`CStr`]: struct.CStr.html\n     #[unstable(feature = \"as_c_str\", issue = \"40380\")]\n     pub fn as_c_str(&self) -> &CStr {\n         &*self\n     }\n \n-    /// Converts this `CString` into a boxed `CStr`.\n+    /// Converts this `CString` into a boxed [`CStr`].\n+    ///\n+    /// [`CStr`]: struct.CStr.html\n     #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_boxed_c_str(self) -> Box<CStr> {\n         unsafe { mem::transmute(self.into_inner()) }\n     }\n \n-    // Bypass \"move out of struct which implements `Drop` trait\" restriction.\n+    // Bypass \"move out of struct which implements [`Drop`] trait\" restriction.\n+    ///\n+    /// [`Drop`]: ../ops/trait.Drop.html\n     fn into_inner(self) -> Box<[u8]> {\n         unsafe {\n             let result = ptr::read(&self.inner);\n@@ -443,7 +473,9 @@ impl Default for Box<CStr> {\n \n impl NulError {\n     /// Returns the position of the nul byte in the slice that was provided to\n-    /// `CString::new`.\n+    /// [`CString::new`].\n+    ///\n+    /// [`CString::new`]: struct.CString.html#method.new\n     ///\n     /// # Examples\n     ///\n@@ -518,8 +550,10 @@ impl fmt::Display for FromBytesWithNulError {\n }\n \n impl IntoStringError {\n-    /// Consumes this error, returning original `CString` which generated the\n+    /// Consumes this error, returning original [`CString`] which generated the\n     /// error.\n+    ///\n+    /// [`CString`]: struct.CString.html\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_cstring(self) -> CString {\n         self.inner\n@@ -557,9 +591,9 @@ impl CStr {\n     /// allows inspection and interoperation of non-owned C strings. This method\n     /// is unsafe for a number of reasons:\n     ///\n-    /// * There is no guarantee to the validity of `ptr`\n+    /// * There is no guarantee to the validity of `ptr`.\n     /// * The returned lifetime is not guaranteed to be the actual lifetime of\n-    ///   `ptr`\n+    ///   `ptr`.\n     /// * There is no guarantee that the memory pointed to by `ptr` contains a\n     ///   valid nul terminator byte at the end of the string.\n     ///\n@@ -703,26 +737,30 @@ impl CStr {\n \n     /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n-    /// This function is the equivalent of `to_bytes` except that it will retain\n+    /// This function is the equivalent of [`to_bytes`] except that it will retain\n     /// the trailing nul instead of chopping it off.\n     ///\n     /// > **Note**: This method is currently implemented as a 0-cost cast, but\n     /// > it is planned to alter its definition in the future to perform the\n     /// > length calculation whenever this method is called.\n+    ///\n+    /// [`to_bytes`]: #method.to_bytes\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_bytes_with_nul(&self) -> &[u8] {\n         unsafe { mem::transmute(&self.inner) }\n     }\n \n-    /// Yields a `&str` slice if the `CStr` contains valid UTF-8.\n+    /// Yields a [`&str`] slice if the `CStr` contains valid UTF-8.\n     ///\n     /// This function will calculate the length of this string and check for\n-    /// UTF-8 validity, and then return the `&str` if it's valid.\n+    /// UTF-8 validity, and then return the [`&str`] if it's valid.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n     /// > future to perform the length calculation in addition to the UTF-8\n     /// > check whenever this method is called.\n+    ///\n+    /// [`&str`]: ../primitive.str.html\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n         // NB: When CStr is changed to perform the length check in .to_bytes()\n@@ -732,23 +770,29 @@ impl CStr {\n         str::from_utf8(self.to_bytes())\n     }\n \n-    /// Converts a `CStr` into a `Cow<str>`.\n+    /// Converts a `CStr` into a [`Cow`]`<`[`str`]`>`.\n     ///\n     /// This function will calculate the length of this string (which normally\n     /// requires a linear amount of work to be done) and then return the\n-    /// resulting slice as a `Cow<str>`, replacing any invalid UTF-8 sequences\n+    /// resulting slice as a [`Cow`]`<`[`str`]`>`, replacing any invalid UTF-8 sequences\n     /// with `U+FFFD REPLACEMENT CHARACTER`.\n     ///\n     /// > **Note**: This method is currently implemented to check for validity\n     /// > after a 0-cost cast, but it is planned to alter its definition in the\n     /// > future to perform the length calculation in addition to the UTF-8\n     /// > check whenever this method is called.\n+    ///\n+    /// [`Cow`]: ../borrow/enum.Cow.html\n+    /// [`str`]: ../primitive.str.html\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         String::from_utf8_lossy(self.to_bytes())\n     }\n \n-    /// Converts a `Box<CStr>` into a `CString` without copying or allocating.\n+    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n+    ///\n+    /// [`Box`]: ../boxed/struct.Box.html\n+    /// [`CString`]: struct.CString.html\n     #[unstable(feature = \"into_boxed_c_str\", issue = \"40380\")]\n     pub fn into_c_string(self: Box<CStr>) -> CString {\n         unsafe { mem::transmute(self) }"}]}