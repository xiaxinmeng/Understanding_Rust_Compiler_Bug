{"sha": "31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "node_id": "C_kwDOAAsO6NoAKDMxZTFjZGU0YjViZDcwZGZlODkyZjVlN2JjNDQ5YWQzYTZlMWQ3NzM", "commit": {"author": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-26T19:55:05Z"}, "committer": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-30T00:18:27Z"}, "message": "clean up pointer docs", "tree": {"sha": "c82816a3c1878b3d9d7c6107f1c78895c734f57b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c82816a3c1878b3d9d7c6107f1c78895c734f57b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "html_url": "https://github.com/rust-lang/rust/commit/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b608df8277d0e21dd04b73691a56b124ef125d6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b608df8277d0e21dd04b73691a56b124ef125d6a", "html_url": "https://github.com/rust-lang/rust/commit/b608df8277d0e21dd04b73691a56b124ef125d6a"}], "stats": {"total": 121, "additions": 84, "deletions": 37}, "files": [{"sha": "20ee12802642169b7605f86bef50ec95ef80a38d", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "patch": "@@ -156,14 +156,16 @@ impl<T: ?Sized> *const T {\n     /// *provenance* and *address-space* information. To properly restore that information,\n     /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n     ///\n-    /// On most platforms this information isn't represented at runtime, and so the loss\n-    /// of information is \"only\" semantic. On more complicated platforms like miri, CHERI,\n-    /// and segmented architectures, this may result in an actual change of representation\n-    /// and the loss of information.\n+    /// On most platforms this will produce a value with the same bytes as the original\n+    /// pointer, because all the bytes are dedicated to describing the address.\n+    /// Platforms which need to store additional information in the pointer may\n+    /// perform a change of representation to produce a value containing only the address\n+    /// portion of the pointer. What that means is up to the platform to define.\n     ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n     /// see the [module documentation][crate::ptr] for details.\n     #[must_use]\n+    #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn addr(self) -> usize\n     where\n@@ -180,12 +182,13 @@ impl<T: ?Sized> *const T {\n     /// This allows us to dynamically preserve and propagate this important\n     /// information in a way that is otherwise impossible with a unary cast.\n     ///\n-    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset `self` to the\n-    /// given address, and therefore has all the same capabilities and restrictions.\n+    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset\n+    /// `self` to the given address, and therefore has all the same capabilities and restrictions.\n     ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n     /// see the [module documentation][crate::ptr] for details.\n     #[must_use]\n+    #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn with_addr(self, addr: usize) -> Self\n     where\n@@ -211,6 +214,7 @@ impl<T: ?Sized> *const T {\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n     /// see the [module documentation][crate::ptr] for details.\n     #[must_use]\n+    #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n     where"}, {"sha": "6d04add67d1768eb060d06cb7105440638c4db5d", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "patch": "@@ -66,22 +66,30 @@\n //!\n //! # Strict Provenance\n //!\n-//! This section is *non-normative* and describes an experimental set of APIs that help tools\n-//! that validate the memory-safety of your program's execution. Notably this includes [miri][]\n+//! **The following text is non-normative, insufficiently formal, and is an extremely strict\n+//! interpretation of provenance. It's ok if your code doesn't strictly conform to it.**\n+//!\n+//! [Strict Provenance][] is an experimental set of APIs that help tools that try\n+//! to validate the memory-safety of your program's execution. Notably this includes [miri][]\n //! and [CHERI][], which can detect when you access out of bounds memory or otherwise violate\n //! Rust's memory model.\n //!\n-//! **The following text is overly strict and insufficiently formal, and is an extremely\n-//! strict interpretation of provenance.** Provenance must exist in some form for any language\n-//! higher-level than an assembler, but to our knowledge no one has ever been able to square\n-//! the notion of provenance with all the operations that programmers believe should be permitted.\n+//! Provenance must exist in some form for any programming\n+//! language compiled for modern computer architectures, but specifying a model for provenance\n+//! in a way that is useful to both compilers and programmers is an ongoing challenge.\n //! The [Strict Provenance][] experiment seeks to explore the question: *what if we just said you\n //! couldn't do all the nasty operations that make provenance so messy?*\n //!\n //! What APIs would have to be removed? What APIs would have to be added? How much would code\n //! have to change, and is it worse or better now? Would any patterns become truly inexpressible?\n-//! Could we carve out special exceptions for those patterns?\n+//! Could we carve out special exceptions for those patterns? Should we?\n //!\n+//! A secondary goal of this project is to see if we can disamiguate the many functions of\n+//! pointer<->integer casts enough for the definition of `usize` to be loosened so that it\n+//! isn't *pointer*-sized but address-space/offset/allocation-sized (we'll probably continue\n+//! to conflate these notions). This would potentially make it possible to more efficiently\n+//! target platforms where pointers are larger than offsets, such as CHERI and maybe some\n+//! segmented architecures.\n //!\n //! ## Provenance\n //!\n@@ -102,26 +110,37 @@\n //! The Original Pointer for an allocation is guaranteed to have unique access to the entire\n //! allocation and *only* that allocation. In this sense, an allocation can be thought of\n //! as a \"sandbox\" that cannot be broken into or out of. *Provenance* is the permission\n-//! to access an allocation's sandbox and consists of:\n+//! to access an allocation's sandbox and has both a *spatial* and *temporal* component:\n+//!\n+//! * Spatial: A range of bytes in the allocation that the pointer is allowed to access.\n+//! * Temporal: Some kind of globally unique identifier tied to the allocation itself.\n //!\n-//! * Some kind of globally unique identifier tied to the allocation itself.\n-//! * A range of bytes in the allocation that the pointer is allowed to access.\n+//! Spatial provenance makes sure you don't go beyond your sandbox, while temporal provenance\n+//! makes sure that you can't \"get lucky\" after your permission to access some memory\n+//! has been revoked (either through deallocations or borrows expiring).\n //!\n //! Provenance is implicitly shared with all pointers transitively derived from\n //! The Original Pointer through operations like [`offset`], borrowing, and pointer casts.\n-//! Some operations may produce a pointer whose provenance has a smaller range\n-//! than the one it's derived from (i.e. borrowing a subfield and subslicing).\n+//! Some operations may *shrink* the derived provenance, limiting how much memory it can\n+//! access or how long it's valid for (i.e. borrowing a subfield and subslicing).\n //!\n //! Shrinking provenance cannot be undone: even if you \"know\" there is a larger allocation, you\n //! can't derive a pointer with a larger provenance. Similarly, you cannot \"recombine\"\n //! two contiguous provenances back into one (i.e. with a `fn merge(&[T], &[T]) -> &[T]`).\n //!\n //! A reference to a value always has provenance over exactly the memory that field occupies.\n-//! A reference slice always has provenance over exactly the range that slice describes.\n+//! A reference to a slice always has provenance over exactly the range that slice describes.\n //!\n //! If an allocation is deallocated, all pointers with provenance to that allocation become\n //! invalidated, and effectively lose their provenance.\n //!\n+//! The strict provenance experiment is mostly only interested in exploring stricter *spatial*\n+//! provenance. In this sense it can be thought of as a subset of the more ambitious and\n+//! formal [Stacked Borrows][] research project, which is what tools like [miri][] are based on.\n+//! In particular, Stacked Borrows is necessary to properly describe what borrows are allowed\n+//! to do and when they become invalidated. This necessarily involves much more complex\n+//! *temporal* reasoning than simply identifying allocations.\n+//!\n //!\n //! ## Pointer Vs Addresses\n //!\n@@ -241,20 +260,33 @@\n //!   be used for sentinel values like `null` *or* to represent a tagged pointer that will\n //!   never be dereferencable.\n //!\n-//! * [`wrapping_offset`][] a pointer outside its provenance. This includes invalid pointers\n-//!   which have no provenance. Unfortunately there may be practical limits on this for a\n-//!   particular platform ([CHERI][] may mark your pointers as invalid, but it has a pretty\n-//!   generour buffer that is *at least* 1KB on each side of the provenance). Note that\n-//!   least-significant-bit tagging is generally pretty robust, and often doesn't even\n-//!   go out of bounds because types have a size >= align.\n-//!\n //! * Forge an allocation of size zero at any sufficiently aligned non-null address.\n //!   i.e. the usual \"ZSTs are fake, do what you want\" rules apply *but* this only applies\n //!   for actual forgery (integers cast to pointers). If you borrow some structs subfield\n //!   that *happens* to be zero-sized, the resulting pointer will have provenance tied to\n //!   that allocation and it will still get invalidated if the allocation gets deallocated.\n //!   In the future we may introduce an API to make such a forged allocation explicit.\n //!\n+//! * [`wrapping_offset`][] a pointer outside its provenance. This includes invalid pointers\n+//!   which have \"no\" provenance. Unfortunately there may be practical limits on this for a\n+//!   particular platform, and it's an open question as to how to specify this (if at all).\n+//!   Notably, [CHERI][] relies on a compression scheme that can't handle a\n+//!   pointer getting offset \"too far\" out of bounds. If this happens, the address\n+//!   returned by `addr` will be the value you expect, but the provenance will get invalidated\n+//!   and using it to read/write will fault. The details of this are architecture-specific\n+//!   and based on alignment, but the buffer on either side of the pointer's range is pretty\n+//!   generous (think kilobytes, not bytes).\n+//!\n+//! * Perform pointer tagging tricks. This falls out of [`wrapping_offset`] but is worth\n+//!   mentioning in more detail because of the limitations of [CHERI][]. Low-bit tagging\n+//!   is very robust, and often doesn't even go out of bounds because types have a\n+//!   size >= align (and over-aligning actually gives CHERI more flexibility). Anything\n+//!   more complex than this rapidly enters \"extremely platform-specific\" territory as\n+//!   certain things may or may not be allowed based on specific supported operations.\n+//!   For instance, ARM explicitly supports high-bit tagging, and so CHERI on ARM inherits\n+//!   that and should support it.\n+//!\n+//!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n //! [ub]: ../../reference/behavior-considered-undefined.html\n@@ -269,6 +301,7 @@\n //! [miri]: https://github.com/rust-lang/miri\n //! [CHERI]: https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/\n //! [Strict Provenance]: https://github.com/rust-lang/rust/issues/95228\n+//! [Stacked Borrows]: https://plv.mpi-sws.org/rustbelt/stacked-borrows/\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -410,7 +443,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n #[rustc_diagnostic_item = \"ptr_null\"]\n pub const fn null<T>() -> *const T {\n-    invalid::<T>(0)\n+    invalid(0)\n }\n \n /// Creates a null mutable raw pointer.\n@@ -430,22 +463,25 @@ pub const fn null<T>() -> *const T {\n #[rustc_const_stable(feature = \"const_ptr_null\", since = \"1.24.0\")]\n #[rustc_diagnostic_item = \"ptr_null_mut\"]\n pub const fn null_mut<T>() -> *mut T {\n-    invalid_mut::<T>(0)\n+    invalid_mut(0)\n }\n \n /// Creates an invalid pointer with the given address.\n ///\n /// This is *currently* equivalent to `addr as *const T` but it expresses the intended semantic\n /// more clearly, and may become important under future memory models.\n ///\n-/// The module's to-level documentation discusses the precise meaning of an \"invalid\"\n+/// The module's top-level documentation discusses the precise meaning of an \"invalid\"\n /// pointer but essentially this expresses that the pointer is not associated\n /// with any actual allocation and is little more than a usize address in disguise.\n ///\n /// This pointer will have no provenance associated with it and is therefore\n /// UB to read/write/offset. This mostly exists to facilitate things\n /// like ptr::null and NonNull::dangling which make invalid pointers.\n ///\n+/// (Standard \"Zero-Sized-Types get to cheat and lie\" caveats apply, although it\n+/// may be desirable to give them their own API just to make that 100% clear.)\n+///\n /// This API and its claimed semantics are part of the Strict Provenance experiment,\n /// see the [module documentation][crate::ptr] for details.\n #[inline(always)]\n@@ -459,17 +495,20 @@ pub const fn invalid<T>(addr: usize) -> *const T {\n \n /// Creates an invalid mutable pointer with the given address.\n ///\n-/// This is *currently* equivalent to `addr as *const T` but it expresses the intended semantic\n+/// This is *currently* equivalent to `addr as *mut T` but it expresses the intended semantic\n /// more clearly, and may become important under future memory models.\n ///\n-/// The module's to-level documentation discusses the precise meaning of an \"invalid\"\n+/// The module's top-level documentation discusses the precise meaning of an \"invalid\"\n /// pointer but essentially this expresses that the pointer is not associated\n /// with any actual allocation and is little more than a usize address in disguise.\n ///\n /// This pointer will have no provenance associated with it and is therefore\n /// UB to read/write/offset. This mostly exists to facilitate things\n /// like ptr::null and NonNull::dangling which make invalid pointers.\n ///\n+/// (Standard \"Zero-Sized-Types get to cheat and lie\" caveats apply, although it\n+/// may be desirable to give them their own API just to make that 100% clear.)\n+///\n /// This API and its claimed semantics are part of the Strict Provenance experiment,\n /// see the [module documentation][crate::ptr] for details.\n #[inline(always)]"}, {"sha": "547208025214a173718216202e3dbecb7eac1510", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=31e1cde4b5bd70dfe892f5e7bc449ad3a6e1d773", "patch": "@@ -160,14 +160,16 @@ impl<T: ?Sized> *mut T {\n     /// *provenance* and *address-space* information. To properly restore that information,\n     /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n     ///\n-    /// On most platforms this information isn't represented at runtime, and so the loss\n-    /// of information is \"only\" semantic. On more complicated platforms like miri, CHERI,\n-    /// and segmented architectures, this may result in an actual change of representation\n-    /// and the loss of information.\n+    /// On most platforms this will produce a value with the same bytes as the original\n+    /// pointer, because all the bytes are dedicated to describing the address.\n+    /// Platforms which need to store additional information in the pointer may\n+    /// perform a change of representation to produce a value containing only the address\n+    /// portion of the pointer. What that means is up to the platform to define.\n     ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n     /// see the [module documentation][crate::ptr] for details.\n     #[must_use]\n+    #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn addr(self) -> usize\n     where\n@@ -184,12 +186,13 @@ impl<T: ?Sized> *mut T {\n     /// This allows us to dynamically preserve and propagate this important\n     /// information in a way that is otherwise impossible with a unary cast.\n     ///\n-    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset `self` to the\n-    /// given address, and therefore has all the same capabilities and restrictions.\n+    /// This is equivalent to using [`wrapping_offset`][pointer::wrapping_offset] to offset\n+    /// `self` to the given address, and therefore has all the same capabilities and restrictions.\n     ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n     /// see the [module documentation][crate::ptr] for details.\n     #[must_use]\n+    #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn with_addr(self, addr: usize) -> Self\n     where\n@@ -215,6 +218,7 @@ impl<T: ?Sized> *mut T {\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n     /// see the [module documentation][crate::ptr] for details.\n     #[must_use]\n+    #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n     pub fn map_addr(self, f: impl FnOnce(usize) -> usize) -> Self\n     where"}]}