{"sha": "bd28fa4af5b5200b274b8e965a422174fb7ad354", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMjhmYTRhZjViNTIwMGIyNzRiOGU5NjVhNDIyMTc0ZmI3YWQzNTQ=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2013-01-19T09:59:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:04:10Z"}, "message": "rustpkg: Finish all commands and declarative logic", "tree": {"sha": "1fcd297c24ad7a3e19fafaccec3225ca7a0063b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fcd297c24ad7a3e19fafaccec3225ca7a0063b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd28fa4af5b5200b274b8e965a422174fb7ad354", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd28fa4af5b5200b274b8e965a422174fb7ad354", "html_url": "https://github.com/rust-lang/rust/commit/bd28fa4af5b5200b274b8e965a422174fb7ad354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd28fa4af5b5200b274b8e965a422174fb7ad354/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "321e3c490906fed6ed1d46a7cbd2d2f9a42c9a53", "url": "https://api.github.com/repos/rust-lang/rust/commits/321e3c490906fed6ed1d46a7cbd2d2f9a42c9a53", "html_url": "https://github.com/rust-lang/rust/commit/321e3c490906fed6ed1d46a7cbd2d2f9a42c9a53"}], "stats": {"total": 733, "additions": 640, "deletions": 93}, "files": [{"sha": "aec3f21eb6f332e4417bb0cd09f532e54488aa68", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 266, "deletions": 65, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/bd28fa4af5b5200b274b8e965a422174fb7ad354/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bd28fa4af5b5200b274b8e965a422174fb7ad354/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=bd28fa4af5b5200b274b8e965a422174fb7ad354", "patch": "@@ -29,6 +29,7 @@ use core::*;\n use io::{ReaderUtil, WriterUtil};\n use std::getopts;\n use std::net::url;\n+use send_map::linear::LinearMap;\n use rustc::driver::{driver, session};\n use rustc::metadata::{filesearch};\n use syntax::{ast, attr, codemap, diagnostic, parse, visit};\n@@ -38,6 +39,8 @@ mod api;\n mod usage;\n mod util;\n \n+use util::Package;\n+\n struct PackageScript {\n     id: ~str,\n     name: ~str,\n@@ -167,23 +170,26 @@ impl PackageScript {\n         }\n \n         let id = id.get();\n-        let vers = vers.get();\n+        let name = match util::parse_name(id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => return result::Err(err)\n+        };\n+        let vers = match util::parse_vers(vers.get()) {\n+            result::Ok(vers) => vers,\n+            result::Err(err) => return result::Err(err)\n+        };\n \n         result::Ok(PackageScript {\n             id: id,\n-            name: util::parse_id(id),\n-            vers: util::parse_vers(vers),\n+            name: name,\n+            vers: vers,\n             crates: crates,\n             deps: deps\n         })\n     }\n \n     fn hash() -> ~str {\n-        let hasher = hash::default_state();\n-\n-        hasher.write_str(self.id + self.vers.to_str());\n-\n-        fmt!(\"%s-%s-%s\", self.name, hasher.result_str(), self.vers.to_str())\n+        fmt!(\"%s-%s-%s\", self.name, util::hash(self.id + self.vers.to_str()), self.vers.to_str())\n     }\n \n     fn work_dir() -> Path {\n@@ -192,8 +198,8 @@ impl PackageScript {\n }\n \n struct Ctx {\n-    cfgs: ~[~str],\n-    prefer: bool\n+    cfg: ast::crate_cfg,\n+    mut dep_cache: LinearMap<~str, bool>\n }\n \n impl Ctx {\n@@ -213,8 +219,10 @@ impl Ctx {\n \n             if parts.len() >= 1 {\n                 name = Some(parts[0]);\n-            } else if parts.len() >= 2 {\n-                vers = Some(parts[1]);\n+\n+                if parts.len() >= 2 {\n+                    vers = Some(parts[1]);\n+                }\n             }\n \n             (name, vers)\n@@ -301,7 +309,8 @@ impl Ctx {\n         }\n \n         for script.crates.each |&crate| {\n-            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[]);\n+            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[],\n+                                   false, false);\n \n             if !success { break; }\n         }\n@@ -318,15 +327,20 @@ impl Ctx {\n         true\n     }\n \n-    fn compile(dir: &Path, crate: &Path, flags: ~[~str]) -> bool {\n+    fn compile(dir: &Path, crate: &Path, flags: ~[~str],\n+               opt: bool, test: bool) -> bool {\n         util::note(~\"compiling \" + crate.to_str());\n \n         let lib_dir = dir.push(~\"lib\");\n         let bin_dir = dir.push(~\"bin\");\n+        let test_dir = dir.push(~\"test\");\n         let binary = os::args()[0];\n         let options: @session::options = @{\n             binary: binary,\n+            addl_lib_search_paths: ~[util::root().push(~\"lib\")],\n             crate_type: session::unknown_crate,\n+            optimize: if opt { session::Aggressive } else { session::No },\n+            test: test,\n             .. *session::basic_options()\n         };\n         let input = driver::file_input(*crate);\n@@ -421,19 +435,33 @@ impl Ctx {\n             }\n         };\n \n-        if is_bin {\n-            let hasher = hash::default_state();\n+        if test {\n+            util::need_dir(&test_dir);\n \n+            outputs = driver::build_output_filenames(input, &Some(test_dir),\n+                                                     &None, sess)\n+        }\n+        else if is_bin {\n             util::need_dir(&bin_dir);\n-            hasher.write_str(name + uuid + vers);\n \n-            let path = bin_dir.push(fmt!(\"%s-%s-%s\", name, hasher.result_str(), vers));\n+            #[cfg(windows)]\n+            fn suffix() -> ~str { ~\".exe\" }\n+\n+            #[cfg(target_os = \"linux\")]\n+            #[cfg(target_os = \"android\")]\n+            #[cfg(target_os = \"freebsd\")]\n+            #[cfg(target_os = \"macos\")]\n+            fn suffix() -> ~str { ~\"\" }\n+\n+            let path = bin_dir.push(fmt!(\"%s-%s-%s%s\", name,\n+                                                       util::hash(name + uuid + vers),\n+                                                       vers, suffix()));\n             outputs = driver::build_output_filenames(input, &None, &Some(path), sess);\n         } else {\n             util::need_dir(&lib_dir);\n \n-            outputs = driver::build_output_filenames(input, &Some(lib_dir), &None,\n-                                                     sess)\n+            outputs = driver::build_output_filenames(input, &Some(lib_dir),\n+                                                     &None, sess)\n         }\n \n         driver::compile_upto(sess, cfg, input, driver::cu_everything,\n@@ -456,19 +484,14 @@ impl Ctx {\n         util::note(fmt!(\"cleaning %s v%s (%s)\", script.name, script.vers.to_str(),\n                                                 script.id));\n \n-        if os::path_is_dir(&dir) {\n-            if os::remove_dir(&dir) {\n-                util::note(fmt!(\"cleaned %s v%s\", script.name,\n-                                                  script.vers.to_str()));\n-            } else {\n-                util::error(fmt!(\"cleaning %s v%s failed\",\n-                                 script.name, script.vers.to_str()));\n-            }\n-        } else {\n-            util::note(fmt!(\"cleaned %s v%s\", script.name,\n-                                              script.vers.to_str()));\n+        if os::path_exists(&dir) {\n+            util::remove_dir_r(&dir);\n+            util::note(fmt!(\"removed %s\", dir.to_str()));\n         }\n \n+        util::note(fmt!(\"cleaned %s v%s\", script.name,\n+                                          script.vers.to_str()));\n+\n         true\n     }\n \n@@ -482,15 +505,17 @@ impl Ctx {\n             dir = os::getcwd();\n         } else {\n             let url = url.get();\n-            let hasher = hash::default_state();\n+            let hash = util::hash(if !target.is_none() { url + target.get() } else { url });\n \n-            hasher.write_str(url);\n+            if self.dep_cache.contains_key(&hash) {\n+                util::warn(~\"already installed dep this run\");\n \n-            if !target.is_none() {\n-                hasher.write_str(target.get());\n+                return true;\n             }\n \n-            dir = util::root().push(~\"tmp\").push(hasher.result_str());\n+            self.dep_cache.insert(hash, true);\n+\n+            dir = util::root().push(~\"tmp\").push(hash);\n \n             if cache && os::path_exists(&dir) {\n                 return true;\n@@ -538,7 +563,8 @@ impl Ctx {\n         }\n \n         for script.crates.each |&crate| {\n-            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[]);\n+            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[],\n+                                 true, false);\n \n             if !success { break; }\n         }\n@@ -549,24 +575,37 @@ impl Ctx {\n             return false;\n         }\n \n-        let from_bin_dir = dir.push(~\"bin\");\n-        let from_lib_dir = dir.push(~\"lib\");\n+        let from_bin_dir = work_dir.push(~\"bin\");\n+        let from_lib_dir = work_dir.push(~\"lib\");\n         let to_bin_dir = util::root().push(~\"bin\");\n         let to_lib_dir = util::root().push(~\"lib\");\n+        let mut bins = ~[];\n+        let mut libs = ~[];\n \n         for os::walk_dir(&from_bin_dir) |bin| {\n             let to = to_bin_dir.push_rel(&bin.file_path());\n \n             os::copy_file(bin, &to);\n+            bins.push(to.to_str());\n         }\n+\n         for os::walk_dir(&from_lib_dir) |lib| {\n             let to = to_lib_dir.push_rel(&lib.file_path());\n \n             os::copy_file(lib, &to);\n+            libs.push(to.to_str());\n         }\n \n+        let package = Package {\n+            id: script.id,\n+            vers: script.vers,\n+            bins: bins,\n+            libs: libs\n+        };\n+\n         util::note(fmt!(\"installed %s v%s\", script.name,\n                                             script.vers.to_str()));\n+        util::add_pkg(&package);\n \n         true\n     }\n@@ -626,21 +665,7 @@ impl Ctx {\n         util::note(fmt!(\"fetching from %s using git\", url));\n \n         // Git can't clone into a non-empty directory\n-        for os::walk_dir(dir) |&file| {\n-            let mut cdir = file;\n-\n-            loop {\n-                if os::path_is_dir(&cdir) {\n-                    os::remove_dir(&cdir);\n-                } else {\n-                    os::remove_file(&cdir);\n-                }\n-\n-                cdir = cdir.dir_path();\n-\n-                if cdir == *dir { break; }\n-            }\n-        }\n+        util::remove_dir_r(dir);\n \n         if run::program_output(~\"git\", ~[~\"clone\", url, dir.to_str()]).status != 0 {\n             util::error(~\"fetching failed: can't clone repository\");\n@@ -665,40 +690,210 @@ impl Ctx {\n         true\n     }\n \n-    fn prefer(name: ~str, vers: Option<~str>) -> bool {\n+    fn prefer(id: ~str, vers: Option<~str>) -> bool {\n+        let package = match util::get_pkg(id, vers) {\n+            result::Ok(package) => package,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let name = match util::parse_name(package.id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+\n+        util::note(fmt!(\"preferring %s v%s (%s)\", name, package.vers.to_str(),\n+                                                  package.id));\n+\n+        let bin_dir = util::root().push(~\"bin\");\n+\n+        for package.bins.each |&bin| {\n+            let path = Path(bin);\n+            let name = str::split_char(path.file_path().to_str(), '-')[0];\n+            let out = bin_dir.push(name);\n+\n+            util::link_exe(&path, &out);\n+            util::note(fmt!(\"linked %s\", out.to_str()));\n+        }\n+\n+        util::note(fmt!(\"preferred %s v%s\", name, package.vers.to_str()));\n+\n         true\n     }\n \n     fn test() -> bool {\n+        let dir = os::getcwd();\n+        let script = match PackageScript::parse(dir) {\n+            result::Ok(script) => script,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false; \n+            }\n+        };\n+        let work_dir = script.work_dir();\n+        let test_dir = work_dir.push(~\"test\");\n+        let mut success = true;\n+\n+        util::need_dir(&work_dir);\n+        util::note(fmt!(\"testing %s v%s (%s)\", script.name, script.vers.to_str(),\n+                                               script.id));\n+\n+        if script.deps.len() >= 1 {\n+            util::note(~\"installing dependencies\");\n+\n+            for script.deps.each |&dep| {\n+                let (url, target) = dep;\n+\n+                success = self.install(Some(url), target, true);\n+\n+                if !success { break; }\n+            }\n+\n+\n+            if !success {\n+                util::error(fmt!(\"testing %s v%s failed: a dep wasn't installed\",\n+                                 script.name, script.vers.to_str()));\n+\n+                return false;\n+            }\n+\n+            util::note(~\"installed dependencies\");\n+        }\n+\n+        for script.crates.each |&crate| {\n+            success = self.compile(&work_dir, &dir.push_rel(&Path(crate)), ~[],\n+                                   false, true);\n+\n+            if !success { break; }\n+        }\n+\n+        if !success {\n+            util::error(fmt!(\"testing %s v%s failed: a crate failed to compile\",\n+                             script.name, script.vers.to_str()));\n+\n+            return false;\n+        }\n+\n+        for os::walk_dir(&test_dir) |test| {\n+            util::note(fmt!(\"running %s\", test.to_str()));\n+\n+            let status = run::run_program(test.to_str(), ~[]);\n+\n+            if status != 0 {\n+                os::set_exit_status(status);\n+            }\n+        }\n+\n+        util::note(fmt!(\"tested %s v%s\", script.name, script.vers.to_str()));\n+\n         true\n     }\n \n-    fn uninstall(name: ~str, vers: Option<~str>) -> bool {\n+    fn uninstall(id: ~str, vers: Option<~str>) -> bool {\n+        let package = match util::get_pkg(id, vers) {\n+            result::Ok(package) => package,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let name = match util::parse_name(package.id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+\n+        util::note(fmt!(\"uninstalling %s v%s (%s)\", name, package.vers.to_str(),\n+                                                    package.id));\n+\n+        for vec::append(package.bins, package.libs).each |&file| {\n+            let path = Path(file);\n+\n+            if os::path_exists(&path) {\n+                if os::remove_file(&path) {\n+                    util::note(fmt!(\"removed %s\", path.to_str()));\n+                } else {\n+                    util::error(fmt!(\"could not remove %s\", path.to_str()));\n+                }\n+            }\n+        }\n+\n+        util::note(fmt!(\"uninstalled %s v%s\", name, package.vers.to_str()));\n+        util::remove_pkg(&package);\n+\n         true\n     }\n \n-    fn unprefer(name: ~str, vers: Option<~str>) -> bool {\n+    fn unprefer(id: ~str, vers: Option<~str>) -> bool {\n+        let package = match util::get_pkg(id, vers) {\n+            result::Ok(package) => package,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+        let name = match util::parse_name(package.id) {\n+            result::Ok(name) => name,\n+            result::Err(err) => {\n+                util::error(err);\n+\n+                return false;\n+            }\n+        };\n+\n+        util::note(fmt!(\"unpreferring %s v%s (%s)\", name, package.vers.to_str(),\n+                                                    package.id));\n+\n+        let bin_dir = util::root().push(~\"bin\");\n+\n+        for package.bins.each |&bin| {\n+            let path = Path(bin);\n+            let name = str::split_char(path.file_path().to_str(), '-')[0];\n+            let out = bin_dir.push(name);\n+\n+            if os::path_exists(&out) {\n+                if os::remove_file(&out) {\n+                    util::note(fmt!(\"unlinked %s\", out.to_str()));\n+                } else {\n+                    util::error(fmt!(\"could not unlink %s\", out.to_str()));\n+                }\n+            }\n+        }\n+\n+        util::note(fmt!(\"unpreferred %s v%s\", name, package.vers.to_str()));\n+\n         true\n     }\n }\n \n pub fn main() {\n     let args = os::args();\n     let opts = ~[getopts::optflag(~\"h\"), getopts::optflag(~\"help\"),\n-                 getopts::optmulti(~\"c\"), getopts::optmulti(~\"cfg\"),\n-                 getopts::optmulti(~\"p\"), getopts::optmulti(~\"prefer\")];\n+                 getopts::optmulti(~\"c\"), getopts::optmulti(~\"cfg\")];\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n-            fail fmt!(\"%s\", getopts::fail_str(f));\n+            util::error(fmt!(\"%s\", getopts::fail_str(f)));\n+\n+            return;\n         }\n     };\n     let help = getopts::opt_present(matches, ~\"h\") ||\n                getopts::opt_present(matches, ~\"help\");\n-    let cfgs = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n+    let cfg = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n                            getopts::opt_strs(matches, ~\"c\"));\n-    let prefer = getopts::opt_present(matches, ~\"p\") ||\n-                 getopts::opt_present(matches, ~\"prefer\");\n     let mut args = copy matches.free;\n \n     args.shift();\n@@ -724,9 +919,15 @@ pub fn main() {\n         };\n     }\n \n+    let mut cfg_specs = ~[];\n+\n+    for cfg.each |s| {\n+        cfg_specs.push(attr::mk_word_item(/*bad*/copy *s));\n+    }\n+\n     Ctx {\n-        cfgs: cfgs,\n-        prefer: prefer\n+        cfg: cfg_specs,\n+        mut dep_cache: LinearMap()\n     }.run(cmd, args);\n }\n "}, {"sha": "28694948511d6d9a4bc7cc2699e6cd0ad7d5717c", "filename": "src/librustpkg/usage.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd28fa4af5b5200b274b8e965a422174fb7ad354/src%2Flibrustpkg%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd28fa4af5b5200b274b8e965a422174fb7ad354/src%2Flibrustpkg%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fusage.rs?ref=bd28fa4af5b5200b274b8e965a422174fb7ad354", "patch": "@@ -1,5 +1,5 @@\n use core::io;\n-\n+ \n pub fn general() {\n     io::println(~\"Usage: rustpkg [options] <cmd> [args..]\n \n@@ -46,29 +46,22 @@ Examples:\n     rustpkg install http://rust-lang.org/servo-0.1.2.tar.gz\n \n Options:\n-    -c, --cfg      Pass a cfg flag to the package script\n-    -p, --prefer   Prefer the package after installing\n-                   (see `rustpkg prefer -h`)\");\n+    -c, --cfg      Pass a cfg flag to the package script\");\n }\n \n pub fn uninstall() {\n-    io::println(~\"rustpkg uninstall <name>[@version]\n-\n-Remove a package by name and/or version. If version is omitted then all\n-versions of the package will be removed. If the package[s] is/are depended\n-on by another package then they cannot be removed.  If the package is preferred\n-(see `rustpkg prefer -h`), it will attempt to prefer the next latest\n-version of the package if another version is installed, otherwise it'll remove\n-the symlink.\");\n+    io::println(~\"rustpkg uninstall <id|name>[@version]\n+\n+Remove a package by id or name and optionally version. If the package(s) is/are depended\n+on by another package then they cannot be removed.\");\n }\n \n pub fn prefer() {\n-    io::println(~\"rustpkg [options..] prefer <name>[@version]\n+    io::println(~\"rustpkg [options..] prefer <id|name>[@version]\n \n By default all binaries are given a unique name so that multiple versions can\n coexist. The prefer command will symlink the uniquely named binary to\n-the binary directory under its bare name. The user will need to confirm\n-if the symlink will overwrite another. If version is not supplied, the latest\n+the binary directory under its bare name. If version is not supplied, the latest\n version of the package will be preferred.\n \n Example:\n@@ -82,10 +75,12 @@ Example:\n }\n \n pub fn unprefer() {\n-    io::println(~\"rustpkg [options..] unprefer <name>\n+    io::println(~\"rustpkg [options..] unprefer <id|name>[@version]\n \n Remove all symlinks from the store to the binary directory for a package\n-name. See `rustpkg prefer -h` for more information.\");\n+name and optionally version. If version is not supplied, the latest version\n+of the package will be unpreferred. See `rustpkg prefer -h` for more\n+information.\");\n }\n \n pub fn test() {"}, {"sha": "16ded3c640b6d1111e3d7e60bb5ec03054ac67f2", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 362, "deletions": 11, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/bd28fa4af5b5200b274b8e965a422174fb7ad354/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd28fa4af5b5200b274b8e965a422174fb7ad354/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=bd28fa4af5b5200b274b8e965a422174fb7ad354", "patch": "@@ -1,7 +1,15 @@\n use core::*;\n+use send_map::linear::LinearMap;\n use rustc::metadata::filesearch;\n use semver::Version;\n-use std::term;\n+use std::{json, term, sort};\n+\n+pub struct Package {\n+    id: ~str,\n+    vers: Version,\n+    bins: ~[~str],\n+    libs: ~[~str],\n+}\n \n pub fn root() -> Path {\n     match filesearch::get_rustpkg_root() {\n@@ -17,26 +25,26 @@ pub fn is_cmd(cmd: ~str) -> bool {\n     vec::contains(cmds, &cmd)\n }\n \n-pub fn parse_id(id: ~str) -> ~str {\n+pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n     let parts = str::split_char(id, '.');\n \n     for parts.each |&part| {\n         for str::chars(part).each |&char| {\n             if char::is_whitespace(char) {\n-                fail ~\"could not parse id: contains whitespace\";\n+                return result::Err(~\"could not parse id: contains whitespace\");\n             } else if char::is_uppercase(char) {\n-                fail ~\"could not parse id: should be all lowercase\";\n+                return result::Err(~\"could not parse id: should be all lowercase\");\n             }\n         }\n     }\n \n-    parts.last()\n+    result::Ok(parts.last())\n }\n \n-pub fn parse_vers(vers: ~str) -> Version {\n+pub fn parse_vers(vers: ~str) -> result::Result<Version, ~str> {\n     match semver::parse(vers) {\n-        Some(vers) => vers,\n-        None => fail ~\"could not parse version: invalid\"\n+        Some(vers) => result::Ok(vers),\n+        None => result::Err(~\"could not parse version: invalid\")\n     }\n }\n \n@@ -80,6 +88,13 @@ pub fn error(msg: ~str) {\n     else { out.write_line(~\"error: \" + msg); }\n }\n \n+pub fn hash(data: ~str) -> ~str {\n+    let hasher = hash::default_state();\n+\n+    hasher.write_str(data);\n+    hasher.result_str()\n+}\n+\n pub fn temp_change_dir<T>(dir: &Path, cb: fn() -> T) {\n     let cwd = os::getcwd();\n \n@@ -88,6 +103,342 @@ pub fn temp_change_dir<T>(dir: &Path, cb: fn() -> T) {\n     os::change_dir(&cwd);\n }\n \n+pub fn touch(path: &Path) {\n+    match io::mk_file_writer(path, ~[io::Create]) {\n+        result::Ok(writer) => writer.write_line(~\"\"),\n+        _ => {}\n+    }\n+}\n+\n+pub fn remove_dir_r(path: &Path) {\n+    for os::walk_dir(path) |&file| {\n+        let mut cdir = file;\n+\n+        loop {\n+            if os::path_is_dir(&cdir) {\n+                os::remove_dir(&cdir);\n+            } else {\n+                os::remove_file(&cdir);\n+            }\n+\n+            cdir = cdir.dir_path();\n+\n+            if cdir == *path { break; }\n+        }\n+    }\n+\n+    os::remove_dir(path);\n+}\n+\n+pub fn wait_for_lock(path: &Path) {\n+    if os::path_exists(path) {\n+        warn(fmt!(\"the database appears locked, please wait (or rm %s)\",\n+                        path.to_str()));\n+\n+        loop {\n+            if !os::path_exists(path) { break; }\n+        }\n+    }\n+}\n+\n+fn _add_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n+    for packages.each |&package| {\n+        match package {\n+            json::Object(map) => {\n+                let mut has_id = false;\n+\n+                match map.get(&~\"id\") {\n+                    json::String(str) => {\n+                        if pkg.id == str {\n+                            has_id = true;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                match map.get(&~\"vers\") {\n+                    json::String(str) => {\n+                        if pkg.vers.to_str() == str {\n+                            return packages;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let mut map = ~LinearMap();\n+\n+    map.insert(~\"id\", json::String(pkg.id));\n+    map.insert(~\"vers\", json::String(pkg.vers.to_str()));\n+    map.insert(~\"bins\", json::List(do pkg.bins.map |&bin| {\n+        json::String(bin)\n+    }));\n+    map.insert(~\"libs\", json::List(do pkg.libs.map |&lib| {\n+        json::String(lib)\n+    }));\n+\n+    vec::append(packages, ~[json::Object(map)])\n+}\n+\n+fn _rm_pkg(packages: ~[json::Json], pkg: &Package) -> ~[json::Json] {\n+    do packages.filter_map |&package| {\n+        match package {\n+            json::Object(map) => {\n+                let mut has_id = false;\n+\n+                match map.get(&~\"id\") {\n+                    json::String(str) => {\n+                        if pkg.id == str {\n+                            has_id = true;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                match map.get(&~\"vers\") {\n+                    json::String(str) => {\n+                        if pkg.vers.to_str() == str { None }\n+                        else { Some(package) } \n+                    }\n+                    _ => { Some(package) }\n+                }\n+            }\n+            _ => { Some(package) }\n+        }\n+    }\n+}\n+\n+pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n+    let root = root();\n+    let db = root.push(~\"db.json\");\n+    let db_lock = root.push(~\"db.json.lck\");\n+\n+    wait_for_lock(&db_lock);\n+    touch(&db_lock);\n+\n+    let packages = if os::path_exists(&db) {\n+        match io::read_whole_file_str(&db) {\n+            result::Ok(str) => {\n+                match json::from_str(str) {\n+                    result::Ok(json) => {\n+                        match json {\n+                            json::List(list) => list,\n+                            _ => {\n+                                os::remove_file(&db_lock);\n+\n+                                return result::Err(~\"package db's json is not a list\");\n+                            }\n+                        }\n+                    }\n+                    result::Err(err) => {\n+                        os::remove_file(&db_lock);\n+\n+                        return result::Err(fmt!(\"failed to parse package db: %s\", err.to_str()));\n+                    }\n+                }\n+            }\n+            result::Err(err) => {\n+                os::remove_file(&db_lock);\n+\n+                return result::Err(fmt!(\"failed to read package db: %s\", err));\n+            }\n+        }\n+    } else { ~[] };\n+\n+    os::remove_file(&db_lock);\n+\n+    result::Ok(packages)\n+}\n+\n+pub fn get_pkg(id: ~str, vers: Option<~str>) -> result::Result<Package, ~str> {\n+    let name = match parse_name(id) {\n+        result::Ok(name) => name,\n+        result::Err(err) => return result::Err(err)\n+    };\n+    let packages = match load_pkgs() {\n+        result::Ok(packages) => packages,\n+        result::Err(err) => return result::Err(err)\n+    };\n+    let mut sel = None;\n+    let mut possibs = ~[];\n+    let mut err = None;\n+\n+    for packages.each |&package| {\n+        match package {\n+            json::Object(map) => {\n+                let pid = match map.get(&~\"id\") {\n+                    json::String(str) => str,\n+                    _ => loop\n+                };\n+                let pname = match parse_name(pid) {\n+                    result::Ok(pname) => pname,\n+                    result::Err(perr) => {\n+                        err = Some(perr);\n+\n+                        break;\n+                    }\n+                };\n+                let pvers = match map.get(&~\"vers\") {\n+                    json::String(str) => str,\n+                    _ => loop\n+                };\n+                if pid == id || pname == name {\n+                    let bins = match map.get(&~\"bins\") {\n+                        json::List(list) => {\n+                            do list.map |&bin| {\n+                                match bin {\n+                                    json::String(str) => str,\n+                                    _ => ~\"\"\n+                                }\n+                            }\n+                        }\n+                        _ => ~[]\n+                    };\n+                    let libs = match map.get(&~\"libs\") {\n+                        json::List(list) => {\n+                            do list.map |&lib| {\n+                                match lib {\n+                                    json::String(str) => str,\n+                                    _ => ~\"\"\n+                                }\n+                            }\n+                        }\n+                        _ => ~[]\n+                    };\n+                    let package = Package {\n+                        id: pid,\n+                        vers: match parse_vers(pvers) {\n+                            result::Ok(vers) => vers,\n+                            result::Err(verr) => {\n+                                err = Some(verr);\n+\n+                                break;\n+                            }\n+                        },\n+                        bins: bins,\n+                        libs: libs\n+                    };\n+\n+                    if !vers.is_none() && vers.get() == pvers {\n+                        sel = Some(package);\n+                    }\n+                    else {\n+                        possibs.push(package);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if !err.is_none() {\n+        return result::Err(err.get());\n+    }\n+    if !sel.is_none() {\n+        return result::Ok(sel.get());\n+    }\n+    if !vers.is_none() || possibs.len() < 1 {\n+        return result::Err(~\"package not found\");\n+    }\n+\n+    result::Ok(sort::merge_sort(possibs, |v1, v2| {\n+        v1.vers <= v2.vers\n+    }).last())\n+}\n+\n+pub fn add_pkg(pkg: &Package) -> bool {\n+    let root = root();\n+    let db = root.push(~\"db.json\");\n+    let db_lock = root.push(~\"db.json.lck\");\n+    let packages = match load_pkgs() {\n+        result::Ok(packages) => packages,\n+        result::Err(err) => {\n+            error(err);\n+\n+            return false;\n+        }\n+    };\n+\n+    wait_for_lock(&db_lock);\n+    touch(&db_lock);\n+    os::remove_file(&db);\n+\n+    match io::mk_file_writer(&db, ~[io::Create]) {\n+        result::Ok(writer) => {\n+            writer.write_line(json::to_pretty_str(&json::List(_add_pkg(packages, pkg))));\n+        }\n+        result::Err(err) => {\n+            error(fmt!(\"failed to dump package db: %s\", err));\n+            os::remove_file(&db_lock);\n+\n+            return false;\n+        }\n+    }\n+\n+    os::remove_file(&db_lock);\n+\n+    true\n+}\n+\n+pub fn remove_pkg(pkg: &Package) -> bool {\n+    let root = root();\n+    let db = root.push(~\"db.json\");\n+    let db_lock = root.push(~\"db.json.lck\");\n+    let packages = match load_pkgs() {\n+        result::Ok(packages) => packages,\n+        result::Err(err) => {\n+            error(err);\n+\n+            return false;\n+        }\n+    };\n+\n+    wait_for_lock(&db_lock);\n+    touch(&db_lock);\n+    os::remove_file(&db);\n+\n+    match io::mk_file_writer(&db, ~[io::Create]) {\n+        result::Ok(writer) => {\n+            writer.write_line(json::to_pretty_str(&json::List(_rm_pkg(packages, pkg))));\n+        }\n+        result::Err(err) => {\n+            error(fmt!(\"failed to dump package db: %s\", err));\n+            os::remove_file(&db_lock);\n+\n+            return false;\n+        }\n+    }\n+\n+    os::remove_file(&db_lock);\n+\n+    true\n+}\n+\n+#[cfg(windows)]\n+pub fn link_exe(_src: &Path, _dest: &Path) -> bool{\n+    /* FIXME: Investigate how to do this on win32\n+       Node wraps symlinks by having a .bat,\n+       but that won't work with minGW. */\n+\n+    false\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[cfg(target_os = \"macos\")]\n+pub fn link_exe(src: &Path, dest: &Path) -> bool unsafe {\n+    do str::as_c_str(src.to_str()) |src_buf| {\n+        do str::as_c_str(dest.to_str()) |dest_buf| {\n+            libc::link(src_buf, dest_buf) == 0 as libc::c_int &&\n+            libc::chmod(dest_buf, 755) == 0 as libc::c_int\n+        }\n+    }\n+}\n+\n #[test]\n fn test_is_cmd() {\n     assert is_cmd(~\"build\");\n@@ -100,7 +451,7 @@ fn test_is_cmd() {\n }\n \n #[test]\n-fn test_parse_id() {\n-    assert parse_id(~\"org.mozilla.servo\").get() == ~\"servo\";\n-    assert parse_id(~\"org. mozilla.servo 2131\").is_err();\n+fn test_parse_name() {\n+    assert parse_name(~\"org.mozilla.servo\").get() == ~\"servo\";\n+    assert parse_name(~\"org. mozilla.servo 2131\").is_err();\n }"}]}