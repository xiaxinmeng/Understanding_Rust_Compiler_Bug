{"sha": "6330bf24fe2641cec2045fdfaab439f96c35652a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMzBiZjI0ZmUyNjQxY2VjMjA0NWZkZmFhYjQzOWY5NmMzNTY1MmE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-17T00:22:43Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-25T10:26:47Z"}, "message": "Fix handling of None", "tree": {"sha": "afe222cb03ad68346f9a96d3143d9139c31014dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afe222cb03ad68346f9a96d3143d9139c31014dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6330bf24fe2641cec2045fdfaab439f96c35652a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6330bf24fe2641cec2045fdfaab439f96c35652a", "html_url": "https://github.com/rust-lang/rust/commit/6330bf24fe2641cec2045fdfaab439f96c35652a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6330bf24fe2641cec2045fdfaab439f96c35652a/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "url": "https://api.github.com/repos/rust-lang/rust/commits/6eb4f0f7fd44026a2353a620dee39d379a8e4a29", "html_url": "https://github.com/rust-lang/rust/commit/6eb4f0f7fd44026a2353a620dee39d379a8e4a29"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "b6f36582f3c7429d0923d78f6bd0fd5e1732da81", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6330bf24fe2641cec2045fdfaab439f96c35652a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6330bf24fe2641cec2045fdfaab439f96c35652a/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=6330bf24fe2641cec2045fdfaab439f96c35652a", "patch": "@@ -213,8 +213,8 @@ fn cs_op(less: bool,\n                                       Ident::from_str(\"partial_cmp\"),\n                                       vec![cx.expr_addr_of(span, other_f.clone())]);\n \n-        let default = ordering_path(cx, if less { \"Greater\" } else { \"Less\" });\n-        // `_.unwrap_or(Ordering::Greater/Less)`\n+        let default = ordering_path(cx, \"Equal\");\n+        // `_.unwrap_or(Ordering::Equal)`\n         cx.expr_method_call(span, cmp, Ident::from_str(\"unwrap_or\"), vec![default])\n     };\n \n@@ -225,28 +225,28 @@ fn cs_op(less: bool,\n             // `ast::lt`\n             //\n             // ```\n-            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Greater)\n-            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Greater))\n+            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Equal)\n+            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Equal))\n             // == Ordering::Less\n             // ```\n             //\n             // and for op ==\n             // `ast::le`\n             //\n             // ```\n-            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Greater)\n-            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Greater))\n+            // self.f1.partial_cmp(other.f1).unwrap_or(Ordering::Equal)\n+            //     .then_with(|| self.f2.partial_cmp(other.f2).unwrap_or(Ordering::Equal))\n             // != Ordering::Greater\n             // ```\n             //\n             // The optimiser should remove the redundancy. We explicitly\n             // get use the binops to avoid auto-deref dereferencing too many\n             // layers of pointers, if the type includes pointers.\n \n-            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Greater/Less)`\n+            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Equal)`\n             let par_cmp = par_cmp(cx, span, self_f, other_fs);\n \n-            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Greater/Less).then_with(...)`\n+            // `self.fi.partial_cmp(other.fi).unwrap_or(Ordering::Equal).then_with(...)`\n             cx.expr_method_call(span,\n                                 par_cmp,\n                                 Ident::from_str(\"then_with\"),\n@@ -255,7 +255,7 @@ fn cs_op(less: bool,\n         |cx, args| {\n             match args {\n                 Some((span, self_f, other_fs)) => par_cmp(cx, span, self_f, other_fs),\n-                None => ordering_path(cx, if less { \"Less\" } else { \"Equal\" })\n+                None => cx.expr_bool(span, inclusive)\n             }\n         },\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n@@ -276,8 +276,8 @@ fn cs_op(less: bool,\n         substr);\n \n     match *substr.fields {\n-        EnumMatching(..) |\n-        Struct(..) => {\n+        EnumMatching(.., ref all_fields) |\n+        Struct(.., ref all_fields) if !all_fields.is_empty() => {\n             let ordering = ordering_path(cx, if less ^ inclusive { \"Less\" } else { \"Greater\" });\n             let comp_op = if inclusive { BinOpKind::Ne } else { BinOpKind::Eq };\n "}]}