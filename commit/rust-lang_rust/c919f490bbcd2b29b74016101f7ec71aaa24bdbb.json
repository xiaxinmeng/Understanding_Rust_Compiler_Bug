{"sha": "c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTlmNDkwYmJjZDJiMjliNzQwMTYxMDFmN2VjNzFhYWEyNGJkYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-17T15:27:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-17T15:27:29Z"}, "message": "Auto merge of #79138 - m-ou-se:rollup-owel5ld, r=m-ou-se\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #74293 (Rustdoc test compiler output color)\n - #78702 ([self-profiling] Include the estimated size of each cgu in the profile)\n - #79069 (Get rid of `highlight::Class::None`)\n - #79072 (Fix exhaustiveness in case a byte string literal is used at slice type)\n - #79120 (update rustfmt to v1.4.27)\n - #79125 (Get rid of clean::{Method, TyMethod})\n - #79126 (Remove duplicate `Trait::auto` field)\n - #79130 (extend macro braces test)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ce8406ee4a726bc8db7c864518f3d8ea16ea8c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce8406ee4a726bc8db7c864518f3d8ea16ea8c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "html_url": "https://github.com/rust-lang/rust/commit/c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0ef0fc392963438af5f0343bf7caa46fb9c3ec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ef0fc392963438af5f0343bf7caa46fb9c3ec3", "html_url": "https://github.com/rust-lang/rust/commit/e0ef0fc392963438af5f0343bf7caa46fb9c3ec3"}, {"sha": "f698505177eb1853b3d905bbe1005140acd50d53", "url": "https://api.github.com/repos/rust-lang/rust/commits/f698505177eb1853b3d905bbe1005140acd50d53", "html_url": "https://github.com/rust-lang/rust/commit/f698505177eb1853b3d905bbe1005140acd50d53"}], "stats": {"total": 466, "additions": 325, "deletions": 141}, "files": [{"sha": "928d19b1e2c3f36b4c7aaf7d1a8a29dc28135042", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -4338,7 +4338,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.26\"\n+version = \"1.4.27\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\","}, {"sha": "7d01f6a54995a85a9f15fb247ba99f5344d00c6e", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -97,21 +97,23 @@ pub fn compile_codegen_unit(\n     tcx: TyCtxt<'tcx>,\n     cgu_name: Symbol,\n ) -> (ModuleCodegen<ModuleLlvm>, u64) {\n-    let prof_timer = tcx.prof.generic_activity_with_arg(\"codegen_module\", cgu_name.to_string());\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n     let (module, _) =\n         tcx.dep_graph.with_task(dep_node, tcx, cgu_name, module_codegen, dep_graph::hash_result);\n     let time_to_codegen = start_time.elapsed();\n-    drop(prof_timer);\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n     // the time we needed for codegenning it.\n     let cost = time_to_codegen.as_nanos() as u64;\n \n     fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n+        let _prof_timer = tcx.prof.generic_activity_with_args(\n+            \"codegen_module\",\n+            &[cgu_name.to_string(), cgu.size_estimate().to_string()],\n+        );\n         // Instantiate monomorphizations without filling out definitions yet...\n         let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n         {"}, {"sha": "5d13b7f27c70453097e8b242dc376e4589a4394a", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -272,6 +272,28 @@ impl SelfProfilerRef {\n         })\n     }\n \n+    #[inline(always)]\n+    pub fn generic_activity_with_args(\n+        &self,\n+        event_label: &'static str,\n+        event_args: &[String],\n+    ) -> TimingGuard<'_> {\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let builder = EventIdBuilder::new(&profiler.profiler);\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+            let event_id = if profiler.event_filter_mask.contains(EventFilter::FUNCTION_ARGS) {\n+                let event_args: Vec<_> = event_args\n+                    .iter()\n+                    .map(|s| profiler.get_or_alloc_cached_string(&s[..]))\n+                    .collect();\n+                builder.from_label_and_args(event_label, &event_args)\n+            } else {\n+                builder.from_label(event_label)\n+            };\n+            TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n+        })\n+    }\n+\n     /// Start profiling a query provider. Profiling continues until the\n     /// TimingGuard returned from this call is dropped.\n     #[inline(always)]"}, {"sha": "32104e6f00d44f5471c7b99f74ee4087f0cbfbbc", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -200,6 +200,11 @@ pub trait Emitter {\n         true\n     }\n \n+    /// Checks if we can use colors in the current output stream.\n+    fn supports_color(&self) -> bool {\n+        false\n+    }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>>;\n \n     /// Formats the substitutions of the primary_span\n@@ -504,6 +509,10 @@ impl Emitter for EmitterWriter {\n     fn should_show_explain(&self) -> bool {\n         !self.short_message\n     }\n+\n+    fn supports_color(&self) -> bool {\n+        self.dst.supports_color()\n+    }\n }\n \n /// An emitter that does nothing when emitting a diagnostic.\n@@ -2057,6 +2066,14 @@ impl Destination {\n             Destination::Raw(ref mut t, true) => WritableDst::ColoredRaw(Ansi::new(t)),\n         }\n     }\n+\n+    fn supports_color(&self) -> bool {\n+        match *self {\n+            Self::Terminal(ref stream) => stream.supports_color(),\n+            Self::Buffered(ref buffer) => buffer.buffer().supports_color(),\n+            Self::Raw(_, supports_color) => supports_color,\n+        }\n+    }\n }\n \n impl<'a> WritableDst<'a> {"}, {"sha": "36cbd36a7705f1ad21bd5dd80f9989d88860b624", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -422,6 +422,12 @@ pub struct TypeckResults<'tcx> {\n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n+\n+    /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n+    /// as `&[u8]`, depending on the pattern  in which they are used.\n+    /// This hashset records all instances where we behave\n+    /// like this to allow `const_to_pat` to reliably handle this situation.\n+    pub treat_byte_string_as_slice: ItemLocalSet,\n }\n \n impl<'tcx> TypeckResults<'tcx> {\n@@ -448,6 +454,7 @@ impl<'tcx> TypeckResults<'tcx> {\n             closure_captures: Default::default(),\n             closure_min_captures: Default::default(),\n             generator_interior_types: Default::default(),\n+            treat_byte_string_as_slice: Default::default(),\n         }\n     }\n \n@@ -683,6 +690,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             ref closure_captures,\n             ref closure_min_captures,\n             ref generator_interior_types,\n+            ref treat_byte_string_as_slice,\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -717,6 +725,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckResults<'tcx> {\n             closure_captures.hash_stable(hcx, hasher);\n             closure_min_captures.hash_stable(hcx, hasher);\n             generator_interior_types.hash_stable(hcx, hasher);\n+            treat_byte_string_as_slice.hash_stable(hcx, hasher);\n         })\n     }\n }"}, {"sha": "32fc0f008e972f706893c79007b6f8227e04c113", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -18,22 +18,20 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n     /// This means aggregate values (like structs and enums) are converted\n     /// to a pattern that matches the value (as if you'd compared via structural equality).\n+    #[instrument(skip(self))]\n     pub(super) fn const_to_pat(\n         &self,\n         cv: &'tcx ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n-        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n-\n         let pat = self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n         });\n \n-        debug!(\"const_to_pat: pat={:?}\", pat);\n+        debug!(?pat);\n         pat\n     }\n }\n@@ -61,6 +59,8 @@ struct ConstToPat<'a, 'tcx> {\n     infcx: InferCtxt<'a, 'tcx>,\n \n     include_lint_checks: bool,\n+\n+    treat_byte_string_as_slice: bool,\n }\n \n mod fallback_to_const_ref {\n@@ -88,6 +88,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         span: Span,\n         infcx: InferCtxt<'a, 'tcx>,\n     ) -> Self {\n+        trace!(?pat_ctxt.typeck_results.hir_owner);\n         ConstToPat {\n             id,\n             span,\n@@ -97,6 +98,10 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             saw_const_match_error: Cell::new(false),\n             saw_const_match_lint: Cell::new(false),\n             behind_reference: Cell::new(false),\n+            treat_byte_string_as_slice: pat_ctxt\n+                .typeck_results\n+                .treat_byte_string_as_slice\n+                .contains(&id.local_id),\n         }\n     }\n \n@@ -153,6 +158,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         cv: &'tcx ty::Const<'tcx>,\n         mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n+        trace!(self.treat_byte_string_as_slice);\n         // This method is just a wrapper handling a validity check; the heavy lifting is\n         // performed by the recursive `recur` method, which is not meant to be\n         // invoked except by this method.\n@@ -384,7 +390,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     }\n                     PatKind::Wild\n                 }\n-                // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n+                // `&str` is represented as `ConstValue::Slice`, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n@@ -393,11 +399,33 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n                 // has no negative effects on pattern matching, even if we're actually matching on\n                 // arrays.\n-                ty::Array(..) |\n+                ty::Array(..) if !self.treat_byte_string_as_slice => {\n+                    let old = self.behind_reference.replace(true);\n+                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let val = PatKind::Deref {\n+                        subpattern: Pat {\n+                            kind: Box::new(PatKind::Array {\n+                                prefix: tcx\n+                                    .destructure_const(param_env.and(array))\n+                                    .fields\n+                                    .iter()\n+                                    .map(|val| self.recur(val, false))\n+                                    .collect::<Result<_, _>>()?,\n+                                slice: None,\n+                                suffix: vec![],\n+                            }),\n+                            span,\n+                            ty: pointee_ty,\n+                        },\n+                    };\n+                    self.behind_reference.set(old);\n+                    val\n+                }\n+                ty::Array(elem_ty, _) |\n                 // Cannot merge this with the catch all branch below, because the `const_deref`\n                 // changes the type from slice to array, we need to keep the original type in the\n                 // pattern.\n-                ty::Slice(..) => {\n+                ty::Slice(elem_ty) => {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_const(self.param_env.and(cv));\n                     let val = PatKind::Deref {\n@@ -413,7 +441,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                                 suffix: vec![],\n                             }),\n                             span,\n-                            ty: pointee_ty,\n+                            ty: tcx.mk_slice(elem_ty),\n                         },\n                     };\n                     self.behind_reference.set(old);"}, {"sha": "a729912126e4f0d3462d59f6bd3cc5751b06a0d5", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -149,15 +149,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// Outside of this module, `check_pat_top` should always be used.\n     /// Conversely, inside this module, `check_pat_top` should never be used.\n+    #[instrument(skip(self, ti))]\n     fn check_pat(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n         ti: TopInfo<'tcx>,\n     ) {\n-        debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n-\n         let path_res = match &pat.kind {\n             PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n             _ => None,\n@@ -398,6 +397,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Ref(_, inner_ty, _) = expected.kind() {\n                 if matches!(inner_ty.kind(), ty::Slice(_)) {\n                     let tcx = self.tcx;\n+                    trace!(?lt.hir_id.local_id, \"polymorphic byte string lit\");\n+                    self.typeck_results\n+                        .borrow_mut()\n+                        .treat_byte_string_as_slice\n+                        .insert(lt.hir_id.local_id);\n                     pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.mk_slice(tcx.types.u8));\n                 }\n             }"}, {"sha": "335f2cc2716c75c392e0de6fe5fd4cf70ef89c31", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -70,6 +70,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n         wbcx.typeck_results.used_trait_imports = used_trait_imports;\n \n+        wbcx.typeck_results.treat_byte_string_as_slice =\n+            mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n+\n         wbcx.typeck_results.closure_captures =\n             mem::take(&mut self.typeck_results.borrow_mut().closure_captures);\n "}, {"sha": "7a4ec77907080f889d589414b481ca66ea3d3f5c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -193,15 +193,13 @@ crate fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let trait_items =\n         cx.tcx.associated_items(did).in_definition_order().map(|item| item.clean(cx)).collect();\n \n-    let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n     let predicates = cx.tcx.predicates_of(did);\n     let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     let is_spotlight = load_attrs(cx, did).clean(cx).has_doc_flag(sym::spotlight);\n     let is_auto = cx.tcx.trait_is_auto(did);\n     clean::Trait {\n-        auto: auto_trait,\n         unsafety: cx.tcx.trait_def(did).unsafety,\n         generics,\n         items: trait_items,"}, {"sha": "95a0d335c4f912ac99a06c9d89f35c30a07b39e4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -883,14 +883,12 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n-impl<'a> Clean<Method>\n-    for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId, Option<hir::Defaultness>)\n-{\n-    fn clean(&self, cx: &DocContext<'_>) -> Method {\n+impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n+    fn clean(&self, cx: &DocContext<'_>) -> Function {\n         let (generics, decl) =\n             enter_impl_trait(cx, || (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n         let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-        Method { decl, generics, header: self.0.header, defaultness: self.3, all_types, ret_types }\n+        Function { decl, generics, header: self.0.header, all_types, ret_types }\n     }\n }\n \n@@ -1024,7 +1022,6 @@ impl Clean<Item> for doctree::Trait<'_> {\n             stability: cx.stability(self.id),\n             deprecation: cx.deprecation(self.id).clean(cx),\n             kind: TraitItem(Trait {\n-                auto: self.is_auto.clean(cx),\n                 unsafety: self.unsafety,\n                 items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n@@ -1107,20 +1104,20 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                let mut m = (sig, &self.generics, body, None).clean(cx);\n+                let mut m = (sig, &self.generics, body).clean(cx);\n                 if m.header.constness == hir::Constness::Const\n                     && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n                 {\n                     m.header.constness = hir::Constness::NotConst;\n                 }\n-                MethodItem(m)\n+                MethodItem(m, None)\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-                let mut t = TyMethod { header: sig.header, decl, generics, all_types, ret_types };\n+                let mut t = Function { header: sig.header, decl, generics, all_types, ret_types };\n                 if t.header.constness == hir::Constness::Const\n                     && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n                 {\n@@ -1153,13 +1150,13 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n-                let mut m = (sig, &self.generics, body, Some(self.defaultness)).clean(cx);\n+                let mut m = (sig, &self.generics, body).clean(cx);\n                 if m.header.constness == hir::Constness::Const\n                     && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n                 {\n                     m.header.constness = hir::Constness::NotConst;\n                 }\n-                MethodItem(m)\n+                MethodItem(m, Some(self.defaultness))\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {\n                 let type_ = ty.clean(cx);\n@@ -1235,21 +1232,23 @@ impl Clean<Item> for ty::AssocItem {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n                     };\n-                    MethodItem(Method {\n-                        generics,\n-                        decl,\n-                        header: hir::FnHeader {\n-                            unsafety: sig.unsafety(),\n-                            abi: sig.abi(),\n-                            constness,\n-                            asyncness,\n+                    MethodItem(\n+                        Function {\n+                            generics,\n+                            decl,\n+                            header: hir::FnHeader {\n+                                unsafety: sig.unsafety(),\n+                                abi: sig.abi(),\n+                                constness,\n+                                asyncness,\n+                            },\n+                            all_types,\n+                            ret_types,\n                         },\n                         defaultness,\n-                        all_types,\n-                        ret_types,\n-                    })\n+                    )\n                 } else {\n-                    TyMethodItem(TyMethod {\n+                    TyMethodItem(Function {\n                         generics,\n                         decl,\n                         header: hir::FnHeader {"}, {"sha": "a3677e3f5178f2e04cc6105a33e32f3202ddeeff", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -227,12 +227,8 @@ impl Item {\n \n     crate fn is_default(&self) -> bool {\n         match self.kind {\n-            ItemKind::MethodItem(ref meth) => {\n-                if let Some(defaultness) = meth.defaultness {\n-                    defaultness.has_value() && !defaultness.is_final()\n-                } else {\n-                    false\n-                }\n+            ItemKind::MethodItem(_, Some(defaultness)) => {\n+                defaultness.has_value() && !defaultness.is_final()\n             }\n             _ => false,\n         }\n@@ -264,9 +260,9 @@ crate enum ItemKind {\n     ImplItem(Impl),\n     /// A method signature only. Used for required methods in traits (ie,\n     /// non-default-methods).\n-    TyMethodItem(TyMethod),\n+    TyMethodItem(Function),\n     /// A method with a body.\n-    MethodItem(Method),\n+    MethodItem(Function, Option<hir::Defaultness>),\n     StructFieldItem(Type),\n     VariantItem(Variant),\n     /// `fn`s from an extern block\n@@ -910,25 +906,6 @@ crate struct Generics {\n     crate where_predicates: Vec<WherePredicate>,\n }\n \n-#[derive(Clone, Debug)]\n-crate struct Method {\n-    crate generics: Generics,\n-    crate decl: FnDecl,\n-    crate header: hir::FnHeader,\n-    crate defaultness: Option<hir::Defaultness>,\n-    crate all_types: Vec<(Type, TypeKind)>,\n-    crate ret_types: Vec<(Type, TypeKind)>,\n-}\n-\n-#[derive(Clone, Debug)]\n-crate struct TyMethod {\n-    crate header: hir::FnHeader,\n-    crate decl: FnDecl,\n-    crate generics: Generics,\n-    crate all_types: Vec<(Type, TypeKind)>,\n-    crate ret_types: Vec<(Type, TypeKind)>,\n-}\n-\n #[derive(Clone, Debug)]\n crate struct Function {\n     crate decl: FnDecl,\n@@ -1026,7 +1003,6 @@ impl GetDefId for FnRetTy {\n \n #[derive(Clone, Debug)]\n crate struct Trait {\n-    crate auto: bool,\n     crate unsafety: hir::Unsafety,\n     crate items: Vec<Item>,\n     crate generics: Generics,"}, {"sha": "9f35e57df418b36f7cf6b5f287eca9c5a83f4f97", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -1,13 +1,13 @@\n use rustc_ast as ast;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::ErrorReported;\n+use rustc_errors::{ColorConfig, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::intravisit;\n use rustc_hir::{HirId, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, CrateType};\n+use rustc_session::config::{self, CrateType, ErrorOutputType};\n use rustc_session::{lint, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::SourceMap;\n@@ -248,7 +248,8 @@ fn run_test(\n     outdir: DirState,\n     path: PathBuf,\n ) -> Result<(), TestFailure> {\n-    let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts, edition);\n+    let (test, line_offset, supports_color) =\n+        make_test(test, Some(cratename), as_test_harness, opts, edition);\n \n     let output_file = outdir.path().join(\"rust_out\");\n \n@@ -293,6 +294,20 @@ fn run_test(\n             path.to_str().expect(\"target path must be valid unicode\").to_string()\n         }\n     });\n+    if let ErrorOutputType::HumanReadable(kind) = options.error_format {\n+        let (_, color_config) = kind.unzip();\n+        match color_config {\n+            ColorConfig::Never => {\n+                compiler.arg(\"--color\").arg(\"never\");\n+            }\n+            ColorConfig::Always => {\n+                compiler.arg(\"--color\").arg(\"always\");\n+            }\n+            ColorConfig::Auto => {\n+                compiler.arg(\"--color\").arg(if supports_color { \"always\" } else { \"never\" });\n+            }\n+        }\n+    }\n \n     compiler.arg(\"-\");\n     compiler.stdin(Stdio::piped());\n@@ -320,7 +335,10 @@ fn run_test(\n         (true, false) => {}\n         (false, true) => {\n             if !error_codes.is_empty() {\n-                error_codes.retain(|err| !out.contains(&format!(\"error[{}]: \", err)));\n+                // We used to check if the output contained \"error[{}]: \" but since we added the\n+                // colored output, we can't anymore because of the color escape characters before\n+                // the \":\".\n+                error_codes.retain(|err| !out.contains(&format!(\"error[{}]\", err)));\n \n                 if !error_codes.is_empty() {\n                     return Err(TestFailure::MissingErrorCodes(error_codes));\n@@ -362,18 +380,19 @@ fn run_test(\n }\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n-/// lines before the test code begins.\n+/// lines before the test code begins as well as if the output stream supports colors or not.\n crate fn make_test(\n     s: &str,\n     cratename: Option<&str>,\n     dont_insert_main: bool,\n     opts: &TestOptions,\n     edition: Edition,\n-) -> (String, usize) {\n+) -> (String, usize, bool) {\n     let (crate_attrs, everything_else, crates) = partition_source(s);\n     let everything_else = everything_else.trim();\n     let mut line_offset = 0;\n     let mut prog = String::new();\n+    let mut supports_color = false;\n \n     if opts.attrs.is_empty() && !opts.display_warnings {\n         // If there aren't any attributes supplied by #![doc(test(attr(...)))], then allow some\n@@ -399,7 +418,7 @@ crate fn make_test(\n     // crate already is included.\n     let result = rustc_driver::catch_fatal_errors(|| {\n         rustc_span::with_session_globals(edition, || {\n-            use rustc_errors::emitter::EmitterWriter;\n+            use rustc_errors::emitter::{Emitter, EmitterWriter};\n             use rustc_errors::Handler;\n             use rustc_parse::maybe_new_parser_from_source_str;\n             use rustc_session::parse::ParseSess;\n@@ -411,8 +430,13 @@ crate fn make_test(\n             // Any errors in parsing should also appear when the doctest is compiled for real, so just\n             // send all the errors that librustc_ast emits directly into a `Sink` instead of stderr.\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            supports_color =\n+                EmitterWriter::stderr(ColorConfig::Auto, None, false, false, Some(80), false)\n+                    .supports_color();\n+\n             let emitter =\n                 EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+\n             // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n             let handler = Handler::with_emitter(false, None, box emitter);\n             let sess = ParseSess::with_span_handler(handler, sm);\n@@ -482,7 +506,7 @@ crate fn make_test(\n         Err(ErrorReported) => {\n             // If the parser panicked due to a fatal error, pass the test code through unchanged.\n             // The error will be reported during compilation.\n-            return (s.to_owned(), 0);\n+            return (s.to_owned(), 0, false);\n         }\n     };\n \n@@ -532,7 +556,7 @@ crate fn make_test(\n \n     debug!(\"final doctest:\\n{}\", prog);\n \n-    (prog, line_offset)\n+    (prog, line_offset, supports_color)\n }\n \n // FIXME(aburka): use a real parser to deal with multiline attributes"}, {"sha": "a024e9c72a43e01969a2523dfca486cc115a7b67", "filename": "src/librustdoc/doctest/tests.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest%2Ftests.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -11,8 +11,8 @@ fn main() {\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -26,8 +26,8 @@ fn main() {\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -44,8 +44,8 @@ use asdf::qwop;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 3));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 3));\n }\n \n #[test]\n@@ -61,8 +61,8 @@ use asdf::qwop;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -79,8 +79,8 @@ use std::*;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -98,8 +98,8 @@ use asdf::qwop;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -115,8 +115,8 @@ use asdf::qwop;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -134,8 +134,8 @@ use asdf::qwop;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 3));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 3));\n \n     // Adding more will also bump the returned line offset.\n     opts.attrs.push(\"feature(hella_dope)\".to_string());\n@@ -147,8 +147,8 @@ use asdf::qwop;\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 4));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 4));\n }\n \n #[test]\n@@ -164,8 +164,8 @@ fn main() {\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -180,8 +180,8 @@ fn main() {\n     assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 1));\n+    let (output, len, _) = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 1));\n }\n \n #[test]\n@@ -196,8 +196,8 @@ fn main() {\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n }\n \n #[test]\n@@ -210,8 +210,8 @@ assert_eq!(2+2, 4);\";\n //Ceci n'est pas une `fn main`\n assert_eq!(2+2, 4);\"\n         .to_string();\n-    let output = make_test(input, None, true, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 1));\n+    let (output, len, _) = make_test(input, None, true, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 1));\n }\n \n #[test]\n@@ -224,8 +224,8 @@ fn make_test_display_warnings() {\n assert_eq!(2+2, 4);\n }\"\n     .to_string();\n-    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 1));\n+    let (output, len, _) = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 1));\n }\n \n #[test]\n@@ -242,8 +242,8 @@ assert_eq!(2+2, 4);\n }\"\n     .to_string();\n \n-    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 2));\n+    let (output, len, _) = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 2));\n \n     let input = \"extern crate hella_qwop;\n assert_eq!(asdf::foo, 4);\";\n@@ -256,8 +256,8 @@ assert_eq!(asdf::foo, 4);\n }\"\n     .to_string();\n \n-    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 3));\n+    let (output, len, _) = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 3));\n }\n \n #[test]\n@@ -274,6 +274,6 @@ test_wrapper! {\n }\"\n     .to_string();\n \n-    let output = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n-    assert_eq!(output, (expected, 1));\n+    let (output, len, _) = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!((output, len), (expected, 1));\n }"}, {"sha": "1cbfbf50dd745dafd90905e0630ac6d6d39ede55", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -64,7 +64,6 @@ fn write_footer(out: &mut String, playground_button: Option<&str>) {\n /// How a span of text is classified. Mostly corresponds to token kinds.\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Class {\n-    None,\n     Comment,\n     DocComment,\n     Attribute,\n@@ -89,7 +88,6 @@ impl Class {\n     /// Returns the css class expected by rustdoc for each `Class`.\n     fn as_html(self) -> &'static str {\n         match self {\n-            Class::None => \"\",\n             Class::Comment => \"comment\",\n             Class::DocComment => \"doccomment\",\n             Class::Attribute => \"attribute\",\n@@ -112,7 +110,7 @@ impl Class {\n }\n \n enum Highlight<'a> {\n-    Token { text: &'a str, class: Class },\n+    Token { text: &'a str, class: Option<Class> },\n     EnterSpan { class: Class },\n     ExitSpan,\n }\n@@ -166,8 +164,9 @@ impl<'a> Classifier<'a> {\n     /// a couple of following ones as well.\n     fn advance(&mut self, token: TokenKind, text: &'a str, sink: &mut dyn FnMut(Highlight<'a>)) {\n         let lookahead = self.peek();\n+        let no_highlight = |sink: &mut dyn FnMut(_)| sink(Highlight::Token { text, class: None });\n         let class = match token {\n-            TokenKind::Whitespace => Class::None,\n+            TokenKind::Whitespace => return no_highlight(sink),\n             TokenKind::LineComment { doc_style } | TokenKind::BlockComment { doc_style, .. } => {\n                 if doc_style.is_some() {\n                     Class::DocComment\n@@ -192,12 +191,12 @@ impl<'a> Classifier<'a> {\n             TokenKind::And => match lookahead {\n                 Some(TokenKind::And) => {\n                     let _and = self.tokens.next();\n-                    sink(Highlight::Token { text: \"&&\", class: Class::Op });\n+                    sink(Highlight::Token { text: \"&&\", class: Some(Class::Op) });\n                     return;\n                 }\n                 Some(TokenKind::Eq) => {\n                     let _eq = self.tokens.next();\n-                    sink(Highlight::Token { text: \"&=\", class: Class::Op });\n+                    sink(Highlight::Token { text: \"&=\", class: Some(Class::Op) });\n                     return;\n                 }\n                 Some(TokenKind::Whitespace) => Class::Op,\n@@ -228,7 +227,7 @@ impl<'a> Classifier<'a> {\n             | TokenKind::At\n             | TokenKind::Tilde\n             | TokenKind::Colon\n-            | TokenKind::Unknown => Class::None,\n+            | TokenKind::Unknown => return no_highlight(sink),\n \n             TokenKind::Question => Class::QuestionMark,\n \n@@ -237,7 +236,7 @@ impl<'a> Classifier<'a> {\n                     self.in_macro_nonterminal = true;\n                     Class::MacroNonTerminal\n                 }\n-                _ => Class::None,\n+                _ => return no_highlight(sink),\n             },\n \n             // This might be the start of an attribute. We're going to want to\n@@ -253,8 +252,8 @@ impl<'a> Classifier<'a> {\n                             self.in_attribute = true;\n                             sink(Highlight::EnterSpan { class: Class::Attribute });\n                         }\n-                        sink(Highlight::Token { text: \"#\", class: Class::None });\n-                        sink(Highlight::Token { text: \"!\", class: Class::None });\n+                        sink(Highlight::Token { text: \"#\", class: None });\n+                        sink(Highlight::Token { text: \"!\", class: None });\n                         return;\n                     }\n                     // Case 2: #[outer_attribute]\n@@ -264,16 +263,16 @@ impl<'a> Classifier<'a> {\n                     }\n                     _ => (),\n                 }\n-                Class::None\n+                return no_highlight(sink);\n             }\n             TokenKind::CloseBracket => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    sink(Highlight::Token { text: \"]\", class: Class::None });\n+                    sink(Highlight::Token { text: \"]\", class: None });\n                     sink(Highlight::ExitSpan);\n                     return;\n                 }\n-                Class::None\n+                return no_highlight(sink);\n             }\n             TokenKind::Literal { kind, .. } => match kind {\n                 // Text literals.\n@@ -309,7 +308,7 @@ impl<'a> Classifier<'a> {\n         };\n         // Anything that didn't return above is the simple case where we the\n         // class just spans a single token, so we can use the `string` method.\n-        sink(Highlight::Token { text, class });\n+        sink(Highlight::Token { text, class: Some(class) });\n     }\n \n     fn peek(&mut self) -> Option<TokenKind> {\n@@ -339,10 +338,10 @@ fn exit_span(out: &mut String) {\n /// ```\n /// The latter can be thought of as a shorthand for the former, which is more\n /// flexible.\n-fn string<T: Display>(out: &mut String, text: T, klass: Class) {\n+fn string<T: Display>(out: &mut String, text: T, klass: Option<Class>) {\n     match klass {\n-        Class::None => write!(out, \"{}\", text).unwrap(),\n-        klass => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text).unwrap(),\n+        None => write!(out, \"{}\", text).unwrap(),\n+        Some(klass) => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text).unwrap(),\n     }\n }\n "}, {"sha": "880c859dd1b23e8fd5642bd38e23cf0bb374bad2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -243,7 +243,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n                 .collect::<Vec<Cow<'_, str>>>()\n                 .join(\"\\n\");\n             let krate = krate.as_ref().map(|s| &**s);\n-            let (test, _) = doctest::make_test(&test, krate, false, &Default::default(), edition);\n+            let (test, _, _) =\n+                doctest::make_test(&test, krate, false, &Default::default(), edition);\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };\n \n             let edition_string = format!(\"&amp;edition={}\", edition);"}, {"sha": "085ca01f58daa38ffb5ca91ab6ef050b9013cc3b", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -167,7 +167,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match item.kind {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n-        clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),\n+        clean::MethodItem(ref m, _) => (&m.all_types, &m.ret_types),\n         clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),\n         _ => return None,\n     };"}, {"sha": "28f7a4d3162489714892bd5d49e954c817105f46", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -2589,7 +2589,9 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n             for (pos, m) in provided.iter().enumerate() {\n                 render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n                 match m.kind {\n-                    clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n+                    clean::MethodItem(ref inner, _)\n+                        if !inner.generics.where_predicates.is_empty() =>\n+                    {\n                         write!(w, \",\\n    {{ ... }}\\n\");\n                     }\n                     _ => {\n@@ -2759,7 +2761,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n         }\n         write_loading_content(w, \"</div>\");\n \n-        if t.auto {\n+        if t.is_auto {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -2790,7 +2792,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait,\n         );\n         write_loading_content(w, \"</div>\");\n \n-        if t.auto {\n+        if t.is_auto {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -2968,7 +2970,9 @@ fn render_assoc_item(\n     match item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n-        clean::MethodItem(ref m) => method(w, item, m.header, &m.generics, &m.decl, link, parent),\n+        clean::MethodItem(ref m, _) => {\n+            method(w, item, m.header, &m.generics, &m.decl, link, parent)\n+        }\n         clean::AssocConstItem(ref ty, ref default) => assoc_const(\n             w,\n             item,\n@@ -3545,7 +3549,7 @@ fn render_deref_methods(\n \n fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n     let self_type_opt = match item.kind {\n-        clean::MethodItem(ref method) => method.decl.self_type(),\n+        clean::MethodItem(ref method, _) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n         _ => None,\n     };\n@@ -3752,8 +3756,7 @@ fn render_impl(\n                 (true, \" hidden\")\n             };\n         match item.kind {\n-            clean::MethodItem(clean::Method { .. })\n-            | clean::TyMethodItem(clean::TyMethod { .. }) => {\n+            clean::MethodItem(..) | clean::TyMethodItem(_) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n@@ -4454,7 +4457,7 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     sidebar.push_str(&sidebar_assoc_items(it));\n \n     sidebar.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementors\\\">Implementors</a>\");\n-    if t.auto {\n+    if t.is_auto {\n         sidebar.push_str(\n             \"<a class=\\\"sidebar-title\\\" \\\n                 href=\\\"#synthetic-implementors\\\">Auto Implementors</a>\","}, {"sha": "e5b67f61a25b7463c315ebb2fb29d51c003b9b83", "filename": "src/test/ui/const-generics/macro_rules-braces.full.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.full.stderr?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -9,6 +9,17 @@ help: enclose the `const` expression in braces\n LL |     let _: baz!({ N });\n    |                 ^   ^\n \n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/macro_rules-braces.rs:54:17\n+   |\n+LL |     let _: baz!(10 + 7);\n+   |                 ^^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     let _: baz!({ 10 + 7 });\n+   |                 ^        ^\n+\n error: constant expression depends on a generic parameter\n   --> $DIR/macro_rules-braces.rs:10:13\n    |\n@@ -57,5 +68,5 @@ LL |     let _: biz!({ N });\n    = note: this may fail depending on what value the parameter takes\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "a4ef732017dd531448afbc3773fb60e830a01abd", "filename": "src/test/ui/const-generics/macro_rules-braces.min.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.min.stderr?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -9,6 +9,17 @@ help: enclose the `const` expression in braces\n LL |     let _: baz!({ N });\n    |                 ^   ^\n \n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/macro_rules-braces.rs:54:17\n+   |\n+LL |     let _: baz!(10 + 7);\n+   |                 ^^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     let _: baz!({ 10 + 7 });\n+   |                 ^        ^\n+\n error: generic parameters may not be used in const operations\n   --> $DIR/macro_rules-braces.rs:31:20\n    |\n@@ -41,5 +52,5 @@ LL |     let _: biz!({ N });\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "bc67d464f11bb0170c8cd045225e9b52bb6e75c2", "filename": "src/test/ui/const-generics/macro_rules-braces.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -36,6 +36,26 @@ fn test<const N: usize>() {\n     let _: baz!({{ N }}); //[min]~ ERROR generic parameters may not\n     let _: biz!(N);\n     let _: biz!({ N }); //[min]~ ERROR generic parameters may not\n+    let _: foo!(3);\n+    let _: foo!({ 3 });\n+    let _: foo!({{ 3 }});\n+    let _: bar!(3);\n+    let _: bar!({ 3 });\n+    let _: baz!(3);\n+    let _: baz!({ 3 });\n+    let _: baz!({{ 3 }});\n+    let _: biz!(3);\n+    let _: biz!({ 3 });\n+    let _: foo!(10 + 7);\n+    let _: foo!({ 10 + 7 });\n+    let _: foo!({{ 10 + 7 }});\n+    let _: bar!(10 + 7);\n+    let _: bar!({ 10 + 7 });\n+    let _: baz!(10 + 7); //~ ERROR expressions must be enclosed in braces\n+    let _: baz!({ 10 + 7 });\n+    let _: baz!({{ 10 + 7 }});\n+    let _: biz!(10 + 7);\n+    let _: biz!({ 10 + 7 });\n }\n \n fn main() {"}, {"sha": "cb44c1da76ba5e22f58ddace30ac630c624deae8", "filename": "src/test/ui/match/type_polymorphic_byte_str_literals.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.rs?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -0,0 +1,36 @@\n+#[deny(unreachable_patterns)]\n+\n+fn parse_data1(data: &[u8]) -> u32 {\n+    match data {\n+        b\"\" => 1,\n+        _ => 2,\n+    }\n+}\n+\n+fn parse_data2(data: &[u8]) -> u32 {\n+    match data { //~ ERROR non-exhaustive patterns: `&[_, ..]` not covered\n+        b\"\" => 1,\n+    }\n+}\n+\n+fn parse_data3(data: &[u8; 0]) -> u8 {\n+    match data {\n+        b\"\" => 1,\n+    }\n+}\n+\n+fn parse_data4(data: &[u8]) -> u8 {\n+    match data { //~ ERROR non-exhaustive patterns\n+        b\"aaa\" => 0,\n+        [_, _, _] => 1,\n+    }\n+}\n+\n+fn parse_data5(data: &[u8; 3]) -> u8 {\n+    match data {\n+        b\"aaa\" => 0,\n+        [_, _, _] => 1,\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6ce53a4f21ea21ed1402d490fdb54b34fef3ab8a", "filename": "src/test/ui/match/type_polymorphic_byte_str_literals.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Ftype_polymorphic_byte_str_literals.stderr?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -0,0 +1,21 @@\n+error[E0004]: non-exhaustive patterns: `&[_, ..]` not covered\n+  --> $DIR/type_polymorphic_byte_str_literals.rs:11:11\n+   |\n+LL |     match data {\n+   |           ^^^^ pattern `&[_, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8]`\n+\n+error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+  --> $DIR/type_polymorphic_byte_str_literals.rs:23:11\n+   |\n+LL |     match data {\n+   |           ^^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 1 more not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[u8]`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "ffc8433403fd59d96de8e2caa10fe9750c066106", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c919f490bbcd2b29b74016101f7ec71aaa24bdbb/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -7,11 +7,11 @@ LL |     match buf {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`\n \n-error[E0004]: non-exhaustive patterns: `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n   --> $DIR/match-byte-array-patterns-2.rs:10:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[0_u8..=64_u8, _, _, _]` and `&[66_u8..=u8::MAX, _, _, _]` not covered\n+   |           ^^^ patterns `&[]`, `&[_]`, `&[_, _]` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8]`"}, {"sha": "580d826e9b0f407a2d4b36696cda2f0fa8d7ddaa", "filename": "src/tools/rustfmt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt?ref=c919f490bbcd2b29b74016101f7ec71aaa24bdbb", "patch": "@@ -1 +1 @@\n-Subproject commit 293d7d01118c9fb5479649399e1dae60322b8e09\n+Subproject commit 580d826e9b0f407a2d4b36696cda2f0fa8d7ddaa"}]}