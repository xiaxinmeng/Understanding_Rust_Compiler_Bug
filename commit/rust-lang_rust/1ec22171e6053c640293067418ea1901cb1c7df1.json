{"sha": "1ec22171e6053c640293067418ea1901cb1c7df1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYzIyMTcxZTYwNTNjNjQwMjkzMDY3NDE4ZWExOTAxY2IxYzdkZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-08T07:31:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-08T07:31:40Z"}, "message": "Auto merge of #33130 - eddyb:mir-const, r=nikomatsakis\n\nImplement constant support in MIR.\n\nAll of the intended features in `trans::consts` are now supported by `mir::constant`.\nThe implementation is considered a temporary measure until `miri` replaces it.\n\nA `-Z orbit` bootstrap build will only translate LLVM IR from AST for `#[rustc_no_mir]` functions.\n\nFurthermore, almost all checks of constant expressions have been moved to MIR.\nIn non-`const` functions, trees of temporaries are promoted, as per RFC 1414 (rvalue promotion).\nPromotion before MIR borrowck would allow reasoning about promoted values' lifetimes.\n\nThe improved checking comes at the cost of four `[breaking-change]`s:\n* repeat counts must contain a constant expression, e.g.:\n`let arr = [0; { println!(\"foo\"); 5 }];` used to be allowed (it behaved like `let arr = [0; 5];`)\n* dereference of a reference to a `static` cannot be used in another `static`, e.g.:\n`static X: [u8; 1] = [1]; static Y: u8 = (&X)[0];` was unintentionally allowed before\n* the type of a `static` *must* be `Sync`, irrespective of the initializer, e.g.\n`static FOO: *const T = &BAR;` worked as `&T` is `Sync`, but it shouldn't because `*const T` isn't\n* a `static` cannot wrap `UnsafeCell` around a type that *may* need drop, e.g.\n`static X: MakeSync<UnsafeCell<Option<String>>> = MakeSync(UnsafeCell::new(None));`\nwas previously allowed based on the fact `None` alone doesn't need drop, but in `UnsafeCell`\nit can be later changed to `Some(String)` which *does* need dropping\n\nThe drop restrictions are relaxed by RFC 1440 (#33156), which is implemented, but feature-gated.\nHowever, creating `UnsafeCell` from constants is unstable, so users can just enable the feature gate.", "tree": {"sha": "8d4b9c30157f0bcaeb42fc3d7fe606fe91b33738", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d4b9c30157f0bcaeb42fc3d7fe606fe91b33738"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ec22171e6053c640293067418ea1901cb1c7df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec22171e6053c640293067418ea1901cb1c7df1", "html_url": "https://github.com/rust-lang/rust/commit/1ec22171e6053c640293067418ea1901cb1c7df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ec22171e6053c640293067418ea1901cb1c7df1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "url": "https://api.github.com/repos/rust-lang/rust/commits/d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "html_url": "https://github.com/rust-lang/rust/commit/d91f8ab0f58fa123857d96b9e151fc5185f5ff08"}, {"sha": "3b0e27cc74d61e229aeaf0a710d3a018f7104ffc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0e27cc74d61e229aeaf0a710d3a018f7104ffc", "html_url": "https://github.com/rust-lang/rust/commit/3b0e27cc74d61e229aeaf0a710d3a018f7104ffc"}], "stats": {"total": 4762, "additions": 3411, "deletions": 1351}, "files": [{"sha": "48c1e4ad59d5bbe752a7cdb20da2d6ae41a061ca", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -111,7 +111,7 @@ DEPS_rustc_lint := rustc log syntax rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_metadata := rustc syntax rbml rustc_const_math\n DEPS_rustc_passes := syntax rustc core rustc_const_eval\n-DEPS_rustc_mir := rustc syntax rustc_const_math rustc_const_eval\n+DEPS_rustc_mir := rustc syntax rustc_const_math rustc_const_eval rustc_bitflags\n DEPS_rustc_resolve := arena rustc log syntax\n DEPS_rustc_platform_intrinsics := std\n DEPS_rustc_plugin := rustc rustc_metadata syntax rustc_mir"}, {"sha": "8378495599ce33be9b9b38cbc566dd20fd7af569", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -64,6 +64,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IntrinsicCheck(D),\n     MatchCheck(D),\n     MirMapConstruction(D),\n+    MirPass(D),\n     MirTypeck(D),\n     BorrowCheck(D),\n     RvalueCheck(D),\n@@ -186,6 +187,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n             MatchCheck(ref d) => op(d).map(MatchCheck),\n             MirMapConstruction(ref d) => op(d).map(MirMapConstruction),\n+            MirPass(ref d) => op(d).map(MirPass),\n             MirTypeck(ref d) => op(d).map(MirTypeck),\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),"}, {"sha": "640ef48493a2ce819f8d23967e9e6cd2b96077b3", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 68, "deletions": 14, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -97,6 +97,31 @@ impl<'ast> DefCollector<'ast> {\n         f(self);\n         self.parent_def = parent;\n     }\n+\n+    fn visit_ast_const_integer(&mut self, expr: &'ast Expr) {\n+        // Find the node which will be used after lowering.\n+        if let ExprKind::Paren(ref inner) = expr.node {\n+            return self.visit_ast_const_integer(inner);\n+        }\n+\n+        // FIXME(eddyb) Closures should have separate\n+        // function definition IDs and expression IDs.\n+        if let ExprKind::Closure(..) = expr.node {\n+            return;\n+        }\n+\n+        self.create_def(expr.id, DefPathData::Initializer);\n+    }\n+\n+    fn visit_hir_const_integer(&mut self, expr: &'ast hir::Expr) {\n+        // FIXME(eddyb) Closures should have separate\n+        // function definition IDs and expression IDs.\n+        if let hir::ExprClosure(..) = expr.node {\n+            return;\n+        }\n+\n+        self.create_def(expr.id, DefPathData::Initializer);\n+    }\n }\n \n impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n@@ -126,14 +151,17 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n                                             DefPathData::EnumVariant(v.node.name.name));\n-\n-                        for (index, field) in v.node.data.fields().iter().enumerate() {\n-                            let name = field.ident.map(|ident| ident.name)\n-                                .unwrap_or(token::intern(&index.to_string()));\n-                            this.create_def_with_parent(Some(variant_def_index),\n-                                                        field.id,\n-                                                        DefPathData::Field(name));\n-                        }\n+                        this.with_parent(variant_def_index, |this| {\n+                            for (index, field) in v.node.data.fields().iter().enumerate() {\n+                                let name = field.ident.map(|ident| ident.name)\n+                                    .unwrap_or_else(|| token::intern(&index.to_string()));\n+                                this.create_def(field.id, DefPathData::Field(name));\n+                            }\n+\n+                            if let Some(ref expr) = v.node.disr_expr {\n+                                this.visit_ast_const_integer(expr);\n+                            }\n+                        });\n                     }\n                 }\n                 ItemKind::Struct(ref struct_def, _) => {\n@@ -221,6 +249,10 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &'ast Expr) {\n         let parent_def = self.parent_def;\n \n+        if let ExprKind::Repeat(_, ref count) = expr.node {\n+            self.visit_ast_const_integer(count);\n+        }\n+\n         if let ExprKind::Closure(..) = expr.node {\n             let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n             self.parent_def = Some(def);\n@@ -230,6 +262,13 @@ impl<'ast> visit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n+            self.visit_ast_const_integer(length);\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+\n     fn visit_lifetime_def(&mut self, def: &'ast LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n@@ -276,11 +315,15 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n                             this.create_def(v.node.data.id(),\n                                             DefPathData::EnumVariant(v.node.name));\n \n-                        for field in v.node.data.fields() {\n-                            this.create_def_with_parent(Some(variant_def_index),\n-                                                        field.id,\n-                                                        DefPathData::Field(field.name));\n-                        }\n+                        this.with_parent(variant_def_index, |this| {\n+                            for field in v.node.data.fields() {\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(field.name));\n+                            }\n+                            if let Some(ref expr) = v.node.disr_expr {\n+                                this.visit_hir_const_integer(expr);\n+                            }\n+                        });\n                     }\n                 }\n                 hir::ItemStruct(ref struct_def, _) => {\n@@ -365,6 +408,10 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &'ast hir::Expr) {\n         let parent_def = self.parent_def;\n \n+        if let hir::ExprRepeat(_, ref count) = expr.node {\n+            self.visit_hir_const_integer(count);\n+        }\n+\n         if let hir::ExprClosure(..) = expr.node {\n             let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n             self.parent_def = Some(def);\n@@ -374,11 +421,18 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         self.parent_def = parent_def;\n     }\n \n+    fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n+        if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n+            self.visit_hir_const_integer(length);\n+        }\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n     fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "9f8a3dbfa8f39d66ce2b6f3c13f548c1fb5aa171", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -36,6 +36,11 @@ pub struct Mir<'tcx> {\n     /// used (eventually) for debuginfo. Indexed by a `ScopeId`.\n     pub scopes: Vec<ScopeData>,\n \n+    /// Rvalues promoted from this function, such as borrows of constants.\n+    /// Each of them is the Mir of a constant with the fn's type parameters\n+    /// in scope, but no vars or args and a separate set of temps.\n+    pub promoted: Vec<Mir<'tcx>>,\n+\n     /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n@@ -987,6 +992,10 @@ pub enum Literal<'tcx> {\n     Value {\n         value: ConstVal,\n     },\n+    Promoted {\n+        // Index into the `promoted` vector of `Mir`.\n+        index: usize\n+    },\n }\n \n impl<'tcx> Debug for Constant<'tcx> {\n@@ -1007,6 +1016,9 @@ impl<'tcx> Debug for Literal<'tcx> {\n                 write!(fmt, \"const \")?;\n                 fmt_const_val(fmt, value)\n             }\n+            Promoted { index } => {\n+                write!(fmt, \"promoted{}\", index)\n+            }\n         }\n     }\n }"}, {"sha": "520bfbddf9f0a179f18503070a5c6631da83826f", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,31 +8,102 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::DepNode;\n+use hir;\n+use hir::map::DefPathData;\n+use hir::def_id::DefId;\n use mir::mir_map::MirMap;\n use mir::repr::Mir;\n use ty::TyCtxt;\n use syntax::ast::NodeId;\n \n+/// Where a specific Mir comes from.\n+#[derive(Copy, Clone)]\n+pub enum MirSource {\n+    /// Functions and methods.\n+    Fn(NodeId),\n+\n+    /// Constants and associated constants.\n+    Const(NodeId),\n+\n+    /// Initializer of a `static` item.\n+    Static(NodeId, hir::Mutability),\n+\n+    /// Promoted rvalues within a function.\n+    Promoted(NodeId, usize)\n+}\n+\n+impl MirSource {\n+    pub fn from_node(tcx: &TyCtxt, id: NodeId) -> MirSource {\n+        use hir::*;\n+\n+        // Handle constants in enum discriminants, types, and repeat expressions.\n+        let def_id = tcx.map.local_def_id(id);\n+        let def_key = tcx.def_key(def_id);\n+        if def_key.disambiguated_data.data == DefPathData::Initializer {\n+            return MirSource::Const(id);\n+        }\n+\n+        match tcx.map.get(id) {\n+            map::NodeItem(&Item { node: ItemConst(..), .. }) |\n+            map::NodeTraitItem(&TraitItem { node: ConstTraitItem(..), .. }) |\n+            map::NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) => {\n+                MirSource::Const(id)\n+            }\n+            map::NodeItem(&Item { node: ItemStatic(_, m, _), .. }) => {\n+                MirSource::Static(id, m)\n+            }\n+            // Default to function if it's not a constant or static.\n+            _ => MirSource::Fn(id)\n+        }\n+    }\n+\n+    pub fn item_id(&self) -> NodeId {\n+        match *self {\n+            MirSource::Fn(id) |\n+            MirSource::Const(id) |\n+            MirSource::Static(id, _) |\n+            MirSource::Promoted(id, _) => id\n+        }\n+    }\n+}\n+\n /// Various information about pass.\n pub trait Pass {\n     // fn name() for printouts of various sorts?\n     // fn should_run(Session) to check if pass should run?\n+    fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n+        DepNode::MirPass(def_id)\n+    }\n }\n \n /// A pass which inspects the whole MirMap.\n pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass(&mut self, cx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n }\n \n /// A pass which inspects Mir of functions in isolation.\n pub trait MirPass<'tcx>: Pass {\n-    fn run_pass(&mut self, cx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>);\n+    fn run_pass_on_promoted(&mut self, tcx: &TyCtxt<'tcx>,\n+                            item_id: NodeId, index: usize,\n+                            mir: &mut Mir<'tcx>) {\n+        self.run_pass(tcx, MirSource::Promoted(item_id, index), mir);\n+    }\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>);\n }\n \n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n     fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n         for (&id, mir) in &mut map.map {\n-            MirPass::run_pass(self, tcx, id, mir);\n+            let def_id = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+\n+            let src = MirSource::from_node(tcx, id);\n+            MirPass::run_pass(self, tcx, src, mir);\n+\n+            for (i, mir) in mir.promoted.iter_mut().enumerate() {\n+                self.run_pass_on_promoted(tcx, id, i, mir);\n+            }\n         }\n     }\n }"}, {"sha": "f6a241004b37beb319a084421778bc8bea57da07", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -244,6 +244,7 @@ macro_rules! make_mir_visitor {\n                 let Mir {\n                     ref $($mutability)* basic_blocks,\n                     ref $($mutability)* scopes,\n+                    promoted: _, // Visited by passes separately.\n                     ref $($mutability)* return_ty,\n                     ref $($mutability)* var_decls,\n                     ref $($mutability)* arg_decls,\n@@ -649,10 +650,11 @@ macro_rules! make_mir_visitor {\n                                     ref $($mutability)* substs } => {\n                         self.visit_def_id(def_id);\n                         self.visit_substs(substs);\n-                    },\n+                    }\n                     Literal::Value { ref $($mutability)* value } => {\n                         self.visit_const_val(value);\n                     }\n+                    Literal::Promoted { index: _ } => {}\n                 }\n             }\n "}, {"sha": "174f626498b1f17ae45d25dad5fb263474d1ddc5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -25,7 +25,7 @@ use middle::cstore::{self, LOCAL_CRATE};\n use hir::def::{self, Def, ExportMap};\n use hir::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n-use middle::region::{CodeExtent};\n+use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n use traits;\n use ty;\n use ty::subst::{Subst, Substs, VecPerParamSpace};\n@@ -1376,6 +1376,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n+                    hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n@@ -1408,6 +1409,15 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 // This is a convenience to allow closures to work.\n                 ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n             }\n+            Some(ast_map::NodeForeignItem(item)) => {\n+                let def_id = cx.map.local_def_id(id);\n+                let scheme = cx.lookup_item_type(def_id);\n+                let predicates = cx.lookup_predicates(def_id);\n+                cx.construct_parameter_environment(item.span,\n+                                                   &scheme.generics,\n+                                                   &predicates,\n+                                                   ROOT_CODE_EXTENT)\n+            }\n             _ => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n                       `{}` is not an item\","}, {"sha": "1b570933beeccd495c4b3ad7476e4fe0ba3d58b0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -37,7 +37,7 @@ use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc::hir::lowering::{lower_crate, LoweringContext};\n-use rustc_passes::{no_asm, loops, consts, const_fn, rvalues, static_recursion};\n+use rustc_passes::{no_asm, loops, consts, rvalues, static_recursion};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -726,10 +726,6 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         })\n     })?;\n \n-    time(time_passes,\n-         \"const fn bodies and arguments\",\n-         || const_fn::check_crate(sess, &krate))?;\n-\n     if sess.opts.debugging_opts.input_stats {\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n@@ -903,6 +899,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in passes.\n             passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n+            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n             passes.push_pass(box mir::transform::simplify_cfg::SimplifyCfg);\n             passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);"}, {"sha": "c911b20c2aba2c94217db4c3a7f2ac03f36c6355", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -855,6 +855,9 @@ pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n         };\n \n         def_id_and_span_translator.visit_mir(&mut mir);\n+        for promoted in &mut mir.promoted {\n+            def_id_and_span_translator.visit_mir(promoted);\n+        }\n \n         mir\n     });"}, {"sha": "77dccb7e0d48347b96500dfb62bd408563aa7d16", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -16,4 +16,5 @@ rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "a4f4e44b1b13998e599347b9dc0a69c94a841442", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -35,13 +35,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         let expr_ty = expr.ty.clone();\n         let temp = this.temp(expr_ty.clone());\n-        let temp_lifetime = match expr.temp_lifetime {\n-            Some(t) => t,\n-            None => {\n-                span_bug!(expr.span, \"no temp_lifetime for expr\");\n-            }\n-        };\n-        this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);\n+        // In constants, temp_lifetime is None. We should not need to drop\n+        // anything because no values with a destructor can be created in\n+        // a constant at this time, even if the type may need dropping.\n+        if let Some(temp_lifetime) = expr.temp_lifetime {\n+            this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);\n+        }\n \n         // Careful here not to cause an infinite cycle. If we always\n         // called `into`, then for lvalues like `x.f`, it would"}, {"sha": "c6765f95d33caf9e68715d51625948aded39bf0d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 146, "deletions": 114, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n use hair::cx::Cx;\n-use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{self, FnOutput, Ty};\n+use rustc::middle::region::{CodeExtent, CodeExtentData, ROOT_CODE_EXTENT};\n+use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n@@ -83,7 +84,7 @@ pub struct ScopeAuxiliary {\n     pub postdoms: Vec<Location>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Location {\n     /// the location is within this block\n     pub block: BasicBlock,\n@@ -159,74 +160,51 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n-                          span: Span,\n-                          fn_id: ast::NodeId,\n-                          body_id: ast::NodeId,\n-                          implicit_arguments: Vec<Ty<'tcx>>,\n-                          explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                          return_ty: FnOutput<'tcx>,\n-                          ast_block: &'tcx hir::Block)\n-                          -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n+                                 fn_id: ast::NodeId,\n+                                 arguments: A,\n+                                 return_ty: ty::FnOutput<'tcx>,\n+                                 ast_block: &'tcx hir::Block)\n+                                 -> (Mir<'tcx>, ScopeAuxiliaryVec)\n+    where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n+{\n     let tcx = hir.tcx();\n-    let cfg = CFG { basic_blocks: vec![] };\n-\n-    let mut builder = Builder {\n-        hir: hir,\n-        cfg: cfg,\n-        fn_span: span,\n-        scopes: vec![],\n-        scope_datas: vec![],\n-        scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n-        loop_scopes: vec![],\n-        temp_decls: vec![],\n-        var_decls: vec![],\n-        var_indices: FnvHashMap(),\n-        unit_temp: None,\n-        cached_resume_block: None,\n-        cached_return_block: None\n-    };\n-\n-    assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+    let span = tcx.map.span(fn_id);\n+    let mut builder = Builder::new(hir, span);\n \n-    let mut arg_decls = None; // assigned to `Some` in closures below\n+    let body_id = ast_block.id;\n     let call_site_extent =\n         tcx.region_maps.lookup_code_extent(\n             CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id });\n-    let _ = builder.in_scope(call_site_extent, START_BLOCK, |builder, call_site_scope_id| {\n-        let mut block = START_BLOCK;\n-        let arg_extent =\n-            tcx.region_maps.lookup_code_extent(\n-                CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n-        unpack!(block = builder.in_scope(arg_extent, block, |builder, arg_scope_id| {\n-            arg_decls = Some(unpack!(block = builder.args_and_body(block,\n-                                                                   return_ty,\n-                                                                   implicit_arguments,\n-                                                                   explicit_arguments,\n-                                                                   arg_scope_id,\n-                                                                   ast_block)));\n-            block.unit()\n+    let arg_extent =\n+        tcx.region_maps.lookup_code_extent(\n+            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body_id });\n+    let mut block = START_BLOCK;\n+    let mut arg_decls = unpack!(block = builder.in_scope(call_site_extent, block,\n+                                                         |builder, call_site_scope_id| {\n+        let arg_decls = unpack!(block = builder.in_scope(arg_extent, block,\n+                                                         |builder, arg_scope_id| {\n+            builder.args_and_body(block, return_ty, arguments, arg_scope_id, ast_block)\n         }));\n \n         let return_block = builder.return_block();\n         builder.cfg.terminate(block, call_site_scope_id, span,\n                               TerminatorKind::Goto { target: return_block });\n         builder.cfg.terminate(return_block, call_site_scope_id, span,\n                               TerminatorKind::Return);\n-        return_block.unit()\n-    });\n-\n-    assert!(\n-        builder.cfg.basic_blocks\n-                   .iter()\n-                   .enumerate()\n-                   .all(|(index, block)| {\n-                       if block.terminator.is_none() {\n-                           bug!(\"no terminator on block {:?} in fn {:?}\",\n-                                index, fn_id)\n-                       }\n-                       true\n-                   }));\n+        return_block.and(arg_decls)\n+    }));\n+    assert_eq!(block, builder.return_block());\n+\n+    match tcx.node_id_to_type(fn_id).sty {\n+        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n+            // RustCall pseudo-ABI untuples the last argument.\n+            if let Some(arg_decl) = arg_decls.last_mut() {\n+                arg_decl.spread = true;\n+            }\n+        }\n+        _ => {}\n+    }\n \n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n@@ -251,72 +229,126 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n         }).collect()\n     });\n \n-    (\n-        Mir {\n-            basic_blocks: builder.cfg.basic_blocks,\n-            scopes: builder.scope_datas,\n-            var_decls: builder.var_decls,\n-            arg_decls: arg_decls.take().expect(\"args never built?\"),\n-            temp_decls: builder.temp_decls,\n-            upvar_decls: upvar_decls,\n-            return_ty: return_ty,\n-            span: span\n-        },\n-        builder.scope_auxiliary,\n-    )\n+    builder.finish(upvar_decls, arg_decls, return_ty)\n+}\n+\n+pub fn construct_const<'a, 'tcx>(hir: Cx<'a,'tcx>,\n+                                 item_id: ast::NodeId,\n+                                 ast_expr: &'tcx hir::Expr)\n+                                 -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+    let tcx = hir.tcx();\n+    let span = tcx.map.span(item_id);\n+    let mut builder = Builder::new(hir, span);\n+\n+    let extent = ROOT_CODE_EXTENT;\n+    let mut block = START_BLOCK;\n+    let _ = builder.in_scope(extent, block, |builder, call_site_scope_id| {\n+        let expr = builder.hir.mirror(ast_expr);\n+        unpack!(block = builder.into(&Lvalue::ReturnPointer, block, expr));\n+\n+        let return_block = builder.return_block();\n+        builder.cfg.terminate(block, call_site_scope_id, span,\n+                              TerminatorKind::Goto { target: return_block });\n+        builder.cfg.terminate(return_block, call_site_scope_id, span,\n+                              TerminatorKind::Return);\n+\n+        return_block.unit()\n+    });\n+\n+    let ty = tcx.expr_ty_adjusted(ast_expr);\n+    builder.finish(vec![], vec![], ty::FnConverging(ty))\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn args_and_body(&mut self,\n-                     mut block: BasicBlock,\n-                     return_ty: FnOutput<'tcx>,\n-                     implicit_arguments: Vec<Ty<'tcx>>,\n-                     explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n-                     argument_scope_id: ScopeId,\n-                     ast_block: &'tcx hir::Block)\n-                     -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+    fn new(hir: Cx<'a, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n+        let mut builder = Builder {\n+            hir: hir,\n+            cfg: CFG { basic_blocks: vec![] },\n+            fn_span: span,\n+            scopes: vec![],\n+            scope_datas: vec![],\n+            scope_auxiliary: ScopeAuxiliaryVec { vec: vec![] },\n+            loop_scopes: vec![],\n+            temp_decls: vec![],\n+            var_decls: vec![],\n+            var_indices: FnvHashMap(),\n+            unit_temp: None,\n+            cached_resume_block: None,\n+            cached_return_block: None\n+        };\n+\n+        assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n+\n+        builder\n+    }\n+\n+    fn finish(self,\n+              upvar_decls: Vec<UpvarDecl>,\n+              arg_decls: Vec<ArgDecl<'tcx>>,\n+              return_ty: ty::FnOutput<'tcx>)\n+              -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+        for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n+            if block.terminator.is_none() {\n+                span_bug!(self.fn_span, \"no terminator on block {:?}\", index);\n+            }\n+        }\n+\n+        (Mir {\n+            basic_blocks: self.cfg.basic_blocks,\n+            scopes: self.scope_datas,\n+            promoted: vec![],\n+            var_decls: self.var_decls,\n+            arg_decls: arg_decls,\n+            temp_decls: self.temp_decls,\n+            upvar_decls: upvar_decls,\n+            return_ty: return_ty,\n+            span: self.fn_span\n+        }, self.scope_auxiliary)\n+    }\n+\n+    fn args_and_body<A>(&mut self,\n+                        mut block: BasicBlock,\n+                        return_ty: ty::FnOutput<'tcx>,\n+                        arguments: A,\n+                        argument_scope_id: ScopeId,\n+                        ast_block: &'tcx hir::Block)\n+                        -> BlockAnd<Vec<ArgDecl<'tcx>>>\n+        where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n-        let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n-        let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n-            let arg_decls =\n-            implicits\n-            .chain(explicits)\n-            .enumerate()\n-            .map(|(index, (ty, pattern))| {\n-                let lvalue = Lvalue::Arg(index as u32);\n-                if let Some(pattern) = pattern {\n-                    let pattern = self.hir.irrefutable_pat(pattern);\n-                    unpack!(block = self.lvalue_into_pattern(block,\n-                                                             argument_scope_id,\n-                                                             pattern,\n-                                                             &lvalue));\n-                }\n+        let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {\n+            let lvalue = Lvalue::Arg(index as u32);\n+            if let Some(pattern) = pattern {\n+                let pattern = self.hir.irrefutable_pat(pattern);\n+                unpack!(block = self.lvalue_into_pattern(block,\n+                                                         argument_scope_id,\n+                                                         pattern,\n+                                                         &lvalue));\n+            }\n \n-                // Make sure we drop (parts of) the argument even when not matched on.\n-                let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n-                self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n-                                   argument_extent, &lvalue, ty);\n-\n-                let mut name = keywords::Invalid.name();\n-                if let Some(pat) = pattern {\n-                    if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n-                        if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n-                            name = ident.node.name;\n-                        }\n+            // Make sure we drop (parts of) the argument even when not matched on.\n+            let argument_extent = self.scope_auxiliary[argument_scope_id].extent;\n+            self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n+                               argument_extent, &lvalue, ty);\n+\n+            let mut name = keywords::Invalid.name();\n+            if let Some(pat) = pattern {\n+                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                    if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n+                        name = ident.node.name;\n                     }\n                 }\n+            }\n \n-                ArgDecl {\n-                    ty: ty,\n-                    spread: false,\n-                    debug_name: name\n-                }\n-            })\n-            .collect();\n+            ArgDecl {\n+                ty: ty,\n+                spread: false,\n+                debug_name: name\n+            }\n+        }).collect();\n \n         // FIXME(#32959): temporary hack for the issue at hand\n-        let return_is_unit = if let FnOutput::FnConverging(t) = return_ty {\n+        let return_is_unit = if let ty::FnConverging(t) = return_ty {\n             t.is_nil()\n         } else {\n             false"}, {"sha": "65d51d205285a6c1836da6eee8676ac8366c3f6c", "filename": "src/librustc_mir/diagnostics.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_long_diagnostics! {\n+\n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time. Erroneous\n+code example:\n+\n+```compile_fail\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```\n+\"##,\n+\n+E0013: r##\"\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable. For example, `Y` cannot refer to\n+`X` here:\n+\n+```compile_fail\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+To fix this, the value can be extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```\n+\"##,\n+\n+// FIXME(#24111) Change the language here when const fn stabilizes\n+E0015: r##\"\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+\"##,\n+\n+E0016: r##\"\n+Blocks in constants may only contain items (such as constant, function\n+definition, etc...) and a tail expression. Erroneous code example:\n+\n+```compile_fail\n+const FOO: i32 = { let x = 0; x }; // 'x' isn't an item!\n+```\n+\n+To avoid it, you have to replace the non-item object:\n+\n+```\n+const FOO: i32 = { const X : i32 = 0; X };\n+```\n+\"##,\n+\n+E0017: r##\"\n+References in statics and constants may only refer to immutable values.\n+Erroneous code example:\n+\n+```compile_fail\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &'static mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`.\n+\"##,\n+\n+E0018: r##\"\n+\n+The value of static and constant integers must be known at compile time. You\n+can't cast a pointer to an integer because the address of a pointer can\n+vary.\n+\n+For example, if you write:\n+\n+```compile_fail\n+static MY_STATIC: u32 = 42;\n+static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;\n+static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n+```\n+\n+Then `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However,\n+the address can change when the program is linked, as well as change\n+between different executions due to ASLR, and many linkers would\n+not be able to calculate the value of `WHAT`.\n+\n+On the other hand, static and constant pointers can point either to\n+a known numeric address or to the address of a symbol.\n+\n+```\n+static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;\n+// ... and also\n+static MY_STATIC_ADDR2: *const u32 = &MY_STATIC;\n+\n+const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n+```\n+\n+This does not pose a problem by itself because they can't be\n+accessed directly.\n+\"##,\n+\n+E0019: r##\"\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time. Erroneous code\n+example:\n+\n+```compile_fail\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn test(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    const A: i32 = FOO.test(); // You can't call Test::func() here !\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```\n+\"##,\n+\n+E0022: r##\"\n+Constant functions are not allowed to mutate anything. Thus, binding to an\n+argument with a mutable pattern is not allowed. For example,\n+\n+```compile_fail\n+const fn foo(mut x: u8) {\n+    // do stuff\n+}\n+```\n+\n+Is incorrect because the function body may not mutate `x`.\n+\n+Remove any mutable bindings from the argument list to fix this error. In case\n+you need to mutate the argument, try lazily initializing a global variable\n+instead of using a `const fn`, or refactoring the code to a functional style to\n+avoid mutation if possible.\n+\"##,\n+\n+E0394: r##\"\n+From [RFC 246]:\n+\n+ > It is invalid for a static to reference another static by value. It is\n+ > required that all references be borrowed.\n+\n+[RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n+\"##,\n+\n+\n+E0395: r##\"\n+The value assigned to a constant scalar must be known at compile time,\n+which is not the case when comparing raw pointers.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+static FOO: i32 = 42;\n+static BAR: i32 = 42;\n+\n+static BAZ: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n+// error: raw pointers cannot be compared in statics!\n+```\n+\n+The address assigned by the linker to `FOO` and `BAR` may or may not\n+be identical, so the value of `BAZ` can't be determined.\n+\n+If you want to do the comparison, please do it at run-time.\n+\n+For example:\n+\n+```\n+static FOO: i32 = 42;\n+static BAR: i32 = 42;\n+\n+let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n+// baz isn't a constant expression so it's ok\n+```\n+\"##,\n+\n+E0396: r##\"\n+The value behind a raw pointer can't be determined at compile-time\n+(or even link-time), which means it can't be used in a constant\n+expression. Erroneous code example:\n+\n+```compile_fail\n+const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n+\n+const VALUE: u8 = unsafe { *REG_ADDR };\n+// error: raw pointers cannot be dereferenced in constants\n+```\n+\n+A possible fix is to dereference your pointer at some point in run-time.\n+\n+For example:\n+\n+```\n+const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n+\n+let reg_value = unsafe { *REG_ADDR };\n+```\n+\"##,\n+\n+E0492: r##\"\n+A borrow of a constant containing interior mutability was attempted. Erroneous\n+code example:\n+\n+```compile_fail\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+const A: AtomicUsize = ATOMIC_USIZE_INIT;\n+static B: &'static AtomicUsize = &A;\n+// error: cannot borrow a constant which contains interior mutability, create a\n+//        static instead\n+```\n+\n+A `const` represents a constant value that should never change. If one takes\n+a `&` reference to the constant, then one is taking a pointer to some memory\n+location containing the value. Normally this is perfectly fine: most values\n+can't be changed via a shared `&` pointer, but interior mutability would allow\n+it. That is, a constant value could be mutated. On the other hand, a `static` is\n+explicitly a single memory location, which can be mutated at will.\n+\n+So, in order to solve this error, either use statics which are `Sync`:\n+\n+```\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+\n+static A: AtomicUsize = ATOMIC_USIZE_INIT;\n+static B: &'static AtomicUsize = &A; // ok!\n+```\n+\n+You can also have this error while using a cell type:\n+\n+```compile_fail\n+#![feature(const_fn)]\n+\n+use std::cell::Cell;\n+\n+const A: Cell<usize> = Cell::new(1);\n+const B: &'static Cell<usize> = &A;\n+// error: cannot borrow a constant which contains interior mutability, create\n+//        a static instead\n+\n+// or:\n+struct C { a: Cell<usize> }\n+\n+const D: C = C { a: Cell::new(1) };\n+const E: &'static Cell<usize> = &D.a; // error\n+\n+// or:\n+const F: &'static C = &D; // error\n+```\n+\n+This is because cell types do operations that are not thread-safe. Due to this,\n+they don't implement Sync and thus can't be placed in statics. In this\n+case, `StaticMutex` would work just fine, but it isn't stable yet:\n+https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n+\n+However, if you still wish to use these types, you can achieve this by an unsafe\n+wrapper:\n+\n+```\n+#![feature(const_fn)]\n+\n+use std::cell::Cell;\n+use std::marker::Sync;\n+\n+struct NotThreadSafe<T> {\n+    value: Cell<T>,\n+}\n+\n+unsafe impl<T> Sync for NotThreadSafe<T> {}\n+\n+static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n+static B: &'static NotThreadSafe<usize> = &A; // ok!\n+```\n+\n+Remember this solution is unsafe! You will have to ensure that accesses to the\n+cell are synchronized.\n+\"##,\n+\n+E0493: r##\"\n+A type with a destructor was assigned to an invalid type of variable. Erroneous\n+code example:\n+\n+```compile_fail\n+struct Foo {\n+    a: u32\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+const F : Foo = Foo { a : 0 };\n+// error: constants are not allowed to have destructors\n+static S : Foo = Foo { a : 0 };\n+// error: destructors in statics are an unstable feature\n+```\n+\n+To solve this issue, please use a type which does allow the usage of type with\n+destructors.\n+\"##,\n+\n+E0494: r##\"\n+A reference of an interior static was assigned to another const/static.\n+Erroneous code example:\n+\n+```compile_fail\n+struct Foo {\n+    a: u32\n+}\n+\n+static S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a;\n+// error: cannot refer to the interior of another static, use a\n+//        constant instead\n+```\n+\n+The \"base\" variable has to be a const if you want another static/const variable\n+to refer to one of its fields. Example:\n+\n+```\n+struct Foo {\n+    a: u32\n+}\n+\n+const S : Foo = Foo { a : 0 };\n+static A : &'static u32 = &S.a; // ok!\n+```\n+\"##,\n+\n+}\n+\n+register_diagnostics! {\n+    E0526, // shuffle indices are not constant\n+}"}, {"sha": "049426db2f4d09f9e50683bdc7402c35836e0e71", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -351,21 +351,39 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n                                     pass_args, lhs.to_ref(), vec![rhs])\n             } else {\n                 // FIXME overflow\n-                match op.node {\n-                    hir::BinOp_::BiAnd => {\n+                match (op.node, cx.constness) {\n+                    // FIXME(eddyb) use logical ops in constants when\n+                    // they can handle that kind of control-flow.\n+                    (hir::BinOp_::BiAnd, hir::Constness::Const) => {\n+                        ExprKind::Binary {\n+                            op: BinOp::BitAnd,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+                    (hir::BinOp_::BiOr, hir::Constness::Const) => {\n+                        ExprKind::Binary {\n+                            op: BinOp::BitOr,\n+                            lhs: lhs.to_ref(),\n+                            rhs: rhs.to_ref(),\n+                        }\n+                    }\n+\n+                    (hir::BinOp_::BiAnd, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::And,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n-                    hir::BinOp_::BiOr => {\n+                    (hir::BinOp_::BiOr, hir::Constness::NotConst) => {\n                         ExprKind::LogicalOp {\n                             op: LogicalOp::Or,\n                             lhs: lhs.to_ref(),\n                             rhs: rhs.to_ref(),\n                         }\n                     }\n+\n                     _ => {\n                         let op = bin_op(op.node);\n                         ExprKind::Binary {"}, {"sha": "5274b5e9abad8a82e52b16354370ca95ec1d7a75", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -32,13 +32,17 @@ use rustc_const_math::{ConstInt, ConstUsize};\n pub struct Cx<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n+    constness: hir::Constness\n }\n \n impl<'a,'tcx> Cx<'a,'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Cx<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>,\n+               constness: hir::Constness)\n+               -> Cx<'a, 'tcx> {\n         Cx {\n             tcx: infcx.tcx,\n             infcx: infcx,\n+            constness: constness,\n         }\n     }\n }"}, {"sha": "79d11e78bde5af65d08b7e4a1382dd665970e2c4", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -20,7 +20,9 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![cfg_attr(not(stage0), deny(warnings))]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n \n+#![feature(associated_consts)]\n #![feature(box_patterns)]\n+#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(question_mark)]\n@@ -31,10 +33,16 @@ extern crate graphviz as dot;\n extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_back;\n+#[macro_use]\n+#[no_link]\n+extern crate rustc_bitflags;\n+#[macro_use]\n extern crate syntax;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n+pub mod diagnostics;\n+\n pub mod build;\n pub mod graphviz;\n mod hair;"}, {"sha": "d771c80438921f7f4d13e4366338f1956082b984", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 118, "deletions": 122, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -16,33 +16,30 @@\n //! - `#[rustc_mir(graphviz=\"file.gv\")]`\n //! - `#[rustc_mir(pretty=\"file.mir\")]`\n \n-extern crate syntax;\n-\n use build;\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n+use rustc::mir::transform::MirSource;\n use pretty;\n use hair::cx::Cx;\n \n use rustc::mir::mir_map::MirMap;\n use rustc::infer;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor};\n-use syntax::abi::Abi;\n+use rustc::hir::intravisit::{self, FnKind, Visitor};\n+use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n-use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n pub fn build_mir_for_crate<'tcx>(tcx: &TyCtxt<'tcx>) -> MirMap<'tcx> {\n     let mut map = MirMap {\n         map: NodeMap(),\n     };\n     {\n-        let mut dump = OuterDump {\n+        let mut dump = BuildMir {\n             tcx: tcx,\n             map: &mut map,\n         };\n@@ -52,161 +49,160 @@ pub fn build_mir_for_crate<'tcx>(tcx: &TyCtxt<'tcx>) -> MirMap<'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// OuterDump -- walks a crate, looking for fn items and methods to build MIR from\n+// BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-struct OuterDump<'a, 'tcx: 'a> {\n+struct BuildMir<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     map: &'a mut MirMap<'tcx>,\n }\n \n-impl<'a, 'tcx> OuterDump<'a, 'tcx> {\n-    fn visit_mir<OP>(&mut self, attributes: &'a [ast::Attribute], mut walk_op: OP)\n-        where OP: for<'m> FnMut(&mut InnerDump<'a, 'm, 'tcx>)\n+impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n+    fn build<F>(&mut self, src: MirSource, f: F)\n+        where F: for<'b> FnOnce(Cx<'b, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n-        let mut closure_dump = InnerDump {\n-            tcx: self.tcx,\n-            attr: None,\n-            map: &mut *self.map,\n-        };\n-        for attr in attributes {\n-            if attr.check_name(\"rustc_mir\") {\n-                closure_dump.attr = Some(attr);\n+        let constness = match src {\n+            MirSource::Const(_) |\n+            MirSource::Static(..) => hir::Constness::Const,\n+            MirSource::Fn(id) => {\n+                let fn_like = FnLikeNode::from_node(self.tcx.map.get(id));\n+                match fn_like.map(|f| f.kind()) {\n+                    Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n+                    Some(FnKind::Method(_, m, _, _)) => m.constness,\n+                    _ => hir::Constness::NotConst\n+                }\n             }\n+            MirSource::Promoted(..) => bug!()\n+        };\n+\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n+\n+        let (mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n+\n+        pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n+\n+        assert!(self.map.map.insert(src.item_id(), mir).is_none())\n+    }\n+\n+    fn build_const_integer(&mut self, expr: &'tcx hir::Expr) {\n+        // FIXME(eddyb) Closures should have separate\n+        // function definition IDs and expression IDs.\n+        // Type-checking should not let closures get\n+        // this far in an integer constant position.\n+        if let hir::ExprClosure(..) = expr.node {\n+            return;\n         }\n-        walk_op(&mut closure_dump);\n+        self.build(MirSource::Const(expr.id), |cx| {\n+            build::construct_const(cx, expr.id, expr)\n+        });\n     }\n }\n \n-\n-impl<'a, 'tcx> Visitor<'tcx> for OuterDump<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n+    // Const and static items.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        self.visit_mir(&item.attrs, |c| intravisit::walk_item(c, item));\n+        match item.node {\n+            hir::ItemConst(_, ref expr) => {\n+                self.build(MirSource::Const(item.id), |cx| {\n+                    build::construct_const(cx, item.id, expr)\n+                });\n+            }\n+            hir::ItemStatic(_, m, ref expr) => {\n+                self.build(MirSource::Static(item.id, m), |cx| {\n+                    build::construct_const(cx, item.id, expr)\n+                });\n+            }\n+            _ => {}\n+        }\n         intravisit::walk_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        match trait_item.node {\n-            hir::MethodTraitItem(_, Some(_)) => {\n-                self.visit_mir(&trait_item.attrs, |c| intravisit::walk_trait_item(c, trait_item));\n-            }\n-            hir::MethodTraitItem(_, None) |\n-            hir::ConstTraitItem(..) |\n-            hir::TypeTraitItem(..) => {}\n+    // Trait associated const defaults.\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n+        if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n+            self.build(MirSource::Const(item.id), |cx| {\n+                build::construct_const(cx, item.id, expr)\n+            });\n         }\n-        intravisit::walk_trait_item(self, trait_item);\n+        intravisit::walk_trait_item(self, item);\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        match impl_item.node {\n-            hir::ImplItemKind::Method(..) => {\n-                self.visit_mir(&impl_item.attrs, |c| intravisit::walk_impl_item(c, impl_item));\n-            }\n-            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(..) => {}\n+    // Impl associated const.\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n+        if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n+            self.build(MirSource::Const(item.id), |cx| {\n+                build::construct_const(cx, item.id, expr)\n+            });\n         }\n-        intravisit::walk_impl_item(self, impl_item);\n+        intravisit::walk_impl_item(self, item);\n     }\n-}\n \n-///////////////////////////////////////////////////////////////////////////\n-// InnerDump -- dumps MIR for a single fn and its contained closures\n-\n-struct InnerDump<'a, 'm, 'tcx: 'a + 'm> {\n-    tcx: &'a TyCtxt<'tcx>,\n-    map: &'m mut MirMap<'tcx>,\n-    attr: Option<&'a ast::Attribute>,\n-}\n+    // Repeat counts, i.e. [expr; constant].\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        if let hir::ExprRepeat(_, ref count) = expr.node {\n+            self.build_const_integer(count);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n \n-impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n-    fn visit_trait_item(&mut self, _: &'tcx hir::TraitItem) {\n-        // ignore methods; the outer dump will call us for them independently\n+    // Array lengths, i.e. [T; constant].\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n+            self.build_const_integer(length);\n+        }\n+        intravisit::walk_ty(self, ty);\n     }\n \n-    fn visit_impl_item(&mut self, _: &'tcx hir::ImplItem) {\n-        // ignore methods; the outer dump will call us for them independently\n+    // Enum variant discriminant values.\n+    fn visit_variant(&mut self, v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics, item_id: ast::NodeId) {\n+        if let Some(ref expr) = v.node.disr_expr {\n+            self.build_const_integer(expr);\n+        }\n+        intravisit::walk_variant(self, v, g, item_id);\n     }\n \n     fn visit_fn(&mut self,\n-                fk: intravisit::FnKind<'tcx>,\n+                fk: FnKind<'tcx>,\n                 decl: &'tcx hir::FnDecl,\n                 body: &'tcx hir::Block,\n                 span: Span,\n                 id: ast::NodeId) {\n-        let implicit_arg_tys = if let intravisit::FnKind::Closure(..) = fk {\n-            vec![closure_self_ty(&self.tcx, id, body.id)]\n+        // fetch the fully liberated fn signature (that is, all bound\n+        // types/lifetimes replaced)\n+        let fn_sig = match self.tcx.tables.borrow().liberated_fn_sigs.get(&id) {\n+            Some(f) => f.clone(),\n+            None => {\n+                span_bug!(span, \"no liberated fn sig for {:?}\", id);\n+            }\n+        };\n+\n+        let implicit_argument = if let FnKind::Closure(..) = fk {\n+            Some((closure_self_ty(&self.tcx, id, body.id), None))\n         } else {\n-            vec![]\n+            None\n         };\n \n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        let infcx = infer::new_infer_ctxt(self.tcx,\n-                                          &self.tcx.tables,\n-                                          Some(param_env),\n-                                          ProjectionMode::AnyFinal);\n+        let explicit_arguments =\n+            decl.inputs\n+                .iter()\n+                .enumerate()\n+                .map(|(index, arg)| {\n+                    (fn_sig.inputs[index], Some(&*arg.pat))\n+                });\n \n-        match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n-            Ok(mir) => assert!(self.map.map.insert(id, mir).is_none()),\n-            Err(ErrorReported) => {}\n-        }\n+        self.build(MirSource::Fn(id), |cx| {\n+            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+            build::construct_fn(cx, id, arguments, fn_sig.output, body)\n+        });\n \n         intravisit::walk_fn(self, fk, decl, body, span);\n     }\n }\n \n-fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n-                         implicit_arg_tys: Vec<Ty<'tcx>>,\n-                         fn_id: ast::NodeId,\n-                         span: Span,\n-                         decl: &'tcx hir::FnDecl,\n-                         body: &'tcx hir::Block)\n-                         -> Result<Mir<'tcx>, ErrorReported> {\n-    // fetch the fully liberated fn signature (that is, all bound\n-    // types/lifetimes replaced)\n-    let fn_sig = match cx.tcx().tables.borrow().liberated_fn_sigs.get(&fn_id) {\n-        Some(f) => f.clone(),\n-        None => {\n-            span_bug!(span, \"no liberated fn sig for {:?}\", fn_id);\n-        }\n-    };\n-\n-    let arguments =\n-        decl.inputs\n-            .iter()\n-            .enumerate()\n-            .map(|(index, arg)| {\n-                (fn_sig.inputs[index], &*arg.pat)\n-            })\n-            .collect();\n-\n-    let (mut mir, scope_auxiliary) =\n-        build::construct(cx,\n-                         span,\n-                         fn_id,\n-                         body.id,\n-                         implicit_arg_tys,\n-                         arguments,\n-                         fn_sig.output,\n-                         body);\n-\n-    match cx.tcx().node_id_to_type(fn_id).sty {\n-        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n-            // RustCall pseudo-ABI untuples the last argument.\n-            if let Some(arg_decl) = mir.arg_decls.last_mut() {\n-                arg_decl.spread = true;\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    pretty::dump_mir(cx.tcx(),\n-                     \"mir_map\",\n-                     &0,\n-                     fn_id,\n-                     &mir,\n-                     Some(&scope_auxiliary));\n-\n-    Ok(mir)\n-}\n-\n fn closure_self_ty<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)"}, {"sha": "0e082ac262ec1ff51e01dc44c666bb1ed3c77316", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use build::{Location, ScopeAuxiliaryVec};\n+use rustc::hir;\n use rustc::mir::repr::*;\n+use rustc::mir::transform::MirSource;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Display;\n@@ -37,13 +39,14 @@ const INDENT: &'static str = \"    \";\n pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n-                          node_id: NodeId,\n+                          src: MirSource,\n                           mir: &Mir<'tcx>,\n                           auxiliary: Option<&ScopeAuxiliaryVec>) {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return,\n         Some(ref filters) => filters,\n     };\n+    let node_id = src.item_id();\n     let node_path = tcx.item_path_str(tcx.map.local_def_id(node_id));\n     let is_matched =\n         filters.split(\"&\")\n@@ -64,7 +67,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n         try!(writeln!(file, \"// pass_name = {}\", pass_name));\n         try!(writeln!(file, \"// disambiguator = {}\", disambiguator));\n         try!(writeln!(file, \"\"));\n-        try!(write_mir_fn(tcx, node_id, mir, &mut file, auxiliary));\n+        try!(write_mir_fn(tcx, src, mir, &mut file, auxiliary));\n         Ok(())\n     });\n }\n@@ -76,8 +79,13 @@ pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &TyCtxt<'tcx>,\n                                      -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n-    for (&node_id, mir) in iter {\n-        write_mir_fn(tcx, node_id, mir, w, None)?;\n+    for (&id, mir) in iter {\n+        let src = MirSource::from_node(tcx, id);\n+        write_mir_fn(tcx, src, mir, w, None)?;\n+\n+        for (i, mir) in mir.promoted.iter().enumerate() {\n+            write_mir_fn(tcx, MirSource::Promoted(id, i), mir, w, None)?;\n+        }\n     }\n     Ok(())\n }\n@@ -88,7 +96,7 @@ enum Annotation {\n }\n \n pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          node_id: NodeId,\n+                          src: MirSource,\n                           mir: &Mir<'tcx>,\n                           w: &mut Write,\n                           auxiliary: Option<&ScopeAuxiliaryVec>)\n@@ -111,7 +119,7 @@ pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    write_mir_intro(tcx, node_id, mir, w)?;\n+    write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.all_basic_blocks() {\n         write_basic_block(tcx, block, mir, w, &annotations)?;\n     }\n@@ -214,24 +222,39 @@ fn write_scope_tree(tcx: &TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro(tcx: &TyCtxt, nid: NodeId, mir: &Mir, w: &mut Write)\n+fn write_mir_intro(tcx: &TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n                    -> io::Result<()> {\n-    write!(w, \"fn {}(\", tcx.node_path_str(nid))?;\n+    match src {\n+        MirSource::Fn(_) => write!(w, \"fn\")?,\n+        MirSource::Const(_) => write!(w, \"const\")?,\n+        MirSource::Static(_, hir::MutImmutable) => write!(w, \"static\")?,\n+        MirSource::Static(_, hir::MutMutable) => write!(w, \"static mut\")?,\n+        MirSource::Promoted(_, i) => write!(w, \"promoted{} in\", i)?\n+    }\n+\n+    write!(w, \" {}\", tcx.node_path_str(src.item_id()))?;\n \n-    // fn argument types.\n-    for (i, arg) in mir.arg_decls.iter().enumerate() {\n-        if i > 0 {\n-            write!(w, \", \")?;\n+    if let MirSource::Fn(_) = src {\n+        write!(w, \"(\")?;\n+\n+        // fn argument types.\n+        for (i, arg) in mir.arg_decls.iter().enumerate() {\n+            if i > 0 {\n+                write!(w, \", \")?;\n+            }\n+            write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n         }\n-        write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty)?;\n-    }\n \n-    write!(w, \") -> \")?;\n+        write!(w, \") -> \")?;\n \n-    // fn return type.\n-    match mir.return_ty {\n-        ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty)?,\n-        ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n+        // fn return type.\n+        match mir.return_ty {\n+            ty::FnOutput::FnConverging(ty) => write!(w, \"{}\", ty)?,\n+            ty::FnOutput::FnDiverging => write!(w, \"!\")?,\n+        }\n+    } else {\n+        assert!(mir.arg_decls.is_empty());\n+        write!(w, \": {} =\", mir.return_ty.unwrap())?;\n     }\n \n     writeln!(w, \" {{\")?;"}, {"sha": "ee7c9015baad666e4e74aaf40b8ea5fc98909321", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -10,8 +10,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{MirPass, Pass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n use rustc_data_structures::bitvec::BitVector;\n \n@@ -43,7 +42,7 @@ pub struct BreakCriticalEdges;\n  */\n \n impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         break_critical_edges(mir);\n     }\n }"}, {"sha": "678d2c4614d276d166f4c0da75aae23078806fc7", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -16,8 +16,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{MirPass, Pass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -47,7 +46,7 @@ pub struct EraseRegions;\n impl Pass for EraseRegions {}\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "51f5c3cd7f53d9c7000c717a1ec4f0d3b0a2ec66", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -14,3 +14,5 @@ pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n pub mod break_critical_edges;\n+pub mod promote_consts;\n+pub mod qualify_consts;"}, {"sha": "9c9f95e2e630ec285a9590efa66c19afe99a0faa", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -14,8 +14,7 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::visit::MutVisitor;\n-use rustc::mir::transform::{Pass, MirPass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n \n pub struct NoLandingPads;\n \n@@ -42,7 +41,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }"}, {"sha": "c5ebe708eb45694ea6d062780134751b3c11d3af", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -0,0 +1,412 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that promotes borrows of constant rvalues.\n+//!\n+//! The rvalues considered constant are trees of temps,\n+//! each with exactly one initialization, and holding\n+//! a constant value with no interior mutability.\n+//! They are placed into a new MIR constant body in\n+//! `promoted` and the borrow rvalue is replaced with\n+//! a `Literal::Promoted` using the index into `promoted`\n+//! of that constant MIR.\n+//!\n+//! This pass assumes that every use is dominated by an\n+//! initialization and can otherwise silence errors, if\n+//! move analysis runs after promotion on broken MIR.\n+\n+use rustc::mir::repr::*;\n+use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc::ty::{self, TyCtxt};\n+use syntax::codemap::Span;\n+\n+use build::Location;\n+use traversal::ReversePostorder;\n+\n+use std::mem;\n+\n+/// State of a temporary during collection and promotion.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TempState {\n+    /// No references to this temp.\n+    Undefined,\n+    /// One direct assignment and any number of direct uses.\n+    /// A borrow of this temp is promotable if the assigned\n+    /// value is qualified as constant.\n+    Defined {\n+        location: Location,\n+        uses: usize\n+    },\n+    /// Any other combination of assignments/uses.\n+    Unpromotable,\n+    /// This temp was part of an rvalue which got extracted\n+    /// during promotion and needs cleanup.\n+    PromotedOut\n+}\n+\n+impl TempState {\n+    pub fn is_promotable(&self) -> bool {\n+        if let TempState::Defined { uses, .. } = *self {\n+            uses > 0\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// A \"root candidate\" for promotion, which will become the\n+/// returned value in a promoted MIR, unless it's a subset\n+/// of a larger candidate.\n+pub enum Candidate {\n+    /// Borrow of a constant temporary.\n+    Ref(Location),\n+\n+    /// Array of indices found in the third argument of\n+    /// a call to one of the simd_shuffleN intrinsics.\n+    ShuffleIndices(BasicBlock)\n+}\n+\n+struct TempCollector {\n+    temps: Vec<TempState>,\n+    location: Location,\n+    span: Span\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TempCollector {\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+        if let Lvalue::Temp(index) = *lvalue {\n+            // Ignore drops, if the temp gets promoted,\n+            // then it's constant and thus drop is noop.\n+            if let LvalueContext::Drop = context {\n+                return;\n+            }\n+\n+            let temp = &mut self.temps[index as usize];\n+            if *temp == TempState::Undefined {\n+                match context {\n+                    LvalueContext::Store |\n+                    LvalueContext::Call => {\n+                        *temp = TempState::Defined {\n+                            location: self.location,\n+                            uses: 0\n+                        };\n+                        return;\n+                    }\n+                    _ => { /* mark as unpromotable below */ }\n+                }\n+            } else if let TempState::Defined { ref mut uses, .. } = *temp {\n+                match context {\n+                    LvalueContext::Borrow {..} |\n+                    LvalueContext::Consume |\n+                    LvalueContext::Inspect => {\n+                        *uses += 1;\n+                        return;\n+                    }\n+                    _ => { /* mark as unpromotable below */ }\n+                }\n+            }\n+            *temp = TempState::Unpromotable;\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n+        assert_eq!(self.location.block, bb);\n+        self.span = statement.span;\n+        self.super_statement(bb, statement);\n+        self.location.statement_index += 1;\n+    }\n+\n+    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n+        self.span = terminator.span;\n+        self.super_terminator(bb, terminator);\n+    }\n+\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.location.statement_index = 0;\n+        self.location.block = bb;\n+        self.super_basic_block_data(bb, data);\n+    }\n+}\n+\n+pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> Vec<TempState> {\n+    let mut collector = TempCollector {\n+        temps: vec![TempState::Undefined; mir.temp_decls.len()],\n+        location: Location {\n+            block: START_BLOCK,\n+            statement_index: 0\n+        },\n+        span: mir.span\n+    };\n+    for (bb, data) in rpo {\n+        collector.visit_basic_block_data(bb, data);\n+    }\n+    collector.temps\n+}\n+\n+struct Promoter<'a, 'tcx: 'a> {\n+    source: &'a mut Mir<'tcx>,\n+    promoted: Mir<'tcx>,\n+    temps: &'a mut Vec<TempState>,\n+\n+    /// If true, all nested temps are also kept in the\n+    /// source MIR, not moved to the promoted MIR.\n+    keep_original: bool\n+}\n+\n+impl<'a, 'tcx> Promoter<'a, 'tcx> {\n+    fn new_block(&mut self) -> BasicBlock {\n+        let index = self.promoted.basic_blocks.len();\n+        self.promoted.basic_blocks.push(BasicBlockData {\n+            statements: vec![],\n+            terminator: Some(Terminator {\n+                span: self.promoted.span,\n+                scope: ScopeId::new(0),\n+                kind: TerminatorKind::Return\n+            }),\n+            is_cleanup: false\n+        });\n+        BasicBlock::new(index)\n+    }\n+\n+    fn assign(&mut self, dest: Lvalue<'tcx>, rvalue: Rvalue<'tcx>, span: Span) {\n+        let data = self.promoted.basic_blocks.last_mut().unwrap();\n+        data.statements.push(Statement {\n+            span: span,\n+            scope: ScopeId::new(0),\n+            kind: StatementKind::Assign(dest, rvalue)\n+        });\n+    }\n+\n+    /// Copy the initialization of this temp to the\n+    /// promoted MIR, recursing through temps.\n+    fn promote_temp(&mut self, index: u32) -> u32 {\n+        let index = index as usize;\n+        let old_keep_original = self.keep_original;\n+        let (bb, stmt_idx) = match self.temps[index] {\n+            TempState::Defined {\n+                location: Location { block, statement_index },\n+                uses\n+            } if uses > 0 => {\n+                if uses > 1 {\n+                    self.keep_original = true;\n+                }\n+                (block, statement_index)\n+            }\n+            temp =>  {\n+                span_bug!(self.promoted.span, \"tmp{} not promotable: {:?}\",\n+                          index, temp);\n+            }\n+        };\n+        if !self.keep_original {\n+            self.temps[index] = TempState::PromotedOut;\n+        }\n+\n+        let no_stmts = self.source[bb].statements.len();\n+\n+        // First, take the Rvalue or Call out of the source MIR,\n+        // or duplicate it, depending on keep_original.\n+        let (mut rvalue, mut call) = (None, None);\n+        let span = if stmt_idx < no_stmts {\n+            let statement = &mut self.source[bb].statements[stmt_idx];\n+            let StatementKind::Assign(_, ref mut rhs) = statement.kind;\n+            if self.keep_original {\n+                rvalue = Some(rhs.clone());\n+            } else {\n+                let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n+                rvalue = Some(mem::replace(rhs, unit));\n+            }\n+            statement.span\n+        } else if self.keep_original {\n+            let terminator = self.source[bb].terminator().clone();\n+            call = Some(terminator.kind);\n+            terminator.span\n+        } else {\n+            let terminator = self.source[bb].terminator_mut();\n+            let target = match terminator.kind {\n+                TerminatorKind::Call {\n+                    destination: ref mut dest @ Some(_),\n+                    ref mut cleanup, ..\n+                } => {\n+                    // No cleanup necessary.\n+                    cleanup.take();\n+\n+                    // We'll put a new destination in later.\n+                    dest.take().unwrap().1\n+                }\n+                ref kind => {\n+                    span_bug!(terminator.span, \"{:?} not promotable\", kind);\n+                }\n+            };\n+            call = Some(mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n+                target: target\n+            }));\n+            terminator.span\n+        };\n+\n+        // Then, recurse for components in the Rvalue or Call.\n+        if stmt_idx < no_stmts {\n+            self.visit_rvalue(rvalue.as_mut().unwrap());\n+        } else {\n+            self.visit_terminator_kind(bb, call.as_mut().unwrap());\n+        }\n+\n+        let new_index = self.promoted.temp_decls.len() as u32;\n+        let new_temp = Lvalue::Temp(new_index);\n+        self.promoted.temp_decls.push(TempDecl {\n+            ty: self.source.temp_decls[index].ty\n+        });\n+\n+        // Inject the Rvalue or Call into the promoted MIR.\n+        if stmt_idx < no_stmts {\n+            self.assign(new_temp, rvalue.unwrap(), span);\n+        } else {\n+            let last = self.promoted.basic_blocks.len() - 1;\n+            let new_target = self.new_block();\n+            let mut call = call.unwrap();\n+            match call {\n+                TerminatorKind::Call { ref mut destination, ..}  => {\n+                    *destination = Some((new_temp, new_target));\n+                }\n+                _ => bug!()\n+            }\n+            let terminator = &mut self.promoted.basic_blocks[last].terminator_mut();\n+            terminator.span = span;\n+            terminator.kind = call;\n+        }\n+\n+        // Restore the old duplication state.\n+        self.keep_original = old_keep_original;\n+\n+        new_index\n+    }\n+\n+    fn promote_candidate(mut self, candidate: Candidate) {\n+        let span = self.promoted.span;\n+        let new_operand = Operand::Constant(Constant {\n+            span: span,\n+            ty: self.promoted.return_ty.unwrap(),\n+            literal: Literal::Promoted {\n+                index: self.source.promoted.len()\n+            }\n+        });\n+        let mut rvalue = match candidate {\n+            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n+                match self.source[bb].statements[stmt_idx].kind {\n+                    StatementKind::Assign(_, ref mut rvalue) => {\n+                        mem::replace(rvalue, Rvalue::Use(new_operand))\n+                    }\n+                }\n+            }\n+            Candidate::ShuffleIndices(bb) => {\n+                match self.source[bb].terminator_mut().kind {\n+                    TerminatorKind::Call { ref mut args, .. } => {\n+                        Rvalue::Use(mem::replace(&mut args[2], new_operand))\n+                    }\n+                    _ => bug!()\n+                }\n+            }\n+        };\n+        self.visit_rvalue(&mut rvalue);\n+        self.assign(Lvalue::ReturnPointer, rvalue, span);\n+        self.source.promoted.push(self.promoted);\n+    }\n+}\n+\n+/// Replaces all temporaries with their promoted counterparts.\n+impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n+    fn visit_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>, context: LvalueContext) {\n+        if let Lvalue::Temp(ref mut index) = *lvalue {\n+            *index = self.promote_temp(*index);\n+        }\n+        self.super_lvalue(lvalue, context);\n+    }\n+}\n+\n+pub fn promote_candidates<'tcx>(mir: &mut Mir<'tcx>,\n+                                tcx: &TyCtxt<'tcx>,\n+                                mut temps: Vec<TempState>,\n+                                candidates: Vec<Candidate>) {\n+    // Visit candidates in reverse, in case they're nested.\n+    for candidate in candidates.into_iter().rev() {\n+        let (span, ty) = match candidate {\n+            Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n+                let statement = &mir[bb].statements[stmt_idx];\n+                let StatementKind::Assign(ref dest, _) = statement.kind;\n+                if let Lvalue::Temp(index) = *dest {\n+                    if temps[index as usize] == TempState::PromotedOut {\n+                        // Already promoted.\n+                        continue;\n+                    }\n+                }\n+                (statement.span, mir.lvalue_ty(tcx, dest).to_ty(tcx))\n+            }\n+            Candidate::ShuffleIndices(bb) => {\n+                let terminator = mir[bb].terminator();\n+                let ty = match terminator.kind {\n+                    TerminatorKind::Call { ref args, .. } => {\n+                        mir.operand_ty(tcx, &args[2])\n+                    }\n+                    _ => {\n+                        span_bug!(terminator.span,\n+                                  \"expected simd_shuffleN call to promote\");\n+                    }\n+                };\n+                (terminator.span, ty)\n+            }\n+        };\n+\n+        let mut promoter = Promoter {\n+            source: mir,\n+            promoted: Mir {\n+                basic_blocks: vec![],\n+                scopes: vec![ScopeData {\n+                    span: span,\n+                    parent_scope: None\n+                }],\n+                promoted: vec![],\n+                return_ty: ty::FnConverging(ty),\n+                var_decls: vec![],\n+                arg_decls: vec![],\n+                temp_decls: vec![],\n+                upvar_decls: vec![],\n+                span: span\n+            },\n+            temps: &mut temps,\n+            keep_original: false\n+        };\n+        assert_eq!(promoter.new_block(), START_BLOCK);\n+        promoter.promote_candidate(candidate);\n+    }\n+\n+    // Eliminate assignments to, and drops of promoted temps.\n+    let promoted = |index: u32| temps[index as usize] == TempState::PromotedOut;\n+    for block in &mut mir.basic_blocks {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::Assign(Lvalue::Temp(index), _) => {\n+                    !promoted(index)\n+                }\n+                _ => true\n+            }\n+        });\n+        let terminator = block.terminator_mut();\n+        match terminator.kind {\n+            TerminatorKind::Drop { value: Lvalue::Temp(index), target, .. } => {\n+                if promoted(index) {\n+                    terminator.kind = TerminatorKind::Goto {\n+                        target: target\n+                    };\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "90823528973b9ff8fd88a0bed67e3088672d8019", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "added", "additions": 1037, "deletions": 0, "changes": 1037, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -0,0 +1,1037 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A pass that qualifies constness of temporaries in constants,\n+//! static initializers and functions and also drives promotion.\n+//!\n+//! The Qualif flags below can be used to also provide better\n+//! diagnostics as to why a constant rvalue wasn't promoted.\n+\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::intravisit::FnKind;\n+use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::infer;\n+use rustc::traits::{self, ProjectionMode};\n+use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::cast::CastTy;\n+use rustc::mir::repr::*;\n+use rustc::mir::mir_map::MirMap;\n+use rustc::mir::transform::{Pass, MirMapPass, MirSource};\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+use rustc::util::nodemap::DefIdMap;\n+use syntax::abi::Abi;\n+use syntax::codemap::Span;\n+use syntax::feature_gate::UnstableFeatures;\n+\n+use std::collections::hash_map::Entry;\n+use std::fmt;\n+\n+use build::Location;\n+use traversal::{self, ReversePostorder};\n+\n+use super::promote_consts::{self, Candidate, TempState};\n+\n+bitflags! {\n+    flags Qualif: u8 {\n+        // Const item's qualification while recursing.\n+        // Recursive consts are an error.\n+        const RECURSIVE         = 1 << 0,\n+\n+        // Constant containing interior mutability (UnsafeCell).\n+        const MUTABLE_INTERIOR  = 1 << 1,\n+\n+        // Constant containing an ADT that implements Drop.\n+        const NEEDS_DROP        = 1 << 2,\n+\n+        // Function argument.\n+        const FN_ARGUMENT       = 1 << 3,\n+\n+        // Static lvalue or move from a static.\n+        const STATIC            = 1 << 4,\n+\n+        // Reference to a static.\n+        const STATIC_REF        = 1 << 5,\n+\n+        // Not constant at all - non-`const fn` calls, asm!,\n+        // pointer comparisons, ptr-to-int casts, etc.\n+        const NOT_CONST         = 1 << 6,\n+\n+        // Borrows of temporaries can be promoted only\n+        // if they have none of the above qualifications.\n+        const UNPROMOTABLE      = !0,\n+\n+        // Const items can only have MUTABLE_INTERIOR\n+        // without producing an error.\n+        const CONST_ERROR       = !Qualif::MUTABLE_INTERIOR.bits\n+    }\n+}\n+\n+impl Qualif {\n+    /// Remove flags which are impossible for the given type.\n+    fn restrict<'a, 'tcx>(&mut self, ty: Ty<'tcx>,\n+                          param_env: &ty::ParameterEnvironment<'a, 'tcx>) {\n+        if !ty.type_contents(param_env.tcx).interior_unsafe() {\n+            *self = *self - Qualif::MUTABLE_INTERIOR;\n+        }\n+        if !param_env.tcx.type_needs_drop_given_env(ty, param_env) {\n+            *self = *self - Qualif::NEEDS_DROP;\n+        }\n+    }\n+}\n+\n+/// What kind of item we are in.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum Mode {\n+    Const,\n+    Static,\n+    StaticMut,\n+    ConstFn,\n+    Fn\n+}\n+\n+impl fmt::Display for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Mode::Const => write!(f, \"constant\"),\n+            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n+            Mode::ConstFn => write!(f, \"constant function\"),\n+            Mode::Fn => write!(f, \"function\")\n+        }\n+    }\n+}\n+\n+fn is_const_fn(tcx: &TyCtxt, def_id: DefId) -> bool {\n+    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+        let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n+        match fn_like.map(|f| f.kind()) {\n+            Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => {\n+                c == hir::Constness::Const\n+            }\n+            Some(FnKind::Method(_, m, _, _)) => {\n+                m.constness == hir::Constness::Const\n+            }\n+            _ => false\n+        }\n+    } else {\n+        tcx.sess.cstore.is_const_fn(def_id)\n+    }\n+}\n+\n+struct Qualifier<'a, 'tcx: 'a> {\n+    mode: Mode,\n+    span: Span,\n+    def_id: DefId,\n+    mir: &'a Mir<'tcx>,\n+    rpo: ReversePostorder<'a, 'tcx>,\n+    tcx: &'a TyCtxt<'tcx>,\n+    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+    qualif_map: &'a mut DefIdMap<Qualif>,\n+    mir_map: Option<&'a MirMap<'tcx>>,\n+    temp_qualif: Vec<Option<Qualif>>,\n+    return_qualif: Option<Qualif>,\n+    qualif: Qualif,\n+    const_fn_arg_vars: BitVector,\n+    location: Location,\n+    temp_promotion_state: Vec<TempState>,\n+    promotion_candidates: Vec<Candidate>\n+}\n+\n+impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n+    fn new(param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+           qualif_map: &'a mut DefIdMap<Qualif>,\n+           mir_map: Option<&'a MirMap<'tcx>>,\n+           def_id: DefId,\n+           mir: &'a Mir<'tcx>,\n+           mode: Mode)\n+           -> Qualifier<'a, 'tcx> {\n+        let mut rpo = traversal::reverse_postorder(mir);\n+        let temps = promote_consts::collect_temps(mir, &mut rpo);\n+        rpo.reset();\n+        Qualifier {\n+            mode: mode,\n+            span: mir.span,\n+            def_id: def_id,\n+            mir: mir,\n+            rpo: rpo,\n+            tcx: param_env.tcx,\n+            param_env: param_env,\n+            qualif_map: qualif_map,\n+            mir_map: mir_map,\n+            temp_qualif: vec![None; mir.temp_decls.len()],\n+            return_qualif: None,\n+            qualif: Qualif::empty(),\n+            const_fn_arg_vars: BitVector::new(mir.var_decls.len()),\n+            location: Location {\n+                block: START_BLOCK,\n+                statement_index: 0\n+            },\n+            temp_promotion_state: temps,\n+            promotion_candidates: vec![]\n+        }\n+    }\n+\n+    // FIXME(eddyb) we could split the errors into meaningful\n+    // categories, but enabling full miri would make that\n+    // slightly pointless (even with feature-gating).\n+    fn not_const(&mut self) {\n+        self.add(Qualif::NOT_CONST);\n+        if self.mode != Mode::Fn {\n+            span_err!(self.tcx.sess, self.span, E0019,\n+                      \"{} contains unimplemented expression type\", self.mode);\n+        }\n+    }\n+\n+    /// Error about extra statements in a constant.\n+    fn statement_like(&mut self) {\n+        self.add(Qualif::NOT_CONST);\n+        if self.mode != Mode::Fn {\n+            span_err!(self.tcx.sess, self.span, E0016,\n+                      \"blocks in {}s are limited to items and tail expressions\",\n+                      self.mode);\n+        }\n+    }\n+\n+    /// Add the given qualification to self.qualif.\n+    fn add(&mut self, qualif: Qualif) {\n+        self.qualif = self.qualif | qualif;\n+    }\n+\n+    /// Add the given type's qualification to self.qualif.\n+    fn add_type(&mut self, ty: Ty<'tcx>) {\n+        self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n+        self.qualif.restrict(ty, &self.param_env);\n+    }\n+\n+    /// Within the provided closure, self.qualif will start\n+    /// out empty, and its value after the closure returns will\n+    /// be combined with the value before the call to nest.\n+    fn nest<F: FnOnce(&mut Self)>(&mut self, f: F) {\n+        let original = self.qualif;\n+        self.qualif = Qualif::empty();\n+        f(self);\n+        self.add(original);\n+    }\n+\n+    /// Check for NEEDS_DROP (from an ADT or const fn call) and\n+    /// error, unless we're in a function, or the feature-gate\n+    /// for globals with destructors is enabled.\n+    fn deny_drop(&self) {\n+        if self.mode == Mode::Fn || !self.qualif.intersects(Qualif::NEEDS_DROP) {\n+            return;\n+        }\n+\n+        // Static and const fn's allow destructors, but they're feature-gated.\n+        let msg = if self.mode != Mode::Const {\n+            // Feature-gate for globals with destructors is enabled.\n+            if self.tcx.sess.features.borrow().drop_types_in_const {\n+                return;\n+            }\n+\n+            // This comes from a macro that has #[allow_internal_unstable].\n+            if self.tcx.sess.codemap().span_allows_unstable(self.span) {\n+                return;\n+            }\n+\n+            format!(\"destructors in {}s are an unstable feature\",\n+                    self.mode)\n+        } else {\n+            format!(\"{}s are not allowed to have destructors\",\n+                    self.mode)\n+        };\n+\n+        let mut err =\n+            struct_span_err!(self.tcx.sess, self.span, E0493, \"{}\", msg);\n+        if self.mode != Mode::Const {\n+            help!(&mut err,\n+                  \"in Nightly builds, add `#![feature(drop_types_in_const)]` \\\n+                   to the crate attributes to enable\");\n+        }\n+        err.emit();\n+    }\n+\n+    /// Check if an Lvalue with the current qualifications could\n+    /// be consumed, by either an operand or a Deref projection.\n+    fn try_consume(&mut self) -> bool {\n+        if self.qualif.intersects(Qualif::STATIC) && self.mode != Mode::Fn {\n+            let msg = if self.mode == Mode::Static ||\n+                         self.mode == Mode::StaticMut {\n+                \"cannot refer to other statics by value, use the \\\n+                 address-of operator or a constant instead\"\n+            } else {\n+                \"cannot refer to statics by value, use a constant instead\"\n+            };\n+            span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg);\n+\n+            // Replace STATIC with NOT_CONST to avoid further errors.\n+            self.qualif = self.qualif - Qualif::STATIC;\n+            self.add(Qualif::NOT_CONST);\n+\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    /// Assign the current qualification to the given destination.\n+    fn assign(&mut self, dest: &Lvalue<'tcx>) {\n+        let qualif = self.qualif;\n+        let span = self.span;\n+        let store = |slot: &mut Option<Qualif>| {\n+            if slot.is_some() {\n+                span_bug!(span, \"multiple assignments to {:?}\", dest);\n+            }\n+            *slot = Some(qualif);\n+        };\n+\n+        // Only handle promotable temps in non-const functions.\n+        if self.mode == Mode::Fn {\n+            if let Lvalue::Temp(index) = *dest {\n+                if self.temp_promotion_state[index as usize].is_promotable() {\n+                    store(&mut self.temp_qualif[index as usize]);\n+                }\n+            }\n+            return;\n+        }\n+\n+        match *dest {\n+            Lvalue::Temp(index) => store(&mut self.temp_qualif[index as usize]),\n+            Lvalue::ReturnPointer => store(&mut self.return_qualif),\n+\n+            Lvalue::Projection(box Projection {\n+                base: Lvalue::Temp(index),\n+                elem: ProjectionElem::Deref\n+            }) if self.mir.temp_decls[index as usize].ty.is_unique()\n+               && self.temp_qualif[index as usize].map_or(false, |qualif| {\n+                    qualif.intersects(Qualif::NOT_CONST)\n+               }) => {\n+                // Part of `box expr`, we should've errored\n+                // already for the Box allocation Rvalue.\n+            }\n+\n+            // This must be an explicit assignment.\n+            _ => {\n+                // Catch more errors in the destination.\n+                self.visit_lvalue(dest, LvalueContext::Store);\n+                self.statement_like();\n+            }\n+        }\n+    }\n+\n+    /// Returns true if the block ends in a bounds check branch, i.e.:\n+    /// len = Len(array);\n+    /// cond = Lt(idx, len);\n+    /// if cond {\n+    ///     ...\n+    /// } else {\n+    ///     loc = (...);\n+    ///     loc_ref = &loc;\n+    ///     panic_bounds_check(loc_ref, idx, len);\n+    /// }\n+    fn is_bounds_check(&self, bb: BasicBlock,\n+                       cond_op: &Operand<'tcx>,\n+                       if_else: BasicBlock) -> bool {\n+        use rustc::mir::repr::Lvalue::*;\n+        use rustc::mir::repr::Operand::Consume;\n+        use rustc::mir::repr::Rvalue::*;\n+        use rustc::mir::repr::StatementKind::*;\n+        use rustc::mir::repr::TerminatorKind::*;\n+\n+        let stmts = &self.mir[bb].statements;\n+        let stmts_panic = &self.mir[if_else].statements;\n+        if stmts.len() < 2 || stmts_panic.len() != 2 {\n+            return false;\n+        }\n+\n+        let all = (&stmts[stmts.len() - 2].kind,\n+                   &stmts[stmts.len() - 1].kind,\n+                   cond_op,\n+                   &stmts_panic[0].kind,\n+                   &stmts_panic[1].kind,\n+                   &self.mir[if_else].terminator().kind);\n+        match all {\n+            (&Assign(Temp(len), Len(_)),\n+             &Assign(Temp(cond), BinaryOp(BinOp::Lt, ref idx, Consume(Temp(len2)))),\n+             /* if */ &Consume(Temp(cond2)), /* {...} else */\n+             &Assign(Temp(loc), Aggregate(..)),\n+             &Assign(Temp(loc_ref), Ref(_, _, Temp(loc2))),\n+             &Call {\n+                func: Operand::Constant(Constant {\n+                    literal: Literal::Item { def_id, .. }, ..\n+                }),\n+                ref args,\n+                destination: None,\n+                ..\n+            }) => {\n+                len == len2 && cond == cond2 && loc == loc2 &&\n+                args[0] == Consume(Temp(loc_ref)) &&\n+                args[1] == *idx &&\n+                args[2] == Consume(Temp(len)) &&\n+                Some(def_id) == self.tcx.lang_items.panic_bounds_check_fn()\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    /// Qualify a whole const, static initializer or const fn.\n+    fn qualify_const(&mut self) -> Qualif {\n+        let mir = self.mir;\n+\n+        let mut seen_blocks = BitVector::new(mir.basic_blocks.len());\n+        let mut bb = START_BLOCK;\n+        loop {\n+            seen_blocks.insert(bb.index());\n+\n+            self.visit_basic_block_data(bb, &mir[bb]);\n+\n+            let target = match mir[bb].terminator().kind {\n+                TerminatorKind::Goto { target } |\n+                // Drops are considered noops.\n+                TerminatorKind::Drop { target, .. } |\n+                TerminatorKind::Call { destination: Some((_, target)), .. } => {\n+                    Some(target)\n+                }\n+\n+                // Non-terminating calls cannot produce any value.\n+                TerminatorKind::Call { destination: None, .. } => {\n+                    return Qualif::empty();\n+                }\n+\n+                // Need to allow bounds checking branches.\n+                TerminatorKind::If { ref cond, targets: (if_true, if_else) } => {\n+                    if self.is_bounds_check(bb, cond, if_else) {\n+                        Some(if_true)\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                TerminatorKind::Switch {..} |\n+                TerminatorKind::SwitchInt {..} |\n+                TerminatorKind::Resume => None,\n+\n+                TerminatorKind::Return => {\n+                    // Check for unused values. This usually means\n+                    // there are extra statements in the AST.\n+                    for i in 0..mir.temp_decls.len() {\n+                        if self.temp_qualif[i].is_none() {\n+                            continue;\n+                        }\n+\n+                        let state = self.temp_promotion_state[i];\n+                        if let TempState::Defined { location, uses: 0 } = state {\n+                            let data = &mir[location.block];\n+                            let stmt_idx = location.statement_index;\n+\n+                            // Get the span for the initialization.\n+                            if stmt_idx < data.statements.len() {\n+                                self.span = data.statements[stmt_idx].span;\n+                            } else {\n+                                self.span = data.terminator().span;\n+                            }\n+\n+                            // Treat this as a statement in the AST.\n+                            self.statement_like();\n+                        }\n+                    }\n+\n+                    // Make sure there are no extra unassigned variables.\n+                    self.qualif = Qualif::NOT_CONST;\n+                    for index in 0..mir.var_decls.len() {\n+                        if !self.const_fn_arg_vars.contains(index) {\n+                            self.assign(&Lvalue::Var(index as u32));\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            };\n+\n+            match target {\n+                // No loops allowed.\n+                Some(target) if !seen_blocks.contains(target.index()) => {\n+                    bb = target;\n+                }\n+                _ => {\n+                    self.not_const();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let return_ty = mir.return_ty.unwrap();\n+        self.qualif = self.return_qualif.unwrap_or(Qualif::NOT_CONST);\n+\n+        match self.mode {\n+            Mode::StaticMut => {\n+                // Check for destructors in static mut.\n+                self.add_type(return_ty);\n+                self.deny_drop();\n+            }\n+            _ => {\n+                // Account for errors in consts by using the\n+                // conservative type qualification instead.\n+                if self.qualif.intersects(Qualif::CONST_ERROR) {\n+                    self.qualif = Qualif::empty();\n+                    self.add_type(return_ty);\n+                }\n+            }\n+        }\n+        self.qualif\n+    }\n+}\n+\n+/// Accumulates an Rvalue or Call's effects in self.qualif.\n+/// For functions (constant or not), it also records\n+/// candidates for promotion in promotion_candidates.\n+impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n+        match *lvalue {\n+            Lvalue::Arg(_) => {\n+                self.add(Qualif::FN_ARGUMENT);\n+            }\n+            Lvalue::Var(_) => {\n+                self.add(Qualif::NOT_CONST);\n+            }\n+            Lvalue::Temp(index) => {\n+                if let Some(qualif) = self.temp_qualif[index as usize] {\n+                    self.add(qualif);\n+                } else {\n+                    self.not_const();\n+                }\n+            }\n+            Lvalue::Static(_) => {\n+                self.add(Qualif::STATIC);\n+                if self.mode == Mode::Const || self.mode == Mode::ConstFn {\n+                    span_err!(self.tcx.sess, self.span, E0013,\n+                              \"{}s cannot refer to statics, use \\\n+                               a constant instead\", self.mode);\n+                }\n+            }\n+            Lvalue::ReturnPointer => {\n+                self.not_const();\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                self.nest(|this| {\n+                    this.super_lvalue(lvalue, context);\n+                    match proj.elem {\n+                        ProjectionElem::Deref => {\n+                            if !this.try_consume() {\n+                                return;\n+                            }\n+\n+                            if this.qualif.intersects(Qualif::STATIC_REF) {\n+                                this.qualif = this.qualif - Qualif::STATIC_REF;\n+                                this.add(Qualif::STATIC);\n+                            }\n+\n+                            let base_ty = this.mir.lvalue_ty(this.tcx, &proj.base)\n+                                              .to_ty(this.tcx);\n+                            if let ty::TyRawPtr(_) = base_ty.sty {\n+                                this.add(Qualif::NOT_CONST);\n+                                if this.mode != Mode::Fn {\n+                                    span_err!(this.tcx.sess, this.span, E0396,\n+                                              \"raw pointers cannot be dereferenced in {}s\",\n+                                              this.mode);\n+                                }\n+                            }\n+                        }\n+\n+                        ProjectionElem::Field(..) |\n+                        ProjectionElem::Index(_) => {\n+                            if this.mode != Mode::Fn &&\n+                               this.qualif.intersects(Qualif::STATIC) {\n+                                span_err!(this.tcx.sess, this.span, E0494,\n+                                          \"cannot refer to the interior of another \\\n+                                           static, use a constant instead\");\n+                            }\n+                            let ty = this.mir.lvalue_ty(this.tcx, lvalue)\n+                                         .to_ty(this.tcx);\n+                            this.qualif.restrict(ty, &this.param_env);\n+                        }\n+\n+                        ProjectionElem::ConstantIndex {..} |\n+                        ProjectionElem::Downcast(..) => {\n+                            this.not_const()\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>) {\n+        match *operand {\n+            Operand::Consume(_) => {\n+                self.nest(|this| {\n+                    this.super_operand(operand);\n+                    this.try_consume();\n+                });\n+            }\n+            Operand::Constant(ref constant) => {\n+                // Only functions and methods can have these types.\n+                if let ty::TyFnDef(..) = constant.ty.sty {\n+                    return;\n+                }\n+\n+                if let Literal::Item { def_id, substs } = constant.literal {\n+                    // Don't peek inside generic (associated) constants.\n+                    if !substs.types.is_empty() {\n+                        self.add_type(constant.ty);\n+                    } else {\n+                        let qualif = qualify_const_item_cached(self.tcx,\n+                                                               self.qualif_map,\n+                                                               self.mir_map,\n+                                                               def_id);\n+                        self.add(qualif);\n+                    }\n+\n+                    // FIXME(eddyb) check recursive constants here,\n+                    // instead of rustc_passes::static_recursion.\n+                    if self.qualif.intersects(Qualif::RECURSIVE) {\n+                        span_bug!(constant.span,\n+                                  \"recursive constant wasn't caught earlier\");\n+                    }\n+\n+                    // Let `const fn` transitively have destructors,\n+                    // but they do get stopped in `const` or `static`.\n+                    if self.mode != Mode::ConstFn {\n+                        self.deny_drop();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+        // Recurse through operands and lvalues.\n+        self.super_rvalue(rvalue);\n+\n+        match *rvalue {\n+            Rvalue::Use(_) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Cast(CastKind::ReifyFnPointer, _, _) |\n+            Rvalue::Cast(CastKind::UnsafeFnPointer, _, _) |\n+            Rvalue::Cast(CastKind::Unsize, _, _) => {}\n+\n+            Rvalue::Len(_) => {\n+                // Static lvalues in consts would have errored already,\n+                // don't treat length checks as reads from statics.\n+                self.qualif = self.qualif - Qualif::STATIC;\n+            }\n+\n+            Rvalue::Ref(_, kind, ref lvalue) => {\n+                // Static lvalues in consts would have errored already,\n+                // only keep track of references to them here.\n+                if self.qualif.intersects(Qualif::STATIC) {\n+                    self.qualif = self.qualif - Qualif::STATIC;\n+                    self.add(Qualif::STATIC_REF);\n+                }\n+\n+                let ty = self.mir.lvalue_ty(self.tcx, lvalue).to_ty(self.tcx);\n+                if kind == BorrowKind::Mut {\n+                    // In theory, any zero-sized value could be borrowed\n+                    // mutably without consequences. However, only &mut []\n+                    // is allowed right now, and only in functions.\n+                    let allow = if let ty::TyArray(_, 0) = ty.sty {\n+                        self.mode == Mode::Fn\n+                    } else if self.mode == Mode::StaticMut {\n+                        // Inside a `static mut`, &mut [...] is also allowed.\n+                        match ty.sty {\n+                            ty::TyArray(..) | ty::TySlice(_) => {\n+                                // Mutating can expose drops, be conservative.\n+                                self.add_type(ty);\n+                                self.deny_drop();\n+                                true\n+                            }\n+                            _ => false\n+                        }\n+                    } else {\n+                        false\n+                    };\n+\n+                    if !allow {\n+                        self.add(Qualif::NOT_CONST);\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0017,\n+                                      \"references in {}s may only refer \\\n+                                       to immutable values\", self.mode);\n+                        }\n+                    }\n+                } else {\n+                    // Constants cannot be borrowed if they contain interior mutability as\n+                    // it means that our \"silent insertion of statics\" could change\n+                    // initializer values (very bad).\n+                    if self.qualif.intersects(Qualif::MUTABLE_INTERIOR) {\n+                        // Replace MUTABLE_INTERIOR with NOT_CONST to avoid\n+                        // duplicate errors (from reborrowing, for example).\n+                        self.qualif = self.qualif - Qualif::MUTABLE_INTERIOR;\n+                        self.add(Qualif::NOT_CONST);\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0492,\n+                                      \"cannot borrow a constant which contains \\\n+                                       interior mutability, create a static instead\");\n+                        }\n+                    }\n+                }\n+\n+                // We might have a candidate for promotion.\n+                let candidate = Candidate::Ref(self.location);\n+                if self.mode == Mode::Fn || self.mode == Mode::ConstFn {\n+                    if !self.qualif.intersects(Qualif::UNPROMOTABLE) {\n+                        self.promotion_candidates.push(candidate);\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n+                let operand_ty = self.mir.operand_ty(self.tcx, operand);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                match (cast_in, cast_out) {\n+                    (CastTy::Ptr(_), CastTy::Int(_)) |\n+                    (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        self.add(Qualif::NOT_CONST);\n+                        if self.mode != Mode::Fn {\n+                            span_err!(self.tcx.sess, self.span, E0018,\n+                                      \"raw pointers cannot be cast to integers in {}s\",\n+                                      self.mode);\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) => {\n+                if let ty::TyRawPtr(_) = self.mir.operand_ty(self.tcx, lhs).sty {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt);\n+\n+                    self.add(Qualif::NOT_CONST);\n+                    if self.mode != Mode::Fn {\n+                        span_err!(self.tcx.sess, self.span, E0395,\n+                                  \"raw pointers cannot be compared in {}s\",\n+                                  self.mode);\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Box(_) => {\n+                self.add(Qualif::NOT_CONST);\n+                if self.mode != Mode::Fn {\n+                    span_err!(self.tcx.sess, self.span, E0010,\n+                              \"allocations are not allowed in {}s\", self.mode);\n+                }\n+            }\n+\n+            Rvalue::Aggregate(ref kind, _) => {\n+                if let AggregateKind::Adt(def, _, _) = *kind {\n+                    if def.has_dtor() {\n+                        self.add(Qualif::NEEDS_DROP);\n+                        self.deny_drop();\n+                    }\n+\n+                    if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n+                        let ty = self.mir.rvalue_ty(self.tcx, rvalue).unwrap();\n+                        self.add_type(ty);\n+                        assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n+                        // Even if the value inside may not need dropping,\n+                        // mutating it would change that.\n+                        if !self.qualif.intersects(Qualif::NOT_CONST) {\n+                            self.deny_drop();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            Rvalue::Slice {..} |\n+            Rvalue::InlineAsm {..} => {\n+                self.not_const();\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_kind(&mut self, bb: BasicBlock, kind: &TerminatorKind<'tcx>) {\n+        if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n+            self.visit_operand(func);\n+\n+            let fn_ty = self.mir.operand_ty(self.tcx, func);\n+            let (is_shuffle, is_const_fn) = match fn_ty.sty {\n+                ty::TyFnDef(def_id, _, f) => {\n+                    (f.abi == Abi::PlatformIntrinsic &&\n+                     self.tcx.item_name(def_id).as_str().starts_with(\"simd_shuffle\"),\n+                     is_const_fn(self.tcx, def_id))\n+                }\n+                _ => (false, false)\n+            };\n+\n+            for (i, arg) in args.iter().enumerate() {\n+                self.nest(|this| {\n+                    this.visit_operand(arg);\n+                    if is_shuffle && i == 2 && this.mode == Mode::Fn {\n+                        let candidate = Candidate::ShuffleIndices(bb);\n+                        if !this.qualif.intersects(Qualif::UNPROMOTABLE) {\n+                            this.promotion_candidates.push(candidate);\n+                        } else {\n+                            span_err!(this.tcx.sess, this.span, E0526,\n+                                      \"shuffle indices are not constant\");\n+                        }\n+                    }\n+                });\n+            }\n+\n+            // Const fn calls.\n+            if is_const_fn {\n+                // We are in a const or static initializer,\n+                if self.mode != Mode::Fn &&\n+\n+                    // feature-gate is not enabled,\n+                    !self.tcx.sess.features.borrow().const_fn &&\n+\n+                    // this doesn't come from a crate with the feature-gate enabled,\n+                    self.def_id.is_local() &&\n+\n+                    // this doesn't come from a macro that has #[allow_internal_unstable]\n+                    !self.tcx.sess.codemap().span_allows_unstable(self.span)\n+                {\n+                    let mut err = self.tcx.sess.struct_span_err(self.span,\n+                        \"const fns are an unstable feature\");\n+                    help!(&mut err,\n+                          \"in Nightly builds, add `#![feature(const_fn)]` \\\n+                           to the crate attributes to enable\");\n+                    err.emit();\n+                }\n+            } else {\n+                self.qualif = Qualif::NOT_CONST;\n+                if self.mode != Mode::Fn {\n+                    // FIXME(#24111) Remove this check when const fn stabilizes\n+                    let (msg, note) = if let UnstableFeatures::Disallow =\n+                            self.tcx.sess.opts.unstable_features {\n+                        (format!(\"calls in {}s are limited to \\\n+                                  struct and enum constructors\",\n+                                 self.mode),\n+                         Some(\"a limited form of compile-time function \\\n+                               evaluation is available on a nightly \\\n+                               compiler via `const fn`\"))\n+                    } else {\n+                        (format!(\"calls in {}s are limited \\\n+                                  to constant functions, \\\n+                                  struct and enum constructors\",\n+                                 self.mode),\n+                         None)\n+                    };\n+                    let mut err = struct_span_err!(self.tcx.sess, self.span, E0015, \"{}\", msg);\n+                    if let Some(note) = note {\n+                        err.span_note(self.span, note);\n+                    }\n+                    err.emit();\n+                }\n+            }\n+\n+            if let Some((ref dest, _)) = *destination {\n+                // Avoid propagating irrelevant callee/argument qualifications.\n+                if self.qualif.intersects(Qualif::CONST_ERROR) {\n+                    self.qualif = Qualif::NOT_CONST;\n+                } else {\n+                    // Be conservative about the returned value of a const fn.\n+                    let tcx = self.tcx;\n+                    let ty = self.mir.lvalue_ty(tcx, dest).to_ty(tcx);\n+                    self.qualif = Qualif::empty();\n+                    self.add_type(ty);\n+\n+                    // Let `const fn` transitively have destructors,\n+                    // but they do get stopped in `const` or `static`.\n+                    if self.mode != Mode::ConstFn {\n+                        self.deny_drop();\n+                    }\n+                }\n+                self.assign(dest);\n+            }\n+        } else {\n+            // Qualify any operands inside other terminators.\n+            self.super_terminator_kind(bb, kind);\n+        }\n+    }\n+\n+    fn visit_assign(&mut self, _: BasicBlock, dest: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n+        self.visit_rvalue(rvalue);\n+\n+        // Check the allowed const fn argument forms.\n+        if let (Mode::ConstFn, &Lvalue::Var(index)) = (self.mode, dest) {\n+            if self.const_fn_arg_vars.insert(index as usize) {\n+                // Direct use of an argument is permitted.\n+                if let Rvalue::Use(Operand::Consume(Lvalue::Arg(_))) = *rvalue {\n+                    return;\n+                }\n+\n+                // Avoid a generic error for other uses of arguments.\n+                if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n+                    let decl = &self.mir.var_decls[index as usize];\n+                    span_err!(self.tcx.sess, decl.span, E0022,\n+                              \"arguments of constant functions can only \\\n+                               be immutable by-value bindings\");\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.assign(dest);\n+    }\n+\n+    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n+        assert_eq!(self.location.block, bb);\n+        self.span = statement.span;\n+        self.nest(|this| this.super_statement(bb, statement));\n+        self.location.statement_index += 1;\n+    }\n+\n+    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n+        assert_eq!(self.location.block, bb);\n+        self.span = terminator.span;\n+        self.nest(|this| this.super_terminator(bb, terminator));\n+    }\n+\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.location.statement_index = 0;\n+        self.location.block = bb;\n+        self.super_basic_block_data(bb, data);\n+    }\n+}\n+\n+fn qualify_const_item_cached<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                   qualif_map: &mut DefIdMap<Qualif>,\n+                                   mir_map: Option<&MirMap<'tcx>>,\n+                                   def_id: DefId)\n+                                   -> Qualif {\n+    match qualif_map.entry(def_id) {\n+        Entry::Occupied(entry) => return *entry.get(),\n+        Entry::Vacant(entry) => {\n+            // Guard against `const` recursion.\n+            entry.insert(Qualif::RECURSIVE);\n+        }\n+    }\n+\n+    let extern_mir;\n+    let param_env_and_mir = if def_id.is_local() {\n+        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n+        mir_map.and_then(|map| map.map.get(&node_id)).map(|mir| {\n+            (ty::ParameterEnvironment::for_item(tcx, node_id), mir)\n+        })\n+    } else if let Some(mir) = tcx.sess.cstore.maybe_get_item_mir(tcx, def_id) {\n+        // These should only be monomorphic constants.\n+        extern_mir = mir;\n+        Some((tcx.empty_parameter_environment(), &extern_mir))\n+    } else {\n+        None\n+    };\n+\n+    let (param_env, mir) = param_env_and_mir.unwrap_or_else(|| {\n+        bug!(\"missing constant MIR for {}\", tcx.item_path_str(def_id))\n+    });\n+\n+    let mut qualifier = Qualifier::new(param_env, qualif_map, mir_map,\n+                                       def_id, mir, Mode::Const);\n+    let qualif = qualifier.qualify_const();\n+    qualifier.qualif_map.insert(def_id, qualif);\n+    qualif\n+}\n+\n+pub struct QualifyAndPromoteConstants;\n+\n+impl Pass for QualifyAndPromoteConstants {}\n+\n+impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+        let mut qualif_map = DefIdMap();\n+\n+        // First, visit `const` items, potentially recursing, to get\n+        // accurate MUTABLE_INTERIOR and NEEDS_DROP qualifications.\n+        for &id in map.map.keys() {\n+            let def_id = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+            let src = MirSource::from_node(tcx, id);\n+            if let MirSource::Const(_) = src {\n+                qualify_const_item_cached(tcx, &mut qualif_map, Some(map), def_id);\n+            }\n+        }\n+\n+        // Then, handle everything else, without recursing,\n+        // as the MIR map is not shared, since promotion\n+        // in functions (including `const fn`) mutates it.\n+        for (&id, mir) in &mut map.map {\n+            let def_id = tcx.map.local_def_id(id);\n+            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+            let src = MirSource::from_node(tcx, id);\n+            let mode = match src {\n+                MirSource::Fn(_) => {\n+                    if is_const_fn(tcx, def_id) {\n+                        Mode::ConstFn\n+                    } else {\n+                        Mode::Fn\n+                    }\n+                }\n+                MirSource::Const(_) => continue,\n+                MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n+                MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n+                MirSource::Promoted(..) => bug!()\n+            };\n+            let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+\n+            if mode == Mode::Fn || mode == Mode::ConstFn {\n+                // This is ugly because Qualifier holds onto mir,\n+                // which can't be mutated until its scope ends.\n+                let (temps, candidates) = {\n+                    let mut qualifier = Qualifier::new(param_env, &mut qualif_map,\n+                                                       None, def_id, mir, mode);\n+                    if mode == Mode::ConstFn {\n+                        // Enforce a constant-like CFG for `const fn`.\n+                        qualifier.qualify_const();\n+                    } else {\n+                        while let Some((bb, data)) = qualifier.rpo.next() {\n+                            qualifier.visit_basic_block_data(bb, data);\n+                        }\n+                    }\n+\n+                    (qualifier.temp_promotion_state,\n+                     qualifier.promotion_candidates)\n+                };\n+\n+                // Do the actual promotion, now that we know what's viable.\n+                promote_consts::promote_candidates(mir, tcx, temps, candidates);\n+            } else {\n+                let mut qualifier = Qualifier::new(param_env, &mut qualif_map,\n+                                                   None, def_id, mir, mode);\n+                qualifier.qualify_const();\n+            }\n+\n+            // Statics must be Sync.\n+            if mode == Mode::Static {\n+                let ty = mir.return_ty.unwrap();\n+                let infcx = infer::new_infer_ctxt(tcx,\n+                                                  &tcx.tables,\n+                                                  None,\n+                                                  ProjectionMode::AnyFinal);\n+                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+                    traits::report_fulfillment_errors(&infcx, &err);\n+                }\n+\n+                if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                   traits::report_fulfillment_errors_as_warnings(&infcx, errors, id);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "e0d05a17d4376ea2e73b805c03c688a3b94b9d9c", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -35,13 +35,12 @@\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{Pass, MirPass};\n-use syntax::ast::NodeId;\n+use rustc::mir::transform::{Pass, MirPass, MirSource};\n \n pub struct RemoveDeadBlocks;\n \n impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         let mut seen = BitVector::new(mir.basic_blocks.len());\n         // This block is always required.\n         seen.insert(START_BLOCK.index());"}, {"sha": "a137a812867fa6bef22689f14784edbddd5e222c", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -11,9 +11,8 @@\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n-use rustc::mir::transform::{MirPass, Pass};\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n use pretty;\n-use syntax::ast::NodeId;\n \n use super::remove_dead_blocks::RemoveDeadBlocks;\n \n@@ -112,15 +111,15 @@ impl SimplifyCfg {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let mut counter = 0;\n         let mut changed = true;\n         while changed {\n-            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, id, mir, None);\n+            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, src, mir, None);\n             counter += 1;\n             changed = self.simplify_branches(mir);\n             changed |= self.remove_goto_chains(mir);\n-            RemoveDeadBlocks.run_pass(tcx, id, mir);\n+            RemoveDeadBlocks.run_pass(tcx, src, mir);\n         }\n         // FIXME: Should probably be moved into some kind of pass manager\n         mir.basic_blocks.shrink_to_fit();"}, {"sha": "18ebadf42d688953fbeb09cd0601ea1daaba841d", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -12,16 +12,16 @@\n #![allow(unreachable_code)]\n \n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::mir::transform::{MirPass, Pass};\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n use rustc::mir::visit::{self, Visitor};\n use std::fmt;\n-use syntax::ast::NodeId;\n use syntax::codemap::{Span, DUMMY_SP};\n \n macro_rules! span_mirbug {\n@@ -578,15 +578,13 @@ impl TypeckMir {\n }\n \n impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, id: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let def_id = tcx.map.local_def_id(id);\n-        let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(def_id));\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n         let infcx = infer::new_infer_ctxt(tcx,\n                                           &tcx.tables,\n                                           Some(param_env),\n@@ -605,4 +603,8 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n     }\n }\n \n-impl Pass for TypeckMir {}\n+impl Pass for TypeckMir {\n+    fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n+        DepNode::MirTypeck(def_id)\n+    }\n+}"}, {"sha": "97a4c14863d59c083b54ea56fce231dea707ede8", "filename": "src/librustc_passes/const_fn.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -1,118 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Verifies that const fn arguments are immutable by value bindings\n-//! and the const fn body doesn't contain any statements\n-\n-use rustc::session::{Session, CompileResult};\n-\n-use syntax::ast::{self, PatKind};\n-use syntax::visit::{self, Visitor, FnKind};\n-use syntax::codemap::Span;\n-\n-pub fn check_crate(sess: &Session, krate: &ast::Crate) -> CompileResult {\n-    sess.track_errors(|| {\n-        visit::walk_crate(&mut CheckConstFn{ sess: sess }, krate);\n-    })\n-}\n-\n-struct CheckConstFn<'a> {\n-    sess: &'a Session,\n-}\n-\n-struct CheckBlock<'a> {\n-    sess: &'a Session,\n-    kind: &'static str,\n-}\n-\n-impl<'a, 'v> Visitor<'v> for CheckBlock<'a> {\n-    fn visit_block(&mut self, block: &'v ast::Block) {\n-        check_block(&self.sess, block, self.kind);\n-        CheckConstFn{ sess: self.sess}.visit_block(block);\n-    }\n-    fn visit_expr(&mut self, e: &'v ast::Expr) {\n-        if let ast::ExprKind::Closure(..) = e.node {\n-            CheckConstFn{ sess: self.sess}.visit_expr(e);\n-        } else {\n-            visit::walk_expr(self, e);\n-        }\n-    }\n-    fn visit_item(&mut self, _i: &'v ast::Item) { bug!(\"should be handled in CheckConstFn\") }\n-    fn visit_fn(&mut self,\n-                _fk: FnKind<'v>,\n-                _fd: &'v ast::FnDecl,\n-                _b: &'v ast::Block,\n-                _s: Span,\n-                _fn_id: ast::NodeId) { bug!(\"should be handled in CheckConstFn\") }\n-}\n-\n-fn check_block(sess: &Session, b: &ast::Block, kind: &'static str) {\n-    // Check all statements in the block\n-    for stmt in &b.stmts {\n-        let span = match stmt.node {\n-            ast::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    ast::DeclKind::Local(_) => decl.span,\n-\n-                    // Item statements are allowed\n-                    ast::DeclKind::Item(_) => continue,\n-                }\n-            }\n-            ast::StmtKind::Expr(ref expr, _) => expr.span,\n-            ast::StmtKind::Semi(ref semi, _) => semi.span,\n-            ast::StmtKind::Mac(..) => bug!(),\n-        };\n-        span_err!(sess, span, E0016,\n-                  \"blocks in {}s are limited to items and tail expressions\", kind);\n-    }\n-}\n-\n-impl<'a, 'v> Visitor<'v> for CheckConstFn<'a> {\n-    fn visit_item(&mut self, i: &'v ast::Item) {\n-        visit::walk_item(self, i);\n-        match i.node {\n-            ast::ItemKind::Const(_, ref e) => {\n-                CheckBlock{ sess: self.sess, kind: \"constant\"}.visit_expr(e)\n-            },\n-            ast::ItemKind::Static(_, _, ref e) => {\n-                CheckBlock{ sess: self.sess, kind: \"static\"}.visit_expr(e)\n-            },\n-            _ => {},\n-        }\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fk: FnKind<'v>,\n-                fd: &'v ast::FnDecl,\n-                b: &'v ast::Block,\n-                s: Span,\n-                _fn_id: ast::NodeId) {\n-        visit::walk_fn(self, fk, fd, b, s);\n-        match fk {\n-            FnKind::ItemFn(_, _, _, ast::Constness::Const, _, _) => {},\n-            FnKind::Method(_, m, _) if m.constness == ast::Constness::Const => {},\n-            _ => return,\n-        }\n-\n-        // Ensure the arguments are simple, not mutable/by-ref or patterns.\n-        for arg in &fd.inputs {\n-            match arg.pat.node {\n-                PatKind::Wild => {}\n-                PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable), _, None) => {}\n-                _ => {\n-                    span_err!(self.sess, arg.pat.span, E0022,\n-                              \"arguments of constant functions can only \\\n-                               be immutable by-value bindings\");\n-                }\n-            }\n-        }\n-        check_block(&self.sess, b, \"const function\");\n-    }\n-}"}, {"sha": "c417ec79ff2a8d9cfe11e458236a596e163406f4", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 9, "deletions": 168, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -40,15 +40,14 @@ use rustc::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::ProjectionMode;\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n \n use rustc::hir::{self, PatKind};\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n \n use std::collections::hash_map::Entry;\n@@ -180,31 +179,11 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     /// Returns true if the call is to a const fn or method.\n     fn handle_const_fn_call(&mut self,\n-                            expr: &hir::Expr,\n+                            _expr: &hir::Expr,\n                             def_id: DefId,\n                             ret_ty: Ty<'tcx>)\n                             -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n-            if\n-                // we are in a static/const initializer\n-                self.mode != Mode::Var &&\n-\n-                // feature-gate is not enabled\n-                !self.tcx.sess.features.borrow().const_fn &&\n-\n-                // this doesn't come from a macro that has #[allow_internal_unstable]\n-                !self.tcx.sess.codemap().span_allows_unstable(expr.span)\n-            {\n-                let mut err = self.tcx.sess.struct_span_err(\n-                    expr.span,\n-                    \"const fns are an unstable feature\");\n-                help!(\n-                    &mut err,\n-                    \"in Nightly builds, add `#![feature(const_fn)]` to the crate \\\n-                     attributes to enable\");\n-                err.emit();\n-            }\n-\n             let qualif = self.fn_like(fn_like.kind(),\n                                       fn_like.decl(),\n                                       fn_like.body(),\n@@ -245,42 +224,6 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Mode::Var => bug!(),\n         }\n     }\n-\n-    fn check_static_mut_type(&self, e: &hir::Expr) {\n-        let node_ty = self.tcx.node_id_to_type(e.id);\n-        let tcontents = node_ty.type_contents(self.tcx);\n-\n-        let suffix = if tcontents.has_dtor() {\n-            \"destructors\"\n-        } else if tcontents.owns_owned() {\n-            \"boxes\"\n-        } else {\n-            return\n-        };\n-\n-        span_err!(self.tcx.sess, e.span, E0397,\n-                 \"mutable statics are not allowed to have {}\", suffix);\n-    }\n-\n-    fn check_static_type(&self, e: &hir::Expr) {\n-        let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx,\n-                                          &self.tcx.tables,\n-                                          None,\n-                                          ProjectionMode::AnyFinal);\n-        let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n-        let mut fulfillment_cx = traits::FulfillmentContext::new();\n-        fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-        match fulfillment_cx.select_all_or_error(&infcx) {\n-            Ok(()) => { },\n-            Err(ref errors) => {\n-                traits::report_fulfillment_errors(&infcx, errors);\n-            }\n-        }\n-        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n-            traits::report_fulfillment_errors_as_warnings(&infcx, errors, e.id);\n-        }\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n@@ -289,11 +232,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         assert_eq!(self.mode, Mode::Var);\n         match i.node {\n             hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n-                self.check_static_type(&expr);\n                 self.global_expr(Mode::Static, &expr);\n             }\n             hir::ItemStatic(_, hir::MutMutable, ref expr) => {\n-                self.check_static_mut_type(&expr);\n                 self.global_expr(Mode::StaticMut, &expr);\n             }\n             hir::ItemConst(_, ref expr) => {\n@@ -360,8 +301,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                             \"lower range bound must be less than or equal to upper\");\n                     }\n                     None => {\n-                        self.tcx.sess.delay_span_bug(start.span,\n-                                                     \"non-constant path in constant expr\");\n+                        span_err!(self.tcx.sess, p.span, E0014,\n+                                  \"paths in {}s may only refer to constants\",\n+                                  self.msg());\n                     }\n                 }\n             }\n@@ -384,8 +326,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 hir::StmtSemi(_, _) => {},\n             }\n             self.add_qualif(ConstQualif::NOT_CONST);\n-            // anything else should have been caught by check_const_fn\n-            assert_eq!(self.mode, Mode::Var);\n         }\n         intravisit::walk_block(self, block);\n     }\n@@ -455,11 +395,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 let tc = node_ty.type_contents(self.tcx);\n                 if self.qualif.intersects(ConstQualif::MUTABLE_MEM) && tc.interior_unsafe() {\n                     outer = outer | ConstQualif::NOT_CONST;\n-                    if self.mode != Mode::Var {\n-                        span_err!(self.tcx.sess, ex.span, E0492,\n-                                  \"cannot borrow a constant which contains \\\n-                                   interior mutability, create a static instead\");\n-                    }\n                 }\n                 // If the reference has to be 'static, avoid in-place initialization\n                 // as that will end up pointing to the stack instead.\n@@ -474,10 +409,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                     if self.mode == Mode::Var {\n                         outer = outer | ConstQualif::NOT_CONST;\n                         self.add_qualif(ConstQualif::MUTABLE_MEM);\n-                    } else {\n-                        span_err!(self.tcx.sess, ex.span, E0017,\n-                            \"references in {}s may only refer \\\n-                             to immutable values\", self.msg())\n                     }\n                 }\n                 if !self.qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n@@ -525,11 +456,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         ty::TyStruct(def, _) |\n         ty::TyEnum(def, _) if def.has_dtor() => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0493,\n-                          \"{}s are not allowed to have destructors\",\n-                          v.msg());\n-            }\n         }\n         _ => {}\n     }\n@@ -540,28 +466,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprBinary(..) |\n         hir::ExprIndex(..) if v.tcx.tables.borrow().method_map.contains_key(&method_call) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0011,\n-                            \"user-defined operators are not allowed in {}s\", v.msg());\n-            }\n         }\n         hir::ExprBox(_) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0010,\n-                          \"allocations are not allowed in {}s\", v.msg());\n-            }\n         }\n         hir::ExprUnary(op, ref inner) => {\n             match v.tcx.node_id_to_type(inner.id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0396,\n-                                  \"raw pointers cannot be dereferenced in {}s\", v.msg());\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -574,10 +488,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                             op.node == hir::BiGe || op.node == hir::BiGt);\n \n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0395,\n-                                  \"raw pointers cannot be compared in {}s\", v.msg());\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -588,10 +498,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0018,\n-                                  \"raw pointers cannot be cast to integers in {}s\", v.msg());\n-                    }\n                 }\n                 _ => {}\n             }\n@@ -616,11 +522,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(Def::Static(..)) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n-                        Mode::Const | Mode::ConstFn => {\n-                            span_err!(v.tcx.sess, e.span, E0013,\n-                                \"{}s cannot refer to other statics, insert \\\n-                                 an intermediate constant instead\", v.msg());\n-                        }\n+                        Mode::Const | Mode::ConstFn => {}\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n@@ -636,14 +538,8 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                     // Sadly, we can't determine whether the types are zero-sized.\n                     v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n                 }\n-                def => {\n+                _ => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        debug!(\"(checking const) found bad def: {:?}\", def);\n-                        span_err!(v.tcx.sess, e.span, E0014,\n-                                  \"paths in {}s may only refer to constants \\\n-                                   or functions\", v.msg());\n-                    }\n                 }\n             }\n         }\n@@ -681,29 +577,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    // FIXME(#24111) Remove this check when const fn stabilizes\n-                    let (msg, note) =\n-                        if let UnstableFeatures::Disallow = v.tcx.sess.opts.unstable_features {\n-                        (format!(\"function calls in {}s are limited to \\\n-                                  struct and enum constructors\",\n-                                 v.msg()),\n-                         Some(\"a limited form of compile-time function \\\n-                               evaluation is available on a nightly \\\n-                               compiler via `const fn`\"))\n-                    } else {\n-                        (format!(\"function calls in {}s are limited \\\n-                                  to constant functions, \\\n-                                  struct and enum constructors\",\n-                                 v.msg()),\n-                         None)\n-                    };\n-                    let mut err = struct_span_err!(v.tcx.sess, e.span, E0015, \"{}\", msg);\n-                    if let Some(note) = note {\n-                        err.span_note(e.span, note);\n-                    }\n-                    err.emit();\n-                }\n             }\n         }\n         hir::ExprMethodCall(..) => {\n@@ -714,11 +587,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             };\n             if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0378,\n-                              \"method calls in {}s are limited to \\\n-                               constant inherent methods\", v.msg());\n-                }\n             }\n         }\n         hir::ExprStruct(..) => {\n@@ -773,10 +641,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprAssignOp(..) |\n         hir::ExprInlineAsm(..) => {\n             v.add_qualif(ConstQualif::NOT_CONST);\n-            if v.mode != Mode::Var {\n-                span_err!(v.tcx.sess, e.span, E0019,\n-                          \"{} contains unimplemented expression type\", v.msg());\n-            }\n         }\n     }\n }\n@@ -796,11 +660,6 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n                     v.tcx.is_overloaded_autoderef(e.id, autoderef)\n             }) {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0400,\n-                              \"user-defined dereference operators are not allowed in {}s\",\n-                              v.msg());\n-                }\n             }\n         }\n     }\n@@ -819,21 +678,13 @@ pub fn check_crate(tcx: &TyCtxt) {\n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n-               consume_span: Span,\n+               _consume_span: Span,\n                cmt: mc::cmt,\n                _mode: euv::ConsumeMode) {\n         let mut cur = &cmt;\n         loop {\n             match cur.cat {\n                 Categorization::StaticItem => {\n-                    if self.mode != Mode::Var {\n-                        // statics cannot be consumed by value at any time, that would imply\n-                        // that they're an initializer (what a const is for) or kept in sync\n-                        // over time (not feasible), so deny it outright.\n-                        span_err!(self.tcx.sess, consume_span, E0394,\n-                                  \"cannot refer to other statics by value, use the \\\n-                                   address-of operator or a constant instead\");\n-                    }\n                     break;\n                 }\n                 Categorization::Deref(ref cmt, _, _) |\n@@ -848,7 +699,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n     }\n     fn borrow(&mut self,\n               borrow_id: ast::NodeId,\n-              borrow_span: Span,\n+              _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n               _loan_region: ty::Region,\n               bk: ty::BorrowKind,\n@@ -866,7 +717,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         }\n \n         let mut cur = &cmt;\n-        let mut is_interior = false;\n         loop {\n             match cur.cat {\n                 Categorization::Rvalue(..) => {\n@@ -891,20 +741,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n                     break;\n                 }\n                 Categorization::StaticItem => {\n-                    if is_interior && self.mode != Mode::Var {\n-                        // Borrowed statics can specifically *only* have their address taken,\n-                        // not any number of other borrows such as borrowing fields, reading\n-                        // elements of an array, etc.\n-                        span_err!(self.tcx.sess, borrow_span, E0494,\n-                                  \"cannot refer to the interior of another \\\n-                                   static, use a constant instead\");\n-                    }\n                     break;\n                 }\n                 Categorization::Deref(ref cmt, _, _) |\n                 Categorization::Downcast(ref cmt, _) |\n                 Categorization::Interior(ref cmt, _) => {\n-                    is_interior = true;\n                     cur = cmt;\n                 }\n "}, {"sha": "77f896e011b938b076ad84c1deb9230ceaa8bc33", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -12,70 +12,6 @@\n \n register_long_diagnostics! {\n \n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time. Erroneous\n-code example:\n-\n-```compile_fail\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0011: r##\"\n-Initializers for constants and statics are evaluated at compile time.\n-User-defined operators rely on user-defined functions, which cannot be evaluated\n-at compile time.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-use std::ops::Index;\n-\n-struct Foo { a: u8 }\n-\n-impl Index<u8> for Foo {\n-    type Output = u8;\n-\n-    fn index<'a>(&'a self, idx: u8) -> &'a u8 { &self.a }\n-}\n-\n-const a: Foo = Foo { a: 0u8 };\n-const b: u8 = a[0]; // Index trait is defined by the user, bad!\n-```\n-\n-Only operators on builtin types are allowed.\n-\n-Example:\n-\n-```\n-const a: &'static [i32] = &[1, 2, 3];\n-const b: i32 = a[0]; // Ok!\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable. For example, `Y` cannot refer to\n-`X` here:\n-\n-```compile_fail\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-To fix this, the value can be extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n E0014: r##\"\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n@@ -95,149 +31,6 @@ const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n \n-// FIXME(#24111) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0016: r##\"\n-Blocks in constants may only contain items (such as constant, function\n-definition, etc...) and a tail expression. Erroneous code example:\n-\n-```compile_fail\n-const FOO: i32 = { let x = 0; x }; // 'x' isn't an item!\n-```\n-\n-To avoid it, you have to replace the non-item object:\n-\n-```\n-const FOO: i32 = { const X : i32 = 0; X };\n-```\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-Erroneous code example:\n-\n-```compile_fail\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &'static mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0018: r##\"\n-\n-The value of static and constant integers must be known at compile time. You\n-can't cast a pointer to an integer because the address of a pointer can\n-vary.\n-\n-For example, if you write:\n-\n-```compile_fail\n-static MY_STATIC: u32 = 42;\n-static MY_STATIC_ADDR: usize = &MY_STATIC as *const _ as usize;\n-static WHAT: usize = (MY_STATIC_ADDR^17) + MY_STATIC_ADDR;\n-```\n-\n-Then `MY_STATIC_ADDR` would contain the address of `MY_STATIC`. However,\n-the address can change when the program is linked, as well as change\n-between different executions due to ASLR, and many linkers would\n-not be able to calculate the value of `WHAT`.\n-\n-On the other hand, static and constant pointers can point either to\n-a known numeric address or to the address of a symbol.\n-\n-```\n-static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;\n-// ... and also\n-static MY_STATIC_ADDR2: *const u32 = &MY_STATIC;\n-\n-const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n-```\n-\n-This does not pose a problem by itself because they can't be\n-accessed directly.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time. Erroneous code\n-example:\n-\n-```compile_fail\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn test(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    const A: i32 = FOO.test(); // You can't call Test::func() here !\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0022: r##\"\n-Constant functions are not allowed to mutate anything. Thus, binding to an\n-argument with a mutable pattern is not allowed. For example,\n-\n-```compile_fail\n-const fn foo(mut x: u8) {\n-    // do stuff\n-}\n-```\n-\n-Is incorrect because the function body may not mutate `x`.\n-\n-Remove any mutable bindings from the argument list to fix this error. In case\n-you need to mutate the argument, try lazily initializing a global variable\n-instead of using a `const fn`, or refactoring the code to a functional style to\n-avoid mutation if possible.\n-\"##,\n-\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to\n@@ -325,281 +118,6 @@ fn some_func() {\n ```\n \"##,\n \n-E0378: r##\"\n-Method calls that aren't calls to inherent `const` methods are disallowed\n-in statics, constants, and constant functions.\n-\n-For example:\n-\n-```compile_fail\n-const BAZ: i32 = Foo(25).bar(); // error, `bar` isn't `const`\n-\n-struct Foo(i32);\n-\n-impl Foo {\n-    const fn foo(&self) -> i32 {\n-        self.bar() // error, `bar` isn't `const`\n-    }\n-\n-    fn bar(&self) -> i32 { self.0 }\n-}\n-```\n-\n-For more information about `const fn`'s, see [RFC 911].\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0394: r##\"\n-From [RFC 246]:\n-\n- > It is invalid for a static to reference another static by value. It is\n- > required that all references be borrowed.\n-\n-[RFC 246]: https://github.com/rust-lang/rfcs/pull/246\n-\"##,\n-\n-\n-E0395: r##\"\n-The value assigned to a constant scalar must be known at compile time,\n-which is not the case when comparing raw pointers.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-static FOO: i32 = 42;\n-static BAR: i32 = 42;\n-\n-static BAZ: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n-// error: raw pointers cannot be compared in statics!\n-```\n-\n-The address assigned by the linker to `FOO` and `BAR` may or may not\n-be identical, so the value of `BAZ` can't be determined.\n-\n-If you want to do the comparison, please do it at run-time.\n-\n-For example:\n-\n-```\n-static FOO: i32 = 42;\n-static BAR: i32 = 42;\n-\n-let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n-// baz isn't a constant expression so it's ok\n-```\n-\"##,\n-\n-E0396: r##\"\n-The value behind a raw pointer can't be determined at compile-time\n-(or even link-time), which means it can't be used in a constant\n-expression. Erroneous code example:\n-\n-```compile_fail\n-const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n-\n-const VALUE: u8 = unsafe { *REG_ADDR };\n-// error: raw pointers cannot be dereferenced in constants\n-```\n-\n-A possible fix is to dereference your pointer at some point in run-time.\n-\n-For example:\n-\n-```\n-const REG_ADDR: *const u8 = 0x5f3759df as *const u8;\n-\n-let reg_value = unsafe { *REG_ADDR };\n-```\n-\"##,\n-\n-E0397: r##\"\n-It is not allowed for a mutable static to allocate or have destructors. For\n-example:\n-\n-```compile_fail\n-// error: mutable statics are not allowed to have boxes\n-static mut FOO: Option<Box<usize>> = None;\n-\n-// error: mutable statics are not allowed to have destructors\n-static mut BAR: Option<Vec<i32>> = None;\n-```\n-\"##,\n-\n-E0400: r##\"\n-A user-defined dereference was attempted in an invalid context. Erroneous\n-code example:\n-\n-```compile_fail\n-use std::ops::Deref;\n-\n-struct A;\n-\n-impl Deref for A {\n-    type Target = str;\n-\n-    fn deref(&self)-> &str { \"foo\" }\n-}\n-\n-const S: &'static str = &A;\n-// error: user-defined dereference operators are not allowed in constants\n-\n-fn main() {\n-    let foo = S;\n-}\n-```\n-\n-You cannot directly use a dereference operation whilst initializing a constant\n-or a static. To fix this error, restructure your code to avoid this dereference,\n-perhaps moving it inline:\n-\n-```\n-use std::ops::Deref;\n-\n-struct A;\n-\n-impl Deref for A {\n-    type Target = str;\n-\n-    fn deref(&self)-> &str { \"foo\" }\n-}\n-\n-fn main() {\n-    let foo : &str = &A;\n-}\n-```\n-\"##,\n-\n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted. Erroneous\n-code example:\n-\n-```compile_fail\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n-\n-const A: AtomicUsize = ATOMIC_USIZE_INIT;\n-static B: &'static AtomicUsize = &A;\n-// error: cannot borrow a constant which contains interior mutability, create a\n-//        static instead\n-```\n-\n-A `const` represents a constant value that should never change. If one takes\n-a `&` reference to the constant, then one is taking a pointer to some memory\n-location containing the value. Normally this is perfectly fine: most values\n-can't be changed via a shared `&` pointer, but interior mutability would allow\n-it. That is, a constant value could be mutated. On the other hand, a `static` is\n-explicitly a single memory location, which can be mutated at will.\n-\n-So, in order to solve this error, either use statics which are `Sync`:\n-\n-```\n-use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n-\n-static A: AtomicUsize = ATOMIC_USIZE_INIT;\n-static B: &'static AtomicUsize = &A; // ok!\n-```\n-\n-You can also have this error while using a cell type:\n-\n-```compile_fail\n-#![feature(const_fn)]\n-\n-use std::cell::Cell;\n-\n-const A: Cell<usize> = Cell::new(1);\n-const B: &'static Cell<usize> = &A;\n-// error: cannot borrow a constant which contains interior mutability, create\n-//        a static instead\n-\n-// or:\n-struct C { a: Cell<usize> }\n-\n-const D: C = C { a: Cell::new(1) };\n-const E: &'static Cell<usize> = &D.a; // error\n-\n-// or:\n-const F: &'static C = &D; // error\n-```\n-\n-This is because cell types do operations that are not thread-safe. Due to this,\n-they don't implement Sync and thus can't be placed in statics. In this\n-case, `StaticMutex` would work just fine, but it isn't stable yet:\n-https://doc.rust-lang.org/nightly/std/sync/struct.StaticMutex.html\n-\n-However, if you still wish to use these types, you can achieve this by an unsafe\n-wrapper:\n-\n-```\n-#![feature(const_fn)]\n-\n-use std::cell::Cell;\n-use std::marker::Sync;\n-\n-struct NotThreadSafe<T> {\n-    value: Cell<T>,\n-}\n-\n-unsafe impl<T> Sync for NotThreadSafe<T> {}\n-\n-static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n-static B: &'static NotThreadSafe<usize> = &A; // ok!\n-```\n-\n-Remember this solution is unsafe! You will have to ensure that accesses to the\n-cell are synchronized.\n-\"##,\n-\n-E0493: r##\"\n-A type with a destructor was assigned to an invalid type of variable. Erroneous\n-code example:\n-\n-```compile_fail\n-struct Foo {\n-    a: u32\n-}\n-\n-impl Drop for Foo {\n-    fn drop(&mut self) {}\n-}\n-\n-const F : Foo = Foo { a : 0 };\n-// error: constants are not allowed to have destructors\n-static S : Foo = Foo { a : 0 };\n-// error: statics are not allowed to have destructors\n-```\n-\n-To solve this issue, please use a type which does allow the usage of type with\n-destructors.\n-\"##,\n-\n-E0494: r##\"\n-A reference of an interior static was assigned to another const/static.\n-Erroneous code example:\n-\n-```compile_fail\n-struct Foo {\n-    a: u32\n-}\n-\n-static S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a;\n-// error: cannot refer to the interior of another static, use a\n-//        constant instead\n-```\n-\n-The \"base\" variable has to be a const if you want another static/const variable\n-to refer to one of its fields. Example:\n-\n-```\n-struct Foo {\n-    a: u32\n-}\n-\n-const S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a; // ok!\n-```\n-\"##,\n-\n }\n \n register_diagnostics! {"}, {"sha": "67a9c2fd17e9fcf6ffedecd9fe341698142df280", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -37,7 +37,6 @@ extern crate rustc_const_math;\n \n pub mod diagnostics;\n \n-pub mod const_fn;\n pub mod consts;\n pub mod loops;\n pub mod no_asm;"}, {"sha": "a0311ec606627757e3b0f391c7e7ebcb6a4f631b", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -414,6 +414,9 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n             };\n \n             visitor.visit_mir(&mir);\n+            for promoted in &mir.promoted {\n+                visitor.visit_mir(promoted);\n+            }\n         }\n     }\n "}, {"sha": "09d38e8946bbdc5e090e5aec803680e3d875fbac", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -39,7 +39,7 @@ use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::cast::{CastTy,IntTy};\n use util::nodemap::NodeMap;\n-use rustc_const_math::{ConstInt, ConstMathErr, ConstUsize, ConstIsize};\n+use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n \n use rustc::hir;\n \n@@ -48,6 +48,7 @@ use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n use syntax::attr::{self, AttrMetaMethods};\n+use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -110,11 +111,11 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn addr_of_mut(ccx: &CrateContext,\n-               cv: ValueRef,\n-               align: machine::llalign,\n-               kind: &str)\n-               -> ValueRef {\n+pub fn addr_of_mut(ccx: &CrateContext,\n+                   cv: ValueRef,\n+                   align: machine::llalign,\n+                   kind: &str)\n+                    -> ValueRef {\n     unsafe {\n         // FIXME: this totally needs a better name generation scheme, perhaps a simple global\n         // counter? Also most other uses of gensym in trans.\n@@ -158,13 +159,13 @@ pub fn addr_of(ccx: &CrateContext,\n }\n \n /// Deref a constant pointer\n-fn load_const(cx: &CrateContext, v: ValueRef, t: Ty) -> ValueRef {\n+pub fn load_const(cx: &CrateContext, v: ValueRef, t: Ty) -> ValueRef {\n     let v = match cx.const_unsized().borrow().get(&v) {\n         Some(&v) => v,\n         None => v\n     };\n     let d = unsafe { llvm::LLVMGetInitializer(v) };\n-    if t.is_bool() {\n+    if !d.is_null() && t.is_bool() {\n         unsafe { llvm::LLVMConstTrunc(d, Type::i1(cx).to_ref()) }\n     } else {\n         d\n@@ -466,16 +467,12 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n             Some(v) => v,\n             None => return Ok(()),\n         };\n-        match -cval {\n-            Ok(_) => return Ok(()),\n-            Err(err) => const_err(cx, e, Err(err), trueconst),\n-        }\n-    } else {\n-        Ok(())\n+        const_err(cx, e.span, (-cval).map_err(ErrKind::Math), trueconst)?;\n     }\n+    Ok(())\n }\n \n-fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n+pub fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n         ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n             ast::IntTy::I8 => {\n@@ -523,24 +520,21 @@ fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n     }\n }\n \n-fn const_err(cx: &CrateContext,\n-             e: &hir::Expr,\n-             result: Result<ConstInt, ConstMathErr>,\n-             trueconst: TrueConst)\n-             -> Result<(), ConstEvalFailure> {\n+pub fn const_err<T>(cx: &CrateContext,\n+                    span: Span,\n+                    result: Result<T, ErrKind>,\n+                    trueconst: TrueConst)\n+                    -> Result<T, ConstEvalFailure> {\n     match (result, trueconst) {\n-        (Ok(_), _) => {\n-            // We do not actually care about a successful result.\n-            Ok(())\n-        },\n+        (Ok(x), _) => Ok(x),\n         (Err(err), TrueConst::Yes) => {\n-            let err = ConstEvalErr{ span: e.span, kind: ErrKind::Math(err) };\n-            cx.tcx().sess.span_err(e.span, &err.description());\n+            let err = ConstEvalErr{ span: span, kind: err };\n+            cx.tcx().sess.span_err(span, &err.description());\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n-            let err = ConstEvalErr{ span: e.span, kind: ErrKind::Math(err) };\n-            cx.tcx().sess.span_warn(e.span, &err.description());\n+            let err = ConstEvalErr{ span: span, kind: err };\n+            cx.tcx().sess.span_warn(span, &err.description());\n             Err(Runtime(err))\n         },\n     }\n@@ -564,7 +558,8 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n         hir::BiShr => lhs >> rhs,\n         _ => return Ok(()),\n     };\n-    const_err(cx, e, result, trueconst)\n+    const_err(cx, e.span, result.map_err(ErrKind::Math), trueconst)?;\n+    Ok(())\n }\n \n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -719,8 +714,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if iv >= len {\n                 // FIXME #3170: report this earlier on in the const-eval\n                 // pass. Reporting here is a bit late.\n-                span_err!(cx.sess(), e.span, E0515,\n-                          \"const index-expr is out of bounds\");\n+                const_err(cx, e.span, Err(ErrKind::IndexOutOfBounds), trueconst)?;\n                 C_undef(val_ty(arr).element_type())\n             } else {\n                 const_get_elt(arr, &[iv as c_uint])\n@@ -1128,6 +1122,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n     };\n \n     ccx.instances().borrow_mut().insert(instance, g);\n+    ccx.statics().borrow_mut().insert(g, def_id);\n     Datum::new(g, ty, Lvalue::new(\"static\"))\n }\n \n@@ -1147,14 +1142,20 @@ pub fn trans_static(ccx: &CrateContext,\n         let def_id = ccx.tcx().map.local_def_id(id);\n         let datum = get_static(ccx, def_id);\n \n-        let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n-        let (v, _) = const_expr(\n-            ccx,\n-            expr,\n-            empty_substs,\n-            None,\n-            TrueConst::Yes,\n-        ).map_err(|e| e.into_inner())?;\n+        let check_attrs = |attrs: &[ast::Attribute]| {\n+            let default_to_mir = ccx.sess().opts.debugging_opts.orbit;\n+            let invert = if default_to_mir { \"rustc_no_mir\" } else { \"rustc_mir\" };\n+            default_to_mir ^ attrs.iter().any(|item| item.check_name(invert))\n+        };\n+        let use_mir = check_attrs(ccx.tcx().map.attrs(id));\n+\n+        let v = if use_mir {\n+            ::mir::trans_static_initializer(ccx, def_id)\n+        } else {\n+            let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n+            const_expr(ccx, expr, empty_substs, None, TrueConst::Yes)\n+                .map(|(v, _)| v)\n+        }.map_err(|e| e.into_inner())?;\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected"}, {"sha": "2ee880fa3d8500c96d2d03641b14fe76a8d817a7", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -131,6 +131,9 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n+    /// Mapping from static definitions to their DefId's.\n+    statics: RefCell<FnvHashMap<ValueRef, DefId>>,\n+\n     impl_method_cache: RefCell<FnvHashMap<(DefId, ast::Name), DefId>>,\n \n     /// Cache of closure wrappers for bare fn's.\n@@ -495,6 +498,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 const_globals: RefCell::new(FnvHashMap()),\n                 const_values: RefCell::new(FnvHashMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n+                statics: RefCell::new(FnvHashMap()),\n                 impl_method_cache: RefCell::new(FnvHashMap()),\n                 closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n@@ -699,6 +703,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.extern_const_values\n     }\n \n+    pub fn statics<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, DefId>> {\n+        &self.local.statics\n+    }\n+\n     pub fn impl_method_cache<'a>(&'a self)\n             -> &'a RefCell<FnvHashMap<(DefId, ast::Name), DefId>> {\n         &self.local.impl_method_cache"}, {"sha": "d9de673db27caba2d9dbc5d46e29b2b827095863", "filename": "src/librustc_trans/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdiagnostics.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -82,19 +82,4 @@ extern \"platform-intrinsic\" {\n unsafe { simd_add(i32x1(0), i32x1(1)); } // ok!\n ```\n \"##,\n-\n-E0515: r##\"\n-A constant index expression was out of bounds. Erroneous code example:\n-\n-```compile_fail\n-let x = &[0, 1, 2][7]; // error: const index-expr is out of bounds\n-```\n-\n-Please specify a valid index (not inferior to 0 or superior to array length).\n-Example:\n-\n-```\n-let x = &[0, 1, 2][2]; // ok\n-```\n-\"##,\n }"}, {"sha": "8653c977362249d8c39f012ad6f413099a47c366", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -1482,28 +1482,23 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n \n         let total_len = in_len as u64 * 2;\n \n-        let (vector, indirect) = match args {\n+        let vector = match args {\n             Some(args) => {\n                 match consts::const_expr(bcx.ccx(), &args[2], substs, None,\n                                          // this should probably help simd error reporting\n                                          consts::TrueConst::Yes) {\n-                    Ok((vector, _)) => (vector, false),\n+                    Ok((vector, _)) => vector,\n                     Err(err) => bcx.sess().span_fatal(span, &err.description()),\n                 }\n             }\n-            None => (llargs[2], !type_is_immediate(bcx.ccx(), arg_tys[2]))\n+            None => llargs[2]\n         };\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = if indirect {\n-                    Load(bcx, StructGEP(bcx, vector, i))\n-                } else {\n-                    const_get_elt(vector, &[i as libc::c_uint])\n-                };\n-                let c = const_to_opt_uint(val);\n-                match c {\n+                let val = const_get_elt(vector, &[i as libc::c_uint]);\n+                match const_to_opt_uint(val) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None"}, {"sha": "e605ef81c587f1cb60e6e1285de83719649bd10e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -26,6 +26,7 @@ use glue;\n use type_::Type;\n \n use super::{MirContext, TempRef, drop};\n+use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n@@ -114,9 +115,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n                 let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n-                    let llval = self.trans_constval(&bcx, value, switch_ty).immediate();\n+                    let val = Const::from_constval(bcx.ccx(), value.clone(), switch_ty);\n                     let llbb = self.llblock(*target);\n-                    build::AddCase(switch, llval, llbb)\n+                    build::AddCase(switch, val.llval, llbb)\n                 }\n             }\n \n@@ -240,8 +241,30 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     (&args[..], None)\n                 };\n \n+                let is_shuffle = intrinsic.map_or(false, |name| {\n+                    name.starts_with(\"simd_shuffle\")\n+                });\n                 let mut idx = 0;\n                 for arg in first_args {\n+                    // The indices passed to simd_shuffle* in the\n+                    // third argument must be constant. This is\n+                    // checked by const-qualification, which also\n+                    // promotes any complex rvalues to constants.\n+                    if is_shuffle && idx == 2 {\n+                        match *arg {\n+                            mir::Operand::Consume(_) => {\n+                                span_bug!(terminator.span,\n+                                          \"shuffle indices must be constant\");\n+                            }\n+                            mir::Operand::Constant(ref constant) => {\n+                                let val = self.trans_constant(&bcx, constant);\n+                                llargs.push(val.llval);\n+                                idx += 1;\n+                                continue;\n+                            }\n+                        }\n+                    }\n+\n                     let val = self.trans_operand(&bcx, arg).val;\n                     self.trans_argument(&bcx, val, &mut llargs, &fn_ty,\n                                         &mut idx, &mut callee.data);"}, {"sha": "9320617983772e180510c2995b77705d3d5009ff", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 786, "deletions": 71, "changes": 857, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,62 +8,59 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n-use rustc::ty::{Ty, TypeFoldable};\n+use llvm::{self, ValueRef};\n use rustc::middle::const_val::ConstVal;\n+use rustc_const_eval::ErrKind;\n use rustc_const_math::ConstInt::*;\n-use rustc_const_eval::lookup_const_by_id;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::repr as mir;\n-use abi;\n-use common::{self, BlockAndBuilder, C_bool, C_bytes, C_floating_f64, C_integral,\n-                    C_str_slice, C_undef};\n-use consts;\n-use datum;\n-use expr;\n+use rustc::mir::tcx::LvalueTy;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::cast::{CastTy, IntTy};\n+use rustc::ty::subst::Substs;\n+use {abi, adt, base, Disr};\n+use callee::Callee;\n+use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n+use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n+use consts::{self, ConstEvalFailure, TrueConst, to_const_int};\n+use monomorphize::{self, Instance};\n use type_of;\n use type_::Type;\n+use value::Value;\n \n-use super::operand::{OperandRef, OperandValue};\n-use super::MirContext;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n+use std::ptr;\n \n-impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    pub fn trans_constval(&mut self,\n-                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                          cv: &ConstVal,\n-                          ty: Ty<'tcx>)\n-                          -> OperandRef<'tcx>\n-    {\n-        let ccx = bcx.ccx();\n-        let val = self.trans_constval_inner(bcx, cv, ty);\n-        let val = if common::type_is_immediate(ccx, ty) {\n-            OperandValue::Immediate(val)\n-        } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-            let data = common::const_get_elt(val, &[abi::FAT_PTR_ADDR as u32]);\n-            let extra = common::const_get_elt(val, &[abi::FAT_PTR_EXTRA as u32]);\n-            OperandValue::FatPtr(data, extra)\n-        } else {\n-            OperandValue::Ref(val)\n-        };\n+use super::operand::{OperandRef, OperandValue};\n+use super::MirContext;\n \n-        assert!(!ty.has_erasable_regions());\n+/// A sized constant rvalue.\n+/// The LLVM type might not be the same for a single Rust type,\n+/// e.g. each enum variant would have its own LLVM struct type.\n+#[derive(Copy, Clone)]\n+pub struct Const<'tcx> {\n+    pub llval: ValueRef,\n+    pub ty: Ty<'tcx>\n+}\n \n-        OperandRef {\n-            ty: ty,\n-            val: val\n+impl<'tcx> Const<'tcx> {\n+    pub fn new(llval: ValueRef, ty: Ty<'tcx>) -> Const<'tcx> {\n+        Const {\n+            llval: llval,\n+            ty: ty\n         }\n     }\n \n-    /// Translate ConstVal into a bare LLVM ValueRef.\n-    fn trans_constval_inner(&mut self,\n-                            bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                            cv: &ConstVal,\n-                            ty: Ty<'tcx>)\n-                            -> ValueRef\n-    {\n-        let ccx = bcx.ccx();\n+    /// Translate ConstVal into a LLVM constant value.\n+    pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n+                             cv: ConstVal,\n+                             ty: Ty<'tcx>)\n+                             -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n-        match *cv {\n+        let val = match cv {\n             ConstVal::Float(v) => C_floating_f64(v, llty),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n@@ -93,51 +90,769 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n             ConstVal::Dummy => bug!(),\n+        };\n+\n+        assert!(!ty.has_erasable_regions());\n+\n+        Const::new(val, ty)\n+    }\n+\n+    fn get_fat_ptr(&self) -> (ValueRef, ValueRef) {\n+        (const_get_elt(self.llval, &[abi::FAT_PTR_ADDR as u32]),\n+         const_get_elt(self.llval, &[abi::FAT_PTR_EXTRA as u32]))\n+    }\n+\n+    fn as_lvalue(&self) -> ConstLvalue<'tcx> {\n+        ConstLvalue {\n+            base: Base::Value(self.llval),\n+            llextra: ptr::null_mut(),\n+            ty: self.ty\n+        }\n+    }\n+\n+    pub fn to_operand<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> OperandRef<'tcx> {\n+        let llty = type_of::immediate_type_of(ccx, self.ty);\n+        let llvalty = val_ty(self.llval);\n+\n+        let val = if common::type_is_fat_ptr(ccx.tcx(), self.ty) {\n+            let (data, extra) = self.get_fat_ptr();\n+            OperandValue::FatPtr(data, extra)\n+        } else if common::type_is_immediate(ccx, self.ty) && llty == llvalty {\n+            // If the types match, we can use the value directly.\n+            OperandValue::Immediate(self.llval)\n+        } else {\n+            // Otherwise, or if the value is not immediate, we create\n+            // a constant LLVM global and cast its address if necessary.\n+            let align = type_of::align_of(ccx, self.ty);\n+            let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n+            OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()))\n+        };\n+\n+        OperandRef {\n+            val: val,\n+            ty: self.ty\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum Base {\n+    /// A constant value without an unique address.\n+    Value(ValueRef),\n+\n+    /// String literal base pointer (cast from array).\n+    Str(ValueRef),\n+\n+    /// The address of a static.\n+    Static(ValueRef)\n+}\n+\n+/// An lvalue as seen from a constant.\n+#[derive(Copy, Clone)]\n+struct ConstLvalue<'tcx> {\n+    base: Base,\n+    llextra: ValueRef,\n+    ty: Ty<'tcx>\n+}\n+\n+impl<'tcx> ConstLvalue<'tcx> {\n+    fn to_const(&self, span: Span) -> Const<'tcx> {\n+        match self.base {\n+            Base::Value(val) => Const::new(val, self.ty),\n+            Base::Str(ptr) => {\n+                span_bug!(span, \"loading from `str` ({:?}) in constant\",\n+                          Value(ptr))\n+            }\n+            Base::Static(val) => {\n+                span_bug!(span, \"loading from `static` ({:?}) in constant\",\n+                          Value(val))\n+            }\n+        }\n+    }\n+\n+    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+        match self.ty.sty {\n+            ty::TyArray(_, n) => C_uint(ccx, n),\n+            ty::TySlice(_) | ty::TyStr => {\n+                assert!(self.llextra != ptr::null_mut());\n+                self.llextra\n+            }\n+            _ => bug!(\"unexpected type `{}` in ConstLvalue::len\", self.ty)\n+        }\n+    }\n+}\n+\n+/// Machinery for translating a constant's MIR to LLVM values.\n+/// FIXME(eddyb) use miri and lower its allocations to LLVM.\n+struct MirConstContext<'a, 'tcx: 'a> {\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    mir: &'a mir::Mir<'tcx>,\n+\n+    /// Type parameters for const fn and associated constants.\n+    substs: &'tcx Substs<'tcx>,\n+\n+    /// Arguments passed to a const fn.\n+    args: Vec<Const<'tcx>>,\n+\n+    /// Variable values - specifically, argument bindings of a const fn.\n+    vars: Vec<Option<Const<'tcx>>>,\n+\n+    /// Temp values.\n+    temps: Vec<Option<Const<'tcx>>>,\n+\n+    /// Value assigned to Return, which is the resulting constant.\n+    return_value: Option<Const<'tcx>>\n+}\n+\n+\n+impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n+    fn new(ccx: &'a CrateContext<'a, 'tcx>,\n+           mir: &'a mir::Mir<'tcx>,\n+           substs: &'tcx Substs<'tcx>,\n+           args: Vec<Const<'tcx>>)\n+           -> MirConstContext<'a, 'tcx> {\n+        MirConstContext {\n+            ccx: ccx,\n+            mir: mir,\n+            substs: substs,\n+            args: args,\n+            vars: vec![None; mir.var_decls.len()],\n+            temps: vec![None; mir.temp_decls.len()],\n+            return_value: None\n         }\n     }\n \n+    fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n+                 mut instance: Instance<'tcx>,\n+                 args: Vec<Const<'tcx>>)\n+                 -> Result<Const<'tcx>, ConstEvalFailure> {\n+        // Try to resolve associated constants.\n+        if instance.substs.self_ty().is_some() {\n+            // Only trait items can have a Self parameter.\n+            let trait_item = ccx.tcx().impl_or_trait_item(instance.def);\n+            let trait_id = trait_item.container().id();\n+            let substs = instance.substs;\n+            let trait_ref = ty::Binder(substs.to_trait_ref(ccx.tcx(), trait_id));\n+            let vtable = common::fulfill_obligation(ccx, DUMMY_SP, trait_ref);\n+            if let traits::VtableImpl(vtable_impl) = vtable {\n+                let name = ccx.tcx().item_name(instance.def);\n+                for ac in ccx.tcx().associated_consts(vtable_impl.impl_def_id) {\n+                    if ac.name == name {\n+                        instance = Instance::new(ac.def_id, vtable_impl.substs);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mir = ccx.get_mir(instance.def).unwrap_or_else(|| {\n+            bug!(\"missing constant MIR for {}\", instance)\n+        });\n+        MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n+    }\n+\n+    fn monomorphize<T>(&self, value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        monomorphize::apply_param_substs(self.ccx.tcx(),\n+                                         self.substs,\n+                                         value)\n+    }\n+\n+    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalFailure> {\n+        let tcx = self.ccx.tcx();\n+        let mut bb = mir::START_BLOCK;\n+        loop {\n+            let data = self.mir.basic_block_data(bb);\n+            for statement in &data.statements {\n+                match statement.kind {\n+                    mir::StatementKind::Assign(ref dest, ref rvalue) => {\n+                        let ty = self.mir.lvalue_ty(tcx, dest);\n+                        let ty = self.monomorphize(&ty).to_ty(tcx);\n+                        let value = self.const_rvalue(rvalue, ty, statement.span)?;\n+                        self.store(dest, value, statement.span);\n+                    }\n+                }\n+            }\n+\n+            let terminator = data.terminator();\n+            let span = terminator.span;\n+            bb = match terminator.kind {\n+                mir::TerminatorKind::Drop { target, .. } | // No dropping.\n+                mir::TerminatorKind::Goto { target } => target,\n+                mir::TerminatorKind::Return => {\n+                    return Ok(self.return_value.unwrap_or_else(|| {\n+                        span_bug!(span, \"no returned value in constant\");\n+                    }))\n+                }\n+\n+                // This is only supported to make bounds checking work.\n+                mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n+                    let cond = self.const_operand(cond, span)?;\n+                    if common::const_to_uint(cond.llval) != 0 {\n+                        true_bb\n+                    } else {\n+                        false_bb\n+                    }\n+                }\n+\n+                mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n+                    let fn_ty = self.mir.operand_ty(tcx, func);\n+                    let fn_ty = self.monomorphize(&fn_ty);\n+                    let instance = match fn_ty.sty {\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            Instance::new(def_id, substs)\n+                        }\n+                        _ => span_bug!(span, \"calling {:?} (of type {}) in constant\",\n+                                       func, fn_ty)\n+                    };\n+\n+                    // Indexing OOB doesn't call a const fn, handle it.\n+                    if Some(instance.def) == tcx.lang_items.panic_bounds_check_fn() {\n+                        consts::const_err(self.ccx, span,\n+                                          Err(ErrKind::IndexOutOfBounds),\n+                                          TrueConst::Yes)?;\n+                    }\n+\n+                    let args = args.iter().map(|arg| {\n+                        self.const_operand(arg, span)\n+                    }).collect::<Result<Vec<_>, _>>()?;\n+                    let value = MirConstContext::trans_def(self.ccx, instance, args)?;\n+                    if let Some((ref dest, target)) = *destination {\n+                        self.store(dest, value, span);\n+                        target\n+                    } else {\n+                        span_bug!(span, \"diverging {:?} in constant\", terminator.kind)\n+                    }\n+                }\n+                _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n+            };\n+        }\n+    }\n+\n+    fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n+        let dest = match *dest {\n+            mir::Lvalue::Var(index) => &mut self.vars[index as usize],\n+            mir::Lvalue::Temp(index) => &mut self.temps[index as usize],\n+            mir::Lvalue::ReturnPointer => &mut self.return_value,\n+            _ => span_bug!(span, \"assignment to {:?} in constant\", dest)\n+        };\n+        *dest = Some(value);\n+    }\n+\n+    fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n+                    -> Result<ConstLvalue<'tcx>, ConstEvalFailure> {\n+        let tcx = self.ccx.tcx();\n+        let lvalue = match *lvalue {\n+            mir::Lvalue::Var(index) => {\n+                self.vars[index as usize].unwrap_or_else(|| {\n+                    span_bug!(span, \"var{} not initialized\", index)\n+                }).as_lvalue()\n+            }\n+            mir::Lvalue::Temp(index) => {\n+                self.temps[index as usize].unwrap_or_else(|| {\n+                    span_bug!(span, \"tmp{} not initialized\", index)\n+                }).as_lvalue()\n+            }\n+            mir::Lvalue::Arg(index) => self.args[index as usize].as_lvalue(),\n+            mir::Lvalue::Static(def_id) => {\n+                ConstLvalue {\n+                    base: Base::Static(consts::get_static(self.ccx, def_id).val),\n+                    llextra: ptr::null_mut(),\n+                    ty: self.mir.lvalue_ty(tcx, lvalue).to_ty(tcx)\n+                }\n+            }\n+            mir::Lvalue::ReturnPointer => {\n+                span_bug!(span, \"accessing Lvalue::ReturnPointer in constant\")\n+            }\n+            mir::Lvalue::Projection(ref projection) => {\n+                let tr_base = self.const_lvalue(&projection.base, span)?;\n+                let projected_ty = LvalueTy::Ty { ty: tr_base.ty }\n+                    .projection_ty(tcx, &projection.elem);\n+                let base = tr_base.to_const(span);\n+                let projected_ty = self.monomorphize(&projected_ty).to_ty(tcx);\n+                let is_sized = common::type_is_sized(tcx, projected_ty);\n+\n+                let (projected, llextra) = match projection.elem {\n+                    mir::ProjectionElem::Deref => {\n+                        let (base, extra) = if is_sized {\n+                            (base.llval, ptr::null_mut())\n+                        } else {\n+                            base.get_fat_ptr()\n+                        };\n+                        if self.ccx.statics().borrow().contains_key(&base) {\n+                            (Base::Static(base), extra)\n+                        } else if let ty::TyStr = projected_ty.sty {\n+                            (Base::Str(base), extra)\n+                        } else {\n+                            let val = consts::load_const(self.ccx, base, projected_ty);\n+                            if val.is_null() {\n+                                span_bug!(span, \"dereference of non-constant pointer `{:?}`\",\n+                                          Value(base));\n+                            }\n+                            (Base::Value(val), extra)\n+                        }\n+                    }\n+                    mir::ProjectionElem::Field(ref field, _) => {\n+                        let base_repr = adt::represent_type(self.ccx, tr_base.ty);\n+                        let llprojected = adt::const_get_field(&base_repr, base.llval,\n+                                                               Disr(0), field.index());\n+                        let llextra = if is_sized {\n+                            ptr::null_mut()\n+                        } else {\n+                            tr_base.llextra\n+                        };\n+                        (Base::Value(llprojected), llextra)\n+                    }\n+                    mir::ProjectionElem::Index(ref index) => {\n+                        let llindex = self.const_operand(index, span)?.llval;\n+\n+                        let iv = if let Some(iv) = common::const_to_opt_uint(llindex) {\n+                            iv\n+                        } else {\n+                            span_bug!(span, \"index is not an integer-constant expression\")\n+                        };\n+                        (Base::Value(const_get_elt(base.llval, &[iv as u32])),\n+                         ptr::null_mut())\n+                    }\n+                    _ => span_bug!(span, \"{:?} in constant\", projection.elem)\n+                };\n+                ConstLvalue {\n+                    base: projected,\n+                    llextra: llextra,\n+                    ty: projected_ty\n+                }\n+            }\n+        };\n+        Ok(lvalue)\n+    }\n+\n+    fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n+                     -> Result<Const<'tcx>, ConstEvalFailure> {\n+        match *operand {\n+            mir::Operand::Consume(ref lvalue) => {\n+                Ok(self.const_lvalue(lvalue, span)?.to_const(span))\n+            }\n+\n+            mir::Operand::Constant(ref constant) => {\n+                let ty = self.monomorphize(&constant.ty);\n+                match constant.literal.clone() {\n+                    mir::Literal::Item { def_id, substs } => {\n+                        // Shortcut for zero-sized types, including function item\n+                        // types, which would not work with MirConstContext.\n+                        if common::type_is_zero_size(self.ccx, ty) {\n+                            let llty = type_of::type_of(self.ccx, ty);\n+                            return Ok(Const::new(C_null(llty), ty));\n+                        }\n+\n+                        let substs = self.ccx.tcx().mk_substs(self.monomorphize(substs));\n+                        let instance = Instance::new(def_id, substs);\n+                        MirConstContext::trans_def(self.ccx, instance, vec![])\n+                    }\n+                    mir::Literal::Promoted { index } => {\n+                        let mir = &self.mir.promoted[index];\n+                        MirConstContext::new(self.ccx, mir, self.substs, vec![]).trans()\n+                    }\n+                    mir::Literal::Value { value } => {\n+                        Ok(Const::from_constval(self.ccx, value, ty))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n+                    dest_ty: Ty<'tcx>, span: Span)\n+                    -> Result<Const<'tcx>, ConstEvalFailure> {\n+        let tcx = self.ccx.tcx();\n+        let val = match *rvalue {\n+            mir::Rvalue::Use(ref operand) => self.const_operand(operand, span)?,\n+\n+            mir::Rvalue::Repeat(ref elem, ref count) => {\n+                let elem = self.const_operand(elem, span)?;\n+                let size = count.value.as_u64(tcx.sess.target.uint_type);\n+                let fields = vec![elem.llval; size as usize];\n+\n+                let llunitty = type_of::type_of(self.ccx, elem.ty);\n+                // If the array contains enums, an LLVM array won't work.\n+                let val = if val_ty(elem.llval) == llunitty {\n+                    C_array(llunitty, &fields)\n+                } else {\n+                    C_struct(self.ccx, &fields, false)\n+                };\n+                Const::new(val, dest_ty)\n+            }\n+\n+            mir::Rvalue::Aggregate(ref kind, ref operands) => {\n+                let fields = operands.iter().map(|operand| {\n+                    Ok(self.const_operand(operand, span)?.llval)\n+                }).collect::<Result<Vec<_>, _>>()?;\n+\n+                // FIXME Shouldn't need to manually trigger closure instantiations.\n+                if let mir::AggregateKind::Closure(def_id, substs) = *kind {\n+                    use rustc::hir;\n+                    use syntax::ast::DUMMY_NODE_ID;\n+                    use syntax::ptr::P;\n+                    use closure;\n+\n+                    closure::trans_closure_expr(closure::Dest::Ignore(self.ccx),\n+                                                &hir::FnDecl {\n+                                                    inputs: P::new(),\n+                                                    output: hir::NoReturn(DUMMY_SP),\n+                                                    variadic: false\n+                                                },\n+                                                &hir::Block {\n+                                                    stmts: P::new(),\n+                                                    expr: None,\n+                                                    id: DUMMY_NODE_ID,\n+                                                    rules: hir::DefaultBlock,\n+                                                    span: DUMMY_SP\n+                                                },\n+                                                DUMMY_NODE_ID, def_id,\n+                                                &self.monomorphize(substs));\n+                }\n+\n+                let val = if let mir::AggregateKind::Adt(adt_def, index, _) = *kind {\n+                    let repr = adt::represent_type(self.ccx, dest_ty);\n+                    let disr = Disr::from(adt_def.variants[index].disr_val);\n+                    adt::trans_const(self.ccx, &repr, disr, &fields)\n+                } else if let ty::TyArray(elem_ty, _) = dest_ty.sty {\n+                    let llunitty = type_of::type_of(self.ccx, elem_ty);\n+                    // If the array contains enums, an LLVM array won't work.\n+                    if fields.iter().all(|&f| val_ty(f) == llunitty) {\n+                        C_array(llunitty, &fields)\n+                    } else {\n+                        C_struct(self.ccx, &fields, false)\n+                    }\n+                } else {\n+                    C_struct(self.ccx, &fields, false)\n+                };\n+                Const::new(val, dest_ty)\n+            }\n+\n+            mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n+                let operand = self.const_operand(source, span)?;\n+                let cast_ty = self.monomorphize(&cast_ty);\n+\n+                let val = match *kind {\n+                    mir::CastKind::ReifyFnPointer => {\n+                        match operand.ty.sty {\n+                            ty::TyFnDef(def_id, substs, _) => {\n+                                Callee::def(self.ccx, def_id, substs)\n+                                    .reify(self.ccx).val\n+                            }\n+                            _ => {\n+                                span_bug!(span, \"{} cannot be reified to a fn ptr\",\n+                                          operand.ty)\n+                            }\n+                        }\n+                    }\n+                    mir::CastKind::UnsafeFnPointer => {\n+                        // this is a no-op at the LLVM level\n+                        operand.llval\n+                    }\n+                    mir::CastKind::Unsize => {\n+                        // unsize targets other than to a fat pointer currently\n+                        // can't be in constants.\n+                        assert!(common::type_is_fat_ptr(tcx, cast_ty));\n+\n+                        let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n+                            .expect(\"consts: unsizing got non-pointer type\").ty;\n+                        let (base, old_info) = if !common::type_is_sized(tcx, pointee_ty) {\n+                            // Normally, the source is a thin pointer and we are\n+                            // adding extra info to make a fat pointer. The exception\n+                            // is when we are upcasting an existing object fat pointer\n+                            // to use a different vtable. In that case, we want to\n+                            // load out the original data pointer so we can repackage\n+                            // it.\n+                            let (base, extra) = operand.get_fat_ptr();\n+                            (base, Some(extra))\n+                        } else {\n+                            (operand.llval, None)\n+                        };\n+\n+                        let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n+                            .expect(\"consts: unsizing got non-pointer target type\").ty;\n+                        let ptr_ty = type_of::in_memory_type_of(self.ccx, unsized_ty).ptr_to();\n+                        let base = consts::ptrcast(base, ptr_ty);\n+                        let info = base::unsized_info(self.ccx, pointee_ty,\n+                                                      unsized_ty, old_info);\n+\n+                        if old_info.is_none() {\n+                            let prev_const = self.ccx.const_unsized().borrow_mut()\n+                                                     .insert(base, operand.llval);\n+                            assert!(prev_const.is_none() || prev_const == Some(operand.llval));\n+                        }\n+                        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+                        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+                        C_struct(self.ccx, &[base, info], false)\n+                    }\n+                    mir::CastKind::Misc if common::type_is_immediate(self.ccx, operand.ty) => {\n+                        debug_assert!(common::type_is_immediate(self.ccx, cast_ty));\n+                        let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n+                        let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                        let ll_t_out = type_of::immediate_type_of(self.ccx, cast_ty);\n+                        let llval = operand.llval;\n+                        let signed = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n+                            let repr = adt::represent_type(self.ccx, operand.ty);\n+                            adt::is_discr_signed(&repr)\n+                        } else {\n+                            operand.ty.is_signed()\n+                        };\n+\n+                        unsafe {\n+                            match (r_t_in, r_t_out) {\n+                                (CastTy::Int(_), CastTy::Int(_)) => {\n+                                    let s = signed as llvm::Bool;\n+                                    llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n+                                }\n+                                (CastTy::Int(_), CastTy::Float) => {\n+                                    if signed {\n+                                        llvm::LLVMConstSIToFP(llval, ll_t_out.to_ref())\n+                                    } else {\n+                                        llvm::LLVMConstUIToFP(llval, ll_t_out.to_ref())\n+                                    }\n+                                }\n+                                (CastTy::Float, CastTy::Float) => {\n+                                    llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Float, CastTy::Int(IntTy::I)) => {\n+                                    llvm::LLVMConstFPToSI(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Float, CastTy::Int(_)) => {\n+                                    llvm::LLVMConstFPToUI(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Ptr(_), CastTy::Ptr(_)) |\n+                                (CastTy::FnPtr, CastTy::Ptr(_)) |\n+                                (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n+                                    consts::ptrcast(llval, ll_t_out)\n+                                }\n+                                (CastTy::Int(_), CastTy::Ptr(_)) => {\n+                                    llvm::LLVMConstIntToPtr(llval, ll_t_out.to_ref())\n+                                }\n+                                (CastTy::Ptr(_), CastTy::Int(_)) |\n+                                (CastTy::FnPtr, CastTy::Int(_)) => {\n+                                    llvm::LLVMConstPtrToInt(llval, ll_t_out.to_ref())\n+                                }\n+                                _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n+                            }\n+                        }\n+                    }\n+                    mir::CastKind::Misc => { // Casts from a fat-ptr.\n+                        let ll_cast_ty = type_of::immediate_type_of(self.ccx, cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(self.ccx, operand.ty);\n+                        if common::type_is_fat_ptr(tcx, operand.ty) {\n+                            let (data_ptr, meta_ptr) = operand.get_fat_ptr();\n+                            if common::type_is_fat_ptr(tcx, cast_ty) {\n+                                let ll_cft = ll_cast_ty.field_types();\n+                                let ll_fft = ll_from_ty.field_types();\n+                                let data_cast = consts::ptrcast(data_ptr, ll_cft[0]);\n+                                assert_eq!(ll_cft[1].kind(), ll_fft[1].kind());\n+                                C_struct(self.ccx, &[data_cast, meta_ptr], false)\n+                            } else { // cast to thin-ptr\n+                                // Cast of fat-ptr to thin-ptr is an extraction of data-ptr and\n+                                // pointer-cast of that pointer to desired pointer type.\n+                                consts::ptrcast(data_ptr, ll_cast_ty)\n+                            }\n+                        } else {\n+                            bug!(\"Unexpected non-FatPtr operand\")\n+                        }\n+                    }\n+                };\n+                Const::new(val, cast_ty)\n+            }\n+\n+            mir::Rvalue::Ref(_, bk, ref lvalue) => {\n+                let tr_lvalue = self.const_lvalue(lvalue, span)?;\n+\n+                let ty = tr_lvalue.ty;\n+                let ref_ty = tcx.mk_ref(tcx.mk_region(ty::ReStatic),\n+                    ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() });\n+\n+                let base = match tr_lvalue.base {\n+                    Base::Value(llval) => {\n+                        let align = type_of::align_of(self.ccx, ty);\n+                        if bk == mir::BorrowKind::Mut {\n+                            consts::addr_of_mut(self.ccx, llval, align, \"ref_mut\")\n+                        } else {\n+                            consts::addr_of(self.ccx, llval, align, \"ref\")\n+                        }\n+                    }\n+                    Base::Str(llval) |\n+                    Base::Static(llval) => llval\n+                };\n+\n+                let ptr = if common::type_is_sized(tcx, ty) {\n+                    base\n+                } else {\n+                    C_struct(self.ccx, &[base, tr_lvalue.llextra], false)\n+                };\n+                Const::new(ptr, ref_ty)\n+            }\n+\n+            mir::Rvalue::Len(ref lvalue) => {\n+                let tr_lvalue = self.const_lvalue(lvalue, span)?;\n+                Const::new(tr_lvalue.len(self.ccx), tcx.types.usize)\n+            }\n+\n+            mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs = self.const_operand(lhs, span)?;\n+                let rhs = self.const_operand(rhs, span)?;\n+                let ty = lhs.ty;\n+                let binop_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let (lhs, rhs) = (lhs.llval, rhs.llval);\n+                assert!(!ty.is_simd());\n+                let is_float = ty.is_fp();\n+                let signed = ty.is_signed();\n+\n+                if let (Some(lhs), Some(rhs)) = (to_const_int(lhs, ty, tcx),\n+                                                 to_const_int(rhs, ty, tcx)) {\n+                    let result = match op {\n+                        mir::BinOp::Add => lhs + rhs,\n+                        mir::BinOp::Sub => lhs - rhs,\n+                        mir::BinOp::Mul => lhs * rhs,\n+                        mir::BinOp::Div => lhs / rhs,\n+                        mir::BinOp::Rem => lhs % rhs,\n+                        mir::BinOp::Shl => lhs << rhs,\n+                        mir::BinOp::Shr => lhs >> rhs,\n+                        _ => Ok(lhs)\n+                    };\n+                    consts::const_err(self.ccx, span,\n+                                      result.map_err(ErrKind::Math),\n+                                      TrueConst::Yes)?;\n+                }\n+\n+                let llval = unsafe {\n+                    match op {\n+                        mir::BinOp::Add if is_float => llvm::LLVMConstFAdd(lhs, rhs),\n+                        mir::BinOp::Add             => llvm::LLVMConstAdd(lhs, rhs),\n+\n+                        mir::BinOp::Sub if is_float => llvm::LLVMConstFSub(lhs, rhs),\n+                        mir::BinOp::Sub             => llvm::LLVMConstSub(lhs, rhs),\n+\n+                        mir::BinOp::Mul if is_float => llvm::LLVMConstFMul(lhs, rhs),\n+                        mir::BinOp::Mul             => llvm::LLVMConstMul(lhs, rhs),\n+\n+                        mir::BinOp::Div if is_float => llvm::LLVMConstFDiv(lhs, rhs),\n+                        mir::BinOp::Div if signed   => llvm::LLVMConstSDiv(lhs, rhs),\n+                        mir::BinOp::Div             => llvm::LLVMConstUDiv(lhs, rhs),\n+\n+                        mir::BinOp::Rem if is_float => llvm::LLVMConstFRem(lhs, rhs),\n+                        mir::BinOp::Rem if signed   => llvm::LLVMConstSRem(lhs, rhs),\n+                        mir::BinOp::Rem             => llvm::LLVMConstURem(lhs, rhs),\n+\n+                        mir::BinOp::BitXor => llvm::LLVMConstXor(lhs, rhs),\n+                        mir::BinOp::BitAnd => llvm::LLVMConstAnd(lhs, rhs),\n+                        mir::BinOp::BitOr  => llvm::LLVMConstOr(lhs, rhs),\n+                        mir::BinOp::Shl    => {\n+                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                            llvm::LLVMConstShl(lhs, rhs)\n+                        }\n+                        mir::BinOp::Shr    => {\n+                            let rhs = base::cast_shift_const_rhs(op.to_hir_binop(), lhs, rhs);\n+                            if signed { llvm::LLVMConstAShr(lhs, rhs) }\n+                            else      { llvm::LLVMConstLShr(lhs, rhs) }\n+                        }\n+                        mir::BinOp::Eq | mir::BinOp::Ne |\n+                        mir::BinOp::Lt | mir::BinOp::Le |\n+                        mir::BinOp::Gt | mir::BinOp::Ge => {\n+                            if is_float {\n+                                let cmp = base::bin_op_to_fcmp_predicate(op.to_hir_binop());\n+                                llvm::ConstFCmp(cmp, lhs, rhs)\n+                            } else {\n+                                let cmp = base::bin_op_to_icmp_predicate(op.to_hir_binop(),\n+                                                                         signed);\n+                                llvm::ConstICmp(cmp, lhs, rhs)\n+                            }\n+                        }\n+                    }\n+                };\n+                Const::new(llval, binop_ty)\n+            }\n+\n+            mir::Rvalue::UnaryOp(op, ref operand) => {\n+                let operand = self.const_operand(operand, span)?;\n+                let lloperand = operand.llval;\n+                let llval = match op {\n+                    mir::UnOp::Not => {\n+                        unsafe {\n+                            llvm::LLVMConstNot(lloperand)\n+                        }\n+                    }\n+                    mir::UnOp::Neg => {\n+                        if let Some(cval) = to_const_int(lloperand, operand.ty, tcx) {\n+                            consts::const_err(self.ccx, span,\n+                                              (-cval).map_err(ErrKind::Math),\n+                                              TrueConst::Yes)?;\n+                        }\n+                        let is_float = operand.ty.is_fp();\n+                        unsafe {\n+                            if is_float {\n+                                llvm::LLVMConstFNeg(lloperand)\n+                            } else {\n+                                llvm::LLVMConstNeg(lloperand)\n+                            }\n+                        }\n+                    }\n+                };\n+                Const::new(llval, operand.ty)\n+            }\n+\n+            _ => span_bug!(span, \"{:?} in constant\", rvalue)\n+        };\n+\n+        Ok(val)\n+    }\n+}\n+\n+impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_constant(&mut self,\n                           bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n-                          -> OperandRef<'tcx>\n+                          -> Const<'tcx>\n     {\n         let ty = bcx.monomorphize(&constant.ty);\n-        match constant.literal {\n+        let result = match constant.literal.clone() {\n             mir::Literal::Item { def_id, substs } => {\n                 // Shortcut for zero-sized types, including function item\n-                // types, which would not work with lookup_const_by_id.\n+                // types, which would not work with MirConstContext.\n                 if common::type_is_zero_size(bcx.ccx(), ty) {\n                     let llty = type_of::type_of(bcx.ccx(), ty);\n-                    return OperandRef {\n-                        val: OperandValue::Immediate(C_undef(llty)),\n-                        ty: ty\n-                    };\n+                    return Const::new(C_null(llty), ty);\n                 }\n \n-                let substs = Some(bcx.monomorphize(substs));\n-                let expr = lookup_const_by_id(bcx.tcx(), def_id, substs)\n-                            .expect(\"def was const, but lookup_const_by_id failed\").0;\n-                // FIXME: this is falling back to translating from HIR. This is not easy to fix,\n-                // because we would have somehow adapt const_eval to work on MIR rather than HIR.\n-                let d = bcx.with_block(|bcx| {\n-                    expr::trans(bcx, expr)\n-                });\n-\n-                let datum = d.datum.to_rvalue_datum(d.bcx, \"\").datum;\n-\n-                match datum.kind.mode {\n-                    datum::RvalueMode::ByValue => {\n-                        OperandRef {\n-                            ty: datum.ty,\n-                            val: OperandValue::Immediate(datum.val)\n-                        }\n-                    }\n-                    datum::RvalueMode::ByRef => self.trans_load(bcx, datum.val, datum.ty)\n-                }\n+                let substs = bcx.tcx().mk_substs(bcx.monomorphize(substs));\n+                let instance = Instance::new(def_id, substs);\n+                MirConstContext::trans_def(bcx.ccx(), instance, vec![])\n+            }\n+            mir::Literal::Promoted { index } => {\n+                let mir = &self.mir.promoted[index];\n+                MirConstContext::new(bcx.ccx(), mir, bcx.fcx().param_substs, vec![]).trans()\n+            }\n+            mir::Literal::Value { value } => {\n+                Ok(Const::from_constval(bcx.ccx(), value, ty))\n             }\n-            mir::Literal::Value { ref value } => {\n-                self.trans_constval(bcx, value, ty)\n+        };\n+\n+        match result {\n+            Ok(v) => v,\n+            Err(ConstEvalFailure::Compiletime(_)) => {\n+                // We've errored, so we don't have to produce working code.\n+                let llty = type_of::type_of(bcx.ccx(), ty);\n+                Const::new(C_undef(llty), ty)\n+            }\n+            Err(ConstEvalFailure::Runtime(err)) => {\n+                span_bug!(constant.span,\n+                          \"MIR constant {:?} results in runtime panic: {}\",\n+                          constant, err.description())\n             }\n         }\n     }\n }\n+\n+\n+pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n+                                -> Result<ValueRef, ConstEvalFailure> {\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    MirConstContext::trans_def(ccx, instance, vec![]).map(|c| c.llval)\n+}"}, {"sha": "e57a5cbc5b8b969c19fde829d946671d6245bf90", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -16,7 +16,7 @@ use abi;\n use adt;\n use base;\n use builder::Builder;\n-use common::{self, BlockAndBuilder, C_uint};\n+use common::{self, BlockAndBuilder, CrateContext, C_uint};\n use consts;\n use machine;\n use mir::drop;\n@@ -56,6 +56,18 @@ impl<'tcx> LvalueRef<'tcx> {\n         }\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n+\n+    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+        let ty = self.ty.to_ty(ccx.tcx());\n+        match ty.sty {\n+            ty::TyArray(_, n) => common::C_uint(ccx, n),\n+            ty::TySlice(_) | ty::TyStr => {\n+                assert!(self.llextra != ptr::null_mut());\n+                self.llextra\n+            }\n+            _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n+        }\n+    }\n }\n \n pub fn get_meta(b: &Builder, fat_ptr: ValueRef) -> ValueRef {\n@@ -71,20 +83,6 @@ pub fn load_fat_ptr(b: &Builder, fat_ptr: ValueRef) -> (ValueRef, ValueRef) {\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n-    pub fn lvalue_len(&mut self,\n-                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                      lvalue: LvalueRef<'tcx>)\n-                      -> ValueRef {\n-        match lvalue.ty.to_ty(bcx.tcx()).sty {\n-            ty::TyArray(_, n) => common::C_uint(bcx.ccx(), n),\n-            ty::TySlice(_) | ty::TyStr => {\n-                assert!(lvalue.llextra != ptr::null_mut());\n-                lvalue.llextra\n-            }\n-            _ => bug!(\"unexpected type in lvalue_len\"),\n-        }\n-    }\n-\n     pub fn trans_lvalue(&mut self,\n                         bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n@@ -190,7 +188,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                          from_end: true,\n                                                          min_length: _ } => {\n                         let lloffset = C_uint(bcx.ccx(), offset);\n-                        let lllen = self.lvalue_len(bcx, tr_base);\n+                        let lllen = tr_base.len(bcx.ccx());\n                         let llindex = bcx.sub(lllen, lloffset);\n                         project_index(self.prepare_index(bcx, llindex))\n                     }"}, {"sha": "b98e04e51c007d41e2a4f37c8b52de176438e1f9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -31,6 +31,8 @@ use basic_block::BasicBlock;\n \n use rustc_data_structures::bitvec::BitVector;\n \n+pub use self::constant::trans_static_initializer;\n+\n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use rustc_mir::traversal;\n "}, {"sha": "fc726a3474f7e6d996b506b08e1cf6306338ee3f", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -140,7 +140,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                self.trans_constant(bcx, constant)\n+                let val = self.trans_constant(bcx, constant);\n+                let operand = val.to_operand(bcx.ccx());\n+                if let OperandValue::Ref(ptr) = operand.val {\n+                    // If this is a OperandValue::Ref to an immediate constant, load it.\n+                    self.trans_load(bcx, ptr, operand.ty)\n+                } else {\n+                    operand\n+                }\n             }\n         }\n     }"}, {"sha": "1236100a4d51c08a1bfe4dab4243984e6352ee03", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -11,8 +11,6 @@\n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use middle::const_val::ConstVal;\n-use rustc_const_math::ConstInt;\n use rustc::mir::repr as mir;\n \n use asm;\n@@ -100,8 +98,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let count = ConstVal::Integral(ConstInt::Usize(count.value));\n-                let size = self.trans_constval(&bcx, &count, bcx.tcx().types.usize).immediate();\n+                let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n+                let size = C_uint(bcx.ccx(), size);\n                 let base = get_dataptr(&bcx, dest.llval);\n                 let bcx = bcx.map_block(|block| {\n                     tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n@@ -405,7 +403,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let operand = OperandRef {\n-                    val: OperandValue::Immediate(self.lvalue_len(&bcx, tr_lvalue)),\n+                    val: OperandValue::Immediate(tr_lvalue.len(bcx.ccx())),\n                     ty: bcx.tcx().types.usize,\n                 };\n                 (bcx, operand)"}, {"sha": "7f01821b00433aa4c507497a5ae1011cdb2b5a12", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -266,7 +266,10 @@ declare_features! (\n     (active, specialization, \"1.7.0\", Some(31844)),\n \n     // pub(restricted) visibilities (RFC 1422)\n-    (active, pub_restricted, \"1.9.0\", Some(32409))\n+    (active, pub_restricted, \"1.9.0\", Some(32409)),\n+\n+     // Allow Drop types in statics/const functions (RFC 1440)\n+    (active, drop_types_in_const, \"1.9.0\", Some(33156))\n );\n \n declare_features! ("}, {"sha": "9dc1899e5a092015829e312424858997ced28002", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -220,6 +220,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -233,6 +234,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n \n@@ -278,6 +280,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n+ \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n "}, {"sha": "1134dbfd1c46c9e74bf5c6e70eadbc5d5ce1b3b2", "filename": "src/test/compile-fail/array_const_index-0.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static A: &'static [i32] = &[];\n-static B: i32 = (&A)[1]; //~ ERROR: const index-expr is out of bounds\n+const A: &'static [i32] = &[];\n+const B: i32 = (&A)[1];\n+//~^ ERROR: array index out of bounds\n \n fn main() {\n     let _ = B;"}, {"sha": "e59895cda442ae1adab9a2a493d2ac7efdf88b28", "filename": "src/test/compile-fail/array_const_index-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n const A: [i32; 0] = [];\n-const B: i32 = A[1]; //~ ERROR: const index-expr is out of bounds\n+const B: i32 = A[1]; //~ ERROR: array index out of bounds\n \n fn main() {\n     let _ = B;"}, {"sha": "7248d0e543bdba2d138ebf308f15da3ef9c15c4e", "filename": "src/test/compile-fail/auxiliary/pub_static_array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpub_static_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpub_static_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Fpub_static_array.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub static ARRAY: &'static [u8] = &[1];\n+pub static ARRAY: [u8; 1] = [1];"}, {"sha": "370cfe9d5501258044fcecb026b631670ad87d7e", "filename": "src/test/compile-fail/check-static-immutable-mut-slices.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-immutable-mut-slices.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -12,5 +12,6 @@\n \n static TEST: &'static mut [isize] = &mut [];\n //~^ ERROR references in statics may only refer to immutable values\n+//~^^ ERROR references in statics may only refer to immutable values\n \n pub fn main() { }"}, {"sha": "df22e2ea4de130aa9d7f338d434f0501f45863b8", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -37,7 +37,7 @@ static STATIC2: SafeEnum = SafeEnum::Variant2(0);\n \n // This one should fail\n static STATIC3: SafeEnum = SafeEnum::Variant3(WithDtor);\n-//~^ ERROR statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n \n \n // This enum will be used to test that variants\n@@ -54,9 +54,9 @@ impl Drop for UnsafeEnum {\n \n \n static STATIC4: UnsafeEnum = UnsafeEnum::Variant5;\n-//~^ ERROR statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n static STATIC5: UnsafeEnum = UnsafeEnum::Variant6(0);\n-//~^ ERROR statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n \n \n struct SafeStruct {\n@@ -71,7 +71,7 @@ static STATIC6: SafeStruct = SafeStruct{field1: SafeEnum::Variant1, field2: Safe\n // field2 has an unsafe value, hence this should fail\n static STATIC7: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n                                         field2: SafeEnum::Variant3(WithDtor)};\n-//~^ ERROR statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n \n // Test variadic constructor for structs. The base struct should be examined\n // as well as every field present in the constructor.\n@@ -84,7 +84,7 @@ static STATIC8: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n static STATIC9: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n                                         ..SafeStruct{field1: SafeEnum::Variant3(WithDtor),\n                                                      field2: SafeEnum::Variant1}};\n-//~^^ ERROR statics are not allowed to have destructors\n+//~^^ ERROR destructors in statics are an unstable feature\n \n struct UnsafeStruct;\n \n@@ -94,7 +94,7 @@ impl Drop for UnsafeStruct {\n \n // Types with destructors are not allowed for statics\n static STATIC10: UnsafeStruct = UnsafeStruct;\n-//~^ ERROR statics are not allowed to have destructor\n+//~^ ERROR destructors in statics are an unstable feature\n \n struct MyOwned;\n \n@@ -105,19 +105,19 @@ static STATIC11: Box<MyOwned> = box MyOwned;\n // to have types with destructors\n // These should fail\n static mut STATIC12: UnsafeStruct = UnsafeStruct;\n-//~^ ERROR mutable statics are not allowed to have destructors\n-//~^^ ERROR statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n+//~^^ ERROR destructors in statics are an unstable feature\n \n static mut STATIC13: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n-//~^ ERROR mutable statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n                                              field2: SafeEnum::Variant3(WithDtor)};\n-//~^ ERROR: statics are not allowed to have destructors\n+//~^ ERROR: destructors in statics are an unstable feature\n \n static mut STATIC14: SafeStruct = SafeStruct {\n-//~^ ERROR mutable statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n     field1: SafeEnum::Variant1,\n     field2: SafeEnum::Variant4(\"str\".to_string())\n-//~^ ERROR method calls in statics are limited to constant inherent methods\n+//~^ ERROR calls in statics are limited to constant functions\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &[\n@@ -131,7 +131,7 @@ static STATIC16: (&'static Box<MyOwned>, &'static Box<MyOwned>) = (\n );\n \n static mut STATIC17: SafeEnum = SafeEnum::Variant1;\n-//~^ ERROR mutable statics are not allowed to have destructors\n+//~^ ERROR destructors in statics are an unstable feature\n \n static STATIC19: Box<isize> =\n     box 3;\n@@ -140,4 +140,5 @@ static STATIC19: Box<isize> =\n pub fn main() {\n     let y = { static x: Box<isize> = box 3; x };\n     //~^ ERROR allocations are not allowed in statics\n+    //~^^ ERROR cannot move out of static item\n }"}, {"sha": "edb85023c9ba78ead594de762b59b4eeeda3ebb2", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -21,6 +21,20 @@ const C: usize = { foo!(); 2 };\n \n const D: usize = { let x = 4; 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n+\n+enum Foo {\n+    Bar = { let x = 1; 3 }\n+    //~^ ERROR: blocks in constants are limited to items and tail expressions\n+    //~^^ ERROR: blocks in constants are limited to items and tail expressions\n+}\n+\n+type Array = [u32; {  let x = 2; 5 }];\n+//~^ ERROR: blocks in constants are limited to items and tail expressions\n+//~^^ ERROR: blocks in constants are limited to items and tail expressions\n \n pub fn main() {\n+    let _: Array = [0; { let x = 3; 5 }];\n+    //~^ ERROR: blocks in constants are limited to items and tail expressions\n+    //~^^ ERROR: blocks in constants are limited to items and tail expressions\n }"}, {"sha": "a25255c010caf4c5bb6f938d6c52c9882704af30", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -19,6 +19,11 @@ fn black_box<T>(_: T) {\n     unimplemented!()\n }\n \n+// Make sure that the two uses get two errors.\n+const FOO: u8 = [5u8][1];\n+//~^ ERROR array index out of bounds\n+//~^^ ERROR array index out of bounds\n+\n #[rustc_no_mir] // FIXME #29769 MIR overflow checking is TBD.\n fn main() {\n     let a = -std::i8::MIN;\n@@ -31,9 +36,11 @@ fn main() {\n     let d = 42u8 - (42u8 + 1);\n     //~^ WARN attempted to subtract with overflow\n     let _e = [5u8][1];\n-    //~^ ERROR const index-expr is out of bounds\n+    //~^ WARN array index out of bounds\n     black_box(a);\n     black_box(b);\n     black_box(c);\n     black_box(d);\n+\n+    black_box((FOO, FOO));\n }"}, {"sha": "c3d5975fe01f679682452f19b8026faad87cff1a", "filename": "src/test/compile-fail/const-fn-destructuring-arg.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-fn-destructuring-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-fn-destructuring-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-destructuring-arg.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -13,6 +13,11 @@\n #![feature(const_fn)]\n \n // no destructuring\n-const fn i((a, b): (u32, u32)) -> u32 { a + b } //~ ERROR: E0022\n+const fn i((\n+            a, //~ ERROR: E0022\n+            b  //~ ERROR: E0022\n+           ): (u32, u32)) -> u32 {\n+    a + b\n+}\n \n fn main() {}"}, {"sha": "45a00de48e71210b697b9b820c00af3a973e8dc9", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,19 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// test that const fn signature and body errors are checked\n-// even in array lengths, which are evaluated before check_const\n-\n #![feature(const_fn)]\n \n const X : usize = 2;\n \n const fn f(x: usize) -> usize {\n-    let mut sum = 0; //~ ERROR: E0016\n-    for i in 0..x { //~ ERROR: E0016\n+    let mut sum = 0;\n+    for i in 0..x {\n         sum += i;\n     }\n-    sum\n+    sum //~ ERROR: E0250\n }\n \n #[allow(unused_variables)]"}, {"sha": "48877a60d25042843486b6ea7214510a19612c41", "filename": "src/test/compile-fail/const-fn-not-safe-for-const.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -29,13 +29,19 @@ static Y: u32 = 0;\n const fn get_Y() -> u32 {\n     Y\n         //~^ ERROR E0013\n-        //~| ERROR cannot refer to other statics by value\n+        //~| ERROR cannot refer to statics by value\n }\n \n const fn get_Y_addr() -> &'static u32 {\n     &Y\n         //~^ ERROR E0013\n }\n \n+const fn get() -> u32 {\n+    let x = 22; //~ ERROR E0016\n+    let y = 44; //~ ERROR E0016\n+    x + y\n+}\n+\n fn main() {\n }"}, {"sha": "a053847e88294cb812cf68d2c65ea04e77d33ec9", "filename": "src/test/compile-fail/const-fn-not-safe-for-const2.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d91f8ab0f58fa123857d96b9e151fc5185f5ff08/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const2.rs?ref=d91f8ab0f58fa123857d96b9e151fc5185f5ff08", "patch": "@@ -1,44 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we can't call random fns in a const fn or do other bad things.\n-\n-#![feature(const_fn)]\n-\n-use std::mem::transmute;\n-\n-fn random() -> u32 { 0 }\n-\n-const fn sub(x: &u32) -> usize {\n-    unsafe { transmute(x) }\n-}\n-\n-const fn sub1() -> u32 {\n-    random()\n-}\n-\n-static Y: u32 = 0;\n-\n-const fn get_Y() -> u32 {\n-    Y\n-}\n-\n-const fn get_Y_addr() -> &'static u32 {\n-    &Y\n-}\n-\n-const fn get() -> u32 {\n-    let x = 22; //~ ERROR E0016\n-    let y = 44; //~ ERROR E0016\n-    x + y\n-}\n-\n-fn main() {\n-}"}, {"sha": "b50468c33fd8bf85c4829edbf9f458c2c746ef70", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n const FOO: &'static[u32] = &[1, 2, 3];\n-const BAR: u32 = FOO[5]; //~ ERROR const index-expr is out of bounds\n+const BAR: u32 = FOO[5]; //~ ERROR array index out of bounds\n \n fn main() {\n     let _ = BAR;"}, {"sha": "98cc2fc0c3e0cf9ec22d2de7dde2b3c5d5e04163", "filename": "src/test/compile-fail/feature-gate-negate-unsigned.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -16,7 +16,9 @@ impl std::ops::Neg for S {\n     fn neg(self) -> u32 { 0 }\n }\n \n-const _MAX: usize = -1;\n+// FIXME(eddyb) move this back to a `-1` literal when\n+// MIR building stops eagerly erroring in that case.\n+const _MAX: usize = -(2 - 1);\n //~^ WARN unary negation of unsigned integer\n //~| ERROR unary negation of unsigned integer\n //~| HELP use a cast or the `!` operator"}, {"sha": "31352c57f1bc3bf566121e1f3be6df87da2c1328", "filename": "src/test/compile-fail/issue-17718-borrow-interior.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-borrow-interior.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -17,7 +17,8 @@ static C: &'static usize = &(A.a);\n \n static D: [usize; 1] = [1];\n static E: usize = D[0];\n-//~^ ERROR: cannot refer to other statics by value\n+//~^ ERROR: cannot refer to the interior of another static\n+//~^^ ERROR: cannot refer to other statics by value\n static F: &'static usize = &D[0];\n //~^ ERROR: cannot refer to the interior of another static\n "}, {"sha": "af356588ed9e7b72f51afe010c6590fad005645f", "filename": "src/test/compile-fail/issue-17718-const-bad-values.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-bad-values.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -10,10 +10,13 @@\n \n const C1: &'static mut [usize] = &mut [];\n //~^ ERROR: references in constants may only refer to immutable values\n+//~| ERROR: references in constants may only refer to immutable values\n \n static mut S: usize = 3;\n-const C2: &'static mut usize = &mut S;\n-//~^ ERROR: constants cannot refer to other statics\n-//~^^ ERROR: references in constants may only refer to immutable values\n+const C2: &'static mut usize = unsafe { &mut S };\n+//~^ ERROR: constants cannot refer to statics\n+//~| ERROR: references in constants may only refer to immutable values\n+//~| ERROR: references in constants may only refer to immutable values\n+//~| ERROR: references in constants may only refer to immutable values\n \n fn main() {}"}, {"sha": "c159168030b8c7b1e50d4aa61406d312bdb708a5", "filename": "src/test/compile-fail/issue-17718-references.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -14,19 +14,19 @@ const C: usize = 1;\n static S: usize = 1;\n \n const T1: &'static usize = &C;\n-const T2: &'static usize = &S; //~ ERROR: constants cannot refer to other statics\n+const T2: &'static usize = &S; //~ ERROR: constants cannot refer to statics\n static T3: &'static usize = &C;\n static T4: &'static usize = &S;\n \n const T5: usize = C;\n-const T6: usize = S; //~ ERROR: constants cannot refer to other statics\n-//~^ cannot refer to other statics\n+const T6: usize = S; //~ ERROR: constants cannot refer to statics\n+//~^ cannot refer to statics\n static T7: usize = C;\n static T8: usize = S; //~ ERROR: cannot refer to other statics by value\n \n const T9: Struct = Struct { a: C };\n-const T10: Struct = Struct { a: S }; //~ ERROR: cannot refer to other statics by value\n-//~^ ERROR: constants cannot refer to other statics\n+const T10: Struct = Struct { a: S }; //~ ERROR: cannot refer to statics by value\n+//~^ ERROR: constants cannot refer to statics\n static T11: Struct = Struct { a: C };\n static T12: Struct = Struct { a: S }; //~ ERROR: cannot refer to other statics by value\n "}, {"sha": "6efe532b5fdf6b45f3b9b16cecb54a766eb08174", "filename": "src/test/compile-fail/issue-18118-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-18118-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-18118-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18118-2.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -12,6 +12,6 @@ pub fn main() {\n     const z: &'static isize = {\n         static p: isize = 3;\n         &p\n-        //~^ ERROR constants cannot refer to other statics, insert an intermediate constant instead\n+        //~^ ERROR constants cannot refer to statics, use a constant instead\n     };\n }"}, {"sha": "3afb34f037bcc6301642652eff6605a97cb047e7", "filename": "src/test/compile-fail/issue-18118.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18118.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -10,6 +10,7 @@\n \n pub fn main() {\n     const z: &'static isize = {\n+        //~^ ERROR blocks in constants are limited to items and tail expressions\n         let p = 3;\n         //~^ ERROR blocks in constants are limited to items and tail expressions\n         &p"}, {"sha": "72fb2a682ebe26c7f8900b49b27c18d1676e5fe1", "filename": "src/test/compile-fail/issue-25901.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-25901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-25901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25901.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -11,7 +11,8 @@\n struct A;\n struct B;\n \n-static S: &'static B = &A; //~ ERROR user-defined dereference operators\n+static S: &'static B = &A;\n+//~^ ERROR calls in statics are limited to constant functions\n \n use std::ops::Deref;\n "}, {"sha": "3b3abc94a4900f391d2746a17dab1e1d74398bac", "filename": "src/test/compile-fail/issue-27895.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -14,8 +14,7 @@ fn main() {\n \n     match i {\n         0...index => println!(\"winner\"),\n-        //~^ ERROR paths in constants may only refer to constants or functions\n-        //~| ERROR non-constant path in constant expression\n+        //~^ ERROR non-constant path in constant expression\n         _ => println!(\"hello\"),\n     }\n }"}, {"sha": "5c697b69c80b1e3cc049291fea55262d39e34127", "filename": "src/test/compile-fail/issue-28113.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28113.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n const X: u8 =\n-    || -> u8 { 5 }() //~ ERROR function calls in constants are limited\n+    || -> u8 { 5 }()\n+    //~^ ERROR calls in constants are limited to constant functions\n ;\n \n fn main() {}"}, {"sha": "58bdff6c0414b809562330b194f40a17bc04ad3d", "filename": "src/test/compile-fail/issue-9243.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-9243.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -10,11 +10,12 @@\n \n // Regression test for issue 9243\n \n-struct Test {\n+pub struct Test {\n     mem: isize,\n }\n \n-pub static g_test: Test = Test {mem: 0}; //~ ERROR statics are not allowed to have destructors\n+pub static g_test: Test = Test {mem: 0};\n+//~^ ERROR destructors in statics are an unstable feature\n \n impl Drop for Test {\n     fn drop(&mut self) {}"}, {"sha": "ee88168515d39f5a7319f21a7527177c3584e985", "filename": "src/test/compile-fail/non-constant-in-const-path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -12,7 +12,6 @@ fn main() {\n     let x = 0;\n     match 1 {\n         0 ... x => {}\n-        //~^ ERROR non-constant path in constant expr\n-        //~| ERROR paths in constants may only refer to constants or functions\n+        //~^ ERROR non-constant path in constant expression\n     };\n }"}, {"sha": "d101432f6d124f141400be02e66028da7ce22b4e", "filename": "src/test/compile-fail/static-array-across-crate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fstatic-array-across-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fstatic-array-across-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-array-across-crate.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -17,4 +17,11 @@ use array::ARRAY;\n static X: &'static u8 = &ARRAY[0];\n //~^ ERROR: cannot refer to the interior of another static, use a constant\n \n+static Y: &'static u8 = &(&ARRAY)[0];\n+//~^ ERROR: cannot refer to the interior of another static, use a constant\n+\n+static Z: u8 = (&ARRAY)[0];\n+//~^ ERROR: cannot refer to the interior of another static, use a constant\n+//~^^ ERROR: cannot refer to other statics by value\n+\n pub fn main() {}"}, {"sha": "9b83c42609aa5cf39cc43feeb6d03ea580c88a0c", "filename": "src/test/compile-fail/static-mut-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-mut-not-constant.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -12,6 +12,6 @@\n \n static mut a: Box<isize> = box 3;\n //~^ ERROR allocations are not allowed in statics\n-//~^^ ERROR mutable statics are not allowed to have boxes\n+//~^^ ERROR destructors in statics are an unstable feature\n \n fn main() {}"}, {"sha": "600df1c778befad58f1caa03658cb56d98b32f94", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -18,21 +18,19 @@ extern crate rustc_plugin;\n extern crate rustc_const_math;\n extern crate syntax;\n \n-use rustc::mir::transform::{self, MirPass};\n+use rustc::mir::transform::{self, MirPass, MirSource};\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_math::ConstInt;\n use rustc_plugin::Registry;\n \n-use syntax::ast::NodeId;\n-\n struct Pass;\n \n impl transform::Pass for Pass {}\n impl<'tcx> MirPass<'tcx> for Pass {\n-    fn run_pass(&mut self, _: &ty::TyCtxt<'tcx>, _: NodeId, mir: &mut Mir<'tcx>) {\n+    fn run_pass(&mut self, _: &ty::TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}, {"sha": "6b3970e4f1997adbdf6b6f43ebef601bc421cd53", "filename": "src/test/run-pass/const-autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-autoderef.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n \n-static A: [u8; 1] = ['h' as u8];\n-static B: u8 = (&A)[0];\n-static C: &'static &'static &'static &'static [u8; 1] = & & & &A;\n-static D: u8 = (&C)[0];\n+const A: [u8; 1] = ['h' as u8];\n+const B: u8 = (&A)[0];\n+const C: &'static &'static &'static &'static [u8; 1] = & & & &A;\n+const D: u8 = (&C)[0];\n \n pub fn main() {\n     assert_eq!(B, A[0]);"}, {"sha": "f58bf4fc39fecc618de72166d0b9d1f788e268a3", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,17 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n-\n-// ignore-pretty : (#23623) problems when  ending with // comments\n-\n use std::{str, string};\n \n const A: [u8; 2] = ['h' as u8, 'i' as u8];\n const B: &'static [u8; 2] = &A;\n const C: *const u8 = B as *const u8;\n \n-#[rustc_no_mir] // FIXME #27840 MIR can't do rvalue promotion yet.\n pub fn main() {\n     unsafe {\n         let foo = &A as *const u8;"}, {"sha": "4e9c0bce646e6f98782f4b72b85522eb7dfff927", "filename": "src/test/run-pass/mir_constval_adts.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_constval_adts.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -14,6 +14,7 @@ struct Point {\n     _x: i32,\n     _y: i32,\n }\n+\n const STRUCT: Point = Point { _x: 42, _y: 42 };\n const TUPLE1: (i32, i32) = (42, 42);\n const TUPLE2: (&'static str, &'static str) = (\"hello\",\"world\");\n@@ -26,7 +27,19 @@ fn mir() -> (Point, (i32, i32), (&'static str, &'static str)){\n     (struct1, tuple1, tuple2)\n }\n \n+#[derive(PartialEq, Eq, Debug)]\n+struct Newtype<T>(T);\n+\n+const NEWTYPE: Newtype<&'static str> = Newtype(\"foobar\");\n+\n+#[rustc_mir]\n+fn test_promoted_newtype_str_ref() {\n+    let x = &NEWTYPE;\n+    assert_eq!(x, &Newtype(\"foobar\"));\n+}\n+\n fn main(){\n     assert_eq!(mir(), (STRUCT, TUPLE1, TUPLE2));\n+    test_promoted_newtype_str_ref();\n }\n "}, {"sha": "a632f00d9ee5f5d1cbca7ccd5626fac7e99bde80", "filename": "src/test/run-pass/mir_raw_fat_ptr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_raw_fat_ptr.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -121,7 +121,6 @@ impl<T> Foo for T {\n \n struct S<T:?Sized>(u32, T);\n \n-#[rustc_no_mir] // FIXME #27840 MIR can't do rvalue promotion yet.\n fn main() {\n     let array = [0,1,2,3,4];\n     let array2 = [5,6,7,8,9];"}, {"sha": "5cb57b63ada2c24e50c8d60e971d783c1909ee91", "filename": "src/test/run-pass/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-elements.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(repr_simd, rustc_attrs, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics)]\n \n // ignore-pretty : (#23623) problems when  ending with // comments\n \n@@ -52,7 +52,6 @@ macro_rules! all_eq {\n     }}\n }\n \n-#[rustc_no_mir] // FIXME #27840 MIR doesn't handle shuffle constants.\n fn main() {\n     let x2 = i32x2(20, 21);\n     let x3 = i32x3(30, 31, 32);"}, {"sha": "a9e6c454ffa6f0bab9018699ff9c4b1fed2641ad", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec22171e6053c640293067418ea1901cb1c7df1/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=1ec22171e6053c640293067418ea1901cb1c7df1", "patch": "@@ -261,6 +261,11 @@ pub fn run_tests(config: &Config) {\n         _ => { /* proceed */ }\n     }\n \n+    // FIXME(#33435) Avoid spurious failures in codegen-units/partitioning tests.\n+    if let Mode::CodegenUnits = config.mode {\n+        let _ = fs::remove_dir_all(\"tmp/partitioning-tests\");\n+    }\n+\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n     // sadly osx needs some file descriptor limits raised for running tests in"}]}