{"sha": "80a96467ec5675e9f69683b5c075a8b15950c341", "node_id": "C_kwDOAAsO6NoAKDgwYTk2NDY3ZWM1Njc1ZTlmNjk2ODNiNWMwNzVhOGIxNTk1MGMzNDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T17:58:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T17:58:12Z"}, "message": "Auto merge of #104945 - GuillaumeGomez:rollup-ygzbpbe, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #104786 (Use the power of adding helper function to simplify code w/ `Mutability`)\n - #104788 (Do not record unresolved const vars in generator interior)\n - #104909 (Rename `normalize_opaque_types` to `reveal_opaque_types_in_bounds`)\n - #104921 (Remove unnecessary binder from `get_impl_future_output_ty`)\n - #104924 (jsondoclint: Accept trait alias is places where trait expected.)\n - #104928 (rustdoc: use flexbox CSS to align sidebar button instead of position)\n - #104943 (jsondoclint: Handle using enum variants and glob using enums.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9bf8143f224eb4e8310a771dcb76648c43880c83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bf8143f224eb4e8310a771dcb76648c43880c83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a96467ec5675e9f69683b5c075a8b15950c341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a96467ec5675e9f69683b5c075a8b15950c341", "html_url": "https://github.com/rust-lang/rust/commit/80a96467ec5675e9f69683b5c075a8b15950c341", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a96467ec5675e9f69683b5c075a8b15950c341/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a1c023c0784ffbcf4dd57cf4618d208bccae69", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a1c023c0784ffbcf4dd57cf4618d208bccae69", "html_url": "https://github.com/rust-lang/rust/commit/c3a1c023c0784ffbcf4dd57cf4618d208bccae69"}, {"sha": "95e63560a00d364166d6b4891e23cd44a27670c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/95e63560a00d364166d6b4891e23cd44a27670c8", "html_url": "https://github.com/rust-lang/rust/commit/95e63560a00d364166d6b4891e23cd44a27670c8"}], "stats": {"total": 763, "additions": 445, "deletions": 318}, "files": [{"sha": "b48a7d29f509723272a4dc77f887edf9cf610fbc", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -775,8 +775,9 @@ pub enum PatKind {\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n-    Mut,\n+    // N.B. Order is deliberate, so that Not < Mut\n     Not,\n+    Mut,\n }\n \n impl Mutability {\n@@ -787,12 +788,39 @@ impl Mutability {\n         }\n     }\n \n-    pub fn prefix_str(&self) -> &'static str {\n+    /// Returns `\"\"` (empty string) or `\"mut \"` depending on the mutability.\n+    pub fn prefix_str(self) -> &'static str {\n         match self {\n             Mutability::Mut => \"mut \",\n             Mutability::Not => \"\",\n         }\n     }\n+\n+    /// Returns `\"&\"` or `\"&mut \"` depending on the mutability.\n+    pub fn ref_prefix_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"&\",\n+            Mutability::Mut => \"&mut \",\n+        }\n+    }\n+\n+    /// Returns `\"\"` (empty string) or `\"mutably \"` depending on the mutability.\n+    pub fn mutably_str(self) -> &'static str {\n+        match self {\n+            Mutability::Not => \"\",\n+            Mutability::Mut => \"mutably \",\n+        }\n+    }\n+\n+    /// Return `true` if self is mutable\n+    pub fn is_mut(self) -> bool {\n+        matches!(self, Self::Mut)\n+    }\n+\n+    /// Return `true` if self is **not** mutable\n+    pub fn is_not(self) -> bool {\n+        matches!(self, Self::Not)\n+    }\n }\n \n /// The kind of borrow in an `AddrOf` expression,"}, {"sha": "4ec943f33e230c4b4e4449f594509502759e0a95", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1781,14 +1781,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // Given we are only considering `ImplicitSelf` types, we needn't consider\n                     // the case where we have a mutable pattern to a reference as that would\n                     // no longer be an `ImplicitSelf`.\n-                    TyKind::Rptr(_, mt)\n-                        if mt.ty.kind.is_implicit_self() && mt.mutbl == ast::Mutability::Mut =>\n-                    {\n-                        hir::ImplicitSelfKind::MutRef\n-                    }\n-                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => {\n-                        hir::ImplicitSelfKind::ImmRef\n-                    }\n+                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => match mt.mutbl {\n+                        hir::Mutability::Not => hir::ImplicitSelfKind::ImmRef,\n+                        hir::Mutability::Mut => hir::ImplicitSelfKind::MutRef,\n+                    },\n                     _ => hir::ImplicitSelfKind::None,\n                 }\n             }),"}, {"sha": "919117651e2db87b6754593ea8b397b03e8fc4b5", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -716,19 +716,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let moved_place = &self.move_data.move_paths[move_out.path].place;\n                 let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n-                let suggestion = if borrow_level == hir::Mutability::Mut {\n-                    \"&mut \".to_string()\n-                } else {\n-                    \"&\".to_string()\n-                };\n+                let suggestion = borrow_level.ref_prefix_str().to_owned();\n                 (move_span.shrink_to_lo(), suggestion)\n             })\n             .collect();\n         err.multipart_suggestion_verbose(\n-            &format!(\n-                \"consider {}borrowing {value_name}\",\n-                if borrow_level == hir::Mutability::Mut { \"mutably \" } else { \"\" }\n-            ),\n+            format!(\"consider {}borrowing {value_name}\", borrow_level.mutably_str()),\n             sugg,\n             Applicability::MaybeIncorrect,\n         );"}, {"sha": "5122f9808ed29e60cf0f70cc6f2db69cf6bd211f", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -389,13 +389,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n             PlaceRef { local: _, projection: [] }\n-                if {\n-                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n-                        snippet.starts_with(\"&mut \")\n-                    } else {\n-                        false\n-                    }\n-                } =>\n+                if self\n+                    .infcx\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(span)\n+                    .map_or(false, |snippet| snippet.starts_with(\"&mut \")) =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_suggestion("}, {"sha": "a6bde88408497ed9d12a7cd28a82966d7fc52439", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -257,9 +257,9 @@ pub(crate) fn data_id_for_alloc_id(\n     mutability: rustc_hir::Mutability,\n ) -> DataId {\n     cx.todo.push(TodoItem::Alloc(alloc_id));\n-    *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-        module.declare_anonymous_data(mutability == rustc_hir::Mutability::Mut, false).unwrap()\n-    })\n+    *cx.anon_allocs\n+        .entry(alloc_id)\n+        .or_insert_with(|| module.declare_anonymous_data(mutability.is_mut(), false).unwrap())\n }\n \n fn data_id_for_static(\n@@ -343,12 +343,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n                     }\n                 };\n                 let data_id = *cx.anon_allocs.entry(alloc_id).or_insert_with(|| {\n-                    module\n-                        .declare_anonymous_data(\n-                            alloc.inner().mutability == rustc_hir::Mutability::Mut,\n-                            false,\n-                        )\n-                        .unwrap()\n+                    module.declare_anonymous_data(alloc.inner().mutability.is_mut(), false).unwrap()\n                 });\n                 (data_id, alloc, None)\n             }"}, {"sha": "2f5dd519b2600af5113b40afb83fb0c6ac04d376", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1500,7 +1500,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n         let (pointer_count, underlying_ty) = match element_ty1.kind() {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl.is_mut() => {\n                 (ptr_count(element_ty1), non_ptr(element_ty1))\n             }\n             _ => {"}, {"sha": "6e2fbf96cbfb3f26aabf1eb23901dffc687d68d8", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -130,10 +130,7 @@ impl hir::Pat<'_> {\n     pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n         self.each_binding(|annotation, _, _, _| match annotation {\n-            hir::BindingAnnotation::REF => match result {\n-                None | Some(hir::Mutability::Not) => result = Some(hir::Mutability::Not),\n-                _ => {}\n-            },\n+            hir::BindingAnnotation::REF if result.is_none() => result = Some(hir::Mutability::Not),\n             hir::BindingAnnotation::REF_MUT => result = Some(hir::Mutability::Mut),\n             _ => {}\n         });"}, {"sha": "193ecdb1678802b1e3a01371238ae1787a779cc2", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -370,7 +370,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                        mt_b: ty::TypeAndMut<'tcx>,\n                        mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-        if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Not, hir::Mutability::Mut) {\n+        if mt_a.mutbl < mt_b.mutbl {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types("}, {"sha": "cc5114dba5efefbdb1283de86487177a701094e6", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -292,7 +292,7 @@ fn emit_newtype_suggestion_for_raw_ptr(\n     diag: &mut Diagnostic,\n ) {\n     if !self_ty.needs_subst() {\n-        let mut_key = if ptr_ty.mutbl == rustc_middle::mir::Mutability::Mut { \"mut \" } else { \"\" };\n+        let mut_key = ptr_ty.mutbl.prefix_str();\n         let msg_sugg = \"consider introducing a new wrapper type\".to_owned();\n         let sugg = vec![\n             ("}, {"sha": "99a7f52efdb742716f7ced2626359cfeafcb3a5c", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -398,7 +398,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(t, m) => {\n                 self.head(\"static\");\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -519,7 +519,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ty, m, expr) => {\n                 self.head(\"static\");\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);"}, {"sha": "e25a9e9036a15607e6b2000aac8c03f8281eaa63", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -574,8 +574,5 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n fn arms_contain_ref_bindings<'tcx>(arms: &'tcx [hir::Arm<'tcx>]) -> Option<hir::Mutability> {\n-    arms.iter().filter_map(|a| a.pat.contains_explicit_ref_binding()).max_by_key(|m| match *m {\n-        hir::Mutability::Mut => 1,\n-        hir::Mutability::Not => 0,\n-    })\n+    arms.iter().filter_map(|a| a.pat.contains_explicit_ref_binding()).max()\n }"}, {"sha": "1c14c1d35f7997ef026f08ed22134a100f6ae75f", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -257,15 +257,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         return None;\n                     };\n \n-                    let mutbl = match mutbl {\n-                        hir::Mutability::Not => AutoBorrowMutability::Not,\n-                        hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                            // For initial two-phase borrow\n-                            // deployment, conservatively omit\n-                            // overloaded function call ops.\n-                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                        },\n-                    };\n+                    // For initial two-phase borrow\n+                    // deployment, conservatively omit\n+                    // overloaded function call ops.\n+                    let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::No);\n+\n                     autoref = Some(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                         target: method.sig.inputs()[0],"}, {"sha": "1cea8c9dadce3e32e9d51f478bb163871ecdef6f", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -951,7 +951,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         m_cast: ty::TypeAndMut<'tcx>,\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast: allow mut-to-mut, mut-to-const, const-to-const\n-        if m_expr.mutbl == hir::Mutability::Mut || m_cast.mutbl == hir::Mutability::Not {\n+        if m_expr.mutbl >= m_cast.mutbl {\n             if let ty::Array(ety, _) = m_expr.ty.kind() {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of"}, {"sha": "1ceb07def72e7f15f7091f90b558145803c8c7a1", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -202,7 +202,7 @@ fn check_panic_info_fn(\n     let arg_is_panic_info = match *inputs[0].kind() {\n         ty::Ref(region, ty, mutbl) => match *ty.kind() {\n             ty::Adt(ref adt, _) => {\n-                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n+                adt.did() == panic_info_did && mutbl.is_not() && !region.is_static()\n             }\n             _ => false,\n         },"}, {"sha": "6b6d54db5062f0b3623fa02e338402231d25a59b", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -108,11 +108,7 @@ fn coerce_mutbls<'tcx>(\n     from_mutbl: hir::Mutability,\n     to_mutbl: hir::Mutability,\n ) -> RelateResult<'tcx, ()> {\n-    match (from_mutbl, to_mutbl) {\n-        (hir::Mutability::Mut, hir::Mutability::Mut | hir::Mutability::Not)\n-        | (hir::Mutability::Not, hir::Mutability::Not) => Ok(()),\n-        (hir::Mutability::Not, hir::Mutability::Mut) => Err(TypeError::Mutability),\n-    }\n+    if from_mutbl >= to_mutbl { Ok(()) } else { Err(TypeError::Mutability) }\n }\n \n /// Do not require any adjustments, i.e. coerce `x -> x`.\n@@ -456,7 +452,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             return Err(err);\n         };\n \n-        if ty == a && mt_a.mutbl == hir::Mutability::Not && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl.is_not() && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -468,7 +464,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mutbl_b, hir::Mutability::Not); // can only coerce &T -> &U\n+            assert!(mutbl_b.is_not()); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -482,12 +478,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let ty::Ref(r_borrow, _, _) = ty.kind() else {\n             span_bug!(span, \"expected a ref type, got {:?}\", ty);\n         };\n-        let mutbl = match mutbl_b {\n-            hir::Mutability::Not => AutoBorrowMutability::Not,\n-            hir::Mutability::Mut => {\n-                AutoBorrowMutability::Mut { allow_two_phase_borrow: self.allow_two_phase }\n-            }\n-        };\n+        let mutbl = AutoBorrowMutability::new(mutbl_b, self.allow_two_phase);\n         adjustments.push(Adjustment {\n             kind: Adjust::Borrow(AutoBorrow::Ref(*r_borrow, mutbl)),\n             target: ty,\n@@ -556,15 +547,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n-                let mutbl = match mutbl_b {\n-                    hir::Mutability::Not => AutoBorrowMutability::Not,\n-                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                        // We don't allow two-phase borrows here, at least for initial\n-                        // implementation. If it happens that this coercion is a function argument,\n-                        // the reborrow in coerce_borrowed_ptr will pick it up.\n-                        allow_two_phase_borrow: AllowTwoPhase::No,\n-                    },\n-                };\n+\n+                // We don't allow two-phase borrows here, at least for initial\n+                // implementation. If it happens that this coercion is a function argument,\n+                // the reborrow in coerce_borrowed_ptr will pick it up.\n+                let mutbl = AutoBorrowMutability::new(mutbl_b, AllowTwoPhase::No);\n+\n                 Some((\n                     Adjustment { kind: Adjust::Deref(None), target: ty_a },\n                     Adjustment {"}, {"sha": "2106dce6f407ed2e03dd901732798e2e08e4a28b", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 29, "deletions": 68, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -19,6 +19,7 @@ use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n \n+use std::cmp::min;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -855,31 +856,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             ..\n                         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n                         {\n-                            if mutability == hir::Mutability::Mut {\n+                            if mutability.is_mut() {\n                                 // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n                                 return None;\n                             }\n                         }\n \n                         let sugg_expr = if needs_parens { format!(\"({src})\") } else { src };\n-                        return Some(match mutability {\n-                            hir::Mutability::Mut => (\n-                                sp,\n-                                \"consider mutably borrowing here\".to_string(),\n-                                format!(\"{prefix}&mut {sugg_expr}\"),\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ),\n-                            hir::Mutability::Not => (\n-                                sp,\n-                                \"consider borrowing here\".to_string(),\n-                                format!(\"{prefix}&{sugg_expr}\"),\n-                                Applicability::MachineApplicable,\n-                                false,\n-                                false,\n-                            ),\n-                        });\n+                        return Some((\n+                            sp,\n+                            format!(\"consider {}borrowing here\", mutability.mutably_str()),\n+                            format!(\"{prefix}{}{sugg_expr}\", mutability.ref_prefix_str()),\n+                            Applicability::MachineApplicable,\n+                            false,\n+                            false,\n+                        ));\n                     }\n                 }\n             }\n@@ -937,51 +928,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && let Ok(src) = sm.span_to_snippet(sp)\n                 {\n                     let derefs = \"*\".repeat(steps);\n-                    if let Some((span, src, applicability)) = match mutbl_b {\n-                        hir::Mutability::Mut => {\n-                            let new_prefix = \"&mut \".to_owned() + &derefs;\n-                            match mutbl_a {\n-                                hir::Mutability::Mut => {\n-                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(5);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                                hir::Mutability::Not => {\n-                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(1);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (\n-                                            sp,\n-                                            format!(\"mut {derefs}\"),\n-                                            Applicability::Unspecified,\n-                                        )\n-                                    })\n-                                }\n-                            }\n-                        }\n-                        hir::Mutability::Not => {\n-                            let new_prefix = \"&\".to_owned() + &derefs;\n-                            match mutbl_a {\n-                                hir::Mutability::Mut => {\n-                                    replace_prefix(&src, \"&mut \", &new_prefix).map(|_| {\n-                                        let lo = sp.lo() + BytePos(1);\n-                                        let hi = sp.lo() + BytePos(5);\n-                                        let sp = sp.with_lo(lo).with_hi(hi);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                                hir::Mutability::Not => {\n-                                    replace_prefix(&src, \"&\", &new_prefix).map(|_| {\n-                                        let pos = sp.lo() + BytePos(1);\n-                                        let sp = sp.with_lo(pos).with_hi(pos);\n-                                        (sp, derefs, Applicability::MachineApplicable)\n-                                    })\n-                                }\n-                            }\n-                        }\n-                    } {\n+                    let old_prefix = mutbl_a.ref_prefix_str();\n+                    let new_prefix = mutbl_b.ref_prefix_str().to_owned() + &derefs;\n+\n+                    let suggestion = replace_prefix(&src, old_prefix, &new_prefix).map(|_| {\n+                        // skip `&` or `&mut ` if both mutabilities are mutable\n+                        let lo = sp.lo() + BytePos(min(old_prefix.len(), mutbl_b.ref_prefix_str().len()) as _);\n+                        // skip `&` or `&mut `\n+                        let hi = sp.lo() + BytePos(old_prefix.len() as _);\n+                        let sp = sp.with_lo(lo).with_hi(hi);\n+\n+                        (\n+                            sp,\n+                            format!(\"{}{derefs}\", if mutbl_a != mutbl_b { mutbl_b.prefix_str() } else { \"\" }),\n+                            if mutbl_b <= mutbl_a { Applicability::MachineApplicable } else { Applicability::MaybeIncorrect }\n+                        )\n+                    });\n+\n+                    if let Some((span, src, applicability)) = suggestion {\n                         return Some((\n                             span,\n                             \"consider dereferencing\".to_string(),\n@@ -1005,10 +969,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // If the expression has `&`, removing it would fix the error\n                             prefix_span = prefix_span.with_hi(inner.span.lo());\n                             expr = inner;\n-                            remove += match mutbl {\n-                                hir::Mutability::Not => \"&\",\n-                                hir::Mutability::Mut => \"&mut \",\n-                            };\n+                            remove.push_str(mutbl.ref_prefix_str());\n                             steps -= 1;\n                         } else {\n                             break;"}, {"sha": "d7f875b2857752d228cdccff34bedcb41d9b9d81", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -2333,12 +2333,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n-        let output_ty = match self.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n-            _ => return,\n-        };\n+        let Some(output_ty) = self.get_impl_future_output_ty(ty) else { return; };\n         let mut add_label = true;\n-        if let ty::Adt(def, _) = output_ty.skip_binder().kind() {\n+        if let ty::Adt(def, _) = output_ty.kind() {\n             // no field access on enum type\n             if !def.is_enum() {\n                 if def"}, {"sha": "6c3526a71a3285955c12288b78aca34ff1d9a674", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -345,8 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             if annotation {\n                 let suggest_annotation = match expr.peel_drop_temps().kind {\n-                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, _) => \"&\",\n-                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) => \"&mut \",\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, mutbl, _) => mutbl.ref_prefix_str(),\n                     _ => return true,\n                 };\n                 let mut tuple_indexes = Vec::new();\n@@ -925,15 +924,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n                 hir::IsAsync::Async => {\n                     let infcx = self.tcx.infer_ctxt().build();\n-                    infcx\n-                        .get_impl_future_output_ty(ty)\n-                        .unwrap_or_else(|| {\n-                            span_bug!(\n-                                fn_decl.output.span(),\n-                                \"failed to get output type of async function\"\n-                            )\n-                        })\n-                        .skip_binder()\n+                    infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                        span_bug!(\n+                            fn_decl.output.span(),\n+                            \"failed to get output type of async function\"\n+                        )\n+                    })\n                 }\n                 hir::IsAsync::NotAsync => ty,\n             };"}, {"sha": "50722c42a6c611ce7d96a8f64276468eb6932628", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -98,8 +98,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 expr, scope, ty, self.expr_count, yield_data.span\n             );\n \n-            if let Some((unresolved_type, unresolved_type_span)) =\n-                self.fcx.unresolved_type_vars(&ty)\n+            if let Some((unresolved_term, unresolved_type_span)) =\n+                self.fcx.first_unresolved_const_or_ty_var(&ty)\n             {\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 let span = self\n@@ -108,21 +108,21 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n \n                 // If we encounter an int/float variable, then inference fallback didn't\n                 // finish due to some other error. Don't emit spurious additional errors.\n-                if let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) =\n-                    unresolved_type.kind()\n+                if let Some(unresolved_ty) = unresolved_term.ty()\n+                    && let ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(_)) = unresolved_ty.kind()\n                 {\n                     self.fcx\n                         .tcx\n                         .sess\n-                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_type));\n+                        .delay_span_bug(span, &format!(\"Encountered var {:?}\", unresolved_term));\n                 } else {\n                     let note = format!(\n                         \"the type is part of the {} because of this {}\",\n                         self.kind, yield_data.source\n                     );\n \n                     self.fcx\n-                        .need_type_info_err_in_generator(self.kind, span, unresolved_type)\n+                        .need_type_info_err_in_generator(self.kind, span, unresolved_term)\n                         .span_note(yield_data.span, &*note)\n                         .emit();\n                 }\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 expr.map(|e| e.span)\n             );\n             if let Some((unresolved_type, unresolved_type_span)) =\n-                self.fcx.unresolved_type_vars(&ty)\n+                self.fcx.first_unresolved_const_or_ty_var(&ty)\n             {\n                 debug!(\n                     \"remained unresolved_type = {:?}, unresolved_type_span: {:?}\","}, {"sha": "f50a16dcb236d58c640fd316a03d27090b1293ff", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -170,14 +170,11 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 let base_ty = target;\n \n                 target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl, ty: target });\n-                let mutbl = match mutbl {\n-                    hir::Mutability::Not => AutoBorrowMutability::Not,\n-                    hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                        // Method call receivers are the primary use case\n-                        // for two-phase borrows.\n-                        allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                    },\n-                };\n+\n+                // Method call receivers are the primary use case\n+                // for two-phase borrows.\n+                let mutbl = AutoBorrowMutability::new(mutbl, AllowTwoPhase::Yes);\n+\n                 adjustments.push(Adjustment {\n                     kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n                     target,\n@@ -202,7 +199,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) => {\n                 target = match target.kind() {\n                     &ty::RawPtr(ty::TypeAndMut { ty, mutbl }) => {\n-                        assert_eq!(mutbl, hir::Mutability::Mut);\n+                        assert!(mutbl.is_mut());\n                         self.tcx.mk_ptr(ty::TypeAndMut { mutbl: hir::Mutability::Not, ty })\n                     }\n                     other => panic!(\"Cannot adjust receiver type {:?} to const ptr\", other),"}, {"sha": "dea14dd93d6acd15e0ec4199ad0f677b5461ce6b", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -5,7 +5,6 @@ use crate::{\n use hir::def_id::DefId;\n use hir::HirId;\n use hir::ItemKind;\n-use rustc_ast::Mutability;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -88,14 +87,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let derefs = \"*\".repeat(pick.autoderefs);\n \n                     let autoref = match pick.autoref_or_ptr_adjustment {\n-                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                            mutbl: Mutability::Mut,\n-                            ..\n-                        }) => \"&mut \",\n-                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n-                            mutbl: Mutability::Not,\n-                            ..\n-                        }) => \"&\",\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, .. }) => {\n+                            mutbl.ref_prefix_str()\n+                        }\n                         Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n                     };\n                     if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span)\n@@ -386,8 +380,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let derefs = \"*\".repeat(pick.autoderefs);\n \n         let autoref = match pick.autoref_or_ptr_adjustment {\n-            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Mut, .. }) => \"&mut \",\n-            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Not, .. }) => \"&\",\n+            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, .. }) => mutbl.ref_prefix_str(),\n             Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n         };\n "}, {"sha": "727fab9e7aa1e7df85b4d31bb27ce265d9423b3f", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1147,19 +1147,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 && assoc.kind == ty::AssocKind::Fn\n             {\n                 let sig = self.tcx.fn_sig(assoc.def_id);\n-                if let Some(first) = sig.inputs().skip_binder().get(0) {\n-                    if first.peel_refs() == rcvr_ty.peel_refs() {\n-                        None\n-                    } else {\n-                        Some(if first.is_region_ptr() {\n-                            if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-                        } else {\n-                            \"\"\n-                        })\n-                    }\n-                } else {\n+                sig.inputs().skip_binder().get(0).and_then(|first| if first.peel_refs() == rcvr_ty.peel_refs() {\n                     None\n-                }\n+                } else {\n+                    Some(first.ref_mutability().map_or(\"\", |mutbl| mutbl.ref_prefix_str()))\n+                })\n             } else {\n                 None\n             };\n@@ -1960,7 +1952,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) {\n         let output_ty = match self.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(output_ty).skip_binder(),\n+            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n             _ => return,\n         };\n         let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);\n@@ -2627,11 +2619,7 @@ fn print_disambiguation_help<'tcx>(\n     let (span, sugg) = if let (ty::AssocKind::Fn, Some((receiver, args))) = (kind, args) {\n         let args = format!(\n             \"({}{})\",\n-            if rcvr_ty.is_region_ptr() {\n-                if rcvr_ty.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-            } else {\n-                \"\"\n-            },\n+            rcvr_ty.ref_mutability().map_or(\"\", |mutbl| mutbl.ref_prefix_str()),\n             std::iter::once(receiver)\n                 .chain(args.iter())\n                 .map(|arg| source_map.span_to_snippet(arg.span).unwrap_or_else(|_| {"}, {"sha": "b12d84af4adbca81f0e04f1b7e36e092c70a872f", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -263,14 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let by_ref_binop = !op.node.is_by_value();\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind() {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // Allow two-phase borrows for binops in initial deployment\n-                                // since they desugar to methods\n-                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                            },\n-                        };\n+                        let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::Yes);\n                         let autoref = Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[0],\n@@ -280,14 +273,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n                 if by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind() {\n-                        let mutbl = match mutbl {\n-                            hir::Mutability::Not => AutoBorrowMutability::Not,\n-                            hir::Mutability::Mut => AutoBorrowMutability::Mut {\n-                                // Allow two-phase borrows for binops in initial deployment\n-                                // since they desugar to methods\n-                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n-                            },\n-                        };\n+                        // Allow two-phase borrows for binops in initial deployment\n+                        // since they desugar to methods\n+                        let mutbl = AutoBorrowMutability::new(*mutbl, AllowTwoPhase::Yes);\n+\n                         let autoref = Adjustment {\n                             kind: Adjust::Borrow(AutoBorrow::Ref(*region, mutbl)),\n                             target: method.sig.inputs()[1],"}, {"sha": "decd317d9fc9b1e3a8943e9419bd0dedbb66e5eb", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -702,7 +702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n             let mut_var_suggestion = 'block: {\n-                if !matches!(mutbl, ast::Mutability::Mut) {\n+                if mutbl.is_not() {\n                     break 'block None;\n                 }\n \n@@ -749,7 +749,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"to take parameter `{binding}` by reference, move `&{mutability}` to the type\"),\n                         vec![\n                             (pat.span.until(inner.span), \"\".to_owned()),\n-                            (ty_span.shrink_to_lo(), format!(\"&{}\", mutbl.prefix_str())),\n+                            (ty_span.shrink_to_lo(), mutbl.ref_prefix_str().to_owned()),\n                         ],\n                         Applicability::MachineApplicable\n                     );"}, {"sha": "6b6be7359a599ef339de8665c1f280a2a3bdfa0c", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -74,7 +74,7 @@ use rustc_middle::dep_graph::DepContext;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::relate::{self, RelateResult, TypeRelation};\n use rustc_middle::ty::{\n-    self, error::TypeError, Binder, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n+    self, error::TypeError, List, Region, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable,\n     TypeVisitable,\n };\n use rustc_span::{sym, symbol::kw, BytePos, DesugaringKind, Pos, Span};\n@@ -339,16 +339,15 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n }\n \n impl<'tcx> InferCtxt<'tcx> {\n-    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n-        if let ty::Opaque(def_id, substs) = ty.kind() {\n-            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n-            // Future::Output\n-            let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        let ty::Opaque(def_id, substs) = *ty.kind() else { return None; };\n \n-            let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n+        let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+        let item_def_id = self.tcx.associated_item_def_ids(future_trait)[0];\n \n-            for (predicate, _) in bounds.subst_iter_copied(self.tcx, substs) {\n-                let output = predicate\n+        self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs).find_map(\n+            |(predicate, _)| {\n+                predicate\n                     .kind()\n                     .map_bound(|kind| match kind {\n                         ty::PredicateKind::Clause(ty::Clause::Projection(projection_predicate))\n@@ -358,14 +357,10 @@ impl<'tcx> InferCtxt<'tcx> {\n                         }\n                         _ => None,\n                     })\n-                    .transpose();\n-                if output.is_some() {\n-                    // We don't account for multiple `Future::Output = Ty` constraints.\n-                    return output;\n-                }\n-            }\n-        }\n-        None\n+                    .no_bound_vars()\n+                    .flatten()\n+            },\n+        )\n     }\n }\n \n@@ -2055,8 +2050,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n \n         match (\n-            self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n-            self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n+            self.get_impl_future_output_ty(exp_found.expected),\n+            self.get_impl_future_output_ty(exp_found.found),\n         ) {\n             (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n                 .code()"}, {"sha": "8ff1639a3a24b489e1f8ffc1d039e77a298fda4f", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -15,7 +15,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Body, Closure, Expr, ExprKind, FnRetTy, HirId, Local, LocalSource};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Print, Printer};\n use rustc_middle::ty::{self, DefIdTree, InferConst};\n use rustc_middle::ty::{GenericArg, GenericArgKind, SubstsRef};\n@@ -508,10 +508,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     [\n                         ..,\n                         Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mut_)), target: _ },\n-                    ] => match mut_ {\n-                        AutoBorrowMutability::Mut { .. } => \"&mut \",\n-                        AutoBorrowMutability::Not => \"&\",\n-                    },\n+                    ] => hir::Mutability::from(*mut_).ref_prefix_str(),\n                     _ => \"\",\n                 };\n \n@@ -571,7 +568,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &self,\n         kind: hir::GeneratorKind,\n         span: Span,\n-        ty: Ty<'tcx>,\n+        ty: ty::Term<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ty = self.resolve_vars_if_possible(ty);\n         let data = self.extract_inference_diagnostics_data(ty.into(), None);"}, {"sha": "cda9299dcb6e795cdf0705f6a90ebe60c51976f7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1421,16 +1421,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns the first unresolved variable contained in `T`. In the\n-    /// process of visiting `T`, this will resolve (where possible)\n-    /// type variables in `T`, but it never constructs the final,\n-    /// resolved type, so it's more efficient than\n-    /// `resolve_vars_if_possible()`.\n-    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n+    /// Returns the first unresolved type or const variable contained in `T`.\n+    pub fn first_unresolved_const_or_ty_var<T>(\n+        &self,\n+        value: &T,\n+    ) -> Option<(ty::Term<'tcx>, Option<Span>)>\n     where\n         T: TypeVisitable<'tcx>,\n     {\n-        value.visit_with(&mut resolve::UnresolvedTypeFinder::new(self)).break_value()\n+        value.visit_with(&mut resolve::UnresolvedTypeOrConstFinder::new(self)).break_value()\n     }\n \n     pub fn probe_const_var("}, {"sha": "8671f8d45a91721d597bb8aa72d514e4dd5027cf", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1,5 +1,6 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::ty::fold::{FallibleTypeFolder, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitor};\n use rustc_middle::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n@@ -110,48 +111,77 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticRegionResolver<'a, 'tcx> {\n /// type variables that don't yet have a value. The first unresolved type is stored.\n /// It does not construct the fully resolved type (which might\n /// involve some hashing and so forth).\n-pub struct UnresolvedTypeFinder<'a, 'tcx> {\n+pub struct UnresolvedTypeOrConstFinder<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n }\n \n-impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n+impl<'a, 'tcx> UnresolvedTypeOrConstFinder<'a, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'tcx>) -> Self {\n-        UnresolvedTypeFinder { infcx }\n+        UnresolvedTypeOrConstFinder { infcx }\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n-    type BreakTy = (Ty<'tcx>, Option<Span>);\n+impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeOrConstFinder<'a, 'tcx> {\n+    type BreakTy = (ty::Term<'tcx>, Option<Span>);\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let t = self.infcx.shallow_resolve(t);\n-        if t.has_infer_types() {\n-            if let ty::Infer(infer_ty) = *t.kind() {\n-                // Since we called `shallow_resolve` above, this must\n-                // be an (as yet...) unresolved inference variable.\n-                let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let mut inner = self.infcx.inner.borrow_mut();\n-                    let ty_vars = &inner.type_variables();\n-                    if let TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n-                        span,\n-                    } = *ty_vars.var_origin(ty_vid)\n-                    {\n-                        Some(span)\n-                    } else {\n-                        None\n-                    }\n+        if let ty::Infer(infer_ty) = *t.kind() {\n+            // Since we called `shallow_resolve` above, this must\n+            // be an (as yet...) unresolved inference variable.\n+            let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let ty_vars = &inner.type_variables();\n+                if let TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n+                    span,\n+                } = *ty_vars.var_origin(ty_vid)\n+                {\n+                    Some(span)\n                 } else {\n                     None\n-                };\n-                ControlFlow::Break((t, ty_var_span))\n+                }\n             } else {\n-                // Otherwise, visit its contents.\n-                t.super_visit_with(self)\n-            }\n+                None\n+            };\n+            ControlFlow::Break((t.into(), ty_var_span))\n+        } else if !t.has_non_region_infer() {\n+            // All const/type variables in inference types must already be resolved,\n+            // no need to visit the contents.\n+            ControlFlow::CONTINUE\n         } else {\n-            // All type variables in inference types must already be resolved,\n-            // - no need to visit the contents, continue visiting.\n+            // Otherwise, keep visiting.\n+            t.super_visit_with(self)\n+        }\n+    }\n+\n+    fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let ct = self.infcx.shallow_resolve(ct);\n+        if let ty::ConstKind::Infer(i) = ct.kind() {\n+            // Since we called `shallow_resolve` above, this must\n+            // be an (as yet...) unresolved inference variable.\n+            let ct_var_span = if let ty::InferConst::Var(vid) = i {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let ct_vars = &mut inner.const_unification_table();\n+                if let ConstVariableOrigin {\n+                    span,\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(_, _),\n+                } = ct_vars.probe_value(vid).origin\n+                {\n+                    Some(span)\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            ControlFlow::Break((ct.into(), ct_var_span))\n+        } else if !ct.has_non_region_infer() {\n+            // All const/type variables in inference types must already be resolved,\n+            // no need to visit the contents.\n             ControlFlow::CONTINUE\n+        } else {\n+            // Otherwise, keep visiting.\n+            ct.super_visit_with(self)\n         }\n     }\n }"}, {"sha": "7fb8ed8c233521183055846f60937d925b2ce031", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1268,10 +1268,10 @@ declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        if let Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) =\n+        if let Some((&ty::Ref(_, _, from_mutbl), &ty::Ref(_, _, to_mutbl))) =\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n-            if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n+            if from_mutbl < to_mutbl {\n                 cx.struct_span_lint(\n                     MUTABLE_TRANSMUTES,\n                     expr.span,"}, {"sha": "38b72ec923193a4e0420d9e49df39bae51a2a29b", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -2068,8 +2068,8 @@ rustc_queries! {\n         remap_env_constness\n     }\n \n-    query normalize_opaque_types(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n-        desc { \"normalizing opaque types in `{:?}`\", key }\n+    query reveal_opaque_types_in_bounds(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+        desc { \"revealing opaque types in `{:?}`\", key }\n     }\n \n     query limits(key: ()) -> Limits {"}, {"sha": "7036c4a7b27d60b8da7772a1e575c33297736d4d", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -159,6 +159,18 @@ pub enum AutoBorrowMutability {\n     Not,\n }\n \n+impl AutoBorrowMutability {\n+    /// Creates an `AutoBorrowMutability` from a mutability and allowance of two phase borrows.\n+    ///\n+    /// Note that when `mutbl.is_not()`, `allow_two_phase_borrow` is ignored\n+    pub fn new(mutbl: hir::Mutability, allow_two_phase_borrow: AllowTwoPhase) -> Self {\n+        match mutbl {\n+            hir::Mutability::Not => Self::Not,\n+            hir::Mutability::Mut => Self::Mut { allow_two_phase_borrow },\n+        }\n+    }\n+}\n+\n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {"}, {"sha": "7ad2a9edd4eff5f12ef2aa3f45a7d1f428c582a9", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1747,7 +1747,7 @@ impl<'tcx> ParamEnv<'tcx> {\n         }\n \n         ParamEnv::new(\n-            tcx.normalize_opaque_types(self.caller_bounds()),\n+            tcx.reveal_opaque_types_in_bounds(self.caller_bounds()),\n             Reveal::All,\n             self.constness(),\n         )"}, {"sha": "141c8354c183d65ace6d553f10172f6ccbf2982b", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -140,6 +140,15 @@ impl<'tcx> From<ty::Const<'tcx>> for GenericArg<'tcx> {\n     }\n }\n \n+impl<'tcx> From<ty::Term<'tcx>> for GenericArg<'tcx> {\n+    fn from(value: ty::Term<'tcx>) -> Self {\n+        match value.unpack() {\n+            ty::TermKind::Ty(t) => t.into(),\n+            ty::TermKind::Const(c) => c.into(),\n+        }\n+    }\n+}\n+\n impl<'tcx> GenericArg<'tcx> {\n     #[inline]\n     pub fn unpack(self) -> GenericArgKind<'tcx> {"}, {"sha": "717e5136e96d95625eb50aead137d3f2559d0f1f", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1248,9 +1248,9 @@ where\n #[derive(Copy, Clone, Debug, HashStable, TyEncodable, TyDecodable)]\n pub struct AlwaysRequiresDrop;\n \n-/// Normalizes all opaque types in the given value, replacing them\n+/// Reveals all opaque types in the given value, replacing them\n /// with their underlying types.\n-pub fn normalize_opaque_types<'tcx>(\n+pub fn reveal_opaque_types_in_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     val: &'tcx ty::List<ty::Predicate<'tcx>>,\n ) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n@@ -1287,7 +1287,7 @@ pub fn is_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        normalize_opaque_types,\n+        reveal_opaque_types_in_bounds,\n         is_doc_hidden,\n         is_doc_notable_trait,\n         is_intrinsic,"}, {"sha": "74048ff7da3bdd0c5edf1075a75f693728ad066c", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -169,7 +169,7 @@ impl<'hir> Sig for hir::Ty<'hir> {\n                 let mut prefix = \"&\".to_owned();\n                 prefix.push_str(&lifetime.name.ident().to_string());\n                 prefix.push(' ');\n-                if let hir::Mutability::Mut = mt.mutbl {\n+                if mt.mutbl.is_mut() {\n                     prefix.push_str(\"mut \");\n                 };\n \n@@ -332,7 +332,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n         match self.kind {\n             hir::ItemKind::Static(ref ty, m, ref body) => {\n                 let mut text = \"static \".to_owned();\n-                if m == hir::Mutability::Mut {\n+                if m.is_mut() {\n                     text.push_str(\"mut \");\n                 }\n                 let name = self.ident.to_string();"}, {"sha": "2cca480f271c73331046c25302e291f9e26e58ad", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -622,7 +622,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 });\n \n                 match inner_ty.kind() {\n-                    ty::Str if *mutbl == hir::Mutability::Not => {\n+                    ty::Str if mutbl.is_not() => {\n                         match ct.kind() {\n                             ty::ConstKind::Value(valtree) => {\n                                 let slice ="}, {"sha": "da6ca30cc9a32edab5cee65eabe8b8dc9a79d30a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1055,7 +1055,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 {\n                     (\n                         mk_result(old_pred.map_bound(|trait_pred| (trait_pred, *ty))),\n-                        matches!(mutability, hir::Mutability::Mut),\n+                        mutability.is_mut(),\n                     )\n                 } else {\n                     (false, false)\n@@ -1344,7 +1344,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         .sess\n                         .source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n-                    if points_at_arg && mutability == hir::Mutability::Not && refs_number > 0 {\n+                    if points_at_arg && mutability.is_not() && refs_number > 0 {\n                         err.span_suggestion_verbose(\n                             sp,\n                             \"consider changing this borrow's mutability\","}, {"sha": "98a5b761dedf56288ffa13e98a992587bd3f8d89", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1327,8 +1327,8 @@ a.test-arrow:hover {\n \tborder-bottom: 1px solid;\n \tdisplay: flex;\n \theight: 40px;\n-\tjustify-content: center;\n-\talign-items: center;\n+\tjustify-content: stretch;\n+\talign-items: stretch;\n \tz-index: 10;\n }\n #source-sidebar {\n@@ -1356,13 +1356,7 @@ a.test-arrow:hover {\n \ttext-align: center;\n \tborder: none;\n \toutline: none;\n-\tposition: absolute;\n-\ttop: 0;\n-\tbottom: 0;\n-\tleft: 0;\n-\tright: 0;\n-\t/* work around button layout strangeness: https://stackoverflow.com/q/7271561 */\n-\twidth: 100%;\n+\tflex: 1 1;\n \t/* iOS button gradient: https://stackoverflow.com/q/5438567 */\n \t-webkit-appearance: none;\n \topacity: 1;"}, {"sha": "62b8b832afdaaf92077eb989973d5604e9326b31", "filename": "src/test/rustdoc-json/enums/use_glob.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Frustdoc-json%2Fenums%2Fuse_glob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Frustdoc-json%2Fenums%2Fuse_glob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fuse_glob.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -0,0 +1,18 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/104942>\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+// @set Color = \"$.index[*][?(@.name == 'Color')].id\"\n+pub enum Color {\n+    Red,\n+    Green,\n+    Blue,\n+}\n+\n+// @set use_Color = \"$.index[*][?(@.kind == 'import')].id\"\n+// @is \"$.index[*][?(@.kind == 'import')].inner.id\" $Color\n+// @is \"$.index[*][?(@.kind == 'import')].inner.glob\" true\n+pub use Color::*;\n+\n+// @ismany \"$.index[*][?(@.name == 'use_glob')].inner.items[*]\" $Color $use_Color"}, {"sha": "5f0d2b9b1ec84935f55c9aff29e86fb5e80ae0a1", "filename": "src/test/rustdoc-json/enums/use_variant.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Frustdoc-json%2Fenums%2Fuse_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Frustdoc-json%2Fenums%2Fuse_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fenums%2Fuse_variant.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -0,0 +1,15 @@\n+#![feature(no_core)]\n+#![no_core]\n+\n+// @set AlwaysNone = \"$.index[*][?(@.name == 'AlwaysNone')].id\"\n+pub enum AlwaysNone {\n+    // @set None = \"$.index[*][?(@.name == 'None')].id\"\n+    None,\n+}\n+// @is \"$.index[*][?(@.name == 'AlwaysNone')].inner.variants[*]\" $None\n+\n+// @set use_None = \"$.index[*][?(@.kind == 'import')].id\"\n+// @is \"$.index[*][?(@.kind == 'import')].inner.id\" $None\n+pub use AlwaysNone::None;\n+\n+// @ismany \"$.index[*][?(@.name == 'use_variant')].inner.items[*]\" $AlwaysNone $use_None"}, {"sha": "35db9296cddb270cfb19eef83e1ce6a41a30dfbf", "filename": "src/test/rustdoc-json/traits/trait_alias.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Frustdoc-json%2Ftraits%2Ftrait_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Frustdoc-json%2Ftraits%2Ftrait_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ftraits%2Ftrait_alias.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/104923>\n+// ignore-tidy-linelength\n+\n+#![feature(trait_alias)]\n+\n+// @set Orig = \"$.index[*][?(@.name == 'Orig')].id\"\n+// @is \"$.index[*][?(@.name == 'Orig')].kind\" '\"trait\"'\n+pub trait Orig<T> {}\n+\n+// @set Alias = \"$.index[*][?(@.name == 'Alias')].id\"\n+// @is \"$.index[*][?(@.name == 'Alias')].kind\" '\"trait_alias\"'\n+// @is \"$.index[*][?(@.name == 'Alias')].inner.generics\" '{\"params\": [], \"where_predicates\": []}'\n+// @count \"$.index[*][?(@.name == 'Alias')].inner.params[*]\" 1\n+// @is \"$.index[*][?(@.name == 'Alias')].inner.params[0].trait_bound.trait.id\" $Orig\n+// @is \"$.index[*][?(@.name == 'Alias')].inner.params[0].trait_bound.trait.args.angle_bracketed.args[0].type.inner\" '\"i32\"'\n+pub trait Alias = Orig<i32>;\n+\n+pub struct Struct;\n+\n+impl Orig<i32> for Struct {}\n+\n+// @is \"$.index[*][?(@.name=='takes_alias')].inner.decl.inputs[0][1].kind\" '\"impl_trait\"'\n+// @is \"$.index[*][?(@.name=='takes_alias')].inner.decl.inputs[0][1].inner[0].trait_bound.trait.id\" $Alias\n+// @is \"$.index[*][?(@.name=='takes_alias')].inner.generics.params[0].kind.type.bounds[0].trait_bound.trait.id\" $Alias\n+pub fn takes_alias(_: impl Alias) {}\n+// FIXME: Should the trait be mentioned in both the decl and generics?\n+\n+fn main() {\n+    takes_alias(Struct);\n+}"}, {"sha": "0a1570fc2395ec43658061c387aa6a97a49da787", "filename": "src/test/ui/generator/unresolved-ct-var.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -0,0 +1,14 @@\n+// incremental\n+// edition:2021\n+\n+fn main() {\n+    let _ = async {\n+        let s = std::array::from_fn(|_| ()).await;\n+        //~^ ERROR `[(); _]` is not a future\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+        //~| ERROR type inside `async` block must be known in this context\n+    };\n+}"}, {"sha": "fdf00dfad7ab7eed36024ff78f1376d8ff351969", "filename": "src/test/ui/generator/unresolved-ct-var.stderr", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved-ct-var.stderr?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -0,0 +1,78 @@\n+error[E0277]: `[(); _]` is not a future\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ---------------------------^^^^^^\n+   |                 |                          |\n+   |                 |                          `[(); _]` is not a future\n+   |                 |                          help: remove the `.await`\n+   |                 this call returns `[(); _]`\n+   |\n+   = help: the trait `Future` is not implemented for `[(); _]`\n+   = note: [(); _] must be a future or must implement `IntoFuture` to be awaited\n+   = note: required for `[(); _]` to implement `IntoFuture`\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error[E0698]: type inside `async` block must be known in this context\n+  --> $DIR/unresolved-ct-var.rs:6:17\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                 ^^^^^^^^^^^^^^^^^^^ cannot infer the value of const parameter `N` declared on the function `from_fn`\n+   |\n+note: the type is part of the `async` block because of this `await`\n+  --> $DIR/unresolved-ct-var.rs:6:44\n+   |\n+LL |         let s = std::array::from_fn(|_| ()).await;\n+   |                                            ^^^^^^\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0277, E0698.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "b395c6e7d2d62071a774a485568487e25290724a", "filename": "src/tools/jsondoclint/src/item_kind.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fitem_kind.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -1,7 +1,7 @@\n use rustdoc_json_types::{Item, ItemEnum, ItemKind, ItemSummary};\n \n /// A univeral way to represent an [`ItemEnum`] or [`ItemKind`]\n-#[derive(Debug)]\n+#[derive(Debug, Clone, Copy)]\n pub(crate) enum Kind {\n     Module,\n     ExternCrate,\n@@ -68,6 +68,22 @@ impl Kind {\n         }\n     }\n \n+    pub fn can_appear_in_import(self) -> bool {\n+        match self {\n+            Kind::Variant => true,\n+            Kind::Import => false,\n+            other => other.can_appear_in_mod(),\n+        }\n+    }\n+\n+    pub fn can_appear_in_glob_import(self) -> bool {\n+        match self {\n+            Kind::Module => true,\n+            Kind::Enum => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn can_appear_in_trait(self) -> bool {\n         match self {\n             Kind::AssocConst => true,\n@@ -111,8 +127,8 @@ impl Kind {\n     pub fn is_variant(self) -> bool {\n         matches!(self, Kind::Variant)\n     }\n-    pub fn is_trait(self) -> bool {\n-        matches!(self, Kind::Trait)\n+    pub fn is_trait_or_alias(self) -> bool {\n+        matches!(self, Kind::Trait | Kind::TraitAlias)\n     }\n     pub fn is_type(self) -> bool {\n         matches!(self, Kind::Struct | Kind::Enum | Kind::Union | Kind::Typedef)"}, {"sha": "5046ab9c7cbc178dad6ffc7744e78e57f875b6c8", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a96467ec5675e9f69683b5c075a8b15950c341/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=80a96467ec5675e9f69683b5c075a8b15950c341", "patch": "@@ -103,9 +103,9 @@ impl<'a> Validator<'a> {\n \n     fn check_import(&mut self, x: &'a Import) {\n         if x.glob {\n-            self.add_mod_id(x.id.as_ref().unwrap());\n+            self.add_glob_import_item_id(x.id.as_ref().unwrap());\n         } else if let Some(id) = &x.id {\n-            self.add_mod_item_id(id);\n+            self.add_import_item_id(id);\n         }\n     }\n \n@@ -266,7 +266,7 @@ impl<'a> Validator<'a> {\n \n     fn check_path(&mut self, x: &'a Path, kind: PathKind) {\n         match kind {\n-            PathKind::Trait => self.add_trait_id(&x.id),\n+            PathKind::Trait => self.add_trait_or_alias_id(&x.id),\n             PathKind::Type => self.add_type_id(&x.id),\n         }\n         if let Some(args) = &x.args {\n@@ -391,8 +391,8 @@ impl<'a> Validator<'a> {\n         self.add_id_checked(id, Kind::is_variant, \"Variant\");\n     }\n \n-    fn add_trait_id(&mut self, id: &'a Id) {\n-        self.add_id_checked(id, Kind::is_trait, \"Trait\");\n+    fn add_trait_or_alias_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::is_trait_or_alias, \"Trait (or TraitAlias)\");\n     }\n \n     fn add_type_id(&mut self, id: &'a Id) {\n@@ -404,6 +404,15 @@ impl<'a> Validator<'a> {\n         self.add_id_checked(id, Kind::can_appear_in_trait, \"Trait inner item\");\n     }\n \n+    /// Add an Id that can be `use`d\n+    fn add_import_item_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::can_appear_in_import, \"Import inner item\");\n+    }\n+\n+    fn add_glob_import_item_id(&mut self, id: &'a Id) {\n+        self.add_id_checked(id, Kind::can_appear_in_glob_import, \"Glob import inner item\");\n+    }\n+\n     /// Add an Id that appeared in a mod\n     fn add_mod_item_id(&mut self, id: &'a Id) {\n         self.add_id_checked(id, Kind::can_appear_in_mod, \"Module inner item\")"}]}