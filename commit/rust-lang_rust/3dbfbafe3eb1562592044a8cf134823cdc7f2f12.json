{"sha": "3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYmZiYWZlM2ViMTU2MjU5MjA0NGE4Y2YxMzQ4MjNjZGM3ZjJmMTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T17:59:27Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T17:59:27Z"}, "message": "parser: split into {ty, path}.rs", "tree": {"sha": "86c1dd2f152c75e42880197b01d2d9e098abebf4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86c1dd2f152c75e42880197b01d2d9e098abebf4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "html_url": "https://github.com/rust-lang/rust/commit/3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e81347c3685dfc818fca2d502819ee0d1b692621", "url": "https://api.github.com/repos/rust-lang/rust/commits/e81347c3685dfc818fca2d502819ee0d1b692621", "html_url": "https://github.com/rust-lang/rust/commit/e81347c3685dfc818fca2d502819ee0d1b692621"}], "stats": {"total": 1829, "additions": 930, "deletions": 899}, "files": [{"sha": "490abc8edd0b74a0dc6cd70a3a4c253b2eda2cb0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 899, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "patch": "@@ -1,26 +1,25 @@\n-// ignore-tidy-filelength\n-\n mod expr;\n use expr::LhsExpr;\n mod pat;\n mod item;\n pub use item::AliasKind;\n mod module;\n pub use module::{ModulePath, ModulePathSuccess};\n+mod ty;\n+mod path;\n+pub use path::PathStyle;\n \n-use crate::ast::{self, AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n-use crate::ast::{AnonConst, Arg, Attribute, BindingMode};\n+use crate::ast::{self, AttrStyle};\n+use crate::ast::{Arg, Attribute, BindingMode};\n use crate::ast::{Block, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind};\n-use crate::ast::{FnDecl, FunctionRetTy};\n+use crate::ast::{FnDecl};\n use crate::ast::{Ident, IsAsync, Local, Lifetime};\n use crate::ast::{MacStmtStyle, Mac_, MacDelimiter};\n-use crate::ast::{MutTy, Mutability};\n-use crate::ast::{PolyTraitRef, QSelf, PathSegment};\n+use crate::ast::{Mutability};\n use crate::ast::StrStyle;\n use crate::ast::SelfKind;\n-use crate::ast::{GenericBound, TraitBoundModifier, TraitObjectSyntax};\n-use crate::ast::{GenericParam, GenericParamKind, GenericArg, WhereClause};\n-use crate::ast::{Ty, TyKind, AssocTyConstraint, AssocTyConstraintKind, GenericBounds};\n+use crate::ast::{GenericParam, GenericParamKind, WhereClause};\n+use crate::ast::{Ty, TyKind,  GenericBounds};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n use crate::ext::base::DummyResult;\n use crate::ext::hygiene::SyntaxContext;\n@@ -54,29 +53,6 @@ bitflags::bitflags! {\n     }\n }\n \n-/// Specifies how to parse a path.\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum PathStyle {\n-    /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n-    /// with something else. For example, in expressions `segment < ....` can be interpreted\n-    /// as a comparison and `segment ( ....` can be interpreted as a function call.\n-    /// In all such contexts the non-path interpretation is preferred by default for practical\n-    /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n-    /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n-    Expr,\n-    /// In other contexts, notably in types, no ambiguity exists and paths can be written\n-    /// without the disambiguator, e.g., `x<y>` - unambiguously a path.\n-    /// Paths with disambiguators are still accepted, `x::<Y>` - unambiguously a path too.\n-    Type,\n-    /// A path with generic arguments disallowed, e.g., `foo::bar::Baz`, used in imports,\n-    /// visibilities or attributes.\n-    /// Technically, this variant is unnecessary and e.g., `Expr` can be used instead\n-    /// (paths in \"mod\" contexts have to be checked later for absence of generic arguments\n-    /// anyway, due to macros), but it is used to avoid weird suggestions about expected\n-    /// tokens when something goes wrong.\n-    Mod,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Debug)]\n crate enum SemiColonMode {\n     Break,\n@@ -357,16 +333,6 @@ impl TokenType {\n     }\n }\n \n-/// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n-/// `IDENT<<u8 as Trait>::AssocTy>`.\n-///\n-/// Types can also be of the form `IDENT(u8, u8) -> u8`, however this assumes\n-/// that `IDENT` is not the ident of a fn trait.\n-fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n-    t == &token::ModSep || t == &token::Lt ||\n-    t == &token::BinOp(token::Shl)\n-}\n-\n #[derive(Copy, Clone, Debug)]\n crate enum TokenExpectType {\n     Expect,\n@@ -976,50 +942,6 @@ impl<'a> Parser<'a> {\n         self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n     }\n \n-    /// Is the current token one of the keywords that signals a bare function type?\n-    fn token_is_bare_fn_keyword(&mut self) -> bool {\n-        self.check_keyword(kw::Fn) ||\n-            self.check_keyword(kw::Unsafe) ||\n-            self.check_keyword(kw::Extern)\n-    }\n-\n-    /// Parses a `TyKind::BareFn` type.\n-    fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n-        /*\n-\n-        [unsafe] [extern \"ABI\"] fn (S) -> T\n-         ^~~~^           ^~~~^     ^~^    ^\n-           |               |        |     |\n-           |               |        |   Return type\n-           |               |      Argument types\n-           |               |\n-           |              ABI\n-        Function Style\n-        */\n-\n-        let unsafety = self.parse_unsafety();\n-        let abi = if self.eat_keyword(kw::Extern) {\n-            self.parse_opt_abi()?.unwrap_or(Abi::C)\n-        } else {\n-            Abi::Rust\n-        };\n-\n-        self.expect_keyword(kw::Fn)?;\n-        let (inputs, c_variadic) = self.parse_fn_args(false, true)?;\n-        let ret_ty = self.parse_ret_ty(false)?;\n-        let decl = P(FnDecl {\n-            inputs,\n-            output: ret_ty,\n-            c_variadic,\n-        });\n-        Ok(TyKind::BareFn(P(BareFnTy {\n-            abi,\n-            unsafety,\n-            generic_params,\n-            decl,\n-        })))\n-    }\n-\n     /// Parses asyncness: `async` or nothing.\n     fn parse_asyncness(&mut self) -> IsAsync {\n         if self.eat_keyword(kw::Async) {\n@@ -1041,236 +963,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses an optional return type `[ -> TY ]` in a function declaration.\n-    fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n-        if self.eat(&token::RArrow) {\n-            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n-        } else {\n-            Ok(FunctionRetTy::Default(self.token.span.shrink_to_lo()))\n-        }\n-    }\n-\n-    /// Parses a type.\n-    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(true, true, false)\n-    }\n-\n-    /// Parses a type in restricted contexts where `+` is not permitted.\n-    ///\n-    /// Example 1: `&'a TYPE`\n-    ///     `+` is prohibited to maintain operator priority (P(+) < P(&)).\n-    /// Example 2: `value1 as TYPE + value2`\n-    ///     `+` is prohibited to avoid interactions with expression grammar.\n-    fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n-        self.parse_ty_common(false, true, false)\n-    }\n-\n-    fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n-                       allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n-        maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n-        maybe_whole!(self, NtTy, |x| x);\n-\n-        let lo = self.token.span;\n-        let mut impl_dyn_multi = false;\n-        let node = if self.eat(&token::OpenDelim(token::Paren)) {\n-            // `(TYPE)` is a parenthesized type.\n-            // `(TYPE,)` is a tuple with a single field of type TYPE.\n-            let mut ts = vec![];\n-            let mut last_comma = false;\n-            while self.token != token::CloseDelim(token::Paren) {\n-                ts.push(self.parse_ty()?);\n-                if self.eat(&token::Comma) {\n-                    last_comma = true;\n-                } else {\n-                    last_comma = false;\n-                    break;\n-                }\n-            }\n-            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-\n-            if ts.len() == 1 && !last_comma {\n-                let ty = ts.into_iter().nth(0).unwrap().into_inner();\n-                let maybe_bounds = allow_plus && self.token.is_like_plus();\n-                match ty.node {\n-                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n-                    TyKind::Path(None, ref path) if maybe_bounds => {\n-                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n-                    }\n-                    TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n-                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n-                        let path = match bounds[0] {\n-                            GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n-                            GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n-                        };\n-                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n-                    }\n-                    // `(TYPE)`\n-                    _ => TyKind::Paren(P(ty))\n-                }\n-            } else {\n-                TyKind::Tup(ts)\n-            }\n-        } else if self.eat(&token::Not) {\n-            // Never type `!`\n-            TyKind::Never\n-        } else if self.eat(&token::BinOp(token::Star)) {\n-            // Raw pointer\n-            TyKind::Ptr(self.parse_ptr()?)\n-        } else if self.eat(&token::OpenDelim(token::Bracket)) {\n-            // Array or slice\n-            let t = self.parse_ty()?;\n-            // Parse optional `; EXPR` in `[TYPE; EXPR]`\n-            let t = match self.maybe_parse_fixed_length_of_vec()? {\n-                None => TyKind::Slice(t),\n-                Some(length) => TyKind::Array(t, AnonConst {\n-                    id: ast::DUMMY_NODE_ID,\n-                    value: length,\n-                }),\n-            };\n-            self.expect(&token::CloseDelim(token::Bracket))?;\n-            t\n-        } else if self.check(&token::BinOp(token::And)) || self.check(&token::AndAnd) {\n-            // Reference\n-            self.expect_and()?;\n-            self.parse_borrowed_pointee()?\n-        } else if self.eat_keyword_noexpect(kw::Typeof) {\n-            // `typeof(EXPR)`\n-            // In order to not be ambiguous, the type must be surrounded by parens.\n-            self.expect(&token::OpenDelim(token::Paren))?;\n-            let e = AnonConst {\n-                id: ast::DUMMY_NODE_ID,\n-                value: self.parse_expr()?,\n-            };\n-            self.expect(&token::CloseDelim(token::Paren))?;\n-            TyKind::Typeof(e)\n-        } else if self.eat_keyword(kw::Underscore) {\n-            // A type to be inferred `_`\n-            TyKind::Infer\n-        } else if self.token_is_bare_fn_keyword() {\n-            // Function pointer type\n-            self.parse_ty_bare_fn(Vec::new())?\n-        } else if self.check_keyword(kw::For) {\n-            // Function pointer type or bound list (trait object type) starting with a poly-trait.\n-            //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n-            //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n-            let lo = self.token.span;\n-            let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-            if self.token_is_bare_fn_keyword() {\n-                self.parse_ty_bare_fn(lifetime_defs)?\n-            } else {\n-                let path = self.parse_path(PathStyle::Type)?;\n-                let parse_plus = allow_plus && self.check_plus();\n-                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n-            }\n-        } else if self.eat_keyword(kw::Impl) {\n-            // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds(None)?;\n-            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n-            TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n-        } else if self.check_keyword(kw::Dyn) &&\n-                  (self.token.span.rust_2018() ||\n-                   self.look_ahead(1, |t| t.can_begin_bound() &&\n-                                          !can_continue_type_after_non_fn_ident(t))) {\n-            self.bump(); // `dyn`\n-            // Always parse bounds greedily for better error recovery.\n-            let bounds = self.parse_generic_bounds(None)?;\n-            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n-            TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n-        } else if self.check(&token::Question) ||\n-                  self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n-            // Bound list (trait object type)\n-            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus, None)?,\n-                                TraitObjectSyntax::None)\n-        } else if self.eat_lt() {\n-            // Qualified path\n-            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n-            TyKind::Path(Some(qself), path)\n-        } else if self.token.is_path_start() {\n-            // Simple path\n-            let path = self.parse_path(PathStyle::Type)?;\n-            if self.eat(&token::Not) {\n-                // Macro invocation in type position\n-                let (delim, tts) = self.expect_delimited_token_tree()?;\n-                let node = Mac_ {\n-                    path,\n-                    tts,\n-                    delim,\n-                    prior_type_ascription: self.last_type_ascription,\n-                };\n-                TyKind::Mac(respan(lo.to(self.prev_span), node))\n-            } else {\n-                // Just a type path or bound list (trait object type) starting with a trait.\n-                //   `Type`\n-                //   `Trait1 + Trait2 + 'a`\n-                if allow_plus && self.check_plus() {\n-                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n-                } else {\n-                    TyKind::Path(None, path)\n-                }\n-            }\n-        } else if self.check(&token::DotDotDot) {\n-            if allow_c_variadic {\n-                self.eat(&token::DotDotDot);\n-                TyKind::CVarArgs\n-            } else {\n-                return Err(self.fatal(\n-                    \"only foreign functions are allowed to be C-variadic\"\n-                ));\n-            }\n-        } else {\n-            let msg = format!(\"expected type, found {}\", self.this_token_descr());\n-            let mut err = self.fatal(&msg);\n-            err.span_label(self.token.span, \"expected type\");\n-            self.maybe_annotate_with_ascription(&mut err, true);\n-            return Err(err);\n-        };\n-\n-        let span = lo.to(self.prev_span);\n-        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n-\n-        // Try to recover from use of `+` with incorrect priority.\n-        self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n-        self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n-        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n-    }\n-\n-    fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n-                              lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n-        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n-        let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n-        if parse_plus {\n-            self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n-            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_span))?);\n-        }\n-        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n-    }\n-\n-    fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n-        let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n-        let mutbl = self.parse_mutability();\n-        let ty = self.parse_ty_no_plus()?;\n-        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }));\n-    }\n-\n-    fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n-        let mutbl = if self.eat_keyword(kw::Mut) {\n-            Mutability::Mutable\n-        } else if self.eat_keyword(kw::Const) {\n-            Mutability::Immutable\n-        } else {\n-            let span = self.prev_span;\n-            let msg = \"expected mut or const in raw pointer type\";\n-            self.struct_span_err(span, msg)\n-                .span_label(span, msg)\n-                .help(\"use `*mut T` or `*const T` as appropriate\")\n-                .emit();\n-            Mutability::Immutable\n-        };\n-        let t = self.parse_ty_no_plus()?;\n-        Ok(MutTy { ty: t, mutbl })\n-    }\n-\n     fn is_named_argument(&self) -> bool {\n         let offset = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n@@ -1387,25 +1079,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n-        if self.eat(&token::Semi) {\n-            Ok(Some(self.parse_expr()?))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n-            token::Ident(name, _) if name.is_path_segment_keyword() => {\n-                let span = self.token.span;\n-                self.bump();\n-                Ok(Ident::new(name, span))\n-            }\n-            _ => self.parse_ident(),\n-        }\n-    }\n-\n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n             token::Ident(name, false) if name == kw::Underscore => {\n@@ -1417,188 +1090,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a qualified path.\n-    /// Assumes that the leading `<` has been parsed already.\n-    ///\n-    /// `qualified_path = <type [as trait_ref]>::path`\n-    ///\n-    /// # Examples\n-    /// `<T>::default`\n-    /// `<T as U>::a`\n-    /// `<T as U>::F::a<S>` (without disambiguator)\n-    /// `<T as U>::F::a::<S>` (with disambiguator)\n-    fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, ast::Path)> {\n-        let lo = self.prev_span;\n-        let ty = self.parse_ty()?;\n-\n-        // `path` will contain the prefix of the path up to the `>`,\n-        // if any (e.g., `U` in the `<T as U>::*` examples\n-        // above). `path_span` has the span of that path, or an empty\n-        // span in the case of something like `<T>::Bar`.\n-        let (mut path, path_span);\n-        if self.eat_keyword(kw::As) {\n-            let path_lo = self.token.span;\n-            path = self.parse_path(PathStyle::Type)?;\n-            path_span = path_lo.to(self.prev_span);\n-        } else {\n-            path_span = self.token.span.to(self.token.span);\n-            path = ast::Path { segments: Vec::new(), span: path_span };\n-        }\n-\n-        // See doc comment for `unmatched_angle_bracket_count`.\n-        self.expect(&token::Gt)?;\n-        if self.unmatched_angle_bracket_count > 0 {\n-            self.unmatched_angle_bracket_count -= 1;\n-            debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n-        }\n-\n-        self.expect(&token::ModSep)?;\n-\n-        let qself = QSelf { ty, path_span, position: path.segments.len() };\n-        self.parse_path_segments(&mut path.segments, style)?;\n-\n-        Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))\n-    }\n-\n-    /// Parses simple paths.\n-    ///\n-    /// `path = [::] segment+`\n-    /// `segment = ident | ident[::]<args> | ident[::](args) [-> type]`\n-    ///\n-    /// # Examples\n-    /// `a::b::C<D>` (without disambiguator)\n-    /// `a::b::C::<D>` (with disambiguator)\n-    /// `Fn(Args)` (without disambiguator)\n-    /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n-        maybe_whole!(self, NtPath, |path| {\n-            if style == PathStyle::Mod &&\n-               path.segments.iter().any(|segment| segment.args.is_some()) {\n-                self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n-            }\n-            path\n-        });\n-\n-        let lo = self.meta_var_span.unwrap_or(self.token.span);\n-        let mut segments = Vec::new();\n-        let mod_sep_ctxt = self.token.span.ctxt();\n-        if self.eat(&token::ModSep) {\n-            segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n-        }\n-        self.parse_path_segments(&mut segments, style)?;\n-\n-        Ok(ast::Path { segments, span: lo.to(self.prev_span) })\n-    }\n-\n-    /// Like `parse_path`, but also supports parsing `Word` meta items into paths for\n-    /// backwards-compatibility. This is used when parsing derive macro paths in `#[derive]`\n-    /// attributes.\n-    pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n-        let meta_ident = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref meta) => match meta.node {\n-                    ast::MetaItemKind::Word => Some(meta.path.clone()),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-        if let Some(path) = meta_ident {\n-            self.bump();\n-            return Ok(path);\n-        }\n-        self.parse_path(style)\n-    }\n-\n-    crate fn parse_path_segments(&mut self,\n-                           segments: &mut Vec<PathSegment>,\n-                           style: PathStyle)\n-                           -> PResult<'a, ()> {\n-        loop {\n-            let segment = self.parse_path_segment(style)?;\n-            if style == PathStyle::Expr {\n-                // In order to check for trailing angle brackets, we must have finished\n-                // recursing (`parse_path_segment` can indirectly call this function),\n-                // that is, the next token must be the highlighted part of the below example:\n-                //\n-                // `Foo::<Bar as Baz<T>>::Qux`\n-                //                      ^ here\n-                //\n-                // As opposed to the below highlight (if we had only finished the first\n-                // recursion):\n-                //\n-                // `Foo::<Bar as Baz<T>>::Qux`\n-                //                     ^ here\n-                //\n-                // `PathStyle::Expr` is only provided at the root invocation and never in\n-                // `parse_path_segment` to recurse and therefore can be checked to maintain\n-                // this invariant.\n-                self.check_trailing_angle_brackets(&segment, token::ModSep);\n-            }\n-            segments.push(segment);\n-\n-            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n-                return Ok(());\n-            }\n-        }\n-    }\n-\n-    fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n-        let ident = self.parse_path_segment_ident()?;\n-\n-        let is_args_start = |token: &Token| match token.kind {\n-            token::Lt | token::BinOp(token::Shl) | token::OpenDelim(token::Paren)\n-            | token::LArrow => true,\n-            _ => false,\n-        };\n-        let check_args_start = |this: &mut Self| {\n-            this.expected_tokens.extend_from_slice(\n-                &[TokenType::Token(token::Lt), TokenType::Token(token::OpenDelim(token::Paren))]\n-            );\n-            is_args_start(&this.token)\n-        };\n-\n-        Ok(if style == PathStyle::Type && check_args_start(self) ||\n-              style != PathStyle::Mod && self.check(&token::ModSep)\n-                                      && self.look_ahead(1, |t| is_args_start(t)) {\n-            // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n-            // it isn't, then we reset the unmatched angle bracket count as we're about to start\n-            // parsing a new path.\n-            if style == PathStyle::Expr {\n-                self.unmatched_angle_bracket_count = 0;\n-                self.max_angle_bracket_count = 0;\n-            }\n-\n-            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n-            self.eat(&token::ModSep);\n-            let lo = self.token.span;\n-            let args = if self.eat_lt() {\n-                // `<'a, T, A = U>`\n-                let (args, constraints) =\n-                    self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n-                self.expect_gt()?;\n-                let span = lo.to(self.prev_span);\n-                AngleBracketedArgs { args, constraints, span }.into()\n-            } else {\n-                // `(T, U) -> R`\n-                let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n-                let span = lo.to(self.prev_span);\n-                let output = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty_common(false, false, false)?)\n-                } else {\n-                    None\n-                };\n-                ParenthesizedArgs { inputs, output, span }.into()\n-            };\n-\n-            PathSegment { ident, args, id: ast::DUMMY_NODE_ID }\n-        } else {\n-            // Generic arguments are not found.\n-            PathSegment::from_ident(ident)\n-        })\n-    }\n-\n     crate fn check_lifetime(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Lifetime);\n         self.token.is_lifetime()\n@@ -2202,130 +1693,6 @@ impl<'a> Parser<'a> {\n         }).emit();\n     }\n \n-    /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n-    ///\n-    /// ```\n-    /// BOUND = TY_BOUND | LT_BOUND\n-    /// LT_BOUND = LIFETIME (e.g., `'a`)\n-    /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n-    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n-    /// ```\n-    fn parse_generic_bounds_common(&mut self,\n-                                   allow_plus: bool,\n-                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n-        let mut bounds = Vec::new();\n-        let mut negative_bounds = Vec::new();\n-        let mut last_plus_span = None;\n-        let mut was_negative = false;\n-        loop {\n-            // This needs to be synchronized with `TokenKind::can_begin_bound`.\n-            let is_bound_start = self.check_path() || self.check_lifetime() ||\n-                                 self.check(&token::Not) || // used for error reporting only\n-                                 self.check(&token::Question) ||\n-                                 self.check_keyword(kw::For) ||\n-                                 self.check(&token::OpenDelim(token::Paren));\n-            if is_bound_start {\n-                let lo = self.token.span;\n-                let has_parens = self.eat(&token::OpenDelim(token::Paren));\n-                let inner_lo = self.token.span;\n-                let is_negative = self.eat(&token::Not);\n-                let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n-                if self.token.is_lifetime() {\n-                    if let Some(question_span) = question {\n-                        self.span_err(question_span,\n-                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n-                    }\n-                    bounds.push(GenericBound::Outlives(self.expect_lifetime()));\n-                    if has_parens {\n-                        let inner_span = inner_lo.to(self.prev_span);\n-                        self.expect(&token::CloseDelim(token::Paren))?;\n-                        let mut err = self.struct_span_err(\n-                            lo.to(self.prev_span),\n-                            \"parenthesized lifetime bounds are not supported\"\n-                        );\n-                        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n-                            err.span_suggestion_short(\n-                                lo.to(self.prev_span),\n-                                \"remove the parentheses\",\n-                                snippet.to_owned(),\n-                                Applicability::MachineApplicable\n-                            );\n-                        }\n-                        err.emit();\n-                    }\n-                } else {\n-                    let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-                    let path = self.parse_path(PathStyle::Type)?;\n-                    if has_parens {\n-                        self.expect(&token::CloseDelim(token::Paren))?;\n-                    }\n-                    let poly_span = lo.to(self.prev_span);\n-                    if is_negative {\n-                        was_negative = true;\n-                        if let Some(sp) = last_plus_span.or(colon_span) {\n-                            negative_bounds.push(sp.to(poly_span));\n-                        }\n-                    } else {\n-                        let poly_trait = PolyTraitRef::new(lifetime_defs, path, poly_span);\n-                        let modifier = if question.is_some() {\n-                            TraitBoundModifier::Maybe\n-                        } else {\n-                            TraitBoundModifier::None\n-                        };\n-                        bounds.push(GenericBound::Trait(poly_trait, modifier));\n-                    }\n-                }\n-            } else {\n-                break\n-            }\n-\n-            if !allow_plus || !self.eat_plus() {\n-                break\n-            } else {\n-                last_plus_span = Some(self.prev_span);\n-            }\n-        }\n-\n-        if !negative_bounds.is_empty() || was_negative {\n-            let plural = negative_bounds.len() > 1;\n-            let last_span = negative_bounds.last().map(|sp| *sp);\n-            let mut err = self.struct_span_err(\n-                negative_bounds,\n-                \"negative trait bounds are not supported\",\n-            );\n-            if let Some(sp) = last_span {\n-                err.span_label(sp, \"negative trait bounds are not supported\");\n-            }\n-            if let Some(bound_list) = colon_span {\n-                let bound_list = bound_list.to(self.prev_span);\n-                let mut new_bound_list = String::new();\n-                if !bounds.is_empty() {\n-                    let mut snippets = bounds.iter().map(|bound| bound.span())\n-                        .map(|span| self.span_to_snippet(span));\n-                    while let Some(Ok(snippet)) = snippets.next() {\n-                        new_bound_list.push_str(\" + \");\n-                        new_bound_list.push_str(&snippet);\n-                    }\n-                    new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n-                }\n-                err.span_suggestion_hidden(\n-                    bound_list,\n-                    &format!(\"remove the trait bound{}\", if plural { \"s\" } else { \"\" }),\n-                    new_bound_list,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        return Ok(bounds);\n-    }\n-\n-    crate fn parse_generic_bounds(&mut self,\n-                                  colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n-        self.parse_generic_bounds_common(true, colon_span)\n-    }\n-\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     ///\n     /// ```\n@@ -2475,250 +1842,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parses generic args (within a path segment) with recovery for extra leading angle brackets.\n-    /// For the purposes of understanding the parsing logic of generic arguments, this function\n-    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n-    /// had the correct amount of leading angle brackets.\n-    ///\n-    /// ```ignore (diagnostics)\n-    /// bar::<<<<T as Foo>::Output>();\n-    ///      ^^ help: remove extra angle brackets\n-    /// ```\n-    fn parse_generic_args_with_leaning_angle_bracket_recovery(\n-        &mut self,\n-        style: PathStyle,\n-        lo: Span,\n-    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n-        // We need to detect whether there are extra leading left angle brackets and produce an\n-        // appropriate error and suggestion. This cannot be implemented by looking ahead at\n-        // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n-        // then there won't be matching `>` tokens to find.\n-        //\n-        // To explain how this detection works, consider the following example:\n-        //\n-        // ```ignore (diagnostics)\n-        // bar::<<<<T as Foo>::Output>();\n-        //      ^^ help: remove extra angle brackets\n-        // ```\n-        //\n-        // Parsing of the left angle brackets starts in this function. We start by parsing the\n-        // `<` token (incrementing the counter of unmatched angle brackets on `Parser` via\n-        // `eat_lt`):\n-        //\n-        // *Upcoming tokens:* `<<<<T as Foo>::Output>;`\n-        // *Unmatched count:* 1\n-        // *`parse_path_segment` calls deep:* 0\n-        //\n-        // This has the effect of recursing as this function is called if a `<` character\n-        // is found within the expected generic arguments:\n-        //\n-        // *Upcoming tokens:* `<<<T as Foo>::Output>;`\n-        // *Unmatched count:* 2\n-        // *`parse_path_segment` calls deep:* 1\n-        //\n-        // Eventually we will have recursed until having consumed all of the `<` tokens and\n-        // this will be reflected in the count:\n-        //\n-        // *Upcoming tokens:* `T as Foo>::Output>;`\n-        // *Unmatched count:* 4\n-        // `parse_path_segment` calls deep:* 3\n-        //\n-        // The parser will continue until reaching the first `>` - this will decrement the\n-        // unmatched angle bracket count and return to the parent invocation of this function\n-        // having succeeded in parsing:\n-        //\n-        // *Upcoming tokens:* `::Output>;`\n-        // *Unmatched count:* 3\n-        // *`parse_path_segment` calls deep:* 2\n-        //\n-        // This will continue until the next `>` character which will also return successfully\n-        // to the parent invocation of this function and decrement the count:\n-        //\n-        // *Upcoming tokens:* `;`\n-        // *Unmatched count:* 2\n-        // *`parse_path_segment` calls deep:* 1\n-        //\n-        // At this point, this function will expect to find another matching `>` character but\n-        // won't be able to and will return an error. This will continue all the way up the\n-        // call stack until the first invocation:\n-        //\n-        // *Upcoming tokens:* `;`\n-        // *Unmatched count:* 2\n-        // *`parse_path_segment` calls deep:* 0\n-        //\n-        // In doing this, we have managed to work out how many unmatched leading left angle\n-        // brackets there are, but we cannot recover as the unmatched angle brackets have\n-        // already been consumed. To remedy this, we keep a snapshot of the parser state\n-        // before we do the above. We can then inspect whether we ended up with a parsing error\n-        // and unmatched left angle brackets and if so, restore the parser state before we\n-        // consumed any `<` characters to emit an error and consume the erroneous tokens to\n-        // recover by attempting to parse again.\n-        //\n-        // In practice, the recursion of this function is indirect and there will be other\n-        // locations that consume some `<` characters - as long as we update the count when\n-        // this happens, it isn't an issue.\n-\n-        let is_first_invocation = style == PathStyle::Expr;\n-        // Take a snapshot before attempting to parse - we can restore this later.\n-        let snapshot = if is_first_invocation {\n-            Some(self.clone())\n-        } else {\n-            None\n-        };\n-\n-        debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n-        match self.parse_generic_args() {\n-            Ok(value) => Ok(value),\n-            Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n-                // Cancel error from being unable to find `>`. We know the error\n-                // must have been this due to a non-zero unmatched angle bracket\n-                // count.\n-                e.cancel();\n-\n-                // Swap `self` with our backup of the parser state before attempting to parse\n-                // generic arguments.\n-                let snapshot = mem::replace(self, snapshot.unwrap());\n-\n-                debug!(\n-                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n-                     snapshot.count={:?}\",\n-                    snapshot.unmatched_angle_bracket_count,\n-                );\n-\n-                // Eat the unmatched angle brackets.\n-                for _ in 0..snapshot.unmatched_angle_bracket_count {\n-                    self.eat_lt();\n-                }\n-\n-                // Make a span over ${unmatched angle bracket count} characters.\n-                let span = lo.with_hi(\n-                    lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n-                );\n-                let plural = snapshot.unmatched_angle_bracket_count > 1;\n-                self.diagnostic()\n-                    .struct_span_err(\n-                        span,\n-                        &format!(\n-                            \"unmatched angle bracket{}\",\n-                            if plural { \"s\" } else { \"\" }\n-                        ),\n-                    )\n-                    .span_suggestion(\n-                        span,\n-                        &format!(\n-                            \"remove extra angle bracket{}\",\n-                            if plural { \"s\" } else { \"\" }\n-                        ),\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-\n-                // Try again without unmatched angle bracket characters.\n-                self.parse_generic_args()\n-            },\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n-    /// possibly including trailing comma.\n-    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n-        let mut args = Vec::new();\n-        let mut constraints = Vec::new();\n-        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n-        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n-\n-        let args_lo = self.token.span;\n-\n-        loop {\n-            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n-                // Parse lifetime argument.\n-                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else if self.check_ident() && self.look_ahead(1,\n-                    |t| t == &token::Eq || t == &token::Colon) {\n-                // Parse associated type constraint.\n-                let lo = self.token.span;\n-                let ident = self.parse_ident()?;\n-                let kind = if self.eat(&token::Eq) {\n-                    AssocTyConstraintKind::Equality {\n-                        ty: self.parse_ty()?,\n-                    }\n-                } else if self.eat(&token::Colon) {\n-                    AssocTyConstraintKind::Bound {\n-                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n-                    }\n-                } else {\n-                    unreachable!();\n-                };\n-                let span = lo.to(self.prev_span);\n-                constraints.push(AssocTyConstraint {\n-                    id: ast::DUMMY_NODE_ID,\n-                    ident,\n-                    kind,\n-                    span,\n-                });\n-                assoc_ty_constraints.push(span);\n-            } else if self.check_const_arg() {\n-                // Parse const argument.\n-                let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n-                    self.parse_block_expr(\n-                        None, self.token.span, BlockCheckMode::Default, ThinVec::new()\n-                    )?\n-                } else if self.token.is_ident() {\n-                    // FIXME(const_generics): to distinguish between idents for types and consts,\n-                    // we should introduce a GenericArg::Ident in the AST and distinguish when\n-                    // lowering to the HIR. For now, idents for const args are not permitted.\n-                    if self.token.is_keyword(kw::True) || self.token.is_keyword(kw::False) {\n-                        self.parse_literal_maybe_minus()?\n-                    } else {\n-                        return Err(\n-                            self.fatal(\"identifiers may currently not be used for const generics\")\n-                        );\n-                    }\n-                } else {\n-                    self.parse_literal_maybe_minus()?\n-                };\n-                let value = AnonConst {\n-                    id: ast::DUMMY_NODE_ID,\n-                    value: expr,\n-                };\n-                args.push(GenericArg::Const(value));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else if self.check_type() {\n-                // Parse type argument.\n-                args.push(GenericArg::Type(self.parse_ty()?));\n-                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n-            } else {\n-                break\n-            }\n-\n-            if !self.eat(&token::Comma) {\n-                break\n-            }\n-        }\n-\n-        // FIXME: we would like to report this in ast_validation instead, but we currently do not\n-        // preserve ordering of generic parameters with respect to associated type binding, so we\n-        // lose that information after parsing.\n-        if misplaced_assoc_ty_constraints.len() > 0 {\n-            let mut err = self.struct_span_err(\n-                args_lo.to(self.prev_span),\n-                \"associated type bindings must be declared after generic parameters\",\n-            );\n-            for span in misplaced_assoc_ty_constraints {\n-                err.span_label(\n-                    span,\n-                    \"this associated type binding should be moved after the generic parameters\",\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        Ok((args, constraints))\n-    }\n-\n     /// Parses an optional where-clause and places it in `generics`.\n     ///\n     /// ```ignore (only-for-syntax-highlight)\n@@ -3087,19 +2210,6 @@ impl<'a> Parser<'a> {\n             self.is_keyword_ahead(1, &[kw::Const]))\n     }\n \n-    fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n-        if self.eat_keyword(kw::For) {\n-            self.expect_lt()?;\n-            let params = self.parse_generic_params()?;\n-            self.expect_gt()?;\n-            // We rely on AST validation to rule out invalid cases: There must not be type\n-            // parameters, and the lifetime parameters must not have bounds.\n-            Ok(params)\n-        } else {\n-            Ok(Vec::new())\n-        }\n-    }\n-\n     /// Parses `pub`, `pub(crate)` and `pub(in path)` plus shortcuts `crate` for `pub(crate)`,\n     /// `pub(self)` for `pub(in self)` and `pub(super)` for `pub(in super)`.\n     /// If the following element can't be a tuple (i.e., it's a function definition), then"}, {"sha": "2760cd38cabc6b53c44614092b4c9ae6ced6a73d", "filename": "src/libsyntax/parse/parser/path.rs", "status": "added", "additions": 474, "deletions": 0, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "patch": "@@ -0,0 +1,474 @@\n+use super::{Parser, PResult, TokenType, BlockCheckMode};\n+\n+use crate::{maybe_whole, ThinVec};\n+use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n+use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind};\n+use crate::parse::token::{self, Token};\n+use crate::source_map::{Span, BytePos};\n+use crate::symbol::{kw};\n+\n+use std::mem;\n+use log::debug;\n+use errors::{Applicability};\n+\n+/// Specifies how to parse a path.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum PathStyle {\n+    /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n+    /// with something else. For example, in expressions `segment < ....` can be interpreted\n+    /// as a comparison and `segment ( ....` can be interpreted as a function call.\n+    /// In all such contexts the non-path interpretation is preferred by default for practical\n+    /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n+    /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n+    Expr,\n+    /// In other contexts, notably in types, no ambiguity exists and paths can be written\n+    /// without the disambiguator, e.g., `x<y>` - unambiguously a path.\n+    /// Paths with disambiguators are still accepted, `x::<Y>` - unambiguously a path too.\n+    Type,\n+    /// A path with generic arguments disallowed, e.g., `foo::bar::Baz`, used in imports,\n+    /// visibilities or attributes.\n+    /// Technically, this variant is unnecessary and e.g., `Expr` can be used instead\n+    /// (paths in \"mod\" contexts have to be checked later for absence of generic arguments\n+    /// anyway, due to macros), but it is used to avoid weird suggestions about expected\n+    /// tokens when something goes wrong.\n+    Mod,\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a qualified path.\n+    /// Assumes that the leading `<` has been parsed already.\n+    ///\n+    /// `qualified_path = <type [as trait_ref]>::path`\n+    ///\n+    /// # Examples\n+    /// `<T>::default`\n+    /// `<T as U>::a`\n+    /// `<T as U>::F::a<S>` (without disambiguator)\n+    /// `<T as U>::F::a::<S>` (with disambiguator)\n+    pub(super) fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, Path)> {\n+        let lo = self.prev_span;\n+        let ty = self.parse_ty()?;\n+\n+        // `path` will contain the prefix of the path up to the `>`,\n+        // if any (e.g., `U` in the `<T as U>::*` examples\n+        // above). `path_span` has the span of that path, or an empty\n+        // span in the case of something like `<T>::Bar`.\n+        let (mut path, path_span);\n+        if self.eat_keyword(kw::As) {\n+            let path_lo = self.token.span;\n+            path = self.parse_path(PathStyle::Type)?;\n+            path_span = path_lo.to(self.prev_span);\n+        } else {\n+            path_span = self.token.span.to(self.token.span);\n+            path = ast::Path { segments: Vec::new(), span: path_span };\n+        }\n+\n+        // See doc comment for `unmatched_angle_bracket_count`.\n+        self.expect(&token::Gt)?;\n+        if self.unmatched_angle_bracket_count > 0 {\n+            self.unmatched_angle_bracket_count -= 1;\n+            debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+        }\n+\n+        self.expect(&token::ModSep)?;\n+\n+        let qself = QSelf { ty, path_span, position: path.segments.len() };\n+        self.parse_path_segments(&mut path.segments, style)?;\n+\n+        Ok((qself, Path { segments: path.segments, span: lo.to(self.prev_span) }))\n+    }\n+\n+    /// Parses simple paths.\n+    ///\n+    /// `path = [::] segment+`\n+    /// `segment = ident | ident[::]<args> | ident[::](args) [-> type]`\n+    ///\n+    /// # Examples\n+    /// `a::b::C<D>` (without disambiguator)\n+    /// `a::b::C::<D>` (with disambiguator)\n+    /// `Fn(Args)` (without disambiguator)\n+    /// `Fn::(Args)` (with disambiguator)\n+    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+        maybe_whole!(self, NtPath, |path| {\n+            if style == PathStyle::Mod &&\n+               path.segments.iter().any(|segment| segment.args.is_some()) {\n+                self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n+            }\n+            path\n+        });\n+\n+        let lo = self.meta_var_span.unwrap_or(self.token.span);\n+        let mut segments = Vec::new();\n+        let mod_sep_ctxt = self.token.span.ctxt();\n+        if self.eat(&token::ModSep) {\n+            segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n+        }\n+        self.parse_path_segments(&mut segments, style)?;\n+\n+        Ok(Path { segments, span: lo.to(self.prev_span) })\n+    }\n+\n+    /// Like `parse_path`, but also supports parsing `Word` meta items into paths for\n+    /// backwards-compatibility. This is used when parsing derive macro paths in `#[derive]`\n+    /// attributes.\n+    pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+        let meta_ident = match self.token.kind {\n+            token::Interpolated(ref nt) => match **nt {\n+                token::NtMeta(ref meta) => match meta.node {\n+                    ast::MetaItemKind::Word => Some(meta.path.clone()),\n+                    _ => None,\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        if let Some(path) = meta_ident {\n+            self.bump();\n+            return Ok(path);\n+        }\n+        self.parse_path(style)\n+    }\n+\n+    crate fn parse_path_segments(&mut self,\n+                           segments: &mut Vec<PathSegment>,\n+                           style: PathStyle)\n+                           -> PResult<'a, ()> {\n+        loop {\n+            let segment = self.parse_path_segment(style)?;\n+            if style == PathStyle::Expr {\n+                // In order to check for trailing angle brackets, we must have finished\n+                // recursing (`parse_path_segment` can indirectly call this function),\n+                // that is, the next token must be the highlighted part of the below example:\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                      ^ here\n+                //\n+                // As opposed to the below highlight (if we had only finished the first\n+                // recursion):\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                     ^ here\n+                //\n+                // `PathStyle::Expr` is only provided at the root invocation and never in\n+                // `parse_path_segment` to recurse and therefore can be checked to maintain\n+                // this invariant.\n+                self.check_trailing_angle_brackets(&segment, token::ModSep);\n+            }\n+            segments.push(segment);\n+\n+            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+                return Ok(());\n+            }\n+        }\n+    }\n+\n+    pub(super) fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n+        let ident = self.parse_path_segment_ident()?;\n+\n+        let is_args_start = |token: &Token| match token.kind {\n+            token::Lt | token::BinOp(token::Shl) | token::OpenDelim(token::Paren)\n+            | token::LArrow => true,\n+            _ => false,\n+        };\n+        let check_args_start = |this: &mut Self| {\n+            this.expected_tokens.extend_from_slice(\n+                &[TokenType::Token(token::Lt), TokenType::Token(token::OpenDelim(token::Paren))]\n+            );\n+            is_args_start(&this.token)\n+        };\n+\n+        Ok(if style == PathStyle::Type && check_args_start(self) ||\n+              style != PathStyle::Mod && self.check(&token::ModSep)\n+                                      && self.look_ahead(1, |t| is_args_start(t)) {\n+            // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n+            // it isn't, then we reset the unmatched angle bracket count as we're about to start\n+            // parsing a new path.\n+            if style == PathStyle::Expr {\n+                self.unmatched_angle_bracket_count = 0;\n+                self.max_angle_bracket_count = 0;\n+            }\n+\n+            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n+            self.eat(&token::ModSep);\n+            let lo = self.token.span;\n+            let args = if self.eat_lt() {\n+                // `<'a, T, A = U>`\n+                let (args, constraints) =\n+                    self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n+                self.expect_gt()?;\n+                let span = lo.to(self.prev_span);\n+                AngleBracketedArgs { args, constraints, span }.into()\n+            } else {\n+                // `(T, U) -> R`\n+                let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n+                let span = lo.to(self.prev_span);\n+                let output = if self.eat(&token::RArrow) {\n+                    Some(self.parse_ty_common(false, false, false)?)\n+                } else {\n+                    None\n+                };\n+                ParenthesizedArgs { inputs, output, span }.into()\n+            };\n+\n+            PathSegment { ident, args, id: ast::DUMMY_NODE_ID }\n+        } else {\n+            // Generic arguments are not found.\n+            PathSegment::from_ident(ident)\n+        })\n+    }\n+\n+    pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n+        match self.token.kind {\n+            token::Ident(name, _) if name.is_path_segment_keyword() => {\n+                let span = self.token.span;\n+                self.bump();\n+                Ok(Ident::new(name, span))\n+            }\n+            _ => self.parse_ident(),\n+        }\n+    }\n+\n+    /// Parses generic args (within a path segment) with recovery for extra leading angle brackets.\n+    /// For the purposes of understanding the parsing logic of generic arguments, this function\n+    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n+    /// had the correct amount of leading angle brackets.\n+    ///\n+    /// ```ignore (diagnostics)\n+    /// bar::<<<<T as Foo>::Output>();\n+    ///      ^^ help: remove extra angle brackets\n+    /// ```\n+    fn parse_generic_args_with_leaning_angle_bracket_recovery(\n+        &mut self,\n+        style: PathStyle,\n+        lo: Span,\n+    ) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+        // We need to detect whether there are extra leading left angle brackets and produce an\n+        // appropriate error and suggestion. This cannot be implemented by looking ahead at\n+        // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n+        // then there won't be matching `>` tokens to find.\n+        //\n+        // To explain how this detection works, consider the following example:\n+        //\n+        // ```ignore (diagnostics)\n+        // bar::<<<<T as Foo>::Output>();\n+        //      ^^ help: remove extra angle brackets\n+        // ```\n+        //\n+        // Parsing of the left angle brackets starts in this function. We start by parsing the\n+        // `<` token (incrementing the counter of unmatched angle brackets on `Parser` via\n+        // `eat_lt`):\n+        //\n+        // *Upcoming tokens:* `<<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 1\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // This has the effect of recursing as this function is called if a `<` character\n+        // is found within the expected generic arguments:\n+        //\n+        // *Upcoming tokens:* `<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // Eventually we will have recursed until having consumed all of the `<` tokens and\n+        // this will be reflected in the count:\n+        //\n+        // *Upcoming tokens:* `T as Foo>::Output>;`\n+        // *Unmatched count:* 4\n+        // `parse_path_segment` calls deep:* 3\n+        //\n+        // The parser will continue until reaching the first `>` - this will decrement the\n+        // unmatched angle bracket count and return to the parent invocation of this function\n+        // having succeeded in parsing:\n+        //\n+        // *Upcoming tokens:* `::Output>;`\n+        // *Unmatched count:* 3\n+        // *`parse_path_segment` calls deep:* 2\n+        //\n+        // This will continue until the next `>` character which will also return successfully\n+        // to the parent invocation of this function and decrement the count:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // At this point, this function will expect to find another matching `>` character but\n+        // won't be able to and will return an error. This will continue all the way up the\n+        // call stack until the first invocation:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // In doing this, we have managed to work out how many unmatched leading left angle\n+        // brackets there are, but we cannot recover as the unmatched angle brackets have\n+        // already been consumed. To remedy this, we keep a snapshot of the parser state\n+        // before we do the above. We can then inspect whether we ended up with a parsing error\n+        // and unmatched left angle brackets and if so, restore the parser state before we\n+        // consumed any `<` characters to emit an error and consume the erroneous tokens to\n+        // recover by attempting to parse again.\n+        //\n+        // In practice, the recursion of this function is indirect and there will be other\n+        // locations that consume some `<` characters - as long as we update the count when\n+        // this happens, it isn't an issue.\n+\n+        let is_first_invocation = style == PathStyle::Expr;\n+        // Take a snapshot before attempting to parse - we can restore this later.\n+        let snapshot = if is_first_invocation {\n+            Some(self.clone())\n+        } else {\n+            None\n+        };\n+\n+        debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n+        match self.parse_generic_args() {\n+            Ok(value) => Ok(value),\n+            Err(ref mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n+                // Cancel error from being unable to find `>`. We know the error\n+                // must have been this due to a non-zero unmatched angle bracket\n+                // count.\n+                e.cancel();\n+\n+                // Swap `self` with our backup of the parser state before attempting to parse\n+                // generic arguments.\n+                let snapshot = mem::replace(self, snapshot.unwrap());\n+\n+                debug!(\n+                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n+                     snapshot.count={:?}\",\n+                    snapshot.unmatched_angle_bracket_count,\n+                );\n+\n+                // Eat the unmatched angle brackets.\n+                for _ in 0..snapshot.unmatched_angle_bracket_count {\n+                    self.eat_lt();\n+                }\n+\n+                // Make a span over ${unmatched angle bracket count} characters.\n+                let span = lo.with_hi(\n+                    lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n+                );\n+                let plural = snapshot.unmatched_angle_bracket_count > 1;\n+                self.diagnostic()\n+                    .struct_span_err(\n+                        span,\n+                        &format!(\n+                            \"unmatched angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                    )\n+                    .span_suggestion(\n+                        span,\n+                        &format!(\n+                            \"remove extra angle bracket{}\",\n+                            if plural { \"s\" } else { \"\" }\n+                        ),\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+\n+                // Try again without unmatched angle bracket characters.\n+                self.parse_generic_args()\n+            },\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n+    /// possibly including trailing comma.\n+    fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<AssocTyConstraint>)> {\n+        let mut args = Vec::new();\n+        let mut constraints = Vec::new();\n+        let mut misplaced_assoc_ty_constraints: Vec<Span> = Vec::new();\n+        let mut assoc_ty_constraints: Vec<Span> = Vec::new();\n+\n+        let args_lo = self.token.span;\n+\n+        loop {\n+            if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n+                // Parse lifetime argument.\n+                args.push(GenericArg::Lifetime(self.expect_lifetime()));\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else if self.check_ident() && self.look_ahead(1,\n+                    |t| t == &token::Eq || t == &token::Colon) {\n+                // Parse associated type constraint.\n+                let lo = self.token.span;\n+                let ident = self.parse_ident()?;\n+                let kind = if self.eat(&token::Eq) {\n+                    AssocTyConstraintKind::Equality {\n+                        ty: self.parse_ty()?,\n+                    }\n+                } else if self.eat(&token::Colon) {\n+                    AssocTyConstraintKind::Bound {\n+                        bounds: self.parse_generic_bounds(Some(self.prev_span))?,\n+                    }\n+                } else {\n+                    unreachable!();\n+                };\n+                let span = lo.to(self.prev_span);\n+                constraints.push(AssocTyConstraint {\n+                    id: ast::DUMMY_NODE_ID,\n+                    ident,\n+                    kind,\n+                    span,\n+                });\n+                assoc_ty_constraints.push(span);\n+            } else if self.check_const_arg() {\n+                // Parse const argument.\n+                let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n+                    self.parse_block_expr(\n+                        None, self.token.span, BlockCheckMode::Default, ThinVec::new()\n+                    )?\n+                } else if self.token.is_ident() {\n+                    // FIXME(const_generics): to distinguish between idents for types and consts,\n+                    // we should introduce a GenericArg::Ident in the AST and distinguish when\n+                    // lowering to the HIR. For now, idents for const args are not permitted.\n+                    if self.token.is_keyword(kw::True) || self.token.is_keyword(kw::False) {\n+                        self.parse_literal_maybe_minus()?\n+                    } else {\n+                        return Err(\n+                            self.fatal(\"identifiers may currently not be used for const generics\")\n+                        );\n+                    }\n+                } else {\n+                    self.parse_literal_maybe_minus()?\n+                };\n+                let value = AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: expr,\n+                };\n+                args.push(GenericArg::Const(value));\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else if self.check_type() {\n+                // Parse type argument.\n+                args.push(GenericArg::Type(self.parse_ty()?));\n+                misplaced_assoc_ty_constraints.append(&mut assoc_ty_constraints);\n+            } else {\n+                break\n+            }\n+\n+            if !self.eat(&token::Comma) {\n+                break\n+            }\n+        }\n+\n+        // FIXME: we would like to report this in ast_validation instead, but we currently do not\n+        // preserve ordering of generic parameters with respect to associated type binding, so we\n+        // lose that information after parsing.\n+        if misplaced_assoc_ty_constraints.len() > 0 {\n+            let mut err = self.struct_span_err(\n+                args_lo.to(self.prev_span),\n+                \"associated type bindings must be declared after generic parameters\",\n+            );\n+            for span in misplaced_assoc_ty_constraints {\n+                err.span_label(\n+                    span,\n+                    \"this associated type binding should be moved after the generic parameters\",\n+                );\n+            }\n+            err.emit();\n+        }\n+\n+        Ok((args, constraints))\n+    }\n+}"}, {"sha": "a5a073c3af1a9f952b58b05ecc2d9c1f2f3d588d", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dbfbafe3eb1562592044a8cf134823cdc7f2f12/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=3dbfbafe3eb1562592044a8cf134823cdc7f2f12", "patch": "@@ -0,0 +1,447 @@\n+use super::{Parser, PResult, PathStyle, PrevTokenKind};\n+\n+use crate::{maybe_whole, maybe_recover_from_interpolated_ty_qpath};\n+use crate::ptr::P;\n+use crate::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam};\n+use crate::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n+use crate::ast::{Mutability, AnonConst, FnDecl, Mac_};\n+use crate::parse::token::{self, Token};\n+use crate::source_map::{respan, Span};\n+use crate::symbol::{kw};\n+\n+use rustc_target::spec::abi::Abi;\n+\n+use errors::{Applicability};\n+\n+/// Returns `true` if `IDENT t` can start a type -- `IDENT::a::b`, `IDENT<u8, u8>`,\n+/// `IDENT<<u8 as Trait>::AssocTy>`.\n+///\n+/// Types can also be of the form `IDENT(u8, u8) -> u8`, however this assumes\n+/// that `IDENT` is not the ident of a fn trait.\n+fn can_continue_type_after_non_fn_ident(t: &Token) -> bool {\n+    t == &token::ModSep || t == &token::Lt ||\n+    t == &token::BinOp(token::Shl)\n+}\n+\n+impl<'a> Parser<'a> {\n+    /// Parses a type.\n+    pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(true, true, false)\n+    }\n+\n+    /// Parses a type in restricted contexts where `+` is not permitted.\n+    ///\n+    /// Example 1: `&'a TYPE`\n+    ///     `+` is prohibited to maintain operator priority (P(+) < P(&)).\n+    /// Example 2: `value1 as TYPE + value2`\n+    ///     `+` is prohibited to avoid interactions with expression grammar.\n+    pub(super) fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(false, true, false)\n+    }\n+\n+    /// Parses an optional return type `[ -> TY ]` in a function declaration.\n+    pub(super) fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n+        if self.eat(&token::RArrow) {\n+            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n+        } else {\n+            Ok(FunctionRetTy::Default(self.token.span.shrink_to_lo()))\n+        }\n+    }\n+\n+    pub(super) fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n+                       allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n+        maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n+        maybe_whole!(self, NtTy, |x| x);\n+\n+        let lo = self.token.span;\n+        let mut impl_dyn_multi = false;\n+        let node = if self.eat(&token::OpenDelim(token::Paren)) {\n+            // `(TYPE)` is a parenthesized type.\n+            // `(TYPE,)` is a tuple with a single field of type TYPE.\n+            let mut ts = vec![];\n+            let mut last_comma = false;\n+            while self.token != token::CloseDelim(token::Paren) {\n+                ts.push(self.parse_ty()?);\n+                if self.eat(&token::Comma) {\n+                    last_comma = true;\n+                } else {\n+                    last_comma = false;\n+                    break;\n+                }\n+            }\n+            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+\n+            if ts.len() == 1 && !last_comma {\n+                let ty = ts.into_iter().nth(0).unwrap().into_inner();\n+                let maybe_bounds = allow_plus && self.token.is_like_plus();\n+                match ty.node {\n+                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n+                    TyKind::Path(None, ref path) if maybe_bounds => {\n+                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n+                    }\n+                    TyKind::TraitObject(ref bounds, TraitObjectSyntax::None)\n+                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                        let path = match bounds[0] {\n+                            GenericBound::Trait(ref pt, ..) => pt.trait_ref.path.clone(),\n+                            GenericBound::Outlives(..) => self.bug(\"unexpected lifetime bound\"),\n+                        };\n+                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                    }\n+                    // `(TYPE)`\n+                    _ => TyKind::Paren(P(ty))\n+                }\n+            } else {\n+                TyKind::Tup(ts)\n+            }\n+        } else if self.eat(&token::Not) {\n+            // Never type `!`\n+            TyKind::Never\n+        } else if self.eat(&token::BinOp(token::Star)) {\n+            // Raw pointer\n+            TyKind::Ptr(self.parse_ptr()?)\n+        } else if self.eat(&token::OpenDelim(token::Bracket)) {\n+            // Array or slice\n+            let t = self.parse_ty()?;\n+            // Parse optional `; EXPR` in `[TYPE; EXPR]`\n+            let t = match self.maybe_parse_fixed_length_of_vec()? {\n+                None => TyKind::Slice(t),\n+                Some(length) => TyKind::Array(t, AnonConst {\n+                    id: ast::DUMMY_NODE_ID,\n+                    value: length,\n+                }),\n+            };\n+            self.expect(&token::CloseDelim(token::Bracket))?;\n+            t\n+        } else if self.check(&token::BinOp(token::And)) || self.check(&token::AndAnd) {\n+            // Reference\n+            self.expect_and()?;\n+            self.parse_borrowed_pointee()?\n+        } else if self.eat_keyword_noexpect(kw::Typeof) {\n+            // `typeof(EXPR)`\n+            // In order to not be ambiguous, the type must be surrounded by parens.\n+            self.expect(&token::OpenDelim(token::Paren))?;\n+            let e = AnonConst {\n+                id: ast::DUMMY_NODE_ID,\n+                value: self.parse_expr()?,\n+            };\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            TyKind::Typeof(e)\n+        } else if self.eat_keyword(kw::Underscore) {\n+            // A type to be inferred `_`\n+            TyKind::Infer\n+        } else if self.token_is_bare_fn_keyword() {\n+            // Function pointer type\n+            self.parse_ty_bare_fn(Vec::new())?\n+        } else if self.check_keyword(kw::For) {\n+            // Function pointer type or bound list (trait object type) starting with a poly-trait.\n+            //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n+            //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n+            let lo = self.token.span;\n+            let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+            if self.token_is_bare_fn_keyword() {\n+                self.parse_ty_bare_fn(lifetime_defs)?\n+            } else {\n+                let path = self.parse_path(PathStyle::Type)?;\n+                let parse_plus = allow_plus && self.check_plus();\n+                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n+            }\n+        } else if self.eat_keyword(kw::Impl) {\n+            // Always parse bounds greedily for better error recovery.\n+            let bounds = self.parse_generic_bounds(None)?;\n+            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+            TyKind::ImplTrait(ast::DUMMY_NODE_ID, bounds)\n+        } else if self.check_keyword(kw::Dyn) &&\n+                  (self.token.span.rust_2018() ||\n+                   self.look_ahead(1, |t| t.can_begin_bound() &&\n+                                          !can_continue_type_after_non_fn_ident(t))) {\n+            self.bump(); // `dyn`\n+            // Always parse bounds greedily for better error recovery.\n+            let bounds = self.parse_generic_bounds(None)?;\n+            impl_dyn_multi = bounds.len() > 1 || self.prev_token_kind == PrevTokenKind::Plus;\n+            TyKind::TraitObject(bounds, TraitObjectSyntax::Dyn)\n+        } else if self.check(&token::Question) ||\n+                  self.check_lifetime() && self.look_ahead(1, |t| t.is_like_plus()) {\n+            // Bound list (trait object type)\n+            TyKind::TraitObject(self.parse_generic_bounds_common(allow_plus, None)?,\n+                                TraitObjectSyntax::None)\n+        } else if self.eat_lt() {\n+            // Qualified path\n+            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n+            TyKind::Path(Some(qself), path)\n+        } else if self.token.is_path_start() {\n+            // Simple path\n+            let path = self.parse_path(PathStyle::Type)?;\n+            if self.eat(&token::Not) {\n+                // Macro invocation in type position\n+                let (delim, tts) = self.expect_delimited_token_tree()?;\n+                let node = Mac_ {\n+                    path,\n+                    tts,\n+                    delim,\n+                    prior_type_ascription: self.last_type_ascription,\n+                };\n+                TyKind::Mac(respan(lo.to(self.prev_span), node))\n+            } else {\n+                // Just a type path or bound list (trait object type) starting with a trait.\n+                //   `Type`\n+                //   `Trait1 + Trait2 + 'a`\n+                if allow_plus && self.check_plus() {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                } else {\n+                    TyKind::Path(None, path)\n+                }\n+            }\n+        } else if self.check(&token::DotDotDot) {\n+            if allow_c_variadic {\n+                self.eat(&token::DotDotDot);\n+                TyKind::CVarArgs\n+            } else {\n+                return Err(self.fatal(\n+                    \"only foreign functions are allowed to be C-variadic\"\n+                ));\n+            }\n+        } else {\n+            let msg = format!(\"expected type, found {}\", self.this_token_descr());\n+            let mut err = self.fatal(&msg);\n+            err.span_label(self.token.span, \"expected type\");\n+            self.maybe_annotate_with_ascription(&mut err, true);\n+            return Err(err);\n+        };\n+\n+        let span = lo.to(self.prev_span);\n+        let ty = P(Ty { node, span, id: ast::DUMMY_NODE_ID });\n+\n+        // Try to recover from use of `+` with incorrect priority.\n+        self.maybe_report_ambiguous_plus(allow_plus, impl_dyn_multi, &ty);\n+        self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n+        self.maybe_recover_from_bad_qpath(ty, allow_qpath_recovery)\n+    }\n+\n+    fn parse_remaining_bounds(&mut self, generic_params: Vec<GenericParam>, path: ast::Path,\n+                              lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n+        let poly_trait_ref = PolyTraitRef::new(generic_params, path, lo.to(self.prev_span));\n+        let mut bounds = vec![GenericBound::Trait(poly_trait_ref, TraitBoundModifier::None)];\n+        if parse_plus {\n+            self.eat_plus(); // `+`, or `+=` gets split and `+` is discarded\n+            bounds.append(&mut self.parse_generic_bounds(Some(self.prev_span))?);\n+        }\n+        Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n+    }\n+\n+    fn parse_ptr(&mut self) -> PResult<'a, MutTy> {\n+        let mutbl = if self.eat_keyword(kw::Mut) {\n+            Mutability::Mutable\n+        } else if self.eat_keyword(kw::Const) {\n+            Mutability::Immutable\n+        } else {\n+            let span = self.prev_span;\n+            let msg = \"expected mut or const in raw pointer type\";\n+            self.struct_span_err(span, msg)\n+                .span_label(span, msg)\n+                .help(\"use `*mut T` or `*const T` as appropriate\")\n+                .emit();\n+            Mutability::Immutable\n+        };\n+        let t = self.parse_ty_no_plus()?;\n+        Ok(MutTy { ty: t, mutbl })\n+    }\n+\n+    fn maybe_parse_fixed_length_of_vec(&mut self) -> PResult<'a, Option<P<ast::Expr>>> {\n+        if self.eat(&token::Semi) {\n+            Ok(Some(self.parse_expr()?))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n+        let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n+        let mutbl = self.parse_mutability();\n+        let ty = self.parse_ty_no_plus()?;\n+        return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty, mutbl }));\n+    }\n+\n+    /// Is the current token one of the keywords that signals a bare function type?\n+    fn token_is_bare_fn_keyword(&mut self) -> bool {\n+        self.check_keyword(kw::Fn) ||\n+            self.check_keyword(kw::Unsafe) ||\n+            self.check_keyword(kw::Extern)\n+    }\n+\n+    /// Parses a `TyKind::BareFn` type.\n+    fn parse_ty_bare_fn(&mut self, generic_params: Vec<GenericParam>) -> PResult<'a, TyKind> {\n+        /*\n+\n+        [unsafe] [extern \"ABI\"] fn (S) -> T\n+         ^~~~^           ^~~~^     ^~^    ^\n+           |               |        |     |\n+           |               |        |   Return type\n+           |               |      Argument types\n+           |               |\n+           |              ABI\n+        Function Style\n+        */\n+\n+        let unsafety = self.parse_unsafety();\n+        let abi = if self.eat_keyword(kw::Extern) {\n+            self.parse_opt_abi()?.unwrap_or(Abi::C)\n+        } else {\n+            Abi::Rust\n+        };\n+\n+        self.expect_keyword(kw::Fn)?;\n+        let (inputs, c_variadic) = self.parse_fn_args(false, true)?;\n+        let ret_ty = self.parse_ret_ty(false)?;\n+        let decl = P(FnDecl {\n+            inputs,\n+            output: ret_ty,\n+            c_variadic,\n+        });\n+        Ok(TyKind::BareFn(P(BareFnTy {\n+            abi,\n+            unsafety,\n+            generic_params,\n+            decl,\n+        })))\n+    }\n+\n+    crate fn parse_generic_bounds(&mut self,\n+                                  colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+        self.parse_generic_bounds_common(true, colon_span)\n+    }\n+\n+    /// Parses bounds of a type parameter `BOUND + BOUND + ...`, possibly with trailing `+`.\n+    ///\n+    /// ```\n+    /// BOUND = TY_BOUND | LT_BOUND\n+    /// LT_BOUND = LIFETIME (e.g., `'a`)\n+    /// TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n+    /// TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g., `?for<'a: 'b> m::Trait<'a>`)\n+    /// ```\n+    fn parse_generic_bounds_common(&mut self,\n+                                   allow_plus: bool,\n+                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n+        let mut bounds = Vec::new();\n+        let mut negative_bounds = Vec::new();\n+        let mut last_plus_span = None;\n+        let mut was_negative = false;\n+        loop {\n+            // This needs to be synchronized with `TokenKind::can_begin_bound`.\n+            let is_bound_start = self.check_path() || self.check_lifetime() ||\n+                                 self.check(&token::Not) || // used for error reporting only\n+                                 self.check(&token::Question) ||\n+                                 self.check_keyword(kw::For) ||\n+                                 self.check(&token::OpenDelim(token::Paren));\n+            if is_bound_start {\n+                let lo = self.token.span;\n+                let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+                let inner_lo = self.token.span;\n+                let is_negative = self.eat(&token::Not);\n+                let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n+                if self.token.is_lifetime() {\n+                    if let Some(question_span) = question {\n+                        self.span_err(question_span,\n+                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n+                    }\n+                    bounds.push(GenericBound::Outlives(self.expect_lifetime()));\n+                    if has_parens {\n+                        let inner_span = inner_lo.to(self.prev_span);\n+                        self.expect(&token::CloseDelim(token::Paren))?;\n+                        let mut err = self.struct_span_err(\n+                            lo.to(self.prev_span),\n+                            \"parenthesized lifetime bounds are not supported\"\n+                        );\n+                        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n+                            err.span_suggestion_short(\n+                                lo.to(self.prev_span),\n+                                \"remove the parentheses\",\n+                                snippet.to_owned(),\n+                                Applicability::MachineApplicable\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n+                } else {\n+                    let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+                    let path = self.parse_path(PathStyle::Type)?;\n+                    if has_parens {\n+                        self.expect(&token::CloseDelim(token::Paren))?;\n+                    }\n+                    let poly_span = lo.to(self.prev_span);\n+                    if is_negative {\n+                        was_negative = true;\n+                        if let Some(sp) = last_plus_span.or(colon_span) {\n+                            negative_bounds.push(sp.to(poly_span));\n+                        }\n+                    } else {\n+                        let poly_trait = PolyTraitRef::new(lifetime_defs, path, poly_span);\n+                        let modifier = if question.is_some() {\n+                            TraitBoundModifier::Maybe\n+                        } else {\n+                            TraitBoundModifier::None\n+                        };\n+                        bounds.push(GenericBound::Trait(poly_trait, modifier));\n+                    }\n+                }\n+            } else {\n+                break\n+            }\n+\n+            if !allow_plus || !self.eat_plus() {\n+                break\n+            } else {\n+                last_plus_span = Some(self.prev_span);\n+            }\n+        }\n+\n+        if !negative_bounds.is_empty() || was_negative {\n+            let plural = negative_bounds.len() > 1;\n+            let last_span = negative_bounds.last().map(|sp| *sp);\n+            let mut err = self.struct_span_err(\n+                negative_bounds,\n+                \"negative trait bounds are not supported\",\n+            );\n+            if let Some(sp) = last_span {\n+                err.span_label(sp, \"negative trait bounds are not supported\");\n+            }\n+            if let Some(bound_list) = colon_span {\n+                let bound_list = bound_list.to(self.prev_span);\n+                let mut new_bound_list = String::new();\n+                if !bounds.is_empty() {\n+                    let mut snippets = bounds.iter().map(|bound| bound.span())\n+                        .map(|span| self.span_to_snippet(span));\n+                    while let Some(Ok(snippet)) = snippets.next() {\n+                        new_bound_list.push_str(\" + \");\n+                        new_bound_list.push_str(&snippet);\n+                    }\n+                    new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n+                }\n+                err.span_suggestion_hidden(\n+                    bound_list,\n+                    &format!(\"remove the trait bound{}\", if plural { \"s\" } else { \"\" }),\n+                    new_bound_list,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            err.emit();\n+        }\n+\n+        return Ok(bounds);\n+    }\n+\n+    // TODO remove super below.\n+\n+    pub(super) fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<GenericParam>> {\n+        if self.eat_keyword(kw::For) {\n+            self.expect_lt()?;\n+            let params = self.parse_generic_params()?;\n+            self.expect_gt()?;\n+            // We rely on AST validation to rule out invalid cases: There must not be type\n+            // parameters, and the lifetime parameters must not have bounds.\n+            Ok(params)\n+        } else {\n+            Ok(Vec::new())\n+        }\n+    }\n+}"}]}