{"sha": "1f32d40ac3c51d6867fc6969e52e960452a40652", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmMzJkNDBhYzNjNTFkNjg2N2ZjNjk2OWU1MmU5NjA0NTJhNDA2NTI=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-11T03:46:54Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-04-13T16:48:58Z"}, "message": "BufWriter: apply #[inline] / #[inline(never)] optimizations\n\nEnsure that `write` and `write_all` can be inlined and that their\ncommonly executed fast paths can be as short as possible.\n\n`write_vectored` would likely benefit from the same optimization, but I\nomitted it because its implementation is more complex, and I don't have\na benchmark on hand to guide its optimization.", "tree": {"sha": "04be3f7caf3cf5d4f8ef96a4c5e183ea3c2d9a4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04be3f7caf3cf5d4f8ef96a4c5e183ea3c2d9a4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f32d40ac3c51d6867fc6969e52e960452a40652", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f32d40ac3c51d6867fc6969e52e960452a40652", "html_url": "https://github.com/rust-lang/rust/commit/1f32d40ac3c51d6867fc6969e52e960452a40652", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f32d40ac3c51d6867fc6969e52e960452a40652/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c1304205b7bc53a1e9f48cf286a60438351c1ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c1304205b7bc53a1e9f48cf286a60438351c1ab", "html_url": "https://github.com/rust-lang/rust/commit/5c1304205b7bc53a1e9f48cf286a60438351c1ab"}], "stats": {"total": 90, "additions": 66, "deletions": 24}, "files": [{"sha": "ae72ddabfb9e4f9dae0ec31fe69a0c41bda6a3a3", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1f32d40ac3c51d6867fc6969e52e960452a40652/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f32d40ac3c51d6867fc6969e52e960452a40652/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=1f32d40ac3c51d6867fc6969e52e960452a40652", "patch": "@@ -331,6 +331,52 @@ impl<W: Write> BufWriter<W> {\n         let buf = if !self.panicked { Ok(buf) } else { Err(WriterPanicked { buf }) };\n         (self.inner.take().unwrap(), buf)\n     }\n+\n+    // Ensure this function does not get inlined into `write`, so that it\n+    // remains inlineable and its common path remains as short as possible.\n+    // If this function ends up being called frequently relative to `write`,\n+    // it's likely a sign that the client is using an improperly sized buffer.\n+    #[inline(never)]\n+    fn flush_and_write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.flush_buf()?;\n+\n+        // Why not len > capacity? To avoid a needless trip through the buffer when the\n+        // input exactly fills. We'd just need to flush it to the underlying writer anyway.\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(buf.len())\n+        }\n+    }\n+\n+    // Ensure this function does not get inlined into `write_all`, so that it\n+    // remains inlineable and its common path remains as short as possible.\n+    // If this function ends up being called frequently relative to `write_all`,\n+    // it's likely a sign that the client is using an improperly sized buffer.\n+    #[inline(never)]\n+    fn flush_and_write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        // Normally, `write_all` just calls `write` in a loop. We can do better\n+        // by calling `self.get_mut().write_all()` directly, which avoids\n+        // round trips through the buffer in the event of a series of partial\n+        // writes in some circumstances.\n+        self.flush_buf()?;\n+\n+        // Why not len > capacity? To avoid a needless trip through the buffer when the\n+        // input exactly fills. We'd just need to flush it to the underlying writer anyway.\n+        if buf.len() >= self.buf.capacity() {\n+            self.panicked = true;\n+            let r = self.get_mut().write_all(buf);\n+            self.panicked = false;\n+            r\n+        } else {\n+            self.buf.extend_from_slice(buf);\n+            Ok(())\n+        }\n+    }\n }\n \n #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n@@ -402,43 +448,39 @@ impl fmt::Debug for WriterPanicked {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for BufWriter<W> {\n+    #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n+        // The `buf.len() != self.buf.capacity()` check is done to avoid a needless trip through\n+        // the buffer when the input is exactly the same size as it. For many clients, that is a\n+        // rare event, so it's unfortunate that the check is in the common code path. But it\n+        // prevents pathological cases for other clients which *always* make writes of this size.\n+        // See #72919 and #79930 for more info and a breadcrumb trail.\n+        if self.buf.len() + buf.len() <= self.buf.capacity() && buf.len() != self.buf.capacity() {\n             self.buf.extend_from_slice(buf);\n             Ok(buf.len())\n+        } else {\n+            self.flush_and_write(buf)\n         }\n     }\n \n+    #[inline]\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n-        // Normally, `write_all` just calls `write` in a loop. We can do better\n-        // by calling `self.get_mut().write_all()` directly, which avoids\n-        // round trips through the buffer in the event of a series of partial\n-        // writes in some circumstances.\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n-            self.flush_buf()?;\n-        }\n-        // FIXME: Why no len > capacity? Why not buffer len == capacity? #72919\n-        if buf.len() >= self.buf.capacity() {\n-            self.panicked = true;\n-            let r = self.get_mut().write_all(buf);\n-            self.panicked = false;\n-            r\n-        } else {\n+        // The `buf.len() != self.buf.capacity()` check is done to avoid a needless trip through\n+        // the buffer when the input is exactly the same size as it. For many clients, that is a\n+        // rare event, so it's unfortunate that the check is in the common code path. But it\n+        // prevents pathological cases for other clients which *always* make writes of this size.\n+        // See #72919 and #79930 for more info and a breadcrumb trail.\n+        if self.buf.len() + buf.len() <= self.buf.capacity() && buf.len() != self.buf.capacity() {\n             self.buf.extend_from_slice(buf);\n             Ok(())\n+        } else {\n+            self.flush_and_write_all(buf)\n         }\n     }\n \n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n+        // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n         if self.get_ref().is_write_vectored() {\n             let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n             if self.buf.len() + total_len > self.buf.capacity() {"}]}