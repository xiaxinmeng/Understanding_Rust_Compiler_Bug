{"sha": "aef8e935142bbb3b8511691e725d8cd53f4ff213", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZjhlOTM1MTQyYmJiM2I4NTExNjkxZTcyNWQ4Y2Q1M2Y0ZmYyMTM=", "commit": {"author": {"name": "calebcartwright", "email": "caleb.cartwright@outlook.com", "date": "2019-07-14T14:30:11Z"}, "committer": {"name": "calebcartwright", "email": "caleb.cartwright@outlook.com", "date": "2019-07-14T14:30:11Z"}, "message": "Merge remote-tracking branch 'upstream/master' into accept-manifest-path", "tree": {"sha": "8ae9f37bc157cfd8bc1ee7ea1b1c859e58a746da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ae9f37bc157cfd8bc1ee7ea1b1c859e58a746da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aef8e935142bbb3b8511691e725d8cd53f4ff213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aef8e935142bbb3b8511691e725d8cd53f4ff213", "html_url": "https://github.com/rust-lang/rust/commit/aef8e935142bbb3b8511691e725d8cd53f4ff213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aef8e935142bbb3b8511691e725d8cd53f4ff213/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17cbbd8cbc2d829e0ce07c619a2970a46a3b9b8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/17cbbd8cbc2d829e0ce07c619a2970a46a3b9b8c", "html_url": "https://github.com/rust-lang/rust/commit/17cbbd8cbc2d829e0ce07c619a2970a46a3b9b8c"}, {"sha": "71289e1d230d19f223e45b0abe75ae976f567900", "url": "https://api.github.com/repos/rust-lang/rust/commits/71289e1d230d19f223e45b0abe75ae976f567900", "html_url": "https://github.com/rust-lang/rust/commit/71289e1d230d19f223e45b0abe75ae976f567900"}], "stats": {"total": 679, "additions": 388, "deletions": 291}, "files": [{"sha": "3a0d1cfddbd39188085759621de9e68d882e14ac", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -89,7 +89,14 @@ fn execute() -> i32 {\n     };\n \n     if opts.version {\n-        return handle_command_status(get_version());\n+        return handle_command_status(get_rustfmt_info(&[String::from(\"--version\")]));\n+    }\n+    if opts.rustfmt_options.iter().any(|s| {\n+        [\"--print-config\", \"-h\", \"--help\", \"-V\", \"--version\"].contains(&s.as_str())\n+            || s.starts_with(\"--help=\")\n+            || s.starts_with(\"--print-config=\")\n+    }) {\n+        return handle_command_status(get_rustfmt_info(&opts.rustfmt_options));\n     }\n \n     let strategy = CargoFmtStrategy::from_opts(&opts);\n@@ -142,10 +149,10 @@ fn handle_command_status(status: Result<i32, io::Error>) -> i32 {\n     }\n }\n \n-fn get_version() -> Result<i32, io::Error> {\n+fn get_rustfmt_info(args: &[String]) -> Result<i32, io::Error> {\n     let mut command = Command::new(\"rustfmt\")\n         .stdout(std::process::Stdio::inherit())\n-        .args(&[String::from(\"--version\")])\n+        .args(args)\n         .spawn()\n         .map_err(|e| match e.kind() {\n             io::ErrorKind::NotFound => io::Error::new(\n@@ -168,14 +175,7 @@ fn format_crate(\n     rustfmt_args: Vec<String>,\n     manifest_path: Option<&Path>,\n ) -> Result<i32, io::Error> {\n-    let targets = if rustfmt_args\n-        .iter()\n-        .any(|s| [\"--print-config\", \"-h\", \"--help\", \"-V\", \"--version\"].contains(&s.as_str()))\n-    {\n-        BTreeSet::new()\n-    } else {\n-        get_targets(strategy, manifest_path)?\n-    };\n+    let targets = get_targets(strategy, manifest_path)?;\n \n     // Currently only bin and lib files get formatted.\n     run_rustfmt(&targets, &rustfmt_args, verbosity)"}, {"sha": "ac83d7082c8880375cd1873080719d4380f21f21", "filename": "src/lists.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -612,7 +612,11 @@ pub(crate) fn extract_post_comment(\n         post_snippet[1..].trim_matches(white_space)\n     } else if post_snippet.starts_with(separator) {\n         post_snippet[separator.len()..].trim_matches(white_space)\n-    } else if post_snippet.ends_with(',') && !post_snippet.trim().starts_with(\"//\") {\n+    }\n+    // not comment or over two lines\n+    else if post_snippet.ends_with(',')\n+        && (!post_snippet.trim().starts_with(\"//\") || post_snippet.trim().contains('\\n'))\n+    {\n         post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n     } else {\n         post_snippet"}, {"sha": "55289f55537bbd9ec52147d4ee1d53f670c6ec8b", "filename": "src/test/configuration_snippet.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Ftest%2Fconfiguration_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Ftest%2Fconfiguration_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fconfiguration_snippet.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -0,0 +1,286 @@\n+use std::collections::{HashMap, HashSet};\n+use std::fs;\n+use std::io::{BufRead, BufReader, Write};\n+use std::iter::Enumerate;\n+use std::path::{Path, PathBuf};\n+\n+use super::{print_mismatches, write_message, DIFF_CONTEXT_SIZE};\n+use crate::config::{Config, EmitMode, Verbosity};\n+use crate::rustfmt_diff::{make_diff, Mismatch};\n+use crate::{Input, Session};\n+\n+const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n+\n+// This enum is used to represent one of three text features in Configurations.md: a block of code\n+// with its starting line number, the name of a rustfmt configuration option, or the value of a\n+// rustfmt configuration option.\n+enum ConfigurationSection {\n+    CodeBlock((String, u32)), // (String: block of code, u32: line number of code block start)\n+    ConfigName(String),\n+    ConfigValue(String),\n+}\n+\n+impl ConfigurationSection {\n+    fn get_section<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+    ) -> Option<ConfigurationSection> {\n+        lazy_static! {\n+            static ref CONFIG_NAME_REGEX: regex::Regex =\n+                regex::Regex::new(r\"^## `([^`]+)`\").expect(\"failed creating configuration pattern\");\n+            static ref CONFIG_VALUE_REGEX: regex::Regex =\n+                regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n+                    .expect(\"failed creating configuration value pattern\");\n+        }\n+\n+        loop {\n+            match file.next() {\n+                Some((i, line)) => {\n+                    if line.starts_with(\"```rust\") {\n+                        // Get the lines of the code block.\n+                        let lines: Vec<String> = file\n+                            .map(|(_i, l)| l)\n+                            .take_while(|l| !l.starts_with(\"```\"))\n+                            .collect();\n+                        let block = format!(\"{}\\n\", lines.join(\"\\n\"));\n+\n+                        // +1 to translate to one-based indexing\n+                        // +1 to get to first line of code (line after \"```\")\n+                        let start_line = (i + 2) as u32;\n+\n+                        return Some(ConfigurationSection::CodeBlock((block, start_line)));\n+                    } else if let Some(c) = CONFIG_NAME_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigName(String::from(&c[1])));\n+                    } else if let Some(c) = CONFIG_VALUE_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigValue(String::from(&c[1])));\n+                    }\n+                }\n+                None => return None, // reached the end of the file\n+            }\n+        }\n+    }\n+}\n+\n+// This struct stores the information about code blocks in the configurations\n+// file, formats the code blocks, and prints formatting errors.\n+struct ConfigCodeBlock {\n+    config_name: Option<String>,\n+    config_value: Option<String>,\n+    code_block: Option<String>,\n+    code_block_start: Option<u32>,\n+}\n+\n+impl ConfigCodeBlock {\n+    fn new() -> ConfigCodeBlock {\n+        ConfigCodeBlock {\n+            config_name: None,\n+            config_value: None,\n+            code_block: None,\n+            code_block_start: None,\n+        }\n+    }\n+\n+    fn set_config_name(&mut self, name: Option<String>) {\n+        self.config_name = name;\n+        self.config_value = None;\n+    }\n+\n+    fn set_config_value(&mut self, value: Option<String>) {\n+        self.config_value = value;\n+    }\n+\n+    fn set_code_block(&mut self, code_block: String, code_block_start: u32) {\n+        self.code_block = Some(code_block);\n+        self.code_block_start = Some(code_block_start);\n+    }\n+\n+    fn get_block_config(&self) -> Config {\n+        let mut config = Config::default();\n+        config.set().verbose(Verbosity::Quiet);\n+        if self.config_name.is_some() && self.config_value.is_some() {\n+            config.override_value(\n+                self.config_name.as_ref().unwrap(),\n+                self.config_value.as_ref().unwrap(),\n+            );\n+        }\n+        config\n+    }\n+\n+    fn code_block_valid(&self) -> bool {\n+        // We never expect to not have a code block.\n+        assert!(self.code_block.is_some() && self.code_block_start.is_some());\n+\n+        // See if code block begins with #![rustfmt::skip].\n+        let fmt_skip = self\n+            .code_block\n+            .as_ref()\n+            .unwrap()\n+            .lines()\n+            .nth(0)\n+            .unwrap_or(\"\")\n+            == \"#![rustfmt::skip]\";\n+\n+        if self.config_name.is_none() && !fmt_skip {\n+            write_message(&format!(\n+                \"No configuration name for {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        if self.config_value.is_none() && !fmt_skip {\n+            write_message(&format!(\n+                \"No configuration value for {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn has_parsing_errors<T: Write>(&self, session: &Session<'_, T>) -> bool {\n+        if session.has_parsing_errors() {\n+            write_message(&format!(\n+                \"\\u{261d}\\u{1f3fd} Cannot format {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    fn print_diff(&self, compare: Vec<Mismatch>) {\n+        let mut mismatches = HashMap::new();\n+        mismatches.insert(PathBuf::from(CONFIGURATIONS_FILE_NAME), compare);\n+        print_mismatches(mismatches, |line_num| {\n+            format!(\n+                \"\\nMismatch at {}:{}:\",\n+                CONFIGURATIONS_FILE_NAME,\n+                line_num + self.code_block_start.unwrap() - 1\n+            )\n+        });\n+    }\n+\n+    fn formatted_has_diff(&self, text: &str) -> bool {\n+        let compare = make_diff(self.code_block.as_ref().unwrap(), text, DIFF_CONTEXT_SIZE);\n+        if !compare.is_empty() {\n+            self.print_diff(compare);\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    // Return a bool indicating if formatting this code block is an idempotent\n+    // operation. This function also triggers printing any formatting failure\n+    // messages.\n+    fn formatted_is_idempotent(&self) -> bool {\n+        // Verify that we have all of the expected information.\n+        if !self.code_block_valid() {\n+            return false;\n+        }\n+\n+        let input = Input::Text(self.code_block.as_ref().unwrap().to_owned());\n+        let mut config = self.get_block_config();\n+        config.set().emit_mode(EmitMode::Stdout);\n+        let mut buf: Vec<u8> = vec![];\n+\n+        {\n+            let mut session = Session::new(config, Some(&mut buf));\n+            session.format(input).unwrap();\n+            if self.has_parsing_errors(&session) {\n+                return false;\n+            }\n+        }\n+\n+        !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n+    }\n+\n+    // Extract a code block from the iterator. Behavior:\n+    // - Rust code blocks are identifed by lines beginning with \"```rust\".\n+    // - One explicit configuration setting is supported per code block.\n+    // - Rust code blocks with no configuration setting are illegal and cause an\n+    //   assertion failure, unless the snippet begins with #![rustfmt::skip].\n+    // - Configuration names in Configurations.md must be in the form of\n+    //   \"## `NAME`\".\n+    // - Configuration values in Configurations.md must be in the form of\n+    //   \"#### `VALUE`\".\n+    fn extract<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+        prev: Option<&ConfigCodeBlock>,\n+        hash_set: &mut HashSet<String>,\n+    ) -> Option<ConfigCodeBlock> {\n+        let mut code_block = ConfigCodeBlock::new();\n+        code_block.config_name = prev.and_then(|cb| cb.config_name.clone());\n+\n+        loop {\n+            match ConfigurationSection::get_section(file) {\n+                Some(ConfigurationSection::CodeBlock((block, start_line))) => {\n+                    code_block.set_code_block(block, start_line);\n+                    break;\n+                }\n+                Some(ConfigurationSection::ConfigName(name)) => {\n+                    assert!(\n+                        Config::is_valid_name(&name),\n+                        \"an unknown configuration option was found: {}\",\n+                        name\n+                    );\n+                    assert!(\n+                        hash_set.remove(&name),\n+                        \"multiple configuration guides found for option {}\",\n+                        name\n+                    );\n+                    code_block.set_config_name(Some(name));\n+                }\n+                Some(ConfigurationSection::ConfigValue(value)) => {\n+                    code_block.set_config_value(Some(value));\n+                }\n+                None => return None, // end of file was reached\n+            }\n+        }\n+\n+        Some(code_block)\n+    }\n+}\n+\n+#[test]\n+fn configuration_snippet_tests() {\n+    let blocks = get_code_blocks();\n+    let failures = blocks\n+        .iter()\n+        .map(ConfigCodeBlock::formatted_is_idempotent)\n+        .fold(0, |acc, r| acc + (!r as u32));\n+\n+    // Display results.\n+    println!(\"Ran {} configurations tests.\", blocks.len());\n+    assert_eq!(failures, 0, \"{} configurations tests failed\", failures);\n+}\n+\n+// Read Configurations.md and build a `Vec` of `ConfigCodeBlock` structs with one\n+// entry for each Rust code block found.\n+fn get_code_blocks() -> Vec<ConfigCodeBlock> {\n+    let mut file_iter = BufReader::new(\n+        fs::File::open(Path::new(CONFIGURATIONS_FILE_NAME))\n+            .unwrap_or_else(|_| panic!(\"couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n+    )\n+    .lines()\n+    .map(Result::unwrap)\n+    .enumerate();\n+    let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n+    let mut hash_set = Config::hash_set();\n+\n+    while let Some(cb) = ConfigCodeBlock::extract(&mut file_iter, code_blocks.last(), &mut hash_set)\n+    {\n+        code_blocks.push(cb);\n+    }\n+\n+    for name in hash_set {\n+        if !Config::is_hidden_option(&name) {\n+            panic!(\"{} does not have a configuration guide\", name);\n+        }\n+    }\n+\n+    code_blocks\n+}"}, {"sha": "10aad268a8df644c328c569d0a880226b51a40ba", "filename": "src/test/mod.rs", "status": "modified", "additions": 5, "deletions": 279, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -1,23 +1,24 @@\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::env;\n use std::fs;\n use std::io::{self, BufRead, BufReader, Read, Write};\n-use std::iter::{Enumerate, Peekable};\n+use std::iter::Peekable;\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str::Chars;\n use std::thread;\n \n-use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle, ReportTactic, Verbosity};\n+use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle, ReportTactic};\n use crate::formatting::{ReportedErrors, SourceFile};\n use crate::is_nightly_channel;\n use crate::rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, ModifiedChunk, OutputWriter};\n use crate::source_file;\n use crate::{FormatReport, FormatReportFormatterBuilder, Input, Session};\n \n+mod configuration_snippet;\n+\n const DIFF_CONTEXT_SIZE: usize = 3;\n-const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n \n // A list of files on which we want to skip testing.\n const SKIP_FILE_WHITE_LIST: &[&str] = &[\n@@ -768,281 +769,6 @@ fn string_eq_ignore_newline_repr_test() {\n     assert!(!string_eq_ignore_newline_repr(\"a\\r\\nbcd\", \"a\\nbcdefghijk\"));\n }\n \n-// This enum is used to represent one of three text features in Configurations.md: a block of code\n-// with its starting line number, the name of a rustfmt configuration option, or the value of a\n-// rustfmt configuration option.\n-enum ConfigurationSection {\n-    CodeBlock((String, u32)), // (String: block of code, u32: line number of code block start)\n-    ConfigName(String),\n-    ConfigValue(String),\n-}\n-\n-impl ConfigurationSection {\n-    fn get_section<I: Iterator<Item = String>>(\n-        file: &mut Enumerate<I>,\n-    ) -> Option<ConfigurationSection> {\n-        lazy_static! {\n-            static ref CONFIG_NAME_REGEX: regex::Regex =\n-                regex::Regex::new(r\"^## `([^`]+)`\").expect(\"failed creating configuration pattern\");\n-            static ref CONFIG_VALUE_REGEX: regex::Regex =\n-                regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n-                    .expect(\"failed creating configuration value pattern\");\n-        }\n-\n-        loop {\n-            match file.next() {\n-                Some((i, line)) => {\n-                    if line.starts_with(\"```rust\") {\n-                        // Get the lines of the code block.\n-                        let lines: Vec<String> = file\n-                            .map(|(_i, l)| l)\n-                            .take_while(|l| !l.starts_with(\"```\"))\n-                            .collect();\n-                        let block = format!(\"{}\\n\", lines.join(\"\\n\"));\n-\n-                        // +1 to translate to one-based indexing\n-                        // +1 to get to first line of code (line after \"```\")\n-                        let start_line = (i + 2) as u32;\n-\n-                        return Some(ConfigurationSection::CodeBlock((block, start_line)));\n-                    } else if let Some(c) = CONFIG_NAME_REGEX.captures(&line) {\n-                        return Some(ConfigurationSection::ConfigName(String::from(&c[1])));\n-                    } else if let Some(c) = CONFIG_VALUE_REGEX.captures(&line) {\n-                        return Some(ConfigurationSection::ConfigValue(String::from(&c[1])));\n-                    }\n-                }\n-                None => return None, // reached the end of the file\n-            }\n-        }\n-    }\n-}\n-\n-// This struct stores the information about code blocks in the configurations\n-// file, formats the code blocks, and prints formatting errors.\n-struct ConfigCodeBlock {\n-    config_name: Option<String>,\n-    config_value: Option<String>,\n-    code_block: Option<String>,\n-    code_block_start: Option<u32>,\n-}\n-\n-impl ConfigCodeBlock {\n-    fn new() -> ConfigCodeBlock {\n-        ConfigCodeBlock {\n-            config_name: None,\n-            config_value: None,\n-            code_block: None,\n-            code_block_start: None,\n-        }\n-    }\n-\n-    fn set_config_name(&mut self, name: Option<String>) {\n-        self.config_name = name;\n-        self.config_value = None;\n-    }\n-\n-    fn set_config_value(&mut self, value: Option<String>) {\n-        self.config_value = value;\n-    }\n-\n-    fn set_code_block(&mut self, code_block: String, code_block_start: u32) {\n-        self.code_block = Some(code_block);\n-        self.code_block_start = Some(code_block_start);\n-    }\n-\n-    fn get_block_config(&self) -> Config {\n-        let mut config = Config::default();\n-        config.set().verbose(Verbosity::Quiet);\n-        if self.config_name.is_some() && self.config_value.is_some() {\n-            config.override_value(\n-                self.config_name.as_ref().unwrap(),\n-                self.config_value.as_ref().unwrap(),\n-            );\n-        }\n-        config\n-    }\n-\n-    fn code_block_valid(&self) -> bool {\n-        // We never expect to not have a code block.\n-        assert!(self.code_block.is_some() && self.code_block_start.is_some());\n-\n-        // See if code block begins with #![rustfmt::skip].\n-        let fmt_skip = self\n-            .code_block\n-            .as_ref()\n-            .unwrap()\n-            .lines()\n-            .nth(0)\n-            .unwrap_or(\"\")\n-            == \"#![rustfmt::skip]\";\n-\n-        if self.config_name.is_none() && !fmt_skip {\n-            write_message(&format!(\n-                \"No configuration name for {}:{}\",\n-                CONFIGURATIONS_FILE_NAME,\n-                self.code_block_start.unwrap()\n-            ));\n-            return false;\n-        }\n-        if self.config_value.is_none() && !fmt_skip {\n-            write_message(&format!(\n-                \"No configuration value for {}:{}\",\n-                CONFIGURATIONS_FILE_NAME,\n-                self.code_block_start.unwrap()\n-            ));\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn has_parsing_errors<T: Write>(&self, session: &Session<'_, T>) -> bool {\n-        if session.has_parsing_errors() {\n-            write_message(&format!(\n-                \"\\u{261d}\\u{1f3fd} Cannot format {}:{}\",\n-                CONFIGURATIONS_FILE_NAME,\n-                self.code_block_start.unwrap()\n-            ));\n-            return true;\n-        }\n-\n-        false\n-    }\n-\n-    fn print_diff(&self, compare: Vec<Mismatch>) {\n-        let mut mismatches = HashMap::new();\n-        mismatches.insert(PathBuf::from(CONFIGURATIONS_FILE_NAME), compare);\n-        print_mismatches(mismatches, |line_num| {\n-            format!(\n-                \"\\nMismatch at {}:{}:\",\n-                CONFIGURATIONS_FILE_NAME,\n-                line_num + self.code_block_start.unwrap() - 1\n-            )\n-        });\n-    }\n-\n-    fn formatted_has_diff(&self, text: &str) -> bool {\n-        let compare = make_diff(self.code_block.as_ref().unwrap(), text, DIFF_CONTEXT_SIZE);\n-        if !compare.is_empty() {\n-            self.print_diff(compare);\n-            return true;\n-        }\n-\n-        false\n-    }\n-\n-    // Return a bool indicating if formatting this code block is an idempotent\n-    // operation. This function also triggers printing any formatting failure\n-    // messages.\n-    fn formatted_is_idempotent(&self) -> bool {\n-        // Verify that we have all of the expected information.\n-        if !self.code_block_valid() {\n-            return false;\n-        }\n-\n-        let input = Input::Text(self.code_block.as_ref().unwrap().to_owned());\n-        let mut config = self.get_block_config();\n-        config.set().emit_mode(EmitMode::Stdout);\n-        let mut buf: Vec<u8> = vec![];\n-\n-        {\n-            let mut session = Session::new(config, Some(&mut buf));\n-            session.format(input).unwrap();\n-            if self.has_parsing_errors(&session) {\n-                return false;\n-            }\n-        }\n-\n-        !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n-    }\n-\n-    // Extract a code block from the iterator. Behavior:\n-    // - Rust code blocks are identifed by lines beginning with \"```rust\".\n-    // - One explicit configuration setting is supported per code block.\n-    // - Rust code blocks with no configuration setting are illegal and cause an\n-    //   assertion failure, unless the snippet begins with #![rustfmt::skip].\n-    // - Configuration names in Configurations.md must be in the form of\n-    //   \"## `NAME`\".\n-    // - Configuration values in Configurations.md must be in the form of\n-    //   \"#### `VALUE`\".\n-    fn extract<I: Iterator<Item = String>>(\n-        file: &mut Enumerate<I>,\n-        prev: Option<&ConfigCodeBlock>,\n-        hash_set: &mut HashSet<String>,\n-    ) -> Option<ConfigCodeBlock> {\n-        let mut code_block = ConfigCodeBlock::new();\n-        code_block.config_name = prev.and_then(|cb| cb.config_name.clone());\n-\n-        loop {\n-            match ConfigurationSection::get_section(file) {\n-                Some(ConfigurationSection::CodeBlock((block, start_line))) => {\n-                    code_block.set_code_block(block, start_line);\n-                    break;\n-                }\n-                Some(ConfigurationSection::ConfigName(name)) => {\n-                    assert!(\n-                        Config::is_valid_name(&name),\n-                        \"an unknown configuration option was found: {}\",\n-                        name\n-                    );\n-                    assert!(\n-                        hash_set.remove(&name),\n-                        \"multiple configuration guides found for option {}\",\n-                        name\n-                    );\n-                    code_block.set_config_name(Some(name));\n-                }\n-                Some(ConfigurationSection::ConfigValue(value)) => {\n-                    code_block.set_config_value(Some(value));\n-                }\n-                None => return None, // end of file was reached\n-            }\n-        }\n-\n-        Some(code_block)\n-    }\n-}\n-\n-#[test]\n-fn configuration_snippet_tests() {\n-    // Read Configurations.md and build a `Vec` of `ConfigCodeBlock` structs with one\n-    // entry for each Rust code block found.\n-    fn get_code_blocks() -> Vec<ConfigCodeBlock> {\n-        let mut file_iter = BufReader::new(\n-            fs::File::open(Path::new(CONFIGURATIONS_FILE_NAME))\n-                .unwrap_or_else(|_| panic!(\"couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n-        )\n-        .lines()\n-        .map(Result::unwrap)\n-        .enumerate();\n-        let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n-        let mut hash_set = Config::hash_set();\n-\n-        while let Some(cb) =\n-            ConfigCodeBlock::extract(&mut file_iter, code_blocks.last(), &mut hash_set)\n-        {\n-            code_blocks.push(cb);\n-        }\n-\n-        for name in hash_set {\n-            if !Config::is_hidden_option(&name) {\n-                panic!(\"{} does not have a configuration guide\", name);\n-            }\n-        }\n-\n-        code_blocks\n-    }\n-\n-    let blocks = get_code_blocks();\n-    let failures = blocks\n-        .iter()\n-        .map(ConfigCodeBlock::formatted_is_idempotent)\n-        .fold(0, |acc, r| acc + (!r as u32));\n-\n-    // Display results.\n-    println!(\"Ran {} configurations tests.\", blocks.len());\n-    assert_eq!(failures, 0, \"{} configurations tests failed\", failures);\n-}\n-\n struct TempFile {\n     path: PathBuf,\n }"}, {"sha": "d1ba2e689b65f8797facb926d832b7160d1d8fbf", "filename": "tests/cargo-fmt/main.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/tests%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/tests%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcargo-fmt%2Fmain.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -0,0 +1,70 @@\n+// Integration tests for cargo-fmt.\n+\n+use std::env;\n+use std::process::Command;\n+\n+/// Run the cargo-fmt executable and return its output.\n+fn cargo_fmt(args: &[&str]) -> (String, String) {\n+    let mut bin_dir = env::current_exe().unwrap();\n+    bin_dir.pop(); // chop off test exe name\n+    if bin_dir.ends_with(\"deps\") {\n+        bin_dir.pop();\n+    }\n+    let cmd = bin_dir.join(format!(\"cargo-fmt{}\", env::consts::EXE_SUFFIX));\n+\n+    // Ensure cargo-fmt runs the rustfmt binary from the local target dir.\n+    let path = env::var_os(\"PATH\").unwrap_or_default();\n+    let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n+    paths.insert(0, bin_dir);\n+    let new_path = env::join_paths(paths).unwrap();\n+\n+    match Command::new(&cmd).args(args).env(\"PATH\", new_path).output() {\n+        Ok(output) => (\n+            String::from_utf8(output.stdout).expect(\"utf-8\"),\n+            String::from_utf8(output.stderr).expect(\"utf-8\"),\n+        ),\n+        Err(e) => panic!(\"failed to run `{:?} {:?}`: {}\", cmd, args, e),\n+    }\n+}\n+\n+macro_rules! assert_that {\n+    ($args:expr, $check:ident $check_args:tt) => {\n+        let (stdout, stderr) = cargo_fmt($args);\n+        if !stdout.$check$check_args {\n+            panic!(\n+                \"Output not expected for cargo-fmt {:?}\\n\\\n+                 expected: {}{}\\n\\\n+                 actual stdout:\\n{}\\n\\\n+                 actual stderr:\\n{}\",\n+                $args,\n+                stringify!($check),\n+                stringify!($check_args),\n+                stdout,\n+                stderr\n+            );\n+        }\n+    };\n+}\n+\n+#[test]\n+fn version() {\n+    assert_that!(&[\"--version\"], starts_with(\"rustfmt \"));\n+    assert_that!(&[\"--version\"], starts_with(\"rustfmt \"));\n+    assert_that!(&[\"--\", \"-V\"], starts_with(\"rustfmt \"));\n+    assert_that!(&[\"--\", \"--version\"], starts_with(\"rustfmt \"));\n+}\n+\n+#[test]\n+fn print_config() {\n+    assert_that!(\n+        &[\"--\", \"--print-config\", \"current\", \".\"],\n+        contains(\"max_width = \")\n+    );\n+}\n+\n+#[test]\n+fn rustfmt_help() {\n+    assert_that!(&[\"--\", \"--help\"], contains(\"Format Rust code\"));\n+    assert_that!(&[\"--\", \"-h\"], contains(\"Format Rust code\"));\n+    assert_that!(&[\"--\", \"--help=config\"], contains(\"Configuration Options:\"));\n+}"}, {"sha": "f16efb2dcac1577ea251465f919f1de6e2658f1f", "filename": "tests/source/issue-3675.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/tests%2Fsource%2Fissue-3675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/tests%2Fsource%2Fissue-3675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3675.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -0,0 +1,5 @@\n+ fn main() {\n+    println!(\"{}\"\n+        // comment\n+        , 111);\n+ }\n\\ No newline at end of file"}, {"sha": "62d986e77341ff91f0491a8010b80da7da61b296", "filename": "tests/target/issue-3675.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aef8e935142bbb3b8511691e725d8cd53f4ff213/tests%2Ftarget%2Fissue-3675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aef8e935142bbb3b8511691e725d8cd53f4ff213/tests%2Ftarget%2Fissue-3675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3675.rs?ref=aef8e935142bbb3b8511691e725d8cd53f4ff213", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    println!(\n+        \"{}\", // comment\n+        111\n+    );\n+}"}]}