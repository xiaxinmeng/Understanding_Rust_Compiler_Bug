{"sha": "2a656828acc6fa619e2e83f928ca21f2281c911b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNjU2ODI4YWNjNmZhNjE5ZTJlODNmOTI4Y2EyMWYyMjgxYzkxMWI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-25T00:34:19Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: remove the ability for pretty-printers to override nesting.", "tree": {"sha": "cf82d6de5fb6653e0acb934a5247cfa69480e60e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf82d6de5fb6653e0acb934a5247cfa69480e60e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a656828acc6fa619e2e83f928ca21f2281c911b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a656828acc6fa619e2e83f928ca21f2281c911b", "html_url": "https://github.com/rust-lang/rust/commit/2a656828acc6fa619e2e83f928ca21f2281c911b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a656828acc6fa619e2e83f928ca21f2281c911b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0c485c3ad7017c99137d8c9bc9afc729e7db534", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c485c3ad7017c99137d8c9bc9afc729e7db534", "html_url": "https://github.com/rust-lang/rust/commit/c0c485c3ad7017c99137d8c9bc9afc729e7db534"}], "stats": {"total": 129, "additions": 59, "deletions": 70}, "files": [{"sha": "da01fd11a3f88370fa7d526856cf32eeae6c1515", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 55, "deletions": 66, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/2a656828acc6fa619e2e83f928ca21f2281c911b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a656828acc6fa619e2e83f928ca21f2281c911b/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=2a656828acc6fa619e2e83f928ca21f2281c911b", "patch": "@@ -20,16 +20,16 @@ use std::ops::{Deref, DerefMut};\n use super::*;\n \n macro_rules! nest {\n-    ($closure:expr) => {\n-        scoped_cx!() = scoped_cx!().nest($closure)?\n+    ($e:expr) => {\n+        scoped_cx!() = PrintCx::new(scoped_cx!().tcx, $e?)\n     }\n }\n macro_rules! print_inner {\n     (write ($($data:expr),+)) => {\n         write!(scoped_cx!(), $($data),+)?\n     };\n     ($kind:ident ($data:expr)) => {\n-        nest!(|cx| $data.$kind(cx))\n+        nest!($data.$kind(scoped_cx!()))\n     };\n }\n macro_rules! p {\n@@ -180,15 +180,6 @@ pub trait PrettyPrinter:\n     > +\n     fmt::Write\n {\n-    /// Enter a nested print context, for pretty-printing\n-    /// nested components in some larger context.\n-    fn nest<'a, 'gcx, 'tcx, E>(\n-        self: PrintCx<'a, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n-    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n-        Ok(PrintCx::new(self.tcx, f(self)?))\n-    }\n-\n     /// Like `print_def_path` but for value paths.\n     fn print_value_path(\n         self: PrintCx<'_, '_, 'tcx, Self>,\n@@ -214,11 +205,13 @@ pub trait PrettyPrinter:\n     ) -> Result<Self, Self::Error>\n         where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n     {\n+        define_scoped_cx!(self);\n+\n         if let Some(first) = elems.next() {\n-            self = self.nest(|cx| first.print(cx))?;\n+            nest!(first.print(self));\n             for elem in elems {\n                 self.write_str(\", \")?;\n-                self = self.nest(|cx| elem.print(cx))?;\n+                nest!(elem.print(self));\n             }\n         }\n         self.ok()\n@@ -355,9 +348,9 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         // the entire path will succeed or not. To support printers that do not\n         // implement `PrettyPrinter`, a `Vec` or linked list on the stack would\n         // need to be built, before starting to print anything.\n-        let mut prefix_success = false;\n-        nest!(|cx| {\n-            let (path, success) = cx.try_print_visible_def_path(visible_parent)?;\n+        let prefix_success;\n+        nest!({\n+            let (path, success) = self.try_print_visible_def_path(visible_parent)?;\n             prefix_success = success;\n             Ok(path)\n         });\n@@ -470,7 +463,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<P::Path, P::Error> {\n-        self = self.nest(print_prefix)?;\n+        self = PrintCx::new(self.tcx, print_prefix(self)?);\n \n         self.generic_delimiters(|mut cx| {\n             define_scoped_cx!(cx);\n@@ -492,7 +485,7 @@ pub struct FmtPrinter<F>(Box<FmtPrinterData<F>>);\n pub struct FmtPrinterData<F> {\n     fmt: F,\n \n-    empty: bool,\n+    empty_path: bool,\n     in_value: bool,\n \n     used_region_names: FxHashSet<InternedString>,\n@@ -519,7 +512,7 @@ impl<F> FmtPrinter<F> {\n     pub fn new(fmt: F, ns: Namespace) -> Self {\n         FmtPrinter(Box::new(FmtPrinterData {\n             fmt,\n-            empty: true,\n+            empty_path: false,\n             in_value: ns == Namespace::ValueNS,\n             used_region_names: Default::default(),\n             region_index: 0,\n@@ -531,7 +524,6 @@ impl<F> FmtPrinter<F> {\n \n impl<F: fmt::Write> fmt::Write for FmtPrinter<F> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n-        self.empty &= s.is_empty();\n         self.fmt.write_str(s)\n     }\n }\n@@ -549,16 +541,18 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         def_id: DefId,\n         substs: Option<SubstsRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n+        define_scoped_cx!(self);\n+\n         // FIXME(eddyb) avoid querying `tcx.generics_of` and `tcx.def_key`\n         // both here and in `default_print_def_path`.\n         let generics = substs.map(|_| self.tcx.generics_of(def_id));\n         if generics.as_ref().and_then(|g| g.parent).is_none() {\n-            let mut visible_path_success = false;\n-            self = self.nest(|cx| {\n-                let (path, success) = cx.try_print_visible_def_path(def_id)?;\n+            let visible_path_success;\n+            nest!({\n+                let (path, success) = self.try_print_visible_def_path(def_id)?;\n                 visible_path_success = success;\n                 Ok(path)\n-            })?;\n+            });\n             if visible_path_success {\n                 return if let (Some(generics), Some(substs)) = (generics, substs) {\n                     let args = self.generic_args_to_print(generics, substs);\n@@ -621,15 +615,18 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         mut self: PrintCx<'_, '_, '_, Self>,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error> {\n+        self.empty_path = true;\n         if cnum == LOCAL_CRATE {\n             if self.tcx.sess.rust_2018() {\n                 // We add the `crate::` keyword on Rust 2018, only when desired.\n                 if SHOULD_PREFIX_WITH_CRATE.with(|flag| flag.get()) {\n                     write!(self, \"{}\", keywords::Crate.name())?;\n+                    self.empty_path = false;\n                 }\n             }\n         } else {\n             write!(self, \"{}\", self.tcx.crate_name(cnum))?;\n+            self.empty_path = false;\n         }\n         self.ok()\n     }\n@@ -638,7 +635,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_qualified(self_ty, trait_ref)\n+        let mut path = self.pretty_path_qualified(self_ty, trait_ref)?;\n+        path.empty_path = false;\n+        Ok(path)\n     }\n \n     fn path_append_impl<'gcx, 'tcx>(\n@@ -649,17 +648,16 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        self.pretty_path_append_impl(|cx| {\n+        let mut path = self.pretty_path_append_impl(|cx| {\n             let mut path = print_prefix(cx)?;\n-\n-            // HACK(eddyb) this accounts for `generic_delimiters`\n-            // printing `::<` instead of `<` if `in_value` is set.\n-            if !path.empty && !path.in_value {\n+            if !path.empty_path {\n                 write!(path, \"::\")?;\n             }\n \n             Ok(path)\n-        }, self_ty, trait_ref)\n+        }, self_ty, trait_ref)?;\n+        path.empty_path = false;\n+        Ok(path)\n     }\n     fn path_append<'gcx, 'tcx>(\n         self: PrintCx<'_, 'gcx, 'tcx, Self>,\n@@ -673,10 +671,11 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         // FIXME(eddyb) `text` should never be empty, but it\n         // currently is for `extern { ... }` \"foreign modules\".\n         if !text.is_empty() {\n-            if !path.empty {\n+            if !path.empty_path {\n                 write!(path, \"::\")?;\n             }\n             write!(path, \"{}\", text)?;\n+            path.empty_path = false;\n         }\n \n         Ok(path)\n@@ -688,7 +687,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         ) -> Result<Self::Path, Self::Error>,\n         args: &[Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n-        self = self.nest(print_prefix)?;\n+        define_scoped_cx!(self);\n+\n+        nest!(print_prefix(self));\n \n         // Don't print `'_` if there's no unerased regions.\n         let print_regions = args.iter().any(|arg| {\n@@ -705,6 +706,9 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n         });\n \n         if args.clone().next().is_some() {\n+            if self.in_value {\n+                write!(self, \"::\")?;\n+            }\n             self.generic_delimiters(|cx| cx.comma_sep(args))\n         } else {\n             self.ok()\n@@ -713,17 +717,6 @@ impl<F: fmt::Write> Printer for FmtPrinter<F> {\n }\n \n impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n-    fn nest<'a, 'gcx, 'tcx, E>(\n-        mut self: PrintCx<'a, 'gcx, 'tcx, Self>,\n-        f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, E>,\n-    ) -> Result<PrintCx<'a, 'gcx, 'tcx, Self>, E> {\n-        let tcx = self.tcx;\n-        let was_empty = std::mem::replace(&mut self.empty, true);\n-        let mut inner = f(self)?;\n-        inner.empty &= was_empty;\n-        Ok(PrintCx::new(tcx, inner))\n-    }\n-\n     fn print_value_path(\n         mut self: PrintCx<'_, '_, 'tcx, Self>,\n         def_id: DefId,\n@@ -749,11 +742,7 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error> {\n-        if !self.empty && self.in_value {\n-            write!(self, \"::<\")?;\n-        } else {\n-            write!(self, \"<\")?;\n-        }\n+        write!(self, \"<\")?;\n \n         let was_in_value = std::mem::replace(&mut self.in_value, false);\n         let mut inner = f(self)?;\n@@ -957,7 +946,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             ty::FnDef(def_id, substs) => {\n                 let sig = self.tcx.fn_sig(def_id).subst(self.tcx, substs);\n                 p!(print(sig), write(\" {{\"));\n-                nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n+                nest!(self.print_value_path(def_id, Some(substs)));\n                 p!(write(\"}}\"))\n             }\n             ty::FnPtr(ref bare_fn) => {\n@@ -980,7 +969,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Adt(def, substs) => {\n-                nest!(|cx| cx.print_def_path(def.did, Some(substs)));\n+                nest!(self.print_def_path(def.did, Some(substs)));\n             }\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n@@ -993,7 +982,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 }\n             }\n             ty::Foreign(def_id) => {\n-                nest!(|cx| cx.print_def_path(def_id, None));\n+                nest!(self.print_def_path(def_id, None));\n             }\n             ty::Projection(ref data) => p!(print(data)),\n             ty::UnnormalizedProjection(ref data) => {\n@@ -1094,7 +1083,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 p!(write(\" \"), print(witness), write(\"]\"))\n             },\n             ty::GeneratorWitness(types) => {\n-                nest!(|cx| cx.in_binder(&types))\n+                nest!(self.in_binder(&types))\n             }\n             ty::Closure(did, substs) => {\n                 let upvar_tys = substs.upvar_tys(did, self.tcx);\n@@ -1179,7 +1168,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         let mut first = true;\n \n         if let Some(principal) = predicates.principal() {\n-            nest!(|cx| cx.print_def_path(principal.def_id, None));\n+            nest!(self.print_def_path(principal.def_id, None));\n \n             let mut resugared = false;\n \n@@ -1189,7 +1178,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).sty {\n                     let mut projections = predicates.projection_bounds();\n                     if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                        nest!(|cx| cx.pretty_fn_sig(args, false, proj.ty));\n+                        nest!(self.pretty_fn_sig(args, false, proj.ty));\n                         resugared = true;\n                     }\n                 }\n@@ -1228,8 +1217,8 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                     let args = arg0.into_iter().chain(args);\n                     let projections = projection0.into_iter().chain(projections);\n \n-                    nest!(|cx| cx.generic_delimiters(|mut cx| {\n-                        cx = cx.nest(|cx| cx.comma_sep(args))?;\n+                    nest!(self.generic_delimiters(|mut cx| {\n+                        cx = PrintCx::new(cx.tcx, cx.comma_sep(args)?);\n                         if arg0.is_some() && projection0.is_some() {\n                             write!(cx, \", \")?;\n                         }\n@@ -1262,7 +1251,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             }\n             first = false;\n \n-            nest!(|cx| cx.print_def_path(def_id, None));\n+            nest!(self.print_def_path(def_id, None));\n         }\n \n         self.ok()\n@@ -1531,7 +1520,7 @@ define_print_and_forward_display! {\n             ty::ExistentialPredicate::Trait(x) => p!(print(x)),\n             ty::ExistentialPredicate::Projection(x) => p!(print(x)),\n             ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                nest!(|cx| cx.print_def_path(def_id, None))\n+                nest!(cx.print_def_path(def_id, None))\n             }\n         }\n     }\n@@ -1546,7 +1535,7 @@ define_print_and_forward_display! {\n         }\n \n         p!(write(\"fn\"));\n-        nest!(|cx| cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+        nest!(cx.pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n     }\n \n     ty::InferTy {\n@@ -1565,7 +1554,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitRef<'tcx> {\n-        nest!(|cx| cx.print_def_path(self.def_id, Some(self.substs)));\n+        nest!(cx.print_def_path(self.def_id, Some(self.substs)));\n     }\n \n     ConstValue<'tcx> {\n@@ -1609,7 +1598,7 @@ define_print_and_forward_display! {\n     }\n \n     ty::ProjectionTy<'tcx> {\n-        nest!(|cx| cx.print_def_path(self.item_def_id, Some(self.substs)));\n+        nest!(cx.print_def_path(self.item_def_id, Some(self.substs)));\n     }\n \n     ty::ClosureKind {\n@@ -1630,17 +1619,17 @@ define_print_and_forward_display! {\n             ty::Predicate::WellFormed(ty) => p!(print(ty), write(\" well-formed\")),\n             ty::Predicate::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"));\n-                nest!(|cx| cx.print_def_path(trait_def_id, None));\n+                nest!(cx.print_def_path(trait_def_id, None));\n                 p!(write(\"` is object-safe\"))\n             }\n             ty::Predicate::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"));\n-                nest!(|cx| cx.print_value_path(closure_def_id, None));\n+                nest!(cx.print_value_path(closure_def_id, None));\n                 p!(write(\"` implements the trait `{}`\", kind))\n             }\n             ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                 p!(write(\"the constant `\"));\n-                nest!(|cx| cx.print_value_path(def_id, Some(substs)));\n+                nest!(cx.print_value_path(def_id, Some(substs)));\n                 p!(write(\"` can be evaluated\"))\n             }\n         }"}, {"sha": "084b86b1eb4240a006e32e836eb79600bdfb0219", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a656828acc6fa619e2e83f928ca21f2281c911b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a656828acc6fa619e2e83f928ca21f2281c911b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=2a656828acc6fa619e2e83f928ca21f2281c911b", "patch": "@@ -445,7 +445,7 @@ impl Printer for SymbolPath {\n                 write!(self, \"+\")?;\n             }\n             first = false;\n-            self = self.nest(|cx| p.print(cx))?;\n+            self = PrintCx::new(self.tcx, p.print(self)?);\n         }\n         self.ok()\n     }\n@@ -520,7 +520,7 @@ impl Printer for SymbolPath {\n         ) -> Result<Self::Path, Self::Error>,\n         args: &[Kind<'tcx>],\n     )  -> Result<Self::Path, Self::Error> {\n-        self = self.nest(print_prefix)?;\n+        self = PrintCx::new(self.tcx, print_prefix(self)?);\n \n         let args = args.iter().cloned().filter(|arg| {\n             match arg.unpack() {\n@@ -551,10 +551,10 @@ impl PrettyPrinter for SymbolPath {\n         where T: Print<'tcx, Self, Output = Self, Error = Self::Error>\n     {\n         if let Some(first) = elems.next() {\n-            self = self.nest(|cx| first.print(cx))?;\n+            self = PrintCx::new(self.tcx, first.print(self)?);\n             for elem in elems {\n                 self.write_str(\",\")?;\n-                self = self.nest(|cx| elem.print(cx))?;\n+                self = PrintCx::new(self.tcx, elem.print(self)?);\n             }\n         }\n         self.ok()"}]}