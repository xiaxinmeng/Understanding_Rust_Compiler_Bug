{"sha": "0c9dc539df56e31d1e2653c64565baec12b473c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOWRjNTM5ZGY1NmUzMWQxZTI2NTNjNjQ1NjViYWVjMTJiNDczYzI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-09-15T12:46:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-15T12:46:22Z"}, "message": "Rollup merge of #36461 - nikomatsakis:issue-36053, r=arielb1\n\nclear obligations-added flag with nested fulfillcx\n\nThis flag is a debugging measure designed to detect cases where we start\na snapshot, create type variables, register obligations involving those\ntype variables in the fulfillment cx, and then have to unroll the\nsnapshot, leaving \"dangling type variables\" behind.  HOWEVER, in some\ncases the flag is wrong. In particular, we sometimes create a\n\"mini-fulfilment-cx\" in which we enroll obligations. As long as this\nfulfillment cx is fully drained before we return, this is not a problem,\nas there won't be any escaping obligations in the main cx. So we add a\nfn to save/restore the flag.\n\nFixes #36053.\n\nr? @arielb1", "tree": {"sha": "83f13e5e9d5843a3dcbafbbc8c6827c7fcd649ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83f13e5e9d5843a3dcbafbbc8c6827c7fcd649ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c9dc539df56e31d1e2653c64565baec12b473c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c9dc539df56e31d1e2653c64565baec12b473c2", "html_url": "https://github.com/rust-lang/rust/commit/0c9dc539df56e31d1e2653c64565baec12b473c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c9dc539df56e31d1e2653c64565baec12b473c2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "959f764f8b320299e3e1cf8d542346d681b85175", "url": "https://api.github.com/repos/rust-lang/rust/commits/959f764f8b320299e3e1cf8d542346d681b85175", "html_url": "https://github.com/rust-lang/rust/commit/959f764f8b320299e3e1cf8d542346d681b85175"}, {"sha": "6353e30bb2d7968332217c04ac25e0800500fb33", "url": "https://api.github.com/repos/rust-lang/rust/commits/6353e30bb2d7968332217c04ac25e0800500fb33", "html_url": "https://github.com/rust-lang/rust/commit/6353e30bb2d7968332217c04ac25e0800500fb33"}], "stats": {"total": 126, "additions": 104, "deletions": 22}, "files": [{"sha": "39fc50666a8ce73f1a7403131c61397b45317208", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0c9dc539df56e31d1e2653c64565baec12b473c2", "patch": "@@ -830,6 +830,33 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         result.map(move |t| InferOk { value: t, obligations: fields.obligations })\n     }\n \n+    // Clear the \"obligations in snapshot\" flag, invoke the closure,\n+    // then restore the flag to its original value. This flag is a\n+    // debugging measure designed to detect cases where we start a\n+    // snapshot, create type variables, register obligations involving\n+    // those type variables in the fulfillment cx, and then have to\n+    // unroll the snapshot, leaving \"dangling type variables\" behind.\n+    // In such cases, the flag will be set by the fulfillment cx, and\n+    // an assertion will fail when rolling the snapshot back.  Very\n+    // useful, much better than grovelling through megabytes of\n+    // RUST_LOG output.\n+    //\n+    // HOWEVER, in some cases the flag is wrong. In particular, we\n+    // sometimes create a \"mini-fulfilment-cx\" in which we enroll\n+    // obligations. As long as this fulfillment cx is fully drained\n+    // before we return, this is not a problem, as there won't be any\n+    // escaping obligations in the main cx. In those cases, you can\n+    // use this function.\n+    pub fn save_and_restore_obligations_in_snapshot_flag<F, R>(&self, func: F) -> R\n+        where F: FnOnce(&Self) -> R\n+    {\n+        let flag = self.obligations_in_snapshot.get();\n+        self.obligations_in_snapshot.set(false);\n+        let result = func(self);\n+        self.obligations_in_snapshot.set(flag);\n+        result\n+    }\n+\n     fn start_snapshot(&self) -> CombinedSnapshot {\n         debug!(\"start_snapshot()\");\n "}, {"sha": "2f63526bf6c270d493b32329d3c3827e1c9a644d", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=0c9dc539df56e31d1e2653c64565baec12b473c2", "patch": "@@ -203,32 +203,34 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n \n-    let mut fulfill_cx = FulfillmentContext::new();\n-    for oblig in obligations.into_iter() {\n-        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-    }\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Err(errors) => {\n-            // no dice!\n-            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                    {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref,\n-                   errors,\n-                   infcx.parameter_environment.caller_bounds);\n-            Err(())\n+    infcx.save_and_restore_obligations_in_snapshot_flag(|infcx| {\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        for oblig in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Err(errors) => {\n+                // no dice!\n+                debug!(\"fulfill_implication: for impls on {:?} and {:?}, \\\n+                        could not fulfill: {:?} given {:?}\",\n+                       source_trait_ref,\n+                       target_trait_ref,\n+                       errors,\n+                       infcx.parameter_environment.caller_bounds);\n+                Err(())\n+            }\n \n-        Ok(()) => {\n-            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref);\n+            Ok(()) => {\n+                debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+                       source_trait_ref,\n+                       target_trait_ref);\n \n-            // Now resolve the *substitution* we built for the target earlier, replacing\n-            // the inference variables inside with whatever we got from fulfillment.\n-            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+                // Now resolve the *substitution* we built for the target earlier, replacing\n+                // the inference variables inside with whatever we got from fulfillment.\n+                Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+            }\n         }\n-    }\n+    })\n }\n \n pub struct SpecializesCache {"}, {"sha": "7da529487aa86f74238e5ccff96970818c9b916d", "filename": "src/test/compile-fail/issue-36053-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Ftest%2Fcompile-fail%2Fissue-36053-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Ftest%2Fcompile-fail%2Fissue-36053-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36053-2.rs?ref=0c9dc539df56e31d1e2653c64565baec12b473c2", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #36053. ICE was caused due to obligations\n+// being added to a special, dedicated fulfillment cx during\n+// a probe.\n+\n+use std::iter::once;\n+fn main() {\n+    once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n+    //~^ ERROR no method named `count`\n+    //~| ERROR E0281\n+    //~| ERROR E0281\n+}"}, {"sha": "2411996cf054b0187fac11434f4dc0300e014ff7", "filename": "src/test/run-pass/issue-36053.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Ftest%2Frun-pass%2Fissue-36053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c9dc539df56e31d1e2653c64565baec12b473c2/src%2Ftest%2Frun-pass%2Fissue-36053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-36053.rs?ref=0c9dc539df56e31d1e2653c64565baec12b473c2", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #36053. ICE was caused due to obligations being\n+// added to a special, dedicated fulfillment cx during a\n+// probe. Problem seems to be related to the particular definition of\n+// `FusedIterator` in std but I was not able to isolate that into an\n+// external crate.\n+\n+#![feature(fused)]\n+use std::iter::FusedIterator;\n+\n+struct Thing<'a>(&'a str);\n+impl<'a> Iterator for Thing<'a> {\n+    type Item = &'a str;\n+    fn next(&mut self) -> Option<&'a str> {\n+        None\n+    }\n+}\n+\n+impl<'a> FusedIterator for Thing<'a> {}\n+\n+fn main() {\n+    Thing(\"test\").fuse().filter(|_| true).count();\n+}"}]}