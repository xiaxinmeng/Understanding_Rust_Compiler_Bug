{"sha": "775ef473d7770f375c571004a8ca1ae42983937b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NWVmNDczZDc3NzBmMzc1YzU3MTAwNGE4Y2ExYWU0Mjk4MzkzN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T16:19:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T16:19:07Z"}, "message": "Auto merge of #6342 - bbqbaron:issue-6061, r=flip1995\n\nLint: filter(Option::is_some).map(Option::unwrap)\n\nFixes #6061\n\n*Please write a short comment explaining your change (or \"none\" for internal only changes)*\nchangelog:\n* add new lint for filter(Option::is_some).map(Option::unwrap)\n\nFirst Rust PR, so I'm sure I've violated some idioms. Happy to change anything.\n\nI'm getting one test failure locally -- a stderr diff for `compile_test`. I'm having a hard time seeing how I could be causing it, so I'm tentatively opening this in the hopes that it's an artifact of my local setup against `rustc`. Hoping it can at least still be reviewed in the meantime.\n\nI'm gathering that since this is a method lint, and `.filter(...).map(...)` is already checked, the means of implementation needs to be a little different, so I didn't exactly follow the setup boilerplate. My way of checking for method calls seems a little too direct (ie, \"is the second element of the expression literally the path for `Option::is_some`?\"), but it seems like that's how some other lints work, so I went with it. I'm assuming we're not concerned about, eg, closures that just end up equivalent to `Option::is_some` by eta reduction.", "tree": {"sha": "70fcd5a3b699af2c704951ec599c784c9b7b5425", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70fcd5a3b699af2c704951ec599c784c9b7b5425"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/775ef473d7770f375c571004a8ca1ae42983937b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/775ef473d7770f375c571004a8ca1ae42983937b", "html_url": "https://github.com/rust-lang/rust/commit/775ef473d7770f375c571004a8ca1ae42983937b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/775ef473d7770f375c571004a8ca1ae42983937b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1021b806c086d66019dacdce5ba550a7c460092", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1021b806c086d66019dacdce5ba550a7c460092", "html_url": "https://github.com/rust-lang/rust/commit/c1021b806c086d66019dacdce5ba550a7c460092"}, {"sha": "56fbbf7b8fc7c99a6c54dfff6847770a4ed27eb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/56fbbf7b8fc7c99a6c54dfff6847770a4ed27eb1", "html_url": "https://github.com/rust-lang/rust/commit/56fbbf7b8fc7c99a6c54dfff6847770a4ed27eb1"}], "stats": {"total": 348, "additions": 279, "deletions": 69}, "files": [{"sha": "fb4a0b500f221d3cc46bf646cfe8940dfcfb2da4", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -2391,6 +2391,7 @@ Released 2018-09-13\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_filter_map\n [`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn"}, {"sha": "3e0a3e3ef9958f77c2e64abee55c360b702eccc2", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -812,6 +812,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::NEW_RET_NO_SELF,\n         &methods::OK_EXPECT,\n         &methods::OPTION_AS_REF_DEREF,\n+        &methods::OPTION_FILTER_MAP,\n         &methods::OPTION_MAP_OR_NONE,\n         &methods::OR_FUN_CALL,\n         &methods::RESULT_MAP_OR_INTO_OPTION,\n@@ -1606,6 +1607,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::NEW_RET_NO_SELF),\n         LintId::of(&methods::OK_EXPECT),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n+        LintId::of(&methods::OPTION_FILTER_MAP),\n         LintId::of(&methods::OPTION_MAP_OR_NONE),\n         LintId::of(&methods::OR_FUN_CALL),\n         LintId::of(&methods::RESULT_MAP_OR_INTO_OPTION),\n@@ -1901,6 +1903,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::MANUAL_FILTER_MAP),\n         LintId::of(&methods::MANUAL_FIND_MAP),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n+        LintId::of(&methods::OPTION_FILTER_MAP),\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n         LintId::of(&methods::SUSPICIOUS_MAP),"}, {"sha": "68f8480dc51b4f4b05e2098d32ddf82216d3df95", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 146, "deletions": 67, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -1,87 +1,166 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet;\n-use clippy_utils::{is_trait_method, path_to_local_id, SpanlessEq};\n+use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_trait_method, path_to_local_id, remove_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::{Expr, ExprKind, PatKind, UnOp};\n+use rustc_hir::def::Res;\n+use rustc_hir::{Expr, ExprKind, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n-use rustc_span::symbol::sym;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::{sym, Symbol};\n+use std::borrow::Cow;\n \n use super::MANUAL_FILTER_MAP;\n use super::MANUAL_FIND_MAP;\n+use super::OPTION_FILTER_MAP;\n+\n+fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol) -> bool {\n+    match &expr.kind {\n+        hir::ExprKind::Path(QPath::TypeRelative(_, ref mname)) => mname.ident.name == method_name,\n+        hir::ExprKind::Path(QPath::Resolved(_, segments)) => {\n+            segments.segments.last().unwrap().ident.name == method_name\n+        },\n+        hir::ExprKind::Closure(_, _, c, _, _) => {\n+            let body = cx.tcx.hir().body(*c);\n+            let closure_expr = remove_blocks(&body.value);\n+            let arg_id = body.params[0].pat.hir_id;\n+            match closure_expr.kind {\n+                hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, ref args, _) => {\n+                    if_chain! {\n+                    if ident.name == method_name;\n+                    if let hir::ExprKind::Path(path) = &args[0].kind;\n+                    if let Res::Local(ref local) = cx.qpath_res(path, args[0].hir_id);\n+                    then {\n+                        return arg_id == *local\n+                    }\n+                    }\n+                    false\n+                },\n+                _ => false,\n+            }\n+        },\n+        _ => false,\n+    }\n+}\n+\n+fn is_option_filter_map<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    filter_arg: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+) -> bool {\n+    is_method(cx, map_arg, sym::unwrap) && is_method(cx, filter_arg, sym!(is_some))\n+}\n+\n+/// lint use of `filter().map()` for `Iterators`\n+fn lint_filter_some_map_unwrap<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_recv: &'tcx hir::Expr<'_>,\n+    filter_arg: &'tcx hir::Expr<'_>,\n+    map_arg: &'tcx hir::Expr<'_>,\n+    target_span: Span,\n+    methods_span: Span,\n+) {\n+    let iterator = is_trait_method(cx, expr, sym::Iterator);\n+    let option = is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&filter_recv), sym::option_type);\n+    if (iterator || option) && is_option_filter_map(cx, filter_arg, map_arg) {\n+        let msg = \"`filter` for `Some` followed by `unwrap`\";\n+        let help = \"consider using `flatten` instead\";\n+        let sugg = format!(\n+            \"{}\",\n+            reindent_multiline(Cow::Borrowed(\"flatten()\"), true, indent_of(cx, target_span),)\n+        );\n+        span_lint_and_sugg(\n+            cx,\n+            OPTION_FILTER_MAP,\n+            methods_span,\n+            msg,\n+            help,\n+            sugg,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n \n /// lint use of `filter().map()` or `find().map()` for `Iterators`\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, is_find: bool, target_span: Span) {\n     if_chain! {\n-        if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n-        if let ExprKind::MethodCall(_, _, [_, filter_arg], filter_span) = map_recv.kind;\n-        if is_trait_method(cx, map_recv, sym::Iterator);\n+            if let ExprKind::MethodCall(_, _, [map_recv, map_arg], map_span) = expr.kind;\n+            if let ExprKind::MethodCall(_, _, [filter_recv, filter_arg], filter_span) = map_recv.kind;\n+            then {\n+              lint_filter_some_map_unwrap(cx, expr, filter_recv, filter_arg,\n+                map_arg, target_span, filter_span.to(map_span));\n+              if_chain! {\n+            if is_trait_method(cx, map_recv, sym::Iterator);\n \n-        // filter(|x| ...is_some())...\n-        if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n-        let filter_body = cx.tcx.hir().body(filter_body_id);\n-        if let [filter_param] = filter_body.params;\n-        // optional ref pattern: `filter(|&x| ..)`\n-        let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n-            (ref_pat, true)\n-        } else {\n-            (filter_param.pat, false)\n-        };\n-        // closure ends with is_some() or is_ok()\n-        if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n-        if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n-        if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n-        if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n-            Some(false)\n-        } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n-            Some(true)\n-        } else {\n-            None\n-        };\n-        if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n+            // filter(|x| ...is_some())...\n+            if let ExprKind::Closure(_, _, filter_body_id, ..) = filter_arg.kind;\n+            let filter_body = cx.tcx.hir().body(filter_body_id);\n+            if let [filter_param] = filter_body.params;\n+            // optional ref pattern: `filter(|&x| ..)`\n+            let (filter_pat, is_filter_param_ref) = if let PatKind::Ref(ref_pat, _) = filter_param.pat.kind {\n+                (ref_pat, true)\n+            } else {\n+                (filter_param.pat, false)\n+            };\n+            // closure ends with is_some() or is_ok()\n+            if let PatKind::Binding(_, filter_param_id, _, None) = filter_pat.kind;\n+            if let ExprKind::MethodCall(path, _, [filter_arg], _) = filter_body.value.kind;\n+            if let Some(opt_ty) = cx.typeck_results().expr_ty(filter_arg).ty_adt_def();\n+            if let Some(is_result) = if cx.tcx.is_diagnostic_item(sym::option_type, opt_ty.did) {\n+                Some(false)\n+            } else if cx.tcx.is_diagnostic_item(sym::result_type, opt_ty.did) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            if path.ident.name.as_str() == if is_result { \"is_ok\" } else { \"is_some\" };\n \n-        // ...map(|x| ...unwrap())\n-        if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n-        let map_body = cx.tcx.hir().body(map_body_id);\n-        if let [map_param] = map_body.params;\n-        if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n-        // closure ends with expect() or unwrap()\n-        if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n-        if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n+            // ...map(|x| ...unwrap())\n+            if let ExprKind::Closure(_, _, map_body_id, ..) = map_arg.kind;\n+            let map_body = cx.tcx.hir().body(map_body_id);\n+            if let [map_param] = map_body.params;\n+            if let PatKind::Binding(_, map_param_id, map_param_ident, None) = map_param.pat.kind;\n+            // closure ends with expect() or unwrap()\n+            if let ExprKind::MethodCall(seg, _, [map_arg, ..], _) = map_body.value.kind;\n+            if matches!(seg.ident.name, sym::expect | sym::unwrap | sym::unwrap_or);\n \n-        let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-            // in `filter(|x| ..)`, replace `*x` with `x`\n-            let a_path = if_chain! {\n-                if !is_filter_param_ref;\n-                if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n-                then { expr_path } else { a }\n-            };\n-            // let the filter closure arg and the map closure arg be equal\n-            if_chain! {\n-                if path_to_local_id(a_path, filter_param_id);\n-                if path_to_local_id(b, map_param_id);\n-                if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n-                then {\n-                    return true;\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                // in `filter(|x| ..)`, replace `*x` with `x`\n+                let a_path = if_chain! {\n+                    if !is_filter_param_ref;\n+                    if let ExprKind::Unary(UnOp::Deref, expr_path) = a.kind;\n+                    then { expr_path } else { a }\n+                };\n+                // let the filter closure arg and the map closure arg be equal\n+                if_chain! {\n+                    if path_to_local_id(a_path, filter_param_id);\n+                    if path_to_local_id(b, map_param_id);\n+                    if TyS::same_type(cx.typeck_results().expr_ty_adjusted(a), cx.typeck_results().expr_ty_adjusted(b));\n+                    then {\n+                        return true;\n+                    }\n                 }\n-            }\n-            false\n-        };\n-        if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n-        then {\n-            let span = filter_span.to(map_span);\n-            let (filter_name, lint) = if is_find {\n-                (\"find\", MANUAL_FIND_MAP)\n-            } else {\n-                (\"filter\", MANUAL_FILTER_MAP)\n+                false\n             };\n-            let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n-            let to_opt = if is_result { \".ok()\" } else { \"\" };\n-            let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n-                snippet(cx, map_arg.span, \"..\"), to_opt);\n-            span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+            if SpanlessEq::new(cx).expr_fallback(eq_fallback).eq_expr(filter_arg, map_arg);\n+            then {\n+                let span = filter_span.to(map_span);\n+                let (filter_name, lint) = if is_find {\n+                    (\"find\", MANUAL_FIND_MAP)\n+                } else {\n+                    (\"filter\", MANUAL_FILTER_MAP)\n+                };\n+                let msg = format!(\"`{}(..).map(..)` can be simplified as `{0}_map(..)`\", filter_name);\n+                let to_opt = if is_result { \".ok()\" } else { \"\" };\n+                let sugg = format!(\"{}_map(|{}| {}{})\", filter_name, map_param_ident,\n+                    snippet(cx, map_arg.span, \"..\"), to_opt);\n+                span_lint_and_sugg(cx, lint, span, &msg, \"try\", sugg, Applicability::MachineApplicable);\n+            }\n+        }\n         }\n     }\n }"}, {"sha": "8a04fd0060d95476ad65ad9d5d212e8f62f4e3ad", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -896,6 +896,28 @@ declare_clippy_lint! {\n     \"using `Iterator::step_by(0)`, which will panic at runtime\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for indirect collection of populated `Option`\n+    ///\n+    /// **Why is this bad?** `Option` is like a collection of 0-1 things, so `flatten`\n+    /// automatically does this without suspicious-looking `unwrap` calls.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let _ = std::iter::empty::<Option<i32>>().filter(Option::is_some).map(Option::unwrap);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let _ = std::iter::empty::<Option<i32>>().flatten();\n+    /// ```\n+    pub OPTION_FILTER_MAP,\n+    complexity,\n+    \"filtering `Option` for `Some` then force-unwrapping, which can be one type-safe operation\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `iter.nth(0)`.\n     ///\n@@ -1651,6 +1673,7 @@ impl_lint_pass!(Methods => [\n     FILTER_MAP_IDENTITY,\n     MANUAL_FILTER_MAP,\n     MANUAL_FIND_MAP,\n+    OPTION_FILTER_MAP,\n     FILTER_MAP_NEXT,\n     FLAT_MAP_IDENTITY,\n     MAP_FLATTEN,\n@@ -1720,10 +1743,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"next\", \"filter\"] => filter_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"skip_while\"] => skip_while_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"iter\"] => iter_next_slice::check(cx, expr, arg_lists[1]),\n-            [\"map\", \"filter\"] => filter_map::check(cx, expr, false),\n+            [\"map\", \"filter\"] => filter_map::check(cx, expr, false, method_spans[0]),\n             [\"map\", \"filter_map\"] => filter_map_map::check(cx, expr),\n             [\"next\", \"filter_map\"] => filter_map_next::check(cx, expr, arg_lists[1], self.msrv.as_ref()),\n-            [\"map\", \"find\"] => filter_map::check(cx, expr, true),\n+            [\"map\", \"find\"] => filter_map::check(cx, expr, true, method_spans[0]),\n             [\"flat_map\", \"filter\"] => filter_flat_map::check(cx, expr),\n             [\"flat_map\", \"filter_map\"] => filter_map_flat_map::check(cx, expr),\n             [\"flat_map\", ..] => flat_map_identity::check(cx, expr, arg_lists[0], method_spans[0]),"}, {"sha": "f9d1825ade05483c44351a1527efcbf77cdf786a", "filename": "tests/ui/option_filter_map.fixed", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/tests%2Fui%2Foption_filter_map.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/tests%2Fui%2Foption_filter_map.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_filter_map.fixed?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -0,0 +1,23 @@\n+#![warn(clippy::option_filter_map)]\n+// run-rustfix\n+fn odds_out(x: i32) -> Option<i32> {\n+    if x % 2 == 0 { Some(x) } else { None }\n+}\n+\n+fn main() {\n+    let _ = Some(Some(1)).flatten();\n+    let _ = Some(Some(1)).flatten();\n+    let _ = Some(1).map(odds_out).flatten();\n+    let _ = Some(1).map(odds_out).flatten();\n+\n+    let _ = vec![Some(1)].into_iter().flatten();\n+    let _ = vec![Some(1)].into_iter().flatten();\n+    let _ = vec![1]\n+        .into_iter()\n+        .map(odds_out)\n+        .flatten();\n+    let _ = vec![1]\n+        .into_iter()\n+        .map(odds_out)\n+        .flatten();\n+}"}, {"sha": "588e1ccccce20149fc5750b4c9c57575cf846f7d", "filename": "tests/ui/option_filter_map.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/tests%2Fui%2Foption_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/tests%2Fui%2Foption_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_filter_map.rs?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -0,0 +1,25 @@\n+#![warn(clippy::option_filter_map)]\n+// run-rustfix\n+fn odds_out(x: i32) -> Option<i32> {\n+    if x % 2 == 0 { Some(x) } else { None }\n+}\n+\n+fn main() {\n+    let _ = Some(Some(1)).filter(Option::is_some).map(Option::unwrap);\n+    let _ = Some(Some(1)).filter(|o| o.is_some()).map(|o| o.unwrap());\n+    let _ = Some(1).map(odds_out).filter(Option::is_some).map(Option::unwrap);\n+    let _ = Some(1).map(odds_out).filter(|o| o.is_some()).map(|o| o.unwrap());\n+\n+    let _ = vec![Some(1)].into_iter().filter(Option::is_some).map(Option::unwrap);\n+    let _ = vec![Some(1)].into_iter().filter(|o| o.is_some()).map(|o| o.unwrap());\n+    let _ = vec![1]\n+        .into_iter()\n+        .map(odds_out)\n+        .filter(Option::is_some)\n+        .map(Option::unwrap);\n+    let _ = vec![1]\n+        .into_iter()\n+        .map(odds_out)\n+        .filter(|o| o.is_some())\n+        .map(|o| o.unwrap());\n+}"}, {"sha": "31a82969d5a1c9bd0a9e4716a14b2f98e1c9a2a7", "filename": "tests/ui/option_filter_map.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/775ef473d7770f375c571004a8ca1ae42983937b/tests%2Fui%2Foption_filter_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/775ef473d7770f375c571004a8ca1ae42983937b/tests%2Fui%2Foption_filter_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_filter_map.stderr?ref=775ef473d7770f375c571004a8ca1ae42983937b", "patch": "@@ -0,0 +1,56 @@\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:8:27\n+   |\n+LL |     let _ = Some(Some(1)).filter(Option::is_some).map(Option::unwrap);\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `flatten` instead: `flatten()`\n+   |\n+   = note: `-D clippy::option-filter-map` implied by `-D warnings`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:9:27\n+   |\n+LL |     let _ = Some(Some(1)).filter(|o| o.is_some()).map(|o| o.unwrap());\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `flatten` instead: `flatten()`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:10:35\n+   |\n+LL |     let _ = Some(1).map(odds_out).filter(Option::is_some).map(Option::unwrap);\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `flatten` instead: `flatten()`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:11:35\n+   |\n+LL |     let _ = Some(1).map(odds_out).filter(|o| o.is_some()).map(|o| o.unwrap());\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `flatten` instead: `flatten()`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:13:39\n+   |\n+LL |     let _ = vec![Some(1)].into_iter().filter(Option::is_some).map(Option::unwrap);\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `flatten` instead: `flatten()`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:14:39\n+   |\n+LL |     let _ = vec![Some(1)].into_iter().filter(|o| o.is_some()).map(|o| o.unwrap());\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `flatten` instead: `flatten()`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:18:10\n+   |\n+LL |           .filter(Option::is_some)\n+   |  __________^\n+LL | |         .map(Option::unwrap);\n+   | |____________________________^ help: consider using `flatten` instead: `flatten()`\n+\n+error: `filter` for `Some` followed by `unwrap`\n+  --> $DIR/option_filter_map.rs:23:10\n+   |\n+LL |           .filter(|o| o.is_some())\n+   |  __________^\n+LL | |         .map(|o| o.unwrap());\n+   | |____________________________^ help: consider using `flatten` instead: `flatten()`\n+\n+error: aborting due to 8 previous errors\n+"}]}