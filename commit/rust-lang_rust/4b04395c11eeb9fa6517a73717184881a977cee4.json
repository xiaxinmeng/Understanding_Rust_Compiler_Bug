{"sha": "4b04395c11eeb9fa6517a73717184881a977cee4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMDQzOTVjMTFlZWI5ZmE2NTE3YTczNzE3MTg0ODgxYTk3N2NlZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-05T03:21:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-05T03:21:50Z"}, "message": "auto merge of #10182 : alexcrichton/rust/typeid-intrinsic, r=nikomatsakis\n\nThis isn't quite as fancy as the struct in #9913, but I'm not sure we should be exposing crate names/hashes of the types. That being said, it'd be pretty easy to extend this (the deterministic hashing regardless of what crate you're in was the hard part).", "tree": {"sha": "93326e0289fcf04a85b7048c25dc9175d16de291", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93326e0289fcf04a85b7048c25dc9175d16de291"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b04395c11eeb9fa6517a73717184881a977cee4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b04395c11eeb9fa6517a73717184881a977cee4", "html_url": "https://github.com/rust-lang/rust/commit/4b04395c11eeb9fa6517a73717184881a977cee4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b04395c11eeb9fa6517a73717184881a977cee4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72e432df9dc5f546d522654336a38213af69cac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/72e432df9dc5f546d522654336a38213af69cac8", "html_url": "https://github.com/rust-lang/rust/commit/72e432df9dc5f546d522654336a38213af69cac8"}, {"sha": "b00449380f520deb65de26e654aeaba4561ee13f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b00449380f520deb65de26e654aeaba4561ee13f", "html_url": "https://github.com/rust-lang/rust/commit/b00449380f520deb65de26e654aeaba4561ee13f"}], "stats": {"total": 464, "additions": 367, "deletions": 97}, "files": [{"sha": "3d1c74028cc3b2e623922c48d6277c915ffe5c76", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -285,6 +285,11 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n             Ret(bcx, td);\n         }\n+        \"type_id\" => {\n+            let hash = ty::hash_crate_independent(ccx.tcx, substs.tys[0],\n+                                                  ccx.link_meta.extras_hash);\n+            Ret(bcx, C_i64(hash as i64))\n+        }\n         \"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);"}, {"sha": "65aa755d67c4e29420c35acedc05227d9d2bd452", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -4724,3 +4724,154 @@ pub fn trait_of_method(tcx: ctxt, def_id: ast::DefId)\n \n     result\n }\n+\n+/// Creates a hash of the type `t` which will be the same no matter what crate\n+/// context it's calculated within. This is used by the `type_id` intrinsic.\n+pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n+    use std::hash::{SipState, Streaming};\n+    use metadata::cstore;\n+\n+    let mut hash = SipState::new(0, 0);\n+    let region = |_hash: &mut SipState, r: Region| {\n+        match r {\n+            re_static => {}\n+\n+            re_empty | re_bound(*) | re_free(*) | re_scope(*) | re_infer(*) =>\n+                tcx.sess.bug(\"non-static region found when hashing a type\")\n+        }\n+    };\n+    let vstore = |hash: &mut SipState, v: vstore| {\n+        match v {\n+            vstore_fixed(_) => hash.input([0]),\n+            vstore_uniq => hash.input([1]),\n+            vstore_box => hash.input([2]),\n+            vstore_slice(r) => {\n+                hash.input([3]);\n+                region(hash, r);\n+            }\n+        }\n+    };\n+    let did = |hash: &mut SipState, did: DefId| {\n+        let h = if ast_util::is_local(did) {\n+            local_hash\n+        } else {\n+            cstore::get_crate_hash(tcx.sess.cstore, did.crate)\n+        };\n+        hash.input(h.as_bytes());\n+        iter(hash, &did.node);\n+    };\n+    let mt = |hash: &mut SipState, mt: mt| {\n+        iter(hash, &mt.mutbl);\n+    };\n+    fn iter<T: IterBytes>(hash: &mut SipState, t: &T) {\n+        do t.iter_bytes(true) |bytes| { hash.input(bytes); true };\n+    }\n+    do ty::walk_ty(t) |t| {\n+        match ty::get(t).sty {\n+            ty_nil => hash.input([0]),\n+            ty_bot => hash.input([1]),\n+            ty_bool => hash.input([2]),\n+            ty_char => hash.input([3]),\n+            ty_int(i) => {\n+                hash.input([4]);\n+                iter(&mut hash, &i);\n+            }\n+            ty_uint(u) => {\n+                hash.input([5]);\n+                iter(&mut hash, &u);\n+            }\n+            ty_float(f) => {\n+                hash.input([6]);\n+                iter(&mut hash, &f);\n+            }\n+            ty_estr(v) => {\n+                hash.input([7]);\n+                vstore(&mut hash, v);\n+            }\n+            ty_enum(d, _) => {\n+                hash.input([8]);\n+                did(&mut hash, d);\n+            }\n+            ty_box(m) => {\n+                hash.input([9]);\n+                mt(&mut hash, m);\n+            }\n+            ty_uniq(m) => {\n+                hash.input([10]);\n+                mt(&mut hash, m);\n+            }\n+            ty_evec(m, v) => {\n+                hash.input([11]);\n+                mt(&mut hash, m);\n+                vstore(&mut hash, v);\n+            }\n+            ty_ptr(m) => {\n+                hash.input([12]);\n+                mt(&mut hash, m);\n+            }\n+            ty_rptr(r, m) => {\n+                hash.input([13]);\n+                region(&mut hash, r);\n+                mt(&mut hash, m);\n+            }\n+            ty_bare_fn(ref b) => {\n+                hash.input([14]);\n+                iter(&mut hash, &b.purity);\n+                iter(&mut hash, &b.abis);\n+            }\n+            ty_closure(ref c) => {\n+                hash.input([15]);\n+                iter(&mut hash, &c.purity);\n+                iter(&mut hash, &c.sigil);\n+                iter(&mut hash, &c.onceness);\n+                iter(&mut hash, &c.bounds);\n+                region(&mut hash, c.region);\n+            }\n+            ty_trait(d, _, store, m, bounds) => {\n+                hash.input([17]);\n+                did(&mut hash, d);\n+                match store {\n+                    BoxTraitStore => hash.input([0]),\n+                    UniqTraitStore => hash.input([1]),\n+                    RegionTraitStore(r) => {\n+                        hash.input([2]);\n+                        region(&mut hash, r);\n+                    }\n+                }\n+                iter(&mut hash, &m);\n+                iter(&mut hash, &bounds);\n+            }\n+            ty_struct(d, _) => {\n+                hash.input([18]);\n+                did(&mut hash, d);\n+            }\n+            ty_tup(ref inner) => {\n+                hash.input([19]);\n+                iter(&mut hash, &inner.len());\n+            }\n+            ty_param(p) => {\n+                hash.input([20]);\n+                iter(&mut hash, &p.idx);\n+                did(&mut hash, p.def_id);\n+            }\n+            ty_self(d) => {\n+                hash.input([21]);\n+                did(&mut hash, d);\n+            }\n+            ty_infer(_) => unreachable!(),\n+            ty_err => hash.input([23]),\n+            ty_type => hash.input([24]),\n+            ty_opaque_box => hash.input([25]),\n+            ty_opaque_closure_ptr(s) => {\n+                hash.input([26]);\n+                iter(&mut hash, &s);\n+            }\n+            ty_unboxed_vec(m) => {\n+                hash.input([27]);\n+                mt(&mut hash, m);\n+            }\n+        }\n+    }\n+\n+    hash.result_u64()\n+}"}, {"sha": "4b282cfef9277654fbaa148e6b05c351f413021e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -3700,6 +3700,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n               });\n               (1u, ~[], td_ptr)\n             }\n+            \"type_id\" => (1u, ~[], ty::mk_u64()),\n             \"visit_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,"}, {"sha": "8cd8ca23b45f09ecaa08c77ad1443bd530372785", "filename": "src/libstd/any.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -15,24 +15,38 @@ use cast::transmute;\n use cmp::Eq;\n use option::{Option, Some, None};\n use to_str::ToStr;\n-use unstable::intrinsics::{TyDesc, get_tydesc, forget};\n+use unstable::intrinsics;\n use util::Void;\n \n ///////////////////////////////////////////////////////////////////////////////\n // TypeId\n-// FIXME: #9913 - Needs proper intrinsic support to work reliably cross crate\n ///////////////////////////////////////////////////////////////////////////////\n \n /// `TypeId` represents a globally unique identifier for a type\n+#[cfg(stage0)]\n pub struct TypeId {\n-    priv t: *TyDesc\n+    priv t: *intrinsics::TyDesc,\n+}\n+\n+/// `TypeId` represents a globally unique identifier for a type\n+#[cfg(not(stage0))]\n+pub struct TypeId {\n+    priv t: u64,\n }\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n     #[inline]\n-    pub fn of<T>() -> TypeId {\n-        TypeId{ t: unsafe { get_tydesc::<T>() } }\n+    #[cfg(stage0)]\n+    pub fn of<T: 'static>() -> TypeId {\n+        TypeId{ t: unsafe { intrinsics::get_tydesc::<T>() } }\n+    }\n+\n+    /// Returns the `TypeId` of the type this generic function has been instantiated with\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    pub fn of<T: 'static>() -> TypeId {\n+        TypeId{ t: unsafe { intrinsics::type_id::<T>() } }\n     }\n }\n \n@@ -50,22 +64,32 @@ impl Eq for TypeId {\n /// The `Any` trait is implemented by all types, and can be used as a trait object\n /// for dynamic typing\n pub trait Any {\n+    /// Get the `TypeId` of `self`\n+    fn get_type_id(&self) -> TypeId;\n+\n+    /// Get a void pointer to `self`\n+    fn as_void_ptr(&self) -> *Void;\n+\n+    /// Get a mutable void pointer to `self`\n+    fn as_mut_void_ptr(&mut self) -> *mut Void;\n+}\n+\n+impl<T: 'static> Any for T {\n     /// Get the `TypeId` of `self`\n     fn get_type_id(&self) -> TypeId {\n-        TypeId::of::<Self>()\n+        TypeId::of::<T>()\n     }\n \n     /// Get a void pointer to `self`\n     fn as_void_ptr(&self) -> *Void {\n-        self as *Self as *Void\n+        self as *T as *Void\n     }\n \n     /// Get a mutable void pointer to `self`\n     fn as_mut_void_ptr(&mut self) -> *mut Void {\n-        self as *mut Self as *mut Void\n+        self as *mut T as *mut Void\n     }\n }\n-impl<T> Any for T {}\n \n ///////////////////////////////////////////////////////////////////////////////\n // Extension methods for Any trait objects.\n@@ -75,16 +99,16 @@ impl<T> Any for T {}\n /// Extension methods for a referenced `Any` trait object\n pub trait AnyRefExt<'self> {\n     /// Returns true if the boxed type is the same as `T`\n-    fn is<T>(self) -> bool;\n+    fn is<T: 'static>(self) -> bool;\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_ref<T>(self) -> Option<&'self T>;\n+    fn as_ref<T: 'static>(self) -> Option<&'self T>;\n }\n \n impl<'self> AnyRefExt<'self> for &'self Any {\n     #[inline]\n-    fn is<T>(self) -> bool {\n+    fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n         let t = TypeId::of::<T>();\n \n@@ -96,7 +120,7 @@ impl<'self> AnyRefExt<'self> for &'self Any {\n     }\n \n     #[inline]\n-    fn as_ref<T>(self) -> Option<&'self T> {\n+    fn as_ref<T: 'static>(self) -> Option<&'self T> {\n         if self.is::<T>() {\n             Some(unsafe { transmute(self.as_void_ptr()) })\n         } else {\n@@ -109,12 +133,12 @@ impl<'self> AnyRefExt<'self> for &'self Any {\n pub trait AnyMutRefExt<'self> {\n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_mut<T>(self) -> Option<&'self mut T>;\n+    fn as_mut<T: 'static>(self) -> Option<&'self mut T>;\n }\n \n impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n     #[inline]\n-    fn as_mut<T>(self) -> Option<&'self mut T> {\n+    fn as_mut<T: 'static>(self) -> Option<&'self mut T> {\n         if self.is::<T>() {\n             Some(unsafe { transmute(self.as_mut_void_ptr()) })\n         } else {\n@@ -127,19 +151,19 @@ impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n pub trait AnyOwnExt {\n     /// Returns the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn move<T>(self) -> Option<~T>;\n+    fn move<T: 'static>(self) -> Option<~T>;\n }\n \n impl AnyOwnExt for ~Any {\n     #[inline]\n-    fn move<T>(self) -> Option<~T> {\n+    fn move<T: 'static>(self) -> Option<~T> {\n         if self.is::<T>() {\n             unsafe {\n                 // Extract the pointer to the boxed value, temporary alias with self\n                 let ptr: ~T = transmute(self.as_void_ptr());\n \n                 // Prevent destructor on self being run\n-                forget(self);\n+                intrinsics::forget(self);\n \n                 Some(ptr)\n             }\n@@ -174,8 +198,10 @@ mod tests {\n \n     #[test]\n     fn type_id() {\n-        let (a, b, c) = (TypeId::of::<uint>(), TypeId::of::<&str>(), TypeId::of::<Test>());\n-        let (d, e, f) = (TypeId::of::<uint>(), TypeId::of::<&str>(), TypeId::of::<Test>());\n+        let (a, b, c) = (TypeId::of::<uint>(), TypeId::of::<&'static str>(),\n+                         TypeId::of::<Test>());\n+        let (d, e, f) = (TypeId::of::<uint>(), TypeId::of::<&'static str>(),\n+                         TypeId::of::<Test>());\n \n         assert!(a != b);\n         assert!(a != c);"}, {"sha": "2709c118191de54318d841e5a67025e3587e47cb", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -155,9 +155,9 @@ use cell::Cell;\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n-use rt::task::UnwindMessageLinked;\n use rt::task::{UnwindResult, Failure};\n use task::spawn::Taskgroup;\n+use task::LinkedFailure;\n use to_bytes::IterBytes;\n use unstable::atomics::{AtomicUint, Relaxed};\n use unstable::sync::{UnsafeArc, UnsafeArcSelf, UnsafeArcT, LittleLock};\n@@ -597,7 +597,7 @@ impl Death {\n                 }\n \n                 if !success {\n-                    result = Cell::new(Failure(UnwindMessageLinked));\n+                    result = Cell::new(Failure(~LinkedFailure as ~Any));\n                 }\n             }\n             on_exit(result.take());"}, {"sha": "cf7c291d189e40516c5b0df0d5969ebd5ae545cb", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 24, "deletions": 53, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -36,6 +36,7 @@ use rt::logging::StdErrLogger;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::stack::{StackSegment, StackPool};\n use send_str::SendStr;\n+use task::LinkedFailure;\n use task::spawn::Taskgroup;\n use unstable::finally::Finally;\n \n@@ -95,8 +96,8 @@ pub enum UnwindResult {\n     /// The task is ending successfully\n     Success,\n \n-    /// The Task is failing with reason `UnwindMessage`\n-    Failure(UnwindMessage),\n+    /// The Task is failing with reason `~Any`\n+    Failure(~Any),\n }\n \n impl UnwindResult {\n@@ -119,27 +120,9 @@ impl UnwindResult {\n     }\n }\n \n-/// Represents the cause of a task failure\n-#[deriving(ToStr)]\n-pub enum UnwindMessage {\n-    // FIXME: #9913 - This variant is not neccessary once Any works properly\n-    /// Failed with a static string message\n-    UnwindMessageStrStatic(&'static str),\n-\n-    // FIXME: #9913 - This variant is not neccessary once Any works properly\n-    /// Failed with a owned string message\n-    UnwindMessageStrOwned(~str),\n-\n-    /// Failed with an `~Any`\n-    UnwindMessageAny(~Any),\n-\n-    /// Failed because of linked failure\n-    UnwindMessageLinked\n-}\n-\n pub struct Unwinder {\n     unwinding: bool,\n-    cause: Option<UnwindMessage>\n+    cause: Option<~Any>\n }\n \n impl Unwinder {\n@@ -532,7 +515,7 @@ impl Unwinder {\n         }\n     }\n \n-    pub fn begin_unwind(&mut self, cause: UnwindMessage) -> ! {\n+    pub fn begin_unwind(&mut self, cause: ~Any) -> ! {\n         #[fixed_stack_segment]; #[inline(never)];\n \n         self.unwinding = true;\n@@ -648,46 +631,34 @@ pub fn begin_unwind_raw(msg: *c_char, file: *c_char, line: size_t) -> ! {\n \n /// This is the entry point of unwinding for fail!() and assert!().\n pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> ! {\n-    // Wrap the fail message in a `Any` box for uniform representation.\n-    let any = ~msg as ~Any;\n-\n-    // FIXME: #9913 - This can be changed to be internal to begin_unwind_internal\n-    // once Any works properly.\n-    // As a workaround, string types need to be special cased right now\n-    // because `Any` does not support dynamically querying whether the\n-    // type implements a trait yet, so without requiring that every `Any`\n-    // also implements `ToStr` there is no way to get a failure message\n-    // out of it again during unwinding.\n-    let msg = if any.is::<&'static str>() {\n-        UnwindMessageStrStatic(*any.move::<&'static str>().unwrap())\n-    } else if any.is::<~str>() {\n-        UnwindMessageStrOwned(*any.move::<~str>().unwrap())\n-    } else {\n-        UnwindMessageAny(any)\n-    };\n-\n-    begin_unwind_internal(msg, file, line)\n-}\n-\n-fn begin_unwind_internal(msg: UnwindMessage, file: &'static str, line: uint) -> ! {\n+    use any::AnyRefExt;\n     use rt::in_green_task_context;\n-    use rt::task::Task;\n     use rt::local::Local;\n+    use rt::task::Task;\n     use str::Str;\n     use unstable::intrinsics;\n \n     unsafe {\n-        // Be careful not to allocate in this block, if we're failing we may\n-        // have been failing due to a lack of memory in the first place...\n-\n         let task: *mut Task;\n+        // Note that this should be the only allocation performed in this block.\n+        // Currently this means that fail!() on OOM will invoke this code path,\n+        // but then again we're not really ready for failing on OOM anyway. If\n+        // we do start doing this, then we should propagate this allocation to\n+        // be performed in the parent of this task instead of the task that's\n+        // failing.\n+        let msg = ~msg as ~Any;\n \n         {\n-            let msg_s = match msg {\n-                UnwindMessageAny(_) => \"~Any\",\n-                UnwindMessageLinked => \"linked failure\",\n-                UnwindMessageStrOwned(ref s)  => s.as_slice(),\n-                UnwindMessageStrStatic(ref s) => s.as_slice(),\n+            //let msg: &Any = msg;\n+            let msg_s = match msg.as_ref::<&'static str>() {\n+                Some(s) => *s,\n+                None => match msg.as_ref::<~str>() {\n+                    Some(s) => s.as_slice(),\n+                    None => match msg.as_ref::<LinkedFailure>() {\n+                        Some(*) => \"linked failure\",\n+                        None => \"~Any\",\n+                    }\n+                }\n             };\n \n             if !in_green_task_context() {"}, {"sha": "e75f8f6237fe2bb50013545b4f4ba9e9be06c31d", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -60,8 +60,6 @@ use comm::{stream, Chan, GenericChan, GenericPort, Port, Peekable};\n use result::{Result, Ok, Err};\n use rt::in_green_task_context;\n use rt::local::Local;\n-use rt::task::{UnwindMessageAny, UnwindMessageLinked};\n-use rt::task::{UnwindMessageStrStatic, UnwindMessageStrOwned};\n use rt::task::{UnwindResult, Success, Failure};\n use send_str::{SendStr, IntoSendStr};\n use unstable::finally::Finally;\n@@ -90,30 +88,25 @@ pub type TaskResult = Result<(), ~Any>;\n \n pub struct LinkedFailure;\n \n-#[inline]\n-fn wrap_as_any(res: UnwindResult) -> TaskResult {\n-    match res {\n-        Success => Ok(()),\n-        Failure(UnwindMessageAny(a)) => Err(a),\n-        Failure(UnwindMessageLinked) => Err(~LinkedFailure as ~Any),\n-        Failure(UnwindMessageStrOwned(s))  => Err(~s as ~Any),\n-        Failure(UnwindMessageStrStatic(s)) => Err(~s as ~Any),\n-    }\n-}\n-\n pub struct TaskResultPort {\n     priv port: Port<UnwindResult>\n }\n \n+fn to_task_result(res: UnwindResult) -> TaskResult {\n+    match res {\n+        Success => Ok(()), Failure(a) => Err(a),\n+    }\n+}\n+\n impl GenericPort<TaskResult> for TaskResultPort {\n     #[inline]\n     fn recv(&self) -> TaskResult {\n-        wrap_as_any(self.port.recv())\n+        to_task_result(self.port.recv())\n     }\n \n     #[inline]\n     fn try_recv(&self) -> Option<TaskResult> {\n-        self.port.try_recv().map(wrap_as_any)\n+        self.port.try_recv().map(to_task_result)\n     }\n }\n "}, {"sha": "a4a43a01edd2811038cd9877313f69d1fb6cbdb5", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -83,11 +83,11 @@ use local_data;\n use rt::local::Local;\n use rt::sched::{Scheduler, Shutdown, TaskFromFriend};\n use rt::task::{Task, Sched};\n-use rt::task::{UnwindMessageLinked, UnwindMessageStrStatic};\n use rt::task::{UnwindResult, Success, Failure};\n use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::{in_green_task_context, new_event_loop, KillHandle};\n+use task::LinkedFailure;\n use task::SingleThreaded;\n use task::TaskOpts;\n use task::unkillable;\n@@ -324,7 +324,7 @@ impl Drop for Taskgroup {\n         do RuntimeGlue::with_task_handle_and_failing |me, failing| {\n             if failing {\n                 for x in self.notifier.mut_iter() {\n-                    x.task_result = Some(Failure(UnwindMessageLinked));\n+                    x.task_result = Some(Failure(~LinkedFailure as ~Any));\n                 }\n                 // Take everybody down with us. After this point, every\n                 // other task in the group will see 'tg' as none, which\n@@ -379,7 +379,7 @@ impl AutoNotify {\n             notify_chan: chan,\n \n             // Un-set above when taskgroup successfully made.\n-            task_result: Some(Failure(UnwindMessageStrStatic(\"AutoNotify::new()\")))\n+            task_result: Some(Failure(~(\"AutoNotify::new()\") as ~Any))\n         }\n     }\n }"}, {"sha": "d042440b4f3eafd1ad15d3127b6fa74e212c4ef7", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -49,23 +49,23 @@ pub struct TyDesc {\n     align: uint,\n \n     // Called on a copy of a value of type `T` *after* memcpy\n-    priv take_glue: GlueFn,\n+    take_glue: GlueFn,\n \n     // Called when a value of type `T` is no longer needed\n     drop_glue: GlueFn,\n \n     // Called by drop glue when a value of type `T` can be freed\n-    priv free_glue: GlueFn,\n+    free_glue: GlueFn,\n \n     // Called by reflection visitor to visit a value of type `T`\n-    priv visit_glue: GlueFn,\n+    visit_glue: GlueFn,\n \n     // If T represents a box pointer (`@U` or `~U`), then\n     // `borrow_offset` is the amount that the pointer must be adjusted\n     // to find the payload.  This is always derivable from the type\n     // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n     // `U` is unknown.\n-    priv borrow_offset: uint,\n+    borrow_offset: uint,\n \n     // Name corresponding to the type\n     name: &'static str\n@@ -307,6 +307,12 @@ extern \"rust-intrinsic\" {\n     /// Get a static pointer to a type descriptor.\n     pub fn get_tydesc<T>() -> *TyDesc;\n \n+    /// Gets an identifier which is globally unique to the specified type. This\n+    /// function will return the same value for a type regardless of whichever\n+    /// crate it is invoked in.\n+    #[cfg(not(stage0))]\n+    pub fn type_id<T: 'static>() -> u64;\n+\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "768b0d19da3d1695b1812eddbeb351d9754094b7", "filename": "src/test/auxiliary/typeid-intrinsic.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::unstable::intrinsics;\n+\n+pub struct A;\n+pub struct B(Option<A>);\n+pub struct C(Option<int>);\n+pub struct D(Option<&'static str>);\n+pub struct E(Result<&'static str, int>);\n+\n+pub type F = Option<int>;\n+pub type G = uint;\n+pub type H = &'static str;\n+\n+pub unsafe fn id_A() -> u64 { intrinsics::type_id::<A>() }\n+pub unsafe fn id_B() -> u64 { intrinsics::type_id::<B>() }\n+pub unsafe fn id_C() -> u64 { intrinsics::type_id::<C>() }\n+pub unsafe fn id_D() -> u64 { intrinsics::type_id::<D>() }\n+pub unsafe fn id_E() -> u64 { intrinsics::type_id::<E>() }\n+pub unsafe fn id_F() -> u64 { intrinsics::type_id::<F>() }\n+pub unsafe fn id_G() -> u64 { intrinsics::type_id::<G>() }\n+pub unsafe fn id_H() -> u64 { intrinsics::type_id::<H>() }\n+\n+pub unsafe fn foo<T: 'static>() -> u64 { intrinsics::type_id::<T>() }"}, {"sha": "768b0d19da3d1695b1812eddbeb351d9754094b7", "filename": "src/test/auxiliary/typeid-intrinsic2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic2.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::unstable::intrinsics;\n+\n+pub struct A;\n+pub struct B(Option<A>);\n+pub struct C(Option<int>);\n+pub struct D(Option<&'static str>);\n+pub struct E(Result<&'static str, int>);\n+\n+pub type F = Option<int>;\n+pub type G = uint;\n+pub type H = &'static str;\n+\n+pub unsafe fn id_A() -> u64 { intrinsics::type_id::<A>() }\n+pub unsafe fn id_B() -> u64 { intrinsics::type_id::<B>() }\n+pub unsafe fn id_C() -> u64 { intrinsics::type_id::<C>() }\n+pub unsafe fn id_D() -> u64 { intrinsics::type_id::<D>() }\n+pub unsafe fn id_E() -> u64 { intrinsics::type_id::<E>() }\n+pub unsafe fn id_F() -> u64 { intrinsics::type_id::<F>() }\n+pub unsafe fn id_G() -> u64 { intrinsics::type_id::<G>() }\n+pub unsafe fn id_H() -> u64 { intrinsics::type_id::<H>() }\n+\n+pub unsafe fn foo<T: 'static>() -> u64 { intrinsics::type_id::<T>() }"}, {"sha": "b9ad9b09d4992966f58748e877bc4deeae31bd2a", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b04395c11eeb9fa6517a73717184881a977cee4/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=4b04395c11eeb9fa6517a73717184881a977cee4", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like aux-build\n+// aux-build:typeid-intrinsic.rs\n+// aux-build:typeid-intrinsic2.rs\n+\n+extern mod other1(name = \"typeid-intrinsic\");\n+extern mod other2(name = \"typeid-intrinsic2\");\n+\n+use std::unstable::intrinsics;\n+\n+struct A;\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(intrinsics::type_id::<other1::A>(), other1::id_A());\n+        assert_eq!(intrinsics::type_id::<other1::B>(), other1::id_B());\n+        assert_eq!(intrinsics::type_id::<other1::C>(), other1::id_C());\n+        assert_eq!(intrinsics::type_id::<other1::D>(), other1::id_D());\n+        assert_eq!(intrinsics::type_id::<other1::E>(), other1::id_E());\n+        assert_eq!(intrinsics::type_id::<other1::F>(), other1::id_F());\n+        assert_eq!(intrinsics::type_id::<other1::G>(), other1::id_G());\n+        assert_eq!(intrinsics::type_id::<other1::H>(), other1::id_H());\n+\n+        assert_eq!(intrinsics::type_id::<other2::A>(), other2::id_A());\n+        assert_eq!(intrinsics::type_id::<other2::B>(), other2::id_B());\n+        assert_eq!(intrinsics::type_id::<other2::C>(), other2::id_C());\n+        assert_eq!(intrinsics::type_id::<other2::D>(), other2::id_D());\n+        assert_eq!(intrinsics::type_id::<other2::E>(), other2::id_E());\n+        assert_eq!(intrinsics::type_id::<other2::F>(), other2::id_F());\n+        assert_eq!(intrinsics::type_id::<other2::G>(), other2::id_G());\n+        assert_eq!(intrinsics::type_id::<other2::H>(), other2::id_H());\n+\n+        assert_eq!(other1::id_F(), other2::id_F());\n+        assert_eq!(other1::id_G(), other2::id_G());\n+        assert_eq!(other1::id_H(), other2::id_H());\n+\n+        assert_eq!(intrinsics::type_id::<int>(), other2::foo::<int>());\n+        assert_eq!(intrinsics::type_id::<int>(), other1::foo::<int>());\n+        assert_eq!(other2::foo::<int>(), other1::foo::<int>());\n+        assert_eq!(intrinsics::type_id::<A>(), other2::foo::<A>());\n+        assert_eq!(intrinsics::type_id::<A>(), other1::foo::<A>());\n+        assert_eq!(other2::foo::<A>(), other1::foo::<A>());\n+    }\n+}"}]}