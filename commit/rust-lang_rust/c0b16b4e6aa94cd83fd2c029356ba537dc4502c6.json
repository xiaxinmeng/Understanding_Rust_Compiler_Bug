{"sha": "c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYjE2YjRlNmFhOTRjZDgzZmQyYzAyOTM1NmJhNTM3ZGM0NTAyYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-26T03:42:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-26T03:42:59Z"}, "message": "Auto merge of #67268 - estebank:assoc-types, r=oli-obk\n\nTweak errors for missing associated types and type parameters\n\n* On `dyn Trait` missing associated types, provide a structured suggestion for them\n* On missing type parameters, provide structured suggestion for them\n* Point at trait definition when missing required type parameter\n* Tweak output of E0658\n* Tweak wording of E0719\n* Account for `Trait1 + Trait2` case\n\nFix #66380, fix #60595. CC #63711.", "tree": {"sha": "a96f943e2f0d94458b4e3d1e2db6d6ae48c86e10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a96f943e2f0d94458b4e3d1e2db6d6ae48c86e10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "html_url": "https://github.com/rust-lang/rust/commit/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b13d65ab9274323de72539556f2c5f7eef29f4a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b13d65ab9274323de72539556f2c5f7eef29f4a1", "html_url": "https://github.com/rust-lang/rust/commit/b13d65ab9274323de72539556f2c5f7eef29f4a1"}, {"sha": "621d7e959b24ea8640584f0ced13ec016be35d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/621d7e959b24ea8640584f0ced13ec016be35d16", "html_url": "https://github.com/rust-lang/rust/commit/621d7e959b24ea8640584f0ced13ec016be35d16"}], "stats": {"total": 1619, "additions": 1160, "deletions": 459}, "files": [{"sha": "18d58d9d19e2c0ba9e512e8d8dc7594b6d1a3a93", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -116,6 +116,7 @@ E0211: include_str!(\"./error_codes/E0211.md\"),\n E0214: include_str!(\"./error_codes/E0214.md\"),\n E0220: include_str!(\"./error_codes/E0220.md\"),\n E0221: include_str!(\"./error_codes/E0221.md\"),\n+E0222: include_str!(\"./error_codes/E0222.md\"),\n E0223: include_str!(\"./error_codes/E0223.md\"),\n E0225: include_str!(\"./error_codes/E0225.md\"),\n E0229: include_str!(\"./error_codes/E0229.md\"),\n@@ -457,8 +458,6 @@ E0745: include_str!(\"./error_codes/E0745.md\"),\n //  E0217, // ambiguous associated type, defined in multiple supertraits\n //  E0218, // no associated type defined\n //  E0219, // associated type defined in higher-ranked supertrait\n-//  E0222, // Error code E0045 (variadic function must have C or cdecl calling\n-           // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n     E0226, // only a single explicit lifetime bound is permitted\n     E0227, // ambiguous lifetime bound, explicit lifetime bound required"}, {"sha": "66b6c4d712b70df473e1bfe6b425fdca3e77f070", "filename": "src/librustc_error_codes/error_codes/E0222.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0222.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_error_codes%2Ferror_codes%2FE0222.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0222.md?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -0,0 +1,51 @@\n+An attempt was made to constrain an associated type.\n+For example:\n+\n+```compile_fail,E0222\n+pub trait Vehicle {\n+    type Color;\n+}\n+\n+pub trait Box {\n+    type Color;\n+}\n+\n+pub trait BoxCar : Box + Vehicle {}\n+\n+fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {} // Invalid constraint\n+```\n+\n+In this example, `BoxCar` has two super-traits: `Vehicle` and `Box`. Both of\n+these traits define an associated type `Color`. `BoxCar` inherits two types\n+with that name from both super-traits. Because of this, we need to use the\n+fully qualified path syntax to refer to the appropriate `Color` associated\n+type, either `<BoxCar as Vehicle>::Color` or `<BoxCar as Box>::Color`, but this\n+syntax is not allowed to be used in a function signature.\n+\n+In order to encode this kind of constraint, a `where` clause and a new type\n+parameter are needed:\n+\n+```\n+pub trait Vehicle {\n+    type Color;\n+}\n+\n+pub trait Box {\n+    type Color;\n+}\n+\n+pub trait BoxCar : Box + Vehicle {}\n+\n+// Introduce a new `CAR` type parameter\n+fn foo<CAR, COLOR>(\n+    c: CAR,\n+) where\n+    // Bind the type parameter `CAR` to the trait `BoxCar`\n+    CAR: BoxCar,\n+    // Further restrict `<BoxCar as Vehicle>::Color` to be the same as the\n+    // type parameter `COLOR`\n+    CAR: Vehicle<Color = COLOR>,\n+    // We can also simultaneously restrict the other trait's associated type\n+    CAR: Box<Color = COLOR>\n+{}\n+```"}, {"sha": "d89db403b15f75d7b3ab8a2e3b2f5098773f1832", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -804,6 +804,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         predicate.span,\n                         \"equality constraints are not yet supported in `where` clauses\",\n                     )\n+                    .span_label(predicate.span, \"not supported\")\n                     .note(\n                         \"for more information, see https://github.com/rust-lang/rust/issues/20041\",\n                     )"}, {"sha": "d28af783c0b25335724c8efc4e1bcd9f9393bb60", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 480, "deletions": 157, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -4,9 +4,9 @@\n \n use crate::hir::def::{CtorOf, DefKind, Res};\n use crate::hir::def_id::DefId;\n+use crate::hir::print;\n use crate::hir::ptr::P;\n-use crate::hir::HirVec;\n-use crate::hir::{self, ExprKind, GenericArg, GenericArgs};\n+use crate::hir::{self, ExprKind, GenericArg, GenericArgs, HirVec};\n use crate::lint;\n use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n@@ -473,7 +473,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Option<Ty<'tcx>>,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs>, bool),\n         provided_kind: impl Fn(&GenericParamDef, &GenericArg) -> subst::GenericArg<'tcx>,\n-        inferred_kind: impl Fn(\n+        mut inferred_kind: impl FnMut(\n             Option<&[subst::GenericArg<'tcx>]>,\n             &GenericParamDef,\n             bool,\n@@ -674,6 +674,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             false\n         };\n \n+        let mut missing_type_params = vec![];\n         let substs = Self::create_substs_for_generic_args(\n             tcx,\n             def_id,\n@@ -709,19 +710,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             // defaults. This will lead to an ICE if we are not\n                             // careful!\n                             if default_needs_object_self(param) {\n-                                struct_span_err!(\n-                                    tcx.sess,\n-                                    span,\n-                                    E0393,\n-                                    \"the type parameter `{}` must be explicitly specified\",\n-                                    param.name\n-                                )\n-                                .span_label(span, format!(\"missing reference to `{}`\", param.name))\n-                                .note(&format!(\n-                                    \"because of the default `Self` reference, type parameters \\\n-                                         must be specified on object types\"\n-                                ))\n-                                .emit();\n+                                missing_type_params.push(param.name.to_string());\n                                 tcx.types.err.into()\n                             } else {\n                                 // This is a default type parameter.\n@@ -760,6 +749,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             },\n         );\n \n+        self.complain_about_missing_type_params(\n+            missing_type_params,\n+            def_id,\n+            span,\n+            generic_args.args.is_empty(),\n+        );\n+\n         // Convert associated-type bindings or constraints into a separate vector.\n         // Example: Given this:\n         //\n@@ -818,6 +814,79 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    /// On missing type parameters, emit an E0393 error and provide a structured suggestion using\n+    /// the type parameter's name as a placeholder.\n+    fn complain_about_missing_type_params(\n+        &self,\n+        missing_type_params: Vec<String>,\n+        def_id: DefId,\n+        span: Span,\n+        empty_generic_args: bool,\n+    ) {\n+        if missing_type_params.is_empty() {\n+            return;\n+        }\n+        let display =\n+            missing_type_params.iter().map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            span,\n+            E0393,\n+            \"the type parameter{} {} must be explicitly specified\",\n+            pluralize!(missing_type_params.len()),\n+            display,\n+        );\n+        err.span_label(\n+            self.tcx().def_span(def_id),\n+            &format!(\n+                \"type parameter{} {} must be specified for this\",\n+                pluralize!(missing_type_params.len()),\n+                display,\n+            ),\n+        );\n+        let mut suggested = false;\n+        if let (Ok(snippet), true) = (\n+            self.tcx().sess.source_map().span_to_snippet(span),\n+            // Don't suggest setting the type params if there are some already: the order is\n+            // tricky to get right and the user will already know what the syntax is.\n+            empty_generic_args,\n+        ) {\n+            if snippet.ends_with('>') {\n+                // The user wrote `Trait<'a, T>` or similar. To provide an accurate suggestion\n+                // we would have to preserve the right order. For now, as clearly the user is\n+                // aware of the syntax, we do nothing.\n+            } else {\n+                // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                // least we can clue them to the correct syntax `Iterator<Type>`.\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"set the type parameter{plural} to the desired type{plural}\",\n+                        plural = pluralize!(missing_type_params.len()),\n+                    ),\n+                    format!(\"{}<{}>\", snippet, missing_type_params.join(\", \")),\n+                    Applicability::HasPlaceholders,\n+                );\n+                suggested = true;\n+            }\n+        }\n+        if !suggested {\n+            err.span_label(\n+                span,\n+                format!(\n+                    \"missing reference{} to {}\",\n+                    pluralize!(missing_type_params.len()),\n+                    display,\n+                ),\n+            );\n+        }\n+        err.note(&format!(\n+            \"because of the default `Self` reference, type parameters must be \\\n+                            specified on object types\"\n+        ));\n+        err.emit();\n+    }\n+\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the `DefId` of the defining trait.\n     /// The type _cannot_ be a type other than a trait type.\n@@ -854,8 +923,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n+        let path_span = if let [segment] = &trait_ref.path.segments[..] {\n+            // FIXME: `trait_ref.path.span` can point to a full path with multiple\n+            // segments, even though `trait_ref.path.segments` is of length `1`. Work\n+            // around that bug here, even though it should be fixed elsewhere.\n+            // This would otherwise cause an invalid suggestion. For an example, look at\n+            // `src/test/ui/issues/issue-28344.rs`.\n+            segment.ident.span\n+        } else {\n+            trait_ref.path.span\n+        };\n         let (substs, assoc_bindings, potential_assoc_types) = self.create_substs_for_ast_trait_ref(\n-            trait_ref.path.span,\n+            path_span,\n             trait_def_id,\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n@@ -874,6 +953,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 bounds,\n                 speculative,\n                 &mut dup_bindings,\n+                span,\n             );\n             // Okay to ignore `Err` because of `ErrorReported` (see above).\n         }\n@@ -932,29 +1012,75 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n-    fn create_substs_for_ast_trait_ref<'a>(\n+    /// When the code is using the `Fn` traits directly, instead of the `Fn(A) -> B` syntax, emit\n+    /// an error and attempt to build a reasonable structured suggestion.\n+    fn complain_about_internal_fn_trait(\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n-        debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n-\n+    ) {\n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n         if !self.tcx().features().unboxed_closures\n             && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n         {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n-            let msg = if trait_def.paren_sugar {\n-                \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n-                 Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\"\n+            let (msg, sugg) = if trait_def.paren_sugar {\n+                (\n+                    \"the precise format of `Fn`-family traits' type parameters is subject to \\\n+                     change\",\n+                    Some(format!(\n+                        \"{}{} -> {}\",\n+                        trait_segment.ident,\n+                        trait_segment\n+                            .args\n+                            .as_ref()\n+                            .and_then(|args| args.args.get(0))\n+                            .and_then(|arg| match arg {\n+                                hir::GenericArg::Type(ty) => {\n+                                    Some(print::to_string(print::NO_ANN, |s| s.print_type(ty)))\n+                                }\n+                                _ => None,\n+                            })\n+                            .unwrap_or_else(|| \"()\".to_string()),\n+                        trait_segment\n+                            .generic_args()\n+                            .bindings\n+                            .iter()\n+                            .filter_map(|b| match (b.ident.as_str() == \"Output\", &b.kind) {\n+                                (true, hir::TypeBindingKind::Equality { ty }) => {\n+                                    Some(print::to_string(print::NO_ANN, |s| s.print_type(ty)))\n+                                }\n+                                _ => None,\n+                            })\n+                            .next()\n+                            .unwrap_or_else(|| \"()\".to_string()),\n+                    )),\n+                )\n             } else {\n-                \"parenthetical notation is only stable when used with `Fn`-family traits\"\n+                (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n             };\n-            feature_err(&self.tcx().sess.parse_sess, sym::unboxed_closures, span, msg).emit();\n+            let sess = &self.tcx().sess.parse_sess;\n+            let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n+            if let Some(sugg) = sugg {\n+                let msg = \"use parenthetical notation instead\";\n+                err.span_suggestion(span, msg, sugg, Applicability::MaybeIncorrect);\n+            }\n+            err.emit();\n         }\n+    }\n+\n+    fn create_substs_for_ast_trait_ref<'a>(\n+        &self,\n+        span: Span,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        trait_segment: &'a hir::PathSegment,\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Option<Vec<Span>>) {\n+        debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n+\n+        self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n \n         self.create_substs_for_ast_path(\n             span,\n@@ -1118,6 +1244,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n+        path_span: Span,\n     ) -> Result<(), ErrorReported> {\n         let tcx = self.tcx();\n \n@@ -1180,17 +1307,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let candidate =\n             if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n                 // Simple case: X is defined in the current trait.\n-                Ok(trait_ref)\n+                trait_ref\n             } else {\n                 // Otherwise, we have to walk through the supertraits to find\n                 // those that do.\n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, trait_ref),\n                     &trait_ref.print_only_trait_path().to_string(),\n                     binding.item_name,\n-                    binding.span,\n-                )\n-            }?;\n+                    path_span,\n+                    match binding.kind {\n+                        ConvertedBindingKind::Equality(ty) => Some(ty.to_string()),\n+                        _ => None,\n+                    },\n+                )?\n+            };\n \n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n@@ -1213,8 +1344,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         self.tcx().sess,\n                         binding.span,\n                         E0719,\n-                        \"the value of the associated type `{}` (from the trait `{}`) \\\n-                                      is already specified\",\n+                        \"the value of the associated type `{}` (from trait `{}`) \\\n+                         is already specified\",\n                         binding.item_name,\n                         tcx.def_path_str(assoc_ty.container.id())\n                     )\n@@ -1326,121 +1457,71 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         // Use a `BTreeSet` to keep output in a more consistent order.\n-        let mut associated_types = BTreeSet::default();\n+        let mut associated_types: FxHashMap<Span, BTreeSet<DefId>> = FxHashMap::default();\n \n-        let regular_traits_refs = bounds\n+        let regular_traits_refs_spans = bounds\n             .trait_bounds\n             .into_iter()\n-            .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()))\n-            .map(|(trait_ref, _)| trait_ref);\n-        for trait_ref in traits::elaborate_trait_refs(tcx, regular_traits_refs) {\n-            debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", trait_ref);\n-            match trait_ref {\n-                ty::Predicate::Trait(pred) => {\n-                    associated_types.extend(\n-                        tcx.associated_items(pred.def_id())\n-                            .filter(|item| item.kind == ty::AssocKind::Type)\n-                            .map(|item| item.def_id),\n-                    );\n-                }\n-                ty::Predicate::Projection(pred) => {\n-                    // A `Self` within the original bound will be substituted with a\n-                    // `trait_object_dummy_self`, so check for that.\n-                    let references_self = pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n-\n-                    // If the projection output contains `Self`, force the user to\n-                    // elaborate it explicitly to avoid a lot of complexity.\n-                    //\n-                    // The \"classicaly useful\" case is the following:\n-                    // ```\n-                    //     trait MyTrait: FnMut() -> <Self as MyTrait>::MyOutput {\n-                    //         type MyOutput;\n-                    //     }\n-                    // ```\n-                    //\n-                    // Here, the user could theoretically write `dyn MyTrait<Output = X>`,\n-                    // but actually supporting that would \"expand\" to an infinitely-long type\n-                    // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput = X, Output = <\u03c4 as MyTrait>::MyOutput`.\n-                    //\n-                    // Instead, we force the user to write `dyn MyTrait<MyOutput = X, Output = X>`,\n-                    // which is uglier but works. See the discussion in #56288 for alternatives.\n-                    if !references_self {\n-                        // Include projections defined on supertraits.\n-                        bounds.projection_bounds.push((pred, DUMMY_SP))\n+            .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()));\n+\n+        for (base_trait_ref, span) in regular_traits_refs_spans {\n+            for trait_ref in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+                debug!(\n+                    \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n+                    trait_ref\n+                );\n+                match trait_ref {\n+                    ty::Predicate::Trait(pred) => {\n+                        associated_types.entry(span).or_default().extend(\n+                            tcx.associated_items(pred.def_id())\n+                                .filter(|item| item.kind == ty::AssocKind::Type)\n+                                .map(|item| item.def_id),\n+                        );\n                     }\n+                    ty::Predicate::Projection(pred) => {\n+                        // A `Self` within the original bound will be substituted with a\n+                        // `trait_object_dummy_self`, so check for that.\n+                        let references_self = pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n+\n+                        // If the projection output contains `Self`, force the user to\n+                        // elaborate it explicitly to avoid a lot of complexity.\n+                        //\n+                        // The \"classicaly useful\" case is the following:\n+                        // ```\n+                        //     trait MyTrait: FnMut() -> <Self as MyTrait>::MyOutput {\n+                        //         type MyOutput;\n+                        //     }\n+                        // ```\n+                        //\n+                        // Here, the user could theoretically write `dyn MyTrait<Output = X>`,\n+                        // but actually supporting that would \"expand\" to an infinitely-long type\n+                        // `fix $ \u03c4 \u2192 dyn MyTrait<MyOutput = X, Output = <\u03c4 as MyTrait>::MyOutput`.\n+                        //\n+                        // Instead, we force the user to write\n+                        // `dyn MyTrait<MyOutput = X, Output = X>`, which is uglier but works. See\n+                        // the discussion in #56288 for alternatives.\n+                        if !references_self {\n+                            // Include projections defined on supertraits.\n+                            bounds.projection_bounds.push((pred, span));\n+                        }\n+                    }\n+                    _ => (),\n                 }\n-                _ => (),\n             }\n         }\n \n         for (projection_bound, _) in &bounds.projection_bounds {\n-            associated_types.remove(&projection_bound.projection_def_id());\n-        }\n-\n-        if !associated_types.is_empty() {\n-            let names = associated_types\n-                .iter()\n-                .map(|item_def_id| {\n-                    let assoc_item = tcx.associated_item(*item_def_id);\n-                    let trait_def_id = assoc_item.container.id();\n-                    format!(\n-                        \"`{}` (from the trait `{}`)\",\n-                        assoc_item.ident,\n-                        tcx.def_path_str(trait_def_id),\n-                    )\n-                })\n-                .collect::<Vec<_>>()\n-                .join(\", \");\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0191,\n-                \"the value of the associated type{} {} must be specified\",\n-                pluralize!(associated_types.len()),\n-                names,\n-            );\n-            let (suggest, potential_assoc_types_spans) =\n-                if potential_assoc_types.len() == associated_types.len() {\n-                    // Only suggest when the amount of missing associated types equals the number of\n-                    // extra type arguments present, as that gives us a relatively high confidence\n-                    // that the user forgot to give the associtated type's name. The canonical\n-                    // example would be trying to use `Iterator<isize>` instead of\n-                    // `Iterator<Item = isize>`.\n-                    (true, potential_assoc_types)\n-                } else {\n-                    (false, Vec::new())\n-                };\n-            let mut suggestions = Vec::new();\n-            for (i, item_def_id) in associated_types.iter().enumerate() {\n-                let assoc_item = tcx.associated_item(*item_def_id);\n-                err.span_label(\n-                    span,\n-                    format!(\"associated type `{}` must be specified\", assoc_item.ident),\n-                );\n-                if let Some(sp) = tcx.hir().span_if_local(*item_def_id) {\n-                    err.span_label(sp, format!(\"`{}` defined here\", assoc_item.ident));\n-                }\n-                if suggest {\n-                    if let Ok(snippet) =\n-                        tcx.sess.source_map().span_to_snippet(potential_assoc_types_spans[i])\n-                    {\n-                        suggestions.push((\n-                            potential_assoc_types_spans[i],\n-                            format!(\"{} = {}\", assoc_item.ident, snippet),\n-                        ));\n-                    }\n-                }\n-            }\n-            if !suggestions.is_empty() {\n-                let msg = format!(\n-                    \"if you meant to specify the associated {}, write\",\n-                    if suggestions.len() == 1 { \"type\" } else { \"types\" }\n-                );\n-                err.multipart_suggestion(&msg, suggestions, Applicability::MaybeIncorrect);\n+            for (_, def_ids) in &mut associated_types {\n+                def_ids.remove(&projection_bound.projection_def_id());\n             }\n-            err.emit();\n         }\n \n+        self.complain_about_missing_associated_types(\n+            associated_types,\n+            potential_assoc_types,\n+            trait_bounds,\n+        );\n+\n         // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n         // `dyn Trait + Send`.\n         auto_traits.sort_by_key(|i| i.trait_ref().def_id());\n@@ -1528,6 +1609,198 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ty\n     }\n \n+    /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n+    /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n+    /// same trait bound have the same name (as they come from different super-traits), we instead\n+    /// emit a generic note suggesting using a `where` clause to constraint instead.\n+    fn complain_about_missing_associated_types(\n+        &self,\n+        associated_types: FxHashMap<Span, BTreeSet<DefId>>,\n+        potential_assoc_types: Vec<Span>,\n+        trait_bounds: &[hir::PolyTraitRef],\n+    ) {\n+        if !associated_types.values().any(|v| v.len() > 0) {\n+            return;\n+        }\n+        let tcx = self.tcx();\n+        // FIXME: Marked `mut` so that we can replace the spans further below with a more\n+        // appropriate one, but this should be handled earlier in the span assignment.\n+        let mut associated_types: FxHashMap<Span, Vec<_>> = associated_types\n+            .into_iter()\n+            .map(|(span, def_ids)| {\n+                (span, def_ids.into_iter().map(|did| tcx.associated_item(did)).collect())\n+            })\n+            .collect();\n+        let mut names = vec![];\n+\n+        // Account for things like `dyn Foo + 'a`, like in tests `issue-22434.rs` and\n+        // `issue-22560.rs`.\n+        let mut trait_bound_spans: Vec<Span> = vec![];\n+        for (span, items) in &associated_types {\n+            if !items.is_empty() {\n+                trait_bound_spans.push(*span);\n+            }\n+            for assoc_item in items {\n+                let trait_def_id = assoc_item.container.id();\n+                names.push(format!(\n+                    \"`{}` (from trait `{}`)\",\n+                    assoc_item.ident,\n+                    tcx.def_path_str(trait_def_id),\n+                ));\n+            }\n+        }\n+\n+        match (&potential_assoc_types[..], &trait_bounds) {\n+            ([], [bound]) => match &bound.trait_ref.path.segments[..] {\n+                // FIXME: `trait_ref.path.span` can point to a full path with multiple\n+                // segments, even though `trait_ref.path.segments` is of length `1`. Work\n+                // around that bug here, even though it should be fixed elsewhere.\n+                // This would otherwise cause an invalid suggestion. For an example, look at\n+                // `src/test/ui/issues/issue-28344.rs` where instead of the following:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^ help: specify the associated type:\n+                //    |                              `BitXor<Output = Type>`\n+                //\n+                // we would output:\n+                //\n+                //   error[E0191]: the value of the associated type `Output`\n+                //                 (from trait `std::ops::BitXor`) must be specified\n+                //   --> $DIR/issue-28344.rs:4:17\n+                //    |\n+                // LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n+                //    |                 ^^^^^^^^^^^^^ help: specify the associated type:\n+                //    |                                     `BitXor::bitor<Output = Type>`\n+                [segment] if segment.args.is_none() => {\n+                    trait_bound_spans = vec![segment.ident.span];\n+                    associated_types = associated_types\n+                        .into_iter()\n+                        .map(|(_, items)| (segment.ident.span, items))\n+                        .collect();\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+        names.sort();\n+        trait_bound_spans.sort();\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            trait_bound_spans,\n+            E0191,\n+            \"the value of the associated type{} {} must be specified\",\n+            pluralize!(names.len()),\n+            names.join(\", \"),\n+        );\n+        let mut suggestions = vec![];\n+        let mut types_count = 0;\n+        let mut where_constraints = vec![];\n+        for (span, assoc_items) in &associated_types {\n+            let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+            for item in assoc_items {\n+                types_count += 1;\n+                *names.entry(item.ident.name).or_insert(0) += 1;\n+            }\n+            let mut dupes = false;\n+            for item in assoc_items {\n+                let prefix = if names[&item.ident.name] > 1 {\n+                    let trait_def_id = item.container.id();\n+                    dupes = true;\n+                    format!(\"{}::\", tcx.def_path_str(trait_def_id))\n+                } else {\n+                    String::new()\n+                };\n+                if let Some(sp) = tcx.hir().span_if_local(item.def_id) {\n+                    err.span_label(sp, format!(\"`{}{}` defined here\", prefix, item.ident));\n+                }\n+            }\n+            if potential_assoc_types.len() == assoc_items.len() {\n+                // Only suggest when the amount of missing associated types equals the number of\n+                // extra type arguments present, as that gives us a relatively high confidence\n+                // that the user forgot to give the associtated type's name. The canonical\n+                // example would be trying to use `Iterator<isize>` instead of\n+                // `Iterator<Item = isize>`.\n+                for (potential, item) in potential_assoc_types.iter().zip(assoc_items.iter()) {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(*potential) {\n+                        suggestions.push((*potential, format!(\"{} = {}\", item.ident, snippet)));\n+                    }\n+                }\n+            } else if let (Ok(snippet), false) =\n+                (tcx.sess.source_map().span_to_snippet(*span), dupes)\n+            {\n+                let types: Vec<_> =\n+                    assoc_items.iter().map(|item| format!(\"{} = Type\", item.ident)).collect();\n+                let code = if snippet.ends_with(\">\") {\n+                    // The user wrote `Trait<'a>` or similar and we don't have a type we can\n+                    // suggest, but at least we can clue them to the correct syntax\n+                    // `Trait<'a, Item = Type>` while accounting for the `<'a>` in the\n+                    // suggestion.\n+                    format!(\"{}, {}>\", &snippet[..snippet.len() - 1], types.join(\", \"))\n+                } else {\n+                    // The user wrote `Iterator`, so we don't have a type we can suggest, but at\n+                    // least we can clue them to the correct syntax `Iterator<Item = Type>`.\n+                    format!(\"{}<{}>\", snippet, types.join(\", \"))\n+                };\n+                suggestions.push((*span, code));\n+            } else if dupes {\n+                where_constraints.push(*span);\n+            }\n+        }\n+        let where_msg = \"consider introducing a new type parameter, adding `where` constraints \\\n+                         using the fully-qualified path to the associated types\";\n+        if !where_constraints.is_empty() && suggestions.is_empty() {\n+            // If there are duplicates associated type names and a single trait bound do not\n+            // use structured suggestion, it means that there are multiple super-traits with\n+            // the same associated type name.\n+            err.help(where_msg);\n+        }\n+        if suggestions.len() != 1 {\n+            // We don't need this label if there's an inline suggestion, show otherwise.\n+            for (span, assoc_items) in &associated_types {\n+                let mut names: FxHashMap<_, usize> = FxHashMap::default();\n+                for item in assoc_items {\n+                    types_count += 1;\n+                    *names.entry(item.ident.name).or_insert(0) += 1;\n+                }\n+                let mut label = vec![];\n+                for item in assoc_items {\n+                    let postfix = if names[&item.ident.name] > 1 {\n+                        let trait_def_id = item.container.id();\n+                        format!(\" (from trait `{}`)\", tcx.def_path_str(trait_def_id))\n+                    } else {\n+                        String::new()\n+                    };\n+                    label.push(format!(\"`{}`{}\", item.ident, postfix));\n+                }\n+                if !label.is_empty() {\n+                    err.span_label(\n+                        *span,\n+                        format!(\n+                            \"associated type{} {} must be specified\",\n+                            pluralize!(label.len()),\n+                            label.join(\", \"),\n+                        ),\n+                    );\n+                }\n+            }\n+        }\n+        if !suggestions.is_empty() {\n+            err.multipart_suggestion(\n+                &format!(\"specify the associated type{}\", pluralize!(types_count)),\n+                suggestions,\n+                Applicability::HasPlaceholders,\n+            );\n+            if !where_constraints.is_empty() {\n+                err.span_help(where_constraints, where_msg);\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn report_ambiguous_associated_type(\n         &self,\n         span: Span,\n@@ -1590,15 +1863,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &param_name.as_str(),\n             assoc_name,\n             span,\n+            None,\n         )\n     }\n \n+    // Checks that `bounds` contains exactly one element and reports appropriate\n+    // errors otherwise.\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n         ty_param_name: &str,\n         assoc_name: ast::Ident,\n         span: Span,\n+        is_equality: Option<String>,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n@@ -1625,16 +1902,29 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n \n             let bounds = iter::once(bound).chain(iter::once(bound2)).chain(matching_candidates);\n-            let mut err = struct_span_err!(\n-                self.tcx().sess,\n-                span,\n-                E0221,\n-                \"ambiguous associated type `{}` in bounds of `{}`\",\n-                assoc_name,\n-                ty_param_name\n-            );\n+            let mut err = if is_equality.is_some() {\n+                // More specific Error Index entry.\n+                struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0222,\n+                    \"ambiguous associated type `{}` in bounds of `{}`\",\n+                    assoc_name,\n+                    ty_param_name\n+                )\n+            } else {\n+                struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0221,\n+                    \"ambiguous associated type `{}` in bounds of `{}`\",\n+                    assoc_name,\n+                    ty_param_name\n+                )\n+            };\n             err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n \n+            let mut where_bounds = vec![];\n             for bound in bounds {\n                 let bound_span = self\n                     .tcx()\n@@ -1645,28 +1935,56 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     })\n                     .and_then(|item| self.tcx().hir().span_if_local(item.def_id));\n \n-                if let Some(span) = bound_span {\n+                if let Some(bound_span) = bound_span {\n                     err.span_label(\n-                        span,\n+                        bound_span,\n                         format!(\n                             \"ambiguous `{}` from `{}`\",\n                             assoc_name,\n-                            bound.print_only_trait_path()\n+                            bound.print_only_trait_path(),\n                         ),\n                     );\n+                    if let Some(constraint) = &is_equality {\n+                        where_bounds.push(format!(\n+                            \"        T: {trait}::{assoc} = {constraint}\",\n+                            trait=bound.print_only_trait_path(),\n+                            assoc=assoc_name,\n+                            constraint=constraint,\n+                        ));\n+                    } else {\n+                        err.span_suggestion(\n+                            span,\n+                            \"use fully qualified syntax to disambiguate\",\n+                            format!(\n+                                \"<{} as {}>::{}\",\n+                                ty_param_name,\n+                                bound.print_only_trait_path(),\n+                                assoc_name,\n+                            ),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 } else {\n-                    span_note!(\n-                        &mut err,\n-                        span,\n+                    err.note(&format!(\n                         \"associated type `{}` could derive from `{}`\",\n                         ty_param_name,\n-                        bound.print_only_trait_path()\n-                    );\n+                        bound.print_only_trait_path(),\n+                    ));\n                 }\n             }\n+            if !where_bounds.is_empty() {\n+                err.help(&format!(\n+                    \"consider introducing a new type parameter `T` and adding `where` constraints:\\\n+                     \\n    where\\n        T: {},\\n{}\",\n+                    ty_param_name,\n+                    where_bounds.join(\",\\n\"),\n+                ));\n+            }\n             err.emit();\n+            if !where_bounds.is_empty() {\n+                return Err(ErrorReported);\n+            }\n         }\n-\n         return Ok(bound);\n     }\n \n@@ -1679,6 +1997,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     {\n+        // The fallback span is needed because `assoc_name` might be an `Fn()`'s `Output` without a\n+        // valid span, so we point at the whole path segment instead.\n+        let span = if assoc_name.span != DUMMY_SP { assoc_name.span } else { span };\n         let mut err = struct_span_err!(\n             self.tcx().sess,\n             span,\n@@ -1696,11 +2017,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             )\n             .collect();\n \n-        if let Some(suggested_name) =\n-            find_best_match_for_name(all_candidate_names.iter(), &assoc_name.as_str(), None)\n-        {\n+        if let (Some(suggested_name), true) = (\n+            find_best_match_for_name(all_candidate_names.iter(), &assoc_name.as_str(), None),\n+            assoc_name.span != DUMMY_SP,\n+        ) {\n             err.span_suggestion(\n-                span,\n+                assoc_name.span,\n                 \"there is an associated type with a similar name\",\n                 suggested_name.to_string(),\n                 Applicability::MaybeIncorrect,\n@@ -1771,6 +2093,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     \"Self\",\n                     assoc_ident,\n                     span,\n+                    None,\n                 )?\n             }\n             (&ty::Param(_), Res::SelfTy(Some(param_did), None))"}, {"sha": "483c205f42d6daa3a109942b1cd7e715cbcc5d3e", "filename": "src/test/compile-fail/issue-23595-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,12 +1,12 @@\n #![feature(associated_type_defaults)]\n \n-use std::ops::{Index};\n+use std::ops::Index;\n \n trait Hierarchy {\n     type Value;\n     type ChildKey;\n     type Children = dyn Index<Self::ChildKey, Output=dyn Hierarchy>;\n-    //~^ ERROR: the value of the associated types `Value` (from the trait `Hierarchy`), `ChildKey`\n+    //~^ ERROR: the value of the associated types\n \n     fn data(&self) -> Option<(Self::Value, Self::Children)>;\n }"}, {"sha": "64bc9eeec25293c91bc51f5042cb702ec0d8f886", "filename": "src/test/ui/associated-type-bounds/duplicate.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -9,175 +9,175 @@\n use std::iter;\n \n struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n \n trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS1: Iterator<Item: Copy, Item: Send> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n \n type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;\n-//~^ ERROR the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified [E0719]\n+//~^ ERROR the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified [E0719]\n //~| ERROR could not find defining uses\n //~| ERROR could not find defining uses\n "}, {"sha": "caecc5e85f6e7312763a263d53b852605dbd3c44", "filename": "src/test/ui/associated-type-bounds/duplicate.stderr", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fduplicate.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -6,359 +6,359 @@ LL | #![feature(impl_trait_in_bindings)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:11:36\n    |\n LL | struct SI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:13:36\n    |\n LL | struct SI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:15:39\n    |\n LL | struct SI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:17:45\n    |\n LL | struct SW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:19:45\n    |\n LL | struct SW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:21:48\n    |\n LL | struct SW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:24:34\n    |\n LL | enum EI1<T: Iterator<Item: Copy, Item: Send>> { V(T) }\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:26:34\n    |\n LL | enum EI2<T: Iterator<Item: Copy, Item: Copy>> { V(T) }\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:28:37\n    |\n LL | enum EI3<T: Iterator<Item: 'static, Item: 'static>> { V(T) }\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:30:43\n    |\n LL | enum EW1<T> where T: Iterator<Item: Copy, Item: Send> { V(T) }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:32:43\n    |\n LL | enum EW2<T> where T: Iterator<Item: Copy, Item: Copy> { V(T) }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:34:46\n    |\n LL | enum EW3<T> where T: Iterator<Item: 'static, Item: 'static> { V(T) }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:37:35\n    |\n LL | union UI1<T: Iterator<Item: Copy, Item: Send>> { f: T }\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:39:35\n    |\n LL | union UI2<T: Iterator<Item: Copy, Item: Copy>> { f: T }\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:41:38\n    |\n LL | union UI3<T: Iterator<Item: 'static, Item: 'static>> { f: T }\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:43:44\n    |\n LL | union UW1<T> where T: Iterator<Item: Copy, Item: Send> { f: T }\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:45:44\n    |\n LL | union UW2<T> where T: Iterator<Item: Copy, Item: Copy> { f: T }\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:47:47\n    |\n LL | union UW3<T> where T: Iterator<Item: 'static, Item: 'static> { f: T }\n    |                                -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:50:32\n    |\n LL | fn FI1<T: Iterator<Item: Copy, Item: Send>>() {}\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:52:32\n    |\n LL | fn FI2<T: Iterator<Item: Copy, Item: Copy>>() {}\n    |                    ----------  ^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:54:35\n    |\n LL | fn FI3<T: Iterator<Item: 'static, Item: 'static>>() {}\n    |                    -------------  ^^^^^^^^^^^^^ re-bound here\n    |                    |\n    |                    `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:56:43\n    |\n LL | fn FW1<T>() where T: Iterator<Item: Copy, Item: Send> {}\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:58:43\n    |\n LL | fn FW2<T>() where T: Iterator<Item: Copy, Item: Copy> {}\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:60:46\n    |\n LL | fn FW3<T>() where T: Iterator<Item: 'static, Item: 'static> {}\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:69:40\n    |\n LL | fn FAPIT1(_: impl Iterator<Item: Copy, Item: Send>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:71:40\n    |\n LL | fn FAPIT2(_: impl Iterator<Item: Copy, Item: Copy>) {}\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:73:43\n    |\n LL | fn FAPIT3(_: impl Iterator<Item: 'static, Item: 'static>) {}\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:63:42\n    |\n LL | fn FRPIT1() -> impl Iterator<Item: Copy, Item: Send> { iter::empty() }\n    |                              ----------  ^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:65:42\n    |\n LL | fn FRPIT2() -> impl Iterator<Item: Copy, Item: Copy> { iter::empty() }\n    |                              ----------  ^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:67:45\n    |\n LL | fn FRPIT3() -> impl Iterator<Item: 'static, Item: 'static> { iter::empty() }\n    |                              -------------  ^^^^^^^^^^^^^ re-bound here\n    |                              |\n    |                              `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:76:39\n    |\n LL | const CIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n    |                           ----------  ^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:78:39\n    |\n LL | const CIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n    |                           ----------  ^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:80:42\n    |\n LL | const CIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n    |                           -------------  ^^^^^^^^^^^^^ re-bound here\n    |                           |\n    |                           `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:82:40\n    |\n LL | static SIT1: impl Iterator<Item: Copy, Item: Send> = iter::empty();\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:84:40\n    |\n LL | static SIT2: impl Iterator<Item: Copy, Item: Copy> = iter::empty();\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:86:43\n    |\n LL | static SIT3: impl Iterator<Item: 'static, Item: 'static> = iter::empty();\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:89:46\n    |\n LL | fn lit1() { let _: impl Iterator<Item: Copy, Item: Send> = iter::empty(); }\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:91:46\n    |\n LL | fn lit2() { let _: impl Iterator<Item: Copy, Item: Copy> = iter::empty(); }\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:93:49\n    |\n LL | fn lit3() { let _: impl Iterator<Item: 'static, Item: 'static> = iter::empty(); }\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:96:35\n    |\n LL | type TAI1<T: Iterator<Item: Copy, Item: Send>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:98:35\n    |\n LL | type TAI2<T: Iterator<Item: Copy, Item: Copy>> = T;\n    |                       ----------  ^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:100:38\n    |\n LL | type TAI3<T: Iterator<Item: 'static, Item: 'static>> = T;\n    |                       -------------  ^^^^^^^^^^^^^ re-bound here\n    |                       |\n    |                       `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:102:44\n    |\n LL | type TAW1<T> where T: Iterator<Item: Copy, Item: Send> = T;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:104:44\n    |\n LL | type TAW2<T> where T: Iterator<Item: Copy, Item: Copy> = T;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:106:47\n    |\n LL | type TAW3<T> where T: Iterator<Item: 'static, Item: 'static> = T;\n@@ -372,7 +372,7 @@ error: could not find defining uses\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:109:36\n    |\n LL | type ETAI1<T: Iterator<Item: Copy, Item: Send>> = impl Copy;\n@@ -386,7 +386,7 @@ error: could not find defining uses\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:114:36\n    |\n LL | type ETAI2<T: Iterator<Item: Copy, Item: Copy>> = impl Copy;\n@@ -400,7 +400,7 @@ error: could not find defining uses\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:119:39\n    |\n LL | type ETAI3<T: Iterator<Item: 'static, Item: 'static>> = impl Copy;\n@@ -414,7 +414,7 @@ error: could not find defining uses\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:124:40\n    |\n LL | type ETAI4 = impl Iterator<Item: Copy, Item: Send>;\n@@ -428,7 +428,7 @@ error: could not find defining uses\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:129:40\n    |\n LL | type ETAI5 = impl Iterator<Item: Copy, Item: Copy>;\n@@ -442,151 +442,151 @@ error: could not find defining uses\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:134:43\n    |\n LL | type ETAI6 = impl Iterator<Item: 'static, Item: 'static>;\n    |                            -------------  ^^^^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:140:36\n    |\n LL | trait TRI1<T: Iterator<Item: Copy, Item: Send>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:142:36\n    |\n LL | trait TRI2<T: Iterator<Item: Copy, Item: Copy>> {}\n    |                        ----------  ^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:144:39\n    |\n LL | trait TRI3<T: Iterator<Item: 'static, Item: 'static>> {}\n    |                        -------------  ^^^^^^^^^^^^^ re-bound here\n    |                        |\n    |                        `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:146:34\n    |\n LL | trait TRS1: Iterator<Item: Copy, Item: Send> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:148:34\n    |\n LL | trait TRS2: Iterator<Item: Copy, Item: Copy> {}\n    |                      ----------  ^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:150:37\n    |\n LL | trait TRS3: Iterator<Item: 'static, Item: 'static> {}\n    |                      -------------  ^^^^^^^^^^^^^ re-bound here\n    |                      |\n    |                      `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:152:45\n    |\n LL | trait TRW1<T> where T: Iterator<Item: Copy, Item: Send> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:154:45\n    |\n LL | trait TRW2<T> where T: Iterator<Item: Copy, Item: Copy> {}\n    |                                 ----------  ^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:156:48\n    |\n LL | trait TRW3<T> where T: Iterator<Item: 'static, Item: 'static> {}\n    |                                 -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                 |\n    |                                 `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:158:46\n    |\n LL | trait TRSW1 where Self: Iterator<Item: Copy, Item: Send> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:160:46\n    |\n LL | trait TRSW2 where Self: Iterator<Item: Copy, Item: Copy> {}\n    |                                  ----------  ^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:162:49\n    |\n LL | trait TRSW3 where Self: Iterator<Item: 'static, Item: 'static> {}\n    |                                  -------------  ^^^^^^^^^^^^^ re-bound here\n    |                                  |\n    |                                  `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:164:43\n    |\n LL | trait TRA1 { type A: Iterator<Item: Copy, Item: Send>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:166:43\n    |\n LL | trait TRA2 { type A: Iterator<Item: Copy, Item: Copy>; }\n    |                               ----------  ^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:168:46\n    |\n LL | trait TRA3 { type A: Iterator<Item: 'static, Item: 'static>; }\n    |                               -------------  ^^^^^^^^^^^^^ re-bound here\n    |                               |\n    |                               `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:171:40\n    |\n LL | type TADyn1 = dyn Iterator<Item: Copy, Item: Send>;\n    |                            ----------  ^^^^^^^^^^ re-bound here\n    |                            |\n    |                            `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:175:44\n    |\n LL | type TADyn2 = Box<dyn Iterator<Item: Copy, Item: Copy>>;\n    |                                ----------  ^^^^^^^^^^ re-bound here\n    |                                |\n    |                                `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/duplicate.rs:179:43\n    |\n LL | type TADyn3 = dyn Iterator<Item: 'static, Item: 'static>;"}, {"sha": "6de8459954c681a8ae2bb93cc6e4445b1f79c6ae", "filename": "src/test/ui/associated-type/associated-type-projection-ambig-between-bound-and-where-clause.stderr", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-ambig-between-bound-and-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-ambig-between-bound-and-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-ambig-between-bound-and-where-clause.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -9,6 +9,15 @@ LL |     type Color;\n ...\n LL | fn a<C:Vehicle+Box>(_: C::Color) {\n    |                        ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn a<C:Vehicle+Box>(_: <C as Box>::Color) {\n+   |                        ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn a<C:Vehicle+Box>(_: <C as Vehicle>::Color) {\n+   |                        ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-ambig-between-bound-and-where-clause.rs:20:12\n@@ -21,6 +30,15 @@ LL |     type Color;\n ...\n LL | fn b<C>(_: C::Color) where C : Vehicle+Box {\n    |            ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn b<C>(_: <C as Box>::Color) where C : Vehicle+Box {\n+   |            ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn b<C>(_: <C as Vehicle>::Color) where C : Vehicle+Box {\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-ambig-between-bound-and-where-clause.rs:24:12\n@@ -33,6 +51,15 @@ LL |     type Color;\n ...\n LL | fn c<C>(_: C::Color) where C : Vehicle, C : Box {\n    |            ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn c<C>(_: <C as Box>::Color) where C : Vehicle, C : Box {\n+   |            ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn c<C>(_: <C as Vehicle>::Color) where C : Vehicle, C : Box {\n+   |            ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0221]: ambiguous associated type `Color` in bounds of `X`\n   --> $DIR/associated-type-projection-ambig-between-bound-and-where-clause.rs:35:20\n@@ -45,6 +72,15 @@ LL |     type Color;\n ...\n LL |     fn e(&self, _: X::Color) where X : Box;\n    |                    ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |     fn e(&self, _: <X as Box>::Color) where X : Box;\n+   |                    ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |     fn e(&self, _: <X as Vehicle>::Color) where X : Box;\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0221]: ambiguous associated type `Color` in bounds of `X`\n   --> $DIR/associated-type-projection-ambig-between-bound-and-where-clause.rs:38:20\n@@ -57,6 +93,15 @@ LL |     type Color;\n ...\n LL |     fn f(&self, _: X::Color) where X : Box { }\n    |                    ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |     fn f(&self, _: <X as Box>::Color) where X : Box { }\n+   |                    ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |     fn f(&self, _: <X as Vehicle>::Color) where X : Box { }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0221]: ambiguous associated type `Color` in bounds of `X`\n   --> $DIR/associated-type-projection-ambig-between-bound-and-where-clause.rs:30:20\n@@ -69,6 +114,15 @@ LL |     type Color;\n ...\n LL |     fn d(&self, _: X::Color) where X : Box { }\n    |                    ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |     fn d(&self, _: <X as Box>::Color) where X : Box { }\n+   |                    ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |     fn d(&self, _: <X as Vehicle>::Color) where X : Box { }\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 6 previous errors\n "}, {"sha": "df19332b6458ac49096ac9dabffafaa7ae88773c", "filename": "src/test/ui/associated-type/associated-type-projection-from-multiple-supertraits.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -22,11 +22,22 @@ fn dent<C:BoxCar>(c: C, color: C::Color) {\n \n fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n     //~^ ERROR ambiguous associated type\n-    //~| ERROR the value of the associated type `Color` (from the trait `Vehicle`) must be specified\n+    //~| ERROR the value of the associated types\n }\n \n fn paint<C:BoxCar>(c: C, d: C::Color) {\n     //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n }\n \n+fn dent_object_2<COLOR>(c: dyn BoxCar) where <dyn BoxCar as Vehicle>::Color = COLOR {\n+    //~^ ERROR the value of the associated types\n+    //~| ERROR equality constraints are not yet supported in `where` clauses\n+}\n+\n+fn dent_object_3<X, COLOR>(c: X)\n+where X: BoxCar,\n+    X: Vehicle<Color = COLOR>,\n+    X: Box<Color = COLOR>\n+{} // OK!\n+\n pub fn main() { }"}, {"sha": "c60d5f8f2c8b8bcc96e87b502091a66f73d788e6", "filename": "src/test/ui/associated-type/associated-type-projection-from-multiple-supertraits.stderr", "status": "modified", "additions": 60, "deletions": 9, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type%2Fassociated-type-projection-from-multiple-supertraits.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,3 +1,11 @@\n+error: equality constraints are not yet supported in `where` clauses\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:32:46\n+   |\n+LL | fn dent_object_2<COLOR>(c: dyn BoxCar) where <dyn BoxCar as Vehicle>::Color = COLOR {\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not supported\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n+\n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:19:32\n    |\n@@ -9,9 +17,18 @@ LL |     type Color;\n ...\n LL | fn dent<C:BoxCar>(c: C, color: C::Color) {\n    |                                ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn dent<C:BoxCar>(c: C, color: <C as Box>::Color) {\n+   |                                ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn dent<C:BoxCar>(c: C, color: <C as Vehicle>::Color) {\n+   |                                ^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0221]: ambiguous associated type `Color` in bounds of `BoxCar`\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:37\n+error[E0222]: ambiguous associated type `Color` in bounds of `BoxCar`\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:30\n    |\n LL |     type Color;\n    |     ----------- ambiguous `Color` from `Vehicle`\n@@ -20,16 +37,27 @@ LL |     type Color;\n    |     ----------- ambiguous `Color` from `Box`\n ...\n LL | fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n-   |                                     ^^^^^^^^^^^ ambiguous associated type `Color`\n+   |                              ^^^^^^^^^^^^^^^^^^^ ambiguous associated type `Color`\n+   |\n+   = help: consider introducing a new type parameter `T` and adding `where` constraints:\n+               where\n+                   T: BoxCar,\n+                   T: Box::Color = COLOR,\n+                   T: Vehicle::Color = COLOR\n \n-error[E0191]: the value of the associated type `Color` (from the trait `Vehicle`) must be specified\n-  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:26\n+error[E0191]: the value of the associated types `Color` (from trait `Box`), `Color` (from trait `Vehicle`) must be specified\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:23:30\n    |\n LL |     type Color;\n-   |     ----------- `Color` defined here\n+   |     ----------- `Vehicle::Color` defined here\n+...\n+LL |     type Color;\n+   |     ----------- `Box::Color` defined here\n ...\n LL | fn dent_object<COLOR>(c: dyn BoxCar<Color=COLOR>) {\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^ associated type `Color` must be specified\n+   |                              ^^^^^^^^^^^^^^^^^^^ associated types `Color` (from trait `Vehicle`), `Color` (from trait `Box`) must be specified\n+   |\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n \n error[E0221]: ambiguous associated type `Color` in bounds of `C`\n   --> $DIR/associated-type-projection-from-multiple-supertraits.rs:28:29\n@@ -42,8 +70,31 @@ LL |     type Color;\n ...\n LL | fn paint<C:BoxCar>(c: C, d: C::Color) {\n    |                             ^^^^^^^^ ambiguous associated type `Color`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn paint<C:BoxCar>(c: C, d: <C as Box>::Color) {\n+   |                             ^^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | fn paint<C:BoxCar>(c: C, d: <C as Vehicle>::Color) {\n+   |                             ^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0191]: the value of the associated types `Color` (from trait `Box`), `Color` (from trait `Vehicle`) must be specified\n+  --> $DIR/associated-type-projection-from-multiple-supertraits.rs:32:32\n+   |\n+LL |     type Color;\n+   |     ----------- `Vehicle::Color` defined here\n+...\n+LL |     type Color;\n+   |     ----------- `Box::Color` defined here\n+...\n+LL | fn dent_object_2<COLOR>(c: dyn BoxCar) where <dyn BoxCar as Vehicle>::Color = COLOR {\n+   |                                ^^^^^^ associated types `Color` (from trait `Vehicle`), `Color` (from trait `Box`) must be specified\n+   |\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0191, E0221.\n+Some errors have detailed explanations: E0191, E0221, E0222.\n For more information about an error, try `rustc --explain E0191`."}, {"sha": "4627dfd2b780822da2cee2682ca04318a955269f", "filename": "src/test/ui/associated-types/associated-types-incomplete-object.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -21,11 +21,11 @@ pub fn main() {\n     let a = &42isize as &dyn Foo<A=usize, B=char>;\n \n     let b = &42isize as &dyn Foo<A=usize>;\n-    //~^ ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n+    //~^ ERROR the value of the associated type `B` (from trait `Foo`) must be specified\n \n     let c = &42isize as &dyn Foo<B=char>;\n-    //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n+    //~^ ERROR the value of the associated type `A` (from trait `Foo`) must be specified\n \n     let d = &42isize as &dyn Foo;\n-    //~^ ERROR the value of the associated types `A` (from the trait `Foo`), `B` (from the trait\n+    //~^ ERROR the value of the associated types `A` (from trait `Foo`), `B` (from trait\n }"}, {"sha": "24732271c420f0932a79cd379dcd287035bcd714", "filename": "src/test/ui/associated-types/associated-types-incomplete-object.stderr", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-incomplete-object.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,34 +1,31 @@\n-error[E0191]: the value of the associated type `B` (from the trait `Foo`) must be specified\n-  --> $DIR/associated-types-incomplete-object.rs:23:26\n+error[E0191]: the value of the associated type `B` (from trait `Foo`) must be specified\n+  --> $DIR/associated-types-incomplete-object.rs:23:30\n    |\n LL |     type B;\n    |     ------- `B` defined here\n ...\n LL |     let b = &42isize as &dyn Foo<A=usize>;\n-   |                          ^^^^^^^^^^^^^^^^ associated type `B` must be specified\n+   |                              ^^^^^^^^^^^^ help: specify the associated type: `Foo<A=usize, B = Type>`\n \n-error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n-  --> $DIR/associated-types-incomplete-object.rs:26:26\n+error[E0191]: the value of the associated type `A` (from trait `Foo`) must be specified\n+  --> $DIR/associated-types-incomplete-object.rs:26:30\n    |\n LL |     type A;\n    |     ------- `A` defined here\n ...\n LL |     let c = &42isize as &dyn Foo<B=char>;\n-   |                          ^^^^^^^^^^^^^^^ associated type `A` must be specified\n+   |                              ^^^^^^^^^^^ help: specify the associated type: `Foo<B=char, A = Type>`\n \n-error[E0191]: the value of the associated types `A` (from the trait `Foo`), `B` (from the trait `Foo`) must be specified\n-  --> $DIR/associated-types-incomplete-object.rs:29:26\n+error[E0191]: the value of the associated types `A` (from trait `Foo`), `B` (from trait `Foo`) must be specified\n+  --> $DIR/associated-types-incomplete-object.rs:29:30\n    |\n LL |     type A;\n    |     ------- `A` defined here\n LL |     type B;\n    |     ------- `B` defined here\n ...\n LL |     let d = &42isize as &dyn Foo;\n-   |                          ^^^^^^^\n-   |                          |\n-   |                          associated type `A` must be specified\n-   |                          associated type `B` must be specified\n+   |                              ^^^ help: specify the associated types: `Foo<A = Type, B = Type>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "60db7749082e5c84e4590529ccb6ee9c4319ad73", "filename": "src/test/ui/associated-types/associated-types-path-1.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-1.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n error[E0220]: associated type `A` not found for `T`\n-  --> $DIR/associated-types-path-1.rs:10:23\n+  --> $DIR/associated-types-path-1.rs:10:26\n    |\n LL | pub fn f1<T>(a: T, x: T::A) {}\n-   |                       ^^^^ associated type `A` not found\n+   |                          ^ associated type `A` not found\n \n error[E0221]: ambiguous associated type `A` in bounds of `T`\n   --> $DIR/associated-types-path-1.rs:11:34\n@@ -15,6 +15,15 @@ LL |     type A;\n ...\n LL | pub fn f2<T: Foo + Bar>(a: T, x: T::A) {}\n    |                                  ^^^^ ambiguous associated type `A`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | pub fn f2<T: Foo + Bar>(a: T, x: <T as Bar>::A) {}\n+   |                                  ^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL | pub fn f2<T: Foo + Bar>(a: T, x: <T as Foo>::A) {}\n+   |                                  ^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3c8410e39bd09d3969f3bef7abdf0778ff1b2439", "filename": "src/test/ui/associated-types/missing-associated-types.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -0,0 +1,27 @@\n+use std::ops::{Add, Sub, Mul, Div};\n+trait X<Rhs>: Mul<Rhs> + Div<Rhs> {}\n+trait Y<Rhs>: Div<Rhs, Output = Rhs> {\n+    type A;\n+}\n+trait Z<Rhs>: Div<Rhs> {\n+    type A;\n+    type B;\n+}\n+trait Fine<Rhs>: Div<Rhs, Output = Rhs> {}\n+\n+type Foo<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Y<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Baz<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Y<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Bat<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Fine<Rhs>;\n+//~^ ERROR only auto traits can be used as additional traits in a trait object\n+//~| ERROR the value of the associated types\n+type Bal<Rhs> = dyn X<Rhs>;\n+//~^ ERROR the value of the associated types\n+\n+fn main() {}"}, {"sha": "f9951170acd665f2c88c90e20f1c93ed98805c72", "filename": "src/test/ui/associated-types/missing-associated-types.stderr", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fmissing-associated-types.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -0,0 +1,129 @@\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:12:32\n+   |\n+LL | type Foo<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Y<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `A` (from trait `Y`), `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Sub`) must be specified\n+  --> $DIR/missing-associated-types.rs:12:21\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n+LL | type Foo<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Y<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^   ^^^^^^   ^^^^^^ associated type `A` must be specified\n+   |                     |          |          |\n+   |                     |          |          associated type `Output` must be specified\n+   |                     |          associated type `Output` must be specified\n+   |                     associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Foo<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + X<Rhs, Output = Type> + Y<Rhs, A = Type>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:15:32\n+   |\n+LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `A` (from trait `Z`), `B` (from trait `Z`), `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Sub`) must be specified\n+  --> $DIR/missing-associated-types.rs:15:21\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+LL |     type B;\n+   |     ------- `B` defined here\n+...\n+LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^   ^^^^^^   ^^^^^^ associated types `A`, `B`, `Output` must be specified\n+   |                     |          |          |\n+   |                     |          |          associated types `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n+   |                     |          associated type `Output` must be specified\n+   |                     associated type `Output` must be specified\n+   |\n+help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n+  --> $DIR/missing-associated-types.rs:15:43\n+   |\n+LL | type Bar<Rhs> = dyn Add<Rhs> + Sub<Rhs> + X<Rhs> + Z<Rhs>;\n+   |                                           ^^^^^^\n+help: specify the associated types\n+   |\n+LL | type Bar<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + X<Rhs> + Z<Rhs, A = Type, B = Type, Output = Type>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:18:32\n+   |\n+LL | type Baz<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Y<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `A` (from trait `Y`), `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Sub`) must be specified\n+  --> $DIR/missing-associated-types.rs:18:21\n+   |\n+LL |     type A;\n+   |     ------- `A` defined here\n+...\n+LL | type Baz<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Y<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^   ^^^^^^ associated type `A` must be specified\n+   |                     |          |\n+   |                     |          associated type `Output` must be specified\n+   |                     associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Baz<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + Y<Rhs, A = Type>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^\n+\n+error[E0225]: only auto traits can be used as additional traits in a trait object\n+  --> $DIR/missing-associated-types.rs:21:32\n+   |\n+LL | type Bat<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Fine<Rhs>;\n+   |                     --------   ^^^^^^^^\n+   |                     |          |\n+   |                     |          additional non-auto trait\n+   |                     |          trait alias used in trait object type (additional use)\n+   |                     first non-auto trait\n+   |                     trait alias used in trait object type (first use)\n+\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Add`), `Output` (from trait `std::ops::Sub`) must be specified\n+  --> $DIR/missing-associated-types.rs:21:21\n+   |\n+LL | type Bat<Rhs> = dyn Add<Rhs> + Sub<Rhs> + Fine<Rhs>;\n+   |                     ^^^^^^^^   ^^^^^^^^ associated type `Output` must be specified\n+   |                     |\n+   |                     associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Bat<Rhs> = dyn Add<Rhs, Output = Type> + Sub<Rhs, Output = Type> + Fine<Rhs>;\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0191]: the value of the associated types `Output` (from trait `std::ops::Div`), `Output` (from trait `std::ops::Mul`) must be specified\n+  --> $DIR/missing-associated-types.rs:24:21\n+   |\n+LL | type Bal<Rhs> = dyn X<Rhs>;\n+   |                     ^^^^^^ associated types `Output` (from trait `std::ops::Mul`), `Output` (from trait `std::ops::Div`) must be specified\n+   |\n+   = help: consider introducing a new type parameter, adding `where` constraints using the fully-qualified path to the associated types\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0191, E0225.\n+For more information about an error, try `rustc --explain E0191`."}, {"sha": "d69a14916e1981df8641c543679335bc0d7a8238", "filename": "src/test/ui/error-codes/E0191.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0191.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,11 +1,11 @@\n-error[E0191]: the value of the associated type `Bar` (from the trait `Trait`) must be specified\n-  --> $DIR/E0191.rs:5:12\n+error[E0191]: the value of the associated type `Bar` (from trait `Trait`) must be specified\n+  --> $DIR/E0191.rs:5:16\n    |\n LL |     type Bar;\n    |     --------- `Bar` defined here\n ...\n LL | type Foo = dyn Trait;\n-   |            ^^^^^^^^^ associated type `Bar` must be specified\n+   |                ^^^^^ help: specify the associated type: `Trait<Bar = Type>`\n \n error: aborting due to previous error\n "}, {"sha": "4fa83d8bf6e82d1b91daebe6f0db7ed82161d85d", "filename": "src/test/ui/error-codes/E0220.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0220.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0220.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0220.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -2,16 +2,16 @@ error[E0220]: associated type `F` not found for `Trait`\n   --> $DIR/E0220.rs:5:22\n    |\n LL | type Foo = dyn Trait<F=i32>;\n-   |                      ^^^^^ associated type `F` not found\n+   |                      ^ associated type `F` not found\n \n-error[E0191]: the value of the associated type `Bar` (from the trait `Trait`) must be specified\n-  --> $DIR/E0220.rs:5:12\n+error[E0191]: the value of the associated type `Bar` (from trait `Trait`) must be specified\n+  --> $DIR/E0220.rs:5:16\n    |\n LL |     type Bar;\n    |     --------- `Bar` defined here\n ...\n LL | type Foo = dyn Trait<F=i32>;\n-   |            ^^^^^^^^^^^^^^^^ associated type `Bar` must be specified\n+   |                ^^^^^^^^^^^^ help: specify the associated type: `Trait<F=i32, Bar = Type>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0b4819143ceb618fa73c6bbc794f4cb9a76e9dfb", "filename": "src/test/ui/error-codes/E0221.stderr", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0221.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0221.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0221.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -9,21 +9,29 @@ LL |     type A: T2;\n LL |     fn do_something() {\n LL |         let _: Self::A;\n    |                ^^^^^^^ ambiguous associated type `A`\n+   |\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |         let _: <Self as Foo>::A;\n+   |                ^^^^^^^^^^^^^^^^\n+help: use fully qualified syntax to disambiguate\n+   |\n+LL |         let _: <Self as Bar>::A;\n+   |                ^^^^^^^^^^^^^^^^\n \n error[E0221]: ambiguous associated type `Err` in bounds of `Self`\n   --> $DIR/E0221.rs:21:16\n    |\n LL |     type Err: T3;\n    |     ------------- ambiguous `Err` from `My`\n LL |     fn test() {\n-LL |         let _: Self::Err;\n-   |                ^^^^^^^^^ ambiguous associated type `Err`\n-   |\n-note: associated type `Self` could derive from `std::str::FromStr`\n-  --> $DIR/E0221.rs:21:16\n-   |\n LL |         let _: Self::Err;\n    |                ^^^^^^^^^\n+   |                |\n+   |                ambiguous associated type `Err`\n+   |                help: use fully qualified syntax to disambiguate: `<Self as My>::Err`\n+   |\n+   = note: associated type `Self` could derive from `std::str::FromStr`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7771bacc9ed935874cb8e3877a118ae9dfed3b43", "filename": "src/test/ui/error-codes/E0393.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0393.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0393.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0393.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,11 @@\n error[E0393]: the type parameter `T` must be explicitly specified\n   --> $DIR/E0393.rs:3:47\n    |\n+LL | trait A<T=Self> {}\n+   | ------------------ type parameter `T` must be specified for this\n+LL | \n LL | fn together_we_will_rule_the_galaxy(son: &dyn A) {}\n-   |                                               ^ missing reference to `T`\n+   |                                               ^ help: set the type parameter to the desired type: `A<T>`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n "}, {"sha": "a046fbfc3d04a0fd4d0c930eafe66ed3d8ecd553", "filename": "src/test/ui/error-codes/E0719.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0719.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,12 +1,12 @@\n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/E0719.rs:1:33\n    |\n LL | trait Foo: Iterator<Item = i32, Item = i32> {}\n    |                     ----------  ^^^^^^^^^^ re-bound here\n    |                     |\n    |                     `Item` bound here first\n \n-error[E0719]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) is already specified\n+error[E0719]: the value of the associated type `Item` (from trait `std::iter::Iterator`) is already specified\n   --> $DIR/E0719.rs:6:42\n    |\n LL | fn test() -> Box<dyn Iterator<Item = (), Item = Unit>> {"}, {"sha": "4addd16649ea08b3efde09dbb16ceba00189cfeb", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures-manual-impls.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures-manual-impls.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -34,11 +34,11 @@ LL |     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:9:6\n    |\n LL | impl Fn<()> for Foo {\n-   |      ^^^^^^\n+   |      ^^^^^^ help: use parenthetical notation instead: `Fn() -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n@@ -49,20 +49,20 @@ error[E0229]: associated type bindings are not allowed here\n LL | impl FnOnce() for Foo1 {\n    |      ^^^^^^^^ associated type not allowed here\n \n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:21:6\n    |\n LL | impl FnMut<()> for Bar {\n-   |      ^^^^^^^^^\n+   |      ^^^^^^^^^ help: use parenthetical notation instead: `FnMut() -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/feature-gate-unboxed-closures-manual-impls.rs:27:6\n    |\n LL | impl FnOnce<()> for Baz {\n-   |      ^^^^^^^^^^\n+   |      ^^^^^^^^^^ help: use parenthetical notation instead: `FnOnce() -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "005ff06e6889897086ddb062635c92e5580bb1d2", "filename": "src/test/ui/feature-gates/feature-gate-unboxed-closures.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unboxed-closures.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -7,11 +7,11 @@ LL |     extern \"rust-call\" fn call_once(self, (a, b): (u32, u32)) -> u32 {\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/feature-gate-unboxed-closures.rs:5:6\n    |\n LL | impl FnOnce<(u32, u32)> for Test {\n-   |      ^^^^^^^^^^^^^^^^^^\n+   |      ^^^^^^^^^^^^^^^^^^ help: use parenthetical notation instead: `FnOnce(u32, u32) -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "3f3c5de9b1404282e1c8ac303eb68875c5f81c53", "filename": "src/test/ui/issues/issue-19482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-19482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-19482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19482.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -8,6 +8,6 @@ trait Foo {\n }\n \n fn bar(x: &dyn Foo) {}\n-//~^ ERROR the associated type `A` (from the trait `Foo`) must be specified\n+//~^ ERROR the associated type `A` (from trait `Foo`) must be specified\n \n pub fn main() {}"}, {"sha": "42a5a01596905102a519df0f9fa525ef17a12135", "filename": "src/test/ui/issues/issue-19482.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-19482.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-19482.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-19482.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,11 +1,11 @@\n-error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n-  --> $DIR/issue-19482.rs:10:12\n+error[E0191]: the value of the associated type `A` (from trait `Foo`) must be specified\n+  --> $DIR/issue-19482.rs:10:16\n    |\n LL |     type A;\n    |     ------- `A` defined here\n ...\n LL | fn bar(x: &dyn Foo) {}\n-   |            ^^^^^^^ associated type `A` must be specified\n+   |                ^^^ help: specify the associated type: `Foo<A = Type>`\n \n error: aborting due to previous error\n "}, {"sha": "72a98bd8ddd8a7ba9f9aefc8cbc86b4e82102e63", "filename": "src/test/ui/issues/issue-21950.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-21950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-21950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21950.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,13 @@\n-use std::ops::Add;\n+trait Add<Rhs=Self> {\n+    type Output;\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+}\n \n fn main() {\n-    let x = &10 as\n-            &dyn Add;\n-            //~^ ERROR E0393\n-            //~| ERROR E0191\n+    let x = &10 as &dyn Add;\n+    //~^ ERROR E0393\n+    //~| ERROR E0191\n }"}, {"sha": "93c2444f884de0bcea87ddbdd17c3e374f82c0e3", "filename": "src/test/ui/issues/issue-21950.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-21950.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-21950.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21950.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,16 +1,24 @@\n error[E0393]: the type parameter `Rhs` must be explicitly specified\n-  --> $DIR/issue-21950.rs:5:18\n+  --> $DIR/issue-21950.rs:10:25\n    |\n-LL |             &dyn Add;\n-   |                  ^^^ missing reference to `Rhs`\n+LL | / trait Add<Rhs=Self> {\n+LL | |     type Output;\n+LL | | }\n+   | |_- type parameter `Rhs` must be specified for this\n+...\n+LL |       let x = &10 as &dyn Add;\n+   |                           ^^^ help: set the type parameter to the desired type: `Add<Rhs>`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n \n-error[E0191]: the value of the associated type `Output` (from the trait `std::ops::Add`) must be specified\n-  --> $DIR/issue-21950.rs:5:14\n+error[E0191]: the value of the associated type `Output` (from trait `Add`) must be specified\n+  --> $DIR/issue-21950.rs:10:25\n    |\n-LL |             &dyn Add;\n-   |              ^^^^^^^ associated type `Output` must be specified\n+LL |     type Output;\n+   |     ------------ `Output` defined here\n+...\n+LL |     let x = &10 as &dyn Add;\n+   |                         ^^^ help: specify the associated type: `Add<Output = Type>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "950c12ef7a21c39aa48f1d70efc774091c795679", "filename": "src/test/ui/issues/issue-22370.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22370.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22370.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22370.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,11 @@\n error[E0393]: the type parameter `T` must be explicitly specified\n   --> $DIR/issue-22370.rs:3:14\n    |\n+LL | trait A<T=Self> {}\n+   | ------------------ type parameter `T` must be specified for this\n+LL | \n LL | fn f(a: &dyn A) {}\n-   |              ^ missing reference to `T`\n+   |              ^ help: set the type parameter to the desired type: `A<T>`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n "}, {"sha": "34057b46ecd4299844de3c20b64900824b54185c", "filename": "src/test/ui/issues/issue-22434.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22434.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22434.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22434.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -3,6 +3,6 @@ pub trait Foo {\n }\n \n type I<'a> = &'a (dyn Foo + 'a);\n-//~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n+//~^ ERROR the value of the associated type `A` (from trait `Foo`) must be specified\n \n fn main() {}"}, {"sha": "79b9d85610bcecd0908b15094227647fe74a7d73", "filename": "src/test/ui/issues/issue-22434.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22434.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22434.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22434.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,11 +1,11 @@\n-error[E0191]: the value of the associated type `A` (from the trait `Foo`) must be specified\n-  --> $DIR/issue-22434.rs:5:19\n+error[E0191]: the value of the associated type `A` (from trait `Foo`) must be specified\n+  --> $DIR/issue-22434.rs:5:23\n    |\n LL |     type A;\n    |     ------- `A` defined here\n ...\n LL | type I<'a> = &'a (dyn Foo + 'a);\n-   |                   ^^^^^^^^^^^^ associated type `A` must be specified\n+   |                       ^^^ help: specify the associated type: `Foo<A = Type>`\n \n error: aborting due to previous error\n "}, {"sha": "44be8817b08c7f4e85a512afbd601c16c9679802", "filename": "src/test/ui/issues/issue-22560.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22560.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,10 +1,15 @@\n-use std::ops::{Add, Sub};\n+trait Add<Rhs=Self> {\n+    type Output;\n+}\n \n-type Test = dyn Add +\n-            //~^ ERROR E0393\n-            //~| ERROR E0191\n-            Sub;\n-            //~^ ERROR E0393\n-            //~| ERROR E0225\n+trait Sub<Rhs=Self> {\n+    type Output;\n+}\n+\n+type Test = dyn Add + Sub;\n+//~^ ERROR E0393\n+//~| ERROR E0191\n+//~| ERROR E0393\n+//~| ERROR E0225\n \n fn main() { }"}, {"sha": "e5e50ddd1554ce459b8c1970ebbe31229b474be7", "filename": "src/test/ui/issues/issue-22560.stderr", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22560.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,48 +1,58 @@\n error[E0393]: the type parameter `Rhs` must be explicitly specified\n-  --> $DIR/issue-22560.rs:6:13\n+  --> $DIR/issue-22560.rs:9:23\n    |\n-LL |             Sub;\n-   |             ^^^ missing reference to `Rhs`\n+LL | / trait Sub<Rhs=Self> {\n+LL | |     type Output;\n+LL | | }\n+   | |_- type parameter `Rhs` must be specified for this\n+LL | \n+LL |   type Test = dyn Add + Sub;\n+   |                         ^^^ help: set the type parameter to the desired type: `Sub<Rhs>`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n \n error[E0393]: the type parameter `Rhs` must be explicitly specified\n-  --> $DIR/issue-22560.rs:3:17\n+  --> $DIR/issue-22560.rs:9:17\n    |\n-LL | type Test = dyn Add +\n-   |                 ^^^ missing reference to `Rhs`\n+LL | / trait Add<Rhs=Self> {\n+LL | |     type Output;\n+LL | | }\n+   | |_- type parameter `Rhs` must be specified for this\n+...\n+LL |   type Test = dyn Add + Sub;\n+   |                   ^^^ help: set the type parameter to the desired type: `Add<Rhs>`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n \n error[E0225]: only auto traits can be used as additional traits in a trait object\n-  --> $DIR/issue-22560.rs:6:13\n+  --> $DIR/issue-22560.rs:9:23\n    |\n-LL | type Test = dyn Add +\n-   |                 ---\n-   |                 |\n+LL | type Test = dyn Add + Sub;\n+   |                 ---   ^^^\n+   |                 |     |\n+   |                 |     additional non-auto trait\n+   |                 |     trait alias used in trait object type (additional use)\n    |                 first non-auto trait\n    |                 trait alias used in trait object type (first use)\n-...\n-LL |             Sub;\n-   |             ^^^\n-   |             |\n-   |             additional non-auto trait\n-   |             trait alias used in trait object type (additional use)\n \n-error[E0191]: the value of the associated types `Output` (from the trait `std::ops::Add`), `Output` (from the trait `std::ops::Sub`) must be specified\n-  --> $DIR/issue-22560.rs:3:13\n-   |\n-LL |   type Test = dyn Add +\n-   |  _____________^\n-   | |_____________|\n-   | |\n-LL | |\n-LL | |\n-LL | |             Sub;\n-   | |               ^\n-   | |_______________|\n-   | |_______________associated type `Output` must be specified\n+error[E0191]: the value of the associated types `Output` (from trait `Add`), `Output` (from trait `Sub`) must be specified\n+  --> $DIR/issue-22560.rs:9:17\n+   |\n+LL |     type Output;\n+   |     ------------ `Output` defined here\n+...\n+LL |     type Output;\n+   |     ------------ `Output` defined here\n+...\n+LL | type Test = dyn Add + Sub;\n+   |                 ^^^   ^^^ associated type `Output` must be specified\n+   |                 |\n    |                 associated type `Output` must be specified\n+   |\n+help: specify the associated types\n+   |\n+LL | type Test = dyn Add<Output = Type> + Sub<Output = Type>;\n+   |                 ^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "63675368162927c9298a9c3bbebff94004b9baac", "filename": "src/test/ui/issues/issue-23024.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-23024.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-23024.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23024.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -9,5 +9,5 @@ fn main()\n     println!(\"{:?}\",(vfnfer[0] as dyn Fn)(3));\n     //~^ ERROR the precise format of `Fn`-family traits'\n     //~| ERROR wrong number of type arguments: expected 1, found 0 [E0107]\n-    //~| ERROR the value of the associated type `Output` (from the trait `std::ops::FnOnce`)\n+    //~| ERROR the value of the associated type `Output` (from trait `std::ops::FnOnce`)\n }"}, {"sha": "1c6dd28ce539e69b9c33a75ff45b8e925cadc060", "filename": "src/test/ui/issues/issue-23024.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23024.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/issue-23024.rs:9:39\n    |\n LL |     println!(\"{:?}\",(vfnfer[0] as dyn Fn)(3));\n-   |                                       ^^\n+   |                                       ^^ help: use parenthetical notation instead: `Fn() -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n@@ -13,11 +13,11 @@ error[E0107]: wrong number of type arguments: expected 1, found 0\n LL |     println!(\"{:?}\",(vfnfer[0] as dyn Fn)(3));\n    |                                       ^^ expected 1 type argument\n \n-error[E0191]: the value of the associated type `Output` (from the trait `std::ops::FnOnce`) must be specified\n-  --> $DIR/issue-23024.rs:9:35\n+error[E0191]: the value of the associated type `Output` (from trait `std::ops::FnOnce`) must be specified\n+  --> $DIR/issue-23024.rs:9:39\n    |\n LL |     println!(\"{:?}\",(vfnfer[0] as dyn Fn)(3));\n-   |                                   ^^^^^^ associated type `Output` must be specified\n+   |                                       ^^ help: specify the associated type: `Fn<Output = Type>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "dded673f6eed6ef7dddb81bfa4e95f7ba63d5763", "filename": "src/test/ui/issues/issue-23595-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-23595-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-23595-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23595-2.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n error[E0220]: associated type `anything_here_kills_it` not found for `Self`\n-  --> $DIR/issue-23595-2.rs:6:16\n+  --> $DIR/issue-23595-2.rs:6:22\n    |\n LL |     type B = C<Self::anything_here_kills_it>;\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated type `anything_here_kills_it` not found\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ associated type `anything_here_kills_it` not found\n \n error: aborting due to previous error\n "}, {"sha": "e315317c98a6c7fb646be3d80a527b9796a31fd4", "filename": "src/test/ui/issues/issue-28344.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n-error[E0191]: the value of the associated type `Output` (from the trait `std::ops::BitXor`) must be specified\n+error[E0191]: the value of the associated type `Output` (from trait `std::ops::BitXor`) must be specified\n   --> $DIR/issue-28344.rs:4:17\n    |\n LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n-   |                 ^^^^^^^^^^^^^ associated type `Output` must be specified\n+   |                 ^^^^^^ help: specify the associated type: `BitXor<Output = Type>`\n \n error[E0599]: no function or associated item named `bitor` found for type `dyn std::ops::BitXor<_>` in the current scope\n   --> $DIR/issue-28344.rs:4:25\n@@ -13,11 +13,11 @@ LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n    |                         function or associated item not found in `dyn std::ops::BitXor<_>`\n    |                         help: there is a method with a similar name: `bitxor`\n \n-error[E0191]: the value of the associated type `Output` (from the trait `std::ops::BitXor`) must be specified\n+error[E0191]: the value of the associated type `Output` (from trait `std::ops::BitXor`) must be specified\n   --> $DIR/issue-28344.rs:8:13\n    |\n LL |     let g = BitXor::bitor;\n-   |             ^^^^^^^^^^^^^ associated type `Output` must be specified\n+   |             ^^^^^^ help: specify the associated type: `BitXor<Output = Type>`\n \n error[E0599]: no function or associated item named `bitor` found for type `dyn std::ops::BitXor<_>` in the current scope\n   --> $DIR/issue-28344.rs:8:21"}, {"sha": "c14c663e5a1a973c6ab45b5fff38e229c9caa81c", "filename": "src/test/ui/issues/issue-39211.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-39211.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-39211.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39211.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n error[E0220]: associated type `Row` not found for `M`\n-  --> $DIR/issue-39211.rs:11:17\n+  --> $DIR/issue-39211.rs:11:20\n    |\n LL |     let a = [3; M::Row::DIM];\n-   |                 ^^^^^^^^^^^ associated type `Row` not found\n+   |                    ^^^ associated type `Row` not found\n \n error: aborting due to previous error\n "}, {"sha": "fb1de9759c5cf5fca6f2224579c4f9f8dd6c9e62", "filename": "src/test/ui/issues/issue-59029-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59029-1.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n error[E0220]: associated type `Res` not found for `Self`\n-  --> $DIR/issue-59029-1.rs:5:46\n+  --> $DIR/issue-59029-1.rs:5:52\n    |\n LL | trait MkSvc<Target, Req> = Svc<Target> where Self::Res: Svc<Req>;\n-   |                                              ^^^^^^^^^ associated type `Res` not found\n+   |                                                    ^^^ associated type `Res` not found\n \n error: aborting due to previous error\n "}, {"sha": "f69899335539a3b1b066301a9df7457a5aa15c93", "filename": "src/test/ui/span/type-binding.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-binding.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -2,7 +2,7 @@ error[E0220]: associated type `Trget` not found for `std::ops::Deref`\n   --> $DIR/type-binding.rs:6:20\n    |\n LL | fn homura<T: Deref<Trget = i32>>(_: T) {}\n-   |                    ^^^^^^^^^^^ help: there is an associated type with a similar name: `Target`\n+   |                    ^^^^^ help: there is an associated type with a similar name: `Target`\n \n error: aborting due to previous error\n "}, {"sha": "58a73187fb158200c11fcef49972e343dcb610a9", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.stderr", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -6,8 +6,8 @@ LL |     i: Box<dyn T<usize, usize, usize, usize, B=usize>>,\n    |                                |\n    |                                unexpected type argument\n \n-error[E0191]: the value of the associated types `A` (from the trait `T`), `C` (from the trait `T`) must be specified\n-  --> $DIR/use-type-argument-instead-of-assoc-type.rs:7:12\n+error[E0191]: the value of the associated types `A` (from trait `T`), `C` (from trait `T`) must be specified\n+  --> $DIR/use-type-argument-instead-of-assoc-type.rs:7:16\n    |\n LL |     type A;\n    |     ------- `A` defined here\n@@ -16,12 +16,9 @@ LL |     type C;\n    |     ------- `C` defined here\n ...\n LL |     i: Box<dyn T<usize, usize, usize, usize, B=usize>>,\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |            |\n-   |            associated type `A` must be specified\n-   |            associated type `C` must be specified\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated types `A`, `C` must be specified\n    |\n-help: if you meant to specify the associated types, write\n+help: specify the associated types\n    |\n LL |     i: Box<dyn T<usize, usize, A = usize, C = usize, B=usize>>,\n    |                                ^^^^^^^^^  ^^^^^^^^^"}, {"sha": "5551b1303b927e35f07912b563ed6c0544e1244a", "filename": "src/test/ui/traits/trait-alias/trait-alias-object-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-object-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-object-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-object-fail.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -6,11 +6,11 @@ LL |     let _: &dyn EqAlias = &123;\n    |\n    = note: the trait cannot use `Self` as a type parameter in the supertraits or where-clauses\n \n-error[E0191]: the value of the associated type `Item` (from the trait `std::iter::Iterator`) must be specified\n-  --> $DIR/trait-alias-object-fail.rs:9:13\n+error[E0191]: the value of the associated type `Item` (from trait `std::iter::Iterator`) must be specified\n+  --> $DIR/trait-alias-object-fail.rs:9:17\n    |\n LL |     let _: &dyn IteratorAlias = &vec![123].into_iter();\n-   |             ^^^^^^^^^^^^^^^^^ associated type `Item` must be specified\n+   |                 ^^^^^^^^^^^^^ help: specify the associated type: `IteratorAlias<Item = Type>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f34fa80a0ceec83871051dea9b2e2a604b6dd4ce", "filename": "src/test/ui/traits/trait-object-with-self-in-projection-output-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-with-self-in-projection-output-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-with-self-in-projection-output-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-with-self-in-projection-output-bad.rs?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -43,8 +43,8 @@ impl NormalizableHelper for u32\n \n fn main() {\n     let _x: Box<dyn Helper<Target=i32>> = Box::new(2u32);\n-    //~^ ERROR the value of the associated type `Output` (from the trait `Base`) must be specified\n+    //~^ ERROR the value of the associated type `Output` (from trait `Base`) must be specified\n \n     let _y: Box<dyn NormalizableHelper<Target=i32>> = Box::new(2u32);\n-    //~^ ERROR the value of the associated type `Output` (from the trait `Base`) must be specified\n+    //~^ ERROR the value of the associated type `Output` (from trait `Base`) must be specified\n }"}, {"sha": "79eb27e101a9b75e486190a044a13f99024609f5", "filename": "src/test/ui/traits/trait-object-with-self-in-projection-output-bad.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-with-self-in-projection-output-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-with-self-in-projection-output-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-object-with-self-in-projection-output-bad.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,20 +1,20 @@\n-error[E0191]: the value of the associated type `Output` (from the trait `Base`) must be specified\n-  --> $DIR/trait-object-with-self-in-projection-output-bad.rs:45:17\n+error[E0191]: the value of the associated type `Output` (from trait `Base`) must be specified\n+  --> $DIR/trait-object-with-self-in-projection-output-bad.rs:45:21\n    |\n LL |     type Output;\n    |     ------------ `Output` defined here\n ...\n LL |     let _x: Box<dyn Helper<Target=i32>> = Box::new(2u32);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^ associated type `Output` must be specified\n+   |                     ^^^^^^^^^^^^^^^^^^ help: specify the associated type: `Helper<Target=i32, Output = Type>`\n \n-error[E0191]: the value of the associated type `Output` (from the trait `Base`) must be specified\n-  --> $DIR/trait-object-with-self-in-projection-output-bad.rs:48:17\n+error[E0191]: the value of the associated type `Output` (from trait `Base`) must be specified\n+  --> $DIR/trait-object-with-self-in-projection-output-bad.rs:48:21\n    |\n LL |     type Output;\n    |     ------------ `Output` defined here\n ...\n LL |     let _y: Box<dyn NormalizableHelper<Target=i32>> = Box::new(2u32);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ associated type `Output` must be specified\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: specify the associated type: `NormalizableHelper<Target=i32, Output = Type>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c2b6f7eae9f3d8e842f112bc5dbcf0f78e659b3a", "filename": "src/test/ui/type-alias-impl-trait/not_well_formed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_well_formed.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,8 @@\n error[E0220]: associated type `Assoc` not found for `V`\n-  --> $DIR/not_well_formed.rs:10:26\n+  --> $DIR/not_well_formed.rs:10:29\n    |\n LL | type Foo<V> = impl Trait<V::Assoc>;\n-   |                          ^^^^^^^^ associated type `Assoc` not found\n+   |                             ^^^^^ associated type `Assoc` not found\n \n error: aborting due to previous error\n "}, {"sha": "eafd3cf79dbb0b588cd565ebaa44f8655ee5eaa9", "filename": "src/test/ui/type/type-parameter-defaults-referencing-Self.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftype%2Ftype-parameter-defaults-referencing-Self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Ftype%2Ftype-parameter-defaults-referencing-Self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-parameter-defaults-referencing-Self.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,8 +1,13 @@\n error[E0393]: the type parameter `T` must be explicitly specified\n   --> $DIR/type-parameter-defaults-referencing-Self.rs:10:16\n    |\n-LL | fn foo(x: &dyn Foo) { }\n-   |                ^^^ missing reference to `T`\n+LL | / trait Foo<T=Self> {\n+LL | |     fn method(&self);\n+LL | | }\n+   | |_- type parameter `T` must be specified for this\n+LL | \n+LL |   fn foo(x: &dyn Foo) { }\n+   |                  ^^^ help: set the type parameter to the desired type: `Foo<T>`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n "}, {"sha": "7ae8caee6f8be45ee78ac1dddabc06c099f7bce8", "filename": "src/test/ui/unboxed-closures/unboxed-closure-feature-gate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-feature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-feature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-feature-gate.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -2,7 +2,7 @@ error[E0658]: parenthetical notation is only stable when used with `Fn`-family t\n   --> $DIR/unboxed-closure-feature-gate.rs:13:20\n    |\n LL |     let x: Box<dyn Foo(isize)>;\n-   |                    ^^^^^^^^^^\n+   |                    ^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "ba9d984e7036cac0e0bb28c248f694c5c5312320", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-not-used-on-fn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-not-used-on-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-not-used-on-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-not-used-on-fn.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/unboxed-closure-sugar-not-used-on-fn.rs:3:17\n    |\n LL | fn bar1(x: &dyn Fn<(), Output=()>) {\n-   |                 ^^^^^^^^^^^^^^^^^\n+   |                 ^^ help: use parenthetical notation instead: `Fn() -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change. Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\n+error[E0658]: the precise format of `Fn`-family traits' type parameters is subject to change\n   --> $DIR/unboxed-closure-sugar-not-used-on-fn.rs:7:28\n    |\n LL | fn bar2<T>(x: &T) where T: Fn<()> {\n-   |                            ^^^^^^\n+   |                            ^^ help: use parenthetical notation instead: `Fn() -> ()`\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29625\n    = help: add `#![feature(unboxed_closures)]` to the crate attributes to enable"}, {"sha": "b92f054498b680ff77de2e0011fa0b1cb3e55aeb", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-region.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -2,7 +2,7 @@ error[E0107]: wrong number of lifetime arguments: expected 1, found 0\n   --> $DIR/unboxed-closure-sugar-region.rs:30:51\n    |\n LL | fn test2(x: &dyn Foo<(isize,),Output=()>, y: &dyn Foo(isize)) {\n-   |                                                   ^^^^^^^^^^ expected 1 lifetime argument\n+   |                                                   ^^^ expected 1 lifetime argument\n \n error: aborting due to previous error\n "}, {"sha": "f482098cbffcb284f904cfb208d9fb1895badd60", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -2,7 +2,7 @@ error[E0107]: wrong number of type arguments: expected 3, found 1\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs:5:16\n    |\n LL | fn foo(_: &dyn Three())\n-   |                ^^^^^^^ expected 3 type arguments\n+   |                ^^^^^ expected 3 type arguments\n \n error[E0220]: associated type `Output` not found for `Three<(), [type error], [type error]>`\n   --> $DIR/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs:5:16"}, {"sha": "ff65fd968c5e7b00bdc20f98126890e4f4a841c1", "filename": "src/test/ui/unboxed-closures/unboxed-closure-sugar-wrong-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closure-sugar-wrong-trait.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -5,10 +5,10 @@ LL | fn f<F:Trait(isize) -> isize>(x: F) {}\n    |        ^^^^^^^^^^^^ unexpected type argument\n \n error[E0220]: associated type `Output` not found for `Trait`\n-  --> $DIR/unboxed-closure-sugar-wrong-trait.rs:5:24\n+  --> $DIR/unboxed-closure-sugar-wrong-trait.rs:5:8\n    |\n LL | fn f<F:Trait(isize) -> isize>(x: F) {}\n-   |                        ^^^^^ associated type `Output` not found\n+   |        ^^^^^^^^^^^^^^^^^^^^^ associated type `Output` not found\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b72d45ebdbfbc0e47d5643153de8a106716cf37a", "filename": "src/test/ui/unspecified-self-in-trait-ref.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funspecified-self-in-trait-ref.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -25,8 +25,13 @@ LL |     let d = Bar::<usize, _>::lol();\n error[E0393]: the type parameter `A` must be explicitly specified\n   --> $DIR/unspecified-self-in-trait-ref.rs:18:13\n    |\n-LL |     let e = Bar::<usize>::lol();\n-   |             ^^^^^^^^^^^^^^^^^ missing reference to `A`\n+LL | / pub trait Bar<X=usize, A=Self> {\n+LL | |     fn foo(&self);\n+LL | | }\n+   | |_- type parameter `A` must be specified for this\n+...\n+LL |       let e = Bar::<usize>::lol();\n+   |               ^^^ missing reference to `A`\n    |\n    = note: because of the default `Self` reference, type parameters must be specified on object types\n "}, {"sha": "54d6ad6a13696829eb917f7640a2cac104f1dea3", "filename": "src/test/ui/where-clauses/where-equality-constraints.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0b16b4e6aa94cd83fd2c029356ba537dc4502c6/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-equality-constraints.stderr?ref=c0b16b4e6aa94cd83fd2c029356ba537dc4502c6", "patch": "@@ -2,15 +2,15 @@ error: equality constraints are not yet supported in `where` clauses\n   --> $DIR/where-equality-constraints.rs:1:14\n    |\n LL | fn f() where u8 = u16 {}\n-   |              ^^^^^^^^\n+   |              ^^^^^^^^ not supported\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n \n error: equality constraints are not yet supported in `where` clauses\n   --> $DIR/where-equality-constraints.rs:3:14\n    |\n LL | fn g() where for<'a> &'static (u8,) == u16, {}\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not supported\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/20041\n "}]}