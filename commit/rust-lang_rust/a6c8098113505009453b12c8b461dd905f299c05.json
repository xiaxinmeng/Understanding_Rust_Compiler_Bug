{"sha": "a6c8098113505009453b12c8b461dd905f299c05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YzgwOTgxMTM1MDUwMDk0NTNiMTJjOGI0NjFkZDkwNWYyOTljMDU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-10T15:08:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-10T15:08:30Z"}, "message": "Merge #6798\n\n6798: Ignore extern items in incorrect-case check r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6736\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "98c91e7db05ab66f85e6d66ae393fe813712fb25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98c91e7db05ab66f85e6d66ae393fe813712fb25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6c8098113505009453b12c8b461dd905f299c05", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf0jnuCRBK7hj4Ov3rIwAAdHIIAH6NkiDah1ZcSOk9LLH5Ld22\nKjSmU+H8CCVaSSKakNUS6t55VBDIi2VMSsa3iU62fft0PVDO6HJcUD03jS6Ip7Tg\nVedxDBTuYWDqJK4UZc0jGdZ6d9De/8iuoYnDclWoWfBIM1sj4TS2j6GCt9d/X9dg\n3eq791glhl4p/wkeKQPSEf2qe/dErMzein2O+ZU0weKwjWIaALe9/xyPV1xus1rP\ncQ4R4VC4cSI4YmJoNkfRJvEbyTBZFS3JQJvFtxjDlsUBpYgRz1aM7ehBRuZv9Un7\n5hNgSXPkIOXYM0p4n1AhbY0tL6NjrFeMTqsv3Jlc9uEfHR85aUG2mmxjUtyPJJA=\n=qREa\n-----END PGP SIGNATURE-----\n", "payload": "tree 98c91e7db05ab66f85e6d66ae393fe813712fb25\nparent bd785788512d1a90ad7b0363835c4ea7d9c1f4ba\nparent 05d4a5a1507673281cc2d9caad7cb9474379c3d9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1607612910 +0000\ncommitter GitHub <noreply@github.com> 1607612910 +0000\n\nMerge #6798\n\n6798: Ignore extern items in incorrect-case check r=jonas-schievink a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6736\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6c8098113505009453b12c8b461dd905f299c05", "html_url": "https://github.com/rust-lang/rust/commit/a6c8098113505009453b12c8b461dd905f299c05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6c8098113505009453b12c8b461dd905f299c05/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd785788512d1a90ad7b0363835c4ea7d9c1f4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd785788512d1a90ad7b0363835c4ea7d9c1f4ba", "html_url": "https://github.com/rust-lang/rust/commit/bd785788512d1a90ad7b0363835c4ea7d9c1f4ba"}, {"sha": "05d4a5a1507673281cc2d9caad7cb9474379c3d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/05d4a5a1507673281cc2d9caad7cb9474379c3d9", "html_url": "https://github.com/rust-lang/rust/commit/05d4a5a1507673281cc2d9caad7cb9474379c3d9"}], "stats": {"total": 489, "additions": 43, "deletions": 446}, "files": [{"sha": "dd3a906af0c0f00c5ad15531553c24e27d384362", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=a6c8098113505009453b12c8b461dd905f299c05", "patch": "@@ -28,6 +28,7 @@ pub struct FunctionData {\n     pub has_body: bool,\n     pub is_unsafe: bool,\n     pub is_varargs: bool,\n+    pub is_extern: bool,\n     pub visibility: RawVisibility,\n }\n \n@@ -46,6 +47,7 @@ impl FunctionData {\n             has_body: func.has_body,\n             is_unsafe: func.is_unsafe,\n             is_varargs: func.is_varargs,\n+            is_extern: func.is_extern,\n             visibility: item_tree[func.visibility].clone(),\n         })\n     }\n@@ -191,6 +193,7 @@ pub struct StaticData {\n     pub type_ref: TypeRef,\n     pub visibility: RawVisibility,\n     pub mutable: bool,\n+    pub is_extern: bool,\n }\n \n impl StaticData {\n@@ -204,6 +207,7 @@ impl StaticData {\n             type_ref: statik.type_ref.clone(),\n             visibility: item_tree[statik.visibility].clone(),\n             mutable: statik.mutable,\n+            is_extern: statik.is_extern,\n         })\n     }\n }"}, {"sha": "c017b352d86b96641d4334cc50ab988d6551784f", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=a6c8098113505009453b12c8b461dd905f299c05", "patch": "@@ -1,8 +1,6 @@\n //! A simplified AST that only contains items.\n \n mod lower;\n-#[cfg(test)]\n-mod tests;\n \n use std::{\n     any::type_name,\n@@ -507,6 +505,9 @@ pub struct Function {\n     pub has_self_param: bool,\n     pub has_body: bool,\n     pub is_unsafe: bool,\n+    /// Whether the function is located in an `extern` block (*not* whether it is an\n+    /// `extern \"abi\" fn`).\n+    pub is_extern: bool,\n     pub params: Box<[TypeRef]>,\n     pub is_varargs: bool,\n     pub ret_type: TypeRef,\n@@ -565,6 +566,8 @@ pub struct Static {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n     pub mutable: bool,\n+    /// Whether the static is in an `extern` block.\n+    pub is_extern: bool,\n     pub type_ref: TypeRef,\n     pub ast_id: FileAstId<ast::Static>,\n }"}, {"sha": "63b2826f8579a6b0e2bb9f0ca7efd039da89c75e", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=a6c8098113505009453b12c8b461dd905f299c05", "patch": "@@ -340,6 +340,7 @@ impl Ctx {\n             has_self_param,\n             has_body,\n             is_unsafe: func.unsafe_token().is_some(),\n+            is_extern: false,\n             params: params.into_boxed_slice(),\n             is_varargs,\n             ret_type,\n@@ -378,7 +379,7 @@ impl Ctx {\n         let visibility = self.lower_visibility(static_);\n         let mutable = static_.mut_token().is_some();\n         let ast_id = self.source_ast_id_map.ast_id(static_);\n-        let res = Static { name, visibility, mutable, type_ref, ast_id };\n+        let res = Static { name, visibility, mutable, type_ref, ast_id, is_extern: false };\n         Some(id(self.data().statics.alloc(res)))\n     }\n \n@@ -554,13 +555,15 @@ impl Ctx {\n                     let attrs = Attrs::new(&item, &self.hygiene);\n                     let id: ModItem = match item {\n                         ast::ExternItem::Fn(ast) => {\n-                            let func = self.lower_function(&ast)?;\n-                            self.data().functions[func.index].is_unsafe =\n-                                is_intrinsic_fn_unsafe(&self.data().functions[func.index].name);\n-                            func.into()\n+                            let func_id = self.lower_function(&ast)?;\n+                            let func = &mut self.data().functions[func_id.index];\n+                            func.is_unsafe = is_intrinsic_fn_unsafe(&func.name);\n+                            func.is_extern = true;\n+                            func_id.into()\n                         }\n                         ast::ExternItem::Static(ast) => {\n                             let statik = self.lower_static(&ast)?;\n+                            self.data().statics[statik.index].is_extern = true;\n                             statik.into()\n                         }\n                         ast::ExternItem::TypeAlias(ty) => {"}, {"sha": "4b354c4c145e53948d65d6e6cad28324f16f2115", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/bd785788512d1a90ad7b0363835c4ea7d9c1f4ba/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd785788512d1a90ad7b0363835c4ea7d9c1f4ba/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=bd785788512d1a90ad7b0363835c4ea7d9c1f4ba", "patch": "@@ -1,439 +0,0 @@\n-use base_db::fixture::WithFixture;\n-use expect_test::{expect, Expect};\n-use hir_expand::{db::AstDatabase, HirFileId, InFile};\n-use rustc_hash::FxHashSet;\n-use std::sync::Arc;\n-use stdx::format_to;\n-use syntax::{ast, AstNode};\n-\n-use crate::{db::DefDatabase, test_db::TestDB};\n-\n-use super::{ItemTree, ModItem, ModKind};\n-\n-fn test_inner_items(ra_fixture: &str) {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-    let file_id = HirFileId::from(file_id);\n-    let tree = db.item_tree(file_id);\n-    let root = db.parse_or_expand(file_id).unwrap();\n-    let ast_id_map = db.ast_id_map(file_id);\n-\n-    // Traverse the item tree and collect all module/impl/trait-level items as AST nodes.\n-    let mut outer_items = FxHashSet::default();\n-    let mut worklist = tree.top_level_items().to_vec();\n-    while let Some(item) = worklist.pop() {\n-        let node: ast::Item = match item {\n-            ModItem::Import(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::ExternCrate(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Function(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Struct(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Union(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Enum(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Const(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Static(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::TypeAlias(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Mod(it) => {\n-                if let ModKind::Inline { items } = &tree[it].kind {\n-                    worklist.extend(&**items);\n-                }\n-                tree.source(&db, InFile::new(file_id, it)).into()\n-            }\n-            ModItem::Trait(it) => {\n-                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n-                tree.source(&db, InFile::new(file_id, it)).into()\n-            }\n-            ModItem::Impl(it) => {\n-                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n-                tree.source(&db, InFile::new(file_id, it)).into()\n-            }\n-            ModItem::MacroCall(_) => continue,\n-        };\n-\n-        outer_items.insert(node);\n-    }\n-\n-    // Now descend the root node and check that all `ast::ModuleItem`s are either recorded above, or\n-    // registered as inner items.\n-    for item in root.descendants().skip(1).filter_map(ast::Item::cast) {\n-        if outer_items.contains(&item) {\n-            continue;\n-        }\n-\n-        let ast_id = ast_id_map.ast_id(&item);\n-        assert!(!tree.inner_items(ast_id).is_empty());\n-    }\n-}\n-\n-fn item_tree(ra_fixture: &str) -> Arc<ItemTree> {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-    db.item_tree(file_id.into())\n-}\n-\n-fn print_item_tree(ra_fixture: &str) -> String {\n-    let tree = item_tree(ra_fixture);\n-    let mut out = String::new();\n-\n-    format_to!(out, \"inner attrs: {:?}\\n\\n\", tree.top_level_attrs());\n-    format_to!(out, \"top-level items:\\n\");\n-    for item in tree.top_level_items() {\n-        fmt_mod_item(&mut out, &tree, *item);\n-        format_to!(out, \"\\n\");\n-    }\n-\n-    if !tree.inner_items.is_empty() {\n-        format_to!(out, \"\\ninner items:\\n\\n\");\n-        for (ast_id, items) in &tree.inner_items {\n-            format_to!(out, \"for AST {:?}:\\n\", ast_id);\n-            for inner in items {\n-                fmt_mod_item(&mut out, &tree, *inner);\n-                format_to!(out, \"\\n\\n\");\n-            }\n-        }\n-    }\n-\n-    out\n-}\n-\n-fn fmt_mod_item(out: &mut String, tree: &ItemTree, item: ModItem) {\n-    let attrs = tree.attrs(item.into());\n-    if !attrs.is_empty() {\n-        format_to!(out, \"#[{:?}]\\n\", attrs);\n-    }\n-\n-    let mut children = String::new();\n-    match item {\n-        ModItem::ExternCrate(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Import(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Function(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Struct(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Union(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Enum(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Const(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Static(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Trait(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-            for item in &*tree[it].items {\n-                fmt_mod_item(&mut children, tree, ModItem::from(*item));\n-                format_to!(children, \"\\n\");\n-            }\n-        }\n-        ModItem::Impl(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-            for item in &*tree[it].items {\n-                fmt_mod_item(&mut children, tree, ModItem::from(*item));\n-                format_to!(children, \"\\n\");\n-            }\n-        }\n-        ModItem::TypeAlias(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Mod(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-            match &tree[it].kind {\n-                ModKind::Inline { items } => {\n-                    for item in &**items {\n-                        fmt_mod_item(&mut children, tree, *item);\n-                        format_to!(children, \"\\n\");\n-                    }\n-                }\n-                ModKind::Outline {} => {}\n-            }\n-        }\n-        ModItem::MacroCall(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-    }\n-\n-    for line in children.lines() {\n-        format_to!(out, \"\\n> {}\", line);\n-    }\n-}\n-\n-fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = print_item_tree(ra_fixture);\n-    expect.assert_eq(&actual);\n-}\n-\n-#[test]\n-fn smoke() {\n-    check(\n-        r\"\n-        #![attr]\n-\n-        #[attr_on_use]\n-        use {a, b::*};\n-\n-        #[ext_crate]\n-        extern crate krate;\n-\n-        #[on_trait]\n-        trait Tr<U> {\n-            #[assoc_ty]\n-            type AssocTy: Tr<()>;\n-\n-            #[assoc_const]\n-            const CONST: u8;\n-\n-            #[assoc_method]\n-            fn method(&self);\n-\n-            #[assoc_dfl_method]\n-            fn dfl_method(&mut self) {}\n-        }\n-\n-        #[struct0]\n-        struct Struct0<T = ()>;\n-\n-        #[struct1]\n-        struct Struct1<T>(#[struct1fld] u8);\n-\n-        #[struct2]\n-        struct Struct2<T> {\n-            #[struct2fld]\n-            fld: (T, ),\n-        }\n-\n-        #[en]\n-        enum En {\n-            #[enum_variant]\n-            Variant {\n-                #[enum_field]\n-                field: u8,\n-            },\n-        }\n-\n-        #[un]\n-        union Un {\n-            #[union_fld]\n-            fld: u16,\n-        }\n-    \",\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr\"))] }, input: None }]) }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0), index: 0 }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0), index: 1 }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n-            ExternCrate { name: Name(Text(\"krate\")), alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<syntax::ast::generated::nodes::ExternCrate>(1) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]\n-            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Trait>(2) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_ty\"))] }, input: None }]) }]\n-            > TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, is_extern: false, ast_id: FileAstId::<syntax::ast::generated::nodes::TypeAlias>(8) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_const\"))] }, input: None }]) }]\n-            > Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<syntax::ast::generated::nodes::Const>(9) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_method\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, has_body: false, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(10) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_dfl_method\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, has_body: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(11) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(3), kind: Unit }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(4), kind: Tuple }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(5), kind: Record }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n-            Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<syntax::ast::generated::nodes::Enum>(6) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n-            Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<syntax::ast::generated::nodes::Union>(7) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn simple_inner_items() {\n-    check(\n-        r\"\n-        impl<T:A> D for Response<T> {\n-            fn foo() {\n-                end();\n-                fn end<W: Write>() {\n-                    let _x: T = loop {};\n-                }\n-            }\n-        }\n-    \",\n-        expect![[r#\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n-            > Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-\n-            inner items:\n-\n-            for AST FileAstId::<syntax::ast::generated::nodes::Item>(2):\n-            Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn extern_attrs() {\n-    check(\n-        r#\"\n-        #[block_attr]\n-        extern \"C\" {\n-            #[attr_a]\n-            fn a() {}\n-            #[attr_b]\n-            fn b() {}\n-        }\n-    \"#,\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn trait_attrs() {\n-    check(\n-        r#\"\n-        #[trait_attr]\n-        trait Tr {\n-            #[attr_a]\n-            fn a() {}\n-            #[attr_b]\n-            fn b() {}\n-        }\n-    \"#,\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"trait_attr\"))] }, input: None }]) }]\n-            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Trait>(0) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn impl_attrs() {\n-    check(\n-        r#\"\n-        #[impl_attr]\n-        impl Ty {\n-            #[attr_a]\n-            fn a() {}\n-            #[attr_b]\n-            fn b() {}\n-        }\n-    \"#,\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"impl_attr\"))] }, input: None }]) }]\n-            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn cursed_inner_items() {\n-    test_inner_items(\n-        r\"\n-        struct S<T: Trait = [u8; { fn f() {} 0 }]>(T);\n-\n-        enum En {\n-            Var1 {\n-                t: [(); { trait Inner {} 0 }],\n-            },\n-\n-            Var2([u16; { enum Inner {} 0 }]),\n-        }\n-\n-        type Ty = [En; { struct Inner; 0 }];\n-\n-        impl En {\n-            fn assoc() {\n-                trait InnerTrait<T = [u8; { fn f() {} }]> {}\n-                struct InnerStruct<T = [u8; { fn f() {} }]> {}\n-                impl<T = [u8; { fn f() {} }]> InnerTrait for InnerStruct {}\n-            }\n-        }\n-\n-        trait Tr<T = [u8; { fn f() {} }]> {\n-            type AssocTy = [u8; { fn f() {} }];\n-\n-            const AssocConst: [u8; { fn f() {} }];\n-        }\n-    \",\n-    );\n-}\n-\n-#[test]\n-fn inner_item_attrs() {\n-    check(\n-        r\"\n-        fn foo() {\n-            #[on_inner]\n-            fn inner() {}\n-        }\n-    \",\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(0) }\n-\n-            inner items:\n-\n-            for AST FileAstId::<syntax::ast::generated::nodes::Item>(1):\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn assoc_item_macros() {\n-    check(\n-        r\"\n-        impl S {\n-            items!();\n-        }\n-    \",\n-        expect![[r#\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n-            > MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<syntax::ast::generated::nodes::MacroCall>(1) }\n-        \"#]],\n-    );\n-}"}, {"sha": "25587e1168630bc026257d619c5ac91452890e18", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6c8098113505009453b12c8b461dd905f299c05/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=a6c8098113505009453b12c8b461dd905f299c05", "patch": "@@ -26,6 +26,7 @@ use syntax::{\n     ast::{self, NameOwner},\n     AstNode, AstPtr,\n };\n+use test_utils::mark;\n \n use crate::{\n     db::HirDatabase,\n@@ -87,6 +88,11 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n     fn validate_func(&mut self, db: &dyn HirDatabase, func: FunctionId) {\n         let data = db.function_data(func);\n+        if data.is_extern {\n+            mark::hit!(extern_func_incorrect_case_ignored);\n+            return;\n+        }\n+\n         let body = db.body(func.into());\n \n         // Recursively validate inner scope items, such as static variables and constants.\n@@ -648,6 +654,10 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n \n     fn validate_static(&mut self, db: &dyn HirDatabase, static_id: StaticId) {\n         let data = db.static_data(static_id);\n+        if data.is_extern {\n+            mark::hit!(extern_static_incorrect_case_ignored);\n+            return;\n+        }\n \n         if self.allowed(db, static_id.into(), allow::NON_UPPER_CASE_GLOBAL) {\n             return;\n@@ -709,6 +719,8 @@ fn pat_equals_to_name(pat: Option<ast::Pat>, name: &Name) -> bool {\n \n #[cfg(test)]\n mod tests {\n+    use test_utils::mark;\n+\n     use crate::diagnostics::tests::check_diagnostics;\n \n     #[test]\n@@ -920,4 +932,18 @@ fn main() {\n     \"#,\n         );\n     }\n+\n+    #[test]\n+    fn ignores_extern_items() {\n+        mark::check!(extern_func_incorrect_case_ignored);\n+        mark::check!(extern_static_incorrect_case_ignored);\n+        check_diagnostics(\n+            r#\"\n+extern {\n+    fn NonSnakeCaseName(SOME_VAR: u8) -> u8;\n+    pub static SomeStatic: u8 = 10;\n+}\n+            \"#,\n+        );\n+    }\n }"}]}