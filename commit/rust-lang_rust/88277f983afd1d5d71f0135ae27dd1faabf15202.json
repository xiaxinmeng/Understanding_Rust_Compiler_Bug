{"sha": "88277f983afd1d5d71f0135ae27dd1faabf15202", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4Mjc3Zjk4M2FmZDFkNWQ3MWYwMTM1YWUyN2RkMWZhYWJmMTUyMDI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-08T10:52:04Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-08T10:52:04Z"}, "message": "Remove some workarounds for missing inst legalizations", "tree": {"sha": "7b9b23fb4da0ff2dd2f036935d8bae9d6bb2eb9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b9b23fb4da0ff2dd2f036935d8bae9d6bb2eb9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88277f983afd1d5d71f0135ae27dd1faabf15202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88277f983afd1d5d71f0135ae27dd1faabf15202", "html_url": "https://github.com/rust-lang/rust/commit/88277f983afd1d5d71f0135ae27dd1faabf15202", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88277f983afd1d5d71f0135ae27dd1faabf15202/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cbcccf4c1022d568a47a3e43c347730126924c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cbcccf4c1022d568a47a3e43c347730126924c2", "html_url": "https://github.com/rust-lang/rust/commit/0cbcccf4c1022d568a47a3e43c347730126924c2"}], "stats": {"total": 55, "additions": 11, "deletions": 44}, "files": [{"sha": "28f55a6cc6d287f837c029876741ddd88c8d3e99", "filename": "src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88277f983afd1d5d71f0135ae27dd1faabf15202/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88277f983afd1d5d71f0135ae27dd1faabf15202/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=88277f983afd1d5d71f0135ae27dd1faabf15202", "patch": "@@ -168,8 +168,6 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Backend>) {\n                     }\n                 }\n                 let cond = trans_operand(fx, cond).load_scalar(fx);\n-                // TODO HACK brz/brnz for i8/i16 is not yet implemented\n-                let cond = fx.bcx.ins().uextend(types::I32, cond);\n                 let target = fx.get_ebb(*target);\n                 if *expected {\n                     fx.bcx.ins().brnz(cond, target, &[]);"}, {"sha": "f3b7fc925eeb8791a13500c53684651dc4eb07cc", "filename": "src/common.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/88277f983afd1d5d71f0135ae27dd1faabf15202/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88277f983afd1d5d71f0135ae27dd1faabf15202/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=88277f983afd1d5d71f0135ae27dd1faabf15202", "patch": "@@ -80,21 +80,6 @@ pub fn has_ptr_meta<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-pub fn codegen_select(bcx: &mut FunctionBuilder, cond: Value, lhs: Value, rhs: Value) -> Value {\n-    let lhs_ty = bcx.func.dfg.value_type(lhs);\n-    let rhs_ty = bcx.func.dfg.value_type(rhs);\n-    assert_eq!(lhs_ty, rhs_ty);\n-    if lhs_ty == types::I8 || lhs_ty == types::I16 {\n-        // FIXME workaround for missing encoding for select.i8\n-        let lhs = bcx.ins().uextend(types::I32, lhs);\n-        let rhs = bcx.ins().uextend(types::I32, rhs);\n-        let res = bcx.ins().select(cond, lhs, rhs);\n-        bcx.ins().ireduce(lhs_ty, res)\n-    } else {\n-        bcx.ins().select(cond, lhs, rhs)\n-    }\n-}\n-\n pub fn codegen_icmp(\n     fx: &mut FunctionCx<'_, '_, impl Backend>,\n     intcc: IntCC,"}, {"sha": "4ad6ae91f928eedbe54667e4c2d4ee30c294d1ab", "filename": "src/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/88277f983afd1d5d71f0135ae27dd1faabf15202/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88277f983afd1d5d71f0135ae27dd1faabf15202/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=88277f983afd1d5d71f0135ae27dd1faabf15202", "patch": "@@ -118,7 +118,7 @@ macro_rules! atomic_minmax {\n \n         // Compare\n         let is_eq = codegen_icmp($fx, IntCC::SignedGreaterThan, old, $src);\n-        let new = codegen_select(&mut $fx.bcx, is_eq, old, $src);\n+        let new = $fx.bcx.ins().select(is_eq, old, $src);\n \n         // Write new\n         $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n@@ -195,7 +195,7 @@ pub fn bool_to_zero_or_max_uint<'tcx>(\n         .bcx\n         .ins()\n         .iconst(int_ty, (u64::max_value() >> (64 - int_ty.bits())) as i64);\n-    let mut res = crate::common::codegen_select(&mut fx.bcx, val, max, zero);\n+    let mut res = fx.bcx.ins().select(val, max, zero);\n \n     if ty.is_float() {\n         res = fx.bcx.ins().bitcast(ty, res);\n@@ -553,19 +553,19 @@ pub fn codegen_intrinsic_call<'tcx>(\n             let max = fx.bcx.ins().iconst(clif_ty, max);\n \n             let val = match (intrinsic, signed) {\n-                (\"saturating_add\", false) => codegen_select(&mut fx.bcx, has_overflow, max, val),\n-                (\"saturating_sub\", false) => codegen_select(&mut fx.bcx, has_overflow, min, val),\n+                (\"saturating_add\", false) => fx.bcx.ins().select(has_overflow, max, val),\n+                (\"saturating_sub\", false) => fx.bcx.ins().select(has_overflow, min, val),\n                 (\"saturating_add\", true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = codegen_select(&mut fx.bcx, rhs_ge_zero, max, min);\n-                    codegen_select(&mut fx.bcx, has_overflow, sat_val, val)\n+                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n+                    fx.bcx.ins().select(has_overflow, sat_val, val)\n                 }\n                 (\"saturating_sub\", true) => {\n                     let rhs = rhs.load_scalar(fx);\n                     let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = codegen_select(&mut fx.bcx, rhs_ge_zero, min, max);\n-                    codegen_select(&mut fx.bcx, has_overflow, sat_val, val)\n+                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n+                    fx.bcx.ins().select(has_overflow, sat_val, val)\n                 }\n                 _ => unreachable!(),\n             };\n@@ -703,28 +703,12 @@ pub fn codegen_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, res);\n         };\n         ctpop, <T> (v arg) {\n-            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n-                let (lo, hi) = fx.bcx.ins().isplit(arg);\n-                let lo_popcnt = fx.bcx.ins().popcnt(lo);\n-                let hi_popcnt = fx.bcx.ins().popcnt(hi);\n-                let popcnt = fx.bcx.ins().iadd(lo_popcnt, hi_popcnt);\n-                crate::cast::clif_intcast(fx, popcnt, types::I128, false)\n-            } else {\n-                fx.bcx.ins().popcnt(arg)\n-            };\n+            let res = fx.bcx.ins().popcnt(arg);\n             let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n         bitreverse, <T> (v arg) {\n-            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n-                let (lo, hi) = fx.bcx.ins().isplit(arg);\n-                let lo_bitrev = fx.bcx.ins().bitrev(lo);\n-                let hi_bitrev = fx.bcx.ins().bitrev(hi);\n-                let bitrev = fx.bcx.ins().iconcat(hi_bitrev, lo_bitrev);\n-                crate::cast::clif_intcast(fx, bitrev, types::I128, false)\n-            } else {\n-                fx.bcx.ins().bitrev(arg)\n-            };\n+            let res = fx.bcx.ins().bitrev(arg);\n             let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n@@ -881,7 +865,7 @@ pub fn codegen_intrinsic_call<'tcx>(\n \n             // Compare\n             let is_eq = codegen_icmp(fx, IntCC::Equal, old, test_old);\n-            let new = crate::common::codegen_select(&mut fx.bcx, is_eq, new, old); // Keep old if not equal to test_old\n+            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n \n             // Write new\n             fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);"}]}