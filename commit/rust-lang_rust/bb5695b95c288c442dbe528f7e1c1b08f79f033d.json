{"sha": "bb5695b95c288c442dbe528f7e1c1b08f79f033d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNTY5NWI5NWMyODhjNDQyZGJlNTI4ZjdlMWMxYjA4Zjc5ZjAzM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-29T23:36:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-29T23:36:43Z"}, "message": "auto merge of #15245 : sfackler/rust/coretest, r=alexcrichton\n\nLibcore's test infrastructure is complicated by the fact that many lang\r\nitems are defined in the crate. The current approach (realcore/realstd\r\nimports) is hacky and hard to work with (tests inside of core::cmp\r\nhaven't been run for months!).\r\n\r\nMoving tests to a separate crate does mean that they can only test the\r\npublic API of libcore, but I don't feel that that is too much of an\r\nissue. The only tests that I had to get rid of were some checking the\r\nvarious numeric formatters, but those are also exercised through normal\r\nformat! calls in other tests.", "tree": {"sha": "0269cdf468e55163d90491d9ba0b18bf76e718c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0269cdf468e55163d90491d9ba0b18bf76e718c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb5695b95c288c442dbe528f7e1c1b08f79f033d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5695b95c288c442dbe528f7e1c1b08f79f033d", "html_url": "https://github.com/rust-lang/rust/commit/bb5695b95c288c442dbe528f7e1c1b08f79f033d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb5695b95c288c442dbe528f7e1c1b08f79f033d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a490871a6c3fae9017a6402fcf911d05dcf1d013", "url": "https://api.github.com/repos/rust-lang/rust/commits/a490871a6c3fae9017a6402fcf911d05dcf1d013", "html_url": "https://github.com/rust-lang/rust/commit/a490871a6c3fae9017a6402fcf911d05dcf1d013"}, {"sha": "1ed646eaf7d09455a086afa11bcd83a7d2a6b0f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed646eaf7d09455a086afa11bcd83a7d2a6b0f4", "html_url": "https://github.com/rust-lang/rust/commit/1ed646eaf7d09455a086afa11bcd83a7d2a6b0f4"}], "stats": {"total": 6687, "additions": 3348, "deletions": 3339}, "files": [{"sha": "44bedde99ccffdba2a1571000adc371b601da523", "filename": "mk/tests.mk", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -14,7 +14,12 @@\n ######################################################################\n \n # The names of crates that must be tested\n-TEST_TARGET_CRATES = $(TARGET_CRATES)\n+\n+# libcore tests are in a separate crate\n+DEPS_coretest :=\n+$(eval $(call RUST_CRATE,coretest))\n+\n+TEST_TARGET_CRATES = $(filter-out core,$(TARGET_CRATES)) coretest\n TEST_DOC_CRATES = $(DOC_CRATES)\n TEST_HOST_CRATES = $(HOST_CRATES)\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n@@ -172,7 +177,7 @@ check-notidy: cleantmptestlogs cleantestlibs all check-stage2\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n check-lite: cleantestlibs cleantmptestlogs \\\n-\t$(foreach crate,$(TARGET_CRATES),check-stage2-$(crate)) \\\n+\t$(foreach crate,$(TEST_TARGET_CRATES),check-stage2-$(crate)) \\\n \tcheck-stage2-rpass \\\n \tcheck-stage2-rfail check-stage2-cfail check-stage2-rmake\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log"}, {"sha": "33afa806f4e391c180ebd6eedcfe11c6590695c7", "filename": "src/liballoc/owned.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Fliballoc%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Fliballoc%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fowned.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -146,3 +146,51 @@ impl fmt::Show for Box<Any> {\n         f.pad(\"Box<Any>\")\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn test_owned_clone() {\n+        let a = box 5i;\n+        let b: Box<int> = a.clone();\n+        assert!(a == b);\n+    }\n+\n+    #[test]\n+    fn any_move() {\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+\n+        match a.move::<uint>() {\n+            Ok(a) => { assert!(a == box 8u); }\n+            Err(..) => fail!()\n+        }\n+        match b.move::<Test>() {\n+            Ok(a) => { assert!(a == box Test); }\n+            Err(..) => fail!()\n+        }\n+\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+\n+        assert!(a.move::<Box<Test>>().is_err());\n+        assert!(b.move::<Box<uint>>().is_err());\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let a = box 8u as Box<Any>;\n+        let b = box Test as Box<Any>;\n+        let a_str = a.to_str();\n+        let b_str = b.to_str();\n+        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n+        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n+\n+        let a = &8u as &Any;\n+        let b = &Test as &Any;\n+        let s = format!(\"{}\", a);\n+        assert_eq!(s.as_slice(), \"&Any\");\n+        let s = format!(\"{}\", b);\n+        assert_eq!(s.as_slice(), \"&Any\");\n+    }\n+}"}, {"sha": "8021fa50d8f4647ac3155d8050f9d329c6aff435", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -115,179 +115,3 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-    use realstd::owned::{Box, AnyOwnExt};\n-    use realstd::str::Str;\n-\n-    #[deriving(PartialEq, Show)]\n-    struct Test;\n-\n-    static TEST: &'static str = \"Test\";\n-\n-    #[test]\n-    fn any_referenced() {\n-        let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_owning() {\n-        let (a, b, c) = (box 5u as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n-\n-        assert!(a.is::<uint>());\n-        assert!(!b.is::<uint>());\n-        assert!(!c.is::<uint>());\n-\n-        assert!(!a.is::<&'static str>());\n-        assert!(b.is::<&'static str>());\n-        assert!(!c.is::<&'static str>());\n-\n-        assert!(!a.is::<Test>());\n-        assert!(!b.is::<Test>());\n-        assert!(c.is::<Test>());\n-    }\n-\n-    #[test]\n-    fn any_as_ref() {\n-        let a = &5u as &Any;\n-\n-        match a.as_ref::<uint>() {\n-            Some(&5) => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match a.as_ref::<Test>() {\n-            None => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-    }\n-\n-    #[test]\n-    fn any_as_mut() {\n-        let mut a = 5u;\n-        let mut b = box 7u;\n-\n-        let a_r = &mut a as &mut Any;\n-        let tmp: &mut uint = &mut *b;\n-        let b_r = tmp as &mut Any;\n-\n-        match a_r.as_mut::<uint>() {\n-            Some(x) => {\n-                assert_eq!(*x, 5u);\n-                *x = 612;\n-            }\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match b_r.as_mut::<uint>() {\n-            Some(x) => {\n-                assert_eq!(*x, 7u);\n-                *x = 413;\n-            }\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match a_r.as_mut::<Test>() {\n-            None => (),\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match b_r.as_mut::<Test>() {\n-            None => (),\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match a_r.as_mut::<uint>() {\n-            Some(&612) => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-\n-        match b_r.as_mut::<uint>() {\n-            Some(&413) => {}\n-            x => fail!(\"Unexpected value {}\", x)\n-        }\n-    }\n-\n-    #[test]\n-    fn any_move() {\n-        use realstd::any::Any;\n-        use realstd::result::{Ok, Err};\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n-\n-        match a.move::<uint>() {\n-            Ok(a) => { assert!(a == box 8u); }\n-            Err(..) => fail!()\n-        }\n-        match b.move::<Test>() {\n-            Ok(a) => { assert!(a == box Test); }\n-            Err(..) => fail!()\n-        }\n-\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n-\n-        assert!(a.move::<Box<Test>>().is_err());\n-        assert!(b.move::<Box<uint>>().is_err());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        use realstd::to_str::ToStr;\n-        let a = box 8u as Box<::realstd::any::Any>;\n-        let b = box Test as Box<::realstd::any::Any>;\n-        let a_str = a.to_str();\n-        let b_str = b.to_str();\n-        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n-        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n-\n-        let a = &8u as &Any;\n-        let b = &Test as &Any;\n-        let s = format!(\"{}\", a);\n-        assert_eq!(s.as_slice(), \"&Any\");\n-        let s = format!(\"{}\", b);\n-        assert_eq!(s.as_slice(), \"&Any\");\n-    }\n-\n-    #[test]\n-    fn any_fixed_vec() {\n-        let test = [0u, ..8];\n-        let test = &test as &Any;\n-        assert!(test.is::<[uint, ..8]>());\n-        assert!(!test.is::<[uint, ..10]>());\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use any::{Any, AnyRefExt};\n-    use option::Some;\n-    use self::test::Bencher;\n-\n-    #[bench]\n-    fn bench_as_ref(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut x = 0i;\n-            let mut y = &mut x as &mut Any;\n-            test::black_box(&mut y);\n-            test::black_box(y.as_ref::<int>() == Some(&0));\n-        });\n-    }\n-}"}, {"sha": "971799acc7862e61efb2112990ddf8fa045a5bef", "filename": "src/libcore/atomics.rs", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -693,97 +693,3 @@ pub fn fence(order: Ordering) {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn bool_() {\n-        let a = AtomicBool::new(false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n-\n-        a.store(false, SeqCst);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-    }\n-\n-    #[test]\n-    fn bool_and() {\n-        let a = AtomicBool::new(true);\n-        assert_eq!(a.fetch_and(false, SeqCst),true);\n-        assert_eq!(a.load(SeqCst),false);\n-    }\n-\n-    #[test]\n-    fn uint_and() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_or() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_xor() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_and() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_or() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_xor() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n-\n-    #[test]\n-    fn static_init() {\n-        unsafe {\n-            assert!(!S_BOOL.load(SeqCst));\n-            assert!(S_INT.load(SeqCst) == 0);\n-            assert!(S_UINT.load(SeqCst) == 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn different_sizes() {\n-        unsafe {\n-            let mut slot = 0u16;\n-            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n-\n-            let mut slot = 0u8;\n-            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n-\n-            let slot = 0u32;\n-            assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n-\n-            let mut slot = 0u64;\n-            super::atomic_store(&mut slot, 2, SeqCst);\n-        }\n-    }\n-}"}, {"sha": "355ee7c7a16f010c48b2f954b4d58eef7e2adbcb", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -383,132 +383,3 @@ impl<'b, T> DerefMut<T> for RefMut<'b, T> {\n         unsafe { &mut *self._parent.value.get() }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use mem::drop;\n-\n-    #[test]\n-    fn smoketest_cell() {\n-        let x = Cell::new(10i);\n-        assert!(x == Cell::new(10));\n-        assert!(x.get() == 10);\n-        x.set(20);\n-        assert!(x == Cell::new(20));\n-        assert!(x.get() == 20);\n-\n-        let y = Cell::new((30i, 40i));\n-        assert!(y == Cell::new((30, 40)));\n-        assert!(y.get() == (30, 40));\n-    }\n-\n-    #[test]\n-    fn cell_has_sensible_show() {\n-        use str::StrSlice;\n-        use realstd::str::Str;\n-\n-        let x = Cell::new(\"foo bar\");\n-        assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n-\n-        x.set(\"baz qux\");\n-        assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n-    }\n-\n-    #[test]\n-    fn ref_and_refmut_have_sensible_show() {\n-        use str::StrSlice;\n-        use realstd::str::Str;\n-\n-        let refcell = RefCell::new(\"foo\");\n-\n-        let refcell_refmut = refcell.borrow_mut();\n-        assert!(format!(\"{}\", refcell_refmut).as_slice().contains(\"foo\"));\n-        drop(refcell_refmut);\n-\n-        let refcell_ref = refcell.borrow();\n-        assert!(format!(\"{}\", refcell_ref).as_slice().contains(\"foo\"));\n-        drop(refcell_ref);\n-    }\n-\n-    #[test]\n-    fn double_imm_borrow() {\n-        let x = RefCell::new(0i);\n-        let _b1 = x.borrow();\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn no_mut_then_imm_borrow() {\n-        let x = RefCell::new(0i);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow().is_none());\n-    }\n-\n-    #[test]\n-    fn no_imm_then_borrow_mut() {\n-        let x = RefCell::new(0i);\n-        let _b1 = x.borrow();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn no_double_borrow_mut() {\n-        let x = RefCell::new(0i);\n-        let _b1 = x.borrow_mut();\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    fn imm_release_borrow_mut() {\n-        let x = RefCell::new(0i);\n-        {\n-            let _b1 = x.borrow();\n-        }\n-        x.borrow_mut();\n-    }\n-\n-    #[test]\n-    fn mut_release_borrow_mut() {\n-        let x = RefCell::new(0i);\n-        {\n-            let _b1 = x.borrow_mut();\n-        }\n-        x.borrow();\n-    }\n-\n-    #[test]\n-    fn double_borrow_single_release_no_borrow_mut() {\n-        let x = RefCell::new(0i);\n-        let _b1 = x.borrow();\n-        {\n-            let _b2 = x.borrow();\n-        }\n-        assert!(x.try_borrow_mut().is_none());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn discard_doesnt_unborrow() {\n-        let x = RefCell::new(0i);\n-        let _b = x.borrow();\n-        let _ = _b;\n-        let _b = x.borrow_mut();\n-    }\n-\n-    #[test]\n-    #[allow(experimental)]\n-    fn clone_ref_updates_flag() {\n-        let x = RefCell::new(0i);\n-        {\n-            let b1 = x.borrow();\n-            assert!(x.try_borrow_mut().is_none());\n-            {\n-                let _b2 = clone_ref(&b1);\n-                assert!(x.try_borrow_mut().is_none());\n-            }\n-            assert!(x.try_borrow_mut().is_none());\n-        }\n-        assert!(x.try_borrow_mut().is_some());\n-    }\n-}"}, {"sha": "da67772d0f1229c3a311bfeaf2166c549c6f1037", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 202, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -602,205 +602,3 @@ impl Char for char {\n }\n \n \n-#[cfg(test)]\n-mod test {\n-    use super::{escape_unicode, escape_default};\n-\n-    use char::Char;\n-    use slice::ImmutableVector;\n-    use option::{Some, None};\n-    use realstd::string::String;\n-    use realstd::str::Str;\n-\n-    #[test]\n-    fn test_is_lowercase() {\n-        assert!('a'.is_lowercase());\n-        assert!('\u00f6'.is_lowercase());\n-        assert!('\u00df'.is_lowercase());\n-        assert!(!'\u00dc'.is_lowercase());\n-        assert!(!'P'.is_lowercase());\n-    }\n-\n-    #[test]\n-    fn test_is_uppercase() {\n-        assert!(!'h'.is_uppercase());\n-        assert!(!'\u00e4'.is_uppercase());\n-        assert!(!'\u00df'.is_uppercase());\n-        assert!('\u00d6'.is_uppercase());\n-        assert!('T'.is_uppercase());\n-    }\n-\n-    #[test]\n-    fn test_is_whitespace() {\n-        assert!(' '.is_whitespace());\n-        assert!('\\u2007'.is_whitespace());\n-        assert!('\\t'.is_whitespace());\n-        assert!('\\n'.is_whitespace());\n-        assert!(!'a'.is_whitespace());\n-        assert!(!'_'.is_whitespace());\n-        assert!(!'\\u0000'.is_whitespace());\n-    }\n-\n-    #[test]\n-    fn test_to_digit() {\n-        assert_eq!('0'.to_digit(10u), Some(0u));\n-        assert_eq!('1'.to_digit(2u), Some(1u));\n-        assert_eq!('2'.to_digit(3u), Some(2u));\n-        assert_eq!('9'.to_digit(10u), Some(9u));\n-        assert_eq!('a'.to_digit(16u), Some(10u));\n-        assert_eq!('A'.to_digit(16u), Some(10u));\n-        assert_eq!('b'.to_digit(16u), Some(11u));\n-        assert_eq!('B'.to_digit(16u), Some(11u));\n-        assert_eq!('z'.to_digit(36u), Some(35u));\n-        assert_eq!('Z'.to_digit(36u), Some(35u));\n-        assert_eq!(' '.to_digit(10u), None);\n-        assert_eq!('$'.to_digit(36u), None);\n-    }\n-\n-    #[test]\n-    fn test_to_lowercase() {\n-        assert_eq!('A'.to_lowercase(), 'a');\n-        assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n-        assert_eq!('\u00df'.to_lowercase(), '\u00df');\n-        assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n-        assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n-        assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-        assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n-        assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n-        assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n-        assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n-        assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n-        assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n-    }\n-\n-    #[test]\n-    fn test_to_uppercase() {\n-        assert_eq!('a'.to_uppercase(), 'A');\n-        assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n-        assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n-        assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n-        assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n-\n-        assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n-        assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n-        assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n-        assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n-        assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n-        assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n-        assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n-    }\n-\n-    #[test]\n-    fn test_is_control() {\n-        assert!('\\u0000'.is_control());\n-        assert!('\\u0003'.is_control());\n-        assert!('\\u0006'.is_control());\n-        assert!('\\u0009'.is_control());\n-        assert!('\\u007f'.is_control());\n-        assert!('\\u0092'.is_control());\n-        assert!(!'\\u0020'.is_control());\n-        assert!(!'\\u0055'.is_control());\n-        assert!(!'\\u0068'.is_control());\n-    }\n-\n-    #[test]\n-    fn test_is_digit() {\n-       assert!('2'.is_digit());\n-       assert!('7'.is_digit());\n-       assert!(!'c'.is_digit());\n-       assert!(!'i'.is_digit());\n-       assert!(!'z'.is_digit());\n-       assert!(!'Q'.is_digit());\n-    }\n-\n-    #[test]\n-    fn test_escape_default() {\n-        fn string(c: char) -> String {\n-            let mut result = String::new();\n-            escape_default(c, |c| { result.push_char(c); });\n-            return result;\n-        }\n-        let s = string('\\n');\n-        assert_eq!(s.as_slice(), \"\\\\n\");\n-        let s = string('\\r');\n-        assert_eq!(s.as_slice(), \"\\\\r\");\n-        let s = string('\\'');\n-        assert_eq!(s.as_slice(), \"\\\\'\");\n-        let s = string('\"');\n-        assert_eq!(s.as_slice(), \"\\\\\\\"\");\n-        let s = string(' ');\n-        assert_eq!(s.as_slice(), \" \");\n-        let s = string('a');\n-        assert_eq!(s.as_slice(), \"a\");\n-        let s = string('~');\n-        assert_eq!(s.as_slice(), \"~\");\n-        let s = string('\\x00');\n-        assert_eq!(s.as_slice(), \"\\\\x00\");\n-        let s = string('\\x1f');\n-        assert_eq!(s.as_slice(), \"\\\\x1f\");\n-        let s = string('\\x7f');\n-        assert_eq!(s.as_slice(), \"\\\\x7f\");\n-        let s = string('\\xff');\n-        assert_eq!(s.as_slice(), \"\\\\xff\");\n-        let s = string('\\u011b');\n-        assert_eq!(s.as_slice(), \"\\\\u011b\");\n-        let s = string('\\U0001d4b6');\n-        assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n-    }\n-\n-    #[test]\n-    fn test_escape_unicode() {\n-        fn string(c: char) -> String {\n-            let mut result = String::new();\n-            escape_unicode(c, |c| { result.push_char(c); });\n-            return result;\n-        }\n-        let s = string('\\x00');\n-        assert_eq!(s.as_slice(), \"\\\\x00\");\n-        let s = string('\\n');\n-        assert_eq!(s.as_slice(), \"\\\\x0a\");\n-        let s = string(' ');\n-        assert_eq!(s.as_slice(), \"\\\\x20\");\n-        let s = string('a');\n-        assert_eq!(s.as_slice(), \"\\\\x61\");\n-        let s = string('\\u011b');\n-        assert_eq!(s.as_slice(), \"\\\\u011b\");\n-        let s = string('\\U0001d4b6');\n-        assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n-    }\n-\n-    #[test]\n-    fn test_to_str() {\n-        use realstd::to_str::ToStr;\n-        let s = 't'.to_str();\n-        assert_eq!(s.as_slice(), \"t\");\n-    }\n-\n-    #[test]\n-    fn test_encode_utf8() {\n-        fn check(input: char, expect: &[u8]) {\n-            let mut buf = [0u8, ..4];\n-            let n = input.encode_utf8(buf /* as mut slice! */);\n-            assert_eq!(buf.slice_to(n), expect);\n-        }\n-\n-        check('x', [0x78]);\n-        check('\\u00e9', [0xc3, 0xa9]);\n-        check('\\ua66e', [0xea, 0x99, 0xae]);\n-        check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n-    }\n-\n-    #[test]\n-    fn test_encode_utf16() {\n-        fn check(input: char, expect: &[u16]) {\n-            let mut buf = [0u16, ..2];\n-            let n = input.encode_utf16(buf /* as mut slice! */);\n-            assert_eq!(buf.slice_to(n), expect);\n-        }\n-\n-        check('x', [0x0078]);\n-        check('\\u00e9', [0x00e9]);\n-        check('\\ua66e', [0xa66e]);\n-        check('\\U0001f4a9', [0xd83d, 0xdca9]);\n-    }\n-}"}, {"sha": "247f63115a783be9dba296ec49c69a7f8b816bd4", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -110,63 +110,3 @@ extern_fn_clone!(A, B, C, D, E, F)\n extern_fn_clone!(A, B, C, D, E, F, G)\n extern_fn_clone!(A, B, C, D, E, F, G, H)\n \n-#[cfg(test)]\n-mod test {\n-    use prelude::*;\n-    use realstd::owned::Box;\n-    use realstd::gc::{Gc, GC};\n-\n-    fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n-        use realstd::clone::Clone;\n-        t.clone()\n-    }\n-\n-    fn realclone_from<T: ::realstd::clone::Clone>(t1: &mut T, t2: &T) {\n-        use realstd::clone::Clone;\n-        t1.clone_from(t2)\n-    }\n-\n-    #[test]\n-    fn test_owned_clone() {\n-        let a = box 5i;\n-        let b: Box<int> = realclone(&a);\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_managed_clone() {\n-        let a = box(GC) 5i;\n-        let b: Gc<int> = realclone(&a);\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_borrowed_clone() {\n-        let x = 5i;\n-        let y: &int = &x;\n-        let z: &int = (&y).clone();\n-        assert_eq!(*z, 5);\n-    }\n-\n-    #[test]\n-    fn test_clone_from() {\n-        let a = box 5i;\n-        let mut b = box 10i;\n-        realclone_from(&mut b, &a);\n-        assert_eq!(*b, 5);\n-    }\n-\n-    #[test]\n-    fn test_extern_fn_clone() {\n-        trait Empty {}\n-        impl Empty for int {}\n-\n-        fn test_fn_a() -> f64 { 1.0 }\n-        fn test_fn_b<T: Empty>(x: T) -> T { x }\n-        fn test_fn_c(_: int, _: f64, _: int, _: int, _: int) {}\n-\n-        let _ = test_fn_a.clone();\n-        let _ = test_fn_b::<int>.clone();\n-        let _ = test_fn_c.clone();\n-    }\n-}"}, {"sha": "a29aba6df980e48126f530f827997af5a86bc3b6", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -192,7 +192,6 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n }\n \n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n-#[cfg(not(test))]\n mod impls {\n     use cmp::{PartialOrd, Ord, PartialEq, Eq, Ordering,\n               Less, Greater, Equal};\n@@ -327,66 +326,3 @@ mod impls {\n     }\n     impl<'a, T: Eq> Eq for &'a mut T {}\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::lexical_ordering;\n-\n-    #[test]\n-    fn test_int_totalord() {\n-        assert_eq!(5u.cmp(&10), Less);\n-        assert_eq!(10u.cmp(&5), Greater);\n-        assert_eq!(5u.cmp(&5), Equal);\n-        assert_eq!((-5u).cmp(&12), Less);\n-        assert_eq!(12u.cmp(-5), Greater);\n-    }\n-\n-    #[test]\n-    fn test_mut_int_totalord() {\n-        assert_eq!((&mut 5u).cmp(&10), Less);\n-        assert_eq!((&mut 10u).cmp(&5), Greater);\n-        assert_eq!((&mut 5u).cmp(&5), Equal);\n-        assert_eq!((&mut -5u).cmp(&12), Less);\n-        assert_eq!((&mut 12u).cmp(-5), Greater);\n-    }\n-\n-    #[test]\n-    fn test_ordering_order() {\n-        assert!(Less < Equal);\n-        assert_eq!(Greater.cmp(&Less), Greater);\n-    }\n-\n-    #[test]\n-    fn test_lexical_ordering() {\n-        fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n-            assert_eq!(lexical_ordering(o1, o2), e);\n-        }\n-\n-        let xs = [Less, Equal, Greater];\n-        for &o in xs.iter() {\n-            t(Less, o, Less);\n-            t(Equal, o, o);\n-            t(Greater, o, Greater);\n-         }\n-    }\n-\n-    #[test]\n-    fn test_user_defined_eq() {\n-        // Our type.\n-        struct SketchyNum {\n-            num : int\n-        }\n-\n-        // Our implementation of `PartialEq` to support `==` and `!=`.\n-        impl PartialEq for SketchyNum {\n-            // Our custom eq allows numbers which are near each other to be equal! :D\n-            fn eq(&self, other: &SketchyNum) -> bool {\n-                (self.num - other.num).abs() < 5\n-            }\n-        }\n-\n-        // Now these binary operators will work when applied!\n-        assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n-        assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n-    }\n-}"}, {"sha": "4bc39db8ecf0932e2baef0c8e67406ed325f5110", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -31,11 +31,10 @@\n #![allow(dead_code, missing_doc)]\n \n use fmt;\n-#[cfg(not(test))] use intrinsics;\n+use intrinsics;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n-#[cfg(not(test))]\n fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     format_args!(|args| -> () {\n         begin_unwind(args, file, line);\n@@ -46,7 +45,6 @@ fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n \n #[cold]\n #[lang=\"fail_bounds_check\"]\n-#[cfg(not(test))]\n fn fail_bounds_check(file: &'static str, line: uint,\n                      index: uint, len: uint) -> ! {\n     format_args!(|args| -> () {"}, {"sha": "514b3f90df7c0dfde86baa6d9b56f9bd93da9072", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -115,55 +115,3 @@ impl<'a,A> Drop for Finallyalizer<'a,A> {\n     }\n }\n \n-#[cfg(test)]\n-mod test {\n-    use super::{try_finally, Finally};\n-    use realstd::task::failing;\n-\n-    #[test]\n-    fn test_success() {\n-        let mut i = 0i;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| {\n-                *i = 10;\n-            },\n-            |i| {\n-                assert!(!failing());\n-                assert_eq!(*i, 10);\n-                *i = 20;\n-            });\n-        assert_eq!(i, 20);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_fail() {\n-        let mut i = 0i;\n-        try_finally(\n-            &mut i, (),\n-            |i, ()| {\n-                *i = 10;\n-                fail!();\n-            },\n-            |i| {\n-                assert!(failing());\n-                assert_eq!(*i, 10);\n-            })\n-    }\n-\n-    #[test]\n-    fn test_retval() {\n-        let mut closure: || -> int = || 10;\n-        let i = closure.finally(|| { });\n-        assert_eq!(i, 10);\n-    }\n-\n-    #[test]\n-    fn test_compact() {\n-        fn do_some_fallible_work() {}\n-        fn but_always_run_this_function() { }\n-        let mut f = do_some_fallible_work;\n-        f.finally(but_always_run_this_function);\n-    }\n-}"}, {"sha": "ff7d7827fbb8ef932c8ab949438d67eade40dcce", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -496,31 +496,6 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n     }\n }\n \n-#[cfg(test)]\n-pub fn format(args: &Arguments) -> ::realstd::string::String {\n-    use str;\n-    use realstd::io::MemWriter;\n-\n-    fn mywrite<T: ::realstd::io::Writer>(t: &mut T, b: &[u8]) {\n-        use realstd::io::Writer;\n-        let _ = t.write(b);\n-    }\n-\n-    impl FormatWriter for MemWriter {\n-        fn write(&mut self, bytes: &[u8]) -> Result {\n-            mywrite(self, bytes);\n-            Ok(())\n-        }\n-    }\n-\n-    let mut i = MemWriter::new();\n-    let _ = write(&mut i, args);\n-\n-    let mut result = ::realstd::string::String::new();\n-    result.push_str(str::from_utf8(i.get_ref()).unwrap());\n-    result\n-}\n-\n /// When the compiler determines that the type of an argument *must* be a string\n /// (such as for select), then it invokes this method.\n #[doc(hidden)] #[inline]"}, {"sha": "d52791f6b0ea2e2768240bd6484d09099a6a1d8a", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 0, "deletions": 280, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -188,283 +188,3 @@ integer!(i8, u8)\n integer!(i16, u16)\n integer!(i32, u32)\n integer!(i64, u64)\n-\n-#[cfg(test)]\n-mod tests {\n-    use fmt::radix;\n-    use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n-    use super::{GenericRadix, Radix};\n-    use realstd::str::Str;\n-\n-    #[test]\n-    fn test_radix_base() {\n-        assert_eq!(Binary.base(), 2);\n-        assert_eq!(Octal.base(), 8);\n-        assert_eq!(Decimal.base(), 10);\n-        assert_eq!(LowerHex.base(), 16);\n-        assert_eq!(UpperHex.base(), 16);\n-        assert_eq!(Radix { base: 36 }.base(), 36);\n-    }\n-\n-    #[test]\n-    fn test_radix_prefix() {\n-        assert_eq!(Binary.prefix(), \"0b\");\n-        assert_eq!(Octal.prefix(), \"0o\");\n-        assert_eq!(Decimal.prefix(), \"\");\n-        assert_eq!(LowerHex.prefix(), \"0x\");\n-        assert_eq!(UpperHex.prefix(), \"0x\");\n-        assert_eq!(Radix { base: 36 }.prefix(), \"\");\n-    }\n-\n-    #[test]\n-    fn test_radix_digit() {\n-        assert_eq!(Binary.digit(0), '0' as u8);\n-        assert_eq!(Binary.digit(2), '2' as u8);\n-        assert_eq!(Octal.digit(0), '0' as u8);\n-        assert_eq!(Octal.digit(7), '7' as u8);\n-        assert_eq!(Decimal.digit(0), '0' as u8);\n-        assert_eq!(Decimal.digit(9), '9' as u8);\n-        assert_eq!(LowerHex.digit(0), '0' as u8);\n-        assert_eq!(LowerHex.digit(10), 'a' as u8);\n-        assert_eq!(LowerHex.digit(15), 'f' as u8);\n-        assert_eq!(UpperHex.digit(0), '0' as u8);\n-        assert_eq!(UpperHex.digit(10), 'A' as u8);\n-        assert_eq!(UpperHex.digit(15), 'F' as u8);\n-        assert_eq!(Radix { base: 36 }.digit(0), '0' as u8);\n-        assert_eq!(Radix { base: 36 }.digit(15), 'f' as u8);\n-        assert_eq!(Radix { base: 36 }.digit(35), 'z' as u8);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_hex_radix_digit_overflow() {\n-        let _ = LowerHex.digit(16);\n-    }\n-\n-    #[test]\n-    fn test_format_int() {\n-        // Formatting integers should select the right implementation based off\n-        // the type of the argument. Also, hex/octal/binary should be defined\n-        // for integers, but they shouldn't emit the negative sign.\n-        assert!(format!(\"{}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:d}\", -1i).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i8).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i16).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i32).as_slice() == \"-1\");\n-        assert!(format!(\"{:d}\", -1i64).as_slice() == \"-1\");\n-        assert!(format!(\"{:t}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1i64).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i8).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i16).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i32).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1i64).as_slice() == \"1\");\n-\n-        assert!(format!(\"{}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:u}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:t}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:x}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:X}\", 1u64).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u8).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u16).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u32).as_slice() == \"1\");\n-        assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n-\n-        // Test a larger number\n-        assert!(format!(\"{:t}\", 55i).as_slice() == \"110111\");\n-        assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n-        assert!(format!(\"{:d}\", 55i).as_slice() == \"55\");\n-        assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n-        assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_zero() {\n-        assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:d}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:t}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n-        assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n-\n-        assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:u}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:t}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n-        assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_flags() {\n-        assert!(format!(\"{:3d}\", 1i).as_slice() == \"  1\");\n-        assert!(format!(\"{:>3d}\", 1i).as_slice() == \"  1\");\n-        assert!(format!(\"{:>+3d}\", 1i).as_slice() == \" +1\");\n-        assert!(format!(\"{:<3d}\", 1i).as_slice() == \"1  \");\n-        assert!(format!(\"{:#d}\", 1i).as_slice() == \"1\");\n-        assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n-        assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n-        assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n-        assert!(format!(\"{:#o}\", 10i).as_slice() == \"0o12\");\n-        assert!(format!(\"{:08x}\", 10i).as_slice() == \"0000000a\");\n-        assert!(format!(\"{:8x}\", 10i).as_slice() == \"       a\");\n-        assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n-        assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n-        assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n-        assert!(format!(\"{:08d}\", -10i).as_slice() == \"-0000010\");\n-        assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n-        assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n-        assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n-        assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n-        assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n-        assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n-        assert!(format!(\"{:#t}\", -1u8).as_slice() == \"0b11111111\");\n-        assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_sign_padding() {\n-        assert!(format!(\"{:+5d}\", 1i).as_slice() == \"   +1\");\n-        assert!(format!(\"{:+5d}\", -1i).as_slice() == \"   -1\");\n-        assert!(format!(\"{:05d}\", 1i).as_slice() == \"00001\");\n-        assert!(format!(\"{:05d}\", -1i).as_slice() == \"-0001\");\n-        assert!(format!(\"{:+05d}\", 1i).as_slice() == \"+0001\");\n-        assert!(format!(\"{:+05d}\", -1i).as_slice() == \"-0001\");\n-    }\n-\n-    #[test]\n-    fn test_format_int_twos_complement() {\n-        use {i8, i16, i32, i64};\n-        assert!(format!(\"{}\", i8::MIN).as_slice() == \"-128\");\n-        assert!(format!(\"{}\", i16::MIN).as_slice() == \"-32768\");\n-        assert!(format!(\"{}\", i32::MIN).as_slice() == \"-2147483648\");\n-        assert!(format!(\"{}\", i64::MIN).as_slice() == \"-9223372036854775808\");\n-    }\n-\n-    #[test]\n-    fn test_format_radix() {\n-        assert!(format!(\"{:04}\", radix(3i, 2)).as_slice() == \"0011\");\n-        assert!(format!(\"{}\", radix(55i, 36)).as_slice() == \"1j\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_radix_base_too_large() {\n-        let _ = radix(55i, 37);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    mod uint {\n-        use super::test::Bencher;\n-        use fmt::radix;\n-        use realstd::rand::{weak_rng, Rng};\n-\n-        #[bench]\n-        fn format_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n-        }\n-\n-        #[bench]\n-        fn format_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n-        }\n-    }\n-\n-    mod int {\n-        use super::test::Bencher;\n-        use fmt::radix;\n-        use realstd::rand::{weak_rng, Rng};\n-\n-        #[bench]\n-        fn format_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n-        }\n-\n-        #[bench]\n-        fn format_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n-            b.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n-        }\n-    }\n-}"}, {"sha": "161dd7cef7e13fc3efdde9818fb24ece8df3ec6d", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -44,14 +44,9 @@ A quick refresher on memory ordering:\n #![experimental]\n #![allow(missing_doc)]\n \n-// This is needed to prevent duplicate lang item definitions.\n-#[cfg(test)]\n-pub use realcore::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n-\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n-#[cfg(not(test))]\n pub struct TyDesc {\n     // sizeof(T)\n     pub size: uint,\n@@ -70,13 +65,11 @@ pub struct TyDesc {\n }\n \n #[lang=\"opaque\"]\n-#[cfg(not(test))]\n pub enum Opaque { }\n \n pub type Disr = u64;\n \n #[lang=\"ty_visitor\"]\n-#[cfg(not(test))]\n pub trait TyVisitor {\n     fn visit_bot(&mut self) -> bool;\n     fn visit_nil(&mut self) -> bool;\n@@ -564,12 +557,10 @@ extern \"rust-intrinsic\" {\n #[lang=\"type_id\"] // This needs to be kept in lockstep with the code in trans/intrinsic.rs and\n                   // middle/lang_items.rs\n #[deriving(PartialEq, Eq, Show)]\n-#[cfg(not(test))]\n pub struct TypeId {\n     t: u64,\n }\n \n-#[cfg(not(test))]\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n     pub fn of<T: 'static>() -> TypeId {"}, {"sha": "1445376d7db21615f2840dbf5865aebdc3847248", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 864, "changes": 865, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -2281,868 +2281,5 @@ pub mod order {\n             }\n         }\n     }\n-\n-    #[test]\n-    fn test_lt() {\n-        use slice::ImmutableVector;\n-\n-        let empty: [int, ..0] = [];\n-        let xs = [1i,2,3];\n-        let ys = [1i,2,0];\n-\n-        assert!(!lt(xs.iter(), ys.iter()));\n-        assert!(!le(xs.iter(), ys.iter()));\n-        assert!( gt(xs.iter(), ys.iter()));\n-        assert!( ge(xs.iter(), ys.iter()));\n-\n-        assert!( lt(ys.iter(), xs.iter()));\n-        assert!( le(ys.iter(), xs.iter()));\n-        assert!(!gt(ys.iter(), xs.iter()));\n-        assert!(!ge(ys.iter(), xs.iter()));\n-\n-        assert!( lt(empty.iter(), xs.iter()));\n-        assert!( le(empty.iter(), xs.iter()));\n-        assert!(!gt(empty.iter(), xs.iter()));\n-        assert!(!ge(empty.iter(), xs.iter()));\n-\n-        // Sequence with NaN\n-        let u = [1.0f64, 2.0];\n-        let v = [0.0f64/0.0, 3.0];\n-\n-        assert!(!lt(u.iter(), v.iter()));\n-        assert!(!le(u.iter(), v.iter()));\n-        assert!(!gt(u.iter(), v.iter()));\n-        assert!(!ge(u.iter(), v.iter()));\n-\n-        let a = [0.0f64/0.0];\n-        let b = [1.0f64];\n-        let c = [2.0f64];\n-\n-        assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n-        assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n-        assert!(gt(a.iter(), b.iter()) == (a[0] >  b[0]));\n-        assert!(ge(a.iter(), b.iter()) == (a[0] >= b[0]));\n-\n-        assert!(lt(c.iter(), b.iter()) == (c[0] <  b[0]));\n-        assert!(le(c.iter(), b.iter()) == (c[0] <= b[0]));\n-        assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n-        assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n-    }\n-\n-    #[test]\n-    fn test_multi_iter() {\n-        use slice::ImmutableVector;\n-        use iter::DoubleEndedIterator;\n-        let xs = [1i,2,3,4];\n-        let ys = [4i,3,2,1];\n-        assert!(eq(xs.iter(), ys.iter().rev()));\n-        assert!(lt(xs.iter(), xs.iter().skip(2)));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use iter::*;\n-    use num;\n-    use realstd::vec::Vec;\n-    use realstd::slice::Vector;\n-    use realstd::gc::GC;\n-\n-    use cmp;\n-    use realstd::owned::Box;\n-    use uint;\n-\n-    impl<T> FromIterator<T> for Vec<T> {\n-        fn from_iter<I: Iterator<T>>(mut iterator: I) -> Vec<T> {\n-            let mut v = Vec::new();\n-            for e in iterator {\n-                v.push(e);\n-            }\n-            return v;\n-        }\n-    }\n-\n-    impl<'a, T> Iterator<&'a T> for ::realcore::slice::Items<'a, T> {\n-        fn next(&mut self) -> Option<&'a T> {\n-            use RealSome = realcore::option::Some;\n-            use RealNone = realcore::option::None;\n-            fn mynext<T, I: ::realcore::iter::Iterator<T>>(i: &mut I)\n-                -> ::realcore::option::Option<T>\n-            {\n-                use realcore::iter::Iterator;\n-                i.next()\n-            }\n-            match mynext(self) {\n-                RealSome(t) => Some(t),\n-                RealNone => None,\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_counter_from_iter() {\n-        let it = count(0i, 5).take(10);\n-        let xs: Vec<int> = FromIterator::from_iter(it);\n-        assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n-    }\n-\n-    #[test]\n-    fn test_iterator_chain() {\n-        let xs = [0u, 1, 2, 3, 4, 5];\n-        let ys = [30u, 40, 50, 60];\n-        let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n-        let mut it = xs.iter().chain(ys.iter());\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, expected[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, expected.len());\n-\n-        let ys = count(30u, 10).take(4);\n-        let mut it = xs.iter().map(|&x| x).chain(ys);\n-        let mut i = 0;\n-        for x in it {\n-            assert_eq!(x, expected[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_filter_map() {\n-        let mut it = count(0u, 1u).take(10)\n-            .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n-    }\n-\n-    #[test]\n-    fn test_iterator_enumerate() {\n-        let xs = [0u, 1, 2, 3, 4, 5];\n-        let mut it = xs.iter().enumerate();\n-        for (i, &x) in it {\n-            assert_eq!(i, x);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_peekable() {\n-        let xs = vec![0u, 1, 2, 3, 4, 5];\n-        let mut it = xs.iter().map(|&x|x).peekable();\n-        assert_eq!(it.peek().unwrap(), &0);\n-        assert_eq!(it.next().unwrap(), 0);\n-        assert_eq!(it.next().unwrap(), 1);\n-        assert_eq!(it.next().unwrap(), 2);\n-        assert_eq!(it.peek().unwrap(), &3);\n-        assert_eq!(it.peek().unwrap(), &3);\n-        assert_eq!(it.next().unwrap(), 3);\n-        assert_eq!(it.next().unwrap(), 4);\n-        assert_eq!(it.peek().unwrap(), &5);\n-        assert_eq!(it.next().unwrap(), 5);\n-        assert!(it.peek().is_none());\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_iterator_take_while() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [0u, 1, 2, 3, 5, 13];\n-        let mut it = xs.iter().take_while(|&x| *x < 15u);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_skip_while() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [15, 16, 17, 19];\n-        let mut it = xs.iter().skip_while(|&x| *x < 15u);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_skip() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n-        let ys = [13, 15, 16, 17, 19, 20, 30];\n-        let mut it = xs.iter().skip(5);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_take() {\n-        let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n-        let ys = [0u, 1, 2, 3, 5];\n-        let mut it = xs.iter().take(5);\n-        let mut i = 0;\n-        for &x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_scan() {\n-        // test the type inference\n-        fn add(old: &mut int, new: &uint) -> Option<f64> {\n-            *old += *new as int;\n-            Some(*old as f64)\n-        }\n-        let xs = [0u, 1, 2, 3, 4];\n-        let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n-\n-        let mut it = xs.iter().scan(0, add);\n-        let mut i = 0;\n-        for x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_iterator_flat_map() {\n-        let xs = [0u, 3, 6];\n-        let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n-        let mut i = 0;\n-        for x in it {\n-            assert_eq!(x, ys[i]);\n-            i += 1;\n-        }\n-        assert_eq!(i, ys.len());\n-    }\n-\n-    #[test]\n-    fn test_inspect() {\n-        let xs = [1u, 2, 3, 4];\n-        let mut n = 0;\n-\n-        let ys = xs.iter()\n-                   .map(|&x| x)\n-                   .inspect(|_| n += 1)\n-                   .collect::<Vec<uint>>();\n-\n-        assert_eq!(n, xs.len());\n-        assert_eq!(xs.as_slice(), ys.as_slice());\n-    }\n-\n-    #[test]\n-    fn test_unfoldr() {\n-        fn count(st: &mut uint) -> Option<uint> {\n-            if *st < 10 {\n-                let ret = Some(*st);\n-                *st += 1;\n-                ret\n-            } else {\n-                None\n-            }\n-        }\n-\n-        let mut it = Unfold::new(0, count);\n-        let mut i = 0;\n-        for counted in it {\n-            assert_eq!(counted, i);\n-            i += 1;\n-        }\n-        assert_eq!(i, 10);\n-    }\n-\n-    #[test]\n-    fn test_cycle() {\n-        let cycle_len = 3;\n-        let it = count(0u, 1).take(cycle_len).cycle();\n-        assert_eq!(it.size_hint(), (uint::MAX, None));\n-        for (i, x) in it.take(100).enumerate() {\n-            assert_eq!(i % cycle_len, x);\n-        }\n-\n-        let mut it = count(0u, 1).take(0).cycle();\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_nth() {\n-        let v = &[0i, 1, 2, 3, 4];\n-        for i in range(0u, v.len()) {\n-            assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iterator_last() {\n-        let v = &[0i, 1, 2, 3, 4];\n-        assert_eq!(v.iter().last().unwrap(), &4);\n-        assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n-    }\n-\n-    #[test]\n-    fn test_iterator_len() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().count(), 4);\n-        assert_eq!(v.slice(0, 10).iter().count(), 10);\n-        assert_eq!(v.slice(0, 0).iter().count(), 0);\n-    }\n-\n-    #[test]\n-    fn test_iterator_sum() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n-        assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n-    }\n-\n-    #[test]\n-    fn test_iterator_product() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n-        assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n-    }\n-\n-    #[test]\n-    fn test_iterator_max() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n-        assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_min() {\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n-        assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-        assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n-    }\n-\n-    #[test]\n-    fn test_iterator_size_hint() {\n-        let c = count(0i, 1);\n-        let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-        let v2 = &[10i, 11, 12];\n-        let vi = v.iter();\n-\n-        assert_eq!(c.size_hint(), (uint::MAX, None));\n-        assert_eq!(vi.size_hint(), (10, Some(10)));\n-\n-        assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n-        assert_eq!(c.skip(5).size_hint().val1(), None);\n-        assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n-        assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n-        assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n-        assert_eq!(c.scan(0i, |_,_| Some(0i)).size_hint(), (0, None));\n-        assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.map(|_| 0i).size_hint(), (uint::MAX, None));\n-        assert_eq!(c.filter_map(|_| Some(0i)).size_hint(), (0, None));\n-\n-        assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n-        assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n-        assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n-        assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n-        assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n-        assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n-        assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n-        assert_eq!(vi.scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.map(|i| i+1).size_hint(), (10, Some(10)));\n-        assert_eq!(vi.filter_map(|_| Some(0i)).size_hint(), (0, Some(10)));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let a = vec![1i, 2, 3, 4, 5];\n-        let b: Vec<int> = a.iter().map(|&x| x).collect();\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_all() {\n-        let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n-        assert!(v.iter().all(|&x| x < 10));\n-        assert!(!v.iter().all(|&x| x % 2 == 0));\n-        assert!(!v.iter().all(|&x| x > 100));\n-        assert!(v.slice(0, 0).iter().all(|_| fail!()));\n-    }\n-\n-    #[test]\n-    fn test_any() {\n-        let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n-        assert!(v.iter().any(|&x| x < 10));\n-        assert!(v.iter().any(|&x| x % 2 == 0));\n-        assert!(!v.iter().any(|&x| x > 100));\n-        assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n-        assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n-        assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n-    }\n-\n-    #[test]\n-    fn test_position() {\n-        let v = &[1i, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n-        assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n-        assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n-    }\n-\n-    #[test]\n-    fn test_count() {\n-        let xs = &[1i, 2, 2, 1, 5, 9, 0, 2];\n-        assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n-        assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n-        assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n-    }\n-\n-    #[test]\n-    fn test_max_by() {\n-        let xs: &[int] = &[-3i, 0, 1, 5, -10];\n-        assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n-    }\n-\n-    #[test]\n-    fn test_min_by() {\n-        let xs: &[int] = &[-3i, 0, 1, 5, -10];\n-        assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_by_ref() {\n-        let mut xs = range(0i, 10);\n-        // sum the first five values\n-        let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n-        assert_eq!(partial_sum, 10);\n-        assert_eq!(xs.next(), Some(5));\n-    }\n-\n-    #[test]\n-    fn test_rev() {\n-        let xs = [2i, 4, 6, 8, 10, 12, 14, 16];\n-        let mut it = xs.iter();\n-        it.next();\n-        it.next();\n-        assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n-                vec![16, 14, 12, 10, 8, 6]);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_map() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().map(|&x| x * -1);\n-        assert_eq!(it.next(), Some(-1));\n-        assert_eq!(it.next(), Some(-2));\n-        assert_eq!(it.next_back(), Some(-6));\n-        assert_eq!(it.next_back(), Some(-5));\n-        assert_eq!(it.next(), Some(-3));\n-        assert_eq!(it.next_back(), Some(-4));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_enumerate() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().map(|&x| x).enumerate();\n-        assert_eq!(it.next(), Some((0, 1)));\n-        assert_eq!(it.next(), Some((1, 2)));\n-        assert_eq!(it.next_back(), Some((5, 6)));\n-        assert_eq!(it.next_back(), Some((4, 5)));\n-        assert_eq!(it.next_back(), Some((3, 4)));\n-        assert_eq!(it.next_back(), Some((2, 3)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_zip() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let ys = [1i, 2, 3, 7];\n-        let a = xs.iter().map(|&x| x);\n-        let b = ys.iter().map(|&x| x);\n-        let mut it = a.zip(b);\n-        assert_eq!(it.next(), Some((1, 1)));\n-        assert_eq!(it.next(), Some((2, 2)));\n-        assert_eq!(it.next_back(), Some((4, 7)));\n-        assert_eq!(it.next_back(), Some((3, 3)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_filter() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n-        assert_eq!(it.next_back().unwrap(), &6);\n-        assert_eq!(it.next_back().unwrap(), &4);\n-        assert_eq!(it.next().unwrap(), &2);\n-        assert_eq!(it.next_back(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_filter_map() {\n-        let xs = [1i, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n-        assert_eq!(it.next_back().unwrap(), 12);\n-        assert_eq!(it.next_back().unwrap(), 8);\n-        assert_eq!(it.next().unwrap(), 4);\n-        assert_eq!(it.next_back(), None);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_chain() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let ys = [7i, 9, 11];\n-        let mut it = xs.iter().chain(ys.iter()).rev();\n-        assert_eq!(it.next().unwrap(), &11)\n-        assert_eq!(it.next().unwrap(), &9)\n-        assert_eq!(it.next_back().unwrap(), &1)\n-        assert_eq!(it.next_back().unwrap(), &2)\n-        assert_eq!(it.next_back().unwrap(), &3)\n-        assert_eq!(it.next_back().unwrap(), &4)\n-        assert_eq!(it.next_back().unwrap(), &5)\n-        assert_eq!(it.next_back().unwrap(), &7)\n-        assert_eq!(it.next_back(), None)\n-    }\n-\n-    #[test]\n-    fn test_rposition() {\n-        fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-        fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = [(0i, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n-\n-        assert_eq!(v.iter().rposition(f), Some(3u));\n-        assert!(v.iter().rposition(g).is_none());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_rposition_fail() {\n-        let v = [(box 0i, box(GC) 0i), (box 0i, box(GC) 0i),\n-                 (box 0i, box(GC) 0i), (box 0i, box(GC) 0i)];\n-        let mut i = 0i;\n-        v.iter().rposition(|_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 1;\n-            false\n-        });\n-    }\n-\n-\n-    #[cfg(test)]\n-    fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n-    {\n-        let mut b = a.clone();\n-        assert_eq!(len, b.indexable());\n-        let mut n = 0u;\n-        for (i, elt) in a.enumerate() {\n-            assert!(Some(elt) == b.idx(i));\n-            n += 1;\n-        }\n-        assert_eq!(n, len);\n-        assert!(None == b.idx(n));\n-        // call recursively to check after picking off an element\n-        if len > 0 {\n-            b.next();\n-            check_randacc_iter(b, len-1);\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_double_ended_flat_map() {\n-        let u = [0u,1];\n-        let v = [5u,6,7,8];\n-        let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n-        assert_eq!(it.next_back().unwrap(), &8);\n-        assert_eq!(it.next().unwrap(),      &5);\n-        assert_eq!(it.next_back().unwrap(), &7);\n-        assert_eq!(it.next_back().unwrap(), &6);\n-        assert_eq!(it.next_back().unwrap(), &8);\n-        assert_eq!(it.next().unwrap(),      &6);\n-        assert_eq!(it.next_back().unwrap(), &7);\n-        assert_eq!(it.next_back(), None);\n-        assert_eq!(it.next(),      None);\n-        assert_eq!(it.next_back(), None);\n-    }\n-\n-    #[test]\n-    fn test_random_access_chain() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let ys = [7i, 9, 11];\n-        let mut it = xs.iter().chain(ys.iter());\n-        assert_eq!(it.idx(0).unwrap(), &1);\n-        assert_eq!(it.idx(5).unwrap(), &7);\n-        assert_eq!(it.idx(7).unwrap(), &11);\n-        assert!(it.idx(8).is_none());\n-\n-        it.next();\n-        it.next();\n-        it.next_back();\n-\n-        assert_eq!(it.idx(0).unwrap(), &3);\n-        assert_eq!(it.idx(4).unwrap(), &9);\n-        assert!(it.idx(6).is_none());\n-\n-        check_randacc_iter(it, xs.len() + ys.len() - 3);\n-    }\n-\n-    #[test]\n-    fn test_random_access_enumerate() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        check_randacc_iter(xs.iter().enumerate(), xs.len());\n-    }\n-\n-    #[test]\n-    fn test_random_access_rev() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        check_randacc_iter(xs.iter().rev(), xs.len());\n-        let mut it = xs.iter().rev();\n-        it.next();\n-        it.next_back();\n-        it.next();\n-        check_randacc_iter(it, xs.len() - 3);\n-    }\n-\n-    #[test]\n-    fn test_random_access_zip() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let ys = [7i, 9, 11];\n-        check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n-    }\n-\n-    #[test]\n-    fn test_random_access_take() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().take(3), 3);\n-        check_randacc_iter(xs.iter().take(20), xs.len());\n-        check_randacc_iter(xs.iter().take(0), 0);\n-        check_randacc_iter(empty.iter().take(2), 0);\n-    }\n-\n-    #[test]\n-    fn test_random_access_skip() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n-        check_randacc_iter(empty.iter().skip(2), 0);\n-    }\n-\n-    #[test]\n-    fn test_random_access_inspect() {\n-        let xs = [1i, 2, 3, 4, 5];\n-\n-        // test .map and .inspect that don't implement Clone\n-        let mut it = xs.iter().inspect(|_| {});\n-        assert_eq!(xs.len(), it.indexable());\n-        for (i, elt) in xs.iter().enumerate() {\n-            assert_eq!(Some(elt), it.idx(i));\n-        }\n-\n-    }\n-\n-    #[test]\n-    fn test_random_access_map() {\n-        let xs = [1i, 2, 3, 4, 5];\n-\n-        let mut it = xs.iter().map(|x| *x);\n-        assert_eq!(xs.len(), it.indexable());\n-        for (i, elt) in xs.iter().enumerate() {\n-            assert_eq!(Some(*elt), it.idx(i));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_random_access_cycle() {\n-        let xs = [1i, 2, 3, 4, 5];\n-        let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().cycle().take(27), 27);\n-        check_randacc_iter(empty.iter().cycle(), 0);\n-    }\n-\n-    #[test]\n-    fn test_double_ended_range() {\n-        assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n-        for _ in range(10i, 0).rev() {\n-            fail!(\"unreachable\");\n-        }\n-\n-        assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n-        for _ in range(10u, 0).rev() {\n-            fail!(\"unreachable\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_range() {\n-        /// A mock type to check Range when ToPrimitive returns None\n-        struct Foo;\n-\n-        impl ToPrimitive for Foo {\n-            fn to_i64(&self) -> Option<i64> { None }\n-            fn to_u64(&self) -> Option<u64> { None }\n-        }\n-\n-        impl Add<Foo, Foo> for Foo {\n-            fn add(&self, _: &Foo) -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        impl PartialEq for Foo {\n-            fn eq(&self, _: &Foo) -> bool {\n-                true\n-            }\n-        }\n-\n-        impl PartialOrd for Foo {\n-            fn lt(&self, _: &Foo) -> bool {\n-                false\n-            }\n-        }\n-\n-        impl Clone for Foo {\n-            fn clone(&self) -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        impl Mul<Foo, Foo> for Foo {\n-            fn mul(&self, _: &Foo) -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        impl num::One for Foo {\n-            fn one() -> Foo {\n-                Foo\n-            }\n-        }\n-\n-        assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n-        assert!(range(-10i, -1).collect::<Vec<int>>() ==\n-                   vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n-        assert_eq!(range(200i, -5).count(), 0);\n-        assert_eq!(range(200i, -5).rev().count(), 0);\n-        assert_eq!(range(200i, 200).count(), 0);\n-        assert_eq!(range(200i, 200).rev().count(), 0);\n-\n-        assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n-        // this test is only meaningful when sizeof uint < sizeof u64\n-        assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n-        assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n-        assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n-    }\n-\n-    #[test]\n-    fn test_range_inclusive() {\n-        assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n-                vec![0i, 1, 2, 3, 4, 5]);\n-        assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n-                vec![5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200i, -5).count(), 0);\n-        assert_eq!(range_inclusive(200i, -5).rev().count(), 0);\n-        assert!(range_inclusive(200i, 200).collect::<Vec<int>>() == vec![200]);\n-        assert!(range_inclusive(200i, 200).rev().collect::<Vec<int>>() == vec![200]);\n-    }\n-\n-    #[test]\n-    fn test_range_step() {\n-        assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n-                vec![0, 5, 10, 15]);\n-        assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n-                vec![20, 15, 10, 5]);\n-        assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n-                vec![20, 14, 8, 2]);\n-        assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n-                vec![200u8, 250]);\n-        assert!(range_step(200i, -5, 1).collect::<Vec<int>>() == vec![]);\n-        assert!(range_step(200i, 200, 1).collect::<Vec<int>>() == vec![]);\n-    }\n-\n-    #[test]\n-    fn test_range_step_inclusive() {\n-        assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n-                vec![0, 5, 10, 15, 20]);\n-        assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n-                vec![20, 15, 10, 5, 0]);\n-        assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n-                vec![20, 14, 8, 2]);\n-        assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n-                vec![200u8, 250]);\n-        assert!(range_step_inclusive(200i, -5, 1).collect::<Vec<int>>() ==\n-                vec![]);\n-        assert!(range_step_inclusive(200i, 200, 1).collect::<Vec<int>>() ==\n-                vec![200]);\n-    }\n-\n-    #[test]\n-    fn test_reverse() {\n-        let mut ys = [1i, 2, 3, 4, 5];\n-        ys.mut_iter().reverse_();\n-        assert!(ys == [5, 4, 3, 2, 1]);\n-    }\n-\n-    #[test]\n-    fn test_peekable_is_empty() {\n-        let a = [1i];\n-        let mut it = a.iter().peekable();\n-        assert!( !it.is_empty() );\n-        it.next();\n-        assert!( it.is_empty() );\n-    }\n-\n-    #[test]\n-    fn test_min_max() {\n-        let v: [int, ..0] = [];\n-        assert_eq!(v.iter().min_max(), NoElements);\n-\n-        let v = [1i];\n-        assert!(v.iter().min_max() == OneElement(&1));\n-\n-        let v = [1i, 2, 3, 4, 5];\n-        assert!(v.iter().min_max() == MinMax(&1, &5));\n-\n-        let v = [1i, 2, 3, 4, 5, 6];\n-        assert!(v.iter().min_max() == MinMax(&1, &6));\n-\n-        let v = [1i, 1, 1, 1];\n-        assert!(v.iter().min_max() == MinMax(&1, &1));\n-    }\n-\n-    #[test]\n-    fn test_min_max_result() {\n-        let r: MinMaxResult<int> = NoElements;\n-        assert_eq!(r.into_option(), None)\n-\n-        let r = OneElement(1i);\n-        assert_eq!(r.into_option(), Some((1,1)));\n-\n-        let r = MinMax(1i,2);\n-        assert_eq!(r.into_option(), Some((1,2)));\n-    }\n }\n+"}, {"sha": "385a33fb92a4c67cd02d71ecd26acb5d3813fc96", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -43,7 +43,9 @@\n //!   the failure message, the file at which failure was invoked, and the line.\n //!   It is up to consumers of this core library to define this failure\n //!   function; it is only required to never return.\n-//!\n+\n+// Since libcore defines many fundamental lang items, all tests live in a\n+// separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_id = \"core#0.11.0-pre\"]\n #![experimental]\n@@ -59,16 +61,6 @@\n #![feature(simd, unsafe_destructor)]\n #![deny(missing_doc)]\n \n-#[cfg(test)] extern crate realcore = \"core\";\n-#[cfg(test)] extern crate libc;\n-#[cfg(test)] extern crate native;\n-#[cfg(test)] extern crate realstd = \"std\";\n-\n-#[cfg(test)] pub use cmp = realcore::cmp;\n-#[cfg(test)] pub use kinds = realcore::kinds;\n-#[cfg(test)] pub use ops = realcore::ops;\n-#[cfg(test)] pub use ty = realcore::ty;\n-\n mod macros;\n \n #[path = \"num/float_macros.rs\"] mod float_macros;\n@@ -104,10 +96,10 @@ pub mod ptr;\n \n /* Core language traits */\n \n-#[cfg(not(test))] pub mod kinds;\n-#[cfg(not(test))] pub mod ops;\n-#[cfg(not(test))] pub mod ty;\n-#[cfg(not(test))] pub mod cmp;\n+pub mod kinds;\n+pub mod ops;\n+pub mod ty;\n+pub mod cmp;\n pub mod clone;\n pub mod default;\n pub mod collections;\n@@ -144,11 +136,4 @@ mod std {\n     pub use kinds;\n     pub use option;\n     pub use fmt;\n-\n-    #[cfg(test)] pub use realstd::rt;     // needed for fail!()\n-    // #[cfg(test)] pub use realstd::option; // needed for fail!()\n-    // #[cfg(test)] pub use realstd::fmt;    // needed for fail!()\n-    #[cfg(test)] pub use realstd::os;     // needed for tests\n-    #[cfg(test)] pub use realstd::slice;  // needed for tests\n-    #[cfg(test)] pub use realstd::vec;    // needed for vec![]\n }"}, {"sha": "93c838198c559b60792b945f2f49cfa68af86089", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -112,16 +112,6 @@ macro_rules! writeln(\n     )\n )\n \n-#[cfg(test)]\n-macro_rules! vec( ($($e:expr),*) => ({\n-    let mut _v = ::std::vec::Vec::new();\n-    $(_v.push($e);)*\n-    _v\n-}) )\n-\n-#[cfg(test)]\n-macro_rules! format( ($($arg:tt)*) => (format_args!(::fmt::format, $($arg)*)) )\n-\n /// Write some formatted data into a stream.\n ///\n /// Identical to the macro in `std::macros`"}, {"sha": "06e28816c1cd5015cca5bb4901b6c258f10d500b", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -382,182 +382,3 @@ pub unsafe fn copy_mut_lifetime<'a, S, T>(_ptr: &'a mut S,\n                                           ptr: &mut T) -> &'a mut T {\n     transmute(ptr)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use mem::*;\n-    use option::{Some,None};\n-    use realstd::str::StrAllocating;\n-    use realstd::owned::Box;\n-    use realstd::vec::Vec;\n-    use raw;\n-\n-    #[test]\n-    fn size_of_basic() {\n-        assert_eq!(size_of::<u8>(), 1u);\n-        assert_eq!(size_of::<u16>(), 2u);\n-        assert_eq!(size_of::<u32>(), 4u);\n-        assert_eq!(size_of::<u64>(), 8u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"mipsel\")]\n-    fn size_of_32() {\n-        assert_eq!(size_of::<uint>(), 4u);\n-        assert_eq!(size_of::<*const uint>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn size_of_64() {\n-        assert_eq!(size_of::<uint>(), 8u);\n-        assert_eq!(size_of::<*const uint>(), 8u);\n-    }\n-\n-    #[test]\n-    fn size_of_val_basic() {\n-        assert_eq!(size_of_val(&1u8), 1);\n-        assert_eq!(size_of_val(&1u16), 2);\n-        assert_eq!(size_of_val(&1u32), 4);\n-        assert_eq!(size_of_val(&1u64), 8);\n-    }\n-\n-    #[test]\n-    fn align_of_basic() {\n-        assert_eq!(align_of::<u8>(), 1u);\n-        assert_eq!(align_of::<u16>(), 2u);\n-        assert_eq!(align_of::<u32>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"arm\")]\n-    #[cfg(target_arch = \"mips\")]\n-    #[cfg(target_arch = \"mipsel\")]\n-    fn align_of_32() {\n-        assert_eq!(align_of::<uint>(), 4u);\n-        assert_eq!(align_of::<*const uint>(), 4u);\n-    }\n-\n-    #[test]\n-    #[cfg(target_arch = \"x86_64\")]\n-    fn align_of_64() {\n-        assert_eq!(align_of::<uint>(), 8u);\n-        assert_eq!(align_of::<*const uint>(), 8u);\n-    }\n-\n-    #[test]\n-    fn align_of_val_basic() {\n-        assert_eq!(align_of_val(&1u8), 1u);\n-        assert_eq!(align_of_val(&1u16), 2u);\n-        assert_eq!(align_of_val(&1u32), 4u);\n-    }\n-\n-    #[test]\n-    fn test_swap() {\n-        let mut x = 31337i;\n-        let mut y = 42i;\n-        swap(&mut x, &mut y);\n-        assert_eq!(x, 42);\n-        assert_eq!(y, 31337);\n-    }\n-\n-    #[test]\n-    fn test_replace() {\n-        let mut x = Some(\"test\".to_string());\n-        let y = replace(&mut x, None);\n-        assert!(x.is_none());\n-        assert!(y.is_some());\n-    }\n-\n-    #[test]\n-    fn test_transmute_copy() {\n-        assert_eq!(1u, unsafe { ::mem::transmute_copy(&1i) });\n-    }\n-\n-    #[test]\n-    fn test_transmute() {\n-        trait Foo {}\n-        impl Foo for int {}\n-\n-        let a = box 100i as Box<Foo>;\n-        unsafe {\n-            let x: raw::TraitObject = transmute(a);\n-            assert!(*(x.data as *const int) == 100);\n-            let _x: Box<Foo> = transmute(x);\n-        }\n-\n-        unsafe {\n-            assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n-        }\n-    }\n-}\n-\n-// FIXME #13642 (these benchmarks should be in another place)\n-/// Completely miscellaneous language-construct benchmarks.\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use option::{Some,None};\n-\n-    // Static/dynamic method dispatch\n-\n-    struct Struct {\n-        field: int\n-    }\n-\n-    trait Trait {\n-        fn method(&self) -> int;\n-    }\n-\n-    impl Trait for Struct {\n-        fn method(&self) -> int {\n-            self.field\n-        }\n-    }\n-\n-    #[bench]\n-    fn trait_vtable_method_call(b: &mut Bencher) {\n-        let s = Struct { field: 10 };\n-        let t = &s as &Trait;\n-        b.iter(|| {\n-            t.method()\n-        });\n-    }\n-\n-    #[bench]\n-    fn trait_static_method_call(b: &mut Bencher) {\n-        let s = Struct { field: 10 };\n-        b.iter(|| {\n-            s.method()\n-        });\n-    }\n-\n-    // Overhead of various match forms\n-\n-    #[bench]\n-    fn match_option_some(b: &mut Bencher) {\n-        let x = Some(10i);\n-        b.iter(|| {\n-            match x {\n-                Some(y) => y,\n-                None => 11\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn match_vec_pattern(b: &mut Bencher) {\n-        let x = [1i,2,3,4,5,6];\n-        b.iter(|| {\n-            match x {\n-                [1,2,3,..] => 10i,\n-                _ => 11i,\n-            }\n-        });\n-    }\n-}"}, {"sha": "ff0494725f849316f04c5bf6b60f3b394777c577", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -32,152 +32,4 @@ pub static MIN: $T = (-1 as $T) << (BITS - 1);\n #[unstable]\n pub static MAX: $T = !MIN;\n \n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    use int;\n-    use num;\n-    use num::CheckedDiv;\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    pub fn test_abs() {\n-        assert!((1 as $T).abs() == 1 as $T);\n-        assert!((0 as $T).abs() == 0 as $T);\n-        assert!((-1 as $T).abs() == 1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n-        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n-        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n-        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert!((1 as $T).signum() == 1 as $T);\n-        assert!((0 as $T).signum() == 0 as $T);\n-        assert!((-0 as $T).signum() == 0 as $T);\n-        assert!((-1 as $T).signum() == -1 as $T);\n-    }\n-\n-    #[test]\n-    fn test_is_positive() {\n-        assert!((1 as $T).is_positive());\n-        assert!(!(0 as $T).is_positive());\n-        assert!(!(-0 as $T).is_positive());\n-        assert!(!(-1 as $T).is_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_negative() {\n-        assert!(!(1 as $T).is_negative());\n-        assert!(!(0 as $T).is_negative());\n-        assert!(!(-0 as $T).is_negative());\n-        assert!((-1 as $T).is_negative());\n-    }\n-\n-    #[test]\n-    fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n-        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n-    }\n-\n-    static A: $T = 0b0101100;\n-    static B: $T = 0b0100001;\n-    static C: $T = 0b1111001;\n-\n-    static _0: $T = 0;\n-    static _1: $T = !0;\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert!(A.count_zeros() == BITS as $T - 3);\n-        assert!(B.count_zeros() == BITS as $T - 2);\n-        assert!(C.count_zeros() == BITS as $T - 5);\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n-        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n-        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n-\n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        assert_eq!(_0.rotate_left(124), _0);\n-        assert_eq!(_1.rotate_left(124), _1);\n-        assert_eq!(_0.rotate_right(124), _0);\n-        assert_eq!(_1.rotate_right(124), _1);\n-    }\n-\n-    #[test]\n-    fn test_swap_bytes() {\n-        assert_eq!(A.swap_bytes().swap_bytes(), A);\n-        assert_eq!(B.swap_bytes().swap_bytes(), B);\n-        assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.swap_bytes(), _0);\n-        assert_eq!(_1.swap_bytes(), _1);\n-    }\n-\n-    #[test]\n-    fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n-        assert_eq!(_0.to_le(), _0);\n-        assert_eq!(_1.to_le(), _1);\n-    }\n-\n-    #[test]\n-    fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n-        assert_eq!(_0.to_be(), _0);\n-        assert_eq!(_1.to_be(), _1);\n-    }\n-\n-    #[test]\n-    fn test_signed_checked_div() {\n-        assert!(10i.checked_div(&2) == Some(5));\n-        assert!(5i.checked_div(&0) == None);\n-        assert!(int::MIN.checked_div(&-1) == None);\n-    }\n-}\n-\n ))"}, {"sha": "b32e4167da1d45e90517b74a4e36b0a55af6791b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -1375,22 +1375,6 @@ macro_rules! checkeddiv_uint_impl(\n \n checkeddiv_uint_impl!(uint u8 u16 u32 u64)\n \n-/// Helper function for testing numeric operations\n-#[cfg(test)]\n-pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n-    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n-    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n-    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n-    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n-    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n-\n-    assert_eq!(ten.add(&two),  ten + two);\n-    assert_eq!(ten.sub(&two),  ten - two);\n-    assert_eq!(ten.mul(&two),  ten * two);\n-    assert_eq!(ten.div(&two),  ten / two);\n-    assert_eq!(ten.rem(&two),  ten % two);\n-}\n-\n /// Used for representing the classification of floating point numbers\n #[deriving(PartialEq, Show)]\n pub enum FPCategory {"}, {"sha": "b0c570af04ac0f1fc664d08509458f4bc2407d26", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -23,111 +23,4 @@ pub static MIN: $T = 0 as $T;\n #[unstable]\n pub static MAX: $T = 0 as $T - 1 as $T;\n \n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-\n-    use num;\n-    use num::CheckedDiv;\n-\n-    #[test]\n-    fn test_overflows() {\n-        assert!(MAX > 0);\n-        assert!(MIN <= 0);\n-        assert!(MIN + MAX + 1 == 0);\n-    }\n-\n-    #[test]\n-    fn test_num() {\n-        num::test_num(10 as $T, 2 as $T);\n-    }\n-\n-    #[test]\n-    fn test_bitwise_operators() {\n-        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n-        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n-        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n-        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n-        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n-        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n-    }\n-\n-    static A: $T = 0b0101100;\n-    static B: $T = 0b0100001;\n-    static C: $T = 0b1111001;\n-\n-    static _0: $T = 0;\n-    static _1: $T = !0;\n-\n-    #[test]\n-    fn test_count_ones() {\n-        assert!(A.count_ones() == 3);\n-        assert!(B.count_ones() == 2);\n-        assert!(C.count_ones() == 5);\n-    }\n-\n-    #[test]\n-    fn test_count_zeros() {\n-        assert!(A.count_zeros() == BITS as $T - 3);\n-        assert!(B.count_zeros() == BITS as $T - 2);\n-        assert!(C.count_zeros() == BITS as $T - 5);\n-    }\n-\n-    #[test]\n-    fn test_rotate() {\n-        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n-        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n-        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n-\n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        assert_eq!(_0.rotate_left(124), _0);\n-        assert_eq!(_1.rotate_left(124), _1);\n-        assert_eq!(_0.rotate_right(124), _0);\n-        assert_eq!(_1.rotate_right(124), _1);\n-    }\n-\n-    #[test]\n-    fn test_swap_bytes() {\n-        assert_eq!(A.swap_bytes().swap_bytes(), A);\n-        assert_eq!(B.swap_bytes().swap_bytes(), B);\n-        assert_eq!(C.swap_bytes().swap_bytes(), C);\n-\n-        // Swapping these should make no difference\n-        assert_eq!(_0.swap_bytes(), _0);\n-        assert_eq!(_1.swap_bytes(), _1);\n-    }\n-\n-    #[test]\n-    fn test_le() {\n-        assert_eq!(Int::from_le(A.to_le()), A);\n-        assert_eq!(Int::from_le(B.to_le()), B);\n-        assert_eq!(Int::from_le(C.to_le()), C);\n-        assert_eq!(Int::from_le(_0), _0);\n-        assert_eq!(Int::from_le(_1), _1);\n-        assert_eq!(_0.to_le(), _0);\n-        assert_eq!(_1.to_le(), _1);\n-    }\n-\n-    #[test]\n-    fn test_be() {\n-        assert_eq!(Int::from_be(A.to_be()), A);\n-        assert_eq!(Int::from_be(B.to_be()), B);\n-        assert_eq!(Int::from_be(C.to_be()), C);\n-        assert_eq!(Int::from_be(_0), _0);\n-        assert_eq!(Int::from_be(_1), _1);\n-        assert_eq!(_0.to_be(), _0);\n-        assert_eq!(_1.to_be(), _1);\n-    }\n-\n-    #[test]\n-    fn test_unsigned_checked_div() {\n-        assert!(10u.checked_div(&2) == Some(5));\n-        assert!(5u.checked_div(&0) == None);\n-    }\n-}\n-\n ))"}, {"sha": "d42c09b8163dd1d6159264109b8ae85847f84d58", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -117,7 +117,6 @@ pub trait Add<RHS,Result> {\n \n macro_rules! add_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Add<$t, $t> for $t {\n             #[inline]\n             fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n@@ -159,7 +158,6 @@ pub trait Sub<RHS,Result> {\n \n macro_rules! sub_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Sub<$t, $t> for $t {\n             #[inline]\n             fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n@@ -201,7 +199,6 @@ pub trait Mul<RHS,Result> {\n \n macro_rules! mul_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Mul<$t, $t> for $t {\n             #[inline]\n             fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n@@ -243,7 +240,6 @@ pub trait Div<RHS,Result> {\n \n macro_rules! div_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Div<$t, $t> for $t {\n             #[inline]\n             fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n@@ -285,7 +281,6 @@ pub trait Rem<RHS,Result> {\n \n macro_rules! rem_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Rem<$t, $t> for $t {\n             #[inline]\n             fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n@@ -295,7 +290,6 @@ macro_rules! rem_impl(\n \n macro_rules! rem_float_impl(\n     ($t:ty, $fmod:ident) => {\n-        #[cfg(not(test))]\n         impl Rem<$t, $t> for $t {\n             #[inline]\n             fn rem(&self, other: &$t) -> $t {\n@@ -342,7 +336,6 @@ pub trait Neg<Result> {\n \n macro_rules! neg_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Neg<$t> for $t {\n             #[inline]\n             fn neg(&self) -> $t { -*self }\n@@ -352,7 +345,6 @@ macro_rules! neg_impl(\n \n macro_rules! neg_uint_impl(\n     ($t:ty, $t_signed:ty) => {\n-        #[cfg(not(test))]\n         impl Neg<$t> for $t {\n             #[inline]\n             fn neg(&self) -> $t { -(*self as $t_signed) as $t }\n@@ -402,7 +394,6 @@ pub trait Not<Result> {\n \n macro_rules! not_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl Not<$t> for $t {\n             #[inline]\n             fn not(&self) -> $t { !*self }\n@@ -444,7 +435,6 @@ pub trait BitAnd<RHS,Result> {\n \n macro_rules! bitand_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl BitAnd<$t, $t> for $t {\n             #[inline]\n             fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n@@ -486,7 +476,6 @@ pub trait BitOr<RHS,Result> {\n \n macro_rules! bitor_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl BitOr<$t,$t> for $t {\n             #[inline]\n             fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n@@ -528,7 +517,6 @@ pub trait BitXor<RHS,Result> {\n \n macro_rules! bitxor_impl(\n     ($($t:ty)*) => ($(\n-        #[cfg(not(test))]\n         impl BitXor<$t, $t> for $t {\n             #[inline]\n             fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n@@ -746,28 +734,3 @@ pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used.\n     fn call_once(self, args: Args) -> Result;\n }\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use ops::Drop;\n-\n-    // Overhead of dtors\n-\n-    struct HasDtor {\n-        x: int\n-    }\n-\n-    impl Drop for HasDtor {\n-        fn drop(&mut self) {\n-        }\n-    }\n-\n-    #[bench]\n-    fn alloc_obj_with_dtor(b: &mut Bencher) {\n-        b.iter(|| {\n-            HasDtor { x : 10 };\n-        })\n-    }\n-}"}, {"sha": "c0d04ee0b95fdb41aac5c75f8b1be4b343b3abd0", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 288, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -606,291 +606,3 @@ pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) ->\n         Some(v)\n     }\n }\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Tests\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use realstd::vec::Vec;\n-    use realstd::string::String;\n-    use option::collect;\n-    use prelude::*;\n-    use realstd::str::{Str, StrAllocating};\n-    use iter::range;\n-\n-    use str::StrSlice;\n-    use kinds::marker;\n-    use slice::ImmutableVector;\n-\n-    #[test]\n-    fn test_get_ptr() {\n-        unsafe {\n-            let x = box 0i;\n-            let addr_x: *const int = ::mem::transmute(&*x);\n-            let opt = Some(x);\n-            let y = opt.unwrap();\n-            let addr_y: *const int = ::mem::transmute(&*y);\n-            assert_eq!(addr_x, addr_y);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_get_str() {\n-        let x = \"test\".to_string();\n-        let addr_x = x.as_slice().as_ptr();\n-        let opt = Some(x);\n-        let y = opt.unwrap();\n-        let addr_y = y.as_slice().as_ptr();\n-        assert_eq!(addr_x, addr_y);\n-    }\n-\n-    #[test]\n-    fn test_get_resource() {\n-        use realstd::rc::Rc;\n-        use cell::RefCell;\n-\n-        struct R {\n-           i: Rc<RefCell<int>>,\n-        }\n-\n-        #[unsafe_destructor]\n-        impl ::ops::Drop for R {\n-           fn drop(&mut self) {\n-                let ii = &*self.i;\n-                let i = *ii.borrow();\n-                *ii.borrow_mut() = i + 1;\n-            }\n-        }\n-\n-        fn r(i: Rc<RefCell<int>>) -> R {\n-            R {\n-                i: i\n-            }\n-        }\n-\n-        fn realclone<T: ::realstd::clone::Clone>(t: &T) -> T {\n-            use realstd::clone::Clone;\n-            t.clone()\n-        }\n-\n-        let i = Rc::new(RefCell::new(0i));\n-        {\n-            let x = r(realclone(&i));\n-            let opt = Some(x);\n-            let _y = opt.unwrap();\n-        }\n-        assert_eq!(*i.borrow(), 1);\n-    }\n-\n-    #[test]\n-    fn test_option_dance() {\n-        let x = Some(());\n-        let mut y = Some(5i);\n-        let mut y2 = 0;\n-        for _x in x.iter() {\n-            y2 = y.take_unwrap();\n-        }\n-        assert_eq!(y2, 5);\n-        assert!(y.is_none());\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_option_too_much_dance() {\n-        let mut y = Some(marker::NoCopy);\n-        let _y2 = y.take_unwrap();\n-        let _y3 = y.take_unwrap();\n-    }\n-\n-    #[test]\n-    fn test_and() {\n-        let x: Option<int> = Some(1i);\n-        assert_eq!(x.and(Some(2i)), Some(2));\n-        assert_eq!(x.and(None::<int>), None);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.and(Some(2i)), None);\n-        assert_eq!(x.and(None::<int>), None);\n-    }\n-\n-    #[test]\n-    fn test_and_then() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n-        assert_eq!(x.and_then(|_| None::<int>), None);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.and_then(|x| Some(x + 1)), None);\n-        assert_eq!(x.and_then(|_| None::<int>), None);\n-    }\n-\n-    #[test]\n-    fn test_or() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.or(Some(2)), Some(1));\n-        assert_eq!(x.or(None), Some(1));\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.or(Some(2)), Some(2));\n-        assert_eq!(x.or(None), None);\n-    }\n-\n-    #[test]\n-    fn test_or_else() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.or_else(|| Some(2)), Some(1));\n-        assert_eq!(x.or_else(|| None), Some(1));\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.or_else(|| Some(2)), Some(2));\n-        assert_eq!(x.or_else(|| None), None);\n-    }\n-\n-    #[test]\n-    fn test_option_while_some() {\n-        let mut i = 0i;\n-        Some(10i).while_some(|j| {\n-            i += 1;\n-            if j > 0 {\n-                Some(j-1)\n-            } else {\n-                None\n-            }\n-        });\n-        assert_eq!(i, 11);\n-    }\n-\n-    #[test]\n-    fn test_unwrap() {\n-        assert_eq!(Some(1i).unwrap(), 1);\n-        let s = Some(\"hello\".to_string()).unwrap();\n-        assert_eq!(s.as_slice(), \"hello\");\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_unwrap_fail1() {\n-        let x: Option<int> = None;\n-        x.unwrap();\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_unwrap_fail2() {\n-        let x: Option<String> = None;\n-        x.unwrap();\n-    }\n-\n-    #[test]\n-    fn test_unwrap_or() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.unwrap_or(2), 1);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.unwrap_or(2), 2);\n-    }\n-\n-    #[test]\n-    fn test_unwrap_or_else() {\n-        let x: Option<int> = Some(1);\n-        assert_eq!(x.unwrap_or_else(|| 2), 1);\n-\n-        let x: Option<int> = None;\n-        assert_eq!(x.unwrap_or_else(|| 2), 2);\n-    }\n-\n-    #[test]\n-    fn test_filtered() {\n-        let some_stuff = Some(42i);\n-        let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-        assert_eq!(some_stuff.unwrap(), 42);\n-        assert!(modified_stuff.is_none());\n-    }\n-\n-    #[test]\n-    fn test_iter() {\n-        let val = 5i;\n-\n-        let x = Some(val);\n-        let mut it = x.iter();\n-\n-        assert_eq!(it.size_hint(), (1, Some(1)));\n-        assert_eq!(it.next(), Some(&val));\n-        assert_eq!(it.size_hint(), (0, Some(0)));\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_mut_iter() {\n-        let val = 5i;\n-        let new_val = 11i;\n-\n-        let mut x = Some(val);\n-        {\n-            let mut it = x.mut_iter();\n-\n-            assert_eq!(it.size_hint(), (1, Some(1)));\n-\n-            match it.next() {\n-                Some(interior) => {\n-                    assert_eq!(*interior, val);\n-                    *interior = new_val;\n-                }\n-                None => assert!(false),\n-            }\n-\n-            assert_eq!(it.size_hint(), (0, Some(0)));\n-            assert!(it.next().is_none());\n-        }\n-        assert_eq!(x, Some(new_val));\n-    }\n-\n-    #[test]\n-    fn test_ord() {\n-        let small = Some(1.0f64);\n-        let big = Some(5.0f64);\n-        let nan = Some(0.0f64/0.0);\n-        assert!(!(nan < big));\n-        assert!(!(nan > big));\n-        assert!(small < big);\n-        assert!(None < big);\n-        assert!(big > None);\n-    }\n-\n-    #[test]\n-    fn test_mutate() {\n-        let mut x = Some(3i);\n-        assert!(x.mutate(|i| i+1));\n-        assert_eq!(x, Some(4i));\n-        assert!(x.mutate_or_set(0, |i| i+1));\n-        assert_eq!(x, Some(5i));\n-        x = None;\n-        assert!(!x.mutate(|i| i+1));\n-        assert_eq!(x, None);\n-        assert!(!x.mutate_or_set(0i, |i| i+1));\n-        assert_eq!(x, Some(0i));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let v: Option<Vec<int>> = collect(range(0i, 0)\n-                                          .map(|_| Some(0i)));\n-        assert!(v == Some(vec![]));\n-\n-        let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                          .map(|x| Some(x)));\n-        assert!(v == Some(vec![0, 1, 2]));\n-\n-        let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                          .map(|x| if x > 1 { None } else { Some(x) }));\n-        assert!(v == None);\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Some(()), || None, || fail!()];\n-\n-        let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n-\n-        assert!(v == None);\n-    }\n-}"}, {"sha": "cecc6bab683f5db2fe8287e1a453305480d1feff", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 267, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -93,7 +93,7 @@ use intrinsics;\n use iter::{range, Iterator};\n use option::{Some, None, Option};\n \n-#[cfg(not(test))] use cmp::{PartialEq, Eq, PartialOrd, Equiv};\n+use cmp::{PartialEq, Eq, PartialOrd, Equiv};\n \n /// Create a null pointer.\n ///\n@@ -404,7 +404,6 @@ impl<T> RawPtr<T> for *mut T {\n }\n \n // Equality for pointers\n-#[cfg(not(test))]\n impl<T> PartialEq for *const T {\n     #[inline]\n     fn eq(&self, other: &*const T) -> bool {\n@@ -414,10 +413,8 @@ impl<T> PartialEq for *const T {\n     fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n }\n \n-#[cfg(not(test))]\n impl<T> Eq for *const T {}\n \n-#[cfg(not(test))]\n impl<T> PartialEq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -427,18 +424,15 @@ impl<T> PartialEq for *mut T {\n     fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n }\n \n-#[cfg(not(test))]\n impl<T> Eq for *mut T {}\n \n // Equivalence for pointers\n-#[cfg(not(test))]\n impl<T> Equiv<*mut T> for *const T {\n     fn equiv(&self, other: &*mut T) -> bool {\n         self.to_uint() == other.to_uint()\n     }\n }\n \n-#[cfg(not(test))]\n impl<T> Equiv<*const T> for *mut T {\n     fn equiv(&self, other: &*const T) -> bool {\n         self.to_uint() == other.to_uint()\n@@ -460,7 +454,6 @@ impl<T> Clone for *mut T {\n }\n \n // Equality for extern \"C\" fn pointers\n-#[cfg(not(test))]\n mod externfnpointers {\n     use mem;\n     use cmp::PartialEq;\n@@ -494,270 +487,12 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[cfg(not(test))]\n impl<T> PartialOrd for *const T {\n     #[inline]\n     fn lt(&self, other: &*const T) -> bool { *self < *other }\n }\n \n-#[cfg(not(test))]\n impl<T> PartialOrd for *mut T {\n     #[inline]\n     fn lt(&self, other: &*mut T) -> bool { *self < *other }\n }\n-\n-#[cfg(test)]\n-#[allow(deprecated, experimental)]\n-pub mod test {\n-    use super::*;\n-    use prelude::*;\n-\n-    use realstd::c_str::ToCStr;\n-    use mem;\n-    use libc;\n-    use realstd::str;\n-    use realstd::str::Str;\n-    use realstd::vec::Vec;\n-    use realstd::collections::Collection;\n-    use slice::{ImmutableVector, MutableVector};\n-\n-    #[test]\n-    fn test() {\n-        unsafe {\n-            struct Pair {\n-                fst: int,\n-                snd: int\n-            };\n-            let mut p = Pair {fst: 10, snd: 20};\n-            let pptr: *mut Pair = &mut p;\n-            let iptr: *mut int = mem::transmute(pptr);\n-            assert_eq!(*iptr, 10);\n-            *iptr = 30;\n-            assert_eq!(*iptr, 30);\n-            assert_eq!(p.fst, 30);\n-\n-            *pptr = Pair {fst: 50, snd: 60};\n-            assert_eq!(*iptr, 50);\n-            assert_eq!(p.fst, 50);\n-            assert_eq!(p.snd, 60);\n-\n-            let v0 = vec![32000u16, 32001u16, 32002u16];\n-            let mut v1 = vec![0u16, 0u16, 0u16];\n-\n-            copy_memory(v1.as_mut_ptr().offset(1),\n-                        v0.as_ptr().offset(1), 1);\n-            assert!((*v1.get(0) == 0u16 &&\n-                     *v1.get(1) == 32001u16 &&\n-                     *v1.get(2) == 0u16));\n-            copy_memory(v1.as_mut_ptr(),\n-                        v0.as_ptr().offset(2), 1);\n-            assert!((*v1.get(0) == 32002u16 &&\n-                     *v1.get(1) == 32001u16 &&\n-                     *v1.get(2) == 0u16));\n-            copy_memory(v1.as_mut_ptr().offset(2),\n-                        v0.as_ptr(), 1u);\n-            assert!((*v1.get(0) == 32002u16 &&\n-                     *v1.get(1) == 32001u16 &&\n-                     *v1.get(2) == 32000u16));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_position() {\n-        use libc::c_char;\n-\n-        \"hello\".with_c_str(|p| {\n-            unsafe {\n-                assert!(2u == position(p, |c| *c == 'l' as c_char));\n-                assert!(4u == position(p, |c| *c == 'o' as c_char));\n-                assert!(5u == position(p, |c| *c == 0 as c_char));\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_buf_len() {\n-        \"hello\".with_c_str(|p0| {\n-            \"there\".with_c_str(|p1| {\n-                \"thing\".with_c_str(|p2| {\n-                    let v = vec![p0, p1, p2, null()];\n-                    unsafe {\n-                        assert_eq!(buf_len(v.as_ptr()), 3u);\n-                    }\n-                })\n-            })\n-        })\n-    }\n-\n-    #[test]\n-    fn test_is_null() {\n-        let p: *const int = null();\n-        assert!(p.is_null());\n-        assert!(!p.is_not_null());\n-\n-        let q = unsafe { p.offset(1) };\n-        assert!(!q.is_null());\n-        assert!(q.is_not_null());\n-\n-        let mp: *mut int = mut_null();\n-        assert!(mp.is_null());\n-        assert!(!mp.is_not_null());\n-\n-        let mq = unsafe { mp.offset(1) };\n-        assert!(!mq.is_null());\n-        assert!(mq.is_not_null());\n-    }\n-\n-    #[test]\n-    fn test_to_option() {\n-        unsafe {\n-            let p: *const int = null();\n-            assert_eq!(p.to_option(), None);\n-\n-            let q: *const int = &2;\n-            assert_eq!(q.to_option().unwrap(), &2);\n-\n-            let p: *mut int = mut_null();\n-            assert_eq!(p.to_option(), None);\n-\n-            let q: *mut int = &mut 2;\n-            assert_eq!(q.to_option().unwrap(), &2);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_ptr_addition() {\n-        unsafe {\n-            let xs = Vec::from_elem(16, 5i);\n-            let mut ptr = xs.as_ptr();\n-            let end = ptr.offset(16);\n-\n-            while ptr < end {\n-                assert_eq!(*ptr, 5);\n-                ptr = ptr.offset(1);\n-            }\n-\n-            let mut xs_mut = xs;\n-            let mut m_ptr = xs_mut.as_mut_ptr();\n-            let m_end = m_ptr.offset(16);\n-\n-            while m_ptr < m_end {\n-                *m_ptr += 5;\n-                m_ptr = m_ptr.offset(1);\n-            }\n-\n-            assert!(xs_mut == Vec::from_elem(16, 10i));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_ptr_subtraction() {\n-        unsafe {\n-            let xs = vec![0,1,2,3,4,5,6,7,8,9];\n-            let mut idx = 9i8;\n-            let ptr = xs.as_ptr();\n-\n-            while idx >= 0i8 {\n-                assert_eq!(*(ptr.offset(idx as int)), idx as int);\n-                idx = idx - 1i8;\n-            }\n-\n-            let mut xs_mut = xs;\n-            let m_start = xs_mut.as_mut_ptr();\n-            let mut m_ptr = m_start.offset(9);\n-\n-            while m_ptr >= m_start {\n-                *m_ptr += *m_ptr;\n-                m_ptr = m_ptr.offset(-1);\n-            }\n-\n-            assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_ptr_array_each_with_len() {\n-        unsafe {\n-            let one = \"oneOne\".to_c_str();\n-            let two = \"twoTwo\".to_c_str();\n-            let three = \"threeThree\".to_c_str();\n-            let arr = vec![\n-                one.as_ptr(),\n-                two.as_ptr(),\n-                three.as_ptr()\n-            ];\n-            let expected_arr = [\n-                one, two, three\n-            ];\n-\n-            let mut ctr = 0;\n-            let mut iteration_count = 0;\n-            array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n-                    let actual = str::raw::from_c_str(e);\n-                    let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n-                    assert_eq!(actual.as_slice(), expected.as_slice());\n-                    ctr += 1;\n-                    iteration_count += 1;\n-                });\n-            assert_eq!(iteration_count, 3u);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_ptr_array_each() {\n-        unsafe {\n-            let one = \"oneOne\".to_c_str();\n-            let two = \"twoTwo\".to_c_str();\n-            let three = \"threeThree\".to_c_str();\n-            let arr = vec![\n-                one.as_ptr(),\n-                two.as_ptr(),\n-                three.as_ptr(),\n-                // fake a null terminator\n-                null()\n-            ];\n-            let expected_arr = [\n-                one, two, three\n-            ];\n-\n-            let arr_ptr = arr.as_ptr();\n-            let mut ctr = 0u;\n-            let mut iteration_count = 0u;\n-            array_each(arr_ptr, |e| {\n-                    let actual = str::raw::from_c_str(e);\n-                    let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n-                    assert_eq!(actual.as_slice(), expected.as_slice());\n-                    ctr += 1;\n-                    iteration_count += 1;\n-                });\n-            assert_eq!(iteration_count, 3);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_ptr_array_each_with_len_null_ptr() {\n-        unsafe {\n-            array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n-                str::raw::from_c_str(e);\n-            });\n-        }\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_ptr_array_each_null_ptr() {\n-        unsafe {\n-            array_each(0 as *const *const libc::c_char, |e| {\n-                str::raw::from_c_str(e);\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn test_set_memory() {\n-        let mut xs = [0u8, ..20];\n-        let ptr = xs.as_mut_ptr();\n-        unsafe { set_memory(ptr, 5u8, xs.len()); }\n-        assert!(xs == [5u8, ..20]);\n-    }\n-}"}, {"sha": "da9fab0fc6f50ef8894618d0076214a703df268f", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -70,32 +70,3 @@ pub trait Repr<T> {\n impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n \n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use mem;\n-\n-    #[test]\n-    fn synthesize_closure() {\n-        unsafe {\n-            let x = 10;\n-            let f: |int| -> int = |y| x + y;\n-\n-            assert_eq!(f(20), 30);\n-\n-            let original_closure: Closure = mem::transmute(f);\n-\n-            let actual_function_pointer = original_closure.code;\n-            let environment = original_closure.env;\n-\n-            let new_closure = Closure {\n-                code: actual_function_pointer,\n-                env: environment\n-            };\n-\n-            let new_f: |int| -> int = mem::transmute(new_closure);\n-            assert_eq!(new_f(20), 30);\n-        }\n-    }\n-}"}, {"sha": "a104d20f4e5aa199610ecad01899a0acf6210ebd", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -635,166 +635,3 @@ pub fn fold<T,\n pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n     fold(iterator, (), |_, _| ())\n }\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Tests\n-/////////////////////////////////////////////////////////////////////////////\n-\n-#[cfg(test)]\n-mod tests {\n-    use realstd::vec::Vec;\n-\n-    use result::{collect, fold, fold_};\n-    use prelude::*;\n-    use realstd::str::Str;\n-    use iter::range;\n-\n-    pub fn op1() -> Result<int, &'static str> { Ok(666) }\n-    pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n-\n-    #[test]\n-    pub fn test_and() {\n-        assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n-        assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n-                   \"bad\");\n-\n-        assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n-        assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n-                   \"sadface\");\n-    }\n-\n-    #[test]\n-    pub fn test_and_then() {\n-        assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n-        assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n-                   \"bad\");\n-\n-        assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n-                   \"sadface\");\n-        assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n-                   \"sadface\");\n-    }\n-\n-    #[test]\n-    pub fn test_or() {\n-        assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n-        assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n-\n-        assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n-        assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n-    }\n-\n-    #[test]\n-    pub fn test_or_else() {\n-        assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n-        assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n-\n-        assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n-        assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n-                   \"sadface\");\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map() {\n-        assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n-        assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n-    }\n-\n-    #[test]\n-    pub fn test_impl_map_err() {\n-        assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n-        assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n-    }\n-\n-    #[test]\n-    fn test_collect() {\n-        let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n-        assert!(v == Ok(vec![]));\n-\n-        let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n-        assert!(v == Ok(vec![0, 1, 2]));\n-\n-        let v: Result<Vec<int>, int> = collect(range(0i, 3)\n-                                               .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n-        assert!(v == Err(2));\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n-\n-        let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n-        assert!(v == Err(1));\n-    }\n-\n-    #[test]\n-    fn test_fold() {\n-        assert_eq!(fold_(range(0i, 0)\n-                        .map(|_| Ok::<(), ()>(()))),\n-                   Ok(()));\n-        assert_eq!(fold(range(0i, 3)\n-                        .map(|x| Ok::<int, ()>(x)),\n-                        0, |a, b| a + b),\n-                   Ok(3));\n-        assert_eq!(fold_(range(0i, 3)\n-                        .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n-                   Err(2));\n-\n-        // test that it does not take more elements than it needs\n-        let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n-\n-        assert_eq!(fold_(functions.mut_iter()\n-                        .map(|f| (*f)())),\n-                   Err(1));\n-    }\n-\n-    #[test]\n-    pub fn test_fmt_default() {\n-        let ok: Result<int, &'static str> = Ok(100);\n-        let err: Result<int, &'static str> = Err(\"Err\");\n-\n-        let s = format!(\"{}\", ok);\n-        assert_eq!(s.as_slice(), \"Ok(100)\");\n-        let s = format!(\"{}\", err);\n-        assert_eq!(s.as_slice(), \"Err(Err)\");\n-    }\n-\n-    #[test]\n-    pub fn test_unwrap_or() {\n-        let ok: Result<int, &'static str> = Ok(100i);\n-        let ok_err: Result<int, &'static str> = Err(\"Err\");\n-\n-        assert_eq!(ok.unwrap_or(50), 100);\n-        assert_eq!(ok_err.unwrap_or(50), 50);\n-    }\n-\n-    #[test]\n-    pub fn test_unwrap_or_else() {\n-        fn handler(msg: &'static str) -> int {\n-            if msg == \"I got this.\" {\n-                50i\n-            } else {\n-                fail!(\"BadBad\")\n-            }\n-        }\n-\n-        let ok: Result<int, &'static str> = Ok(100);\n-        let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n-\n-        assert_eq!(ok.unwrap_or_else(handler), 100);\n-        assert_eq!(ok_err.unwrap_or_else(handler), 50);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn test_unwrap_or_else_failure() {\n-        fn handler(msg: &'static str) -> int {\n-            if msg == \"I got this.\" {\n-                50i\n-            } else {\n-                fail!(\"BadBad\")\n-            }\n-        }\n-\n-        let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n-        let _ : int = bad_err.unwrap_or_else(handler);\n-    }\n-}"}, {"sha": "6340633410374f9e560ae934f2d2db6e7069be0a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -246,7 +246,6 @@ impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n \n // Equality\n \n-#[cfg(not(test))]\n #[allow(missing_doc)]\n pub mod traits {\n     use super::*;\n@@ -298,9 +297,6 @@ pub mod traits {\n     }\n }\n \n-#[cfg(test)]\n-pub mod traits {}\n-\n /// Any vector that can be represented as a slice.\n pub trait Vector<T> {\n     /// Work with `self` as a slice."}, {"sha": "21de4cdf59fb102e76e3c400728727de3e5eccf8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -579,20 +579,12 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n /// Bytewise slice equality\n /// NOTE: This function is (ab)used in rustc::middle::trans::_match\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)\n }\n \n-/// Bytewise slice equality\n-#[cfg(test)]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    eq_slice_(a, b)\n-}\n-\n /*\n Section: Misc\n */\n@@ -934,7 +926,6 @@ pub mod raw {\n Section: Trait implementations\n */\n \n-#[cfg(not(test))]\n #[allow(missing_doc)]\n pub mod traits {\n     use cmp::{Ord, Ordering, Less, Equal, Greater, PartialEq, PartialOrd, Equiv, Eq};\n@@ -980,9 +971,6 @@ pub mod traits {\n     }\n }\n \n-#[cfg(test)]\n-pub mod traits {}\n-\n /// Any string that can be represented as a slice\n pub trait Str {\n     /// Work with `self` as a slice."}, {"sha": "f44bce33547126df75ae6cb68418e1b02d5071c0", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 2, "deletions": 97, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -62,8 +62,8 @@\n #![doc(primitive = \"tuple\")]\n \n use clone::Clone;\n-#[cfg(not(test))] use cmp::*;\n-#[cfg(not(test))] use default::Default;\n+use cmp::*;\n+use default::Default;\n \n // macro for implementing n-ary tuple functions and operations\n macro_rules! tuple_impls {\n@@ -111,7 +111,6 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:PartialEq),+> PartialEq for ($($T,)+) {\n                 #[inline]\n                 fn eq(&self, other: &($($T,)+)) -> bool {\n@@ -123,10 +122,8 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:Eq),+> Eq for ($($T,)+) {}\n \n-            #[cfg(not(test))]\n             impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+) {\n                 #[inline]\n                 fn lt(&self, other: &($($T,)+)) -> bool {\n@@ -146,15 +143,13 @@ macro_rules! tuple_impls {\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:Ord),+> Ord for ($($T,)+) {\n                 #[inline]\n                 fn cmp(&self, other: &($($T,)+)) -> Ordering {\n                     lexical_cmp!($(self.$refN(), other.$refN()),+)\n                 }\n             }\n \n-            #[cfg(not(test))]\n             impl<$($T:Default),+> Default for ($($T,)+) {\n                 #[inline]\n                 fn default() -> ($($T,)+) {\n@@ -292,93 +287,3 @@ tuple_impls! {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use clone::Clone;\n-    use cmp::*;\n-    use realstd::str::Str;\n-\n-    #[test]\n-    fn test_clone() {\n-        let a = (1i, \"2\");\n-        let b = a.clone();\n-        assert_eq!(a, b);\n-    }\n-\n-    #[test]\n-    fn test_getters() {\n-        macro_rules! test_getter(\n-            ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n-             $init:expr, $incr:expr, $result:expr) => ({\n-                assert_eq!($x.$valN(), $init);\n-                assert_eq!(*$x.$refN(), $init);\n-                *$x.$mutN() += $incr;\n-                assert_eq!(*$x.$refN(), $result);\n-            })\n-        )\n-        let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n-        test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n-        test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n-        test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n-        test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n-        test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n-        test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n-        test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n-        test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n-        test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n-        test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n-        test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n-        test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n-    }\n-\n-    #[test]\n-    fn test_tuple_cmp() {\n-        let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n-\n-        let nan = 0.0f64/0.0;\n-\n-        // PartialEq\n-        assert_eq!(small, small);\n-        assert_eq!(big, big);\n-        assert!(small != big);\n-        assert!(big != small);\n-\n-        // PartialOrd\n-        assert!(small < big);\n-        assert!(!(small < small));\n-        assert!(!(big < small));\n-        assert!(!(big < big));\n-\n-        assert!(small <= small);\n-        assert!(big <= big);\n-\n-        assert!(big > small);\n-        assert!(small >= small);\n-        assert!(big >= small);\n-        assert!(big >= big);\n-\n-        assert!(!((1.0f64, 2.0f64) < (nan, 3.0)));\n-        assert!(!((1.0f64, 2.0f64) <= (nan, 3.0)));\n-        assert!(!((1.0f64, 2.0f64) > (nan, 3.0)));\n-        assert!(!((1.0f64, 2.0f64) >= (nan, 3.0)));\n-        assert!(((1.0f64, 2.0f64) < (2.0, nan)));\n-        assert!(!((2.0f64, 2.0f64) < (2.0, nan)));\n-\n-        // Ord\n-        assert!(small.cmp(&small) == Equal);\n-        assert!(big.cmp(&big) == Equal);\n-        assert!(small.cmp(&big) == Less);\n-        assert!(big.cmp(&small) == Greater);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let s = format!(\"{}\", (1i,));\n-        assert_eq!(s.as_slice(), \"(1,)\");\n-        let s = format!(\"{}\", (1i, true));\n-        assert_eq!(s.as_slice(), \"(1, true)\");\n-        let s = format!(\"{}\", (1i, \"hi\", true));\n-        assert_eq!(s.as_slice(), \"(1, hi, true)\");\n-    }\n-}"}, {"sha": "fae4a26cd3863ff555969cf6c1b8c88b52c42c4b", "filename": "src/libcoretest/any.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,131 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use core::any::*;\n+use test::Bencher;\n+use test;\n+\n+#[deriving(PartialEq, Show)]\n+struct Test;\n+\n+static TEST: &'static str = \"Test\";\n+\n+#[test]\n+fn any_referenced() {\n+    let (a, b, c) = (&5u as &Any, &TEST as &Any, &Test as &Any);\n+\n+    assert!(a.is::<uint>());\n+    assert!(!b.is::<uint>());\n+    assert!(!c.is::<uint>());\n+\n+    assert!(!a.is::<&'static str>());\n+    assert!(b.is::<&'static str>());\n+    assert!(!c.is::<&'static str>());\n+\n+    assert!(!a.is::<Test>());\n+    assert!(!b.is::<Test>());\n+    assert!(c.is::<Test>());\n+}\n+\n+#[test]\n+fn any_owning() {\n+    let (a, b, c) = (box 5u as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n+\n+    assert!(a.is::<uint>());\n+    assert!(!b.is::<uint>());\n+    assert!(!c.is::<uint>());\n+\n+    assert!(!a.is::<&'static str>());\n+    assert!(b.is::<&'static str>());\n+    assert!(!c.is::<&'static str>());\n+\n+    assert!(!a.is::<Test>());\n+    assert!(!b.is::<Test>());\n+    assert!(c.is::<Test>());\n+}\n+\n+#[test]\n+fn any_as_ref() {\n+    let a = &5u as &Any;\n+\n+    match a.as_ref::<uint>() {\n+        Some(&5) => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match a.as_ref::<Test>() {\n+        None => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+}\n+\n+#[test]\n+fn any_as_mut() {\n+    let mut a = 5u;\n+    let mut b = box 7u;\n+\n+    let a_r = &mut a as &mut Any;\n+    let tmp: &mut uint = &mut *b;\n+    let b_r = tmp as &mut Any;\n+\n+    match a_r.as_mut::<uint>() {\n+        Some(x) => {\n+            assert_eq!(*x, 5u);\n+            *x = 612;\n+        }\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match b_r.as_mut::<uint>() {\n+        Some(x) => {\n+            assert_eq!(*x, 7u);\n+            *x = 413;\n+        }\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match a_r.as_mut::<Test>() {\n+        None => (),\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match b_r.as_mut::<Test>() {\n+        None => (),\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match a_r.as_mut::<uint>() {\n+        Some(&612) => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+\n+    match b_r.as_mut::<uint>() {\n+        Some(&413) => {}\n+        x => fail!(\"Unexpected value {}\", x)\n+    }\n+}\n+\n+#[test]\n+fn any_fixed_vec() {\n+    let test = [0u, ..8];\n+    let test = &test as &Any;\n+    assert!(test.is::<[uint, ..8]>());\n+    assert!(!test.is::<[uint, ..10]>());\n+}\n+\n+\n+#[bench]\n+fn bench_as_ref(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut x = 0i;\n+        let mut y = &mut x as &mut Any;\n+        test::black_box(&mut y);\n+        test::black_box(y.as_ref::<int>() == Some(&0));\n+    });\n+}"}, {"sha": "3f960ae1f267fbf9caa8dcc75380ff73199f7841", "filename": "src/libcoretest/atomics.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fatomics.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::atomics::*;\n+\n+#[test]\n+fn bool_() {\n+    let a = AtomicBool::new(false);\n+    assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+    assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n+\n+    a.store(false, SeqCst);\n+    assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+}\n+\n+#[test]\n+fn bool_and() {\n+    let a = AtomicBool::new(true);\n+    assert_eq!(a.fetch_and(false, SeqCst),true);\n+    assert_eq!(a.load(SeqCst),false);\n+}\n+\n+#[test]\n+fn uint_and() {\n+    let x = AtomicUint::new(0xf731);\n+    assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+}\n+\n+#[test]\n+fn uint_or() {\n+    let x = AtomicUint::new(0xf731);\n+    assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+}\n+\n+#[test]\n+fn uint_xor() {\n+    let x = AtomicUint::new(0xf731);\n+    assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+}\n+\n+#[test]\n+fn int_and() {\n+    let x = AtomicInt::new(0xf731);\n+    assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+}\n+\n+#[test]\n+fn int_or() {\n+    let x = AtomicInt::new(0xf731);\n+    assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+}\n+\n+#[test]\n+fn int_xor() {\n+    let x = AtomicInt::new(0xf731);\n+    assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+    assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+}\n+\n+static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n+static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n+static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+\n+#[test]\n+fn static_init() {\n+    unsafe {\n+        assert!(!S_BOOL.load(SeqCst));\n+        assert!(S_INT.load(SeqCst) == 0);\n+        assert!(S_UINT.load(SeqCst) == 0);\n+    }\n+}"}, {"sha": "b3ae110363cb56e357ddcf3adfded634a6673cda", "filename": "src/libcoretest/cell.rs", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::cell::*;\n+use std::mem::drop;\n+\n+#[test]\n+fn smoketest_cell() {\n+    let x = Cell::new(10i);\n+    assert!(x == Cell::new(10));\n+    assert!(x.get() == 10);\n+    x.set(20);\n+    assert!(x == Cell::new(20));\n+    assert!(x.get() == 20);\n+\n+    let y = Cell::new((30i, 40i));\n+    assert!(y == Cell::new((30, 40)));\n+    assert!(y.get() == (30, 40));\n+}\n+\n+#[test]\n+fn cell_has_sensible_show() {\n+    let x = Cell::new(\"foo bar\");\n+    assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n+\n+    x.set(\"baz qux\");\n+    assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n+}\n+\n+#[test]\n+fn ref_and_refmut_have_sensible_show() {\n+    let refcell = RefCell::new(\"foo\");\n+\n+    let refcell_refmut = refcell.borrow_mut();\n+    assert!(format!(\"{}\", refcell_refmut).as_slice().contains(\"foo\"));\n+    drop(refcell_refmut);\n+\n+    let refcell_ref = refcell.borrow();\n+    assert!(format!(\"{}\", refcell_ref).as_slice().contains(\"foo\"));\n+    drop(refcell_ref);\n+}\n+\n+#[test]\n+fn double_imm_borrow() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow();\n+    x.borrow();\n+}\n+\n+#[test]\n+fn no_mut_then_imm_borrow() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow_mut();\n+    assert!(x.try_borrow().is_none());\n+}\n+\n+#[test]\n+fn no_imm_then_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow();\n+    assert!(x.try_borrow_mut().is_none());\n+}\n+\n+#[test]\n+fn no_double_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow_mut();\n+    assert!(x.try_borrow_mut().is_none());\n+}\n+\n+#[test]\n+fn imm_release_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    {\n+        let _b1 = x.borrow();\n+    }\n+    x.borrow_mut();\n+}\n+\n+#[test]\n+fn mut_release_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    {\n+        let _b1 = x.borrow_mut();\n+    }\n+    x.borrow();\n+}\n+\n+#[test]\n+fn double_borrow_single_release_no_borrow_mut() {\n+    let x = RefCell::new(0i);\n+    let _b1 = x.borrow();\n+    {\n+        let _b2 = x.borrow();\n+    }\n+    assert!(x.try_borrow_mut().is_none());\n+}\n+\n+#[test]\n+#[should_fail]\n+fn discard_doesnt_unborrow() {\n+    let x = RefCell::new(0i);\n+    let _b = x.borrow();\n+    let _ = _b;\n+    let _b = x.borrow_mut();\n+}\n+\n+#[test]\n+#[allow(experimental)]\n+fn clone_ref_updates_flag() {\n+    let x = RefCell::new(0i);\n+    {\n+        let b1 = x.borrow();\n+        assert!(x.try_borrow_mut().is_none());\n+        {\n+            let _b2 = clone_ref(&b1);\n+            assert!(x.try_borrow_mut().is_none());\n+        }\n+        assert!(x.try_borrow_mut().is_none());\n+    }\n+    assert!(x.try_borrow_mut().is_some());\n+}"}, {"sha": "852edd90b0f3fb28ecb6ad4b574dce7fe2079d50", "filename": "src/libcoretest/char.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,202 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::char::{escape_unicode, escape_default};\n+\n+#[test]\n+fn test_is_lowercase() {\n+    assert!('a'.is_lowercase());\n+    assert!('\u00f6'.is_lowercase());\n+    assert!('\u00df'.is_lowercase());\n+    assert!(!'\u00dc'.is_lowercase());\n+    assert!(!'P'.is_lowercase());\n+}\n+\n+#[test]\n+fn test_is_uppercase() {\n+    assert!(!'h'.is_uppercase());\n+    assert!(!'\u00e4'.is_uppercase());\n+    assert!(!'\u00df'.is_uppercase());\n+    assert!('\u00d6'.is_uppercase());\n+    assert!('T'.is_uppercase());\n+}\n+\n+#[test]\n+fn test_is_whitespace() {\n+    assert!(' '.is_whitespace());\n+    assert!('\\u2007'.is_whitespace());\n+    assert!('\\t'.is_whitespace());\n+    assert!('\\n'.is_whitespace());\n+    assert!(!'a'.is_whitespace());\n+    assert!(!'_'.is_whitespace());\n+    assert!(!'\\u0000'.is_whitespace());\n+}\n+\n+#[test]\n+fn test_to_digit() {\n+    assert_eq!('0'.to_digit(10u), Some(0u));\n+    assert_eq!('1'.to_digit(2u), Some(1u));\n+    assert_eq!('2'.to_digit(3u), Some(2u));\n+    assert_eq!('9'.to_digit(10u), Some(9u));\n+    assert_eq!('a'.to_digit(16u), Some(10u));\n+    assert_eq!('A'.to_digit(16u), Some(10u));\n+    assert_eq!('b'.to_digit(16u), Some(11u));\n+    assert_eq!('B'.to_digit(16u), Some(11u));\n+    assert_eq!('z'.to_digit(36u), Some(35u));\n+    assert_eq!('Z'.to_digit(36u), Some(35u));\n+    assert_eq!(' '.to_digit(10u), None);\n+    assert_eq!('$'.to_digit(36u), None);\n+}\n+\n+#[test]\n+fn test_to_lowercase() {\n+    assert_eq!('A'.to_lowercase(), 'a');\n+    assert_eq!('\u00d6'.to_lowercase(), '\u00f6');\n+    assert_eq!('\u00df'.to_lowercase(), '\u00df');\n+    assert_eq!('\u00dc'.to_lowercase(), '\u00fc');\n+    assert_eq!('\ud83d\udca9'.to_lowercase(), '\ud83d\udca9');\n+    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+    assert_eq!('\u03a4'.to_lowercase(), '\u03c4');\n+    assert_eq!('\u0399'.to_lowercase(), '\u03b9');\n+    assert_eq!('\u0393'.to_lowercase(), '\u03b3');\n+    assert_eq!('\u039c'.to_lowercase(), '\u03bc');\n+    assert_eq!('\u0391'.to_lowercase(), '\u03b1');\n+    assert_eq!('\u03a3'.to_lowercase(), '\u03c3');\n+}\n+\n+#[test]\n+fn test_to_uppercase() {\n+    assert_eq!('a'.to_uppercase(), 'A');\n+    assert_eq!('\u00f6'.to_uppercase(), '\u00d6');\n+    assert_eq!('\u00df'.to_uppercase(), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!('\u00fc'.to_uppercase(), '\u00dc');\n+    assert_eq!('\ud83d\udca9'.to_uppercase(), '\ud83d\udca9');\n+\n+    assert_eq!('\u03c3'.to_uppercase(), '\u03a3');\n+    assert_eq!('\u03c4'.to_uppercase(), '\u03a4');\n+    assert_eq!('\u03b9'.to_uppercase(), '\u0399');\n+    assert_eq!('\u03b3'.to_uppercase(), '\u0393');\n+    assert_eq!('\u03bc'.to_uppercase(), '\u039c');\n+    assert_eq!('\u03b1'.to_uppercase(), '\u0391');\n+    assert_eq!('\u03c2'.to_uppercase(), '\u03a3');\n+}\n+\n+#[test]\n+fn test_is_control() {\n+    assert!('\\u0000'.is_control());\n+    assert!('\\u0003'.is_control());\n+    assert!('\\u0006'.is_control());\n+    assert!('\\u0009'.is_control());\n+    assert!('\\u007f'.is_control());\n+    assert!('\\u0092'.is_control());\n+    assert!(!'\\u0020'.is_control());\n+    assert!(!'\\u0055'.is_control());\n+    assert!(!'\\u0068'.is_control());\n+}\n+\n+#[test]\n+fn test_is_digit() {\n+   assert!('2'.is_digit());\n+   assert!('7'.is_digit());\n+   assert!(!'c'.is_digit());\n+   assert!(!'i'.is_digit());\n+   assert!(!'z'.is_digit());\n+   assert!(!'Q'.is_digit());\n+}\n+\n+#[test]\n+fn test_escape_default() {\n+    fn string(c: char) -> String {\n+        let mut result = String::new();\n+        escape_default(c, |c| { result.push_char(c); });\n+        return result;\n+    }\n+    let s = string('\\n');\n+    assert_eq!(s.as_slice(), \"\\\\n\");\n+    let s = string('\\r');\n+    assert_eq!(s.as_slice(), \"\\\\r\");\n+    let s = string('\\'');\n+    assert_eq!(s.as_slice(), \"\\\\'\");\n+    let s = string('\"');\n+    assert_eq!(s.as_slice(), \"\\\\\\\"\");\n+    let s = string(' ');\n+    assert_eq!(s.as_slice(), \" \");\n+    let s = string('a');\n+    assert_eq!(s.as_slice(), \"a\");\n+    let s = string('~');\n+    assert_eq!(s.as_slice(), \"~\");\n+    let s = string('\\x00');\n+    assert_eq!(s.as_slice(), \"\\\\x00\");\n+    let s = string('\\x1f');\n+    assert_eq!(s.as_slice(), \"\\\\x1f\");\n+    let s = string('\\x7f');\n+    assert_eq!(s.as_slice(), \"\\\\x7f\");\n+    let s = string('\\xff');\n+    assert_eq!(s.as_slice(), \"\\\\xff\");\n+    let s = string('\\u011b');\n+    assert_eq!(s.as_slice(), \"\\\\u011b\");\n+    let s = string('\\U0001d4b6');\n+    assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n+}\n+\n+#[test]\n+fn test_escape_unicode() {\n+    fn string(c: char) -> String {\n+        let mut result = String::new();\n+        escape_unicode(c, |c| { result.push_char(c); });\n+        return result;\n+    }\n+    let s = string('\\x00');\n+    assert_eq!(s.as_slice(), \"\\\\x00\");\n+    let s = string('\\n');\n+    assert_eq!(s.as_slice(), \"\\\\x0a\");\n+    let s = string(' ');\n+    assert_eq!(s.as_slice(), \"\\\\x20\");\n+    let s = string('a');\n+    assert_eq!(s.as_slice(), \"\\\\x61\");\n+    let s = string('\\u011b');\n+    assert_eq!(s.as_slice(), \"\\\\u011b\");\n+    let s = string('\\U0001d4b6');\n+    assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n+}\n+\n+#[test]\n+fn test_to_str() {\n+    let s = 't'.to_str();\n+    assert_eq!(s.as_slice(), \"t\");\n+}\n+\n+#[test]\n+fn test_encode_utf8() {\n+    fn check(input: char, expect: &[u8]) {\n+        let mut buf = [0u8, ..4];\n+        let n = input.encode_utf8(buf /* as mut slice! */);\n+        assert_eq!(buf.slice_to(n), expect);\n+    }\n+\n+    check('x', [0x78]);\n+    check('\\u00e9', [0xc3, 0xa9]);\n+    check('\\ua66e', [0xea, 0x99, 0xae]);\n+    check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n+}\n+\n+#[test]\n+fn test_encode_utf16() {\n+    fn check(input: char, expect: &[u16]) {\n+        let mut buf = [0u16, ..2];\n+        let n = input.encode_utf16(buf /* as mut slice! */);\n+        assert_eq!(buf.slice_to(n), expect);\n+    }\n+\n+    check('x', [0x0078]);\n+    check('\\u00e9', [0x00e9]);\n+    check('\\ua66e', [0xa66e]);\n+    check('\\U0001f4a9', [0xd83d, 0xdca9]);\n+}"}, {"sha": "67c30d945d497383b2f8edc31e532036a7dc239c", "filename": "src/libcoretest/clone.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fclone.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+fn test_borrowed_clone() {\n+    let x = 5i;\n+    let y: &int = &x;\n+    let z: &int = (&y).clone();\n+    assert_eq!(*z, 5);\n+}\n+\n+#[test]\n+fn test_clone_from() {\n+    let a = box 5i;\n+    let mut b = box 10i;\n+    b.clone_from(&a);\n+    assert_eq!(*b, 5);\n+}\n+\n+#[test]\n+fn test_extern_fn_clone() {\n+    trait Empty {}\n+    impl Empty for int {}\n+\n+    fn test_fn_a() -> f64 { 1.0 }\n+    fn test_fn_b<T: Empty>(x: T) -> T { x }\n+    fn test_fn_c(_: int, _: f64, _: int, _: int, _: int) {}\n+\n+    let _ = test_fn_a.clone();\n+    let _ = test_fn_b::<int>.clone();\n+    let _ = test_fn_c.clone();\n+}"}, {"sha": "88e944be3e860da442b41495447b8dd958e8fe1d", "filename": "src/libcoretest/cmp.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::cmp::lexical_ordering;\n+\n+#[test]\n+fn test_int_totalord() {\n+    assert_eq!(5i.cmp(&10), Less);\n+    assert_eq!(10i.cmp(&5), Greater);\n+    assert_eq!(5i.cmp(&5), Equal);\n+    assert_eq!((-5i).cmp(&12), Less);\n+    assert_eq!(12i.cmp(&-5), Greater);\n+}\n+\n+#[test]\n+fn test_mut_int_totalord() {\n+    assert_eq!((&mut 5i).cmp(&&mut 10), Less);\n+    assert_eq!((&mut 10i).cmp(&&mut 5), Greater);\n+    assert_eq!((&mut 5i).cmp(&&mut 5), Equal);\n+    assert_eq!((&mut -5i).cmp(&&mut 12), Less);\n+    assert_eq!((&mut 12i).cmp(&&mut -5), Greater);\n+}\n+\n+#[test]\n+fn test_ordering_order() {\n+    assert!(Less < Equal);\n+    assert_eq!(Greater.cmp(&Less), Greater);\n+}\n+\n+#[test]\n+fn test_lexical_ordering() {\n+    fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n+        assert_eq!(lexical_ordering(o1, o2), e);\n+    }\n+\n+    let xs = [Less, Equal, Greater];\n+    for &o in xs.iter() {\n+        t(Less, o, Less);\n+        t(Equal, o, o);\n+        t(Greater, o, Greater);\n+     }\n+}\n+\n+#[test]\n+fn test_user_defined_eq() {\n+    // Our type.\n+    struct SketchyNum {\n+        num : int\n+    }\n+\n+    // Our implementation of `PartialEq` to support `==` and `!=`.\n+    impl PartialEq for SketchyNum {\n+        // Our custom eq allows numbers which are near each other to be equal! :D\n+        fn eq(&self, other: &SketchyNum) -> bool {\n+            (self.num - other.num).abs() < 5\n+        }\n+    }\n+\n+    // Now these binary operators will work when applied!\n+    assert!(SketchyNum {num: 37} == SketchyNum {num: 34});\n+    assert!(SketchyNum {num: 25} != SketchyNum {num: 57});\n+}"}, {"sha": "5da004086d27f84dfe97922cba49f27c9911d976", "filename": "src/libcoretest/finally.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::finally::{try_finally, Finally};\n+use std::task::failing;\n+\n+#[test]\n+fn test_success() {\n+    let mut i = 0i;\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+        },\n+        |i| {\n+            assert!(!failing());\n+            assert_eq!(*i, 10);\n+            *i = 20;\n+        });\n+    assert_eq!(i, 20);\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_fail() {\n+    let mut i = 0i;\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+            fail!();\n+        },\n+        |i| {\n+            assert!(failing());\n+            assert_eq!(*i, 10);\n+        })\n+}\n+\n+#[test]\n+fn test_retval() {\n+    let mut closure: || -> int = || 10;\n+    let i = closure.finally(|| { });\n+    assert_eq!(i, 10);\n+}\n+\n+#[test]\n+fn test_compact() {\n+    fn do_some_fallible_work() {}\n+    fn but_always_run_this_function() { }\n+    let mut f = do_some_fallible_work;\n+    f.finally(but_always_run_this_function);\n+}"}, {"sha": "9fc09b3124ef381864c131bbe8710639faa65ed4", "filename": "src/libcoretest/fmt/mod.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fmod.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod num;"}, {"sha": "baef7e3a11e8561bdeb6d10f1a781da68a8341b1", "filename": "src/libcoretest/fmt/num.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(unsigned_negate)]\n+\n+use core::fmt::radix;\n+\n+#[test]\n+fn test_format_int() {\n+    // Formatting integers should select the right implementation based off\n+    // the type of the argument. Also, hex/octal/binary should be defined\n+    // for integers, but they shouldn't emit the negative sign.\n+    assert!(format!(\"{}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:d}\", -1i).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i8).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i16).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i32).as_slice() == \"-1\");\n+    assert!(format!(\"{:d}\", -1i64).as_slice() == \"-1\");\n+    assert!(format!(\"{:t}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1i64).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i8).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i16).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i32).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1i64).as_slice() == \"1\");\n+\n+    assert!(format!(\"{}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:u}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:t}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:x}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:X}\", 1u64).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u8).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u16).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u32).as_slice() == \"1\");\n+    assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n+\n+    // Test a larger number\n+    assert!(format!(\"{:t}\", 55i).as_slice() == \"110111\");\n+    assert!(format!(\"{:o}\", 55i).as_slice() == \"67\");\n+    assert!(format!(\"{:d}\", 55i).as_slice() == \"55\");\n+    assert!(format!(\"{:x}\", 55i).as_slice() == \"37\");\n+    assert!(format!(\"{:X}\", 55i).as_slice() == \"37\");\n+}\n+\n+#[test]\n+fn test_format_int_zero() {\n+    assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:d}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:t}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n+    assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n+\n+    assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:u}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:t}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n+    assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n+}\n+\n+#[test]\n+fn test_format_int_flags() {\n+    assert!(format!(\"{:3d}\", 1i).as_slice() == \"  1\");\n+    assert!(format!(\"{:>3d}\", 1i).as_slice() == \"  1\");\n+    assert!(format!(\"{:>+3d}\", 1i).as_slice() == \" +1\");\n+    assert!(format!(\"{:<3d}\", 1i).as_slice() == \"1  \");\n+    assert!(format!(\"{:#d}\", 1i).as_slice() == \"1\");\n+    assert!(format!(\"{:#x}\", 10i).as_slice() == \"0xa\");\n+    assert!(format!(\"{:#X}\", 10i).as_slice() == \"0xA\");\n+    assert!(format!(\"{:#5x}\", 10i).as_slice() == \"  0xa\");\n+    assert!(format!(\"{:#o}\", 10i).as_slice() == \"0o12\");\n+    assert!(format!(\"{:08x}\", 10i).as_slice() == \"0000000a\");\n+    assert!(format!(\"{:8x}\", 10i).as_slice() == \"       a\");\n+    assert!(format!(\"{:<8x}\", 10i).as_slice() == \"a       \");\n+    assert!(format!(\"{:>8x}\", 10i).as_slice() == \"       a\");\n+    assert!(format!(\"{:#08x}\", 10i).as_slice() == \"0x00000a\");\n+    assert!(format!(\"{:08d}\", -10i).as_slice() == \"-0000010\");\n+    assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n+    assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n+    assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n+    assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n+    assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n+    assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n+    assert!(format!(\"{:#t}\", -1u8).as_slice() == \"0b11111111\");\n+    assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n+}\n+\n+#[test]\n+fn test_format_int_sign_padding() {\n+    assert!(format!(\"{:+5d}\", 1i).as_slice() == \"   +1\");\n+    assert!(format!(\"{:+5d}\", -1i).as_slice() == \"   -1\");\n+    assert!(format!(\"{:05d}\", 1i).as_slice() == \"00001\");\n+    assert!(format!(\"{:05d}\", -1i).as_slice() == \"-0001\");\n+    assert!(format!(\"{:+05d}\", 1i).as_slice() == \"+0001\");\n+    assert!(format!(\"{:+05d}\", -1i).as_slice() == \"-0001\");\n+}\n+\n+#[test]\n+fn test_format_int_twos_complement() {\n+    use core::{i8, i16, i32, i64};\n+    assert!(format!(\"{}\", i8::MIN).as_slice() == \"-128\");\n+    assert!(format!(\"{}\", i16::MIN).as_slice() == \"-32768\");\n+    assert!(format!(\"{}\", i32::MIN).as_slice() == \"-2147483648\");\n+    assert!(format!(\"{}\", i64::MIN).as_slice() == \"-9223372036854775808\");\n+}\n+\n+#[test]\n+fn test_format_radix() {\n+    assert!(format!(\"{:04}\", radix(3i, 2)).as_slice() == \"0011\");\n+    assert!(format!(\"{}\", radix(55i, 36)).as_slice() == \"1j\");\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_radix_base_too_large() {\n+    let _ = radix(55i, 37);\n+}\n+\n+mod uint {\n+    use test::Bencher;\n+    use core::fmt::radix;\n+    use std::rand::{weak_rng, Rng};\n+\n+    #[bench]\n+    fn format_bin(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_oct(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_dec(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_hex(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n+    }\n+\n+    #[bench]\n+    fn format_base_36(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n+    }\n+}\n+\n+mod int {\n+    use test::Bencher;\n+    use core::fmt::radix;\n+    use std::rand::{weak_rng, Rng};\n+\n+    #[bench]\n+    fn format_bin(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_oct(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_dec(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_hex(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n+    }\n+\n+    #[bench]\n+    fn format_base_36(b: &mut Bencher) {\n+        let mut rng = weak_rng();\n+        b.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n+    }\n+}"}, {"sha": "bc55b17b3467f5aac86feb6fdd4b38f36603c4ca", "filename": "src/libcoretest/iter.rs", "status": "added", "additions": 835, "deletions": 0, "changes": 835, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,835 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::iter::*;\n+use core::iter::order::*;\n+use core::uint;\n+use core::cmp;\n+use core::num;\n+\n+#[test]\n+fn test_lt() {\n+    let empty: [int, ..0] = [];\n+    let xs = [1i,2,3];\n+    let ys = [1i,2,0];\n+\n+    assert!(!lt(xs.iter(), ys.iter()));\n+    assert!(!le(xs.iter(), ys.iter()));\n+    assert!( gt(xs.iter(), ys.iter()));\n+    assert!( ge(xs.iter(), ys.iter()));\n+\n+    assert!( lt(ys.iter(), xs.iter()));\n+    assert!( le(ys.iter(), xs.iter()));\n+    assert!(!gt(ys.iter(), xs.iter()));\n+    assert!(!ge(ys.iter(), xs.iter()));\n+\n+    assert!( lt(empty.iter(), xs.iter()));\n+    assert!( le(empty.iter(), xs.iter()));\n+    assert!(!gt(empty.iter(), xs.iter()));\n+    assert!(!ge(empty.iter(), xs.iter()));\n+\n+    // Sequence with NaN\n+    let u = [1.0f64, 2.0];\n+    let v = [0.0f64/0.0, 3.0];\n+\n+    assert!(!lt(u.iter(), v.iter()));\n+    assert!(!le(u.iter(), v.iter()));\n+    assert!(!gt(u.iter(), v.iter()));\n+    assert!(!ge(u.iter(), v.iter()));\n+\n+    let a = [0.0f64/0.0];\n+    let b = [1.0f64];\n+    let c = [2.0f64];\n+\n+    assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n+    assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n+    assert!(gt(a.iter(), b.iter()) == (a[0] >  b[0]));\n+    assert!(ge(a.iter(), b.iter()) == (a[0] >= b[0]));\n+\n+    assert!(lt(c.iter(), b.iter()) == (c[0] <  b[0]));\n+    assert!(le(c.iter(), b.iter()) == (c[0] <= b[0]));\n+    assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n+    assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n+}\n+\n+#[test]\n+fn test_multi_iter() {\n+    let xs = [1i,2,3,4];\n+    let ys = [4i,3,2,1];\n+    assert!(eq(xs.iter(), ys.iter().rev()));\n+    assert!(lt(xs.iter(), xs.iter().skip(2)));\n+}\n+\n+#[test]\n+fn test_counter_from_iter() {\n+    let it = count(0i, 5).take(10);\n+    let xs: Vec<int> = FromIterator::from_iter(it);\n+    assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+}\n+\n+#[test]\n+fn test_iterator_chain() {\n+    let xs = [0u, 1, 2, 3, 4, 5];\n+    let ys = [30u, 40, 50, 60];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    let mut it = xs.iter().chain(ys.iter());\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    let ys = count(30u, 10).take(4);\n+    let mut it = xs.iter().map(|&x| x).chain(ys);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, expected[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_filter_map() {\n+    let mut it = count(0u, 1u).take(10)\n+        .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n+    assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate() {\n+    let xs = [0u, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().enumerate();\n+    for (i, &x) in it {\n+        assert_eq!(i, x);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_peekable() {\n+    let xs = vec![0u, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().map(|&x|x).peekable();\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.next().unwrap(), 0);\n+    assert_eq!(it.next().unwrap(), 1);\n+    assert_eq!(it.next().unwrap(), 2);\n+    assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.peek().unwrap(), &3);\n+    assert_eq!(it.next().unwrap(), 3);\n+    assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.peek().unwrap(), &5);\n+    assert_eq!(it.next().unwrap(), 5);\n+    assert!(it.peek().is_none());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_iterator_take_while() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0u, 1, 2, 3, 5, 13];\n+    let mut it = xs.iter().take_while(|&x| *x < 15u);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_skip_while() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [15, 16, 17, 19];\n+    let mut it = xs.iter().skip_while(|&x| *x < 15u);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_skip() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+    let ys = [13, 15, 16, 17, 19, 20, 30];\n+    let mut it = xs.iter().skip(5);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_take() {\n+    let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n+    let ys = [0u, 1, 2, 3, 5];\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    for &x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_scan() {\n+    // test the type inference\n+    fn add(old: &mut int, new: &uint) -> Option<f64> {\n+        *old += *new as int;\n+        Some(*old as f64)\n+    }\n+    let xs = [0u, 1, 2, 3, 4];\n+    let ys = [0f64, 1.0, 3.0, 6.0, 10.0];\n+\n+    let mut it = xs.iter().scan(0, add);\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_iterator_flat_map() {\n+    let xs = [0u, 3, 6];\n+    let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let mut it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+#[test]\n+fn test_inspect() {\n+    let xs = [1u, 2, 3, 4];\n+    let mut n = 0;\n+\n+    let ys = xs.iter()\n+               .map(|&x| x)\n+               .inspect(|_| n += 1)\n+               .collect::<Vec<uint>>();\n+\n+    assert_eq!(n, xs.len());\n+    assert_eq!(xs.as_slice(), ys.as_slice());\n+}\n+\n+#[test]\n+fn test_unfoldr() {\n+    fn count(st: &mut uint) -> Option<uint> {\n+        if *st < 10 {\n+            let ret = Some(*st);\n+            *st += 1;\n+            ret\n+        } else {\n+            None\n+        }\n+    }\n+\n+    let mut it = Unfold::new(0, count);\n+    let mut i = 0;\n+    for counted in it {\n+        assert_eq!(counted, i);\n+        i += 1;\n+    }\n+    assert_eq!(i, 10);\n+}\n+\n+#[test]\n+fn test_cycle() {\n+    let cycle_len = 3;\n+    let it = count(0u, 1).take(cycle_len).cycle();\n+    assert_eq!(it.size_hint(), (uint::MAX, None));\n+    for (i, x) in it.take(100).enumerate() {\n+        assert_eq!(i % cycle_len, x);\n+    }\n+\n+    let mut it = count(0u, 1).take(0).cycle();\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_nth() {\n+    let v = &[0i, 1, 2, 3, 4];\n+    for i in range(0u, v.len()) {\n+        assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_last() {\n+    let v = &[0i, 1, 2, 3, 4];\n+    assert_eq!(v.iter().last().unwrap(), &4);\n+    assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n+}\n+\n+#[test]\n+fn test_iterator_len() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().count(), 4);\n+    assert_eq!(v.slice(0, 10).iter().count(), 10);\n+    assert_eq!(v.slice(0, 0).iter().count(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_sum() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n+    assert_eq!(v.iter().map(|&x| x).sum(), 55);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_product() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n+    assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n+}\n+\n+#[test]\n+fn test_iterator_max() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n+    assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n+}\n+\n+#[test]\n+fn test_iterator_min() {\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n+}\n+\n+#[test]\n+fn test_iterator_size_hint() {\n+    let c = count(0i, 1);\n+    let v = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let v2 = &[10i, 11, 12];\n+    let vi = v.iter();\n+\n+    assert_eq!(c.size_hint(), (uint::MAX, None));\n+    assert_eq!(vi.size_hint(), (10, Some(10)));\n+\n+    assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(c.skip(5).size_hint().val1(), None);\n+    assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.enumerate().size_hint(), (uint::MAX, None));\n+    assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n+    assert_eq!(c.scan(0i, |_,_| Some(0i)).size_hint(), (0, None));\n+    assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n+    assert_eq!(c.map(|_| 0i).size_hint(), (uint::MAX, None));\n+    assert_eq!(c.filter_map(|_| Some(0i)).size_hint(), (0, None));\n+\n+    assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n+    assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n+    assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n+    assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n+    assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n+    assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n+    assert_eq!(vi.scan(0i, |_,_| Some(0i)).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n+    assert_eq!(vi.map(|i| i+1).size_hint(), (10, Some(10)));\n+    assert_eq!(vi.filter_map(|_| Some(0i)).size_hint(), (0, Some(10)));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let a = vec![1i, 2, 3, 4, 5];\n+    let b: Vec<int> = a.iter().map(|&x| x).collect();\n+    assert!(a == b);\n+}\n+\n+#[test]\n+fn test_all() {\n+    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    assert!(v.iter().all(|&x| x < 10));\n+    assert!(!v.iter().all(|&x| x % 2 == 0));\n+    assert!(!v.iter().all(|&x| x > 100));\n+    assert!(v.slice(0, 0).iter().all(|_| fail!()));\n+}\n+\n+#[test]\n+fn test_any() {\n+    let v: Box<&[int]> = box &[1i, 2, 3, 4, 5];\n+    assert!(v.iter().any(|&x| x < 10));\n+    assert!(v.iter().any(|&x| x % 2 == 0));\n+    assert!(!v.iter().any(|&x| x > 100));\n+    assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n+}\n+\n+#[test]\n+fn test_find() {\n+    let v: &[int] = &[1i, 3, 9, 27, 103, 14, 11];\n+    assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n+    assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n+    assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n+}\n+\n+#[test]\n+fn test_position() {\n+    let v = &[1i, 3, 9, 27, 103, 14, 11];\n+    assert_eq!(v.iter().position(|x| *x & 1 == 0).unwrap(), 5);\n+    assert_eq!(v.iter().position(|x| *x % 3 == 0).unwrap(), 1);\n+    assert!(v.iter().position(|x| *x % 12 == 0).is_none());\n+}\n+\n+#[test]\n+fn test_count() {\n+    let xs = &[1i, 2, 2, 1, 5, 9, 0, 2];\n+    assert_eq!(xs.iter().filter(|x| **x == 2).count(), 3);\n+    assert_eq!(xs.iter().filter(|x| **x == 5).count(), 1);\n+    assert_eq!(xs.iter().filter(|x| **x == 95).count(), 0);\n+}\n+\n+#[test]\n+fn test_max_by() {\n+    let xs: &[int] = &[-3i, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n+}\n+\n+#[test]\n+fn test_min_by() {\n+    let xs: &[int] = &[-3i, 0, 1, 5, -10];\n+    assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_by_ref() {\n+    let mut xs = range(0i, 10);\n+    // sum the first five values\n+    let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n+    assert_eq!(partial_sum, 10);\n+    assert_eq!(xs.next(), Some(5));\n+}\n+\n+#[test]\n+fn test_rev() {\n+    let xs = [2i, 4, 6, 8, 10, 12, 14, 16];\n+    let mut it = xs.iter();\n+    it.next();\n+    it.next();\n+    assert!(it.rev().map(|&x| x).collect::<Vec<int>>() ==\n+            vec![16, 14, 12, 10, 8, 6]);\n+}\n+\n+#[test]\n+fn test_double_ended_map() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().map(|&x| x * -1);\n+    assert_eq!(it.next(), Some(-1));\n+    assert_eq!(it.next(), Some(-2));\n+    assert_eq!(it.next_back(), Some(-6));\n+    assert_eq!(it.next_back(), Some(-5));\n+    assert_eq!(it.next(), Some(-3));\n+    assert_eq!(it.next_back(), Some(-4));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_enumerate() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().map(|&x| x).enumerate();\n+    assert_eq!(it.next(), Some((0, 1)));\n+    assert_eq!(it.next(), Some((1, 2)));\n+    assert_eq!(it.next_back(), Some((5, 6)));\n+    assert_eq!(it.next_back(), Some((4, 5)));\n+    assert_eq!(it.next_back(), Some((3, 4)));\n+    assert_eq!(it.next_back(), Some((2, 3)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_zip() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let ys = [1i, 2, 3, 7];\n+    let a = xs.iter().map(|&x| x);\n+    let b = ys.iter().map(|&x| x);\n+    let mut it = a.zip(b);\n+    assert_eq!(it.next(), Some((1, 1)));\n+    assert_eq!(it.next(), Some((2, 2)));\n+    assert_eq!(it.next_back(), Some((4, 7)));\n+    assert_eq!(it.next_back(), Some((3, 3)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_filter() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().filter(|&x| *x & 1 == 0);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.next().unwrap(), &2);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_filter_map() {\n+    let xs = [1i, 2, 3, 4, 5, 6];\n+    let mut it = xs.iter().filter_map(|&x| if x & 1 == 0 { Some(x * 2) } else { None });\n+    assert_eq!(it.next_back().unwrap(), 12);\n+    assert_eq!(it.next_back().unwrap(), 8);\n+    assert_eq!(it.next().unwrap(), 4);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n+#[test]\n+fn test_double_ended_chain() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let ys = [7i, 9, 11];\n+    let mut it = xs.iter().chain(ys.iter()).rev();\n+    assert_eq!(it.next().unwrap(), &11)\n+    assert_eq!(it.next().unwrap(), &9)\n+    assert_eq!(it.next_back().unwrap(), &1)\n+    assert_eq!(it.next_back().unwrap(), &2)\n+    assert_eq!(it.next_back().unwrap(), &3)\n+    assert_eq!(it.next_back().unwrap(), &4)\n+    assert_eq!(it.next_back().unwrap(), &5)\n+    assert_eq!(it.next_back().unwrap(), &7)\n+    assert_eq!(it.next_back(), None)\n+}\n+\n+#[test]\n+fn test_rposition() {\n+    fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+    fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n+    let v = [(0i, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+\n+    assert_eq!(v.iter().rposition(f), Some(3u));\n+    assert!(v.iter().rposition(g).is_none());\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_rposition_fail() {\n+    use std::gc::GC;\n+    let v = [(box 0i, box(GC) 0i), (box 0i, box(GC) 0i),\n+             (box 0i, box(GC) 0i), (box 0i, box(GC) 0i)];\n+    let mut i = 0i;\n+    v.iter().rposition(|_elt| {\n+        if i == 2 {\n+            fail!()\n+        }\n+        i += 1;\n+        false\n+    });\n+}\n+\n+\n+#[cfg(test)]\n+fn check_randacc_iter<A: PartialEq, T: Clone + RandomAccessIterator<A>>(a: T, len: uint)\n+{\n+    let mut b = a.clone();\n+    assert_eq!(len, b.indexable());\n+    let mut n = 0u;\n+    for (i, elt) in a.enumerate() {\n+        assert!(Some(elt) == b.idx(i));\n+        n += 1;\n+    }\n+    assert_eq!(n, len);\n+    assert!(None == b.idx(n));\n+    // call recursively to check after picking off an element\n+    if len > 0 {\n+        b.next();\n+        check_randacc_iter(b, len-1);\n+    }\n+}\n+\n+\n+#[test]\n+fn test_double_ended_flat_map() {\n+    let u = [0u,1];\n+    let v = [5u,6,7,8];\n+    let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(),      None);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n+#[test]\n+fn test_random_access_chain() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let ys = [7i, 9, 11];\n+    let mut it = xs.iter().chain(ys.iter());\n+    assert_eq!(it.idx(0).unwrap(), &1);\n+    assert_eq!(it.idx(5).unwrap(), &7);\n+    assert_eq!(it.idx(7).unwrap(), &11);\n+    assert!(it.idx(8).is_none());\n+\n+    it.next();\n+    it.next();\n+    it.next_back();\n+\n+    assert_eq!(it.idx(0).unwrap(), &3);\n+    assert_eq!(it.idx(4).unwrap(), &9);\n+    assert!(it.idx(6).is_none());\n+\n+    check_randacc_iter(it, xs.len() + ys.len() - 3);\n+}\n+\n+#[test]\n+fn test_random_access_enumerate() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    check_randacc_iter(xs.iter().enumerate(), xs.len());\n+}\n+\n+#[test]\n+fn test_random_access_rev() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    check_randacc_iter(xs.iter().rev(), xs.len());\n+    let mut it = xs.iter().rev();\n+    it.next();\n+    it.next_back();\n+    it.next();\n+    check_randacc_iter(it, xs.len() - 3);\n+}\n+\n+#[test]\n+fn test_random_access_zip() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let ys = [7i, 9, 11];\n+    check_randacc_iter(xs.iter().zip(ys.iter()), cmp::min(xs.len(), ys.len()));\n+}\n+\n+#[test]\n+fn test_random_access_take() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let empty: &[int] = [];\n+    check_randacc_iter(xs.iter().take(3), 3);\n+    check_randacc_iter(xs.iter().take(20), xs.len());\n+    check_randacc_iter(xs.iter().take(0), 0);\n+    check_randacc_iter(empty.iter().take(2), 0);\n+}\n+\n+#[test]\n+fn test_random_access_skip() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let empty: &[int] = [];\n+    check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n+    check_randacc_iter(empty.iter().skip(2), 0);\n+}\n+\n+#[test]\n+fn test_random_access_inspect() {\n+    let xs = [1i, 2, 3, 4, 5];\n+\n+    // test .map and .inspect that don't implement Clone\n+    let mut it = xs.iter().inspect(|_| {});\n+    assert_eq!(xs.len(), it.indexable());\n+    for (i, elt) in xs.iter().enumerate() {\n+        assert_eq!(Some(elt), it.idx(i));\n+    }\n+\n+}\n+\n+#[test]\n+fn test_random_access_map() {\n+    let xs = [1i, 2, 3, 4, 5];\n+\n+    let mut it = xs.iter().map(|x| *x);\n+    assert_eq!(xs.len(), it.indexable());\n+    for (i, elt) in xs.iter().enumerate() {\n+        assert_eq!(Some(*elt), it.idx(i));\n+    }\n+}\n+\n+#[test]\n+fn test_random_access_cycle() {\n+    let xs = [1i, 2, 3, 4, 5];\n+    let empty: &[int] = [];\n+    check_randacc_iter(xs.iter().cycle().take(27), 27);\n+    check_randacc_iter(empty.iter().cycle(), 0);\n+}\n+\n+#[test]\n+fn test_double_ended_range() {\n+    assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n+    for _ in range(10i, 0).rev() {\n+        fail!(\"unreachable\");\n+    }\n+\n+    assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n+    for _ in range(10u, 0).rev() {\n+        fail!(\"unreachable\");\n+    }\n+}\n+\n+#[test]\n+fn test_range() {\n+    /// A mock type to check Range when ToPrimitive returns None\n+    struct Foo;\n+\n+    impl ToPrimitive for Foo {\n+        fn to_i64(&self) -> Option<i64> { None }\n+        fn to_u64(&self) -> Option<u64> { None }\n+    }\n+\n+    impl Add<Foo, Foo> for Foo {\n+        fn add(&self, _: &Foo) -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, _: &Foo) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl PartialOrd for Foo {\n+        fn lt(&self, _: &Foo) -> bool {\n+            false\n+        }\n+    }\n+\n+    impl Clone for Foo {\n+        fn clone(&self) -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    impl Mul<Foo, Foo> for Foo {\n+        fn mul(&self, _: &Foo) -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    impl num::One for Foo {\n+        fn one() -> Foo {\n+            Foo\n+        }\n+    }\n+\n+    assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n+    assert!(range(-10i, -1).collect::<Vec<int>>() ==\n+               vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+    assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n+    assert_eq!(range(200i, -5).count(), 0);\n+    assert_eq!(range(200i, -5).rev().count(), 0);\n+    assert_eq!(range(200i, 200).count(), 0);\n+    assert_eq!(range(200i, 200).rev().count(), 0);\n+\n+    assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n+    // this test is only meaningful when sizeof uint < sizeof u64\n+    assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n+    assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n+    assert_eq!(range(Foo, Foo).size_hint(), (0, None));\n+}\n+\n+#[test]\n+fn test_range_inclusive() {\n+    assert!(range_inclusive(0i, 5).collect::<Vec<int>>() ==\n+            vec![0i, 1, 2, 3, 4, 5]);\n+    assert!(range_inclusive(0i, 5).rev().collect::<Vec<int>>() ==\n+            vec![5i, 4, 3, 2, 1, 0]);\n+    assert_eq!(range_inclusive(200i, -5).count(), 0);\n+    assert_eq!(range_inclusive(200i, -5).rev().count(), 0);\n+    assert!(range_inclusive(200i, 200).collect::<Vec<int>>() == vec![200]);\n+    assert!(range_inclusive(200i, 200).rev().collect::<Vec<int>>() == vec![200]);\n+}\n+\n+#[test]\n+fn test_range_step() {\n+    assert!(range_step(0i, 20, 5).collect::<Vec<int>>() ==\n+            vec![0, 5, 10, 15]);\n+    assert!(range_step(20i, 0, -5).collect::<Vec<int>>() ==\n+            vec![20, 15, 10, 5]);\n+    assert!(range_step(20i, 0, -6).collect::<Vec<int>>() ==\n+            vec![20, 14, 8, 2]);\n+    assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n+            vec![200u8, 250]);\n+    assert!(range_step(200i, -5, 1).collect::<Vec<int>>() == vec![]);\n+    assert!(range_step(200i, 200, 1).collect::<Vec<int>>() == vec![]);\n+}\n+\n+#[test]\n+fn test_range_step_inclusive() {\n+    assert!(range_step_inclusive(0i, 20, 5).collect::<Vec<int>>() ==\n+            vec![0, 5, 10, 15, 20]);\n+    assert!(range_step_inclusive(20i, 0, -5).collect::<Vec<int>>() ==\n+            vec![20, 15, 10, 5, 0]);\n+    assert!(range_step_inclusive(20i, 0, -6).collect::<Vec<int>>() ==\n+            vec![20, 14, 8, 2]);\n+    assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n+            vec![200u8, 250]);\n+    assert!(range_step_inclusive(200i, -5, 1).collect::<Vec<int>>() ==\n+            vec![]);\n+    assert!(range_step_inclusive(200i, 200, 1).collect::<Vec<int>>() ==\n+            vec![200]);\n+}\n+\n+#[test]\n+fn test_reverse() {\n+    let mut ys = [1i, 2, 3, 4, 5];\n+    ys.mut_iter().reverse_();\n+    assert!(ys == [5, 4, 3, 2, 1]);\n+}\n+\n+#[test]\n+fn test_peekable_is_empty() {\n+    let a = [1i];\n+    let mut it = a.iter().peekable();\n+    assert!( !it.is_empty() );\n+    it.next();\n+    assert!( it.is_empty() );\n+}\n+\n+#[test]\n+fn test_min_max() {\n+    let v: [int, ..0] = [];\n+    assert_eq!(v.iter().min_max(), NoElements);\n+\n+    let v = [1i];\n+    assert!(v.iter().min_max() == OneElement(&1));\n+\n+    let v = [1i, 2, 3, 4, 5];\n+    assert!(v.iter().min_max() == MinMax(&1, &5));\n+\n+    let v = [1i, 2, 3, 4, 5, 6];\n+    assert!(v.iter().min_max() == MinMax(&1, &6));\n+\n+    let v = [1i, 1, 1, 1];\n+    assert!(v.iter().min_max() == MinMax(&1, &1));\n+}\n+\n+#[test]\n+fn test_min_max_result() {\n+    let r: MinMaxResult<int> = NoElements;\n+    assert_eq!(r.into_option(), None)\n+\n+    let r = OneElement(1i);\n+    assert_eq!(r.into_option(), Some((1,1)));\n+\n+    let r = MinMax(1i,2);\n+    assert_eq!(r.into_option(), Some((1,2)));\n+}"}, {"sha": "3a3cac542c91b34a1092e444d25d01bdf82e1580", "filename": "src/libcoretest/lib.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(globs, unsafe_destructor, macro_rules)]\n+\n+extern crate core;\n+extern crate test;\n+extern crate libc;\n+\n+mod any;\n+mod atomics;\n+mod cell;\n+mod char;\n+mod cmp;\n+mod finally;\n+mod fmt;\n+mod iter;\n+mod mem;\n+mod num;\n+mod ops;\n+mod option;\n+mod ptr;\n+mod raw;\n+mod result;\n+mod tuple;"}, {"sha": "fde640158f51e09c9a9c269cd99274638cb62009", "filename": "src/libcoretest/mem.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use core::mem::*;\n+use test::Bencher;\n+\n+#[test]\n+fn size_of_basic() {\n+    assert_eq!(size_of::<u8>(), 1u);\n+    assert_eq!(size_of::<u16>(), 2u);\n+    assert_eq!(size_of::<u32>(), 4u);\n+    assert_eq!(size_of::<u64>(), 8u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"mips\")]\n+#[cfg(target_arch = \"mipsel\")]\n+fn size_of_32() {\n+    assert_eq!(size_of::<uint>(), 4u);\n+    assert_eq!(size_of::<*const uint>(), 4u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86_64\")]\n+fn size_of_64() {\n+    assert_eq!(size_of::<uint>(), 8u);\n+    assert_eq!(size_of::<*const uint>(), 8u);\n+}\n+\n+#[test]\n+fn size_of_val_basic() {\n+    assert_eq!(size_of_val(&1u8), 1);\n+    assert_eq!(size_of_val(&1u16), 2);\n+    assert_eq!(size_of_val(&1u32), 4);\n+    assert_eq!(size_of_val(&1u64), 8);\n+}\n+\n+#[test]\n+fn align_of_basic() {\n+    assert_eq!(align_of::<u8>(), 1u);\n+    assert_eq!(align_of::<u16>(), 2u);\n+    assert_eq!(align_of::<u32>(), 4u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"mips\")]\n+#[cfg(target_arch = \"mipsel\")]\n+fn align_of_32() {\n+    assert_eq!(align_of::<uint>(), 4u);\n+    assert_eq!(align_of::<*const uint>(), 4u);\n+}\n+\n+#[test]\n+#[cfg(target_arch = \"x86_64\")]\n+fn align_of_64() {\n+    assert_eq!(align_of::<uint>(), 8u);\n+    assert_eq!(align_of::<*const uint>(), 8u);\n+}\n+\n+#[test]\n+fn align_of_val_basic() {\n+    assert_eq!(align_of_val(&1u8), 1u);\n+    assert_eq!(align_of_val(&1u16), 2u);\n+    assert_eq!(align_of_val(&1u32), 4u);\n+}\n+\n+#[test]\n+fn test_swap() {\n+    let mut x = 31337i;\n+    let mut y = 42i;\n+    swap(&mut x, &mut y);\n+    assert_eq!(x, 42);\n+    assert_eq!(y, 31337);\n+}\n+\n+#[test]\n+fn test_replace() {\n+    let mut x = Some(\"test\".to_string());\n+    let y = replace(&mut x, None);\n+    assert!(x.is_none());\n+    assert!(y.is_some());\n+}\n+\n+#[test]\n+fn test_transmute_copy() {\n+    assert_eq!(1u, unsafe { transmute_copy(&1i) });\n+}\n+\n+#[test]\n+fn test_transmute() {\n+    trait Foo {}\n+    impl Foo for int {}\n+\n+    let a = box 100i as Box<Foo>;\n+    unsafe {\n+        let x: ::core::raw::TraitObject = transmute(a);\n+        assert!(*(x.data as *const int) == 100);\n+        let _x: Box<Foo> = transmute(x);\n+    }\n+\n+    unsafe {\n+        assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n+    }\n+}\n+\n+// FIXME #13642 (these benchmarks should be in another place)\n+/// Completely miscellaneous language-construct benchmarks.\n+// Static/dynamic method dispatch\n+\n+struct Struct {\n+    field: int\n+}\n+\n+trait Trait {\n+    fn method(&self) -> int;\n+}\n+\n+impl Trait for Struct {\n+    fn method(&self) -> int {\n+        self.field\n+    }\n+}\n+\n+#[bench]\n+fn trait_vtable_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    let t = &s as &Trait;\n+    b.iter(|| {\n+        t.method()\n+    });\n+}\n+\n+#[bench]\n+fn trait_static_method_call(b: &mut Bencher) {\n+    let s = Struct { field: 10 };\n+    b.iter(|| {\n+        s.method()\n+    });\n+}\n+\n+// Overhead of various match forms\n+\n+#[bench]\n+fn match_option_some(b: &mut Bencher) {\n+    let x = Some(10i);\n+    b.iter(|| {\n+        match x {\n+            Some(y) => y,\n+            None => 11\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn match_vec_pattern(b: &mut Bencher) {\n+    let x = [1i,2,3,4,5,6];\n+    b.iter(|| {\n+        match x {\n+            [1,2,3,..] => 10i,\n+            _ => 11i,\n+        }\n+    });\n+}"}, {"sha": "f3c2d67cdeb1b7c6eb29e7a131f06ec092ff9376", "filename": "src/libcoretest/num/i16.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi16.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i16, i16)"}, {"sha": "7232fc7505df9af78fcc16af60e9dbcd1f7cfb16", "filename": "src/libcoretest/num/i32.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi32.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i32, i32)"}, {"sha": "075b8448f3529e5a35aeb5d4ed01c3620f894cec", "filename": "src/libcoretest/num/i64.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi64.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i64, i64)"}, {"sha": "9e0439f281889ba32393e0752e40d4da0e6fb53c", "filename": "src/libcoretest/num/i8.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi8.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(i8, i8)"}, {"sha": "f01ec3f0310a31d7ac34ed394fa8673422e5ea49", "filename": "src/libcoretest/num/int.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+int_module!(int, int)"}, {"sha": "940b036ca907be036b4a7003ba70186d79c66738", "filename": "src/libcoretest/num/int_macros.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+macro_rules! int_module (($T:ty, $T_i:ident) => (\n+#[cfg(test)]\n+mod tests {\n+    use core::$T_i::*;\n+    use core::int;\n+    use num;\n+    use core::num::CheckedDiv;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert!(MIN + MAX + 1 == 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    pub fn test_abs() {\n+        assert!((1 as $T).abs() == 1 as $T);\n+        assert!((0 as $T).abs() == 0 as $T);\n+        assert!((-1 as $T).abs() == 1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_abs_sub() {\n+        assert!((-1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(1 as $T)) == 0 as $T);\n+        assert!((1 as $T).abs_sub(&(0 as $T)) == 1 as $T);\n+        assert!((1 as $T).abs_sub(&(-1 as $T)) == 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_signum() {\n+        assert!((1 as $T).signum() == 1 as $T);\n+        assert!((0 as $T).signum() == 0 as $T);\n+        assert!((-0 as $T).signum() == 0 as $T);\n+        assert!((-1 as $T).signum() == -1 as $T);\n+    }\n+\n+    #[test]\n+    fn test_is_positive() {\n+        assert!((1 as $T).is_positive());\n+        assert!(!(0 as $T).is_positive());\n+        assert!(!(-0 as $T).is_positive());\n+        assert!(!(-1 as $T).is_positive());\n+    }\n+\n+    #[test]\n+    fn test_is_negative() {\n+        assert!(!(1 as $T).is_negative());\n+        assert!(!(0 as $T).is_negative());\n+        assert!(!(-0 as $T).is_negative());\n+        assert!((-1 as $T).is_negative());\n+    }\n+\n+    #[test]\n+    fn test_bitwise_operators() {\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n+    }\n+\n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n+    }\n+\n+    #[test]\n+    fn test_swap_bytes() {\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n+    }\n+\n+    #[test]\n+    fn test_le() {\n+        assert_eq!(Int::from_le(A.to_le()), A);\n+        assert_eq!(Int::from_le(B.to_le()), B);\n+        assert_eq!(Int::from_le(C.to_le()), C);\n+        assert_eq!(Int::from_le(_0), _0);\n+        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!(_0.to_le(), _0);\n+        assert_eq!(_1.to_le(), _1);\n+    }\n+\n+    #[test]\n+    fn test_be() {\n+        assert_eq!(Int::from_be(A.to_be()), A);\n+        assert_eq!(Int::from_be(B.to_be()), B);\n+        assert_eq!(Int::from_be(C.to_be()), C);\n+        assert_eq!(Int::from_be(_0), _0);\n+        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!(_0.to_be(), _0);\n+        assert_eq!(_1.to_be(), _1);\n+    }\n+\n+    #[test]\n+    fn test_signed_checked_div() {\n+        assert!(10i.checked_div(&2) == Some(5));\n+        assert!(5i.checked_div(&0) == None);\n+        assert!(int::MIN.checked_div(&-1) == None);\n+    }\n+}\n+\n+))"}, {"sha": "8bb238c0b66e8be401b2c1ab758d4d90c6bbc4d6", "filename": "src/libcoretest/num/mod.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::num::cast;\n+\n+mod int_macros;\n+mod i8;\n+mod i16;\n+mod i32;\n+mod i64;\n+mod int;\n+mod uint_macros;\n+mod u8;\n+mod u16;\n+mod u32;\n+mod u64;\n+mod uint;\n+\n+/// Helper function for testing numeric operations\n+pub fn test_num<T:Num + NumCast + ::std::fmt::Show>(ten: T, two: T) {\n+    assert_eq!(ten.add(&two),  cast(12i).unwrap());\n+    assert_eq!(ten.sub(&two),  cast(8i).unwrap());\n+    assert_eq!(ten.mul(&two),  cast(20i).unwrap());\n+    assert_eq!(ten.div(&two),  cast(5i).unwrap());\n+    assert_eq!(ten.rem(&two),  cast(0i).unwrap());\n+\n+    assert_eq!(ten.add(&two),  ten + two);\n+    assert_eq!(ten.sub(&two),  ten - two);\n+    assert_eq!(ten.mul(&two),  ten * two);\n+    assert_eq!(ten.div(&two),  ten / two);\n+    assert_eq!(ten.rem(&two),  ten % two);\n+}"}, {"sha": "d6aa6476678040e7bc2218c870c9780105d5fcb5", "filename": "src/libcoretest/num/u16.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu16.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u16, u16)"}, {"sha": "218e79df5aecec458dcb8fa4ec33e062cf995bce", "filename": "src/libcoretest/num/u32.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu32.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u32, u32)"}, {"sha": "f78d4813503e7349fa1c1e584d50fbae26b5c56c", "filename": "src/libcoretest/num/u64.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu64.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u64, u64)"}, {"sha": "bb08072320b70cad64ac9c75d00c05058e0a61f9", "filename": "src/libcoretest/num/u8.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu8.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(u8, u8)"}, {"sha": "0db865f4cde7ac0db43f222eb13db6b011c91e49", "filename": "src/libcoretest/num/uint.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+uint_module!(uint, uint)"}, {"sha": "2272af67daf8580b7303aeb1f84d4a341ba70a5a", "filename": "src/libcoretest/num/uint_macros.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,118 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+macro_rules! uint_module (($T:ty, $T_i:ident) => (\n+#[cfg(test)]\n+mod tests {\n+    use core::$T_i::*;\n+    use num;\n+    use core::num::CheckedDiv;\n+\n+    #[test]\n+    fn test_overflows() {\n+        assert!(MAX > 0);\n+        assert!(MIN <= 0);\n+        assert!(MIN + MAX + 1 == 0);\n+    }\n+\n+    #[test]\n+    fn test_num() {\n+        num::test_num(10 as $T, 2 as $T);\n+    }\n+\n+    #[test]\n+    fn test_bitwise_operators() {\n+        assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n+        assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n+        assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n+        assert!(0b1110 as $T == (0b0111 as $T).shl(&(1 as $T)));\n+        assert!(0b0111 as $T == (0b1110 as $T).shr(&(1 as $T)));\n+        assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n+    }\n+\n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n+    #[test]\n+    fn test_count_ones() {\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n+    }\n+\n+    #[test]\n+    fn test_count_zeros() {\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n+    }\n+\n+    #[test]\n+    fn test_swap_bytes() {\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+        // Swapping these should make no difference\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n+    }\n+\n+    #[test]\n+    fn test_le() {\n+        assert_eq!(Int::from_le(A.to_le()), A);\n+        assert_eq!(Int::from_le(B.to_le()), B);\n+        assert_eq!(Int::from_le(C.to_le()), C);\n+        assert_eq!(Int::from_le(_0), _0);\n+        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!(_0.to_le(), _0);\n+        assert_eq!(_1.to_le(), _1);\n+    }\n+\n+    #[test]\n+    fn test_be() {\n+        assert_eq!(Int::from_be(A.to_be()), A);\n+        assert_eq!(Int::from_be(B.to_be()), B);\n+        assert_eq!(Int::from_be(C.to_be()), C);\n+        assert_eq!(Int::from_be(_0), _0);\n+        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!(_0.to_be(), _0);\n+        assert_eq!(_1.to_be(), _1);\n+    }\n+\n+    #[test]\n+    fn test_unsigned_checked_div() {\n+        assert!(10u.checked_div(&2) == Some(5));\n+        assert!(5u.checked_div(&0) == None);\n+    }\n+}\n+))"}, {"sha": "447fd1c699d3d1bfe4d96664a931156671690781", "filename": "src/libcoretest/ops.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::Bencher;\n+\n+// Overhead of dtors\n+\n+struct HasDtor {\n+    _x: int\n+}\n+\n+impl Drop for HasDtor {\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+#[bench]\n+fn alloc_obj_with_dtor(b: &mut Bencher) {\n+    b.iter(|| {\n+        HasDtor { _x : 10 };\n+    })\n+}"}, {"sha": "776637f3be97d5c59c49d85f87ea594bdfc046ba", "filename": "src/libcoretest/option.rs", "status": "added", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,278 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::option::*;\n+use core::kinds::marker;\n+use core::mem;\n+\n+#[test]\n+fn test_get_ptr() {\n+    unsafe {\n+        let x = box 0i;\n+        let addr_x: *const int = mem::transmute(&*x);\n+        let opt = Some(x);\n+        let y = opt.unwrap();\n+        let addr_y: *const int = mem::transmute(&*y);\n+        assert_eq!(addr_x, addr_y);\n+    }\n+}\n+\n+#[test]\n+fn test_get_str() {\n+    let x = \"test\".to_string();\n+    let addr_x = x.as_slice().as_ptr();\n+    let opt = Some(x);\n+    let y = opt.unwrap();\n+    let addr_y = y.as_slice().as_ptr();\n+    assert_eq!(addr_x, addr_y);\n+}\n+\n+#[test]\n+fn test_get_resource() {\n+    use std::rc::Rc;\n+    use core::cell::RefCell;\n+\n+    struct R {\n+       i: Rc<RefCell<int>>,\n+    }\n+\n+    #[unsafe_destructor]\n+    impl Drop for R {\n+       fn drop(&mut self) {\n+            let ii = &*self.i;\n+            let i = *ii.borrow();\n+            *ii.borrow_mut() = i + 1;\n+        }\n+    }\n+\n+    fn r(i: Rc<RefCell<int>>) -> R {\n+        R {\n+            i: i\n+        }\n+    }\n+\n+    let i = Rc::new(RefCell::new(0i));\n+    {\n+        let x = r(i.clone());\n+        let opt = Some(x);\n+        let _y = opt.unwrap();\n+    }\n+    assert_eq!(*i.borrow(), 1);\n+}\n+\n+#[test]\n+fn test_option_dance() {\n+    let x = Some(());\n+    let mut y = Some(5i);\n+    let mut y2 = 0;\n+    for _x in x.iter() {\n+        y2 = y.take_unwrap();\n+    }\n+    assert_eq!(y2, 5);\n+    assert!(y.is_none());\n+}\n+\n+#[test] #[should_fail]\n+fn test_option_too_much_dance() {\n+    let mut y = Some(marker::NoCopy);\n+    let _y2 = y.take_unwrap();\n+    let _y3 = y.take_unwrap();\n+}\n+\n+#[test]\n+fn test_and() {\n+    let x: Option<int> = Some(1i);\n+    assert_eq!(x.and(Some(2i)), Some(2));\n+    assert_eq!(x.and(None::<int>), None);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.and(Some(2i)), None);\n+    assert_eq!(x.and(None::<int>), None);\n+}\n+\n+#[test]\n+fn test_and_then() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n+    assert_eq!(x.and_then(|_| None::<int>), None);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.and_then(|x| Some(x + 1)), None);\n+    assert_eq!(x.and_then(|_| None::<int>), None);\n+}\n+\n+#[test]\n+fn test_or() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.or(Some(2)), Some(1));\n+    assert_eq!(x.or(None), Some(1));\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.or(Some(2)), Some(2));\n+    assert_eq!(x.or(None), None);\n+}\n+\n+#[test]\n+fn test_or_else() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.or_else(|| Some(2)), Some(1));\n+    assert_eq!(x.or_else(|| None), Some(1));\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.or_else(|| Some(2)), Some(2));\n+    assert_eq!(x.or_else(|| None), None);\n+}\n+\n+#[test]\n+fn test_option_while_some() {\n+    let mut i = 0i;\n+    Some(10i).while_some(|j| {\n+        i += 1;\n+        if j > 0 {\n+            Some(j-1)\n+        } else {\n+            None\n+        }\n+    });\n+    assert_eq!(i, 11);\n+}\n+\n+#[test]\n+fn test_unwrap() {\n+    assert_eq!(Some(1i).unwrap(), 1);\n+    let s = Some(\"hello\".to_string()).unwrap();\n+    assert_eq!(s.as_slice(), \"hello\");\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_unwrap_fail1() {\n+    let x: Option<int> = None;\n+    x.unwrap();\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_unwrap_fail2() {\n+    let x: Option<String> = None;\n+    x.unwrap();\n+}\n+\n+#[test]\n+fn test_unwrap_or() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.unwrap_or(2), 1);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.unwrap_or(2), 2);\n+}\n+\n+#[test]\n+fn test_unwrap_or_else() {\n+    let x: Option<int> = Some(1);\n+    assert_eq!(x.unwrap_or_else(|| 2), 1);\n+\n+    let x: Option<int> = None;\n+    assert_eq!(x.unwrap_or_else(|| 2), 2);\n+}\n+\n+#[test]\n+fn test_filtered() {\n+    let some_stuff = Some(42i);\n+    let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n+    assert_eq!(some_stuff.unwrap(), 42);\n+    assert!(modified_stuff.is_none());\n+}\n+\n+#[test]\n+fn test_iter() {\n+    let val = 5i;\n+\n+    let x = Some(val);\n+    let mut it = x.iter();\n+\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next(), Some(&val));\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_mut_iter() {\n+    let val = 5i;\n+    let new_val = 11i;\n+\n+    let mut x = Some(val);\n+    {\n+        let mut it = x.mut_iter();\n+\n+        assert_eq!(it.size_hint(), (1, Some(1)));\n+\n+        match it.next() {\n+            Some(interior) => {\n+                assert_eq!(*interior, val);\n+                *interior = new_val;\n+            }\n+            None => assert!(false),\n+        }\n+\n+        assert_eq!(it.size_hint(), (0, Some(0)));\n+        assert!(it.next().is_none());\n+    }\n+    assert_eq!(x, Some(new_val));\n+}\n+\n+#[test]\n+fn test_ord() {\n+    let small = Some(1.0f64);\n+    let big = Some(5.0f64);\n+    let nan = Some(0.0f64/0.0);\n+    assert!(!(nan < big));\n+    assert!(!(nan > big));\n+    assert!(small < big);\n+    assert!(None < big);\n+    assert!(big > None);\n+}\n+\n+#[test]\n+fn test_mutate() {\n+    let mut x = Some(3i);\n+    assert!(x.mutate(|i| i+1));\n+    assert_eq!(x, Some(4i));\n+    assert!(x.mutate_or_set(0, |i| i+1));\n+    assert_eq!(x, Some(5i));\n+    x = None;\n+    assert!(!x.mutate(|i| i+1));\n+    assert_eq!(x, None);\n+    assert!(!x.mutate_or_set(0i, |i| i+1));\n+    assert_eq!(x, Some(0i));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let v: Option<Vec<int>> = collect(range(0i, 0)\n+                                      .map(|_| Some(0i)));\n+    assert!(v == Some(vec![]));\n+\n+    let v: Option<Vec<int>> = collect(range(0i, 3)\n+                                      .map(|x| Some(x)));\n+    assert!(v == Some(vec![0, 1, 2]));\n+\n+    let v: Option<Vec<int>> = collect(range(0i, 3)\n+                                      .map(|x| if x > 1 { None } else { Some(x) }));\n+    assert!(v == None);\n+\n+    // test that it does not take more elements than it needs\n+    let mut functions = [|| Some(()), || None, || fail!()];\n+\n+    let v: Option<Vec<()>> = collect(functions.mut_iter().map(|f| (*f)()));\n+\n+    assert!(v == None);\n+}"}, {"sha": "2a4ef5e275d20b271eeaf6f8a18a63f3f6cbbe9a", "filename": "src/libcoretest/ptr.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,255 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(deprecated)]\n+use core::ptr::*;\n+use libc::c_char;\n+use core::mem;\n+use std::str;\n+use libc;\n+\n+#[test]\n+fn test() {\n+    unsafe {\n+        struct Pair {\n+            fst: int,\n+            snd: int\n+        };\n+        let mut p = Pair {fst: 10, snd: 20};\n+        let pptr: *mut Pair = &mut p;\n+        let iptr: *mut int = mem::transmute(pptr);\n+        assert_eq!(*iptr, 10);\n+        *iptr = 30;\n+        assert_eq!(*iptr, 30);\n+        assert_eq!(p.fst, 30);\n+\n+        *pptr = Pair {fst: 50, snd: 60};\n+        assert_eq!(*iptr, 50);\n+        assert_eq!(p.fst, 50);\n+        assert_eq!(p.snd, 60);\n+\n+        let v0 = vec![32000u16, 32001u16, 32002u16];\n+        let mut v1 = vec![0u16, 0u16, 0u16];\n+\n+        copy_memory(v1.as_mut_ptr().offset(1),\n+                    v0.as_ptr().offset(1), 1);\n+        assert!((*v1.get(0) == 0u16 &&\n+                 *v1.get(1) == 32001u16 &&\n+                 *v1.get(2) == 0u16));\n+        copy_memory(v1.as_mut_ptr(),\n+                    v0.as_ptr().offset(2), 1);\n+        assert!((*v1.get(0) == 32002u16 &&\n+                 *v1.get(1) == 32001u16 &&\n+                 *v1.get(2) == 0u16));\n+        copy_memory(v1.as_mut_ptr().offset(2),\n+                    v0.as_ptr(), 1u);\n+        assert!((*v1.get(0) == 32002u16 &&\n+                 *v1.get(1) == 32001u16 &&\n+                 *v1.get(2) == 32000u16));\n+    }\n+}\n+\n+#[test]\n+fn test_position() {\n+    use libc::c_char;\n+\n+    \"hello\".with_c_str(|p| {\n+        unsafe {\n+            assert!(2u == position(p, |c| *c == 'l' as c_char));\n+            assert!(4u == position(p, |c| *c == 'o' as c_char));\n+            assert!(5u == position(p, |c| *c == 0 as c_char));\n+        }\n+    })\n+}\n+\n+#[test]\n+fn test_buf_len() {\n+    \"hello\".with_c_str(|p0| {\n+        \"there\".with_c_str(|p1| {\n+            \"thing\".with_c_str(|p2| {\n+                let v = vec![p0, p1, p2, null()];\n+                unsafe {\n+                    assert_eq!(buf_len(v.as_ptr()), 3u);\n+                }\n+            })\n+        })\n+    })\n+}\n+\n+#[test]\n+fn test_is_null() {\n+    let p: *const int = null();\n+    assert!(p.is_null());\n+    assert!(!p.is_not_null());\n+\n+    let q = unsafe { p.offset(1) };\n+    assert!(!q.is_null());\n+    assert!(q.is_not_null());\n+\n+    let mp: *mut int = mut_null();\n+    assert!(mp.is_null());\n+    assert!(!mp.is_not_null());\n+\n+    let mq = unsafe { mp.offset(1) };\n+    assert!(!mq.is_null());\n+    assert!(mq.is_not_null());\n+}\n+\n+#[test]\n+fn test_to_option() {\n+    unsafe {\n+        let p: *const int = null();\n+        assert_eq!(p.to_option(), None);\n+\n+        let q: *const int = &2;\n+        assert_eq!(q.to_option().unwrap(), &2);\n+\n+        let p: *mut int = mut_null();\n+        assert_eq!(p.to_option(), None);\n+\n+        let q: *mut int = &mut 2;\n+        assert_eq!(q.to_option().unwrap(), &2);\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_addition() {\n+    unsafe {\n+        let xs = Vec::from_elem(16, 5i);\n+        let mut ptr = xs.as_ptr();\n+        let end = ptr.offset(16);\n+\n+        while ptr < end {\n+            assert_eq!(*ptr, 5);\n+            ptr = ptr.offset(1);\n+        }\n+\n+        let mut xs_mut = xs;\n+        let mut m_ptr = xs_mut.as_mut_ptr();\n+        let m_end = m_ptr.offset(16);\n+\n+        while m_ptr < m_end {\n+            *m_ptr += 5;\n+            m_ptr = m_ptr.offset(1);\n+        }\n+\n+        assert!(xs_mut == Vec::from_elem(16, 10i));\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_subtraction() {\n+    unsafe {\n+        let xs = vec![0,1,2,3,4,5,6,7,8,9];\n+        let mut idx = 9i8;\n+        let ptr = xs.as_ptr();\n+\n+        while idx >= 0i8 {\n+            assert_eq!(*(ptr.offset(idx as int)), idx as int);\n+            idx = idx - 1i8;\n+        }\n+\n+        let mut xs_mut = xs;\n+        let m_start = xs_mut.as_mut_ptr();\n+        let mut m_ptr = m_start.offset(9);\n+\n+        while m_ptr >= m_start {\n+            *m_ptr += *m_ptr;\n+            m_ptr = m_ptr.offset(-1);\n+        }\n+\n+        assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_array_each_with_len() {\n+    unsafe {\n+        let one = \"oneOne\".to_c_str();\n+        let two = \"twoTwo\".to_c_str();\n+        let three = \"threeThree\".to_c_str();\n+        let arr = vec![\n+            one.as_ptr(),\n+            two.as_ptr(),\n+            three.as_ptr()\n+        ];\n+        let expected_arr = [\n+            one, two, three\n+        ];\n+\n+        let mut ctr = 0;\n+        let mut iteration_count = 0;\n+        array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n+                assert_eq!(actual.as_slice(), expected.as_slice());\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+        assert_eq!(iteration_count, 3u);\n+    }\n+}\n+\n+#[test]\n+fn test_ptr_array_each() {\n+    unsafe {\n+        let one = \"oneOne\".to_c_str();\n+        let two = \"twoTwo\".to_c_str();\n+        let three = \"threeThree\".to_c_str();\n+        let arr = vec![\n+            one.as_ptr(),\n+            two.as_ptr(),\n+            three.as_ptr(),\n+            // fake a null terminator\n+            null()\n+        ];\n+        let expected_arr = [\n+            one, two, three\n+        ];\n+\n+        let arr_ptr = arr.as_ptr();\n+        let mut ctr = 0u;\n+        let mut iteration_count = 0u;\n+        array_each(arr_ptr, |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = str::raw::from_c_str(expected_arr[ctr].as_ptr());\n+                assert_eq!(actual.as_slice(), expected.as_slice());\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+        assert_eq!(iteration_count, 3);\n+    }\n+}\n+\n+#[test]\n+#[should_fail]\n+fn test_ptr_array_each_with_len_null_ptr() {\n+    unsafe {\n+        array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n+            str::raw::from_c_str(e);\n+        });\n+    }\n+}\n+#[test]\n+#[should_fail]\n+fn test_ptr_array_each_null_ptr() {\n+    unsafe {\n+        array_each(0 as *const *const libc::c_char, |e| {\n+            str::raw::from_c_str(e);\n+        });\n+    }\n+}\n+\n+#[test]\n+fn test_set_memory() {\n+    let mut xs = [0u8, ..20];\n+    let ptr = xs.as_mut_ptr();\n+    unsafe { set_memory(ptr, 5u8, xs.len()); }\n+    assert!(xs == [5u8, ..20]);\n+}"}, {"sha": "f2c23c7c77327762e47e0fa49fa085bf3bc812fe", "filename": "src/libcoretest/raw.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fraw.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::raw::*;\n+use core::mem;\n+\n+#[test]\n+fn synthesize_closure() {\n+    unsafe {\n+        let x = 10;\n+        let f: |int| -> int = |y| x + y;\n+\n+        assert_eq!(f(20), 30);\n+\n+        let original_closure: Closure = mem::transmute(f);\n+\n+        let actual_function_pointer = original_closure.code;\n+        let environment = original_closure.env;\n+\n+        let new_closure = Closure {\n+            code: actual_function_pointer,\n+            env: environment\n+        };\n+\n+        let new_f: |int| -> int = mem::transmute(new_closure);\n+        assert_eq!(new_f(20), 30);\n+    }\n+}"}, {"sha": "7c7e0a542cd8729ac7c5298b34ba37cfc035983c", "filename": "src/libcoretest/result.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,161 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::result::{collect, fold, fold_};\n+use core::iter::range;\n+\n+pub fn op1() -> Result<int, &'static str> { Ok(666) }\n+pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n+\n+#[test]\n+pub fn test_and() {\n+    assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n+    assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n+               \"bad\");\n+\n+    assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n+    assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n+               \"sadface\");\n+}\n+\n+#[test]\n+pub fn test_and_then() {\n+    assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n+    assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+               \"bad\");\n+\n+    assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n+               \"sadface\");\n+    assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+               \"sadface\");\n+}\n+\n+#[test]\n+pub fn test_or() {\n+    assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n+    assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n+\n+    assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n+    assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n+}\n+\n+#[test]\n+pub fn test_or_else() {\n+    assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n+    assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n+\n+    assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n+    assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n+               \"sadface\");\n+}\n+\n+#[test]\n+pub fn test_impl_map() {\n+    assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n+    assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n+}\n+\n+#[test]\n+pub fn test_impl_map_err() {\n+    assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n+    assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n+}\n+\n+#[test]\n+fn test_collect() {\n+    let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n+    assert!(v == Ok(vec![]));\n+\n+    let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n+    assert!(v == Ok(vec![0, 1, 2]));\n+\n+    let v: Result<Vec<int>, int> = collect(range(0i, 3)\n+                                           .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+    assert!(v == Err(2));\n+\n+    // test that it does not take more elements than it needs\n+    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n+\n+    let v: Result<Vec<()>, int> = collect(functions.mut_iter().map(|f| (*f)()));\n+    assert!(v == Err(1));\n+}\n+\n+#[test]\n+fn test_fold() {\n+    assert_eq!(fold_(range(0i, 0)\n+                    .map(|_| Ok::<(), ()>(()))),\n+               Ok(()));\n+    assert_eq!(fold(range(0i, 3)\n+                    .map(|x| Ok::<int, ()>(x)),\n+                    0, |a, b| a + b),\n+               Ok(3));\n+    assert_eq!(fold_(range(0i, 3)\n+                    .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n+               Err(2));\n+\n+    // test that it does not take more elements than it needs\n+    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n+\n+    assert_eq!(fold_(functions.mut_iter()\n+                    .map(|f| (*f)())),\n+               Err(1));\n+}\n+\n+#[test]\n+pub fn test_fmt_default() {\n+    let ok: Result<int, &'static str> = Ok(100);\n+    let err: Result<int, &'static str> = Err(\"Err\");\n+\n+    let s = format!(\"{}\", ok);\n+    assert_eq!(s.as_slice(), \"Ok(100)\");\n+    let s = format!(\"{}\", err);\n+    assert_eq!(s.as_slice(), \"Err(Err)\");\n+}\n+\n+#[test]\n+pub fn test_unwrap_or() {\n+    let ok: Result<int, &'static str> = Ok(100i);\n+    let ok_err: Result<int, &'static str> = Err(\"Err\");\n+\n+    assert_eq!(ok.unwrap_or(50), 100);\n+    assert_eq!(ok_err.unwrap_or(50), 50);\n+}\n+\n+#[test]\n+pub fn test_unwrap_or_else() {\n+    fn handler(msg: &'static str) -> int {\n+        if msg == \"I got this.\" {\n+            50i\n+        } else {\n+            fail!(\"BadBad\")\n+        }\n+    }\n+\n+    let ok: Result<int, &'static str> = Ok(100);\n+    let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n+\n+    assert_eq!(ok.unwrap_or_else(handler), 100);\n+    assert_eq!(ok_err.unwrap_or_else(handler), 50);\n+}\n+\n+#[test]\n+#[should_fail]\n+pub fn test_unwrap_or_else_failure() {\n+    fn handler(msg: &'static str) -> int {\n+        if msg == \"I got this.\" {\n+            50i\n+        } else {\n+            fail!(\"BadBad\")\n+        }\n+    }\n+\n+    let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n+    let _ : int = bad_err.unwrap_or_else(handler);\n+}"}, {"sha": "be71e42ae9ad6561af273a2007dd1a218fd82f9a", "filename": "src/libcoretest/tuple.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+fn test_clone() {\n+    let a = (1i, \"2\");\n+    let b = a.clone();\n+    assert_eq!(a, b);\n+}\n+\n+#[test]\n+fn test_getters() {\n+    macro_rules! test_getter(\n+        ($x:expr, $valN:ident, $refN:ident, $mutN:ident,\n+         $init:expr, $incr:expr, $result:expr) => ({\n+            assert_eq!($x.$valN(), $init);\n+            assert_eq!(*$x.$refN(), $init);\n+            *$x.$mutN() += $incr;\n+            assert_eq!(*$x.$refN(), $result);\n+        })\n+    )\n+    let mut x = (0u8, 1u16, 2u32, 3u64, 4u, 5i8, 6i16, 7i32, 8i64, 9i, 10f32, 11f64);\n+    test_getter!(x, val0,  ref0,  mut0,  0,    1,   1);\n+    test_getter!(x, val1,  ref1,  mut1,  1,    1,   2);\n+    test_getter!(x, val2,  ref2,  mut2,  2,    1,   3);\n+    test_getter!(x, val3,  ref3,  mut3,  3,    1,   4);\n+    test_getter!(x, val4,  ref4,  mut4,  4,    1,   5);\n+    test_getter!(x, val5,  ref5,  mut5,  5,    1,   6);\n+    test_getter!(x, val6,  ref6,  mut6,  6,    1,   7);\n+    test_getter!(x, val7,  ref7,  mut7,  7,    1,   8);\n+    test_getter!(x, val8,  ref8,  mut8,  8,    1,   9);\n+    test_getter!(x, val9,  ref9,  mut9,  9,    1,   10);\n+    test_getter!(x, val10, ref10, mut10, 10.0, 1.0, 11.0);\n+    test_getter!(x, val11, ref11, mut11, 11.0, 1.0, 12.0);\n+}\n+\n+#[test]\n+fn test_tuple_cmp() {\n+    let (small, big) = ((1u, 2u, 3u), (3u, 2u, 1u));\n+\n+    let nan = 0.0f64/0.0;\n+\n+    // PartialEq\n+    assert_eq!(small, small);\n+    assert_eq!(big, big);\n+    assert!(small != big);\n+    assert!(big != small);\n+\n+    // PartialOrd\n+    assert!(small < big);\n+    assert!(!(small < small));\n+    assert!(!(big < small));\n+    assert!(!(big < big));\n+\n+    assert!(small <= small);\n+    assert!(big <= big);\n+\n+    assert!(big > small);\n+    assert!(small >= small);\n+    assert!(big >= small);\n+    assert!(big >= big);\n+\n+    assert!(!((1.0f64, 2.0f64) < (nan, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) <= (nan, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) > (nan, 3.0)));\n+    assert!(!((1.0f64, 2.0f64) >= (nan, 3.0)));\n+    assert!(((1.0f64, 2.0f64) < (2.0, nan)));\n+    assert!(!((2.0f64, 2.0f64) < (2.0, nan)));\n+\n+    // Ord\n+    assert!(small.cmp(&small) == Equal);\n+    assert!(big.cmp(&big) == Equal);\n+    assert!(small.cmp(&big) == Less);\n+    assert!(big.cmp(&small) == Greater);\n+}\n+\n+#[test]\n+fn test_show() {\n+    let s = format!(\"{}\", (1i,));\n+    assert_eq!(s.as_slice(), \"(1,)\");\n+    let s = format!(\"{}\", (1i, true));\n+    assert_eq!(s.as_slice(), \"(1, true)\");\n+    let s = format!(\"{}\", (1i, \"hi\", true));\n+    assert_eq!(s.as_slice(), \"(1, hi, true)\");\n+}"}, {"sha": "44988a23070d7ce68a7d13bc1a9cebf79ecc14f8", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5695b95c288c442dbe528f7e1c1b08f79f033d/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=bb5695b95c288c442dbe528f7e1c1b08f79f033d", "patch": "@@ -103,6 +103,13 @@ mod tests {\n     use super::*;\n     use cell::RefCell;\n \n+    #[test]\n+    fn test_managed_clone() {\n+        let a = box(GC) 5i;\n+        let b: Gc<int> = a.clone();\n+        assert!(a == b);\n+    }\n+\n     #[test]\n     fn test_clone() {\n         let x = Gc::new(RefCell::new(5));"}]}