{"sha": "13079c1a85c2f3391966cc108a48f2313596d78d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMDc5YzFhODVjMmYzMzkxOTY2Y2MxMDhhNDhmMjMxMzU5NmQ3OGQ=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-08-13T23:02:31Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-08-16T19:13:39Z"}, "message": "Optimized IR generation for UTF-8 and UTF-16 encoding\n\n- Both can now be inlined and constant folded away\n- Both can no longer cause failure\n- Both now return an `Option` instead\n\nRemoved debug `assert!()`s over the valid ranges of a `char`\n- It affected optimizations due to unwinding\n- Char handling is now sound enought that they became uneccessary", "tree": {"sha": "0a3e884a73861eb5357d1108b95139e745896377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a3e884a73861eb5357d1108b95139e745896377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13079c1a85c2f3391966cc108a48f2313596d78d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13079c1a85c2f3391966cc108a48f2313596d78d", "html_url": "https://github.com/rust-lang/rust/commit/13079c1a85c2f3391966cc108a48f2313596d78d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13079c1a85c2f3391966cc108a48f2313596d78d/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78ec3904b443c818d9f83e837ca13e5f197db740", "url": "https://api.github.com/repos/rust-lang/rust/commits/78ec3904b443c818d9f83e837ca13e5f197db740", "html_url": "https://github.com/rust-lang/rust/commit/78ec3904b443c818d9f83e837ca13e5f197db740"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "e968899d21d8fb521ef112a1bcd4de6a391e69ba", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -1680,7 +1680,7 @@ mod tests {\n     fn test_chars_decoding() {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(bytes);\n+            let len = c.encode_utf8(bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);\n@@ -1692,7 +1692,7 @@ mod tests {\n     fn test_chars_rev_decoding() {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(bytes);\n+            let len = c.encode_utf8(bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes.slice_to(len)).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 fail!(\"character {:x}={} does not decode correctly\", c as u32, c);"}, {"sha": "c31f4df31c4a1e5594b294a792efdd1472bee562", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -503,7 +503,7 @@ impl String {\n                 data: self.vec.as_ptr().offset(cur_len as int),\n                 len: 4,\n             };\n-            let used = ch.encode_utf8(mem::transmute(slice));\n+            let used = ch.encode_utf8(mem::transmute(slice)).unwrap_or(0);\n             self.vec.set_len(cur_len + used);\n         }\n     }"}, {"sha": "4e9a72c6af544c95974646b77c9420bdae10640c", "filename": "src/libcore/char.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -18,6 +18,7 @@\n use mem::transmute;\n use option::{None, Option, Some};\n use iter::range_step;\n+use collections::Collection;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: u8    = 0b1000_0000u8;\n@@ -27,7 +28,6 @@ static TAG_FOUR_B: u8  = 0b1111_0000u8;\n static MAX_ONE_B: u32   =     0x80u32;\n static MAX_TWO_B: u32   =    0x800u32;\n static MAX_THREE_B: u32 =  0x10000u32;\n-static MAX_FOUR_B:  u32 = 0x200000u32;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -217,14 +217,14 @@ pub fn escape_default(c: char, f: |char|) {\n }\n \n /// Returns the amount of bytes this `char` would need if encoded in UTF-8\n+#[inline]\n pub fn len_utf8_bytes(c: char) -> uint {\n     let code = c as u32;\n     match () {\n         _ if code < MAX_ONE_B   => 1u,\n         _ if code < MAX_TWO_B   => 2u,\n         _ if code < MAX_THREE_B => 3u,\n-        _ if code < MAX_FOUR_B  => 4u,\n-        _                       => fail!(\"invalid character!\"),\n+        _  => 4u,\n     }\n }\n \n@@ -297,21 +297,19 @@ pub trait Char {\n     /// UTF-8.\n     fn len_utf8_bytes(&self) -> uint;\n \n-    /// Encodes this character as UTF-8 into the provided byte buffer.\n-    ///\n-    /// The buffer must be at least 4 bytes long or a runtime failure may\n-    /// occur.\n+    /// Encodes this character as UTF-8 into the provided byte buffer,\n+    /// and then returns the number of bytes written.\n     ///\n-    /// This will then return the number of bytes written to the slice.\n-    fn encode_utf8(&self, dst: &mut [u8]) -> uint;\n+    /// If the buffer is not large enough, nothing will be written into it\n+    /// and a `None` will be returned.\n+    fn encode_utf8(&self, dst: &mut [u8]) -> Option<uint>;\n \n-    /// Encodes this character as UTF-16 into the provided `u16` buffer.\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer,\n+    /// and then returns the number of `u16`s written.\n     ///\n-    /// The buffer must be at least 2 elements long or a runtime failure may\n-    /// occur.\n-    ///\n-    /// This will then return the number of `u16`s written to the slice.\n-    fn encode_utf16(&self, dst: &mut [u16]) -> uint;\n+    /// If the buffer is not large enough, nothing will be written into it\n+    /// and a `None` will be returned.\n+    fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint>;\n }\n \n impl Char for char {\n@@ -325,45 +323,52 @@ impl Char for char {\n \n     fn escape_default(&self, f: |char|) { escape_default(*self, f) }\n \n+    #[inline]\n     fn len_utf8_bytes(&self) -> uint { len_utf8_bytes(*self) }\n \n-    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> uint {\n+    #[inline]\n+    fn encode_utf8<'a>(&self, dst: &'a mut [u8]) -> Option<uint> {\n+        // Marked #[inline] to allow llvm optimizing it away\n         let code = *self as u32;\n-        if code < MAX_ONE_B {\n+        if code < MAX_ONE_B && dst.len() >= 1 {\n             dst[0] = code as u8;\n-            1\n-        } else if code < MAX_TWO_B {\n+            Some(1)\n+        } else if code < MAX_TWO_B && dst.len() >= 2 {\n             dst[0] = (code >> 6u & 0x1F_u32) as u8 | TAG_TWO_B;\n             dst[1] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            2\n-        } else if code < MAX_THREE_B {\n+            Some(2)\n+        } else if code < MAX_THREE_B && dst.len() >= 3  {\n             dst[0] = (code >> 12u & 0x0F_u32) as u8 | TAG_THREE_B;\n             dst[1] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n             dst[2] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            3\n-        } else {\n+            Some(3)\n+        } else if dst.len() >= 4 {\n             dst[0] = (code >> 18u & 0x07_u32) as u8 | TAG_FOUR_B;\n             dst[1] = (code >> 12u & 0x3F_u32) as u8 | TAG_CONT;\n             dst[2] = (code >>  6u & 0x3F_u32) as u8 | TAG_CONT;\n             dst[3] = (code & 0x3F_u32) as u8 | TAG_CONT;\n-            4\n+            Some(4)\n+        } else {\n+            None\n         }\n     }\n \n-    fn encode_utf16(&self, dst: &mut [u16]) -> uint {\n+    #[inline]\n+    fn encode_utf16(&self, dst: &mut [u16]) -> Option<uint> {\n+        // Marked #[inline] to allow llvm optimizing it away\n         let mut ch = *self as u32;\n-        if (ch & 0xFFFF_u32) == ch {\n+        if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n             // The BMP falls through (assuming non-surrogate, as it should)\n-            assert!(ch <= 0xD7FF_u32 || ch >= 0xE000_u32);\n             dst[0] = ch as u16;\n-            1\n-        } else {\n+            Some(1)\n+        } else if dst.len() >= 2 {\n             // Supplementary planes break into surrogates.\n-            assert!(ch >= 0x1_0000_u32 && ch <= 0x10_FFFF_u32);\n             ch -= 0x1_0000_u32;\n             dst[0] = 0xD800_u16 | ((ch >> 10) as u16);\n             dst[1] = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            2\n+            Some(2)\n+        } else {\n+            None\n         }\n     }\n }"}, {"sha": "cc152112917dac380eface5f1f7187da975575b3", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -364,7 +364,7 @@ impl<'a> Formatter<'a> {\n         let write_prefix = |f: &mut Formatter| {\n             for c in sign.move_iter() {\n                 let mut b = [0, ..4];\n-                let n = c.encode_utf8(b);\n+                let n = c.encode_utf8(b).unwrap_or(0);\n                 try!(f.buf.write(b.slice_to(n)));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n@@ -464,7 +464,7 @@ impl<'a> Formatter<'a> {\n             try!(f(self));\n         }\n         let mut fill = [0u8, ..4];\n-        let len = self.fill.encode_utf8(fill);\n+        let len = self.fill.encode_utf8(fill).unwrap_or(0);\n         for _ in range(0, padding) {\n             try!(self.buf.write(fill.slice_to(len)));\n         }\n@@ -540,7 +540,7 @@ impl<'a, T: str::Str> String for T {\n impl Char for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8, ..4];\n-        let amt = self.encode_utf8(utf8);\n+        let amt = self.encode_utf8(utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(utf8.slice_to(amt)) };\n         secret_string(&s, f)\n     }"}, {"sha": "095605326c7f5a4dd6b8347ef91b9d889d6670d4", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -30,7 +30,7 @@ use iter::range;\n use num::{CheckedMul, Saturating};\n use option::{Option, None, Some};\n use raw::Repr;\n-use slice::ImmutableSlice;\n+use slice::{ImmutableSlice, MutableSlice};\n use slice;\n use uint;\n \n@@ -646,7 +646,7 @@ impl<'a> Iterator<u16> for Utf16CodeUnits<'a> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf /* as mut slice! */);\n+            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })"}, {"sha": "8c3f4706a3cc57109484f0fce7ad6e85e9c70b6a", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -173,7 +173,7 @@ fn test_escape_unicode() {\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8, ..4];\n-        let n = input.encode_utf8(buf /* as mut slice! */);\n+        let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n         assert_eq!(buf.slice_to(n), expect);\n     }\n \n@@ -187,7 +187,7 @@ fn test_encode_utf8() {\n fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16, ..2];\n-        let n = input.encode_utf16(buf /* as mut slice! */);\n+        let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n         assert_eq!(buf.slice_to(n), expect);\n     }\n "}, {"sha": "e93a958acc616e66ee59afd7297d1904eb61074f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13079c1a85c2f3391966cc108a48f2313596d78d/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=13079c1a85c2f3391966cc108a48f2313596d78d", "patch": "@@ -1110,7 +1110,7 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf.as_mut_slice());\n+        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n         self.write(buf.slice_to(n))\n     }\n "}]}