{"sha": "be23b326dcf00c43aaa48670a073650b3fc33612", "node_id": "C_kwDOAAsO6NoAKGJlMjNiMzI2ZGNmMDBjNDNhYWE0ODY3MGEwNzM2NTBiM2ZjMzM2MTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-26T11:05:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-26T11:05:00Z"}, "message": "Rollup merge of #108475 - Sp00ph:fix_shrink_to, r=thomcc\n\nFix `VecDeque::shrink_to` and add tests.\n\nFixes #108453.\n\nAlso adds both a specific test with the code from #108453 and an exhaustive test that checks all possible head positions, lengths and target capacities for deques with capacity 16.\n\ncc `@trinity-1686a` `@scottmcm`", "tree": {"sha": "ae43aee27a23f20415c474bfdb516959b54dea28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae43aee27a23f20415c474bfdb516959b54dea28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be23b326dcf00c43aaa48670a073650b3fc33612", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj+zzcCRBK7hj4Ov3rIwAAxw4IAHOLyVmIqHpJ0SoOw8ChN7Fo\nj2dWBW2i8BGsIxrn2IpWs7bbFr4DgDCzqevNHdO2mrvxCNKaesRe/GUkKNfzceJB\nKkgW5fjk4NK15jSA0Yxzp1mJVWfsz04a4LaD/givgUyp6jQPA0m25grr5EUvj7FC\nNiZfAUZdvc1CYdL1slnC312B278GqhfT+OYaXw1Ov5AJ04vbROqb/bqhJQxR1Vu3\niCLli8eoEz288t968OgiVQumgnvkobTxOncciclOt6XeX9VRR29ucNUHq0MEGdKF\nOPzhSqnBPS8HUEYj+HOCIw71mhU7RLFjIw2Kn6MgerdG/Amld8W+GKJrjnaUDyw=\n=9q1E\n-----END PGP SIGNATURE-----\n", "payload": "tree ae43aee27a23f20415c474bfdb516959b54dea28\nparent c815e03447574916fc4e47c28803deadc97479b7\nparent 4a4f43e4e9b994c729a0506d921fe9734673a20a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677409500 +0100\ncommitter GitHub <noreply@github.com> 1677409500 +0100\n\nRollup merge of #108475 - Sp00ph:fix_shrink_to, r=thomcc\n\nFix `VecDeque::shrink_to` and add tests.\n\nFixes #108453.\n\nAlso adds both a specific test with the code from #108453 and an exhaustive test that checks all possible head positions, lengths and target capacities for deques with capacity 16.\n\ncc `@trinity-1686a` `@scottmcm`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be23b326dcf00c43aaa48670a073650b3fc33612", "html_url": "https://github.com/rust-lang/rust/commit/be23b326dcf00c43aaa48670a073650b3fc33612", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be23b326dcf00c43aaa48670a073650b3fc33612/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c815e03447574916fc4e47c28803deadc97479b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c815e03447574916fc4e47c28803deadc97479b7", "html_url": "https://github.com/rust-lang/rust/commit/c815e03447574916fc4e47c28803deadc97479b7"}, {"sha": "4a4f43e4e9b994c729a0506d921fe9734673a20a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4f43e4e9b994c729a0506d921fe9734673a20a", "html_url": "https://github.com/rust-lang/rust/commit/4a4f43e4e9b994c729a0506d921fe9734673a20a"}], "stats": {"total": 159, "additions": 104, "deletions": 55}, "files": [{"sha": "d4a12509b1cf2127c059958279b24e7907d68d5b", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/be23b326dcf00c43aaa48670a073650b3fc33612/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23b326dcf00c43aaa48670a073650b3fc33612/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=be23b326dcf00c43aaa48670a073650b3fc33612", "patch": "@@ -944,65 +944,72 @@ impl<T, A: Allocator> VecDeque<T, A> {\n             return;\n         }\n \n-        if target_cap < self.capacity() {\n-            // There are three cases of interest:\n-            //   All elements are out of desired bounds\n-            //   Elements are contiguous, and head is out of desired bounds\n-            //   Elements are discontiguous, and tail is out of desired bounds\n+        // There are three cases of interest:\n+        //   All elements are out of desired bounds\n+        //   Elements are contiguous, and tail is out of desired bounds\n+        //   Elements are discontiguous\n+        //\n+        // At all other times, element positions are unaffected.\n+\n+        // `head` and `len` are at most `isize::MAX` and `target_cap < self.capacity()`, so nothing can\n+        // overflow.\n+        let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n+\n+        if self.len == 0 {\n+            self.head = 0;\n+        } else if self.head >= target_cap && tail_outside {\n+            // Head and tail are both out of bounds, so copy all of them to the front.\n             //\n-            // At all other times, element positions are unaffected.\n+            //  H := head\n+            //  L := last element\n+            //                    H           L\n+            //   [. . . . . . . . o o o o o o o . ]\n+            //    H           L\n+            //   [o o o o o o o . ]\n+            unsafe {\n+                // nonoverlapping because `self.head >= target_cap >= self.len`.\n+                self.copy_nonoverlapping(self.head, 0, self.len);\n+            }\n+            self.head = 0;\n+        } else if self.head < target_cap && tail_outside {\n+            // Head is in bounds, tail is out of bounds.\n+            // Copy the overflowing part to the beginning of the\n+            // buffer. This won't overlap because `target_cap >= self.len`.\n             //\n-            // Indicates that elements at the head should be moved.\n-\n-            let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));\n-            // Move elements from out of desired bounds (positions after target_cap)\n-            if self.len == 0 {\n-                self.head = 0;\n-            } else if self.head >= target_cap && tail_outside {\n-                //  H := head\n-                //  L := last element\n-                //                    H           L\n-                //   [. . . . . . . . o o o o o o o . ]\n-                //    H           L\n-                //   [o o o o o o o . ]\n-                unsafe {\n-                    // nonoverlapping because self.head >= target_cap >= self.len\n-                    self.copy_nonoverlapping(self.head, 0, self.len);\n-                }\n-                self.head = 0;\n-            } else if self.head < target_cap && tail_outside {\n-                //  H := head\n-                //  L := last element\n-                //          H           L\n-                //   [. . . o o o o o o o . . . . . . ]\n-                //      L   H\n-                //   [o o . o o o o o ]\n-                let len = self.head + self.len - target_cap;\n-                unsafe {\n-                    self.copy_nonoverlapping(target_cap, 0, len);\n-                }\n-            } else if self.head >= target_cap {\n-                //  H := head\n-                //  L := last element\n-                //            L                   H\n-                //   [o o o o o . . . . . . . . . o o ]\n-                //            L   H\n-                //   [o o o o o . o o ]\n-                let len = self.capacity() - self.head;\n-                let new_head = target_cap - len;\n-                unsafe {\n-                    // can't use copy_nonoverlapping here for the same reason\n-                    // as in `handle_capacity_increase()`\n-                    self.copy(self.head, new_head, len);\n-                }\n-                self.head = new_head;\n+            //  H := head\n+            //  L := last element\n+            //          H           L\n+            //   [. . . o o o o o o o . . . . . . ]\n+            //      L   H\n+            //   [o o . o o o o o ]\n+            let len = self.head + self.len - target_cap;\n+            unsafe {\n+                self.copy_nonoverlapping(target_cap, 0, len);\n             }\n-\n-            self.buf.shrink_to_fit(target_cap);\n-\n-            debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n-            debug_assert!(self.len <= self.capacity());\n+        } else if !self.is_contiguous() {\n+            // The head slice is at least partially out of bounds, tail is in bounds.\n+            // Copy the head backwards so it lines up with the target capacity.\n+            // This won't overlap because `target_cap >= self.len`.\n+            //\n+            //  H := head\n+            //  L := last element\n+            //            L                   H\n+            //   [o o o o o . . . . . . . . . o o ]\n+            //            L   H\n+            //   [o o o o o . o o ]\n+            let head_len = self.capacity() - self.head;\n+            let new_head = target_cap - head_len;\n+            unsafe {\n+                // can't use `copy_nonoverlapping()` here because the new and old\n+                // regions for the head might overlap.\n+                self.copy(self.head, new_head, head_len);\n+            }\n+            self.head = new_head;\n         }\n+        self.buf.shrink_to_fit(target_cap);\n+\n+        debug_assert!(self.head < self.capacity() || self.capacity() == 0);\n+        debug_assert!(self.len <= self.capacity());\n     }\n \n     /// Shortens the deque, keeping the first `len` elements and dropping"}, {"sha": "205a8ff3c19a8cf3242fd97efd23756eb753ae20", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be23b326dcf00c43aaa48670a073650b3fc33612/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be23b326dcf00c43aaa48670a073650b3fc33612/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=be23b326dcf00c43aaa48670a073650b3fc33612", "patch": "@@ -748,6 +748,48 @@ fn test_drain() {\n     }\n }\n \n+#[test]\n+fn issue_108453() {\n+    let mut deque = VecDeque::with_capacity(10);\n+\n+    deque.push_back(1u8);\n+    deque.push_back(2);\n+    deque.push_back(3);\n+\n+    deque.push_front(10);\n+    deque.push_front(9);\n+\n+    deque.shrink_to(9);\n+\n+    assert_eq!(deque.into_iter().collect::<Vec<_>>(), vec![9, 10, 1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_shrink_to() {\n+    // test deques with capacity 16 with all possible head positions, lengths and target capacities.\n+    let cap = 16;\n+\n+    for len in 0..cap {\n+        for head in 0..cap {\n+            let expected = (1..=len).collect::<VecDeque<_>>();\n+\n+            for target_cap in len..cap {\n+                let mut deque = VecDeque::with_capacity(cap);\n+                // currently, `with_capacity` always allocates the exact capacity if it's greater than 8.\n+                assert_eq!(deque.capacity(), cap);\n+\n+                // we can let the head point anywhere in the buffer since the deque is empty.\n+                deque.head = head;\n+                deque.extend(1..=len);\n+\n+                deque.shrink_to(target_cap);\n+\n+                assert_eq!(deque, expected);\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_shrink_to_fit() {\n     // This test checks that every single combination of head and tail position,"}]}