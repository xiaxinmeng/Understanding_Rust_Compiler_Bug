{"sha": "25f084d5e007b9561d155be0b1a2e369c8e4b0ef", "node_id": "C_kwDOAAsO6NoAKDI1ZjA4NGQ1ZTAwN2I5NTYxZDE1NWJlMGIxYTJlMzY5YzhlNGIwZWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-20T07:41:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-20T07:41:15Z"}, "message": "Auto merge of #111596 - cjgillot:dominator-bucket, r=Mark-Simulacrum\n\nProcess current bucket instead of parent's bucket when starting loop for dominators.\n\nThe linked paper by Georgiadis suggests in \u00a72.2.3 to process `bucket[w]` when beginning the loop, instead of `bucket[parent[w]]` when finishing it.\n\nIn the test case, we correctly computed `idom[2] = 0` and `sdom[3] = 1`, but the algorithm returned `idom[3] = 1`, instead of the correct value 0, because of the path 0-7-2-3.\n\nThis provoked LLVM ICE in https://github.com/rust-lang/rust/pull/111061#issuecomment-1546912112. LLVM checks that SSA assignments dominate uses using its own implementation of Lengauer-Tarjan, and saw case where rustc was breaking the dominance property.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "953e4a2976aeb199b4118ae8b2c27a29c157565f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/953e4a2976aeb199b4118ae8b2c27a29c157565f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25f084d5e007b9561d155be0b1a2e369c8e4b0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25f084d5e007b9561d155be0b1a2e369c8e4b0ef", "html_url": "https://github.com/rust-lang/rust/commit/25f084d5e007b9561d155be0b1a2e369c8e4b0ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25f084d5e007b9561d155be0b1a2e369c8e4b0ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e86fd62b6b198584a47798eb271d4b54c4dc96ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86fd62b6b198584a47798eb271d4b54c4dc96ec", "html_url": "https://github.com/rust-lang/rust/commit/e86fd62b6b198584a47798eb271d4b54c4dc96ec"}, {"sha": "84339a6f0577b2bd9526383d2a6e3bda7b59c920", "url": "https://api.github.com/repos/rust-lang/rust/commits/84339a6f0577b2bd9526383d2a6e3bda7b59c920", "html_url": "https://github.com/rust-lang/rust/commit/84339a6f0577b2bd9526383d2a6e3bda7b59c920"}], "stats": {"total": 43, "additions": 35, "deletions": 8}, "files": [{"sha": "594ed1ad2e70748d60aebf25541c4f1769d520d2", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25f084d5e007b9561d155be0b1a2e369c8e4b0ef/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f084d5e007b9561d155be0b1a2e369c8e4b0ef/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=25f084d5e007b9561d155be0b1a2e369c8e4b0ef", "patch": "@@ -109,28 +109,27 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // they have been placed in the bucket.\n         //\n         // We compute a partial set of immediate dominators here.\n-        let z = parent[w];\n-        for &v in bucket[z].iter() {\n+        for &v in bucket[w].iter() {\n             // This uses the result of Lemma 5 from section 2 from the original\n             // 1979 paper, to compute either the immediate or relative dominator\n             // for a given vertex v.\n             //\n             // eval returns a vertex y, for which semi[y] is minimum among\n-            // vertices semi[v] +> y *> v. Note that semi[v] = z as we're in the\n-            // z bucket.\n+            // vertices semi[v] +> y *> v. Note that semi[v] = w as we're in the\n+            // w bucket.\n             //\n             // Given such a vertex y, semi[y] <= semi[v] and idom[y] = idom[v].\n             // If semi[y] = semi[v], though, idom[v] = semi[v].\n             //\n             // Using this, we can either set idom[v] to be:\n-            //  * semi[v] (i.e. z), if semi[y] is z\n+            //  * semi[v] (i.e. w), if semi[y] is w\n             //  * idom[y], otherwise\n             //\n             // We don't directly set to idom[y] though as it's not necessarily\n             // known yet. The second preorder traversal will cleanup by updating\n             // the idom for any that were missed in this pass.\n             let y = eval(&mut parent, lastlinked, &semi, &mut label, v);\n-            idom[v] = if semi[y] < z { y } else { z };\n+            idom[v] = if semi[y] < w { y } else { w };\n         }\n \n         // This loop computes the semi[w] for w.\n@@ -213,10 +212,11 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n         // If we don't yet know the idom directly, then push this vertex into\n         // our semidominator's bucket, where it will get processed at a later\n         // stage to compute its immediate dominator.\n-        if parent[w] != semi[w] {\n+        let z = parent[w];\n+        if z != semi[w] {\n             bucket[semi[w]].push(w);\n         } else {\n-            idom[w] = parent[w];\n+            idom[w] = z;\n         }\n \n         // Optimization: We share the parent array between processed and not"}, {"sha": "5472bb8087ec79b98a99f373176b45016b1f2065", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/25f084d5e007b9561d155be0b1a2e369c8e4b0ef/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f084d5e007b9561d155be0b1a2e369c8e4b0ef/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=25f084d5e007b9561d155be0b1a2e369c8e4b0ef", "patch": "@@ -53,3 +53,30 @@ fn immediate_dominator() {\n     assert_eq!(dominators.immediate_dominator(2), Some(1));\n     assert_eq!(dominators.immediate_dominator(3), Some(2));\n }\n+\n+#[test]\n+fn transitive_dominator() {\n+    let graph = TestGraph::new(\n+        0,\n+        &[\n+            // First tree branch.\n+            (0, 1),\n+            (1, 2),\n+            (2, 3),\n+            (3, 4),\n+            // Second tree branch.\n+            (1, 5),\n+            (5, 6),\n+            // Third tree branch.\n+            (0, 7),\n+            // These links make 0 the dominator for 2 and 3.\n+            (7, 2),\n+            (5, 3),\n+        ],\n+    );\n+\n+    let dom_tree = dominators(&graph);\n+    let immediate_dominators = &dom_tree.immediate_dominators;\n+    assert_eq!(immediate_dominators[2], Some(0));\n+    assert_eq!(immediate_dominators[3], Some(0)); // This used to return Some(1).\n+}"}]}