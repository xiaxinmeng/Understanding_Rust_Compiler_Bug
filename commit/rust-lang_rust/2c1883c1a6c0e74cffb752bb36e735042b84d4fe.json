{"sha": "2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMTg4M2MxYTZjMGU3NGNmZmI3NTJiYjM2ZTczNTA0MmI4NGQ0ZmU=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-03T16:13:01Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2018-12-04T15:10:24Z"}, "message": "Refactor LTO type determination\n\nInstead of only determining whether some form of LTO is necessary,\ndetermine whether thin, fat or no LTO is necessary. I've rewritten\nthe conditions in a way that I think is more obvious, i.e. specified\nLTO type + additional preconditions.", "tree": {"sha": "9bab30b97d9bd8ff3a5d3b77554b92103e2e32b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bab30b97d9bd8ff3a5d3b77554b92103e2e32b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "html_url": "https://github.com/rust-lang/rust/commit/2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c1883c1a6c0e74cffb752bb36e735042b84d4fe/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c657e82df97d3946bfe680d35b199228c4e9104", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c657e82df97d3946bfe680d35b199228c4e9104", "html_url": "https://github.com/rust-lang/rust/commit/9c657e82df97d3946bfe680d35b199228c4e9104"}], "stats": {"total": 76, "additions": 41, "deletions": 35}, "files": [{"sha": "7e443aec41195fdcf159584f8f77fd68b200392b", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2c1883c1a6c0e74cffb752bb36e735042b84d4fe/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1883c1a6c0e74cffb752bb36e735042b84d4fe/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=2c1883c1a6c0e74cffb752bb36e735042b84d4fe", "patch": "@@ -696,6 +696,13 @@ fn execute_work_item<B: ExtraBackendMethods>(\n     }\n }\n \n+// Actual LTO type we end up chosing based on multiple factors.\n+enum ComputedLtoType {\n+    No,\n+    Thin,\n+    Fat,\n+}\n+\n fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: ModuleCodegen<B::Module>,\n@@ -708,54 +715,53 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n         B::optimize(cgcx, &diag_handler, &module, module_config, timeline)?;\n     }\n \n-    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n-\n     // After we've done the initial round of optimizations we need to\n     // decide whether to synchronously codegen this module or ship it\n     // back to the coordinator thread for further LTO processing (which\n     // has to wait for all the initial modules to be optimized).\n-    //\n-    // Here we dispatch based on the `cgcx.lto` and kind of module we're\n-    // codegenning...\n-    let needs_lto = match cgcx.lto {\n-        Lto::No => false,\n \n-        // If the linker does LTO, we don't have to do it. Note that we\n-        // keep doing full LTO, if it is requested, as not to break the\n-        // assumption that the output will be a single module.\n-        Lto::Thin | Lto::ThinLocal if linker_does_lto => false,\n+    // If the linker does LTO, we don't have to do it. Note that we\n+    // keep doing full LTO, if it is requested, as not to break the\n+    // assumption that the output will be a single module.\n+    let linker_does_lto = cgcx.opts.debugging_opts.cross_lang_lto.enabled();\n \n-        // Here we've got a full crate graph LTO requested. We ignore\n-        // this, however, if the crate type is only an rlib as there's\n-        // no full crate graph to process, that'll happen later.\n-        //\n-        // This use case currently comes up primarily for targets that\n-        // require LTO so the request for LTO is always unconditionally\n-        // passed down to the backend, but we don't actually want to do\n-        // anything about it yet until we've got a final product.\n-        Lto::Fat | Lto::Thin => {\n-            cgcx.crate_types.len() != 1 ||\n-                cgcx.crate_types[0] != config::CrateType::Rlib\n-        }\n+    // When we're automatically doing ThinLTO for multi-codegen-unit\n+    // builds we don't actually want to LTO the allocator modules if\n+    // it shows up. This is due to various linker shenanigans that\n+    // we'll encounter later.\n+    let is_allocator = module.kind == ModuleKind::Allocator;\n \n-        // When we're automatically doing ThinLTO for multi-codegen-unit\n-        // builds we don't actually want to LTO the allocator modules if\n-        // it shows up. This is due to various linker shenanigans that\n-        // we'll encounter later.\n-        Lto::ThinLocal => {\n-            module.kind != ModuleKind::Allocator\n-        }\n-    };\n+    // We ignore a request for full crate grath LTO if the cate type\n+    // is only an rlib, as there is no full crate graph to process,\n+    // that'll happen later.\n+    //\n+    // This use case currently comes up primarily for targets that\n+    // require LTO so the request for LTO is always unconditionally\n+    // passed down to the backend, but we don't actually want to do\n+    // anything about it yet until we've got a final product.\n+    let is_rlib = cgcx.crate_types.len() == 1\n+        && cgcx.crate_types[0] == config::CrateType::Rlib;\n \n     // Metadata modules never participate in LTO regardless of the lto\n     // settings.\n-    let needs_lto = needs_lto && module.kind != ModuleKind::Metadata;\n-\n-    if needs_lto {\n-        Ok(WorkItemResult::NeedsLTO(module))\n+    let lto_type = if module.kind == ModuleKind::Metadata {\n+        ComputedLtoType::No\n     } else {\n+        match cgcx.lto {\n+            Lto::ThinLocal if !linker_does_lto && !is_allocator\n+                => ComputedLtoType::Thin,\n+            Lto::Thin if !linker_does_lto && !is_rlib\n+                => ComputedLtoType::Thin,\n+            Lto::Fat if !is_rlib => ComputedLtoType::Fat,\n+            _ => ComputedLtoType::No,\n+        }\n+    };\n+\n+    if let ComputedLtoType::No = lto_type {\n         let module = unsafe { B::codegen(cgcx, &diag_handler, module, module_config, timeline)? };\n         Ok(WorkItemResult::Compiled(module))\n+    } else {\n+        Ok(WorkItemResult::NeedsLTO(module))\n     }\n }\n "}]}