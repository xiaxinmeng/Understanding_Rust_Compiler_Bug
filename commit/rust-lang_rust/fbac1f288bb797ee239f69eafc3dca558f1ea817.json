{"sha": "fbac1f288bb797ee239f69eafc3dca558f1ea817", "node_id": "C_kwDOAAsO6NoAKGZiYWMxZjI4OGJiNzk3ZWUyMzlmNjllYWZjM2RjYTU1OGYxZWE4MTc", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-10-03T15:10:34Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-10-10T13:20:16Z"}, "message": "macros: simplify field ordering in diag derive\n\nFollowing the approach taken in earlier commits to separate formatting\ninitialization from use in the subdiagnostic derive, simplify the\ndiagnostic derive by removing the field-ordering logic that previously\nsolved this problem.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "da0863e592460ffe069a99c00c3bbde752d66e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da0863e592460ffe069a99c00c3bbde752d66e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbac1f288bb797ee239f69eafc3dca558f1ea817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbac1f288bb797ee239f69eafc3dca558f1ea817", "html_url": "https://github.com/rust-lang/rust/commit/fbac1f288bb797ee239f69eafc3dca558f1ea817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbac1f288bb797ee239f69eafc3dca558f1ea817/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e20929e55c5c76bc1466568da746cea4171bc71", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e20929e55c5c76bc1466568da746cea4171bc71", "html_url": "https://github.com/rust-lang/rust/commit/7e20929e55c5c76bc1466568da746cea4171bc71"}], "stats": {"total": 140, "additions": 38, "deletions": 102}, "files": [{"sha": "8cf307df5a565c47957512832a90d6de06111f79", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbac1f288bb797ee239f69eafc3dca558f1ea817/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbac1f288bb797ee239f69eafc3dca558f1ea817/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=fbac1f288bb797ee239f69eafc3dca558f1ea817", "patch": "@@ -52,8 +52,10 @@ impl<'a> DiagnosticDerive<'a> {\n                 }\n             };\n \n+            let formatting_init = &builder.formatting_init;\n             quote! {\n                 #init\n+                #formatting_init\n                 #preamble\n                 #body\n                 #diag\n@@ -101,9 +103,10 @@ impl<'a> LintDiagnosticDerive<'a> {\n             let body = builder.body(&variant);\n \n             let diag = &builder.parent.diag;\n-\n+            let formatting_init = &builder.formatting_init;\n             quote! {\n                 #preamble\n+                #formatting_init\n                 #body\n                 #diag\n             }"}, {"sha": "dcbe89251cb36048705773f90d3cc51e62a3c4d9", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fbac1f288bb797ee239f69eafc3dca558f1ea817/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbac1f288bb797ee239f69eafc3dca558f1ea817/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=fbac1f288bb797ee239f69eafc3dca558f1ea817", "patch": "@@ -5,9 +5,9 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    bind_style_of_field, build_field_mapping, report_error_if_not_applied_to_span,\n-    report_type_error, should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo,\n-    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n+    build_field_mapping, report_error_if_not_applied_to_span, report_type_error,\n+    should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo, FieldInnerTy, FieldMap,\n+    HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n@@ -40,6 +40,9 @@ pub(crate) struct DiagnosticDeriveVariantBuilder<'parent> {\n     /// The parent builder for the entire type.\n     pub parent: &'parent DiagnosticDeriveBuilder,\n \n+    /// Initialization of format strings for code suggestions.\n+    pub formatting_init: TokenStream,\n+\n     /// Span of the struct or the enum variant.\n     pub span: proc_macro::Span,\n \n@@ -88,19 +91,7 @@ impl DiagnosticDeriveBuilder {\n             }\n         }\n \n-        for variant in structure.variants_mut() {\n-            // First, change the binding style of each field based on the code that will be\n-            // generated for the field - e.g. `set_arg` calls needs by-move bindings, whereas\n-            // `set_primary_span` only needs by-ref.\n-            variant.bind_with(|bi| bind_style_of_field(bi.ast()).0);\n-\n-            // Then, perform a stable sort on bindings which generates code for by-ref bindings\n-            // before code generated for by-move bindings. Any code generated for the by-ref\n-            // bindings which creates a reference to the by-move fields will happen before the\n-            // by-move bindings move those fields and make them inaccessible.\n-            variant.bindings_mut().sort_by_cached_key(|bi| bind_style_of_field(bi.ast()));\n-        }\n-\n+        structure.bind_with(|_| synstructure::BindStyle::Move);\n         let variants = structure.each_variant(|variant| {\n             let span = match structure.ast().data {\n                 syn::Data::Struct(..) => span,\n@@ -112,6 +103,7 @@ impl DiagnosticDeriveBuilder {\n                 parent: &self,\n                 span,\n                 field_map: build_field_mapping(variant),\n+                formatting_init: TokenStream::new(),\n                 slug: None,\n                 code: None,\n             };\n@@ -143,16 +135,14 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n     /// Generates calls to `span_label` and similar functions based on the attributes on fields or\n     /// calls to `set_arg` when no attributes are present.\n-    ///\n-    /// Expects use of `Self::each_variant` which will have sorted bindings so that by-ref bindings\n-    /// (which may create references to by-move bindings) have their code generated first -\n-    /// necessary as code for suggestions uses formatting machinery and the value of other fields\n-    /// (any given field can be referenced multiple times, so must be accessed through a borrow);\n-    /// and when passing fields to `add_subdiagnostic` or `set_arg` for Fluent, fields must be\n-    /// accessed by-move.\n     pub fn body<'s>(&mut self, variant: &VariantInfo<'s>) -> TokenStream {\n         let mut body = quote! {};\n-        for binding in variant.bindings() {\n+        // Generate `set_arg` calls first..\n+        for binding in variant.bindings().iter().filter(|bi| should_generate_set_arg(bi.ast())) {\n+            body.extend(self.generate_field_code(binding));\n+        }\n+        // ..and then subdiagnostic additions.\n+        for binding in variant.bindings().iter().filter(|bi| !should_generate_set_arg(bi.ast())) {\n             body.extend(self.generate_field_attrs_code(binding));\n         }\n         body\n@@ -274,24 +264,27 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n         }\n     }\n \n-    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+    fn generate_field_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let diag = &self.parent.diag;\n+\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        if should_generate_set_arg(&field) {\n-            let diag = &self.parent.diag;\n-            let ident = field.ident.as_ref().unwrap();\n-            // strip `r#` prefix, if present\n-            let ident = format_ident!(\"{}\", ident);\n-            return quote! {\n-                #diag.set_arg(\n-                    stringify!(#ident),\n-                    #field_binding\n-                );\n-            };\n+        let ident = field.ident.as_ref().unwrap();\n+        let ident = format_ident!(\"{}\", ident); // strip `r#` prefix, if present\n+\n+        quote! {\n+            #diag.set_arg(\n+                stringify!(#ident),\n+                #field_binding\n+            );\n         }\n+    }\n+\n+    fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n+        let field = binding_info.ast();\n+        let field_binding = &binding_info.binding;\n \n-        let needs_move = bind_style_of_field(&field).is_move();\n         let inner_ty = FieldInnerTy::from_type(&field.ty);\n \n         field\n@@ -304,10 +297,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                 let (binding, needs_destructure) = if needs_clone {\n                     // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n                     (quote! { #field_binding.clone() }, false)\n-                } else if needs_move {\n-                    (quote! { #field_binding }, true)\n                 } else {\n-                    (quote! { *#field_binding }, true)\n+                    (quote! { #field_binding }, true)\n                 };\n \n                 let generated_code = self\n@@ -440,8 +431,8 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n                     .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n                 let style = suggestion_kind.to_suggestion_style();\n \n+                self.formatting_init.extend(code_init);\n                 Ok(quote! {\n-                    #code_init\n                     #diag.span_suggestion_with_style(\n                         #span_field,\n                         rustc_errors::fluent::#slug,\n@@ -490,7 +481,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n                 let binding = &info.binding.binding;\n-                Ok((quote!(*#binding), None))\n+                Ok((quote!(#binding), None))\n             }\n             // If `ty` is `(Span, Applicability)` then return tokens accessing those.\n             Type::Tuple(tup) => {"}, {"sha": "4fd4adc5112679ab7044a252ca2cc0d144a544a6", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fbac1f288bb797ee239f69eafc3dca558f1ea817/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbac1f288bb797ee239f69eafc3dca558f1ea817/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=fbac1f288bb797ee239f69eafc3dca558f1ea817", "patch": "@@ -5,13 +5,12 @@ use proc_macro::Span;\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n use std::cell::RefCell;\n-use std::cmp::Ordering;\n use std::collections::{BTreeSet, HashMap};\n use std::fmt;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Field, Meta, Type, TypeTuple};\n use syn::{MetaList, MetaNameValue, NestedMeta, Path};\n-use synstructure::{BindStyle, BindingInfo, VariantInfo};\n+use synstructure::{BindingInfo, VariantInfo};\n \n use super::error::invalid_nested_attr;\n \n@@ -650,65 +649,8 @@ impl quote::IdentFragment for SubdiagnosticKind {\n     }\n }\n \n-/// Wrapper around `synstructure::BindStyle` which implements `Ord`.\n-#[derive(PartialEq, Eq)]\n-pub(super) struct OrderedBindStyle(pub(super) BindStyle);\n-\n-impl OrderedBindStyle {\n-    /// Is `BindStyle::Move` or `BindStyle::MoveMut`?\n-    pub(super) fn is_move(&self) -> bool {\n-        matches!(self.0, BindStyle::Move | BindStyle::MoveMut)\n-    }\n-}\n-\n-impl Ord for OrderedBindStyle {\n-    fn cmp(&self, other: &Self) -> Ordering {\n-        match (self.is_move(), other.is_move()) {\n-            // If both `self` and `other` are the same, then ordering is equal.\n-            (true, true) | (false, false) => Ordering::Equal,\n-            // If `self` is not a move then it should be considered less than `other` (so that\n-            // references are sorted first).\n-            (false, _) => Ordering::Less,\n-            // If `self` is a move then it must be greater than `other` (again, so that references\n-            // are sorted first).\n-            (true, _) => Ordering::Greater,\n-        }\n-    }\n-}\n-\n-impl PartialOrd for OrderedBindStyle {\n-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n /// call (like `span_label`).\n pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n     field.attrs.is_empty()\n }\n-\n-/// Returns `true` if `field` needs to have code generated in the by-move branch of the\n-/// generated derive rather than the by-ref branch.\n-pub(super) fn bind_style_of_field(field: &Field) -> OrderedBindStyle {\n-    let generates_set_arg = should_generate_set_arg(field);\n-    let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n-    // FIXME(davidtwco): better support for one field needing to be in the by-move and\n-    // by-ref branches.\n-    let is_subdiagnostic = field\n-        .attrs\n-        .iter()\n-        .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n-        .any(|attr| attr == \"subdiagnostic\");\n-\n-    // `set_arg` calls take their argument by-move..\n-    let needs_move = generates_set_arg\n-        // If this is a `MultiSpan` field then it needs to be moved to be used by any\n-        // attribute..\n-        || is_multispan\n-        // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n-        // unlikely to be `Copy`..\n-        || is_subdiagnostic;\n-\n-    OrderedBindStyle(if needs_move { BindStyle::Move } else { BindStyle::Ref })\n-}"}]}