{"sha": "801c3f060fc3bf25a730d89aa0b80da4493f3584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMWMzZjA2MGZjM2JmMjVhNzMwZDg5YWEwYjgwZGE0NDkzZjM1ODQ=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-11-20T20:48:16Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-02-20T15:15:08Z"}, "message": "Fix erroneous loop diagnostic in nll\n\nThis commit fixes the logic of detecting when a use happen in a later\niteration of where a borrow was defined\n\nFixes #53773", "tree": {"sha": "09db3c92d34781698651bbf968f89c4e4af5bfcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09db3c92d34781698651bbf968f89c4e4af5bfcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/801c3f060fc3bf25a730d89aa0b80da4493f3584", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEmNHc6jmXzkUyxd4xiMlBzaHUZDIFAlxtbv0ACgkQiMlBzaHU\nZDJAUQ/9FUodghc7MJnaD/Q4JrB2fYZEZOWhuAOT0Z9ewB2f0jPvXgc3wZe1RXgh\nUxg+guWYk7Ql8H5YQc8nFvKbHcUS+PLzf9G8jypXAMNHZW1zp1ENRPsM6Y93VHEF\n/sDwyDNNxIz5r1cn0FGPYMQ8SdO++CRdxvVrjtmGbvVbE1rX1OlK2mXwKlGuJ7Ob\nqBWdjREaOy+CXE7X33CIVi2FP3YbujGZn1wqVzxqGIH0DNT6yb3zit/mjHc3YEci\nsWnwcBdEP9T2yADB0Uz4/N3PV8mtU9dtgza6MpOcb7OtH0fwluX1kQN07E1utY+b\nS0CYXb9Yr73TQlmAzjINuTqnAdnAq99scVEG1pjhuse7c21qTYmeNDuJRegPOmtl\nKvGbJcgvm8SlbmHMmvzaKN434lyrdoFY2MWmcKXEmb240pTrEm4XACsXKQtYfNLR\nhnZkBFfk2CuycW+gExHRMrStF7x83hIfNN3oK0gsue9iuYV7qGnEkAGsOeifalYu\nqwnYGso3k1rCh/UKJI0e8UhKb5+sB9xdL338tbxi9w7pjNNNOR9wp60nJPBbkNnH\nleV6wzuBZp5o2O4Y+is2uJy/CpbsVMHNjWC0ylNVksdMqbuKgyDP3umL7NnN0ou0\nei4tR7bArkGFOtaqo8YwVwogw2TEmtJ8vrW5Xv7bOzMryD/5atk=\n=rlGF\n-----END PGP SIGNATURE-----", "payload": "tree 09db3c92d34781698651bbf968f89c4e4af5bfcc\nparent cbc865defd0b897ec9befafd4a1895bce58e3cf4\nauthor Santiago Pastorino <spastorino@gmail.com> 1542746896 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1550675708 -0300\n\nFix erroneous loop diagnostic in nll\n\nThis commit fixes the logic of detecting when a use happen in a later\niteration of where a borrow was defined\n\nFixes #53773\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/801c3f060fc3bf25a730d89aa0b80da4493f3584", "html_url": "https://github.com/rust-lang/rust/commit/801c3f060fc3bf25a730d89aa0b80da4493f3584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/801c3f060fc3bf25a730d89aa0b80da4493f3584/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc865defd0b897ec9befafd4a1895bce58e3cf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc865defd0b897ec9befafd4a1895bce58e3cf4", "html_url": "https://github.com/rust-lang/rust/commit/cbc865defd0b897ec9befafd4a1895bce58e3cf4"}], "stats": {"total": 278, "additions": 205, "deletions": 73}, "files": [{"sha": "86cab6cbfb2d33fa531be8dd9cd3ddaeff5c44cc", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 123, "deletions": 56, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -1,3 +1,5 @@\n+use std::collections::VecDeque;\n+\n use crate::borrow_check::borrow_set::BorrowData;\n use crate::borrow_check::error_reporting::UseSpans;\n use crate::borrow_check::nll::ConstraintDescription;\n@@ -9,6 +11,7 @@ use rustc::mir::{\n     Place, Projection, ProjectionElem, Rvalue, Statement, StatementKind,\n     TerminatorKind\n };\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -220,7 +223,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let spans = self.move_spans(&Place::Local(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n-                if self.is_borrow_location_in_loop(context.loc) {\n+                let borrow_location = context.loc;\n+                if self.is_use_in_later_iteration_of_loop(borrow_location, location) {\n                     let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1)\n                 } else {\n@@ -285,76 +289,139 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Checks if a borrow location is within a loop.\n-    fn is_borrow_location_in_loop(\n+    /// true if `borrow_location` can reach `use_location` by going through a loop and\n+    /// `use_location` is also inside of that loop\n+    fn is_use_in_later_iteration_of_loop(\n         &self,\n         borrow_location: Location,\n+        use_location: Location,\n     ) -> bool {\n-        let mut visited_locations = Vec::new();\n-        let mut pending_locations = vec![ borrow_location ];\n-        debug!(\"is_in_loop: borrow_location={:?}\", borrow_location);\n-\n-        while let Some(location) = pending_locations.pop() {\n-            debug!(\"is_in_loop: location={:?} pending_locations={:?} visited_locations={:?}\",\n-                   location, pending_locations, visited_locations);\n-            if location == borrow_location && visited_locations.contains(&borrow_location) {\n-                // We've managed to return to where we started (and this isn't the start of the\n-                // search).\n-                debug!(\"is_in_loop: found!\");\n-                return true;\n-            }\n+        let back_edge = self.reach_through_backedge(borrow_location, use_location);\n+        back_edge.map_or(false, |back_edge| {\n+            self.can_reach_head_of_loop(use_location, back_edge)\n+        })\n+    }\n \n-            // Skip locations we've been.\n-            if visited_locations.contains(&location) { continue; }\n+    /// Returns the outmost back edge if `from` location can reach `to` location passing through\n+    /// that back edge\n+    fn reach_through_backedge(&self, from: Location, to: Location) -> Option<Location> {\n+        let mut visited_locations = FxHashSet::default();\n+        let mut pending_locations = VecDeque::new();\n+        visited_locations.insert(from);\n+        pending_locations.push_back(from);\n+        debug!(\"reach_through_backedge: from={:?} to={:?}\", from, to,);\n+\n+        let mut outmost_back_edge = None;\n+        while let Some(location) = pending_locations.pop_front() {\n+            debug!(\n+                \"reach_through_backedge: location={:?} outmost_back_edge={:?}\n+                   pending_locations={:?} visited_locations={:?}\",\n+                location, outmost_back_edge, pending_locations, visited_locations\n+            );\n+\n+            if location == to && outmost_back_edge.is_some() {\n+                // We've managed to reach the use location\n+                debug!(\"reach_through_backedge: found!\");\n+                return outmost_back_edge;\n+            }\n \n             let block = &self.mir.basic_blocks()[location.block];\n-            if location.statement_index ==  block.statements.len() {\n-                // Add start location of the next blocks to pending locations.\n-                match block.terminator().kind {\n-                    TerminatorKind::Goto { target } => {\n-                        pending_locations.push(target.start_location());\n-                    },\n-                    TerminatorKind::SwitchInt { ref targets, .. } => {\n-                        pending_locations.extend(\n-                            targets.into_iter().map(|target| target.start_location()));\n-                    },\n-                    TerminatorKind::Drop { target, unwind, .. } |\n-                    TerminatorKind::DropAndReplace { target, unwind, .. } |\n-                    TerminatorKind::Assert { target, cleanup: unwind, .. } |\n-                    TerminatorKind::Yield { resume: target, drop: unwind, .. } |\n-                    TerminatorKind::FalseUnwind { real_target: target, unwind, .. } => {\n-                        pending_locations.push(target.start_location());\n-                        if let Some(unwind) = unwind {\n-                            pending_locations.push(unwind.start_location());\n-                        }\n-                    },\n-                    TerminatorKind::Call { ref destination, cleanup, .. } => {\n-                        if let Some((_, destination)) = destination {\n-                            pending_locations.push(destination.start_location());\n-                        }\n-                        if let Some(cleanup) = cleanup {\n-                            pending_locations.push(cleanup.start_location());\n-                        }\n-                    },\n-                    TerminatorKind::FalseEdges { real_target, ref imaginary_targets, .. } => {\n-                        pending_locations.push(real_target.start_location());\n-                        pending_locations.extend(\n-                            imaginary_targets.into_iter().map(|target| target.start_location()));\n-                    },\n-                    _ => {},\n+\n+            if location.statement_index < block.statements.len() {\n+                let successor = location.successor_within_block();\n+                if visited_locations.insert(successor) {\n+                    pending_locations.push_back(successor);\n                 }\n             } else {\n-                // Add the next statement to pending locations.\n-                pending_locations.push(location.successor_within_block());\n+                pending_locations.extend(\n+                    block\n+                        .terminator()\n+                        .successors()\n+                        .map(|bb| Location {\n+                            statement_index: 0,\n+                            block: *bb,\n+                        })\n+                        .filter(|s| visited_locations.insert(*s))\n+                        .map(|s| {\n+                            if self.is_back_edge(location, s) {\n+                                match outmost_back_edge {\n+                                    None => {\n+                                        outmost_back_edge = Some(location);\n+                                    }\n+\n+                                    Some(back_edge)\n+                                        if location.dominates(back_edge, &self.dominators) =>\n+                                    {\n+                                        outmost_back_edge = Some(location);\n+                                    }\n+\n+                                    Some(_) => {}\n+                                }\n+                            }\n+\n+                            s\n+                        }),\n+                );\n             }\n+        }\n+\n+        None\n+    }\n+\n+    /// true if `from` location can reach `loop_head` location and `loop_head` dominates all the\n+    /// intermediate nodes\n+    fn can_reach_head_of_loop(&self, from: Location, loop_head: Location) -> bool {\n+        self.find_loop_head_dfs(from, loop_head, &mut FxHashSet::default())\n+    }\n \n-            // Keep track of where we have visited.\n-            visited_locations.push(location);\n+    fn find_loop_head_dfs(\n+        &self,\n+        from: Location,\n+        loop_head: Location,\n+        visited_locations: &mut FxHashSet<Location>,\n+    ) -> bool {\n+        visited_locations.insert(from);\n+\n+        if from == loop_head {\n+            return true;\n+        }\n+\n+        if loop_head.dominates(from, &self.dominators) {\n+            let block = &self.mir.basic_blocks()[from.block];\n+\n+            if from.statement_index < block.statements.len() {\n+                let successor = from.successor_within_block();\n+\n+                if !visited_locations.contains(&successor)\n+                    && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n+                {\n+                    return true;\n+                }\n+            } else {\n+                for bb in block.terminator().successors() {\n+                    let successor = Location {\n+                        statement_index: 0,\n+                        block: *bb,\n+                    };\n+\n+                    if !visited_locations.contains(&successor)\n+                        && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n         }\n \n         false\n     }\n \n+    /// True if an edge `source -> target` is a backedge -- in other words, if the target\n+    /// dominates the source.\n+    fn is_back_edge(&self, source: Location, target: Location) -> bool {\n+        target.dominates(source, &self.mir.dominators())\n+    }\n+\n     /// Determine how the borrow was later used.\n     fn later_use_kind(\n         &self,"}, {"sha": "32ca24ba6ec43a983f6410116e03e2a9da746a14", "filename": "src/test/ui/borrowck/borrowck-for-loop-head-linkage.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-for-loop-head-linkage.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -5,7 +5,7 @@ LL |     for &x in &vector {\n    |               -------\n    |               |\n    |               immutable borrow occurs here\n-   |               immutable borrow used here, in later iteration of loop\n+   |               immutable borrow later used here\n LL |         let cap = vector.capacity();\n LL |         vector.extend(repeat(0));      //~ ERROR cannot borrow\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n@@ -17,7 +17,7 @@ LL |     for &x in &vector {\n    |               -------\n    |               |\n    |               immutable borrow occurs here\n-   |               immutable borrow used here, in later iteration of loop\n+   |               immutable borrow later used here\n ...\n LL |         vector[1] = 5;   //~ ERROR cannot borrow\n    |         ^^^^^^ mutable borrow occurs here"}, {"sha": "396fd6ffa0c6b1aee7a88382d0537dc9f3771118", "filename": "src/test/ui/borrowck/borrowck-lend-flow-loop.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-lend-flow-loop.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -8,13 +8,13 @@ LL |         borrow(&*v); //[ast]~ ERROR cannot borrow\n    |                ^^^ immutable borrow occurs here\n ...\n LL |     *x = box 5;\n-   |     -- mutable borrow used here, in later iteration of loop\n+   |     -- mutable borrow later used here\n \n error[E0502]: cannot borrow `*v` as immutable because it is also borrowed as mutable\n   --> $DIR/borrowck-lend-flow-loop.rs:109:16\n    |\n LL |         **x += 1;\n-   |         -------- mutable borrow used here, in later iteration of loop\n+   |         -------- mutable borrow later used here\n LL |         borrow(&*v); //[ast]~ ERROR cannot borrow\n    |                ^^^ immutable borrow occurs here\n ..."}, {"sha": "0f077765336086001e4e0a9697df29e265078346", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.ast.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.ast.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -4,7 +4,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                    ----      ^^^^^^ second mutable borrow occurs here\n    |                    |\n-   |                    first borrow used here, in later iteration of loop\n+   |                    first borrow later used here\n ...\n LL |             _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ------ first mutable borrow occurs here\n@@ -13,7 +13,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:15:30\n    |\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n-   |                    ---- first borrow used here, in later iteration of loop\n+   |                    ---- first borrow later used here\n LL |             //[mir]~^ ERROR [E0499]\n LL |             2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ^^^^^^ second mutable borrow occurs here"}, {"sha": "0f077765336086001e4e0a9697df29e265078346", "filename": "src/test/ui/borrowck/borrowck-mut-borrow-linear-errors.mir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.mir.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -4,7 +4,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                    ----      ^^^^^^ second mutable borrow occurs here\n    |                    |\n-   |                    first borrow used here, in later iteration of loop\n+   |                    first borrow later used here\n ...\n LL |             _ => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ------ first mutable borrow occurs here\n@@ -13,7 +13,7 @@ error[E0499]: cannot borrow `x` as mutable more than once at a time\n   --> $DIR/borrowck-mut-borrow-linear-errors.rs:15:30\n    |\n LL |             1 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n-   |                    ---- first borrow used here, in later iteration of loop\n+   |                    ---- first borrow later used here\n LL |             //[mir]~^ ERROR [E0499]\n LL |             2 => { addr.push(&mut x); } //[ast]~ ERROR [E0499]\n    |                              ^^^^^^ second mutable borrow occurs here"}, {"sha": "9b20fc02319344201895887c8e13a91abce0dc5e", "filename": "src/test/ui/borrowck/mut-borrow-outside-loop.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-outside-loop.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -17,7 +17,7 @@ LL |         let inner_second = &mut inner_void; //~ ERROR cannot borrow\n    |                            ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n LL |         inner_second.use_mut();\n LL |         inner_first.use_mut();\n-   |         ----------- first borrow used here, in later iteration of loop\n+   |         ----------- first borrow later used here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d231f621e59c7c1e05a4d3380b540c7a5f112154", "filename": "src/test/ui/issues/issue-52126-assign-op-invariance.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -5,7 +5,7 @@ LL |         let v: Vec<&str> = line.split_whitespace().collect();\n    |                            ^^^^ borrowed value does not live long enough\n ...\n LL |         acc += cnt2;\n-   |         --- borrow used here, in later iteration of loop\n+   |         --- borrow later used here\n ...\n LL |     }\n    |     - `line` dropped here while still borrowed"}, {"sha": "62e1631dcf36ffde8e2e3c0afb5de6299c44bf8b", "filename": "src/test/ui/nll/issue-53773.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fnll%2Fissue-53773.rs", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fnll%2Fissue-53773.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53773.rs?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -0,0 +1,49 @@\n+#![feature(nll)]\n+\n+struct Archive;\n+struct ArchiveIterator<'a> {\n+    x: &'a Archive,\n+}\n+struct ArchiveChild<'a> {\n+    x: &'a Archive,\n+}\n+\n+struct A {\n+    raw: &'static mut Archive,\n+}\n+struct Iter<'a> {\n+    raw: &'a mut ArchiveIterator<'a>,\n+}\n+struct C<'a> {\n+    raw: &'a mut ArchiveChild<'a>,\n+}\n+\n+impl A {\n+    pub fn iter(&self) -> Iter<'_> {\n+        panic!()\n+    }\n+}\n+impl Drop for A {\n+    fn drop(&mut self) {}\n+}\n+impl<'a> Drop for C<'a> {\n+    fn drop(&mut self) {}\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = C<'a>;\n+    fn next(&mut self) -> Option<C<'a>> {\n+        panic!()\n+    }\n+}\n+\n+fn error(archive: &A) {\n+    let mut members: Vec<&mut ArchiveChild<'_>> = vec![];\n+    for child in archive.iter() {\n+        members.push(child.raw);\n+        //~^ ERROR borrow may still be in use when destructor runs [E0713]\n+    }\n+    members.len();\n+}\n+\n+fn main() {}"}, {"sha": "92a9946068cfe11a32fa6489b169a91758736916", "filename": "src/test/ui/nll/issue-53773.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53773.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -0,0 +1,16 @@\n+error[E0713]: borrow may still be in use when destructor runs\n+  --> $DIR/issue-53773.rs:43:22\n+   |\n+LL |         members.push(child.raw);\n+   |                      ^^^^^^^^^\n+LL |         //~^ ERROR borrow may still be in use when destructor runs [E0713]\n+LL |     }\n+   |     - here, drop of `child` needs exclusive access to `*child.raw`, because the type `C<'_>` implements the `Drop` trait\n+LL |     members.len();\n+   |     ------- borrow later used here\n+   |\n+   = note: consider using a `let` binding to create a longer lived value\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0713`."}, {"sha": "3a6f66ca4dac5439d0dd3a9bedb3a5861e508b5e", "filename": "src/test/ui/rfc-2005-default-binding-mode/borrowck-issue-49631.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2005-default-binding-mode%2Fborrowck-issue-49631.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -7,7 +7,7 @@ LL |         foo.mutate();\n    |         ^^^^^^^^^^^^ mutable borrow occurs here\n LL |         //~^ ERROR cannot borrow `foo` as mutable\n LL |         println!(\"foo={:?}\", *string);\n-   |                              ------- immutable borrow used here, in later iteration of loop\n+   |                              ------- immutable borrow later used here\n \n error: aborting due to previous error\n "}, {"sha": "42df668529749df6d739a23fd8c37827cc5fde92", "filename": "src/test/ui/span/regions-escape-loop-via-variable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-variable.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -2,7 +2,7 @@ error[E0597]: `x` does not live long enough\n   --> $DIR/regions-escape-loop-via-variable.rs:11:13\n    |\n LL |         let x = 1 + *p;\n-   |                     -- borrow used here, in later iteration of loop\n+   |                     -- borrow later used here\n LL |         p = &x;\n    |             ^^ borrowed value does not live long enough\n LL |     }"}, {"sha": "e07fb72778210af86eacf6ba367a5d0124eff8c7", "filename": "src/test/ui/span/regions-escape-loop-via-vec.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -7,7 +7,7 @@ LL |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n    |           ^ use of borrowed `x`\n LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n LL |         _y.push(&mut z);\n-   |         -- borrow used here, in later iteration of loop\n+   |         -- borrow later used here\n \n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/regions-escape-loop-via-vec.rs:6:21\n@@ -18,15 +18,15 @@ LL |     while x < 10 { //~ ERROR cannot use `x` because it was mutably borrowed\n LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borrowed\n    |                     ^ use of borrowed `x`\n LL |         _y.push(&mut z);\n-   |         -- borrow used here, in later iteration of loop\n+   |         -- borrow later used here\n \n error[E0597]: `z` does not live long enough\n   --> $DIR/regions-escape-loop-via-vec.rs:7:17\n    |\n LL |         _y.push(&mut z);\n    |         --      ^^^^^^ borrowed value does not live long enough\n    |         |\n-   |         borrow used here, in later iteration of loop\n+   |         borrow later used here\n ...\n LL |     }\n    |     - `z` dropped here while still borrowed\n@@ -38,7 +38,7 @@ LL |     let mut _y = vec![&mut x];\n    |                       ------ borrow of `x` occurs here\n ...\n LL |         _y.push(&mut z);\n-   |         -- borrow used here, in later iteration of loop\n+   |         -- borrow later used here\n LL |         //~^ ERROR `z` does not live long enough\n LL |         x += 1; //~ ERROR cannot assign\n    |         ^^^^^^ use of borrowed `x`"}, {"sha": "c77be26f0193883029ba698316f27ca55e088bc4", "filename": "src/test/ui/vec/vec-mut-iter-borrow.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/801c3f060fc3bf25a730d89aa0b80da4493f3584/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvec%2Fvec-mut-iter-borrow.nll.stderr?ref=801c3f060fc3bf25a730d89aa0b80da4493f3584", "patch": "@@ -5,7 +5,7 @@ LL |     for x in &mut xs {\n    |              -------\n    |              |\n    |              first mutable borrow occurs here\n-   |              first borrow used here, in later iteration of loop\n+   |              first borrow later used here\n LL |         xs.push(1) //~ ERROR cannot borrow `xs`\n    |         ^^ second mutable borrow occurs here\n "}]}