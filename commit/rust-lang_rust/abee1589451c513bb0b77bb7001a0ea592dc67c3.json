{"sha": "abee1589451c513bb0b77bb7001a0ea592dc67c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZWUxNTg5NDUxYzUxM2JiMGI3N2JiNzAwMWEwZWE1OTJkYzY3YzM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-07-04T04:29:45Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-07-04T04:29:45Z"}, "message": "Add a basic base64 module", "tree": {"sha": "2eb4f0e0d95f86fdff9658c87254e56e16ce2365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eb4f0e0d95f86fdff9658c87254e56e16ce2365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abee1589451c513bb0b77bb7001a0ea592dc67c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abee1589451c513bb0b77bb7001a0ea592dc67c3", "html_url": "https://github.com/rust-lang/rust/commit/abee1589451c513bb0b77bb7001a0ea592dc67c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abee1589451c513bb0b77bb7001a0ea592dc67c3/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f06a8c8d5e9bdb8ac466134bee2e69978cd3a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f06a8c8d5e9bdb8ac466134bee2e69978cd3a2e", "html_url": "https://github.com/rust-lang/rust/commit/3f06a8c8d5e9bdb8ac466134bee2e69978cd3a2e"}], "stats": {"total": 158, "additions": 158, "deletions": 0}, "files": [{"sha": "3ca34c4b756975f69682ddfec422920f450698d2", "filename": "src/libstd/base64.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/abee1589451c513bb0b77bb7001a0ea592dc67c3/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abee1589451c513bb0b77bb7001a0ea592dc67c3/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=abee1589451c513bb0b77bb7001a0ea592dc67c3", "patch": "@@ -0,0 +1,158 @@\n+import io::{reader, reader_util};\n+\n+iface to_base64 {\n+    fn to_base64() -> str;\n+}\n+\n+impl of to_base64 for ~[u8] {\n+    fn to_base64() -> str {\n+        let chars = str::chars(\n+            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n+        );\n+\n+        let len = self.len();\n+        let mut s = \"\";\n+        str::reserve(s, ((len + 3u) / 4u) * 3u);\n+\n+        let mut i = 0u;\n+\n+        while i < len - (len % 3u) {\n+            let n = (self[i] as uint) << 16u |\n+                    (self[i + 1u] as uint) << 8u |\n+                    (self[i + 2u] as uint);\n+\n+            // This 24-bit number gets separated into four 6-bit numbers.\n+            str::push_char(s, chars[(n >> 18u) & 63u]);\n+            str::push_char(s, chars[(n >> 12u) & 63u]);\n+            str::push_char(s, chars[(n >> 6u) & 63u]);\n+            str::push_char(s, chars[n & 63u]);\n+\n+            i += 3u;\n+        }\n+\n+        alt check len % 3u {\n+          0u { }\n+          1u {\n+            let n = (self[i] as uint) << 16u;\n+            str::push_char(s, chars[(n >> 18u) & 63u]);\n+            str::push_char(s, chars[(n >> 12u) & 63u]);\n+            str::push_char(s, '=');\n+            str::push_char(s, '=');\n+          }\n+          2u {\n+            let n = (self[i] as uint) << 16u | (self[i + 1u] as uint) << 8u;\n+            str::push_char(s, chars[(n >> 18u) & 63u]);\n+            str::push_char(s, chars[(n >> 12u) & 63u]);\n+            str::push_char(s, chars[(n >> 6u) & 63u]);\n+            str::push_char(s, '=');\n+          }\n+        }\n+\n+        s\n+    }\n+}\n+\n+impl of to_base64 for str {\n+    fn to_base64() -> str {\n+        str::bytes(self).to_base64()\n+    }\n+}\n+\n+iface from_base64 {\n+    fn from_base64() -> ~[u8];\n+}\n+\n+impl of from_base64 for ~[u8] {\n+    fn from_base64() -> ~[u8] {\n+        if self.len() % 4u != 0u { fail \"invalid base64 length\"; }\n+\n+        let len = self.len();\n+        let mut padding = 0u;\n+\n+        if len != 0u {\n+            if self[len - 1u] == '=' as u8 { padding += 1u; }\n+            if self[len - 2u] == '=' as u8 { padding += 1u; }\n+        }\n+\n+        let mut r = ~[];\n+        vec::reserve(r, (len / 4u) * 3u - padding);\n+\n+        let mut i = 0u;\n+        while i < len {\n+            let mut n = 0u;\n+\n+            for iter::repeat(4u) {\n+                let ch = self[i] as char;\n+                n <<= 6u;\n+\n+                if ch >= 'A' && ch <= 'Z' {\n+                    n |= (ch as uint) - 0x41u;\n+                } else if ch >= 'a' && ch <= 'z' {\n+                    n |= (ch as uint) - 0x47u;\n+                } else if ch >= '0' && ch <= '9' {\n+                    n |= (ch as uint) + 0x04u;\n+                } else if ch == '+' {\n+                    n |= 0x3Eu;\n+                } else if ch == '/' {\n+                    n |= 0x3Fu;\n+                } else if ch == '=' {\n+                    alt len - i {\n+                      1u {\n+                        vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n+                        vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n+                        ret copy r;\n+                      }\n+                      2u {\n+                        vec::push(r, ((n >> 10u) & 0xFFu) as u8);\n+                        ret copy r;\n+                      }\n+                      _ {\n+                        fail \"invalid base64 padding\";\n+                      }\n+                    }\n+                } else {\n+                    fail \"invalid base64 character\";\n+                }\n+\n+                i += 1u;\n+            };\n+\n+            vec::push(r, ((n >> 16u) & 0xFFu) as u8);\n+            vec::push(r, ((n >> 8u ) & 0xFFu) as u8);\n+            vec::push(r, ((n       ) & 0xFFu) as u8);\n+        }\n+\n+        r\n+    }\n+}\n+\n+impl of from_base64 for str {\n+    fn from_base64() -> ~[u8] {\n+        str::bytes(self).from_base64()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_to_base64() {\n+        assert \"\".to_base64()       == \"\";\n+        assert \"f\".to_base64()      == \"Zg==\";\n+        assert \"fo\".to_base64()     == \"Zm8=\";\n+        assert \"foo\".to_base64()    == \"Zm9v\";\n+        assert \"foob\".to_base64()   == \"Zm9vYg==\";\n+        assert \"fooba\".to_base64()  == \"Zm9vYmE=\";\n+        assert \"foobar\".to_base64() == \"Zm9vYmFy\";\n+    }\n+\n+    #[test]\n+    fn test_from_base64() {\n+        assert \"\".from_base64() == str::bytes(\"\");\n+        assert \"Zg==\".from_base64() == str::bytes(\"f\");\n+        assert \"Zm8=\".from_base64() == str::bytes(\"fo\");\n+        assert \"Zm9v\".from_base64() == str::bytes(\"foo\");\n+        assert \"Zm9vYg==\".from_base64() == str::bytes(\"foob\");\n+        assert \"Zm9vYmE=\".from_base64() == str::bytes(\"fooba\");\n+        assert \"Zm9vYmFy\".from_base64() == str::bytes(\"foobar\");\n+    }\n+}"}]}