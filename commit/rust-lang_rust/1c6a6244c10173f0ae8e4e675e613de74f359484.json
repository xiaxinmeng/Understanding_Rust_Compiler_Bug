{"sha": "1c6a6244c10173f0ae8e4e675e613de74f359484", "node_id": "C_kwDOAAsO6NoAKDFjNmE2MjQ0YzEwMTczZjBhZThlNGU2NzVlNjEzZGU3NGYzNTk0ODQ", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-09-27T01:48:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-04T13:32:10Z"}, "message": "Please help, where is this lifetime bound coming from", "tree": {"sha": "b085d1f20aa5a82edad6d8f11175a47bff2fcfb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b085d1f20aa5a82edad6d8f11175a47bff2fcfb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c6a6244c10173f0ae8e4e675e613de74f359484", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c6a6244c10173f0ae8e4e675e613de74f359484", "html_url": "https://github.com/rust-lang/rust/commit/1c6a6244c10173f0ae8e4e675e613de74f359484", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c6a6244c10173f0ae8e4e675e613de74f359484/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f8106cec59550322e46e33a79ada673c2f13f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f8106cec59550322e46e33a79ada673c2f13f6", "html_url": "https://github.com/rust-lang/rust/commit/a8f8106cec59550322e46e33a79ada673c2f13f6"}], "stats": {"total": 130, "additions": 90, "deletions": 40}, "files": [{"sha": "3c5a6786bd1c87a8505a15a0f6e95f0038f662f4", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=1c6a6244c10173f0ae8e4e675e613de74f359484", "patch": "@@ -32,9 +32,9 @@ pub enum SchedulingAction {\n \n /// Timeout callbacks can be created by synchronization primitives to tell the\n /// scheduler that they should be called once some period of time passes.\n-type TimeoutCallback<'mir, 'tcx> = Box<\n-    dyn FnOnce(&mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx,\n->;\n+pub trait TimeoutCallback<'mir, 'tcx>: VisitMachineValues + 'tcx {\n+    fn call(&self, ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx>;\n+}\n \n /// A thread identifier.\n #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n@@ -252,7 +252,7 @@ struct TimeoutCallbackInfo<'mir, 'tcx> {\n     /// The callback should be called no earlier than this time.\n     call_time: Time,\n     /// The called function.\n-    callback: TimeoutCallback<'mir, 'tcx>,\n+    callback: Box<dyn TimeoutCallback<'mir, 'tcx>>,\n }\n \n impl<'mir, 'tcx> std::fmt::Debug for TimeoutCallbackInfo<'mir, 'tcx> {\n@@ -542,7 +542,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         &mut self,\n         thread: ThreadId,\n         call_time: Time,\n-        callback: TimeoutCallback<'mir, 'tcx>,\n+        callback: Box<dyn TimeoutCallback<'mir, 'tcx>>,\n     ) {\n         self.timeout_callbacks\n             .try_insert(thread, TimeoutCallbackInfo { call_time, callback })\n@@ -558,7 +558,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn get_ready_callback(\n         &mut self,\n         clock: &Clock,\n-    ) -> Option<(ThreadId, TimeoutCallback<'mir, 'tcx>)> {\n+    ) -> Option<(ThreadId, Box<dyn TimeoutCallback<'mir, 'tcx>>)> {\n         // We iterate over all threads in the order of their indices because\n         // this allows us to have a deterministic scheduler.\n         for thread in self.threads.indices() {\n@@ -931,7 +931,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         &mut self,\n         thread: ThreadId,\n         call_time: Time,\n-        callback: TimeoutCallback<'mir, 'tcx>,\n+        callback: Box<dyn TimeoutCallback<'mir, 'tcx>>,\n     ) {\n         let this = self.eval_context_mut();\n         if !this.machine.communicate() && matches!(call_time, Time::RealTime(..)) {\n@@ -970,7 +970,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // 2. Make the scheduler the only place that can change the active\n         //    thread.\n         let old_thread = this.set_active_thread(thread);\n-        callback(this)?;\n+        callback.call(this)?;\n         this.set_active_thread(old_thread);\n         Ok(())\n     }"}, {"sha": "43792024e2c9d1aff34f358551dc49791f4fdb64", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=1c6a6244c10173f0ae8e4e675e613de74f359484", "patch": "@@ -1,5 +1,6 @@\n use std::time::{Duration, SystemTime};\n \n+use crate::concurrency::thread::TimeoutCallback;\n use crate::*;\n \n /// Returns the time elapsed between the provided time and the unix epoch as a `Duration`.\n@@ -218,10 +219,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             Time::Monotonic(timeout_time),\n-            Box::new(move |ecx| {\n-                ecx.unblock_thread(active_thread);\n-                Ok(())\n-            }),\n+            Box::new(Callback { active_thread }),\n         );\n \n         Ok(0)\n@@ -244,12 +242,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             Time::Monotonic(timeout_time),\n-            Box::new(move |ecx| {\n-                ecx.unblock_thread(active_thread);\n-                Ok(())\n-            }),\n+            Box::new(Callback { active_thread }),\n         );\n \n         Ok(())\n     }\n }\n+\n+struct Callback {\n+    active_thread: ThreadId,\n+}\n+\n+impl VisitMachineValues for Callback {\n+    fn visit_machine_values(&self, _visit: &mut ProvenanceVisitor) {}\n+}\n+\n+impl<'mir, 'tcx: 'mir> TimeoutCallback<'mir, 'tcx> for Callback {\n+    fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+        ecx.unblock_thread(self.active_thread);\n+        Ok(())\n+    }\n+}"}, {"sha": "784fa12d18a2b5db9cd61703daa589f03ccf9288", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=1c6a6244c10173f0ae8e4e675e613de74f359484", "patch": "@@ -1,4 +1,4 @@\n-use crate::concurrency::thread::Time;\n+use crate::concurrency::thread::{Time, TimeoutCallback};\n use crate::*;\n use rustc_target::abi::{Align, Size};\n use std::time::SystemTime;\n@@ -193,14 +193,7 @@ pub fn futex<'tcx>(\n                     this.register_timeout_callback(\n                         thread,\n                         timeout_time,\n-                        Box::new(move |this| {\n-                            this.unblock_thread(thread);\n-                            this.futex_remove_waiter(addr_usize, thread);\n-                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n-                            this.set_last_error(etimedout)?;\n-                            this.write_scalar(Scalar::from_machine_isize(-1, this), &dest)?;\n-                            Ok(())\n-                        }),\n+                        Box::new(Callback { thread, addr_usize, dest }),\n                     );\n                 }\n             } else {\n@@ -259,3 +252,30 @@ pub fn futex<'tcx>(\n \n     Ok(())\n }\n+\n+struct Callback<'tcx> {\n+    thread: ThreadId,\n+    addr_usize: u64,\n+    dest: PlaceTy<'tcx, Provenance>,\n+}\n+\n+impl<'tcx> VisitMachineValues for Callback<'tcx> {\n+    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+        let Callback { thread: _, addr_usize: _, dest } = self;\n+        if let Place::Ptr(place) = **dest {\n+            visit.visit(place);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> TimeoutCallback<'mir, 'tcx> for Callback<'tcx> {\n+    fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+        this.unblock_thread(self.thread);\n+        this.futex_remove_waiter(self.addr_usize, self.thread);\n+        let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+        this.set_last_error(etimedout)?;\n+        this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "cdb3cdc4b9a592633aa791c7cea1c294f58eaa1c", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c6a6244c10173f0ae8e4e675e613de74f359484/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=1c6a6244c10173f0ae8e4e675e613de74f359484", "patch": "@@ -3,7 +3,7 @@ use std::time::SystemTime;\n use rustc_hir::LangItem;\n use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n \n-use crate::concurrency::thread::Time;\n+use crate::concurrency::thread::{Time, TimeoutCallback};\n use crate::*;\n \n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n@@ -856,20 +856,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.register_timeout_callback(\n             active_thread,\n             timeout_time,\n-            Box::new(move |ecx| {\n-                // We are not waiting for the condvar any more, wait for the\n-                // mutex instead.\n-                reacquire_cond_mutex(ecx, active_thread, mutex_id)?;\n-\n-                // Remove the thread from the conditional variable.\n-                ecx.condvar_remove_waiter(id, active_thread);\n-\n-                // Set the return value: we timed out.\n-                let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n-                ecx.write_scalar(etimedout, &dest)?;\n-\n-                Ok(())\n-            }),\n+            Box::new(Callback { active_thread, mutex_id, id, dest }),\n         );\n \n         Ok(())\n@@ -898,6 +885,39 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n }\n \n+struct Callback<'tcx> {\n+    active_thread: ThreadId,\n+    mutex_id: MutexId,\n+    id: CondvarId,\n+    dest: PlaceTy<'tcx, Provenance>,\n+}\n+\n+impl<'tcx> VisitMachineValues for Callback<'tcx> {\n+    fn visit_machine_values(&self, visit: &mut ProvenanceVisitor) {\n+        let Callback { active_thread: _, mutex_id: _, id: _, dest } = self;\n+        if let Place::Ptr(place) = **dest {\n+            visit.visit(place);\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> TimeoutCallback<'mir, 'tcx> for Callback<'tcx> {\n+    fn call(&self, ecx: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+        // We are not waiting for the condvar any more, wait for the\n+        // mutex instead.\n+        reacquire_cond_mutex(ecx, self.active_thread, self.mutex_id)?;\n+\n+        // Remove the thread from the conditional variable.\n+        ecx.condvar_remove_waiter(self.id, self.active_thread);\n+\n+        // Set the return value: we timed out.\n+        let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n+        ecx.write_scalar(etimedout, &self.dest)?;\n+\n+        Ok(())\n+    }\n+}\n+\n fn layout_of_maybe_uninit<'tcx>(tcx: TyCtxtAt<'tcx>, param: Ty<'tcx>) -> TyAndLayout<'tcx> {\n     let def_id = tcx.require_lang_item(LangItem::MaybeUninit, None);\n     let ty = tcx.bound_type_of(def_id).subst(*tcx, &[param.into()]);"}]}