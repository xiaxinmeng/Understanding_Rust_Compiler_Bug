{"sha": "53a6304c2a431ae97c3b584066804c6acd667541", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYTYzMDRjMmE0MzFhZTk3YzNiNTg0MDY2ODA0YzZhY2Q2Njc1NDE=", "commit": {"author": {"name": "Jakub Adam Wieczorek", "email": "jakub.adam.wieczorek@gmail.com", "date": "2019-08-09T09:43:26Z"}, "committer": {"name": "Jakub Adam Wieczorek", "email": "jakub.adam.wieczorek@gmail.com", "date": "2019-08-10T21:09:53Z"}, "message": "Suggest using a qualified path in patterns with inconsistent bindings\n\nA program like the following one:\n\n```rust\nenum E { A, B, C }\nfn f(x: E) -> bool {\n    match x {\n        A | B => false,\n        C => true\n    }\n}\n```\n\nis rejected by the compiler due to `E` variant paths not being in scope.\nIn this case `A`, `B` are resolved as pattern bindings and consequently\nthe pattern is considered invalid as the inner or-patterns do not bind\nto the same set of identifiers.\n\nThis is expected but the compiler errors that follow could be surprising\nor confusing to some users. This commit adds a help note explaining that\nif the user desired to match against variants or consts, they should use\na qualified path. The note is restricted to cases where the identifier\nstarts with an upper-case sequence so as to reduce the false negatives.\n\nSince this happens during resolution, there's no clean way to check what\nthe patterns match against. The syntactic criterium, however, is in line\nwith the convention that's assumed by the `non-camel-case-types` lint.", "tree": {"sha": "311475e575eea261586d23be44d709bd1158c5e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311475e575eea261586d23be44d709bd1158c5e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53a6304c2a431ae97c3b584066804c6acd667541", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53a6304c2a431ae97c3b584066804c6acd667541", "html_url": "https://github.com/rust-lang/rust/commit/53a6304c2a431ae97c3b584066804c6acd667541", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53a6304c2a431ae97c3b584066804c6acd667541/comments", "author": {"login": "jakubadamw", "id": 14150873, "node_id": "MDQ6VXNlcjE0MTUwODcz", "avatar_url": "https://avatars.githubusercontent.com/u/14150873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubadamw", "html_url": "https://github.com/jakubadamw", "followers_url": "https://api.github.com/users/jakubadamw/followers", "following_url": "https://api.github.com/users/jakubadamw/following{/other_user}", "gists_url": "https://api.github.com/users/jakubadamw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubadamw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubadamw/subscriptions", "organizations_url": "https://api.github.com/users/jakubadamw/orgs", "repos_url": "https://api.github.com/users/jakubadamw/repos", "events_url": "https://api.github.com/users/jakubadamw/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubadamw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubadamw", "id": 14150873, "node_id": "MDQ6VXNlcjE0MTUwODcz", "avatar_url": "https://avatars.githubusercontent.com/u/14150873?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubadamw", "html_url": "https://github.com/jakubadamw", "followers_url": "https://api.github.com/users/jakubadamw/followers", "following_url": "https://api.github.com/users/jakubadamw/following{/other_user}", "gists_url": "https://api.github.com/users/jakubadamw/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubadamw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubadamw/subscriptions", "organizations_url": "https://api.github.com/users/jakubadamw/orgs", "repos_url": "https://api.github.com/users/jakubadamw/repos", "events_url": "https://api.github.com/users/jakubadamw/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubadamw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9703ef666123c465f784e294b5b24d6d35a37745", "url": "https://api.github.com/repos/rust-lang/rust/commits/9703ef666123c465f784e294b5b24d6d35a37745", "html_url": "https://github.com/rust-lang/rust/commit/9703ef666123c465f784e294b5b24d6d35a37745"}], "stats": {"total": 208, "additions": 159, "deletions": 49}, "files": [{"sha": "b3f6252e4aabdd92fe5e9f7f7b1c579e53c32a39", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/53a6304c2a431ae97c3b584066804c6acd667541/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a6304c2a431ae97c3b584066804c6acd667541/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=53a6304c2a431ae97c3b584066804c6acd667541", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{path_names_to_string, KNOWN_TOOLS};\n-use crate::{CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{BindingError, CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n@@ -207,21 +207,30 @@ impl<'a> Resolver<'a> {\n                 err\n             }\n             ResolutionError::VariableNotBoundInPattern(binding_error) => {\n-                let target_sp = binding_error.target.iter().cloned().collect::<Vec<_>>();\n+                let BindingError { name, target, origin, could_be_variant } = binding_error;\n+\n+                let target_sp = target.iter().cloned().collect::<Vec<_>>();\n+                let origin_sp = origin.iter().cloned().collect::<Vec<_>>();\n+\n                 let msp = MultiSpan::from_spans(target_sp.clone());\n-                let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n+                let msg = format!(\"variable `{}` is not bound in all patterns\", name);\n                 let mut err = self.session.struct_span_err_with_code(\n                     msp,\n                     &msg,\n                     DiagnosticId::Error(\"E0408\".into()),\n                 );\n                 for sp in target_sp {\n-                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", name));\n                 }\n-                let origin_sp = binding_error.origin.iter().cloned();\n                 for sp in origin_sp {\n                     err.span_label(sp, \"variable not in all patterns\");\n                 }\n+                if *could_be_variant {\n+                    let help_msg = format!(\n+                        \"if you meant to match on a variant or a const, consider \\\n+                         making the path in the pattern qualified: `?::{}`\", name);\n+                    err.span_help(span, &help_msg);\n+                }\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name,"}, {"sha": "13bae25a69af0133ea06ecf6fa696c523a205aa8", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/53a6304c2a431ae97c3b584066804c6acd667541/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a6304c2a431ae97c3b584066804c6acd667541/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=53a6304c2a431ae97c3b584066804c6acd667541", "patch": "@@ -1136,64 +1136,56 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     // Checks that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n-        if pats.is_empty() {\n+        if pats.len() <= 1 {\n             return;\n         }\n \n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n-        for (i, p) in pats.iter().enumerate() {\n+        for p in pats.iter() {\n             let map_i = self.binding_mode_map(&p);\n-\n-            for (j, q) in pats.iter().enumerate() {\n-                if i == j {\n+            for q in pats.iter() {\n+                if p.id == q.id {\n                     continue;\n                 }\n \n                 let map_j = self.binding_mode_map(&q);\n-                for (&key, &binding_i) in &map_i {\n-                    if map_j.is_empty() {                   // Account for missing bindings when\n-                        let binding_error = missing_vars    // `map_j` has none.\n-                            .entry(key.name)\n-                            .or_insert(BindingError {\n-                                name: key.name,\n-                                origin: BTreeSet::new(),\n-                                target: BTreeSet::new(),\n-                            });\n-                        binding_error.origin.insert(binding_i.span);\n-                        binding_error.target.insert(q.span);\n-                    }\n-                    for (&key_j, &binding_j) in &map_j {\n-                        match map_i.get(&key_j) {\n-                            None => {  // missing binding\n-                                let binding_error = missing_vars\n+                for (&key_j, &binding_j) in map_j.iter() {\n+                    match map_i.get(&key_j) {\n+                        None => {  // missing binding\n+                            let binding_error = missing_vars\n+                                .entry(key_j.name)\n+                                .or_insert(BindingError {\n+                                    name: key_j.name,\n+                                    origin: BTreeSet::new(),\n+                                    target: BTreeSet::new(),\n+                                    could_be_variant:\n+                                        key_j.name.as_str().starts_with(char::is_uppercase)\n+                                });\n+                            binding_error.origin.insert(binding_j.span);\n+                            binding_error.target.insert(p.span);\n+                        }\n+                        Some(binding_i) => {  // check consistent binding\n+                            if binding_i.binding_mode != binding_j.binding_mode {\n+                                inconsistent_vars\n                                     .entry(key_j.name)\n-                                    .or_insert(BindingError {\n-                                        name: key_j.name,\n-                                        origin: BTreeSet::new(),\n-                                        target: BTreeSet::new(),\n-                                    });\n-                                binding_error.origin.insert(binding_j.span);\n-                                binding_error.target.insert(p.span);\n-                            }\n-                            Some(binding_i) => {  // check consistent binding\n-                                if binding_i.binding_mode != binding_j.binding_mode {\n-                                    inconsistent_vars\n-                                        .entry(key.name)\n-                                        .or_insert((binding_j.span, binding_i.span));\n-                                }\n+                                    .or_insert((binding_j.span, binding_i.span));\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n+\n+        let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n         missing_vars.sort();\n-        for (_, v) in missing_vars {\n+        for (name, mut v) in missing_vars {\n+            if inconsistent_vars.contains_key(name) {\n+                v.could_be_variant = false;\n+            }\n             self.r.report_error(\n-                *v.origin.iter().next().unwrap(), ResolutionError::VariableNotBoundInPattern(v)\n-            );\n+                *v.origin.iter().next().unwrap(),\n+                ResolutionError::VariableNotBoundInPattern(v));\n         }\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();"}, {"sha": "1cacc6b7d606dbe92cdcabd20d80928b0be9bb52", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53a6304c2a431ae97c3b584066804c6acd667541/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a6304c2a431ae97c3b584066804c6acd667541/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=53a6304c2a431ae97c3b584066804c6acd667541", "patch": "@@ -135,6 +135,7 @@ struct BindingError {\n     name: Name,\n     origin: BTreeSet<Span>,\n     target: BTreeSet<Span>,\n+    could_be_variant: bool\n }\n \n impl PartialOrd for BindingError {"}, {"sha": "2fb803c4b2ad429dbefb667dbd6f55688c67146b", "filename": "src/test/ui/resolve/resolve-inconsistent-names.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53a6304c2a431ae97c3b584066804c6acd667541/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53a6304c2a431ae97c3b584066804c6acd667541/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs?ref=53a6304c2a431ae97c3b584066804c6acd667541", "patch": "@@ -1,7 +1,36 @@\n+#![allow(non_camel_case_types)]\n+\n+enum E { A, B, c }\n+\n+mod m {\n+    const CONST1: usize = 10;\n+    const Const2: usize = 20;\n+}\n+\n fn main() {\n     let y = 1;\n     match y {\n        a | b => {} //~  ERROR variable `a` is not bound in all patterns\n-                   //~^ ERROR variable `b` is not bound in all patterns\n+                   //~| ERROR variable `b` is not bound in all patterns\n+    }\n+\n+    let x = (E::A, E::B);\n+    match x {\n+        (A, B) | (ref B, c) | (c, A) => ()\n+        //~^ ERROR variable `A` is not bound in all patterns\n+        //~| ERROR variable `B` is not bound in all patterns\n+        //~| ERROR variable `B` is bound in inconsistent ways\n+        //~| ERROR mismatched types\n+        //~| ERROR variable `c` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::A`\n+    }\n+\n+    let z = (10, 20);\n+    match z {\n+        (CONST1, _) | (_, Const2) => ()\n+        //~^ ERROR variable `CONST1` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::CONST1`\n+        //~| ERROR variable `Const2` is not bound in all patterns\n+        //~| HELP consider making the path in the pattern qualified: `?::Const2`\n     }\n }"}, {"sha": "5a6ae31411ee2e6a3996eaae6e7163a15e6a9b48", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 83, "deletions": 4, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/53a6304c2a431ae97c3b584066804c6acd667541/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53a6304c2a431ae97c3b584066804c6acd667541/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=53a6304c2a431ae97c3b584066804c6acd667541", "patch": "@@ -1,19 +1,98 @@\n error[E0408]: variable `a` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:4:12\n+  --> $DIR/resolve-inconsistent-names.rs:13:12\n    |\n LL |        a | b => {}\n    |        -   ^ pattern doesn't bind `a`\n    |        |\n    |        variable not in all patterns\n \n error[E0408]: variable `b` is not bound in all patterns\n-  --> $DIR/resolve-inconsistent-names.rs:4:8\n+  --> $DIR/resolve-inconsistent-names.rs:13:8\n    |\n LL |        a | b => {}\n    |        ^   - variable not in all patterns\n    |        |\n    |        pattern doesn't bind `b`\n \n-error: aborting due to 2 previous errors\n+error[E0408]: variable `A` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:18\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |          -       ^^^^^^^^^^       - variable not in all patterns\n+   |          |       |\n+   |          |       pattern doesn't bind `A`\n+   |          variable not in all patterns\n+   |\n+help: if you meant to match on a variant or a const, consider making the path in the pattern qualified: `?::A`\n+  --> $DIR/resolve-inconsistent-names.rs:19:10\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |          ^\n+\n+error[E0408]: variable `B` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:31\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |             -         -       ^^^^^^ pattern doesn't bind `B`\n+   |             |         |\n+   |             |         variable not in all patterns\n+   |             variable not in all patterns\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:19:9\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |         ^^^^^^           -     - variable not in all patterns\n+   |         |                |\n+   |         |                variable not in all patterns\n+   |         pattern doesn't bind `c`\n+\n+error[E0409]: variable `B` is bound in inconsistent ways within the same match arm\n+  --> $DIR/resolve-inconsistent-names.rs:19:23\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |             -         ^ bound in different ways\n+   |             |\n+   |             first binding\n+\n+error[E0408]: variable `CONST1` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:30:23\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |          ------       ^^^^^^^^^^^ pattern doesn't bind `CONST1`\n+   |          |\n+   |          variable not in all patterns\n+   |\n+help: if you meant to match on a variant or a const, consider making the path in the pattern qualified: `?::CONST1`\n+  --> $DIR/resolve-inconsistent-names.rs:30:10\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |          ^^^^^^\n+\n+error[E0408]: variable `Const2` is not bound in all patterns\n+  --> $DIR/resolve-inconsistent-names.rs:30:9\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |         ^^^^^^^^^^^       ------ variable not in all patterns\n+   |         |\n+   |         pattern doesn't bind `Const2`\n+   |\n+help: if you meant to match on a variant or a const, consider making the path in the pattern qualified: `?::Const2`\n+  --> $DIR/resolve-inconsistent-names.rs:30:27\n+   |\n+LL |         (CONST1, _) | (_, Const2) => ()\n+   |                           ^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/resolve-inconsistent-names.rs:19:19\n+   |\n+LL |         (A, B) | (ref B, c) | (c, A) => ()\n+   |                   ^^^^^ expected enum `E`, found &E\n+   |\n+   = note: expected type `E`\n+              found type `&E`\n+\n+error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0408`.\n+Some errors have detailed explanations: E0308, E0408, E0409.\n+For more information about an error, try `rustc --explain E0308`."}]}