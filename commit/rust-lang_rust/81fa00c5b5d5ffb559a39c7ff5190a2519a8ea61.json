{"sha": "81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZmEwMGM1YjVkNWZmYjU1OWEzOWM3ZmY1MTkwYTI1MTlhOGVhNjE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-24T14:26:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-24T14:26:33Z"}, "message": "Merge #5733\n\n5733: Fix expand glob import bugs r=matklad a=unexge\n\nfixes https://github.com/rust-analyzer/rust-analyzer/issues/5709\r\n\r\nTODOs:\r\n- [x] Incorrect node replacing\r\n<details>\r\n    <summary>Details</summary>\r\n\r\n```rust\r\nuse crate::{\r\n    body::scope::{ExprScopes, ScopeId},\r\n    body::Body,\r\n    builtin_type::BuiltinType,\r\n    db::DefDatabase,\r\n    expr::{ExprId, PatId},\r\n    generics::GenericParams,\r\n    item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\r\n    nameres::CrateDefMap,\r\n    path::*<|>,\r\n    per_ns::PerNs,\r\n    visibility::{RawVisibility, Visibility},\r\n    AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,\r\n    FunctionId, GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\r\n    StaticId, StructId, TraitId, TypeAliasId, TypeParamId, VariantId,\r\n};\r\n```\r\nbecames\r\n```rust\r\nuse crate::{PathKind, name, name, ModPath};\r\n```\r\n</details>\r\n\r\n- [x] Ignoring visibility\r\n<details>\r\n    <summary>Details</summary>\r\n\r\n```rust\r\nmod foo {\r\n    mod bar {\r\n        pub struct Bar;\r\n    }\r\n}\r\n\r\nuse foo::bar::*;\r\n\r\nfn baz(bar: Bar) {}\r\n```\r\nbecames\r\n```rust\r\nmod foo {\r\n    mod bar {\r\n        pub struct Bar;\r\n    }\r\n}\r\n\r\nuse foo::bar::Bar;\r\n\r\nfn baz(bar: Bar) {}\r\n```\r\nalthough mod `bar` is private\r\n</details>\r\n\r\n- [x] Eating attributes\n\nCo-authored-by: unexge <unexge@gmail.com>", "tree": {"sha": "9d6b197eb7da370c26b52d8a0e4e7dfac480b979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d6b197eb7da370c26b52d8a0e4e7dfac480b979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfQ84ZCRBK7hj4Ov3rIwAAdHIIADhC1AOdKz8zA3y3yMlBg34V\nH4R/jNwORrRpb3W2ZJZBObUOGGaG0/prpyUs1WQlpXdHgHIwc0NVHZoQdUgCy4I/\nVazZxP9T2xnqKqBP+SkOLi1a2gWpmIry0kw8CWOdp/SsDkWabqvG54K8lK1KRCH8\n42lAyjdUSRtjeWyP9m9HLQI8laaGvUHeX4u54QnLPtdAdwSS3YRQn24DjtJVV7pa\nbyDd4v17vx3jsI9JPWoDowYYQjhRH5SGBOr14uSSRLgYGpYhxbfzzbcFBxZB7E2a\nHu9bTmo5fReM6eiWWN1aurdoxMM5Steh+93pHMK1IyiwfIg+uZQmj/y+sfunrwU=\n=nKXU\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d6b197eb7da370c26b52d8a0e4e7dfac480b979\nparent 3aa35e284590c709f1efea695bb12a1d651ddedb\nparent ef54e8451d2ebe20e900f9bea4545795ebd035c7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1598279193 +0000\ncommitter GitHub <noreply@github.com> 1598279193 +0000\n\nMerge #5733\n\n5733: Fix expand glob import bugs r=matklad a=unexge\n\nfixes https://github.com/rust-analyzer/rust-analyzer/issues/5709\r\n\r\nTODOs:\r\n- [x] Incorrect node replacing\r\n<details>\r\n    <summary>Details</summary>\r\n\r\n```rust\r\nuse crate::{\r\n    body::scope::{ExprScopes, ScopeId},\r\n    body::Body,\r\n    builtin_type::BuiltinType,\r\n    db::DefDatabase,\r\n    expr::{ExprId, PatId},\r\n    generics::GenericParams,\r\n    item_scope::{BuiltinShadowMode, BUILTIN_SCOPE},\r\n    nameres::CrateDefMap,\r\n    path::*<|>,\r\n    per_ns::PerNs,\r\n    visibility::{RawVisibility, Visibility},\r\n    AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,\r\n    FunctionId, GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\r\n    StaticId, StructId, TraitId, TypeAliasId, TypeParamId, VariantId,\r\n};\r\n```\r\nbecames\r\n```rust\r\nuse crate::{PathKind, name, name, ModPath};\r\n```\r\n</details>\r\n\r\n- [x] Ignoring visibility\r\n<details>\r\n    <summary>Details</summary>\r\n\r\n```rust\r\nmod foo {\r\n    mod bar {\r\n        pub struct Bar;\r\n    }\r\n}\r\n\r\nuse foo::bar::*;\r\n\r\nfn baz(bar: Bar) {}\r\n```\r\nbecames\r\n```rust\r\nmod foo {\r\n    mod bar {\r\n        pub struct Bar;\r\n    }\r\n}\r\n\r\nuse foo::bar::Bar;\r\n\r\nfn baz(bar: Bar) {}\r\n```\r\nalthough mod `bar` is private\r\n</details>\r\n\r\n- [x] Eating attributes\n\nCo-authored-by: unexge <unexge@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61", "html_url": "https://github.com/rust-lang/rust/commit/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aa35e284590c709f1efea695bb12a1d651ddedb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aa35e284590c709f1efea695bb12a1d651ddedb", "html_url": "https://github.com/rust-lang/rust/commit/3aa35e284590c709f1efea695bb12a1d651ddedb"}, {"sha": "ef54e8451d2ebe20e900f9bea4545795ebd035c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef54e8451d2ebe20e900f9bea4545795ebd035c7", "html_url": "https://github.com/rust-lang/rust/commit/ef54e8451d2ebe20e900f9bea4545795ebd035c7"}], "stats": {"total": 736, "additions": 617, "deletions": 119}, "files": [{"sha": "bf520069e88ea61214e1ced1ce67d430d3978337", "filename": "crates/assists/src/assist_context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/crates%2Fassists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/crates%2Fassists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_context.rs?ref=81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61", "patch": "@@ -73,10 +73,6 @@ impl<'a> AssistContext<'a> {\n         self.sema.db\n     }\n \n-    pub(crate) fn source_file(&self) -> &SourceFile {\n-        &self.source_file\n-    }\n-\n     // NB, this ignores active selection.\n     pub(crate) fn offset(&self) -> TextSize {\n         self.frange.range.start()"}, {"sha": "b39d040f6fdae62d939aa86a7ef6faa1c3a09647", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 617, "deletions": 115, "changes": 732, "blob_url": "https://github.com/rust-lang/rust/blob/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=81fa00c5b5d5ffb559a39c7ff5190a2519a8ea61", "patch": "@@ -1,10 +1,10 @@\n use either::Either;\n-use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n+use hir::{AssocItem, MacroDef, Module, ModuleDef, Name, PathResolution, ScopeDef};\n use ide_db::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n-    RootDatabase,\n+    search::SearchScope,\n };\n-use syntax::{algo, ast, match_ast, AstNode, SyntaxNode, SyntaxToken, T};\n+use syntax::{algo, ast, AstNode, Direction, SyntaxNode, SyntaxToken, T};\n \n use crate::{\n     assist_context::{AssistBuilder, AssistContext, Assists},\n@@ -38,140 +38,259 @@ use crate::{\n // ```\n pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let star = ctx.find_token_at_offset(T![*])?;\n-    let mod_path = find_mod_path(&star)?;\n-    let module = match ctx.sema.resolve_path(&mod_path)? {\n+    let (parent, mod_path) = find_parent_and_path(&star)?;\n+    let target_module = match ctx.sema.resolve_path(&mod_path)? {\n         PathResolution::Def(ModuleDef::Module(it)) => it,\n         _ => return None,\n     };\n \n-    let source_file = ctx.source_file();\n-    let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n+    let current_scope = ctx.sema.scope(&star.parent());\n+    let current_module = current_scope.module()?;\n \n-    let defs_in_mod = find_defs_in_mod(ctx, scope, module)?;\n-    let name_refs_in_source_file =\n-        source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n-    let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n+    let refs_in_target = find_refs_in_mod(ctx, target_module, Some(current_module))?;\n+    let imported_defs = find_imported_defs(ctx, star)?;\n+    let names_to_import = find_names_to_import(ctx, refs_in_target, imported_defs);\n \n-    let parent = star.parent().parent()?;\n+    let target = parent.clone().either(|n| n.syntax().clone(), |n| n.syntax().clone());\n     acc.add(\n         AssistId(\"expand_glob_import\", AssistKind::RefactorRewrite),\n         \"Expand glob import\",\n-        parent.text_range(),\n+        target.text_range(),\n         |builder| {\n-            replace_ast(builder, &parent, mod_path, used_names);\n+            replace_ast(builder, parent, mod_path, names_to_import);\n         },\n     )\n }\n \n-fn find_mod_path(star: &SyntaxToken) -> Option<ast::Path> {\n-    star.ancestors().find_map(|n| ast::UseTree::cast(n).and_then(|u| u.path()))\n+fn find_parent_and_path(\n+    star: &SyntaxToken,\n+) -> Option<(Either<ast::UseTree, ast::UseTreeList>, ast::Path)> {\n+    return star.ancestors().find_map(|n| {\n+        find_use_tree_list(n.clone())\n+            .and_then(|(u, p)| Some((Either::Right(u), p)))\n+            .or_else(|| find_use_tree(n).and_then(|(u, p)| Some((Either::Left(u), p))))\n+    });\n+\n+    fn find_use_tree_list(n: SyntaxNode) -> Option<(ast::UseTreeList, ast::Path)> {\n+        let use_tree_list = ast::UseTreeList::cast(n)?;\n+        let path = use_tree_list.parent_use_tree().path()?;\n+        Some((use_tree_list, path))\n+    }\n+\n+    fn find_use_tree(n: SyntaxNode) -> Option<(ast::UseTree, ast::Path)> {\n+        let use_tree = ast::UseTree::cast(n)?;\n+        let path = use_tree.path()?;\n+        Some((use_tree, path))\n+    }\n }\n \n-#[derive(PartialEq)]\n+#[derive(Debug, PartialEq, Clone)]\n enum Def {\n     ModuleDef(ModuleDef),\n     MacroDef(MacroDef),\n }\n \n impl Def {\n-    fn name(&self, db: &RootDatabase) -> Option<Name> {\n-        match self {\n-            Def::ModuleDef(def) => def.name(db),\n-            Def::MacroDef(def) => def.name(db),\n+    fn is_referenced_in(&self, ctx: &AssistContext) -> bool {\n+        let def = match self {\n+            Def::ModuleDef(def) => Definition::ModuleDef(*def),\n+            Def::MacroDef(def) => Definition::Macro(*def),\n+        };\n+\n+        let search_scope = SearchScope::single_file(ctx.frange.file_id);\n+        def.usages(&ctx.sema).in_scope(search_scope).at_least_one()\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+struct Ref {\n+    // could be alias\n+    visible_name: Name,\n+    def: Def,\n+}\n+\n+impl Ref {\n+    fn from_scope_def(name: Name, scope_def: ScopeDef) -> Option<Self> {\n+        match scope_def {\n+            ScopeDef::ModuleDef(def) => Some(Ref { visible_name: name, def: Def::ModuleDef(def) }),\n+            ScopeDef::MacroDef(def) => Some(Ref { visible_name: name, def: Def::MacroDef(def) }),\n+            _ => None,\n         }\n     }\n }\n \n-fn find_defs_in_mod(\n+#[derive(Debug, Clone)]\n+struct Refs(Vec<Ref>);\n+\n+impl Refs {\n+    fn used_refs(&self, ctx: &AssistContext) -> Refs {\n+        Refs(\n+            self.0\n+                .clone()\n+                .into_iter()\n+                .filter(|r| {\n+                    if let Def::ModuleDef(ModuleDef::Trait(tr)) = r.def {\n+                        if tr\n+                            .items(ctx.db())\n+                            .into_iter()\n+                            .find(|ai| {\n+                                if let AssocItem::Function(f) = *ai {\n+                                    Def::ModuleDef(ModuleDef::Function(f)).is_referenced_in(ctx)\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                            .is_some()\n+                        {\n+                            return true;\n+                        }\n+                    }\n+\n+                    r.def.is_referenced_in(ctx)\n+                })\n+                .collect(),\n+        )\n+    }\n+\n+    fn filter_out_by_defs(&self, defs: Vec<Def>) -> Refs {\n+        Refs(self.0.clone().into_iter().filter(|r| !defs.contains(&r.def)).collect())\n+    }\n+}\n+\n+fn find_refs_in_mod(\n     ctx: &AssistContext,\n-    from: SemanticsScope<'_>,\n-    module: hir::Module,\n-) -> Option<Vec<Def>> {\n-    let module_scope = module.scope(ctx.db(), from.module());\n-\n-    let mut defs = vec![];\n-    for (_, def) in module_scope {\n-        match def {\n-            ScopeDef::ModuleDef(def) => defs.push(Def::ModuleDef(def)),\n-            ScopeDef::MacroDef(def) => defs.push(Def::MacroDef(def)),\n-            _ => continue,\n+    module: Module,\n+    visible_from: Option<Module>,\n+) -> Option<Refs> {\n+    if let Some(from) = visible_from {\n+        if !is_mod_visible_from(ctx, module, from) {\n+            return None;\n         }\n     }\n \n-    Some(defs)\n+    let module_scope = module.scope(ctx.db(), visible_from);\n+    let refs = module_scope.into_iter().filter_map(|(n, d)| Ref::from_scope_def(n, d)).collect();\n+    Some(Refs(refs))\n }\n \n-fn find_used_names(\n-    ctx: &AssistContext,\n-    defs_in_mod: Vec<Def>,\n-    name_refs_in_source_file: Vec<ast::NameRef>,\n-) -> Vec<Name> {\n-    let defs_in_source_file = name_refs_in_source_file\n-        .iter()\n-        .filter_map(|r| classify_name_ref(&ctx.sema, r))\n-        .filter_map(|rc| match rc {\n-            NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n-            NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n-            _ => None,\n-        })\n-        .collect::<Vec<Def>>();\n+fn is_mod_visible_from(ctx: &AssistContext, module: Module, from: Module) -> bool {\n+    match module.parent(ctx.db()) {\n+        Some(parent) => {\n+            parent.visibility_of(ctx.db(), &ModuleDef::Module(module)).map_or(true, |vis| {\n+                vis.is_visible_from(ctx.db(), from.into()) && is_mod_visible_from(ctx, parent, from)\n+            })\n+        }\n+        None => true,\n+    }\n+}\n \n-    defs_in_mod\n-        .iter()\n-        .filter(|def| {\n-            if let Def::ModuleDef(ModuleDef::Trait(tr)) = def {\n-                for item in tr.items(ctx.db()) {\n-                    if let AssocItem::Function(f) = item {\n-                        if defs_in_source_file.contains(&Def::ModuleDef(ModuleDef::Function(f))) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n+// looks for name refs in parent use block's siblings\n+//\n+// mod bar {\n+//     mod qux {\n+//         struct Qux;\n+//     }\n+//\n+//     pub use qux::Qux;\n+// }\n+//\n+// \u2193 ---------------\n+// use foo::*<|>;\n+// use baz::Baz;\n+// \u2191 ---------------\n+fn find_imported_defs(ctx: &AssistContext, star: SyntaxToken) -> Option<Vec<Def>> {\n+    let parent_use_item_syntax =\n+        star.ancestors().find_map(|n| if ast::Use::can_cast(n.kind()) { Some(n) } else { None })?;\n+\n+    Some(\n+        [Direction::Prev, Direction::Next]\n+            .iter()\n+            .map(|dir| {\n+                parent_use_item_syntax\n+                    .siblings(dir.to_owned())\n+                    .filter(|n| ast::Use::can_cast(n.kind()))\n+            })\n+            .flatten()\n+            .filter_map(|n| Some(n.descendants().filter_map(ast::NameRef::cast)))\n+            .flatten()\n+            .filter_map(|r| match classify_name_ref(&ctx.sema, &r)? {\n+                NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n+                NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n+                _ => None,\n+            })\n+            .collect(),\n+    )\n+}\n \n-            defs_in_source_file.contains(def)\n-        })\n-        .filter_map(|d| d.name(ctx.db()))\n-        .collect()\n+fn find_names_to_import(\n+    ctx: &AssistContext,\n+    refs_in_target: Refs,\n+    imported_defs: Vec<Def>,\n+) -> Vec<Name> {\n+    let used_refs = refs_in_target.used_refs(ctx).filter_out_by_defs(imported_defs);\n+    used_refs.0.iter().map(|r| r.visible_name.clone()).collect()\n }\n \n fn replace_ast(\n     builder: &mut AssistBuilder,\n-    node: &SyntaxNode,\n+    parent: Either<ast::UseTree, ast::UseTreeList>,\n     path: ast::Path,\n-    used_names: Vec<Name>,\n+    names_to_import: Vec<Name>,\n ) {\n-    let replacement: Either<ast::UseTree, ast::UseTreeList> = match used_names.as_slice() {\n-        [name] => Either::Left(ast::make::use_tree(\n-            ast::make::path_from_text(&format!(\"{}::{}\", path, name)),\n-            None,\n-            None,\n-            false,\n-        )),\n-        names => Either::Right(ast::make::use_tree_list(names.iter().map(|n| {\n-            ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false)\n-        }))),\n+    let existing_use_trees = match parent.clone() {\n+        Either::Left(_) => vec![],\n+        Either::Right(u) => u\n+            .use_trees()\n+            .filter(|n|\n+            // filter out star\n+            n.star_token().is_none())\n+            .collect(),\n     };\n \n-    let mut replace_node = |replacement: Either<ast::UseTree, ast::UseTreeList>| {\n-        algo::diff(node, &replacement.either(|u| u.syntax().clone(), |ut| ut.syntax().clone()))\n+    let new_use_trees: Vec<ast::UseTree> = names_to_import\n+        .iter()\n+        .map(|n| ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false))\n+        .collect();\n+\n+    let use_trees = [&existing_use_trees[..], &new_use_trees[..]].concat();\n+\n+    match use_trees.as_slice() {\n+        [name] => {\n+            if let Some(end_path) = name.path() {\n+                let replacement = ast::make::use_tree(\n+                    ast::make::path_from_text(&format!(\"{}::{}\", path, end_path)),\n+                    None,\n+                    None,\n+                    false,\n+                );\n+\n+                algo::diff(\n+                    &parent.either(|n| n.syntax().clone(), |n| n.syntax().clone()),\n+                    replacement.syntax(),\n+                )\n+                .into_text_edit(builder.text_edit_builder());\n+            }\n+        }\n+        names => {\n+            let replacement = match parent {\n+                Either::Left(_) => ast::make::use_tree(\n+                    path,\n+                    Some(ast::make::use_tree_list(names.to_owned())),\n+                    None,\n+                    false,\n+                )\n+                .syntax()\n+                .clone(),\n+                Either::Right(_) => ast::make::use_tree_list(names.to_owned()).syntax().clone(),\n+            };\n+\n+            algo::diff(\n+                &parent.either(|n| n.syntax().clone(), |n| n.syntax().clone()),\n+                &replacement,\n+            )\n             .into_text_edit(builder.text_edit_builder());\n-    };\n-\n-    match_ast! {\n-        match node {\n-            ast::UseTree(use_tree) => {\n-                replace_node(replacement);\n-            },\n-            ast::UseTreeList(use_tree_list) => {\n-                replace_node(replacement);\n-            },\n-            ast::Use(use_item) => {\n-                builder.replace_ast(use_item, ast::make::use_(replacement.left_or_else(|ut| ast::make::use_tree(path, Some(ut), None, false))));\n-            },\n-            _ => {},\n         }\n-    }\n+    };\n }\n \n #[cfg(test)]\n@@ -245,7 +364,46 @@ mod foo {\n     pub fn f() {}\n }\n \n-use foo::{Baz, Bar, f};\n+use foo::{f, Baz, Bar};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_existing_uses_in_same_module() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::Bar;\n+use foo::{*<|>, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::Bar;\n+use foo::{f, Baz};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n@@ -260,15 +418,15 @@ fn qux(bar: Bar, baz: Baz) {\n             expand_glob_import,\n             r\"\n mod foo {\n-    mod bar {\n+    pub mod bar {\n         pub struct Bar;\n         pub struct Baz;\n         pub struct Qux;\n \n         pub fn f() {}\n     }\n \n-    mod baz {\n+    pub mod baz {\n         pub fn g() {}\n     }\n }\n@@ -282,63 +440,367 @@ fn qux(bar: Bar, baz: Baz) {\n \",\n             r\"\n mod foo {\n-    mod bar {\n+    pub mod bar {\n         pub struct Bar;\n         pub struct Baz;\n         pub struct Qux;\n \n         pub fn f() {}\n     }\n \n-    mod baz {\n+    pub mod baz {\n         pub fn g() {}\n     }\n }\n \n-use foo::{bar::{Baz, Bar, f}, baz::*};\n+use foo::{bar::{f, Baz, Bar}, baz::*};\n \n fn qux(bar: Bar, baz: Baz) {\n     f();\n     g();\n }\n \",\n-        )\n+        );\n+\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{Bar, Baz, f}, baz::*<|>};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{Bar, Baz, f}, baz::g};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+        );\n+\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::*<|>}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    q::j();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{q, h}}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    q::j();\n+}\n+\",\n+        );\n+\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{h, q::*<|>}}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    j();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{h, q::j}}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    j();\n+}\n+\",\n+        );\n+\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{q::j, *<|>}}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    j();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    pub mod baz {\n+        pub fn g() {}\n+\n+        pub mod qux {\n+            pub fn h() {}\n+            pub fn m() {}\n+\n+            pub mod q {\n+                pub fn j() {}\n+            }\n+        }\n+    }\n+}\n+\n+use foo::{\n+    bar::{*, f},\n+    baz::{g, qux::{q::j, h}}\n+};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+    h();\n+    j();\n+}\n+\",\n+        );\n     }\n \n     #[test]\n     fn expanding_glob_import_with_macro_defs() {\n+        // FIXME: this is currently fails because `Definition::find_usages` ignores macros\n+        //       https://github.com/rust-analyzer/rust-analyzer/issues/3484\n+        //\n+        //         check_assist(\n+        //             expand_glob_import,\n+        //             r\"\n+        // //- /lib.rs crate:foo\n+        // #[macro_export]\n+        // macro_rules! bar {\n+        //     () => ()\n+        // }\n+\n+        // pub fn baz() {}\n+\n+        // //- /main.rs crate:main deps:foo\n+        // use foo::*<|>;\n+\n+        // fn main() {\n+        //     bar!();\n+        //     baz();\n+        // }\n+        // \",\n+        //             r\"\n+        // use foo::{bar, baz};\n+\n+        // fn main() {\n+        //     bar!();\n+        //     baz();\n+        // }\n+        // \",\n+        //         )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_trait_method_uses() {\n         check_assist(\n             expand_glob_import,\n             r\"\n //- /lib.rs crate:foo\n-#[macro_export]\n-macro_rules! bar {\n-    () => ()\n+pub trait Tr {\n+    fn method(&self) {}\n }\n-\n-pub fn baz() {}\n+impl Tr for () {}\n \n //- /main.rs crate:main deps:foo\n use foo::*<|>;\n \n fn main() {\n-    bar!();\n-    baz();\n+    ().method();\n }\n \",\n             r\"\n-use foo::{bar, baz};\n+use foo::Tr;\n \n fn main() {\n-    bar!();\n-    baz();\n+    ().method();\n }\n \",\n-        )\n-    }\n+        );\n \n-    #[test]\n-    fn expanding_glob_import_with_trait_method_uses() {\n         check_assist(\n             expand_glob_import,\n             r\"\n@@ -348,6 +810,11 @@ pub trait Tr {\n }\n impl Tr for () {}\n \n+pub trait Tr2 {\n+    fn method2(&self) {}\n+}\n+impl Tr2 for () {}\n+\n //- /main.rs crate:main deps:foo\n use foo::*<|>;\n \n@@ -362,7 +829,42 @@ fn main() {\n     ().method();\n }\n \",\n-        )\n+        );\n+    }\n+\n+    #[test]\n+    fn expanding_is_not_applicable_if_target_module_is_not_accessible_from_current_scope() {\n+        check_assist_not_applicable(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+    }\n+}\n+\n+use foo::bar::*<|>;\n+\n+fn baz(bar: Bar) {}\n+\",\n+        );\n+\n+        check_assist_not_applicable(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub mod baz {\n+            pub struct Baz;\n+        }\n+    }\n+}\n+\n+use foo::bar::baz::*<|>;\n+\n+fn qux(baz: Baz) {}\n+\",\n+        );\n     }\n \n     #[test]"}]}