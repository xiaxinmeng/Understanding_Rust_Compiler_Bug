{"sha": "7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhOGQ0ODIyZDhlYjkyMmYwY2Q1MGU5MmY0MjBiNWYxOTM4ZGI2NGQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-26T22:13:48Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-26T22:15:07Z"}, "message": "rustc: use Vec<Kind> in Substs, where Kind is a &TyS | &Region tagged pointer.", "tree": {"sha": "424af74ecf39f8b6aad5a5abdb831efd6e21a9b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/424af74ecf39f8b6aad5a5abdb831efd6e21a9b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "html_url": "https://github.com/rust-lang/rust/commit/7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dffd238f8b3195982427ba14bc01d47c6da6aedf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dffd238f8b3195982427ba14bc01d47c6da6aedf", "html_url": "https://github.com/rust-lang/rust/commit/dffd238f8b3195982427ba14bc01d47c6da6aedf"}], "stats": {"total": 941, "additions": 532, "deletions": 409}, "files": [{"sha": "1e4b2e9116fd27f67e5b344e947e683e9700c568", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -27,6 +27,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n+#![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(enumset)]"}, {"sha": "b33bc520fe21622407561beccea2dab9e662dc30", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -149,7 +149,7 @@ pub trait CrateStore<'tcx> {\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n+    fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>;\n@@ -328,7 +328,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n+    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx> { bug!(\"item_type\") }"}, {"sha": "ebe4050022153bee2cb2db306778f25eee1bd967", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -89,9 +89,12 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n \n #[derive(PartialEq, Debug)]\n enum ScopeChain<'a> {\n-    /// EarlyScope(['a, 'b, ...], s) extends s with early-bound\n-    /// lifetimes.\n-    EarlyScope(&'a [hir::LifetimeDef], Scope<'a>),\n+    /// EarlyScope(['a, 'b, ...], start, s) extends s with early-bound\n+    /// lifetimes, with consecutive parameter indices from `start`.\n+    /// That is, 'a has index `start`, 'b has index `start + 1`, etc.\n+    /// Indices before `start` correspond to other generic parameters\n+    /// of a parent item (trait/impl of a method), or `Self` in traits.\n+    EarlyScope(&'a [hir::LifetimeDef], u32, Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n     LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n@@ -157,7 +160,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n-                    this.with(EarlyScope(lifetimes, &ROOT_SCOPE), |old_scope, this| {\n+                    let start = if let hir::ItemTrait(..) = item.node {\n+                        1 // Self comes before lifetimes\n+                    } else {\n+                        0\n+                    };\n+                    this.with(EarlyScope(lifetimes, start, &ROOT_SCOPE), |old_scope, this| {\n                         this.check_lifetime_defs(old_scope, lifetimes);\n                         intravisit::walk_item(this, item);\n                     });\n@@ -461,7 +469,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Block) {\n                 FnScope { s, .. } => { scope = s; }\n                 RootScope => { return; }\n \n-                EarlyScope(lifetimes, s) |\n+                EarlyScope(lifetimes, _, s) |\n                 LateScope(lifetimes, s) => {\n                     for lifetime_def in lifetimes {\n                         // FIXME (#24278): non-hygienic comparison\n@@ -566,8 +574,24 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .cloned()\n                     .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n \n+        // Find the start of nested early scopes, e.g. in methods.\n+        let mut start = 0;\n+        if let EarlyScope(..) = *self.scope {\n+            let parent = self.hir_map.expect_item(self.hir_map.get_parent(fn_id));\n+            if let hir::ItemTrait(..) = parent.node {\n+                start += 1; // Self comes first.\n+            }\n+            match parent.node {\n+                hir::ItemTrait(_, ref generics, _, _) |\n+                hir::ItemImpl(_, _, ref generics, _, _, _) => {\n+                    start += generics.lifetimes.len() + generics.ty_params.len();\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         let this = self;\n-        this.with(EarlyScope(&early, this.scope), move |old_scope, this| {\n+        this.with(EarlyScope(&early, start as u32, this.scope), move |old_scope, this| {\n             this.with(LateScope(&late, this.scope), move |_, this| {\n                 this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                 walk(this);\n@@ -597,19 +621,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(lifetimes, s) => {\n+                EarlyScope(lifetimes, start, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((mut index, lifetime_def)) => {\n-                            // Adjust for nested early scopes, e.g. in methods.\n-                            let mut parent = s;\n-                            while let EarlyScope(lifetimes, s) = *parent {\n-                                index += lifetimes.len() as u32;\n-                                parent = s;\n-                            }\n-                            assert_eq!(*parent, RootScope);\n-\n+                        Some((index, lifetime_def)) => {\n                             let decl_id = lifetime_def.id;\n-                            let def = DefEarlyBoundRegion(index, decl_id);\n+                            let def = DefEarlyBoundRegion(start + index, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n@@ -671,7 +687,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break;\n                 }\n \n-                EarlyScope(lifetimes, s) |\n+                EarlyScope(lifetimes, _, s) |\n                 LateScope(lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n@@ -767,7 +783,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                EarlyScope(lifetimes, s) |\n+                EarlyScope(lifetimes, _, s) |\n                 LateScope(lifetimes, s) => {\n                     if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n                         signal_shadowing_problem("}, {"sha": "6598aacc1d3d2d2ee5adffc807bdf4eb772d4c28", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n                 let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n                 let predicate = ty::TraitRef {\n                     def_id: self.predicate.def_id(),\n-                    substs: Substs::new_trait(tcx, vec![], vec![], concrete_ty)\n+                    substs: Substs::new_trait(tcx, concrete_ty, &[])\n                 }.to_predicate();\n \n                 let original_obligation = Obligation::new(self.cause.clone(),\n@@ -440,7 +440,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n+     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n      .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })"}, {"sha": "b015de79be5c690e632d723359960134b3212d6e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -36,7 +36,7 @@ use super::util;\n use hir::def_id::DefId;\n use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener, TypeOrigin};\n-use ty::subst::{Subst, Substs};\n+use ty::subst::{Kind, Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n@@ -1933,7 +1933,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             // for `PhantomData<T>`, we pass `T`\n             ty::TyStruct(def, substs) if def.is_phantom_data() => {\n-                substs.types().cloned().collect()\n+                substs.types().collect()\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n@@ -1982,7 +1982,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                   trait_def_id,\n                                                   recursion_depth,\n                                                   normalized_ty,\n-                                                  vec![]);\n+                                                  &[]);\n                 obligations.push(skol_obligation);\n                 this.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n@@ -2180,8 +2180,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let input_types = data.principal.input_types();\n                 let assoc_types = data.projection_bounds.iter()\n                                       .map(|pb| pb.skip_binder().ty);\n-                let all_types: Vec<_> = input_types.cloned()\n-                                                   .chain(assoc_types)\n+                let all_types: Vec<_> = input_types.chain(assoc_types)\n                                                    .collect();\n \n                 // reintroduce the two binding levels we skipped, then flatten into one\n@@ -2598,14 +2597,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // TyError and ensure they do not affect any other fields.\n                 // This could be checked after type collection for any struct\n                 // with a potentially unsized trailing field.\n-                let types = substs_a.types().enumerate().map(|(i, ty)| {\n+                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n-                        tcx.types.err\n+                        Kind::from(tcx.types.err)\n                     } else {\n-                        ty\n+                        k\n                     }\n-                }).collect();\n-                let substs = Substs::new(tcx, types, substs_a.regions().cloned().collect());\n+                });\n+                let substs = Substs::new(tcx, params);\n                 for &ty in fields.split_last().unwrap().1 {\n                     if ty.subst(tcx, substs).references_error() {\n                         return Err(Unimplemented);\n@@ -2618,15 +2617,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n                 // Check that the source structure with the target's\n                 // type parameters is a subtype of the target.\n-                let types = substs_a.types().enumerate().map(|(i, ty)| {\n+                let params = substs_a.params().iter().enumerate().map(|(i, &k)| {\n                     if ty_params.contains(i) {\n-                        substs_b.type_at(i)\n+                        Kind::from(substs_b.type_at(i))\n                     } else {\n-                        ty\n+                        k\n                     }\n-                }).collect();\n-                let substs = Substs::new(tcx, types, substs_a.regions().cloned().collect());\n-                let new_struct = tcx.mk_struct(def, substs);\n+                });\n+                let new_struct = tcx.mk_struct(def, Substs::new(tcx, params));\n                 let origin = TypeOrigin::Misc(obligation.cause.span);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n@@ -2639,7 +2637,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n                     inner_source,\n-                    vec![inner_target]));\n+                    &[inner_target]));\n             }\n \n             _ => bug!()\n@@ -2753,7 +2751,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         obligation.predicate.skip_binder().input_types()\n             .zip(impl_trait_ref.input_types())\n-            .any(|(&obligation_ty, &impl_ty)| {\n+            .any(|(obligation_ty, impl_ty)| {\n                 let simplified_obligation_ty =\n                     fast_reject::simplify_type(self.tcx(), obligation_ty, true);\n                 let simplified_impl_ty ="}, {"sha": "038de25312d35b631fb1f6fe41c4abb703d21246", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Ok(def_id) => {\n                 Ok(ty::TraitRef {\n                     def_id: def_id,\n-                    substs: Substs::new_trait(self, vec![], vec![], param_ty)\n+                    substs: Substs::new_trait(self, param_ty, &[])\n                 })\n             }\n             Err(e) => {\n@@ -401,12 +401,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         trait_def_id: DefId,\n         recursion_depth: usize,\n         param_ty: Ty<'tcx>,\n-        ty_params: Vec<Ty<'tcx>>)\n+        ty_params: &[Ty<'tcx>])\n         -> PredicateObligation<'tcx>\n     {\n         let trait_ref = ty::TraitRef {\n             def_id: trait_def_id,\n-            substs: Substs::new_trait(self, ty_params, vec![], param_ty)\n+            substs: Substs::new_trait(self, param_ty, ty_params)\n         };\n         predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n@@ -496,7 +496,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,\n-            substs: Substs::new_trait(self, vec![arguments_tuple], vec![], self_ty),\n+            substs: Substs::new_trait(self, self_ty, &[arguments_tuple]),\n         };\n         ty::Binder((trait_ref, sig.0.output))\n     }"}, {"sha": "e048e618e84d66951cd38467f3b9b0c0d2037f2c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -1152,7 +1152,7 @@ fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n impl_interners!('tcx,\n     type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n     substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n-        substs.types().any(keep_local) || substs.regions().any(keep_local)\n+        substs.params().iter().any(keep_local)\n     }) -> Substs<'tcx>,\n     bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n         keep_local(&fty.sig)"}, {"sha": "1afd49ab47fbfeb686252bb807173bac5fc2a248", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -208,11 +208,11 @@ impl FlagComputation {\n     }\n \n     fn add_substs(&mut self, substs: &Substs) {\n-        for &ty in substs.types() {\n+        for ty in substs.types() {\n             self.add_ty(ty);\n         }\n \n-        for &r in substs.regions() {\n+        for r in substs.regions() {\n             self.add_region(r);\n         }\n     }"}, {"sha": "0e8bea86178f3097bc4021d656c592d6659a3e57", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -38,7 +38,7 @@ dep_map_ty! { TraitItemDefIds: TraitItemDefIds(DefId) -> Rc<Vec<ty::ImplOrTraitI\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n-dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<ty::ItemVariances> }\n+dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplItems: ImplItems(DefId) -> Vec<ty::ImplOrTraitItemId> }\n dep_map_ty! { TraitItems: TraitItems(DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> }"}, {"sha": "759dc30037210166b0729595a1123786a68e2b21", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -417,21 +417,6 @@ pub struct AssociatedType<'tcx> {\n     pub container: ImplOrTraitItemContainer,\n }\n \n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n-pub struct ItemVariances {\n-    pub types: Vec<Variance>,\n-    pub regions: Vec<Variance>,\n-}\n-\n-impl ItemVariances {\n-    pub fn empty() -> ItemVariances {\n-        ItemVariances {\n-            types: vec![],\n-            regions: vec![],\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n@@ -755,6 +740,20 @@ pub struct Generics<'tcx> {\n     pub has_self: bool,\n }\n \n+impl<'tcx> Generics<'tcx> {\n+    pub fn parent_count(&self) -> usize {\n+        self.parent_regions as usize + self.parent_types as usize\n+    }\n+\n+    pub fn own_count(&self) -> usize {\n+        self.regions.len() + self.types.len()\n+    }\n+\n+    pub fn count(&self) -> usize {\n+        self.parent_count() + self.own_count()\n+    }\n+}\n+\n /// Bounds on generics.\n #[derive(Clone)]\n pub struct GenericPredicates<'tcx> {\n@@ -963,7 +962,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n         DepNode::TraitSelect(self.def_id(), def_ids)\n     }\n \n-    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         self.trait_ref.input_types()\n     }\n \n@@ -1107,7 +1106,7 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn walk_tys(&self) -> IntoIter<Ty<'tcx>> {\n         let vec: Vec<_> = match *self {\n             ty::Predicate::Trait(ref data) => {\n-                data.skip_binder().input_types().cloned().collect()\n+                data.skip_binder().input_types().collect()\n             }\n             ty::Predicate::Rfc1592(ref data) => {\n                 return data.walk_tys()\n@@ -1123,9 +1122,7 @@ impl<'tcx> Predicate<'tcx> {\n             }\n             ty::Predicate::Projection(ref data) => {\n                 let trait_inputs = data.0.projection_ty.trait_ref.input_types();\n-                trait_inputs.cloned()\n-                            .chain(Some(data.0.ty))\n-                            .collect()\n+                trait_inputs.chain(Some(data.0.ty)).collect()\n             }\n             ty::Predicate::WellFormed(data) => {\n                 vec![data]\n@@ -1208,7 +1205,7 @@ impl<'tcx> TraitRef<'tcx> {\n         self.substs.type_at(0)\n     }\n \n-    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -1865,7 +1862,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 };\n                 let sized_predicate = Binder(TraitRef {\n                     def_id: sized_trait,\n-                    substs: Substs::new_trait(tcx, vec![], vec![], ty)\n+                    substs: Substs::new_trait(tcx, ty, &[])\n                 }).to_predicate();\n                 let predicates = tcx.lookup_predicates(self.did).predicates;\n                 if predicates.into_iter().any(|p| p == sized_predicate) {\n@@ -2592,7 +2589,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n-    pub fn item_variances(self, item_id: DefId) -> Rc<ItemVariances> {\n+    pub fn item_variances(self, item_id: DefId) -> Rc<Vec<ty::Variance>> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n             || Rc::new(self.sess.cstore.item_variances(item_id)))"}, {"sha": "5c157ff32e7bbb846bd256f6b98c9c3315a07b61", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -14,7 +14,7 @@\n //! type equality, etc.\n \n use hir::def_id::DefId;\n-use ty::subst::Substs;\n+use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n@@ -139,25 +139,26 @@ fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n }\n \n pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                        variances: Option<&ty::ItemVariances>,\n+                                        variances: Option<&Vec<ty::Variance>>,\n                                         a_subst: &'tcx Substs<'tcx>,\n                                         b_subst: &'tcx Substs<'tcx>)\n                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n     where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n \n-    let types = a_subst.types().zip(b_subst.types()).enumerate().map(|(i, (a_ty, b_ty))| {\n-        let variance = variances.map_or(ty::Invariant, |v| v.types[i]);\n-        relation.relate_with_variance(variance, a_ty, b_ty)\n-    }).collect::<Result<_, _>>()?;\n-\n-    let regions = a_subst.regions().zip(b_subst.regions()).enumerate().map(|(i, (a_r, b_r))| {\n-        let variance = variances.map_or(ty::Invariant, |v| v.regions[i]);\n-        relation.relate_with_variance(variance, a_r, b_r)\n-    }).collect::<Result<_, _>>()?;\n+    let params = a_subst.params().iter().zip(b_subst.params()).enumerate().map(|(i, (a, b))| {\n+        let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+        if let (Some(a_ty), Some(b_ty)) = (a.as_type(), b.as_type()) {\n+            Ok(Kind::from(relation.relate_with_variance(variance, &a_ty, &b_ty)?))\n+        } else if let (Some(a_r), Some(b_r)) = (a.as_region(), b.as_region()) {\n+            Ok(Kind::from(relation.relate_with_variance(variance, &a_r, &b_r)?))\n+        } else {\n+            bug!()\n+        }\n+    });\n \n-    Ok(Substs::new(tcx, types, regions))\n+    Substs::maybe_new(tcx, params)\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {"}, {"sha": "0e3f18c4474eaed1b91788ee56b3c298eb38f7aa", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -21,7 +21,6 @@ use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n use std::mem;\n use std::ops;\n-use std::slice;\n use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::keywords;\n@@ -336,7 +335,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n         self.0.substs\n     }\n \n-    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n@@ -361,7 +360,7 @@ pub struct ExistentialTraitRef<'tcx> {\n }\n \n impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>>{\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n@@ -377,7 +376,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n         self.0.def_id\n     }\n \n-    pub fn input_types(&self) -> slice::Iter<Ty<'tcx>> {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n         // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n@@ -1229,13 +1228,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyEnum(_, substs) |\n             TyStruct(_, substs) |\n             TyAnon(_, substs) => {\n-                substs.regions().cloned().collect()\n+                substs.regions().collect()\n             }\n             TyClosure(_, ref substs) => {\n-                substs.func_substs.regions().cloned().collect()\n+                substs.func_substs.regions().collect()\n             }\n             TyProjection(ref data) => {\n-                data.trait_ref.substs.regions().cloned().collect()\n+                data.trait_ref.substs.regions().collect()\n             }\n             TyFnDef(..) |\n             TyFnPtr(_) |"}, {"sha": "0ccfea23309999d96d3fdbfa03151764824aa90a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 187, "deletions": 59, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -18,38 +18,151 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use serialize::{Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use std::slice;\n+use core::nonzero::NonZero;\n+use std::fmt;\n+use std::iter;\n+use std::marker::PhantomData;\n+use std::mem;\n+\n+/// An entity in the Rust typesystem, which can be one of\n+/// several kinds (only types and lifetimes for now).\n+/// To reduce memory usage, a `Kind` is a interned pointer,\n+/// with the lowest 2 bits being reserved for a tag to\n+/// indicate the type (`Ty` or `Region`) it points to.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Kind<'tcx> {\n+    ptr: NonZero<usize>,\n+    marker: PhantomData<(Ty<'tcx>, &'tcx ty::Region)>\n+}\n \n-///////////////////////////////////////////////////////////////////////////\n+const TAG_MASK: usize = 0b11;\n+const TYPE_TAG: usize = 0b00;\n+const REGION_TAG: usize = 0b01;\n+\n+impl<'tcx> From<Ty<'tcx>> for Kind<'tcx> {\n+    fn from(ty: Ty<'tcx>) -> Kind<'tcx> {\n+        // Ensure we can use the tag bits.\n+        assert_eq!(mem::align_of_val(ty) & TAG_MASK, 0);\n+\n+        let ptr = ty as *const _ as usize;\n+        Kind {\n+            ptr: unsafe {\n+                NonZero::new(ptr | TYPE_TAG)\n+            },\n+            marker: PhantomData\n+        }\n+    }\n+}\n+\n+impl<'tcx> From<&'tcx ty::Region> for Kind<'tcx> {\n+    fn from(r: &'tcx ty::Region) -> Kind<'tcx> {\n+        // Ensure we can use the tag bits.\n+        assert_eq!(mem::align_of_val(r) & TAG_MASK, 0);\n+\n+        let ptr = r as *const _ as usize;\n+        Kind {\n+            ptr: unsafe {\n+                NonZero::new(ptr | REGION_TAG)\n+            },\n+            marker: PhantomData\n+        }\n+    }\n+}\n+\n+impl<'tcx> Kind<'tcx> {\n+    #[inline]\n+    unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n+        let ptr = *self.ptr;\n+        if ptr & TAG_MASK == tag {\n+            Some(&*((ptr & !TAG_MASK) as *const _))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_type(self) -> Option<Ty<'tcx>> {\n+        unsafe {\n+            self.downcast(TYPE_TAG)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn as_region(self) -> Option<&'tcx ty::Region> {\n+        unsafe {\n+            self.downcast(REGION_TAG)\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for Kind<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if let Some(ty) = self.as_type() {\n+            write!(f, \"{:?}\", ty)\n+        } else if let Some(r) = self.as_region() {\n+            write!(f, \"{:?}\", r)\n+        } else {\n+            write!(f, \"<unknwon @ {:p}>\", *self.ptr as *const ())\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        if let Some(ty) = self.as_type() {\n+            Kind::from(ty.fold_with(folder))\n+        } else if let Some(r) = self.as_region() {\n+            Kind::from(r.fold_with(folder))\n+        } else {\n+            bug!()\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        if let Some(ty) = self.as_type() {\n+            ty.visit_with(visitor)\n+        } else if let Some(r) = self.as_region() {\n+            r.visit_with(visitor)\n+        } else {\n+            bug!()\n+        }\n+    }\n+}\n \n /// A substitution mapping type/region parameters to new values.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs<'tcx> {\n-    types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>,\n+    params: Vec<Kind<'tcx>>\n }\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               t: Vec<Ty<'tcx>>,\n-               r: Vec<ty::Region>)\n-               -> &'tcx Substs<'tcx>\n-    {\n-        tcx.mk_substs(Substs { types: t, regions: r })\n+    pub fn new<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n+                  -> &'tcx Substs<'tcx>\n+    where I: IntoIterator<Item=Kind<'tcx>> {\n+        tcx.mk_substs(Substs {\n+            params: params.into_iter().collect()\n+        })\n+    }\n+\n+    pub fn maybe_new<I, E>(tcx: TyCtxt<'a, 'gcx, 'tcx>, params: I)\n+                           -> Result<&'tcx Substs<'tcx>, E>\n+    where I: IntoIterator<Item=Result<Kind<'tcx>, E>> {\n+        Ok(tcx.mk_substs(Substs {\n+            params: params.into_iter().collect::<Result<_, _>>()?\n+        }))\n     }\n \n     pub fn new_trait(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     mut t: Vec<Ty<'tcx>>,\n-                     r: Vec<ty::Region>,\n-                     s: Ty<'tcx>)\n+                     s: Ty<'tcx>,\n+                     t: &[Ty<'tcx>])\n                     -> &'tcx Substs<'tcx>\n     {\n-        t.insert(0, s);\n-        Substs::new(tcx, t, r)\n+        let t = iter::once(s).chain(t.iter().cloned());\n+        Substs::new(tcx, t.map(Kind::from))\n     }\n \n     pub fn empty(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n-        Substs::new(tcx, vec![], vec![])\n+        Substs::new(tcx, vec![])\n     }\n \n     /// Creates a Substs for generic parameter definitions,\n@@ -65,16 +178,13 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n-        let num_regions = defs.parent_regions as usize + defs.regions.len();\n-        let num_types = defs.parent_types as usize + defs.types.len();\n         let mut substs = Substs {\n-            regions: Vec::with_capacity(num_regions),\n-            types: Vec::with_capacity(num_types)\n+            params: Vec::with_capacity(defs.count())\n         };\n \n         substs.fill_item(tcx, defs, &mut mk_region, &mut mk_type);\n \n-        Substs::new(tcx, substs.types, substs.regions)\n+        tcx.mk_substs(substs)\n     }\n \n     fn fill_item<FR, FT>(&mut self,\n@@ -89,41 +199,59 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n             self.fill_item(tcx, parent_defs, mk_region, mk_type);\n         }\n \n+        // Handle Self first, before all regions.\n+        let mut types = defs.types.iter();\n+        if defs.parent.is_none() && defs.has_self {\n+            let def = types.next().unwrap();\n+            let ty = mk_type(def, self);\n+            assert_eq!(def.index as usize, self.params.len());\n+            self.params.push(Kind::from(ty));\n+        }\n+\n         for def in &defs.regions {\n             let region = mk_region(def, self);\n-            assert_eq!(def.index as usize, self.regions.len());\n-            self.regions.push(region);\n+            assert_eq!(def.index as usize, self.params.len());\n+            self.params.push(Kind::from(region));\n         }\n \n-        for def in &defs.types {\n+        for def in types {\n             let ty = mk_type(def, self);\n-            assert_eq!(def.index as usize, self.types.len());\n-            self.types.push(ty);\n+            assert_eq!(def.index as usize, self.params.len());\n+            self.params.push(Kind::from(ty));\n         }\n     }\n \n     pub fn is_noop(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n+        self.params.is_empty()\n     }\n \n     #[inline]\n-    pub fn types(&self) -> slice::Iter<Ty<'tcx>> {\n-        self.types.iter()\n+    pub fn params(&self) -> &[Kind<'tcx>] {\n+        &self.params\n     }\n \n     #[inline]\n-    pub fn regions(&self) -> slice::Iter<ty::Region> {\n-        self.regions.iter()\n+    pub fn types(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+        self.params.iter().filter_map(|k| k.as_type())\n+    }\n+\n+    #[inline]\n+    pub fn regions(&'a self) -> impl DoubleEndedIterator<Item=&'tcx ty::Region> + 'a {\n+        self.params.iter().filter_map(|k| k.as_region())\n     }\n \n     #[inline]\n     pub fn type_at(&self, i: usize) -> Ty<'tcx> {\n-        self.types[i]\n+        self.params[i].as_type().unwrap_or_else(|| {\n+            bug!(\"expected type for param #{} in {:?}\", i, self.params);\n+        })\n     }\n \n     #[inline]\n     pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n-        self.regions[i]\n+        self.params[i].as_region().unwrap_or_else(|| {\n+            bug!(\"expected region for param #{} in {:?}\", i, self.params);\n+        })\n     }\n \n     #[inline]\n@@ -146,27 +274,27 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                        target_substs: &Substs<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         let defs = tcx.lookup_generics(source_ancestor);\n-        let regions = target_substs.regions.iter()\n-            .chain(&self.regions[defs.regions.len()..]).cloned().collect();\n-        let types = target_substs.types.iter()\n-            .chain(&self.types[defs.types.len()..]).cloned().collect();\n-        Substs::new(tcx, types, regions)\n+        tcx.mk_substs(Substs {\n+            params: target_substs.params.iter()\n+                .chain(&self.params[defs.own_count()..]).cloned().collect()\n+        })\n     }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let types = self.types.fold_with(folder);\n-        let regions = self.regions.fold_with(folder);\n-        Substs::new(folder.tcx(), types, regions)\n+        let params = self.params.iter().map(|k| k.fold_with(folder)).collect();\n+        folder.tcx().mk_substs(Substs {\n+            params: params\n+        })\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_substs(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.types.visit_with(visitor) || self.regions.visit_with(visitor)\n+        self.params.visit_with(visitor)\n     }\n }\n \n@@ -263,8 +391,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         // the specialized routine `ty::replace_late_regions()`.\n         match *r {\n             ty::ReEarlyBound(data) => {\n-                match self.substs.regions.get(data.index as usize) {\n-                    Some(&r) => {\n+                let r = self.substs.params.get(data.index as usize)\n+                            .and_then(|k| k.as_region());\n+                match r {\n+                    Some(r) => {\n                         self.shift_region_through_binders(r)\n                     }\n                     None => {\n@@ -318,9 +448,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.get(p.idx as usize);\n+        let opt_ty = self.substs.params.get(p.idx as usize)\n+                         .and_then(|k| k.as_type());\n         let ty = match opt_ty {\n-            Some(t) => *t,\n+            Some(t) => t,\n             None => {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 span_bug!(\n@@ -331,7 +462,7 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n                     source_ty,\n                     p.idx,\n                     self.root_ty,\n-                    self.substs);\n+                    self.substs.params);\n             }\n         };\n \n@@ -407,12 +538,11 @@ impl<'a, 'gcx, 'tcx> ty::TraitRef<'tcx> {\n                        substs: &Substs<'tcx>)\n                        -> ty::TraitRef<'tcx> {\n         let defs = tcx.lookup_generics(trait_id);\n-        let regions = substs.regions[..defs.regions.len()].to_vec();\n-        let types = substs.types[..defs.types.len()].to_vec();\n \n+        let params = substs.params[..defs.own_count()].iter().cloned();\n         ty::TraitRef {\n             def_id: trait_id,\n-            substs: Substs::new(tcx, types, regions)\n+            substs: Substs::new(tcx, params)\n         }\n     }\n }\n@@ -421,13 +551,13 @@ impl<'a, 'gcx, 'tcx> ty::ExistentialTraitRef<'tcx> {\n     pub fn erase_self_ty(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          trait_ref: ty::TraitRef<'tcx>)\n                          -> ty::ExistentialTraitRef<'tcx> {\n-        let Substs { mut types, regions } = trait_ref.substs.clone();\n-\n-        types.remove(0);\n+        // Assert there is a Self.\n+        trait_ref.substs.type_at(0);\n \n+        let params = trait_ref.substs.params[1..].iter().cloned();\n         ty::ExistentialTraitRef {\n             def_id: trait_ref.def_id,\n-            substs: Substs::new(tcx, types, regions)\n+            substs: Substs::new(tcx, params)\n         }\n     }\n }\n@@ -444,13 +574,11 @@ impl<'a, 'gcx, 'tcx> ty::PolyExistentialTraitRef<'tcx> {\n         assert!(!self_ty.has_escaping_regions());\n \n         self.map_bound(|trait_ref| {\n-            let Substs { mut types, regions } = trait_ref.substs.clone();\n-\n-            types.insert(0, self_ty);\n-\n+            let params = trait_ref.substs.params.iter().cloned();\n+            let params = iter::once(Kind::from(self_ty)).chain(params);\n             ty::TraitRef {\n                 def_id: trait_ref.def_id,\n-                substs: Substs::new(tcx, types, regions)\n+                substs: Substs::new(tcx, params)\n             }\n         })\n     }"}, {"sha": "dd5c6a9758abf263d49b0960d8b684932b141d56", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -693,7 +693,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                         return false;\n                     }\n \n-                    substs_a.types().zip(substs_b.types()).all(|(&a, &b)| same_type(a, b))\n+                    substs_a.types().zip(substs_b.types()).all(|(a, b)| same_type(a, b))\n                 }\n                 _ => {\n                     a == b"}, {"sha": "409f5a85997bda10eb0fff2eb5b76b28862d6a61", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -67,6 +67,12 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n     stack.into_iter()\n }\n \n+// We push types on the stack in reverse order so as to\n+// maintain a pre-order traversal. As of the time of this\n+// writing, the fact that the traversal is pre-order is not\n+// known to be significant to any code, but it seems like the\n+// natural order one would expect (basically, the order of the\n+// types as they are written).\n fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n@@ -79,28 +85,28 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             stack.push(mt.ty);\n         }\n         ty::TyProjection(ref data) => {\n-            push_reversed(stack, data.trait_ref.substs.types());\n+            stack.extend(data.trait_ref.substs.types().rev());\n         }\n         ty::TyTrait(ref obj) => {\n-            push_reversed(stack, obj.principal.input_types());\n-            push_reversed(stack, &obj.projection_bounds.iter().map(|pred| {\n+            stack.extend(obj.principal.input_types().rev());\n+            stack.extend(obj.projection_bounds.iter().map(|pred| {\n                 pred.0.ty\n-            }).collect::<Vec<_>>());\n+            }).rev());\n         }\n         ty::TyEnum(_, ref substs) |\n         ty::TyStruct(_, ref substs) |\n         ty::TyAnon(_, ref substs) => {\n-            push_reversed(stack, substs.types());\n+            stack.extend(substs.types().rev());\n         }\n         ty::TyClosure(_, ref substs) => {\n-            push_reversed(stack, substs.func_substs.types());\n-            push_reversed(stack, substs.upvar_tys);\n+            stack.extend(substs.func_substs.types().rev());\n+            stack.extend(substs.upvar_tys.iter().cloned().rev());\n         }\n         ty::TyTuple(ts) => {\n-            push_reversed(stack, ts);\n+            stack.extend(ts.iter().cloned().rev());\n         }\n         ty::TyFnDef(_, substs, ref ft) => {\n-            push_reversed(stack, substs.types());\n+            stack.extend(substs.types().rev());\n             push_sig_subtypes(stack, &ft.sig);\n         }\n         ty::TyFnPtr(ref ft) => {\n@@ -111,20 +117,5 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n \n fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n     stack.push(sig.0.output);\n-    push_reversed(stack, &sig.0.inputs);\n-}\n-\n-fn push_reversed<'a, 'tcx: 'a, I>(stack: &mut Vec<Ty<'tcx>>, tys: I)\n-    where I: IntoIterator<Item=&'a Ty<'tcx>>,\n-          I::IntoIter: DoubleEndedIterator\n-{\n-    // We push slices on the stack in reverse order so as to\n-    // maintain a pre-order traversal. As of the time of this\n-    // writing, the fact that the traversal is pre-order is not\n-    // known to be significant to any code, but it seems like the\n-    // natural order one would expect (basically, the order of the\n-    // types as they are written).\n-    for &ty in tys.into_iter().rev() {\n-        stack.push(ty);\n-    }\n+    stack.extend(sig.0.inputs.iter().cloned().rev());\n }"}, {"sha": "24b68c66e46673d3934f33227212987a1a66bf22", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -143,14 +143,14 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         }\n     };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, regions| {\n+    let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n         // Don't print any regions if they're all erased.\n-        if Iterator::all(&mut Clone::clone(&regions),\n-                         |r: &ty::Region| *r == ty::ReErased) {\n+        let regions = || substs.regions().skip(skip).take(count);\n+        if regions().all(|r: &ty::Region| *r == ty::ReErased) {\n             return Ok(());\n         }\n \n-        for region in regions {\n+        for region in regions() {\n             let region: &ty::Region = region;\n             start_or_continue(f, start, \", \")?;\n             if verbose {\n@@ -173,12 +173,12 @@ pub fn parameterized(f: &mut fmt::Formatter,\n         Ok(())\n     };\n \n-    print_regions(f, \"<\", substs.regions().take(num_regions).skip(0))?;\n+    print_regions(f, \"<\", 0, num_regions)?;\n \n     let tps = substs.types().take(num_types - num_supplied_defaults)\n                             .skip(has_self as usize);\n \n-    for &ty in tps {\n+    for ty in tps {\n         start_or_continue(f, \"<\", \", \")?;\n         write!(f, \"{}\", ty)?;\n     }\n@@ -204,7 +204,7 @@ pub fn parameterized(f: &mut fmt::Formatter,\n             write!(f, \"::{}\", item_name)?;\n         }\n \n-        print_regions(f, \"::<\", substs.regions().take(usize::MAX).skip(num_regions))?;\n+        print_regions(f, \"::<\", num_regions, usize::MAX)?;\n \n         // FIXME: consider being smart with defaults here too\n         for ty in substs.types().skip(num_types) {\n@@ -655,13 +655,6 @@ impl fmt::Debug for ty::Variance {\n     }\n }\n \n-impl fmt::Debug for ty::ItemVariances {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ItemVariances(types={:?}, regions={:?})\",\n-               self.types, self.regions)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"GenericPredicates({:?})\", self.predicates)"}, {"sha": "3ff2fb8e2e527bc504e1aa6b5e8ca344ab6bc521", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -16,7 +16,7 @@ use super::{drop_flag_effects_for_location, on_all_children_bits};\n use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::mir::repr::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n use rustc::middle::const_val::ConstVal;\n@@ -26,6 +26,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n \n use std::fmt;\n+use std::iter;\n use std::u32;\n \n pub struct ElaborateDrops;\n@@ -859,7 +860,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let unit_temp = Lvalue::Temp(self.patch.new_temp(tcx.mk_nil()));\n         let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n             .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-        let substs = Substs::new(tcx, vec![ty], vec![]);\n+        let substs = Substs::new(tcx, iter::once(Kind::from(ty)));\n         let fty = tcx.lookup_item_type(free_func).ty.subst(tcx, substs);\n \n         self.patch.new_block(BasicBlockData {"}, {"sha": "460a6e68a5c5a20f4c4af373c67fdc40c80f8279", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -20,13 +20,14 @@ use rustc::middle::region::{self, CodeExtent};\n use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n+use std::iter;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -676,7 +677,7 @@ fn subst_ty_renumber_bound() {\n             env.t_fn(&[t_param], env.t_nil())\n         };\n \n-        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let substs = Substs::new(env.infcx.tcx, iter::once(Kind::from(t_rptr_bound1)));\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)\n@@ -711,7 +712,7 @@ fn subst_ty_renumber_some_bounds() {\n             env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n         };\n \n-        let substs = Substs::new(env.infcx.tcx, vec![t_rptr_bound1], vec![]);\n+        let substs = Substs::new(env.infcx.tcx, iter::once(Kind::from(t_rptr_bound1)));\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = (&'a isize, fn(&'a isize))\n@@ -773,7 +774,7 @@ fn subst_region_renumber_region() {\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n         };\n \n-        let substs = Substs::new(env.infcx.tcx, vec![], vec![re_bound1]);\n+        let substs = Substs::new(env.infcx.tcx, iter::once(Kind::from(re_bound1)));\n         let t_substituted = t_source.subst(env.infcx.tcx, substs);\n \n         // t_expected = fn(&'a isize)"}, {"sha": "0fd7b683067b7441798446c8b5ad19c25c2c4307", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::closure_ty(&cdata, def_id.index, tcx)\n     }\n \n-    fn item_variances(&self, def: DefId) -> ty::ItemVariances {\n+    fn item_variances(&self, def: DefId) -> Vec<ty::Variance> {\n         self.dep_graph.read(DepNode::MetaData(def));\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_item_variances(&cdata, def.index)"}, {"sha": "bbda089b1c2a8da13bddb647af1f1f8be237df47", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -991,7 +991,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: DefIndex)\n     }).collect()\n }\n \n-pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n+pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> Vec<ty::Variance> {\n     let item_doc = cdata.lookup_item(id);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder::new(variance_doc);"}, {"sha": "f51299226fe7da904ff2f689e194d4eb8ad36cd6", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -20,7 +20,7 @@ use rustc::hir;\n \n use rustc::hir::def_id::{DefId, DefIndex};\n use middle::region;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n@@ -129,19 +129,19 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n-        let mut regions = vec![];\n-        let mut types = vec![];\n+        let mut params = vec![];\n         assert_eq!(self.next(), '[');\n-        while self.peek() != '|' {\n-            regions.push(self.parse_region());\n-        }\n-        assert_eq!(self.next(), '|');\n         while self.peek() != ']' {\n-            types.push(self.parse_ty());\n+            let k = match self.next() {\n+                'r' => Kind::from(self.parse_region()),\n+                't' => Kind::from(self.parse_ty()),\n+                _ => bug!()\n+            };\n+            params.push(k);\n         }\n         assert_eq!(self.next(), ']');\n \n-        Substs::new(self.tcx, types, regions)\n+        Substs::new(self.tcx, params)\n     }\n \n     pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {"}, {"sha": "7255eae61d4533cd75b205caae28b6f7f256e121", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -251,12 +251,16 @@ fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                             substs: &Substs<'tcx>) {\n     write!(w, \"[\");\n-    for &r in substs.regions() {\n-        enc_region(w, cx, r);\n-    }\n-    write!(w, \"|\");\n-    for &ty in substs.types() {\n-        enc_ty(w, cx, ty);\n+    for &k in substs.params() {\n+        if let Some(ty) = k.as_type() {\n+            write!(w, \"t\");\n+            enc_ty(w, cx, ty);\n+        } else if let Some(r) = k.as_region() {\n+            write!(w, \"r\");\n+            enc_region(w, cx, r);\n+        } else {\n+            bug!()\n+        }\n     }\n     write!(w, \"]\");\n }"}, {"sha": "bf43bfb326a581a3bc7980776e9977264e639acc", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     assert!(ty.is_slice());\n                     let eq_def_id = self.hir.tcx().lang_items.eq_trait().unwrap();\n                     let ty = mt.ty;\n-                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, vec![ty]);\n+                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n \n                     let bool_ty = self.hir.bool_ty();\n                     let eq_result = self.temp(bool_ty);"}, {"sha": "0b33e5a145083fabc58475ea20d0f153480413cb", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -89,13 +89,15 @@ should go to.\n use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary, ScopeId};\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n use rustc::middle::lang_items;\n-use rustc::ty::subst::{Substs, Subst};\n+use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc::ty::{Ty, TyCtxt};\n use rustc::mir::repr::*;\n use syntax_pos::Span;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::fnv::FnvHashMap;\n \n+use std::iter;\n+\n pub struct Scope<'tcx> {\n     /// the scope-id within the scope_auxiliary\n     id: ScopeId,\n@@ -789,7 +791,7 @@ fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n-    let substs = Substs::new(tcx, vec![data.item_ty], vec![]);\n+    let substs = Substs::new(tcx, iter::once(Kind::from(data.item_ty)));\n     TerminatorKind::Call {\n         func: Operand::Constant(Constant {\n             span: data.span,"}, {"sha": "a38b429333b70f643aec7a315fb16f3d4d294b5b", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -144,10 +144,10 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         trait_def_id: DefId,\n                         method_name: &str,\n                         self_ty: Ty<'tcx>,\n-                        params: Vec<Ty<'tcx>>)\n+                        params: &[Ty<'tcx>])\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n         let method_name = token::intern(method_name);\n-        let substs = Substs::new_trait(self.tcx, params, vec![], self_ty);\n+        let substs = Substs::new_trait(self.tcx, self_ty, params);\n         for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n             match *trait_item {\n                 ty::ImplOrTraitItem::MethodTraitItem(ref method) => {"}, {"sha": "5e431193a2c4cac96366bd61e1376b283a01b573", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -514,7 +514,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n                                              -> CustomCoerceUnsized {\n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: scx.tcx().lang_items.coerce_unsized_trait().unwrap(),\n-        substs: Substs::new_trait(scx.tcx(), vec![target_ty], vec![], source_ty)\n+        substs: Substs::new_trait(scx.tcx(), source_ty, &[target_ty])\n     });\n \n     match fulfill_obligation(scx, DUMMY_SP, trait_ref) {"}, {"sha": "8dd76535cf811db899d663667380e20bffe4c6eb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -753,7 +753,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    .drop_trait()\n                                    .unwrap();\n \n-        let self_type_substs = Substs::new_trait(scx.tcx(), vec![], vec![], ty);\n+        let self_type_substs = Substs::new_trait(scx.tcx(), ty, &[]);\n \n         let trait_ref = ty::TraitRef {\n             def_id: drop_trait_def_id,"}, {"sha": "67d4a0e044c9c8ac7d7b6594255269615a3ba6c5", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -345,7 +345,7 @@ impl<'tcx> TypeMap<'tcx> {\n             if substs.types().next().is_some() {\n                 output.push('<');\n \n-                for &type_parameter in substs.types() {\n+                for type_parameter in substs.types() {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id ="}, {"sha": "4d8a9a2ac40d7a8a9f65b9f38262823f9933f886", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -354,7 +354,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n \n         name_to_append_suffix_to.push('<');\n-        for (i, &actual_type) in substs.types().enumerate() {\n+        for (i, actual_type) in substs.types().enumerate() {\n             if i != 0 {\n                 name_to_append_suffix_to.push_str(\",\");\n             }\n@@ -372,7 +372,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let template_params: Vec<_> = if cx.sess().opts.debuginfo == FullDebugInfo {\n             let names = get_type_parameter_names(cx, generics);\n             substs.types().zip(names).map(|(ty, name)| {\n-                let actual_type = cx.tcx().normalize_associated_type(ty);\n+                let actual_type = cx.tcx().normalize_associated_type(&ty);\n                 let actual_type_metadata = type_metadata(cx, actual_type, syntax_pos::DUMMY_SP);\n                 let name = CString::new(name.as_str().as_bytes()).unwrap();\n                 unsafe {"}, {"sha": "f757578e6954def808863c0a174668972d89c17b", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -181,7 +181,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         output.push('<');\n \n-        for &type_parameter in substs.types() {\n+        for type_parameter in substs.types() {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }"}, {"sha": "f29d85f3b52f06aff255178a7c35db4e72902d86", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -302,7 +302,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let trait_ref = ty::Binder(ty::TraitRef {\n         def_id: tcx.lang_items.drop_trait().unwrap(),\n-        substs: Substs::new_trait(tcx, vec![], vec![], t)\n+        substs: Substs::new_trait(tcx, t, &[])\n     });\n     let vtbl = match fulfill_obligation(bcx.ccx().shared(), DUMMY_SP, trait_ref) {\n         traits::VtableImpl(data) => data,"}, {"sha": "2c91c408487b8513319d06b163be261fcfda2887", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -541,7 +541,7 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     output.push('<');\n \n-    for &type_parameter in substs.types() {\n+    for type_parameter in substs.types() {\n         push_unique_type_name(tcx, type_parameter, output);\n         output.push_str(\", \");\n     }"}, {"sha": "f24a7cf2121ebe7ab67c22e508b9ec3885d8a014", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -473,7 +473,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n-            tcx.mk_region(regions[def.index as usize])\n+            let i = def.index as usize - self_ty.is_some() as usize;\n+            tcx.mk_region(regions[i])\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -482,7 +483,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 return ty;\n             }\n \n-            let i = i - self_ty.is_some() as usize;\n+            let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n             if num_types_provided.map_or(false, |n| i < n) {\n                 // A provided type parameter.\n                 match *parameters {"}, {"sha": "19261a2447f9100ed8b7dee42319073e7ad4fdc0", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                 Some(f) => f,\n                 None => return None\n             },\n-            substs: Substs::new_trait(tcx, vec![], vec![], self.cur_ty)\n+            substs: Substs::new_trait(tcx, self.cur_ty, &[])\n         };\n \n         let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);"}, {"sha": "26a47055289761b72500e2f96258e74d5f1445c8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -458,7 +458,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                                          coerce_unsized_did,\n                                                          0,\n                                                          source,\n-                                                         vec![target]));\n+                                                         &[target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where"}, {"sha": "be77ca435a18c8f27e580abf1c6c94709c52d599", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -327,21 +327,22 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         //\n         // FIXME -- permit users to manually specify lifetimes\n+        let supplied_start = substs.params().len() + method.generics.regions.len();\n         Substs::for_item(self.tcx, method.def_id, |def, _| {\n             let i = def.index as usize;\n-            if i < substs.regions().count() {\n+            if i < substs.params().len() {\n                 substs.region_at(i)\n             } else {\n                 self.region_var_for_def(self.span, def)\n             }\n         }, |def, cur_substs| {\n             let i = def.index as usize;\n-            if i < substs.types().count() {\n+            if i < substs.params().len() {\n                 substs.type_at(i)\n             } else if supplied_method_types.is_empty() {\n                 self.type_var_for_def(self.span, def, cur_substs)\n             } else {\n-                supplied_method_types[i - substs.types().count()]\n+                supplied_method_types[i - supplied_start]\n             }\n         })\n     }"}, {"sha": "a64982cd1bf819efb9ad8960abb7bd9cfe531e3b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -1237,7 +1237,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         } else {\n             let substs = Substs::for_item(self.tcx, method.def_id, |def, _| {\n                 let i = def.index as usize;\n-                if i < substs.regions().count() {\n+                if i < substs.params().len() {\n                     substs.region_at(i)\n                 } else {\n                     // In general, during probe we erase regions. See\n@@ -1246,7 +1246,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 }\n             }, |def, cur_substs| {\n                 let i = def.index as usize;\n-                if i < substs.types().count() {\n+                if i < substs.params().len() {\n                     substs.type_at(i)\n                 } else {\n                     self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "f9699a55f50687e601c783e7ebd6972ca908efb2", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -54,7 +54,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n                     let fn_once_substs =\n-                        Substs::new_trait(tcx, vec![self.next_ty_var()], vec![], ty);\n+                        Substs::new_trait(tcx, ty, &[self.next_ty_var()]);\n                     let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                     let obligation = Obligation::misc(span,"}, {"sha": "e972a5ca7fb3894848b2816b77f880e624d6a935", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -770,7 +770,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       }\n       hir::ItemTy(_, ref generics) => {\n         let pty_ty = ccx.tcx.node_id_to_type(it.id);\n-        check_bounds_are_used(ccx, &generics.ty_params, pty_ty);\n+        check_bounds_are_used(ccx, generics, pty_ty);\n       }\n       hir::ItemForeignMod(ref m) => {\n         if m.abi == Abi::RustIntrinsic {\n@@ -1899,7 +1899,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Registers obligations that all types appearing in `substs` are well-formed.\n     pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &hir::Expr)\n     {\n-        for &ty in substs.types() {\n+        for ty in substs.types() {\n             self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n     }\n@@ -4242,18 +4242,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_path_parameter_count(span, !require_type_space, &mut type_segment);\n         self.check_path_parameter_count(span, true, &mut fn_segment);\n \n+        let (fn_start, has_self) = match (type_segment, fn_segment) {\n+            (_, Some((_, generics))) => {\n+                (generics.parent_count(), generics.has_self)\n+            }\n+            (Some((_, generics)), None) => {\n+                (generics.own_count(), generics.has_self)\n+            }\n+            (None, None) => (0, false)\n+        };\n         let substs = Substs::for_item(self.tcx, def.def_id(), |def, _| {\n             let mut i = def.index as usize;\n-            let type_regions = match (type_segment, fn_segment) {\n-                (_, Some((_, generics))) => generics.parent_regions as usize,\n-                (Some((_, generics)), None) => generics.regions.len(),\n-                (None, None) => 0\n-            };\n \n-            let segment = if i < type_regions {\n+            let segment = if i < fn_start {\n+                i -= has_self as usize;\n                 type_segment\n             } else {\n-                i -= type_regions;\n+                i -= fn_start;\n                 fn_segment\n             };\n             let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n@@ -4269,18 +4274,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }, |def, substs| {\n             let mut i = def.index as usize;\n-            let (type_types, has_self) = match (type_segment, fn_segment) {\n-                (_, Some((_, generics))) => {\n-                    (generics.parent_types as usize, generics.has_self)\n-                }\n-                (Some((_, generics)), None) => {\n-                    (generics.types.len(), generics.has_self)\n-                }\n-                (None, None) => (0, false)\n-            };\n \n-            let can_omit = i >= type_types || !require_type_space;\n-            let segment = if i < type_types {\n+            let can_omit = i >= fn_start || !require_type_space;\n+            let segment = if i < fn_start {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n                     return opt_self_ty.unwrap_or_else(|| {\n@@ -4290,7 +4286,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= has_self as usize;\n                 type_segment\n             } else {\n-                i -= type_types;\n+                i -= fn_start;\n                 fn_segment\n             };\n             let types = match segment.map(|(s, _)| &s.parameters) {\n@@ -4299,6 +4295,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 None => &[]\n             };\n \n+            // Skip over the lifetimes in the same segment.\n+            if let Some((_, generics)) = segment {\n+                i -= generics.regions.len();\n+            }\n+\n             let omitted = can_omit && types.is_empty();\n             if let Some(ast_ty) = types.get(i) {\n                 // A provided type parameter.\n@@ -4502,28 +4503,28 @@ pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n }\n \n pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                       tps: &[hir::TyParam],\n+                                       generics: &hir::Generics,\n                                        ty: Ty<'tcx>) {\n     debug!(\"check_bounds_are_used(n_tps={}, ty={:?})\",\n-           tps.len(),  ty);\n+           generics.ty_params.len(),  ty);\n \n     // make a vector of booleans initially false, set to true when used\n-    if tps.is_empty() { return; }\n-    let mut tps_used = vec![false; tps.len()];\n+    if generics.ty_params.is_empty() { return; }\n+    let mut tps_used = vec![false; generics.ty_params.len()];\n \n     for leaf_ty in ty.walk() {\n         if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n-            tps_used[idx as usize] = true;\n+            tps_used[idx as usize - generics.lifetimes.len()] = true;\n         }\n     }\n \n-    for (i, b) in tps_used.iter().enumerate() {\n-        if !*b {\n-            struct_span_err!(ccx.tcx.sess, tps[i].span, E0091,\n+    for (&used, param) in tps_used.iter().zip(&generics.ty_params) {\n+        if !used {\n+            struct_span_err!(ccx.tcx.sess, param.span, E0091,\n                 \"type parameter `{}` is unused\",\n-                tps[i].name)\n-                .span_label(tps[i].span, &format!(\"unused type parameter\"))\n+                param.name)\n+                .span_label(param.span, &format!(\"unused type parameter\"))\n                 .emit();\n         }\n     }"}, {"sha": "cef2bb07e35ca065991bf0dd4f2f8ee08b0d9358", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -1447,11 +1447,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let origin = infer::ParameterInScope(origin, expr_span);\n \n-        for &region in substs.regions() {\n+        for region in substs.regions() {\n             self.sub_regions(origin.clone(), expr_region, region);\n         }\n \n-        for &ty in substs.types() {\n+        for ty in substs.types() {\n             let ty = self.resolve_type(ty);\n             self.type_must_outlive(origin.clone(), ty, expr_region);\n         }\n@@ -1577,11 +1577,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if env_bounds.is_empty() && needs_infer {\n             debug!(\"projection_must_outlive: no declared bounds\");\n \n-            for &component_ty in projection_ty.trait_ref.substs.types() {\n+            for component_ty in projection_ty.trait_ref.substs.types() {\n                 self.type_must_outlive(origin.clone(), component_ty, region);\n             }\n \n-            for &r in projection_ty.trait_ref.substs.regions() {\n+            for r in projection_ty.trait_ref.substs.regions() {\n                 self.sub_regions(origin.clone(), region, r);\n             }\n "}, {"sha": "38ec7ba686f6f5e1b60372fd4af297510e2f8daa", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -457,7 +457,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         let variances = self.tcx().item_variances(item_def_id);\n \n         let mut constrained_parameters: HashSet<_> =\n-            variances.types\n+            variances[ast_generics.lifetimes.len()..]\n                      .iter().enumerate()\n                      .filter(|&(_, &variance)| variance != ty::Bivariant)\n                      .map(|(index, _)| self.param_ty(ast_generics, index))\n@@ -468,22 +468,22 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                                          None,\n                                          &mut constrained_parameters);\n \n-        for (index, _) in variances.types.iter().enumerate() {\n-            let param_ty = self.param_ty(ast_generics, index);\n-            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n-                continue;\n-            }\n-            let span = ast_generics.ty_params[index].span;\n-            self.report_bivariance(span, param_ty.name);\n-        }\n-\n-        for (index, &variance) in variances.regions.iter().enumerate() {\n-            if variance != ty::Bivariant {\n-                continue;\n-            }\n+        for (index, &variance) in variances.iter().enumerate() {\n+            let (span, name) = if index < ast_generics.lifetimes.len() {\n+                if variance != ty::Bivariant {\n+                    continue;\n+                }\n \n-            let span = ast_generics.lifetimes[index].lifetime.span;\n-            let name = ast_generics.lifetimes[index].lifetime.name;\n+                (ast_generics.lifetimes[index].lifetime.span,\n+                 ast_generics.lifetimes[index].lifetime.name)\n+            } else {\n+                let index = index - ast_generics.lifetimes.len();\n+                let param_ty = self.param_ty(ast_generics, index);\n+                if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n+                    continue;\n+                }\n+                (ast_generics.ty_params[index].span, param_ty.name)\n+            };\n             self.report_bivariance(span, name);\n         }\n     }\n@@ -597,7 +597,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n                 let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n-                trait_ref.substs.types().cloned().collect()\n+                trait_ref.substs.types().collect()\n             }\n \n             None => {"}, {"sha": "3bd0e890bb8119fd4e8bf5196145d9185f1c47a6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -104,7 +104,12 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n         let gcx = fcx.tcx.global_tcx();\n         let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, r) in free_substs.regions().enumerate() {\n+        for (i, k) in free_substs.params().iter().enumerate() {\n+            let r = if let Some(r) = k.as_region() {\n+                r\n+            } else {\n+                continue;\n+            };\n             match *r {\n                 ty::ReFree(ty::FreeRegion {\n                     bound_region: ty::BoundRegion::BrNamed(def_id, name, _), .."}, {"sha": "7d6cee7b3bac16767e64d653f5a727b166f22061", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 // Register an obligation for `A: Trait<B>`.\n                 let cause = traits::ObligationCause::misc(span, impl_node_id);\n                 let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n-                                                            source, vec![target]);\n+                                                            source, &[target]);\n                 fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n                 // Check that all transitive obligations are satisfied."}, {"sha": "0074d3930e29f66402855d86f1df085f2ffa56c0", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -1486,31 +1486,34 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         let has_self = opt_self.is_some();\n         let mut parent_has_self = false;\n+        let mut own_start = has_self as u32;\n         let (parent_regions, parent_types) = parent_def_id.map_or((0, 0), |def_id| {\n             let generics = generics_of_def_id(ccx, def_id);\n             assert_eq!(generics.parent, None);\n             assert_eq!(generics.parent_regions, 0);\n             assert_eq!(generics.parent_types, 0);\n             assert_eq!(has_self, false);\n             parent_has_self = generics.has_self;\n+            own_start = generics.count() as u32;\n             (generics.regions.len() as u32, generics.types.len() as u32)\n         });\n \n         let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n         let regions = early_lifetimes.iter().enumerate().map(|(i, l)| {\n             ty::RegionParameterDef {\n                 name: l.lifetime.name,\n-                index: parent_regions + i as u32,\n+                index: own_start + i as u32,\n                 def_id: tcx.map.local_def_id(l.lifetime.id),\n                 bounds: l.bounds.iter().map(|l| {\n                     ast_region_to_region(tcx, l)\n                 }).collect()\n             }\n-        }).collect();\n+        }).collect::<Vec<_>>();\n \n         // Now create the real type parameters.\n+        let type_start = own_start + regions.len() as u32;\n         let types = ast_generics.ty_params.iter().enumerate().map(|(i, p)| {\n-            let i = parent_types + has_self as u32 + i as u32;\n+            let i = type_start + i as u32;\n             get_or_create_type_parameter_def(ccx, ast_generics, i, p, allow_defaults)\n         });\n         let types: Vec<_> = opt_self.into_iter().chain(types).collect();\n@@ -1529,8 +1532,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         tcx.alloc_generics(ty::Generics {\n             parent: parent_def_id,\n-            parent_regions: parent_regions as u32,\n-            parent_types: parent_types as u32,\n+            parent_regions: parent_regions,\n+            parent_types: parent_types,\n             regions: regions,\n             types: types,\n             has_self: has_self || parent_has_self\n@@ -1741,12 +1744,12 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                   -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let (parent_regions, parent_types) = parent.map_or((0, 0), |def_id| {\n+    let parent_count = parent.map_or(0, |def_id| {\n         let generics = generics_of_def_id(ccx, def_id);\n         assert_eq!(generics.parent, None);\n         assert_eq!(generics.parent_regions, 0);\n         assert_eq!(generics.parent_types, 0);\n-        (generics.regions.len() as u32, generics.types.len() as u32)\n+        generics.count() as u32\n     });\n     let ref base_predicates = match parent {\n         Some(def_id) => {\n@@ -1762,10 +1765,29 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     };\n     let mut predicates = super_predicates;\n \n+    // Collect the region predicates that were declared inline as\n+    // well. In the case of parameters declared on a fn or method, we\n+    // have to be careful to only iterate over early-bound regions.\n+    let own_start = parent_count + has_self as u32;\n+    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n+    for (index, param) in early_lifetimes.iter().enumerate() {\n+        let index = own_start + index as u32;\n+        let region = ccx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            index: index,\n+            name: param.lifetime.name\n+        }));\n+        for bound in &param.bounds {\n+            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n+            predicates.push(outlives.to_predicate());\n+        }\n+    }\n+\n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T:Foo>`).\n+    let type_start = own_start + early_lifetimes.len() as u32;\n     for (index, param) in ast_generics.ty_params.iter().enumerate() {\n-        let index = parent_types + has_self as u32 + index as u32;\n+        let index = type_start + index as u32;\n         let param_ty = ty::ParamTy::new(index, param.name).to_ty(ccx.tcx);\n         let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n                                     param_ty,\n@@ -1776,24 +1798,6 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         predicates.extend(bounds.predicates(ccx.tcx, param_ty));\n     }\n \n-    // Collect the region predicates that were declared inline as\n-    // well. In the case of parameters declared on a fn or method, we\n-    // have to be careful to only iterate over early-bound regions.\n-    let early_lifetimes = early_bound_lifetimes_from_generics(ccx, ast_generics);\n-    for (index, param) in early_lifetimes.iter().enumerate() {\n-        let index = parent_regions + index as u32;\n-        let region =\n-            ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                index: index,\n-                name: param.lifetime.name\n-            });\n-        for bound in &param.bounds {\n-            let bound_region = ast_region_to_region(ccx.tcx, bound);\n-            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n-            predicates.push(outlives.to_predicate());\n-        }\n-    }\n-\n     // Add in the bounds that appear in the where-clause\n     let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {"}, {"sha": "2cf84b5745af4a0ec0c2e25fd4a84794a473407e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -26,7 +26,6 @@ use rustc::hir::intravisit::Visitor;\n \n use super::terms::*;\n use super::terms::VarianceTerm::*;\n-use super::terms::ParamKind::*;\n use super::xform::*;\n \n pub struct ConstraintContext<'a, 'tcx: 'a> {\n@@ -209,7 +208,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn declared_variance(&self,\n                          param_def_id: DefId,\n                          item_def_id: DefId,\n-                         kind: ParamKind,\n                          index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n@@ -224,11 +222,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n             let variances = self.tcx().item_variances(item_def_id);\n-            let variance = match kind {\n-                TypeParam => variances.types[index],\n-                RegionParam => variances.regions[index],\n-            };\n-            self.constant_term(variance)\n+            self.constant_term(variances[index])\n         }\n     }\n \n@@ -330,7 +324,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyRef(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(generics, *region, contra);\n+                self.add_constraints_from_region(generics, region, contra);\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n@@ -401,8 +395,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyParam(ref data) => {\n                 assert_eq!(generics.parent, None);\n-                assert!((data.idx as usize) < generics.types.len());\n-                let def_id = generics.types[data.idx as usize].def_id;\n+                let mut i = data.idx as usize;\n+                if !generics.has_self || i > 0 {\n+                    i -= generics.regions.len();\n+                }\n+                let def_id = generics.types[i].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 match self.terms_cx.inferred_map.get(&node_id) {\n                     Some(&index) => {\n@@ -449,7 +446,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in type_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, TypeParam, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n@@ -459,7 +456,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         for p in region_param_defs {\n             let variance_decl =\n-                self.declared_variance(p.def_id, def_id, RegionParam, p.index as usize);\n+                self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n@@ -488,8 +485,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n                 assert_eq!(generics.parent, None);\n-                assert!((data.index as usize) < generics.regions.len());\n-                let def_id = generics.regions[data.index as usize].def_id;\n+                let i = data.index as usize - generics.has_self as usize;\n+                let def_id = generics.regions[i].def_id;\n                 let node_id = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 if self.is_to_be_inferred(node_id) {\n                     let index = self.inferred_index(node_id);"}, {"sha": "82b63d0cc09377fd015c9bbeb9d6a755ed4689b6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -21,7 +21,6 @@ use std::rc::Rc;\n use super::constraints::*;\n use super::terms::*;\n use super::terms::VarianceTerm::*;\n-use super::terms::ParamKind::*;\n use super::xform::*;\n \n struct SolveContext<'a, 'tcx: 'a> {\n@@ -109,24 +108,16 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         while index < num_inferred {\n             let item_id = inferred_infos[index].item_id;\n \n-            let mut item_variances = ty::ItemVariances::empty();\n+            let mut item_variances = vec![];\n \n             while index < num_inferred && inferred_infos[index].item_id == item_id {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n-                debug!(\"Index {} Info {} / {:?} Variance {:?}\",\n-                       index, info.index, info.kind, variance);\n-                match info.kind {\n-                    TypeParam => {\n-                        assert_eq!(item_variances.types.len(), info.index);\n-                        item_variances.types.push(variance);\n-                    }\n-                    RegionParam => {\n-                        assert_eq!(item_variances.regions.len(), info.index);\n-                        item_variances.regions.push(variance);\n-                    }\n-                }\n+                debug!(\"Index {} Info {} Variance {:?}\",\n+                       index, info.index, variance);\n \n+                assert_eq!(item_variances.len(), info.index);\n+                item_variances.push(variance);\n                 index += 1;\n             }\n "}, {"sha": "c0b53787177d5ff9e0e175506de66d525aa3f93d", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -31,7 +31,6 @@ use rustc::hir::intravisit::Visitor;\n use util::nodemap::NodeMap;\n \n use self::VarianceTerm::*;\n-use self::ParamKind::*;\n \n pub type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n@@ -61,7 +60,7 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n-    pub empty_variances: Rc<ty::ItemVariances>,\n+    pub empty_variances: Rc<Vec<ty::Variance>>,\n \n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n@@ -76,15 +75,8 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum ParamKind {\n-    TypeParam,\n-    RegionParam,\n-}\n-\n pub struct InferredInfo<'a> {\n     pub item_id: ast::NodeId,\n-    pub kind: ParamKind,\n     pub index: usize,\n     pub param_id: ast::NodeId,\n     pub term: VarianceTermPtr<'a>,\n@@ -110,7 +102,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n-        empty_variances: Rc::new(ty::ItemVariances::empty())\n+        empty_variances: Rc::new(vec![])\n     };\n \n     // See README.md for a discussion on dep-graph management.\n@@ -162,17 +154,19 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         let inferreds_on_entry = self.num_inferred();\n \n+        if has_self {\n+            self.add_inferred(item_id, 0, item_id);\n+        }\n+\n         for (i, p) in generics.lifetimes.iter().enumerate() {\n             let id = p.lifetime.id;\n-            self.add_inferred(item_id, RegionParam, i, id);\n+            let i = has_self as usize + i;\n+            self.add_inferred(item_id, i, id);\n         }\n \n-        if has_self {\n-            self.add_inferred(item_id, TypeParam, 0, item_id);\n-        }\n         for (i, p) in generics.ty_params.iter().enumerate() {\n-            let i = has_self as usize + i;\n-            self.add_inferred(item_id, TypeParam, i, p.id);\n+            let i = has_self as usize + generics.lifetimes.len() + i;\n+            self.add_inferred(item_id, i, p.id);\n         }\n \n         // If this item has no type or lifetime parameters,\n@@ -194,14 +188,12 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n-                    kind: ParamKind,\n                     index: usize,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n         let initial_variance = self.pick_initial_variance(item_id, index);\n         self.inferred_infos.push(InferredInfo { item_id: item_id,\n-                                                kind: kind,\n                                                 index: index,\n                                                 param_id: param_id,\n                                                 term: term,\n@@ -211,13 +203,12 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n         debug!(\"add_inferred(item_path={}, \\\n                 item_id={}, \\\n-                kind={:?}, \\\n                 index={}, \\\n                 param_id={}, \\\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n                self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n-               item_id, kind, index, param_id, inf_index,\n+               item_id, index, param_id, inf_index,\n                initial_variance);\n     }\n "}, {"sha": "c8620254b6f42c6696c0adb0568957bf53dccf27", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -643,7 +643,7 @@ impl Clean<TyParamBound> for hir::TyParamBound {\n fn external_path_params(cx: &DocContext, trait_did: Option<DefId>, has_self: bool,\n                         bindings: Vec<TypeBinding>, substs: &Substs) -> PathParameters {\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n-    let types = substs.types().skip(has_self as usize).cloned().collect::<Vec<_>>();\n+    let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n \n     match (trait_did, cx.tcx_opt()) {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n@@ -741,7 +741,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n \n         // collect any late bound regions\n         let mut late_bounds = vec![];\n-        for &ty_s in self.input_types().skip(1) {\n+        for ty_s in self.input_types().skip(1) {\n             if let ty::TyTuple(ts) = ty_s.sty {\n                 for &ty_s in ts {\n                     if let ty::TyRef(ref reg, _) = ty_s.sty {"}, {"sha": "7dbfc6ac1257d082732d314232599c32c460cef8", "filename": "src/test/compile-fail/variance-associated-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-associated-types.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -20,12 +20,12 @@ trait Trait<'a> {\n }\n \n #[rustc_variance]\n-struct Foo<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[+], regions=[-])\n+struct Foo<'a, T : Trait<'a>> { //~ ERROR [-, +]\n     field: (T, &'a ())\n }\n \n #[rustc_variance]\n-struct Bar<'a, T : Trait<'a>> { //~ ERROR ItemVariances(types=[o], regions=[o])\n+struct Bar<'a, T : Trait<'a>> { //~ ERROR [o, o]\n     field: <T as Trait<'a>>::Type\n }\n "}, {"sha": "1f54771e3676abd00677dc05b75672c2d619a1ec", "filename": "src/test/compile-fail/variance-object-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-object-types.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -18,7 +18,7 @@ use std::cell::Cell;\n // For better or worse, associated types are invariant, and hence we\n // get an invariant result for `'a`.\n #[rustc_variance]\n-struct Foo<'a> { //~ ERROR regions=[o]\n+struct Foo<'a> { //~ ERROR [o]\n     x: Box<Fn(i32) -> &'a i32 + 'static>\n }\n "}, {"sha": "41d204a541b5ad9b4481dd1fe51abff1d3afb359", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -13,11 +13,11 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-trait Foo: 'static { //~ ERROR types=[o]\n+trait Foo: 'static { //~ ERROR [o]\n }\n \n #[rustc_variance]\n-trait Bar<T> { //~ ERROR types=[o, o]\n+trait Bar<T> { //~ ERROR [o, o]\n     fn do_it(&self)\n         where T: 'static;\n }"}, {"sha": "bf46edcfab8b172ffc4affd0eff34f98625e62af", "filename": "src/test/compile-fail/variance-regions-direct.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-direct.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -16,7 +16,7 @@\n // Regions that just appear in normal spots are contravariant:\n \n #[rustc_variance]\n-struct Test2<'a, 'b, 'c> { //~ ERROR regions=[-, -, -]\n+struct Test2<'a, 'b, 'c> { //~ ERROR [-, -, -]\n     x: &'a isize,\n     y: &'b [isize],\n     c: &'c str\n@@ -25,7 +25,7 @@ struct Test2<'a, 'b, 'c> { //~ ERROR regions=[-, -, -]\n // Those same annotations in function arguments become covariant:\n \n #[rustc_variance]\n-struct Test3<'a, 'b, 'c> { //~ ERROR regions=[+, +, +]\n+struct Test3<'a, 'b, 'c> { //~ ERROR [+, +, +]\n     x: extern \"Rust\" fn(&'a isize),\n     y: extern \"Rust\" fn(&'b [isize]),\n     c: extern \"Rust\" fn(&'c str),\n@@ -34,15 +34,15 @@ struct Test3<'a, 'b, 'c> { //~ ERROR regions=[+, +, +]\n // Mutability induces invariance:\n \n #[rustc_variance]\n-struct Test4<'a, 'b:'a> { //~ ERROR regions=[-, o]\n+struct Test4<'a, 'b:'a> { //~ ERROR [-, o]\n     x: &'a mut &'b isize,\n }\n \n // Mutability induces invariance, even when in a\n // contravariant context:\n \n #[rustc_variance]\n-struct Test5<'a, 'b:'a> { //~ ERROR regions=[+, o]\n+struct Test5<'a, 'b:'a> { //~ ERROR [+, o]\n     x: extern \"Rust\" fn(&'a mut &'b isize),\n }\n \n@@ -52,22 +52,22 @@ struct Test5<'a, 'b:'a> { //~ ERROR regions=[+, o]\n // argument list occurs in an invariant context.\n \n #[rustc_variance]\n-struct Test6<'a, 'b:'a> { //~ ERROR regions=[-, o]\n+struct Test6<'a, 'b:'a> { //~ ERROR [-, o]\n     x: &'a mut extern \"Rust\" fn(&'b isize),\n }\n \n // No uses at all is bivariant:\n \n #[rustc_variance]\n-struct Test7<'a> { //~ ERROR regions=[*]\n+struct Test7<'a> { //~ ERROR [*]\n     //~^ ERROR parameter `'a` is never used\n     x: isize\n }\n \n // Try enums too.\n \n #[rustc_variance]\n-enum Test8<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n+enum Test8<'a, 'b, 'c:'b> { //~ ERROR [+, -, o]\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),"}, {"sha": "e28828f62e52d655f4b65e7888ac9b7d17131b2d", "filename": "src/test/compile-fail/variance-regions-indirect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-regions-indirect.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -15,33 +15,33 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR regions=[+, -, o, *]\n+enum Base<'a, 'b, 'c:'b, 'd> { //~ ERROR [+, -, o, *]\n     //~^ ERROR parameter `'d` is never used\n     Test8A(extern \"Rust\" fn(&'a isize)),\n     Test8B(&'b [isize]),\n     Test8C(&'b mut &'c str),\n }\n \n #[rustc_variance]\n-struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR regions=[*, o, -, +]\n+struct Derived1<'w, 'x:'y, 'y, 'z> { //~ ERROR [*, o, -, +]\n     //~^ ERROR parameter `'w` is never used\n     f: Base<'z, 'y, 'x, 'w>\n }\n \n #[rustc_variance] // Combine - and + to yield o\n-struct Derived2<'a, 'b:'a, 'c> { //~ ERROR regions=[o, o, *]\n+struct Derived2<'a, 'b:'a, 'c> { //~ ERROR [o, o, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'a, 'b, 'c>\n }\n \n #[rustc_variance] // Combine + and o to yield o (just pay attention to 'a here)\n-struct Derived3<'a:'b, 'b, 'c> { //~ ERROR regions=[o, -, *]\n+struct Derived3<'a:'b, 'b, 'c> { //~ ERROR [o, -, *]\n     //~^ ERROR parameter `'c` is never used\n     f: Base<'a, 'b, 'a, 'c>\n }\n \n #[rustc_variance] // Combine + and * to yield + (just pay attention to 'a here)\n-struct Derived4<'a, 'b, 'c:'b> { //~ ERROR regions=[+, -, o]\n+struct Derived4<'a, 'b, 'c:'b> { //~ ERROR [+, -, o]\n     f: Base<'a, 'b, 'c, 'a>\n }\n "}, {"sha": "4c737a7594d260125b4486e257d6820ff89aaed7", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -15,48 +15,48 @@\n // influence variance.\n \n #[rustc_variance]\n-trait Getter<T> { //~ ERROR types=[o, o]\n+trait Getter<T> { //~ ERROR [o, o]\n     fn get(&self) -> T;\n }\n \n #[rustc_variance]\n-trait Setter<T> { //~ ERROR types=[o, o]\n+trait Setter<T> { //~ ERROR [o, o]\n     fn get(&self, T);\n }\n \n #[rustc_variance]\n-struct TestStruct<U,T:Setter<U>> { //~ ERROR types=[+, +]\n+struct TestStruct<U,T:Setter<U>> { //~ ERROR [+, +]\n     t: T, u: U\n }\n \n #[rustc_variance]\n-enum TestEnum<U,T:Setter<U>> {//~ ERROR types=[*, +]\n+enum TestEnum<U,T:Setter<U>> {//~ ERROR [*, +]\n     //~^ ERROR parameter `U` is never used\n     Foo(T)\n }\n \n #[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR types=[o, o, o]\n+trait TestTrait<U,T:Setter<U>> { //~ ERROR [o, o, o]\n     fn getter(&self, u: U) -> T;\n }\n \n #[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR types=[o, o]\n+trait TestTrait2<U> : Getter<U> { //~ ERROR [o, o]\n }\n \n #[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR types=[o, o]\n+trait TestTrait3<U> { //~ ERROR [o, o]\n     fn getter<T:Getter<U>>(&self);\n }\n \n #[rustc_variance]\n-struct TestContraStruct<U,T:Setter<U>> { //~ ERROR types=[*, +]\n+struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }\n \n #[rustc_variance]\n-struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR types=[*, +]\n+struct TestBox<U,T:Getter<U>+Setter<U>> { //~ ERROR [*, +]\n     //~^ ERROR parameter `U` is never used\n     t: T\n }"}, {"sha": "b120588ecab52318f4d014f6ed4230d38dc72246", "filename": "src/test/compile-fail/variance-trait-object-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-object-bound.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n trait T { fn foo(&self); }\n \n #[rustc_variance]\n-struct TOption<'a> { //~ ERROR regions=[-]\n+struct TOption<'a> { //~ ERROR [-]\n     v: Option<Box<T + 'a>>,\n }\n "}, {"sha": "2df94cc907a9cf88517497712bb4218e90caca3b", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -14,46 +14,46 @@\n #![feature(rustc_attrs)]\n \n #[rustc_variance]\n-struct TestImm<A, B> { //~ ERROR types=[+, +]\n+struct TestImm<A, B> { //~ ERROR [+, +]\n     x: A,\n     y: B,\n }\n \n #[rustc_variance]\n-struct TestMut<A, B:'static> { //~ ERROR types=[+, o]\n+struct TestMut<A, B:'static> { //~ ERROR [+, o]\n     x: A,\n     y: &'static mut B,\n }\n \n #[rustc_variance]\n-struct TestIndirect<A:'static, B:'static> { //~ ERROR types=[+, o]\n+struct TestIndirect<A:'static, B:'static> { //~ ERROR [+, o]\n     m: TestMut<A, B>\n }\n \n #[rustc_variance]\n-struct TestIndirect2<A:'static, B:'static> { //~ ERROR types=[o, o]\n+struct TestIndirect2<A:'static, B:'static> { //~ ERROR [o, o]\n     n: TestMut<A, B>,\n     m: TestMut<B, A>\n }\n \n #[rustc_variance]\n-trait Getter<A> { //~ ERROR types=[o, o]\n+trait Getter<A> { //~ ERROR [o, o]\n     fn get(&self) -> A;\n }\n \n #[rustc_variance]\n-trait Setter<A> { //~ ERROR types=[o, o]\n+trait Setter<A> { //~ ERROR [o, o]\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR types=[o, o]\n+trait GetterSetter<A> { //~ ERROR [o, o]\n     fn get(&self) -> A;\n     fn set(&mut self, a: A);\n }\n \n #[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR types=[o, o]\n+trait GetterInTypeBound<A> { //~ ERROR [o, o]\n     // Here, the use of `A` in the method bound *does* affect\n     // variance.  Think of it as if the method requested a dictionary\n     // for `T:Getter<A>`.  Since this dictionary is an input, it is\n@@ -63,12 +63,12 @@ trait GetterInTypeBound<A> { //~ ERROR types=[o, o]\n }\n \n #[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR types=[o, o]\n+trait SetterInTypeBound<A> { //~ ERROR [o, o]\n     fn do_it<T:Setter<A>>(&self);\n }\n \n #[rustc_variance]\n-struct TestObject<A, R> { //~ ERROR types=[o, o]\n+struct TestObject<A, R> { //~ ERROR [o, o]\n     n: Box<Setter<A>+Send>,\n     m: Box<Getter<R>+Send>,\n }"}, {"sha": "7667972c9d251edcd9d8e85115fb05b848c1e4fc", "filename": "src/test/compile-fail/variance-types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a8d4822d8eb922f0cd50e92f420b5f1938db64d/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types.rs?ref=7a8d4822d8eb922f0cd50e92f420b5f1938db64d", "patch": "@@ -17,32 +17,32 @@ use std::cell::Cell;\n // not considered bivariant.\n \n #[rustc_variance]\n-struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR types=[o, o], regions=[-]\n+struct InvariantMut<'a,A:'a,B:'a> { //~ ERROR [-, o, o]\n     t: &'a mut (A,B)\n }\n \n #[rustc_variance]\n-struct InvariantCell<A> { //~ ERROR types=[o]\n+struct InvariantCell<A> { //~ ERROR [o]\n     t: Cell<A>\n }\n \n #[rustc_variance]\n-struct InvariantIndirect<A> { //~ ERROR types=[o]\n+struct InvariantIndirect<A> { //~ ERROR [o]\n     t: InvariantCell<A>\n }\n \n #[rustc_variance]\n-struct Covariant<A> { //~ ERROR types=[+]\n+struct Covariant<A> { //~ ERROR [+]\n     t: A, u: fn() -> A\n }\n \n #[rustc_variance]\n-struct Contravariant<A> { //~ ERROR types=[-]\n+struct Contravariant<A> { //~ ERROR [-]\n     t: fn(A)\n }\n \n #[rustc_variance]\n-enum Enum<A,B,C> { //~ ERROR types=[+, -, o]\n+enum Enum<A,B,C> { //~ ERROR [+, -, o]\n     Foo(Covariant<A>),\n     Bar(Contravariant<B>),\n     Zed(Covariant<C>,Contravariant<C>)"}]}