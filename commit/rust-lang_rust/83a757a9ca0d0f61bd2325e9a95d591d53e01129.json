{"sha": "83a757a9ca0d0f61bd2325e9a95d591d53e01129", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYTc1N2E5Y2EwZDBmNjFiZDIzMjVlOWE5NWQ1OTFkNTNlMDExMjk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-08T12:36:20Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-18T14:08:25Z"}, "message": "outline modules: parse -> expand.", "tree": {"sha": "22d1a2dd0556c0a303290cd02f5212412b0aae58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22d1a2dd0556c0a303290cd02f5212412b0aae58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83a757a9ca0d0f61bd2325e9a95d591d53e01129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83a757a9ca0d0f61bd2325e9a95d591d53e01129", "html_url": "https://github.com/rust-lang/rust/commit/83a757a9ca0d0f61bd2325e9a95d591d53e01129", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83a757a9ca0d0f61bd2325e9a95d591d53e01129/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59bf8a07f93d194abcc880a366bda37563a9402b", "url": "https://api.github.com/repos/rust-lang/rust/commits/59bf8a07f93d194abcc880a366bda37563a9402b", "html_url": "https://github.com/rust-lang/rust/commit/59bf8a07f93d194abcc880a366bda37563a9402b"}], "stats": {"total": 296, "additions": 116, "deletions": 180}, "files": [{"sha": "662bbe6a287a36e9399e5d3858fe6596e8e7aa2c", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n use rustc_expand::panictry;\n-use rustc_parse::{self, new_sub_parser_from_file, parser::Parser, DirectoryOwnership};\n+use rustc_parse::{self, new_sub_parser_from_file, parser::Parser};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, Pos, Span};\n@@ -108,8 +108,7 @@ pub fn expand_include<'cx>(\n             return DummyResult::any(sp);\n         }\n     };\n-    let directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let p = new_sub_parser_from_file(cx.parse_sess(), &file, directory_ownership, None, sp);\n+    let p = new_sub_parser_from_file(cx.parse_sess(), &file, None, sp);\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "61a34a39d58f16867134bb58b4f331ae9a727b18", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 46, "deletions": 31, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -18,10 +18,10 @@ use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::Features;\n use rustc_parse::configure;\n-use rustc_parse::parser::module;\n+use rustc_parse::parser::module::{parse_external_mod, push_directory};\n use rustc_parse::parser::Parser;\n use rustc_parse::validate_attr;\n-use rustc_parse::DirectoryOwnership;\n+use rustc_parse::{Directory, DirectoryOwnership};\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n@@ -1428,8 +1428,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_items();\n         }\n \n+        let mut attrs = mem::take(&mut item.attrs); // We do this to please borrowck.\n+        let ident = item.ident;\n+\n         match item.kind {\n             ast::ItemKind::MacCall(..) => {\n+                item.attrs = attrs;\n                 self.check_attributes(&item.attrs);\n                 item.and_then(|item| match item.kind {\n                     ItemKind::MacCall(mac) => self\n@@ -1441,45 +1445,56 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ast::Mod { inner, inline, .. })\n-                if item.ident != Ident::invalid() =>\n-            {\n-                let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n+            ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n+                let sess = self.cx.parse_sess;\n+                let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n-                module.mod_path.push(item.ident);\n-\n-                if inline {\n-                    module::push_directory(\n-                        item.ident,\n-                        &item.attrs,\n-                        &mut self.cx.current_expansion.directory_ownership,\n-                        &mut module.directory,\n-                    );\n+\n+                let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n+                let dir = Directory { ownership: orig_ownership, path: module.directory };\n+                let Directory { ownership, path } = if old_mod.inline {\n+                    // Inline `mod foo { ... }`, but we still need to push directories.\n+                    item.attrs = attrs;\n+                    push_directory(ident, &item.attrs, dir)\n                 } else {\n-                    let path = self.cx.parse_sess.source_map().span_to_unmapped_path(inner);\n-                    let mut path = match path {\n-                        FileName::Real(path) => path,\n-                        other => PathBuf::from(other.to_string()),\n-                    };\n-                    let directory_ownership = match path.file_name().unwrap().to_str() {\n-                        Some(\"mod.rs\") => DirectoryOwnership::Owned { relative: None },\n-                        Some(_) => DirectoryOwnership::Owned { relative: Some(item.ident) },\n-                        None => DirectoryOwnership::UnownedViaMod,\n+                    // We have an outline `mod foo;` so we need to parse the file.\n+                    let (new_mod, dir) = parse_external_mod(sess, ident, dir, &mut attrs, pushed);\n+                    *old_mod = new_mod;\n+                    item.attrs = attrs;\n+                    // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n+                    item = match self.configure(item) {\n+                        Some(node) => node,\n+                        None => {\n+                            if *pushed {\n+                                sess.included_mod_stack.borrow_mut().pop();\n+                            }\n+                            return Default::default();\n+                        }\n                     };\n-                    path.pop();\n-                    module.directory = path;\n-                    self.cx.current_expansion.directory_ownership = directory_ownership;\n-                }\n+                    dir\n+                };\n \n+                // Set the module info before we flat map.\n+                self.cx.current_expansion.directory_ownership = ownership;\n+                module.directory = path;\n+                module.mod_path.push(ident);\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n+\n                 let result = noop_flat_map_item(item, self);\n+\n+                // Restore the module info.\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n+                self.cx.current_expansion.directory_ownership = orig_ownership;\n+                if *pushed {\n+                    sess.included_mod_stack.borrow_mut().pop();\n+                }\n                 result\n             }\n-\n-            _ => noop_flat_map_item(item, self),\n+            _ => {\n+                item.attrs = attrs;\n+                noop_flat_map_item(item, self)\n+            }\n         }\n     }\n "}, {"sha": "1628d8bfdbc0a28e54db0b9a0788e3e8c1de5b8a", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -1,4 +1,4 @@\n-use crate::base::{DummyResult, ExpansionData, ExtCtxt, MacResult, TTMacroExpander};\n+use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n@@ -18,7 +18,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder, FatalError};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n-use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n@@ -182,6 +181,8 @@ fn generic_extension<'cx>(\n     lhses: &[mbe::TokenTree],\n     rhses: &[mbe::TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n+    let sess = cx.parse_sess;\n+\n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n         trace_macros_note(&mut cx.expansions, sp, msg);\n@@ -209,7 +210,7 @@ fn generic_extension<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n-    let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+    let parser = parser_from_cx(sess, arg.clone());\n \n     for (i, lhs) in lhses.iter().enumerate() {\n         // try each arm's matchers\n@@ -222,14 +223,13 @@ fn generic_extension<'cx>(\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n-        let mut gated_spans_snapshot =\n-            mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n+        let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n         match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n-                cx.parse_sess.gated_spans.merge(gated_spans_snapshot);\n+                sess.gated_spans.merge(gated_spans_snapshot);\n \n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n@@ -258,11 +258,7 @@ fn generic_extension<'cx>(\n                     trace_macros_note(&mut cx.expansions, sp, msg);\n                 }\n \n-                let directory = Directory {\n-                    path: cx.current_expansion.module.directory.clone(),\n-                    ownership: cx.current_expansion.directory_ownership,\n-                };\n-                let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false, None);\n+                let mut p = Parser::new(cx.parse_sess(), tts, false, None);\n                 p.root_module_name =\n                     cx.current_expansion.module.mod_path.last().map(|id| id.to_string());\n                 p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n@@ -289,7 +285,7 @@ fn generic_extension<'cx>(\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n-        mem::swap(&mut gated_spans_snapshot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n+        mem::swap(&mut gated_spans_snapshot, &mut sess.gated_spans.spans.borrow_mut());\n     }\n     drop(parser);\n \n@@ -309,8 +305,7 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n-            match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n+            match parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -392,7 +387,7 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let parser = Parser::new(sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n@@ -1209,16 +1204,8 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx<'cx>(\n-    current_expansion: &'cx ExpansionData,\n-    sess: &'cx ParseSess,\n-    tts: TokenStream,\n-) -> Parser<'cx> {\n-    let directory = Directory {\n-        path: current_expansion.module.directory.clone(),\n-        ownership: current_expansion.directory_ownership,\n-    };\n-    Parser::new(sess, tts, Some(directory), true, true, rustc_parse::MACRO_ARGUMENTS)\n+fn parser_from_cx<'cx>(sess: &'cx ParseSess, tts: TokenStream) -> Parser<'cx> {\n+    Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}, {"sha": "c611f24942012afefb2e4d6cec2c3c81bba5dd2d", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -538,12 +538,3 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n fn is_cfg(attr: &Attribute) -> bool {\n     attr.check_name(sym::cfg)\n }\n-\n-/// Process the potential `cfg` attributes on a module.\n-/// Also determine if the module should be included in this configuration.\n-pub fn process_configure_mod(sess: &ParseSess, cfg_mods: bool, attrs: &mut Vec<Attribute>) -> bool {\n-    // Don't perform gated feature checking.\n-    let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n-    strip_unconfigured.process_cfg_attrs(attrs);\n-    !cfg_mods || strip_unconfigured.in_cfg(&attrs)\n-}"}, {"sha": "bcaae02942e29e6a3fa4a9e1e68a9e41ca6202c0", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -3,6 +3,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n+#![feature(try_blocks)]\n \n use rustc_ast::ast;\n use rustc_ast::token::{self, Nonterminal};\n@@ -119,10 +120,7 @@ pub fn maybe_new_parser_from_source_str(\n     name: FileName,\n     source: String,\n ) -> Result<Parser<'_>, Vec<Diagnostic>> {\n-    let mut parser =\n-        maybe_source_file_to_parser(sess, sess.source_map().new_source_file(name, source))?;\n-    parser.recurse_into_file_modules = false;\n-    Ok(parser)\n+    maybe_source_file_to_parser(sess, sess.source_map().new_source_file(name, source))\n }\n \n /// Creates a new parser, handling errors as appropriate if the file doesn't exist.\n@@ -146,12 +144,10 @@ pub fn maybe_new_parser_from_file<'a>(\n pub fn new_sub_parser_from_file<'a>(\n     sess: &'a ParseSess,\n     path: &Path,\n-    directory_ownership: DirectoryOwnership,\n     module_name: Option<String>,\n     sp: Span,\n ) -> Parser<'a> {\n     let mut p = source_file_to_parser(sess, file_to_source_file(sess, path, Some(sp)));\n-    p.directory.ownership = directory_ownership;\n     p.root_module_name = module_name;\n     p\n }\n@@ -257,7 +253,7 @@ pub fn stream_to_parser<'a>(\n     stream: TokenStream,\n     subparser_name: Option<&'static str>,\n ) -> Parser<'a> {\n-    Parser::new(sess, stream, None, true, false, subparser_name)\n+    Parser::new(sess, stream, false, subparser_name)\n }\n \n /// Given a stream, the `ParseSess` and the base directory, produces a parser.\n@@ -271,12 +267,8 @@ pub fn stream_to_parser<'a>(\n /// The main usage of this function is outside of rustc, for those who uses\n /// librustc_ast as a library. Please do not remove this function while refactoring\n /// just because it is not used in rustc codebase!\n-pub fn stream_to_parser_with_base_dir(\n-    sess: &ParseSess,\n-    stream: TokenStream,\n-    base_dir: Directory,\n-) -> Parser<'_> {\n-    Parser::new(sess, stream, Some(base_dir), true, false, None)\n+pub fn stream_to_parser_with_base_dir(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n+    Parser::new(sess, stream, false, None)\n }\n \n /// Runs the given subparser `f` on the tokens of the given `attr`'s item.\n@@ -286,7 +278,7 @@ pub fn parse_in<'a, T>(\n     name: &'static str,\n     mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n ) -> PResult<'a, T> {\n-    let mut parser = Parser::new(sess, tts, None, false, false, Some(name));\n+    let mut parser = Parser::new(sess, tts, false, Some(name));\n     let result = f(&mut parser)?;\n     if parser.token != token::Eof {\n         parser.unexpected()?;"}, {"sha": "f4862a6c87b735440d093fca515e7c2f1b1d64dc", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -13,7 +13,6 @@ mod stmt;\n use diagnostics::Error;\n \n use crate::lexer::UnmatchedBrace;\n-use crate::{Directory, DirectoryOwnership};\n \n use log::debug;\n use rustc_ast::ast::DUMMY_NODE_ID;\n@@ -28,11 +27,9 @@ use rustc_ast::util::comments::{doc_comment_style, strip_doc_comment_decoration}\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError, PResult};\n use rustc_session::parse::ParseSess;\n-use rustc_span::source_map::respan;\n+use rustc_span::source_map::{respan, Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{FileName, Span, DUMMY_SP};\n \n-use std::path::PathBuf;\n use std::{cmp, mem, slice};\n \n bitflags::bitflags! {\n@@ -93,21 +90,13 @@ pub struct Parser<'a> {\n     /// The previous token.\n     pub prev_token: Token,\n     restrictions: Restrictions,\n-    /// Used to determine the path to externally loaded source files.\n-    pub(super) directory: Directory,\n-    /// `true` to parse sub-modules in other files.\n-    // Public for rustfmt usage.\n-    pub recurse_into_file_modules: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n     expected_tokens: Vec<TokenType>,\n     token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n-    /// `true` we should configure out of line modules as we parse.\n-    // Public for rustfmt usage.\n-    pub cfg_mods: bool,\n     /// This field is used to keep track of how many left angle brackets we have seen. This is\n     /// required in order to detect extra leading left angle brackets (`<` characters) and error\n     /// appropriately.\n@@ -355,8 +344,6 @@ impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n         tokens: TokenStream,\n-        directory: Option<Directory>,\n-        recurse_into_file_modules: bool,\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n     ) -> Self {\n@@ -365,19 +352,13 @@ impl<'a> Parser<'a> {\n             token: Token::dummy(),\n             prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n-            recurse_into_file_modules,\n-            directory: Directory {\n-                path: PathBuf::new(),\n-                ownership: DirectoryOwnership::Owned { relative: None },\n-            },\n             root_module_name: None,\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n                 frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, &tokens),\n                 stack: Vec::new(),\n             },\n             desugar_doc_comments,\n-            cfg_mods: true,\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n             unclosed_delims: Vec::new(),\n@@ -389,18 +370,6 @@ impl<'a> Parser<'a> {\n         // Make parser point to the first token.\n         parser.bump();\n \n-        if let Some(directory) = directory {\n-            parser.directory = directory;\n-        } else if !parser.token.span.is_dummy() {\n-            if let Some(FileName::Real(path)) =\n-                &sess.source_map().lookup_char_pos(parser.token.span.lo()).file.unmapped_path\n-            {\n-                if let Some(directory_path) = path.parent() {\n-                    parser.directory.path = directory_path.to_path_buf();\n-                }\n-            }\n-        }\n-\n         parser\n     }\n "}, {"sha": "695afafdd824c877e10d38d4321a99ccb1ffc603", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -1,7 +1,7 @@\n use super::item::ItemInfo;\n use super::Parser;\n \n-use crate::{new_sub_parser_from_file, DirectoryOwnership};\n+use crate::{new_sub_parser_from_file, Directory, DirectoryOwnership};\n \n use rustc_ast::ast::{self, Attribute, Crate, Ident, ItemKind, Mod};\n use rustc_ast::attr;\n@@ -39,25 +39,12 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     pub(super) fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n-        let in_cfg = crate::config::process_configure_mod(self.sess, self.cfg_mods, attrs);\n-\n         let id = self.parse_ident()?;\n         let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n-            if in_cfg && self.recurse_into_file_modules {\n-                let dir = &self.directory;\n-                parse_external_module(self.sess, self.cfg_mods, id, dir.ownership, &dir.path, attrs)\n-            } else {\n-                Default::default()\n-            }\n+            Default::default()\n         } else {\n-            let old_directory = self.directory.clone();\n-            push_directory(id, &attrs, &mut self.directory.ownership, &mut self.directory.path);\n-\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            let module = self.parse_mod(&token::CloseDelim(token::Brace))?;\n-\n-            self.directory = old_directory;\n-            module\n+            self.parse_mod(&token::CloseDelim(token::Brace))?\n         };\n         attrs.append(&mut inner_attrs);\n         Ok((id, ItemKind::Mod(module)))\n@@ -95,41 +82,45 @@ impl<'a> Parser<'a> {\n     }\n }\n \n-fn parse_external_module(\n+pub fn parse_external_mod(\n     sess: &ParseSess,\n-    cfg_mods: bool,\n-    id: ast::Ident,\n-    ownership: DirectoryOwnership,\n-    dir_path: &Path,\n-    attrs: &[Attribute],\n-) -> (Mod, Vec<Attribute>) {\n-    submod_path(sess, id, &attrs, ownership, dir_path)\n-        .and_then(|r| eval_src_mod(sess, cfg_mods, r.path, r.ownership, id))\n-        .map_err(|mut err| err.emit())\n-        .unwrap_or_default()\n-}\n-\n-/// Reads a module from a source file.\n-fn eval_src_mod<'a>(\n-    sess: &'a ParseSess,\n-    cfg_mods: bool,\n-    path: PathBuf,\n-    dir_ownership: DirectoryOwnership,\n     id: ast::Ident,\n-) -> PResult<'a, (Mod, Vec<Attribute>)> {\n-    let mut included_mod_stack = sess.included_mod_stack.borrow_mut();\n-    error_on_circular_module(sess, id.span, &path, &included_mod_stack)?;\n-    included_mod_stack.push(path.clone());\n-    drop(included_mod_stack);\n-\n-    let mut p0 =\n-        new_sub_parser_from_file(sess, &path, dir_ownership, Some(id.to_string()), id.span);\n-    p0.cfg_mods = cfg_mods;\n-    let mut module = p0.parse_mod(&token::Eof)?;\n-    module.0.inline = false;\n+    Directory { mut ownership, path }: Directory,\n+    attrs: &mut Vec<Attribute>,\n+    pop_mod_stack: &mut bool,\n+) -> (Mod, Directory) {\n+    // We bail on the first error, but that error does not cause a fatal error... (1)\n+    let result: PResult<'_, _> = try {\n+        // Extract the file path and the new ownership.\n+        let mp = submod_path(sess, id, &attrs, ownership, &path)?;\n+        ownership = mp.ownership;\n+\n+        // Ensure file paths are acyclic.\n+        let mut included_mod_stack = sess.included_mod_stack.borrow_mut();\n+        error_on_circular_module(sess, id.span, &mp.path, &included_mod_stack)?;\n+        included_mod_stack.push(mp.path.clone());\n+        *pop_mod_stack = true; // We have pushed, so notify caller.\n+        drop(included_mod_stack);\n+\n+        // Actually parse the external file as amodule.\n+        let mut p0 = new_sub_parser_from_file(sess, &mp.path, Some(id.to_string()), id.span);\n+        let mut module = p0.parse_mod(&token::Eof)?;\n+        module.0.inline = false;\n+        module\n+    };\n+    // (1) ...instead, we return a dummy module.\n+    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    attrs.append(&mut new_attrs);\n+\n+    // Extract the directory path for submodules of `module`.\n+    let path = sess.source_map().span_to_unmapped_path(module.inner);\n+    let mut path = match path {\n+        FileName::Real(path) => path,\n+        other => PathBuf::from(other.to_string()),\n+    };\n+    path.pop();\n \n-    sess.included_mod_stack.borrow_mut().pop();\n-    Ok(module)\n+    (module, Directory { ownership, path })\n }\n \n fn error_on_circular_module<'a>(\n@@ -153,27 +144,27 @@ fn error_on_circular_module<'a>(\n pub fn push_directory(\n     id: Ident,\n     attrs: &[Attribute],\n-    dir_ownership: &mut DirectoryOwnership,\n-    dir_path: &mut PathBuf,\n-) {\n-    if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-        dir_path.push(&*path.as_str());\n-        *dir_ownership = DirectoryOwnership::Owned { relative: None };\n+    Directory { mut ownership, mut path }: Directory,\n+) -> Directory {\n+    if let Some(filename) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+        path.push(&*filename.as_str());\n+        ownership = DirectoryOwnership::Owned { relative: None };\n     } else {\n         // We have to push on the current module name in the case of relative\n         // paths in order to ensure that any additional module paths from inline\n         // `mod x { ... }` come after the relative extension.\n         //\n         // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n         // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-        if let DirectoryOwnership::Owned { relative } = dir_ownership {\n+        if let DirectoryOwnership::Owned { relative } = &mut ownership {\n             if let Some(ident) = relative.take() {\n                 // Remove the relative offset.\n-                dir_path.push(&*ident.as_str());\n+                path.push(&*ident.as_str());\n             }\n         }\n-        dir_path.push(&*id.as_str());\n+        path.push(&*id.as_str());\n     }\n+    Directory { ownership, path }\n }\n \n fn submod_path<'a>("}, {"sha": "d40597d8fcb0c543127dc61e155dd87e54b84bd7", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a757a9ca0d0f61bd2325e9a95d591d53e01129/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=83a757a9ca0d0f61bd2325e9a95d591d53e01129", "patch": "@@ -5,7 +5,6 @@ use super::pat::GateOr;\n use super::path::PathStyle;\n use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n use crate::maybe_whole;\n-use crate::DirectoryOwnership;\n \n use rustc_ast::ast;\n use rustc_ast::ast::{AttrStyle, AttrVec, Attribute, MacCall, MacStmtStyle};\n@@ -54,7 +53,7 @@ impl<'a> Parser<'a> {\n             // that starts like a path (1 token), but it fact not a path.\n             // Also, we avoid stealing syntax from `parse_item_`.\n             self.parse_stmt_path_start(lo, attrs)?\n-        } else if let Some(item) = self.parse_stmt_item(attrs.clone())? {\n+        } else if let Some(item) = self.parse_item_common(attrs.clone(), false, true, |_| true)? {\n             // FIXME: Bad copy of attrs\n             self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n         } else if self.eat(&token::Semi) {\n@@ -72,13 +71,6 @@ impl<'a> Parser<'a> {\n         Ok(Some(stmt))\n     }\n \n-    fn parse_stmt_item(&mut self, attrs: Vec<Attribute>) -> PResult<'a, Option<ast::Item>> {\n-        let old = mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-        let item = self.parse_item_common(attrs, false, true, |_| true)?;\n-        self.directory.ownership = old;\n-        Ok(item)\n-    }\n-\n     fn parse_stmt_path_start(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, Stmt> {\n         let path = self.parse_path(PathStyle::Expr)?;\n "}]}