{"sha": "a87e9521029fdc319b5c86680d6645f411751943", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4N2U5NTIxMDI5ZmRjMzE5YjVjODY2ODBkNjY0NWY0MTE3NTE5NDM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-09T09:53:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T08:35:40Z"}, "message": "Separate deref and access into different operations; add special exception for creating raw references", "tree": {"sha": "9c48f88dd46b4d67a0dae7b4362383e33b6a541b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c48f88dd46b4d67a0dae7b4362383e33b6a541b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a87e9521029fdc319b5c86680d6645f411751943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a87e9521029fdc319b5c86680d6645f411751943", "html_url": "https://github.com/rust-lang/rust/commit/a87e9521029fdc319b5c86680d6645f411751943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a87e9521029fdc319b5c86680d6645f411751943/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "224d03dbdc642a60a3326c7bb9b9206082d4cda4", "url": "https://api.github.com/repos/rust-lang/rust/commits/224d03dbdc642a60a3326c7bb9b9206082d4cda4", "html_url": "https://github.com/rust-lang/rust/commit/224d03dbdc642a60a3326c7bb9b9206082d4cda4"}], "stats": {"total": 504, "additions": 280, "deletions": 224}, "files": [{"sha": "a0ed7c8e4fdbd5d3c23da38864cf5080dd673696", "filename": "src/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -308,16 +308,18 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n         // Some functions are whitelisted until we figure out how to fix them.\n         // We walk up the stack a few frames to also cover their callees.\n-        const WHITELIST: &[&str] = &[\n+        const WHITELIST: &[(&str, &str)] = &[\n             // Uses mem::uninitialized\n-            \"std::ptr::read\",\n-            \"std::sys::windows::mutex::Mutex::\",\n+            (\"std::ptr::read\", \"\"),\n+            (\"std::sys::windows::mutex::Mutex::\", \"\"),\n+            // Should directly take a raw reference\n+            (\"<std::cell::UnsafeCell<T>>\", \"::get\"),\n         ];\n         for frame in ecx.stack().iter()\n             .rev().take(3)\n         {\n             let name = frame.instance.to_string();\n-            if WHITELIST.iter().any(|white| name.starts_with(white)) {\n+            if WHITELIST.iter().any(|(prefix, suffix)| name.starts_with(prefix) && name.ends_with(suffix)) {\n                 return false;\n             }\n         }\n@@ -453,7 +455,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         let (size, _) = ecx.size_and_align_of_mplace(place)?\n             // for extern types, just cover what we can\n             .unwrap_or_else(|| place.layout.size_and_align());\n-        if !ecx.machine.validate || size == Size::ZERO {\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n+            !Self::enforce_validity(ecx) || size == Size::ZERO\n+        {\n             // No tracking\n             Ok(place.ptr)\n         } else {"}, {"sha": "ab536b5785c9869882503f39b42684cfa8fbc65b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 220, "deletions": 203, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -1,10 +1,10 @@\n use std::cell::RefCell;\n \n use rustc::ty::{self, layout::Size};\n-use rustc::hir;\n+use rustc::hir::{Mutability, MutMutable, MutImmutable};\n \n use crate::{\n-    EvalResult, MiriEvalContext, HelpersEvalContextExt,\n+    EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt,\n     MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n     Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n@@ -27,15 +27,15 @@ pub enum Borrow {\n \n impl Borrow {\n     #[inline(always)]\n-    pub fn is_shr(self) -> bool {\n+    pub fn is_shared(self) -> bool {\n         match self {\n             Borrow::Shr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline(always)]\n-    pub fn is_uniq(self) -> bool {\n+    pub fn is_unique(self) -> bool {\n         match self {\n             Borrow::Uniq(_) => true,\n             _ => false,\n@@ -96,27 +96,17 @@ impl Stack {\n     }\n }\n \n-/// What kind of usage of the pointer are we talking about?\n+/// What kind of reference is being used?\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum UsageKind {\n-    /// Write, or create &mut\n-    Write,\n-    /// Read, or create &\n-    Read,\n-    /// Create * (raw ptr)\n+pub enum RefKind {\n+    /// &mut\n+    Unique,\n+    /// & without interior mutability\n+    Frozen,\n+    /// * (raw pointer) or & to `UnsafeCell`\n     Raw,\n }\n \n-impl From<Option<hir::Mutability>> for UsageKind {\n-    fn from(mutbl: Option<hir::Mutability>) -> Self {\n-        match mutbl {\n-            None => UsageKind::Raw,\n-            Some(hir::MutMutable) => UsageKind::Write,\n-            Some(hir::MutImmutable) => UsageKind::Read,\n-        }\n-    }\n-}\n-\n /// Extra global machine state\n #[derive(Clone, Debug)]\n pub struct State {\n@@ -127,6 +117,12 @@ impl State {\n     pub fn new() -> State {\n         State { clock: 0 }\n     }\n+\n+    fn increment_clock(&mut self) -> Timestamp {\n+        let val = self.clock;\n+        self.clock = val + 1;\n+        val\n+    }\n }\n \n /// Extra per-allocation state\n@@ -136,52 +132,45 @@ pub struct Stacks {\n     stacks: RefCell<RangeMap<Stack>>,\n }\n \n-/// Core operations\n+/// Core per-location operations: deref, access, create.\n+/// We need to make at least the following things true:\n+///\n+/// U1: After creating a Uniq, it is at the top (+unfrozen).\n+/// U2: If the top is Uniq (+unfrozen), accesses must be through that Uniq or pop it.\n+/// U3: If an access (deref sufficient?) happens with a Uniq, it requires the Uniq to be in the stack.\n+///\n+/// F1: After creating a &, the parts outside `UnsafeCell` are frozen.\n+/// F2: If a write access happens, it unfreezes.\n+/// F3: If an access (well, a deref) happens with an & outside `UnsafeCell`, it requires the location to still be frozen.\n impl<'tcx> Stack {\n-    /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `is_write` indicates whether this is being used to write (or, equivalently, to\n-    /// borrow as &mut).\n-    /// Returns `Err` if the answer is \"no\"; otherwise the return value indicates what to\n-    /// do: With `Some(n)` you need to unfreeze, and then additionally pop `n` items.\n-    fn reactivatable(&self, bor: Borrow, is_write: bool) -> Result<Option<usize>, String> {\n-        // Check if we can match the frozen \"item\".  Not possible on writes!\n-        if !is_write {\n-            // For now, we do NOT check the timestamp.  That might be surprising, but\n-            // we cannot even notice when a location should be frozen but is not!\n-            // Those checks are both done in `tag_dereference`, where we have type information.\n-            // Either way, it is crucial that the frozen \"item\" matches raw pointers:\n-            // Reading through a raw should not unfreeze.\n-            match (self.frozen_since, bor) {\n-                (Some(_), Borrow::Shr(_)) => {\n-                    return Ok(None)\n+    /// Deref `bor`: Check if the location is frozen and the tag in the stack.\n+    /// This dos *not* constitute an access!  \"Deref\" refers to the `*` operator\n+    /// in Rust, and includs cases like `&*x` or `(*x).foo` where no or only part\n+    /// of the memory actually gets accessed.  Also we cannot know if we are\n+    /// going to read or write.\n+    /// Returns the index of the item we matched, `None` if it was the frozen one.\n+    /// `kind` indicates which kind of reference is being dereferenced.\n+    fn deref(&self, bor: Borrow, kind: RefKind) -> Result<Option<usize>, String> {\n+        // Checks related to freezing\n+        match bor {\n+            Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n+                // We need the location to be frozen. This ensures F3.\n+                let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n+                return if frozen { Ok(None) } else {\n+                    Err(format!(\"Location is not frozen long enough\"))\n                 }\n-                _ => {},\n             }\n+            Borrow::Shr(_) if self.frozen_since.is_some() => {\n+                return Ok(None) // Shared deref to frozen location, looking good\n+            }\n+            _ => {} // Not sufficient, go on looking.\n         }\n-        // See if we can find this borrow.\n-        for (idx, &itm) in self.borrows.iter().rev().enumerate() {\n-            // Check borrow and stack item for compatibility.\n+        // If we got here, we have to look for our item in the stack.\n+        for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match (itm, bor) {\n-                (BorStackItem::FnBarrier(_), _) => {\n-                    return Err(format!(\"Trying to reactivate a borrow ({:?}) that lives \\\n-                                        behind a barrier\", bor))\n-                }\n+                (BorStackItem::FnBarrier(_), _) => break,\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n-                    // Found matching unique item.  This is *always* required to use a `Uniq`:\n-                    // The item must still be on the stack.\n-                    if !is_write {\n-                        // As a special case, if we are reading, let us see if it would be\n-                        // beneficial to pretend we are a raw pointer instead.  If\n-                        // raw pointers are allowed to read while popping *less* than we\n-                        // would have to pop, there is no reason not to let them do this.\n-                        match self.reactivatable(Borrow::default(), is_write) {\n-                            // If we got something better (popping less) that `idx`, use that\n-                            Ok(None) => return Ok(None),\n-                            Ok(Some(shr_idx)) if shr_idx <= idx => return Ok(Some(shr_idx)),\n-                            // Otherwise just go on.\n-                            _ => {},\n-                        }\n-                    }\n+                    // Found matching unique item.  This satisfies U3.\n                     return Ok(Some(idx))\n                 }\n                 (BorStackItem::Shr, Borrow::Shr(_)) => {\n@@ -192,154 +181,182 @@ impl<'tcx> Stack {\n                 _ => {}\n             }\n         }\n-        // Nothing to be found.\n-        Err(format!(\"Borrow-to-reactivate {:?} does not exist on the stack\", bor))\n+        // If we got here, we did not find our item.  We have to error to satisfy U3.\n+        Err(format!(\n+            \"Borrow being dereferenced ({:?}) does not exist on the stack, or is guarded by a barrier\",\n+            bor\n+        ))\n     }\n \n-    /// Reactive `bor` for this stack.  `is_write` indicates whether this is being\n-    /// used to write (or, equivalently, to borrow as &mut).\n-    fn reactivate(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n-        let mut pop = match self.reactivatable(bor, is_write) {\n-            Ok(None) => return Ok(()),\n-            Ok(Some(pop)) => pop,\n-            Err(err) => return err!(MachineError(err)),\n-        };\n-        // Pop what `reactivatable` told us to pop. Always unfreeze.\n+    /// Perform an actual memory access using `bor`.  We do not know any types here\n+    /// or whether things should be frozen, but we *do* know if this is reading\n+    /// or writing.\n+    fn access(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n+        // Check if we can match the frozen \"item\".\n+        // Not possible on writes!\n         if self.is_frozen() {\n-            trace!(\"reactivate: Unfreezing\");\n+            if !is_write {\n+                // When we are frozen, we just accept all reads.  No harm in this.\n+                // The deref already checked that `Uniq` items are in the stack, and that\n+                // the location is frozen if it should be.\n+                return Ok(());\n+            }\n+            trace!(\"access: Unfreezing\");\n         }\n+        // Unfreeze on writes.  This ensures F2.\n         self.frozen_since = None;\n-        while pop > 0 {\n-            let itm = self.borrows.pop().unwrap();\n-            trace!(\"reactivate: Popping {:?}\", itm);\n-            pop -= 1;\n+        // Pop the stack until we have something matching.\n+        while let Some(&itm) = self.borrows.last() {\n+            match (itm, bor) {\n+                (BorStackItem::FnBarrier(_), _) => break,\n+                (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n+                    // Found matching unique item.\n+                    return Ok(())\n+                }\n+                (BorStackItem::Shr, _) if !is_write => {\n+                    // When reading, everything can use a shared item!\n+                    // We do not want to do this when writing: Writing to an `&mut`\n+                    // should reaffirm its exclusivity (i.e., make sure it is\n+                    // on top of the stack).\n+                    return Ok(())\n+                }\n+                (BorStackItem::Shr, Borrow::Shr(_)) => {\n+                    // Found matching shared item.\n+                    return Ok(())\n+                }\n+                _ => {\n+                    // Pop this.  This ensures U2.\n+                    let itm = self.borrows.pop().unwrap();\n+                    trace!(\"access: Popping {:?}\", itm);\n+                }\n+            }\n         }\n-        Ok(())\n+        // If we got here, we did not find our item.\n+        err!(MachineError(format!(\n+            \"Borrow being accessed ({:?}) does not exist on the stack, or is guarded by a barrier\",\n+            bor\n+        )))\n     }\n \n     /// Initiate `bor`; mostly this means pushing.\n     /// This operation cannot fail; it is up to the caller to ensure that the precondition\n     /// is met: We cannot push `Uniq` onto frozen stacks.\n-    /// Crucially, this makes pushing a `Shr` onto a frozen location a NOP.  We do not want\n-    /// such a location to get mutably shared this way!\n-    fn initiate(&mut self, bor: Borrow) {\n-        if let Some(_) = self.frozen_since {\n+    /// `kind` indicates which kind of reference is being created.\n+    fn create(&mut self, bor: Borrow, kind: RefKind) {\n+        // First, push the item.  We do this even if we will later freeze, because we\n+        // will allow mutation of shared data at the expense of unfreezing.\n+        if let Some(itm_t) = self.frozen_since {\n             // A frozen location, we won't change anything here!\n             match bor {\n                 Borrow::Uniq(_) => bug!(\"Trying to create unique ref to frozen location\"),\n-                Borrow::Shr(_) => trace!(\"initiate: New shared ref to frozen location is a NOP\"),\n+                Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n+                    // Make sure we are frozen long enough.  This is part 1 of ensuring F1.\n+                    assert!(itm_t <= bor_t, \"Trying to freeze shorter than it was frozen?\");\n+                    trace!(\"create: Freezing a frozen location is a NOP\");\n+                }\n+                Borrow::Shr(_) => trace!(\"create: Sharing a frozen location is a NOP\"),\n             }\n         } else {\n-            // Just push.\n+            // First push.\n             let itm = match bor {\n                 Borrow::Uniq(t) => BorStackItem::Uniq(t),\n-                Borrow::Shr(_) if *self.borrows.last().unwrap() == BorStackItem::Shr => {\n-                    // Optimization: Don't push a Shr onto a Shr.\n-                    trace!(\"initiate: New shared ref to already shared location is a NOP\");\n-                    return\n-                },\n                 Borrow::Shr(_) => BorStackItem::Shr,\n             };\n-            trace!(\"initiate: Pushing {:?}\", itm);\n-            self.borrows.push(itm)\n-        }\n-    }\n-\n-    /// Check if this location is \"frozen enough\".\n-    fn check_frozen(&self, bor_t: Timestamp) -> EvalResult<'tcx> {\n-        let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n-        if !frozen {\n-            err!(MachineError(format!(\"Location is not frozen long enough\")))\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    /// Freeze this location, since `bor_t`.\n-    fn freeze(&mut self, bor_t: Timestamp) {\n-        if let Some(itm_t) = self.frozen_since {\n-            assert!(itm_t <= bor_t, \"Trying to freeze shorter than it was frozen?\");\n-        } else {\n-            trace!(\"Freezing\");\n-            self.frozen_since = Some(bor_t);\n+            if *self.borrows.last().unwrap() == itm {\n+                assert!(bor.is_shared());\n+                trace!(\"create: Sharing a shared location is a NOP\");\n+            } else {\n+                // This ensures U1.\n+                trace!(\"create: Pushing {:?}\", itm);\n+                self.borrows.push(itm);\n+            }\n+            // Now, maybe freeze.  This is part 2 of ensuring F1.\n+            if kind == RefKind::Frozen {\n+                let bor_t = match bor {\n+                    Borrow::Shr(Some(t)) => t,\n+                    _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n+                };\n+                trace!(\"create: Freezing\");\n+                self.frozen_since = Some(bor_t);\n+            }\n         }\n     }\n }\n \n-impl State {\n-    fn increment_clock(&mut self) -> Timestamp {\n-        let val = self.clock;\n-        self.clock = val + 1;\n-        val\n-    }\n-}\n-\n-/// Higher-level operations\n+/// Higher-level per-location operations: deref, access, reborrow.\n impl<'tcx> Stacks {\n-    /// `ptr` got used, reflect that in the stack.\n-    fn reactivate(\n+    /// Check that this stack is fine with being dereferenced\n+    fn deref(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        usage: UsageKind,\n+        kind: RefKind,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"use_borrow of tag {:?} as {:?}: {:?}, size {}\",\n-            ptr.tag, usage, ptr, size.bytes());\n+        trace!(\"deref for tag {:?} as {:?}: {:?}, size {}\",\n+            ptr.tag, kind, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n+        // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reactivate(ptr.tag, usage == UsageKind::Write)?;\n+            stack.deref(ptr.tag, kind).map_err(EvalErrorKind::MachineError)?;\n         }\n         Ok(())\n     }\n \n-    /// Create a new borrow, the ptr must already have the new tag.\n-    /// Also freezes the location if `freeze` is set and the tag is a timestamped `Shr`.\n-    fn initiate(\n+    /// `ptr` got used, reflect that in the stack.\n+    fn access(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        freeze: bool,\n-    ) {\n-        trace!(\"reborrow for tag {:?}: {:?}, size {}\",\n+        is_write: bool,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"{} access of tag {:?}: {:?}, size {}\",\n+            if is_write { \"read\" } else { \"write\" },\n             ptr.tag, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.initiate(ptr.tag);\n-            if freeze {\n-                if let Borrow::Shr(Some(bor_t)) = ptr.tag {\n-                    stack.freeze(bor_t);\n-                }\n-            }\n+            stack.access(ptr.tag, is_write)?;\n         }\n+        Ok(())\n     }\n \n-    /// Check that this stack is fine with being dereferenced\n-    fn check_deref(\n+    /// Reborrow the given pointer to the new tag for the given kind of reference.\n+    fn reborrow(\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n-        frozen: bool,\n+        new_bor: Borrow,\n+        new_kind: RefKind,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n+            ptr.tag, new_bor, new_kind, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n-        // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            // Conservatively assume we will just read\n-            if let Err(err) = stack.reactivatable(ptr.tag, /*is_write*/false) {\n-                return err!(MachineError(format!(\n-                    \"Encountered reference with non-reactivatable tag: {}\",\n-                    err\n-                )))\n-            }\n-            // Sometimes we also need to be frozen.\n-            // In this case we *both* push `Shr` and then freeze.  This means that a `&mut`\n-            // to `*const` to `*mut` cast through `&` actually works.\n-            if frozen {\n-                // Even shared refs can have uniq tags (after transmute).  That's not an error\n-                // but they do not get any freezing benefits.\n-                if let Borrow::Shr(Some(bor_t)) = ptr.tag {\n-                    stack.check_frozen(bor_t)?;\n+            // Access source `ptr`, create new ref.\n+            let ptr_idx = stack.deref(ptr.tag, new_kind).map_err(EvalErrorKind::MachineError)?;\n+            if new_kind == RefKind::Raw {\n+                assert!(new_bor.is_shared());\n+                // Raw references do not get quite as many guarantees as the other kinds:\n+                // If we can deref the new tag already, and if that tag lives higher on\n+                // the stack than the one we come from, just use that.\n+                // IOW, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n+                match (ptr_idx, stack.deref(new_bor, new_kind)) {\n+                    // If the new borrow works with the forzen item, or else if it lives\n+                    // above the old one in the stack, our job here is done.\n+                    (_, Ok(None)) => {\n+                        trace!(\"reborrow-to-raw on a frozen location is a NOP\");\n+                        continue\n+                    },\n+                    (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => {\n+                        trace!(\"reborrow-to-raw is a NOP because the src ptr already got reborrowed-to-raw\");\n+                        continue\n+                    },\n+                    _ => {},\n                 }\n             }\n+            // Non-raw reborrows should behave exactly as if we also did a\n+            // read/write to the given location.\n+            stack.access(ptr.tag, new_kind == RefKind::Unique)?;\n+            stack.create(new_bor, new_kind);\n         }\n         Ok(())\n     }\n@@ -353,8 +370,7 @@ impl AllocationExtra<Borrow> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        // Reads behave exactly like the first half of a reborrow-to-shr\n-        alloc.extra.reactivate(ptr, size, UsageKind::Read)\n+        alloc.extra.access(ptr, size, /*is_write*/false)\n     }\n \n     #[inline(always)]\n@@ -363,8 +379,7 @@ impl AllocationExtra<Borrow> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        // Writes behave exactly like the first half of a reborrow-to-mut\n-        alloc.extra.reactivate(ptr, size, UsageKind::Read)\n+        alloc.extra.access(ptr, size, /*is_write*/true)\n     }\n \n     #[inline(always)]\n@@ -374,7 +389,7 @@ impl AllocationExtra<Borrow> for Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // This is like mutating\n-        alloc.extra.reactivate(ptr, size, UsageKind::Write)\n+        alloc.extra.access(ptr, size, /*is_write*/true)\n         // FIXME: Error out of there are any barriers?\n     }\n }\n@@ -402,7 +417,7 @@ pub trait EvalContextExt<'tcx> {\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        usage: UsageKind,\n+        mutability: Option<Mutability>,\n     ) -> EvalResult<'tcx, Borrow>;\n \n     fn tag_new_allocation(\n@@ -412,10 +427,10 @@ pub trait EvalContextExt<'tcx> {\n     ) -> Borrow;\n \n     /// Retag an indidual pointer, returning the retagged version.\n-    fn retag_ptr(\n+    fn reborrow(\n         &mut self,\n         ptr: ImmTy<'tcx, Borrow>,\n-        mutbl: hir::Mutability,\n+        mutbl: Mutability,\n     ) -> EvalResult<'tcx, Immediate<Borrow>>;\n \n     fn retag(\n@@ -461,46 +476,49 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         Borrow::Uniq(time)\n     }\n \n-    /// Called for value-to-place conversion.\n+    /// Called for value-to-place conversion.  `mutability` is `None` for raw pointers.\n     ///\n     /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n     /// We could be in the middle of `&(*var).1`.\n     fn tag_dereference(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n-        usage: UsageKind,\n+        mutability: Option<Mutability>,\n     ) -> EvalResult<'tcx, Borrow> {\n-        trace!(\"tag_dereference: Accessing reference ({:?}) for {:?} (pointee {})\",\n-            usage, place.ptr, place.layout.ty);\n+        trace!(\"tag_dereference: Accessing {} reference for {:?} (pointee {})\",\n+            if let Some(mutability) = mutability { format!(\"{:?}\", mutability) } else { format!(\"raw\") },\n+            place.ptr, place.layout.ty);\n         let ptr = place.ptr.to_ptr()?;\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n-        // it can happen that the tag of `ptr` does not actually match `usage`, and we\n+        // it can happen that the tag of `ptr` does not actually match `mutability`, and we\n         // should adjust for that.\n         // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n         // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n-        match (usage, ptr.tag) {\n-            (UsageKind::Raw, _) => {\n+        match (mutability, ptr.tag) {\n+            (None, _) => {\n                 // Don't use the tag, this is a raw access!  They should happen tagless.\n+                // This is needed for `*mut` to make any sense: Writes *do* enforce the\n+                // `Uniq` tag to be up top, but we must make sure raw writes do not do that.\n                 // This does mean, however, that `&*foo` is *not* a NOP *if* `foo` is a raw ptr.\n                 // Also don't do any further validation, this is raw after all.\n                 return Ok(Borrow::default());\n             }\n-            (UsageKind::Write, Borrow::Uniq(_)) |\n-            (UsageKind::Read, Borrow::Shr(_)) => {\n+            (Some(MutMutable), Borrow::Uniq(_)) |\n+            (Some(MutImmutable), Borrow::Shr(_)) => {\n                 // Expected combinations.  Nothing to do.\n             }\n-            (UsageKind::Write, Borrow::Shr(None)) => {\n+            (Some(MutMutable), Borrow::Shr(None)) => {\n                 // Raw transmuted to mut ref.  Keep this as raw access.\n                 // We cannot reborrow here; there might be a raw in `&(*var).1` where\n                 // `var` is an `&mut`.  The other field of the struct might be already frozen,\n                 // also using `var`, and that would be okay.\n             }\n-            (UsageKind::Read, Borrow::Uniq(_)) => {\n+            (Some(MutImmutable), Borrow::Uniq(_)) => {\n                 // A mut got transmuted to shr.  Can happen even from compiler transformations:\n                 // `&*x` gets optimized to `x` even when `x` is a `&mut`.\n             }\n-            (UsageKind::Write, Borrow::Shr(Some(_))) => {\n+            (Some(MutMutable), Borrow::Shr(Some(_))) => {\n                 // This is just invalid: A shr got transmuted to a mut.\n                 // If we ever allow this, we have to consider what we do when a turn a\n                 // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n@@ -515,13 +533,16 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n         if let Borrow::Shr(Some(_)) = ptr.tag {\n+            assert_eq!(mutability, Some(MutImmutable));\n             // We need a frozen-sensitive check\n             self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n-                alloc.extra.check_deref(cur_ptr, size, frozen)\n+                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n+                alloc.extra.deref(cur_ptr, size, kind)\n             })?;\n         } else {\n             // Just treat this as one big chunk\n-            alloc.extra.check_deref(ptr, size, /*frozen*/false)?;\n+            let kind = if mutability == Some(MutMutable) { RefKind::Unique } else { RefKind::Raw };\n+            alloc.extra.deref(ptr, size, kind)?;\n         }\n \n         // All is good, and do not change the tag\n@@ -534,23 +555,20 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"self: {:?} is now accessible by raw pointers\", *place);\n+        trace!(\"escape_to_raw: {:?} is now accessible by raw pointers\", *place);\n         // Get the allocation\n-        let mut ptr = place.ptr.to_ptr()?;\n+        let ptr = place.ptr.to_ptr()?;\n         self.memory().check_bounds(ptr, size, false)?; // `ptr_dereference` wouldn't do any checks if this is a raw ptr\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n         // Re-borrow to raw.  This is a NOP for shared borrows, but we do not know the borrow\n         // type here and that's also okay.  Freezing does not matter here.\n-        alloc.extra.reactivate(ptr, size, UsageKind::Raw)?;\n-        ptr.tag = Borrow::default();\n-        alloc.extra.initiate(ptr, size, /*freeze*/false);\n-        Ok(())\n+        alloc.extra.reborrow(ptr, size, Borrow::default(), RefKind::Raw)\n     }\n \n-    fn retag_ptr(\n+    fn reborrow(\n         &mut self,\n         val: ImmTy<'tcx, Borrow>,\n-        mutbl: hir::Mutability,\n+        mutbl: Mutability,\n     ) -> EvalResult<'tcx, Immediate<Borrow>> {\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = self.ref_to_mplace(val)?;\n@@ -566,30 +584,29 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         let ptr = place.ptr.to_ptr()?;\n         let time = self.machine.stacked_borrows.increment_clock();\n         let new_bor = match mutbl {\n-            hir::MutMutable => Borrow::Uniq(time),\n-            hir::MutImmutable => Borrow::Shr(Some(time)),\n+            MutMutable => Borrow::Uniq(time),\n+            MutImmutable => Borrow::Shr(Some(time)),\n         };\n-        let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n-        trace!(\"retag: Creating new reference ({:?}) for {:?} (pointee {}): {:?}\",\n+        trace!(\"reborrow: Creating new {:?} reference for {:?} (pointee {}): {:?}\",\n             mutbl, ptr, place.layout.ty, new_bor);\n \n-        // Get the allocation\n-        self.memory().check_bounds(ptr, size, false)?; // `ptr_dereference` wouldn't do any checks if this is a raw ptr\n+        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n+        self.memory().check_bounds(ptr, size, false)?;\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        // Update the stacks.  First use old borrow, then initiate new one.\n-        alloc.extra.reactivate(ptr, size, Some(mutbl).into())?;\n-        if mutbl == hir::MutImmutable {\n-            // We need a frozen-sensitive initiate\n-            self.visit_freeze_sensitive(place, size, |mut cur_ptr, size, frozen| {\n-                cur_ptr.tag = new_bor;\n-                Ok(alloc.extra.initiate(cur_ptr, size, frozen))\n+        // Update the stacks.\n+        if mutbl == MutImmutable {\n+            // Shared reference. We need a frozen-sensitive reborrow.\n+            self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n+                alloc.extra.reborrow(cur_ptr, size, new_bor, kind)\n             })?;\n         } else {\n-            // Just treat this as one big chunk\n-            alloc.extra.initiate(new_ptr, size, /*frozen*/false);\n+            // Mutable reference. Just treat this as one big chunk.\n+            alloc.extra.reborrow(ptr, size, new_bor, RefKind::Unique)?;\n         }\n \n         // Return new ptr\n+        let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n         let new_place = MemPlace { ptr: Scalar::Ptr(new_ptr), ..*place };\n         Ok(new_place.to_ref())\n     }\n@@ -608,7 +625,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         };\n         // Retag the pointer and write it back.\n         let val = self.read_immediate(self.place_to_op(place)?)?;\n-        let val = self.retag_ptr(val, mutbl)?;\n+        let val = self.reborrow(val, mutbl)?;\n         self.write_immediate(val, place)?;\n         Ok(())\n     }"}, {"sha": "092f3f09ed196dff9f93b2675fb67221d05f744e", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -11,5 +11,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR reference with non-reactivatable tag\n+    let _val = *target_alias; //~ ERROR does not exist on the stack\n }"}, {"sha": "863649a47b5ef374d74d4fc21fb2f672d70694c9", "filename": "tests/compile-fail/stacked_borrows/illegal_read5.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -0,0 +1,16 @@\n+// We *can* have aliasing &RefCell<T> and &mut T, but we cannot read through the former.\n+// Else we couldn't optimize based on the assumption that `xref` below is truly unique.\n+\n+use std::cell::RefCell;\n+use std::{mem, ptr};\n+\n+fn main() {\n+    let rc = RefCell::new(0);\n+    let mut refmut = rc.borrow_mut();\n+    let xref: &mut i32 = &mut *refmut;\n+    let xshr = &rc; // creating this is okay\n+    let _val = *xref; // we can even still use our mutable reference\n+    mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref\n+    let _val = *xref; // the mutable one is dead and gone\n+    //~^ ERROR does not exist on the stack\n+}"}, {"sha": "b106cc8dc403cc7d8e0387263950c1c0ee538c45", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let target = Box::new(42); // has an implicit raw\n     let ref_ = &*target;\n     evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR is not frozen long enough\n+    let _x = *ref_; //~ ERROR is not frozen\n }"}, {"sha": "01559af21e7c64fbcea94f6923d9bba9d8cd8770", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n     unsafe { *ptr = 42; }\n-    let _val = *r#ref; //~ ERROR is not frozen long enough\n+    let _val = *r#ref; //~ ERROR is not frozen\n }"}, {"sha": "37ae0f055f0ee52ca6f4951d1e4ab226f3b775bb", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n     let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n     // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n-    let _val = *reference; //~ ERROR is not frozen long enough\n+    let _val = *reference; //~ ERROR is not frozen\n }"}, {"sha": "57b2ca87d810236ad8c75fb77bd79dd4ef63af90", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: reference with non-reactivatable tag\n+    //~^ ERROR: does not exist on the stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "98b9451eda87e77a2217ad9d043f9f7cb13ef5ee", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n-    let _val = *x; // invalidate xraw\n+    let _val = unsafe { *xraw }; // invalidate xref\n     let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n }"}, {"sha": "6599924f0f4c49e92c9fa0e36dbfbbdda8cb1179", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -4,6 +4,6 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n-    *x = 42; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n+    unsafe { *xraw = 42 }; // unfreeze\n+    let _val = *xref_in_mem; //~ ERROR is not frozen\n }"}, {"sha": "28288c6c63623154d91d8915f6900c665ea86325", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     let x = &mut 42;\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n-    let _val = *x; // invalidate xraw\n+    let _val = unsafe { *xraw }; // invalidate xref\n     foo(xref); //~ ERROR does not exist on the stack\n }"}, {"sha": "67bbc88e40fb0dc8a423a8d366618818d0b55831", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -3,8 +3,8 @@ fn foo(_: &i32) {}\n \n fn main() {\n     let x = &mut 42;\n-    let xraw = &*x as *const _;\n+    let xraw = &*x as *const _ as *mut _;\n     let xref = unsafe { &*xraw };\n-    *x = 42; // invalidate xraw\n-    foo(xref); //~ ERROR does not exist on the stack\n+    unsafe { *xraw = 42 }; // unfreeze\n+    foo(xref); //~ ERROR is not frozen\n }"}, {"sha": "e7f0b9bc9ddd0e127715a1e03373fca2b0b430f9", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -2,7 +2,7 @@\n fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n-    let _val = *x; // invalidate xraw and its children\n+    let _val = unsafe { *xraw }; // invalidate xref\n     ret //~ ERROR does not exist on the stack\n }\n "}, {"sha": "986dd18b2e0b4e1c1467c1bf68e1f9c69d4b2574", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -2,8 +2,8 @@\n fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n-    x.1 = 42; // invalidate xraw on the 2nd field\n-    ret //~ ERROR does not exist on the stack\n+    unsafe { *xraw = (42, 23) }; // unfreeze\n+    ret //~ ERROR is not frozen\n }\n \n fn main() {"}, {"sha": "f393fcb2c226fd2daeac2212419f8ce1b50f395c", "filename": "tests/compiletest.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -99,7 +99,9 @@ fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir:\n     flags.push(format!(\"--sysroot {}\", sysroot.display()));\n     flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n     if opt {\n-        flags.push(\"-Zmir-opt-level=3\".to_owned());\n+        // FIXME: We use opt level 1 because MIR inlining defeats the validation\n+        // whitelist.\n+        flags.push(\"-Zmir-opt-level=1\".to_owned());\n     }\n \n     let mut config = mk_config(\"ui\");"}, {"sha": "5f2f3523b96b1e916fb8c5bc79b5d60b1b03bd90", "filename": "tests/run-pass/refcell.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a87e9521029fdc319b5c86680d6645f411751943/tests%2Frun-pass%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a87e9521029fdc319b5c86680d6645f411751943/tests%2Frun-pass%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Frefcell.rs?ref=a87e9521029fdc319b5c86680d6645f411751943", "patch": "@@ -32,6 +32,23 @@ fn lots_of_funny_borrows() {\n     }\n }\n \n+fn aliasing_mut_and_shr() {\n+    fn inner(rc: &RefCell<i32>, aliasing: &mut i32) {\n+        *aliasing += 4;\n+        let _escape_to_raw = rc as *const _;\n+        *aliasing += 4;\n+        let _shr = &*rc;\n+        *aliasing += 4;\n+    }\n+\n+    let rc = RefCell::new(23);\n+    let mut bmut = rc.borrow_mut();\n+    inner(&rc, &mut *bmut);\n+    drop(bmut);\n+    assert_eq!(*rc.borrow(), 23+12);\n+}\n+\n fn main() {\n     lots_of_funny_borrows();\n+    aliasing_mut_and_shr();\n }"}]}