{"sha": "0311fe98e026579cd3581b7655e9ff84d4376682", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMTFmZTk4ZTAyNjU3OWNkMzU4MWI3NjU1ZTlmZjg0ZDQzNzY2ODI=", "commit": {"author": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2021-01-06T15:46:47Z"}, "committer": {"name": "Daniel Henry-Mantilla", "email": "daniel.henry.mantilla@gmail.com", "date": "2021-01-06T16:39:36Z"}, "message": "Fix rebase and clean up some code.", "tree": {"sha": "68002560063bd0f9dddaae2a7e6c09ac5c520b9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68002560063bd0f9dddaae2a7e6c09ac5c520b9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0311fe98e026579cd3581b7655e9ff84d4376682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0311fe98e026579cd3581b7655e9ff84d4376682", "html_url": "https://github.com/rust-lang/rust/commit/0311fe98e026579cd3581b7655e9ff84d4376682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0311fe98e026579cd3581b7655e9ff84d4376682/comments", "author": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "committer": {"login": "danielhenrymantilla", "id": 9920355, "node_id": "MDQ6VXNlcjk5MjAzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/9920355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/danielhenrymantilla", "html_url": "https://github.com/danielhenrymantilla", "followers_url": "https://api.github.com/users/danielhenrymantilla/followers", "following_url": "https://api.github.com/users/danielhenrymantilla/following{/other_user}", "gists_url": "https://api.github.com/users/danielhenrymantilla/gists{/gist_id}", "starred_url": "https://api.github.com/users/danielhenrymantilla/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/danielhenrymantilla/subscriptions", "organizations_url": "https://api.github.com/users/danielhenrymantilla/orgs", "repos_url": "https://api.github.com/users/danielhenrymantilla/repos", "events_url": "https://api.github.com/users/danielhenrymantilla/events{/privacy}", "received_events_url": "https://api.github.com/users/danielhenrymantilla/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4de27aeec7a8c876cce56561598898313a5a6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4de27aeec7a8c876cce56561598898313a5a6bf", "html_url": "https://github.com/rust-lang/rust/commit/a4de27aeec7a8c876cce56561598898313a5a6bf"}], "stats": {"total": 30, "additions": 8, "deletions": 22}, "files": [{"sha": "c559949f01e9d1e1aedc73839221bf12781900a2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0311fe98e026579cd3581b7655e9ff84d4376682/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0311fe98e026579cd3581b7655e9ff84d4376682/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=0311fe98e026579cd3581b7655e9ff84d4376682", "patch": "@@ -93,38 +93,24 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             });\n             // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n             // lookup the module by its name, by looking at each path segment one at a time.\n-            // Once #80415 is merged, this whole `for` loop research can be replaced by that.\n             let mut cur_mod = &mut top_level_module;\n             for path_segment in macro_parent_module.data {\n+                // Path segments may refer to a module (in which case they belong to the type\n+                // namespace), which is _necessary_ for the macro to be accessible outside it\n+                // (no \"associated macros\" as of yet). Else we bail with an outer `continue`.\n                 let path_segment_ty_ns = match path_segment.data {\n                     rustc_hir::definitions::DefPathData::TypeNs(symbol) => symbol,\n-                    _ => {\n-                        // If the path segment is not from the type namespace\n-                        // (_e.g._, it can be from a value namespace in the case of `f::` in:\n-                        // `fn f() { pub macro m() {} }`\n-                        // then the item is not accessible, and should thus act as if it didn't\n-                        // exist (unless \"associated macros\" (inside an `impl`) were a thing\u2026).\n-                        continue 'exported_macros;\n-                    }\n+                    _ => continue 'exported_macros,\n                 };\n-                // The obtained name in the type namespace may belong to something that is not\n-                // a `mod`ule (_e.g._, it could be an `enum` with a `pub macro` defined within\n-                // the block used for a discriminant.\n-                if let Some(child_mod) =\n-                    cur_mod.mods.iter_mut().find(|module| module.name == Some(path_segment_ty_ns))\n-                {\n-                    cur_mod = child_mod;\n-                } else {\n-                    // If the macro's parent def path is not exclusively made of module\n-                    // components, then it is not accessible (c.f. previous `continue`).\n-                    continue 'exported_macros;\n+                // Descend into the child module that matches this path segment (if any).\n+                match cur_mod.mods.iter_mut().find(|child| child.name == Some(path_segment_ty_ns)) {\n+                    Some(child_mod) => cur_mod = &mut *child_mod,\n+                    None => continue 'exported_macros,\n                 }\n             }\n             cur_mod.macros.push((def, None));\n         }\n-\n         self.cx.renderinfo.get_mut().exact_paths = self.exact_paths;\n-\n         top_level_module\n     }\n "}]}