{"sha": "9e5d497b67c7566001bdcfc8a2767f26a23afc5b", "node_id": "C_kwDOAAsO6NoAKDllNWQ0OTdiNjdjNzU2NjAwMWJkY2ZjOGEyNzY3ZjI2YTIzYWZjNWI", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-15T14:55:37Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:57:58Z"}, "message": "fix const `align_offset` implementation", "tree": {"sha": "40f67744bf21fc7695364393f9496114029cffce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40f67744bf21fc7695364393f9496114029cffce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e5d497b67c7566001bdcfc8a2767f26a23afc5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e5d497b67c7566001bdcfc8a2767f26a23afc5b", "html_url": "https://github.com/rust-lang/rust/commit/9e5d497b67c7566001bdcfc8a2767f26a23afc5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e5d497b67c7566001bdcfc8a2767f26a23afc5b/comments", "author": null, "committer": null, "parents": [{"sha": "8717455b9dd5f56d42d605ae7c0b657070cf4774", "url": "https://api.github.com/repos/rust-lang/rust/commits/8717455b9dd5f56d42d605ae7c0b657070cf4774", "html_url": "https://github.com/rust-lang/rust/commit/8717455b9dd5f56d42d605ae7c0b657070cf4774"}], "stats": {"total": 113, "additions": 69, "deletions": 44}, "files": [{"sha": "92ccc94e6302432a77d8aae462945faa720560a7", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e5d497b67c7566001bdcfc8a2767f26a23afc5b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e5d497b67c7566001bdcfc8a2767f26a23afc5b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=9e5d497b67c7566001bdcfc8a2767f26a23afc5b", "patch": "@@ -278,9 +278,8 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             return u64::MAX;\n         }\n \n-        let byte_offset = align - addr_mod_align;\n-\n         if align % stride == 0 {\n+            let byte_offset = align - addr_mod_align;\n             if byte_offset % stride == 0 {\n                 return byte_offset / stride;\n             } else {\n@@ -296,8 +295,11 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             return u64::MAX;\n         }\n \n+        // Instead of `(addr + offset * stride) % align == 0`, we solve\n+        // `((addr + offset * stride) / gcd) % (align / gcd) == 0`.\n+        let addr2 = addr / gcd;\n         let align2 = align / gcd;\n-        let stride2 = (stride / gcd) % align2;\n+        let stride2 = stride / gcd;\n \n         let mut stride_inv = 1u64;\n         let mut mod_gate = 2u64;\n@@ -308,6 +310,7 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n             (mod_gate, overflow) = mod_gate.overflowing_mul(mod_gate);\n         }\n \n+        let byte_offset = align2 - addr2 % align2;\n         byte_offset.wrapping_mul(stride_inv) % align2\n     }\n "}, {"sha": "036acc46daba8fa495370a1d00c8883f94263026", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9e5d497b67c7566001bdcfc8a2767f26a23afc5b/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e5d497b67c7566001bdcfc8a2767f26a23afc5b/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=9e5d497b67c7566001bdcfc8a2767f26a23afc5b", "patch": "@@ -510,49 +510,53 @@ fn align_offset_various_strides_const() {\n         assert!(got == expected);\n     }\n \n-    // For pointers of stride != 1, we verify the algorithm against the naivest possible\n-    // implementation\n-    let mut align = 1;\n-    let limit = 1024;\n-    while align < limit {\n-        for ptr in 1usize..4 * align {\n-            unsafe {\n-                #[repr(packed)]\n-                struct A3(u16, u8);\n-                test_stride::<A3>(ptr::invalid::<A3>(ptr), ptr, align);\n-\n-                struct A4(u32);\n-                test_stride::<A4>(ptr::invalid::<A4>(ptr), ptr, align);\n-\n-                #[repr(packed)]\n-                struct A5(u32, u8);\n-                test_stride::<A5>(ptr::invalid::<A5>(ptr), ptr, align);\n-\n-                #[repr(packed)]\n-                struct A6(u32, u16);\n-                test_stride::<A6>(ptr::invalid::<A6>(ptr), ptr, align);\n-\n-                #[repr(packed)]\n-                struct A7(u32, u16, u8);\n-                test_stride::<A7>(ptr::invalid::<A7>(ptr), ptr, align);\n-\n-                #[repr(packed)]\n-                struct A8(u32, u32);\n-                test_stride::<A8>(ptr::invalid::<A8>(ptr), ptr, align);\n-\n-                #[repr(packed)]\n-                struct A9(u32, u32, u8);\n-                test_stride::<A9>(ptr::invalid::<A9>(ptr), ptr, align);\n-\n-                #[repr(packed)]\n-                struct A10(u32, u32, u16);\n-                test_stride::<A10>(ptr::invalid::<A10>(ptr), ptr, align);\n-\n-                test_stride::<u32>(ptr::invalid::<u32>(ptr), ptr, align);\n-                test_stride::<u128>(ptr::invalid::<u128>(ptr), ptr, align);\n+    const {\n+        // For pointers of stride != 1, we verify the algorithm against the naivest possible\n+        // implementation\n+        let mut align = 1;\n+        let limit = 32;\n+        while align < limit {\n+            let mut ptr = 1;\n+            while ptr < 4 * align {\n+                unsafe {\n+                    #[repr(packed)]\n+                    struct A3(u16, u8);\n+                    test_stride::<A3>(ptr::invalid::<A3>(ptr), ptr, align);\n+\n+                    struct A4(u32);\n+                    test_stride::<A4>(ptr::invalid::<A4>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A5(u32, u8);\n+                    test_stride::<A5>(ptr::invalid::<A5>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A6(u32, u16);\n+                    test_stride::<A6>(ptr::invalid::<A6>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A7(u32, u16, u8);\n+                    test_stride::<A7>(ptr::invalid::<A7>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A8(u32, u32);\n+                    test_stride::<A8>(ptr::invalid::<A8>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A9(u32, u32, u8);\n+                    test_stride::<A9>(ptr::invalid::<A9>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A10(u32, u32, u16);\n+                    test_stride::<A10>(ptr::invalid::<A10>(ptr), ptr, align);\n+\n+                    test_stride::<u32>(ptr::invalid::<u32>(ptr), ptr, align);\n+                    test_stride::<u128>(ptr::invalid::<u128>(ptr), ptr, align);\n+                }\n+                ptr += 1;\n             }\n+            align = (align + 1).next_power_of_two();\n         }\n-        align = (align + 1).next_power_of_two();\n     }\n }\n \n@@ -632,6 +636,24 @@ fn align_offset_issue_103361() {\n     let _ = (SIZE as *const HugeSize).align_offset(SIZE);\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_issue_103361_const() {\n+    #[cfg(target_pointer_width = \"64\")]\n+    const SIZE: usize = 1 << 47;\n+    #[cfg(target_pointer_width = \"32\")]\n+    const SIZE: usize = 1 << 30;\n+    #[cfg(target_pointer_width = \"16\")]\n+    const SIZE: usize = 1 << 13;\n+    struct HugeSize([u8; SIZE - 1]);\n+\n+    const {\n+        assert!(ptr::invalid::<HugeSize>(SIZE - 1).align_offset(SIZE) == SIZE - 1);\n+        assert!(ptr::invalid::<HugeSize>(SIZE).align_offset(SIZE) == 0);\n+        assert!(ptr::invalid::<HugeSize>(SIZE + 1).align_offset(SIZE) == 1);\n+    }\n+}\n+\n #[test]\n fn is_aligned() {\n     let data = 42;"}]}