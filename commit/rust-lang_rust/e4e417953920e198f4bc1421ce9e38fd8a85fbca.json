{"sha": "e4e417953920e198f4bc1421ce9e38fd8a85fbca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZTQxNzk1MzkyMGUxOThmNGJjMTQyMWNlOWUzOGZkOGE4NWZiY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-03T08:51:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-03T08:51:21Z"}, "message": "Auto merge of #86454 - tlyu:refactor-unsized-suggestions, r=davidtwco\n\nRefactor unsized suggestions\n\n`@rustbot` label +A-diagnostics +A-traits +A-typesystem +C-cleanup +T-compiler", "tree": {"sha": "569ced1d7888ca36391b58f128251992823fa6cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/569ced1d7888ca36391b58f128251992823fa6cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4e417953920e198f4bc1421ce9e38fd8a85fbca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e417953920e198f4bc1421ce9e38fd8a85fbca", "html_url": "https://github.com/rust-lang/rust/commit/e4e417953920e198f4bc1421ce9e38fd8a85fbca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4e417953920e198f4bc1421ce9e38fd8a85fbca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbdff7fae941bce21fd3047f87777c84b866850e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdff7fae941bce21fd3047f87777c84b866850e", "html_url": "https://github.com/rust-lang/rust/commit/fbdff7fae941bce21fd3047f87777c84b866850e"}, {"sha": "3252432c27c8ff14f52ce04fa08c6bb73ce40ebe", "url": "https://api.github.com/repos/rust-lang/rust/commits/3252432c27c8ff14f52ce04fa08c6bb73ce40ebe", "html_url": "https://github.com/rust-lang/rust/commit/3252432c27c8ff14f52ce04fa08c6bb73ce40ebe"}], "stats": {"total": 179, "additions": 112, "deletions": 67}, "files": [{"sha": "9ce6c58a0f1df4b81b08fbb494dff3458169a230", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 112, "deletions": 67, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e4e417953920e198f4bc1421ce9e38fd8a85fbca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4e417953920e198f4bc1421ce9e38fd8a85fbca/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e4e417953920e198f4bc1421ce9e38fd8a85fbca", "patch": "@@ -16,6 +16,8 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder,\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n+use rustc_hir::GenericParam;\n+use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_middle::mir::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -1138,6 +1140,20 @@ trait InferCtxtPrivExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     );\n \n+    fn maybe_suggest_unsized_generics(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        node: Node<'hir>,\n+    );\n+\n+    fn maybe_indirection_for_unsized(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        item: &'hir Item<'hir>,\n+        param: &'hir GenericParam<'hir>,\n+    ) -> bool;\n+\n     fn is_recursive_obligation(\n         &self,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n@@ -1816,88 +1832,116 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ) => (pred, item_def_id, span),\n                 _ => return,\n             };\n-\n+        debug!(\n+            \"suggest_unsized_bound_if_applicable: pred={:?} item_def_id={:?} span={:?}\",\n+            pred, item_def_id, span\n+        );\n         let node = match (\n             self.tcx.hir().get_if_local(item_def_id),\n             Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n         ) {\n             (Some(node), true) => node,\n             _ => return,\n         };\n+        self.maybe_suggest_unsized_generics(err, span, node);\n+    }\n+\n+    fn maybe_suggest_unsized_generics(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        node: Node<'hir>,\n+    ) {\n         let generics = match node.generics() {\n             Some(generics) => generics,\n             None => return,\n         };\n-        for param in generics.params {\n-            if param.span != span\n-                || param.bounds.iter().any(|bound| {\n-                    bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n-                        == self.tcx.lang_items().sized_trait()\n-                })\n-            {\n-                continue;\n-            }\n-            match node {\n-                hir::Node::Item(\n-                    item\n-                    @\n-                    hir::Item {\n-                        kind:\n-                            hir::ItemKind::Enum(..)\n-                            | hir::ItemKind::Struct(..)\n-                            | hir::ItemKind::Union(..),\n-                        ..\n-                    },\n-                ) => {\n-                    // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n-                    // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n-                    // is not.\n-                    let mut visitor = FindTypeParam {\n-                        param: param.name.ident().name,\n-                        invalid_spans: vec![],\n-                        nested: false,\n-                    };\n-                    visitor.visit_item(item);\n-                    if !visitor.invalid_spans.is_empty() {\n-                        let mut multispan: MultiSpan = param.span.into();\n-                        multispan.push_span_label(\n-                            param.span,\n-                            format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n-                        );\n-                        for sp in visitor.invalid_spans {\n-                            multispan.push_span_label(\n-                                sp,\n-                                format!(\n-                                    \"...if indirection were used here: `Box<{}>`\",\n-                                    param.name.ident(),\n-                                ),\n-                            );\n-                        }\n-                        err.span_help(\n-                            multispan,\n-                            &format!(\n-                                \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n-                                 used through indirection like `&{T}` or `Box<{T}>`\",\n-                                T = param.name.ident(),\n-                            ),\n-                        );\n-                        return;\n-                    }\n+        let sized_trait = self.tcx.lang_items().sized_trait();\n+        debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n+        debug!(\"maybe_suggest_unsized_generics: generics.where_clause={:?}\", generics.where_clause);\n+        let param = generics\n+            .params\n+            .iter()\n+            .filter(|param| param.span == span)\n+            .filter(|param| {\n+                // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n+                // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n+                param\n+                    .bounds\n+                    .iter()\n+                    .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n+            })\n+            .next();\n+        let param = match param {\n+            Some(param) => param,\n+            _ => return,\n+        };\n+        debug!(\"maybe_suggest_unsized_generics: param={:?}\", param);\n+        match node {\n+            hir::Node::Item(\n+                item\n+                @\n+                hir::Item {\n+                    // Only suggest indirection for uses of type parameters in ADTs.\n+                    kind:\n+                        hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) | hir::ItemKind::Union(..),\n+                    ..\n+                },\n+            ) => {\n+                if self.maybe_indirection_for_unsized(err, item, param) {\n+                    return;\n                 }\n-                _ => {}\n             }\n-            let (span, separator) = match param.bounds {\n-                [] => (span.shrink_to_hi(), \":\"),\n-                [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n-            };\n-            err.span_suggestion_verbose(\n-                span,\n-                \"consider relaxing the implicit `Sized` restriction\",\n-                format!(\"{} ?Sized\", separator),\n-                Applicability::MachineApplicable,\n+            _ => {}\n+        };\n+        // Didn't add an indirection suggestion, so add a general suggestion to relax `Sized`.\n+        let (span, separator) = match param.bounds {\n+            [] => (span.shrink_to_hi(), \":\"),\n+            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+        };\n+        err.span_suggestion_verbose(\n+            span,\n+            \"consider relaxing the implicit `Sized` restriction\",\n+            format!(\"{} ?Sized\", separator),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    fn maybe_indirection_for_unsized(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        item: &'hir Item<'hir>,\n+        param: &'hir GenericParam<'hir>,\n+    ) -> bool {\n+        // Suggesting `T: ?Sized` is only valid in an ADT if `T` is only used in a\n+        // borrow. `struct S<'a, T: ?Sized>(&'a T);` is valid, `struct S<T: ?Sized>(T);`\n+        // is not. Look for invalid \"bare\" parameter uses, and suggest using indirection.\n+        let mut visitor =\n+            FindTypeParam { param: param.name.ident().name, invalid_spans: vec![], nested: false };\n+        visitor.visit_item(item);\n+        if visitor.invalid_spans.is_empty() {\n+            return false;\n+        }\n+        let mut multispan: MultiSpan = param.span.into();\n+        multispan.push_span_label(\n+            param.span,\n+            format!(\"this could be changed to `{}: ?Sized`...\", param.name.ident()),\n+        );\n+        for sp in visitor.invalid_spans {\n+            multispan.push_span_label(\n+                sp,\n+                format!(\"...if indirection were used here: `Box<{}>`\", param.name.ident()),\n             );\n-            return;\n         }\n+        err.span_help(\n+            multispan,\n+            &format!(\n+                \"you could relax the implicit `Sized` bound on `{T}` if it were \\\n+                used through indirection like `&{T}` or `Box<{T}>`\",\n+                T = param.name.ident(),\n+            ),\n+        );\n+        true\n     }\n \n     fn is_recursive_obligation(\n@@ -1948,6 +1992,7 @@ impl<'v> Visitor<'v> for FindTypeParam {\n                 if path.segments.len() == 1 && path.segments[0].ident.name == self.param =>\n             {\n                 if !self.nested {\n+                    debug!(\"FindTypeParam::visit_ty: ty={:?}\", ty);\n                     self.invalid_spans.push(ty.span);\n                 }\n             }"}]}