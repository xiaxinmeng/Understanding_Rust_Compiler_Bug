{"sha": "cab7e7fe76c3c881078f068a8da4a863efdd2c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYjdlN2ZlNzZjM2M4ODEwNzhmMDY4YThkYTRhODYzZWZkZDJjNzc=", "commit": {"author": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2019-05-13T17:52:55Z"}, "committer": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2019-06-08T20:58:53Z"}, "message": "Validate and transcribe raw strings via unescape module", "tree": {"sha": "f10939fce4b481ff04951e69c56293e9a7377e56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f10939fce4b481ff04951e69c56293e9a7377e56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cab7e7fe76c3c881078f068a8da4a863efdd2c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cab7e7fe76c3c881078f068a8da4a863efdd2c77", "html_url": "https://github.com/rust-lang/rust/commit/cab7e7fe76c3c881078f068a8da4a863efdd2c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cab7e7fe76c3c881078f068a8da4a863efdd2c77/comments", "author": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08ede49dcb0ae9a085f1cb8ccf6bc0ba682c83e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ede49dcb0ae9a085f1cb8ccf6bc0ba682c83e7", "html_url": "https://github.com/rust-lang/rust/commit/08ede49dcb0ae9a085f1cb8ccf6bc0ba682c83e7"}], "stats": {"total": 113, "additions": 63, "deletions": 50}, "files": [{"sha": "e3830b1e3b6682ebc922386feb9c217ebaf67467", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=cab7e7fe76c3c881078f068a8da4a863efdd2c77", "patch": "@@ -1086,10 +1086,12 @@ impl<'a> StringReader<'a> {\n                 Ok(TokenKind::lit(token::Str, symbol, suffix))\n             }\n             'r' => {\n-                let (kind, symbol) = self.scan_raw_string();\n+                let (start, end, hash_count) = self.scan_raw_string();\n+                let symbol = self.name_from_to(start, end);\n+                self.validate_raw_str_escape(start, end);\n                 let suffix = self.scan_optional_raw_name();\n \n-                Ok(TokenKind::lit(kind, symbol, suffix))\n+                Ok(TokenKind::lit(token::StrRaw(hash_count), symbol, suffix))\n             }\n             '-' => {\n                 if self.nextch_is('>') {\n@@ -1243,7 +1245,7 @@ impl<'a> StringReader<'a> {\n         id\n     }\n \n-    fn scan_raw_string(&mut self) -> (token::LitKind, Symbol) {\n+    fn scan_raw_string(&mut self) -> (BytePos, BytePos, u16) {\n         let start_bpos = self.pos;\n         self.bump();\n         let mut hash_count: u16 = 0;\n@@ -1273,7 +1275,6 @@ impl<'a> StringReader<'a> {\n         self.bump();\n         let content_start_bpos = self.pos;\n         let mut content_end_bpos;\n-        let mut valid = true;\n         'outer: loop {\n             match self.ch {\n                 None => {\n@@ -1289,29 +1290,14 @@ impl<'a> StringReader<'a> {\n                     }\n                     break;\n                 }\n-                Some(c) => {\n-                    if c == '\\r' && !self.nextch_is('\\n') {\n-                        let last_bpos = self.pos;\n-                        self.err_span_(start_bpos,\n-                                        last_bpos,\n-                                        \"bare CR not allowed in raw string, use \\\\r \\\n-                                        instead\");\n-                        valid = false;\n-                    }\n-                }\n+                _ => (),\n             }\n             self.bump();\n         }\n \n         self.bump();\n \n-        let symbol = if valid {\n-            self.name_from_to(content_start_bpos, content_end_bpos)\n-        } else {\n-            Symbol::intern(\"??\")\n-        };\n-\n-        (token::StrRaw(hash_count), symbol)\n+        (content_start_bpos, content_end_bpos, hash_count)\n     }\n \n     fn scan_raw_byte_string(&mut self) -> (token::LitKind, Symbol) {\n@@ -1421,6 +1407,23 @@ impl<'a> StringReader<'a> {\n         });\n     }\n \n+    fn validate_raw_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        self.with_str_from_to(content_start, content_end, |lit: &str| {\n+            unescape::unescape_raw_str(lit, &mut |range, c| {\n+                if let Err(err) = c {\n+                    emit_unescape_error(\n+                        &self.sess.span_diagnostic,\n+                        lit,\n+                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                        unescape::Mode::Str,\n+                        range,\n+                        err,\n+                    )\n+                }\n+            })\n+        });\n+    }\n+\n     fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n         self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n             unescape::unescape_byte_str(lit, &mut |range, c| {"}, {"sha": "3a2d905585c0edd5345d9feaf4d7dc247eba0e6c", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=cab7e7fe76c3c881078f068a8da4a863efdd2c77", "patch": "@@ -4,7 +4,8 @@ use crate::ast::{self, Lit, LitKind};\n use crate::parse::parser::Parser;\n use crate::parse::PResult;\n use crate::parse::token::{self, Token, TokenKind};\n-use crate::parse::unescape::{unescape_str, unescape_char, unescape_byte_str, unescape_byte};\n+use crate::parse::unescape::{unescape_str, unescape_byte_str, unescape_raw_str};\n+use crate::parse::unescape::{unescape_char, unescape_byte};\n use crate::print::pprust;\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{TokenStream, TokenTree};\n@@ -141,7 +142,17 @@ impl LitKind {\n                 // Ditto.\n                 let s = symbol.as_str();\n                 let symbol = if s.contains('\\r') {\n-                    Symbol::intern(&raw_str_lit(&s))\n+                    let mut buf = String::with_capacity(s.len());\n+                    let mut error = Ok(());\n+                    unescape_raw_str(&s, &mut |_, unescaped_char| {\n+                        match unescaped_char {\n+                            Ok(c) => buf.push(c),\n+                            Err(_) => error = Err(LitError::LexerError),\n+                        }\n+                    });\n+                    error?;\n+                    buf.shrink_to_fit();\n+                    Symbol::intern(&buf)\n                 } else {\n                     symbol\n                 };\n@@ -350,29 +361,6 @@ crate fn expect_no_suffix(diag: &Handler, sp: Span, kind: &str, suffix: Option<S\n     }\n }\n \n-/// Parses a string representing a raw string literal into its final form. The\n-/// only operation this does is convert embedded CRLF into a single LF.\n-fn raw_str_lit(lit: &str) -> String {\n-    debug!(\"raw_str_lit: {:?}\", lit);\n-    let mut res = String::with_capacity(lit.len());\n-\n-    let mut chars = lit.chars().peekable();\n-    while let Some(c) = chars.next() {\n-        if c == '\\r' {\n-            if *chars.peek().unwrap() != '\\n' {\n-                panic!(\"lexer accepted bare CR\");\n-            }\n-            chars.next();\n-            res.push('\\n');\n-        } else {\n-            res.push(c);\n-        }\n-    }\n-\n-    res.shrink_to_fit();\n-    res\n-}\n-\n // Checks if `s` looks like i32 or u1234 etc.\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 && s.starts_with(first_chars) && s[1..].chars().all(|c| c.is_ascii_digit())"}, {"sha": "d6b7db16305bb33880b94b1f983d4a01af654934", "filename": "src/libsyntax/parse/unescape.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Flibsyntax%2Fparse%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Flibsyntax%2Fparse%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape.rs?ref=cab7e7fe76c3c881078f068a8da4a863efdd2c77", "patch": "@@ -66,6 +66,28 @@ where\n     })\n }\n \n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of characters or errors.\n+/// NOTE: Raw strings do not perform any explicit character escaping, here we\n+/// only translate CRLF to LF and produce errors on bare CR.\n+pub(crate) fn unescape_raw_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    let mut byte_offset: usize = 0;\n+\n+    let mut chars = literal_text.chars().peekable();\n+    while let Some(curr) = chars.next() {\n+        let result = match (curr, chars.peek()) {\n+            ('\\r', Some('\\n')) => Ok(curr),\n+            ('\\r', _) => Err(EscapeError::BareCarriageReturn),\n+            _ => Ok(curr),\n+        };\n+        callback(byte_offset..(byte_offset + curr.len_utf8()), result);\n+        byte_offset += curr.len_utf8();\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub(crate) enum Mode {\n     Char,"}, {"sha": "ed5df42f9dd4ed1f35227f3e87a5d8e097fd5b3e", "filename": "src/test/ui/parser/lex-bare-cr-string-literal-doc-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.rs?ref=cab7e7fe76c3c881078f068a8da4a863efdd2c77", "patch": "@@ -21,7 +21,7 @@ fn main() {\n     let _s = \"foo\rbar\"; //~ ERROR: bare CR not allowed in string\n \n     // the following string literal has a bare CR in it\n-    let _s = r\"bar\rfoo\"; //~ ERROR: bare CR not allowed in raw string\n+    let _s = r\"bar\rfoo\"; //~ ERROR: bare CR not allowed in string\n \n     // the following string literal has a bare CR in it\n     let _s = \"foo\\\rbar\"; //~ ERROR: unknown character escape: \\r"}, {"sha": "153237a7f71b4b80ea06b053f2f625ae17590e8a", "filename": "src/test/ui/parser/lex-bare-cr-string-literal-doc-comment.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cab7e7fe76c3c881078f068a8da4a863efdd2c77/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flex-bare-cr-string-literal-doc-comment.stderr?ref=cab7e7fe76c3c881078f068a8da4a863efdd2c77", "patch": "@@ -28,11 +28,11 @@ error: bare CR not allowed in string, use \\r instead\n LL |     let _s = \"foo\rbar\";\n    |                  ^\n \n-error: bare CR not allowed in raw string, use \\r instead\n-  --> $DIR/lex-bare-cr-string-literal-doc-comment.rs:24:14\n+error: bare CR not allowed in string, use \\r instead\n+  --> $DIR/lex-bare-cr-string-literal-doc-comment.rs:24:19\n    |\n LL |     let _s = r\"bar\rfoo\";\n-   |              ^^^^^\n+   |                   ^\n \n error: unknown character escape: \\r\n   --> $DIR/lex-bare-cr-string-literal-doc-comment.rs:27:19"}]}