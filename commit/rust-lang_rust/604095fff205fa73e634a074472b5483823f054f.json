{"sha": "604095fff205fa73e634a074472b5483823f054f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNDA5NWZmZjIwNWZhNzNlNjM0YTA3NDQ3MmI1NDgzODIzZjA1NGY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-13T07:12:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-13T07:12:11Z"}, "message": "Merge branch 'master' into format-padding", "tree": {"sha": "0d72cf1f10a37e1a4546784488fff03a35d28e88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d72cf1f10a37e1a4546784488fff03a35d28e88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/604095fff205fa73e634a074472b5483823f054f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcY8NLCRBK7hj4Ov3rIwAAdHIIAK5DBrLhMYtXiNEdFeuDKwqt\nc2Up8s1eBkbsbanv4/MyddCNmp+/28OeFlkcFkOlrkZNiSAmXK8M/oJ93HHRI3rE\nh/BjTvCQdu9fdsutIugvpM/aiwZJFlbNGfeV9n2tfVLsYJgItx77Vcy/o3vbFtIM\ncCDqtwE1ghBj2XeahvSaZA43DSTGp45v2zVva1VVo96MnIphvVLKXbhGw/SdfJ9y\nBScrlOcX/GFMDRjsxwjD9pfC5NutroIT2lm2l/6bnZYvxmpAQUnRA+iD2laG+NF0\nGib1aH812XrK/xF8YaffzIIBukjBSqDxB8oz9DiMoZWYRj6dNonK4HiM9HpQV6U=\n=Rf3H\n-----END PGP SIGNATURE-----\n", "payload": "tree 0d72cf1f10a37e1a4546784488fff03a35d28e88\nparent 7827924bfc920bc171f3c68e25dc47065f5ae6e4\nparent 4816bfb774dcd3c72751eba8cff67615788ab488\nauthor Ralf Jung <post@ralfj.de> 1550041931 +0100\ncommitter GitHub <noreply@github.com> 1550041931 +0100\n\nMerge branch 'master' into format-padding"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/604095fff205fa73e634a074472b5483823f054f", "html_url": "https://github.com/rust-lang/rust/commit/604095fff205fa73e634a074472b5483823f054f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/604095fff205fa73e634a074472b5483823f054f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7827924bfc920bc171f3c68e25dc47065f5ae6e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7827924bfc920bc171f3c68e25dc47065f5ae6e4", "html_url": "https://github.com/rust-lang/rust/commit/7827924bfc920bc171f3c68e25dc47065f5ae6e4"}, {"sha": "4816bfb774dcd3c72751eba8cff67615788ab488", "url": "https://api.github.com/repos/rust-lang/rust/commits/4816bfb774dcd3c72751eba8cff67615788ab488", "html_url": "https://github.com/rust-lang/rust/commit/4816bfb774dcd3c72751eba8cff67615788ab488"}], "stats": {"total": 394, "additions": 260, "deletions": 134}, "files": [{"sha": "a46214a3c45c61b42f71005f5651942a6fcc5590", "filename": ".appveyor.yml", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/.appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/.appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.appveyor.yml?ref=604095fff205fa73e634a074472b5483823f054f", "previous_filename": "appveyor.yml"}, {"sha": "721ebe5cfd46b972a7241d1039081aeb2eb81a03", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -39,6 +39,7 @@ directories = { version = \"1.0\", optional = true }\n rustc_version = { version = \"0.2.3\", optional = true }\n env_logger = \"0.6\"\n log = \"0.4\"\n+shell-escape = \"0.1.4\"\n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n # for more information."}, {"sha": "21e9fa43a8f8c55ec53ea6759de1dc73154928e2", "filename": "README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -48,6 +48,13 @@ Now you can run your project in Miri:\n 3. If you have a binary project, you can run it through Miri using `cargo\n    +nightly miri run`.\n \n+You can pass arguments to Miri after the first `--`, and pass arguments to the\n+interpreted program or test suite after the second `--`.  For example, `cargo\n++nightly miri run -- -Zmiri-disable-validation` runs the program without\n+validation of basic type invariants and references.  `cargo +nightly miri test\n+-- -- filter` passes `filter` to the test suite the same way `cargo test filter`\n+would.\n+\n When running code via `cargo miri`, the `miri` config flag is set.  You can\n use this to exclude test cases that will fail under Miri because they do things\n Miri does not support:"}, {"sha": "404fe7ae91501928f0b86740aa61af7323a8cd44", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -4,11 +4,13 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate test;\n \n-use self::miri::eval_main;\n-use self::rustc_driver::{driver, Compilation};\n+use rustc_driver::{driver, Compilation};\n use rustc::hir::def_id::LOCAL_CRATE;\n use std::cell::RefCell;\n use std::rc::Rc;\n+\n+use miri::{MiriConfig, eval_main};\n+\n use crate::test::Bencher;\n \n pub struct MiriCompilerCalls<'a>(Rc<RefCell<&'a mut Bencher>>);\n@@ -50,7 +52,8 @@ pub fn run(filename: &str, bencher: &mut Bencher) {\n         );\n \n         bencher.borrow_mut().iter(|| {\n-            eval_main(tcx, entry_def_id, false);\n+            let config = MiriConfig { validate: true, args: vec![] };\n+            eval_main(tcx, entry_def_id, config);\n         });\n \n         state.session.abort_if_errors();"}, {"sha": "93200f33a260644e477789b2a5ba8738c3f8e1f8", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -10,7 +10,7 @@ use std::fs::{self, File};\n const CARGO_MIRI_HELP: &str = r#\"Interprets bin crates and tests in Miri\n \n Usage:\n-    cargo miri [subcommand] [options] [--] [<miri opts>...]\n+    cargo miri [subcommand] [options] [--] [<miri opts>...] [--] [<program opts>...]\n \n Subcommands:\n     run                      Run binaries (default)\n@@ -22,8 +22,9 @@ Common options:\n     --features               Features to compile for the package\n     -V, --version            Print version info and exit\n \n-Other [options] are the same as `cargo rustc`.  Everything after the \"--\" is\n-passed verbatim to Miri.\n+Other [options] are the same as `cargo rustc`.  Everything after the first \"--\" is\n+passed verbatim to Miri, which will pass everything after the second \"--\" verbatim\n+to the interpreted program.\n \n The config flag `miri` is automatically defined for convenience. You can use\n it to configure the resource limits\n@@ -355,11 +356,13 @@ fn in_cargo_miri() {\n             }\n             cmd.arg(arg);\n         }\n-        // add \"--\" \"-Zcargo-miri-marker\" and the remaining user flags\n+        // Add \"--\" (to end the cargo flags), and then the user flags.  We add markers around the user flags\n+        // to be able to identify them later.\n         cmd\n             .arg(\"--\")\n-            .arg(\"cargo-miri-marker\")\n-            .args(args);\n+            .arg(\"cargo-miri-marker-begin\")\n+            .args(args)\n+            .arg(\"cargo-miri-marker-end\");\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {\n@@ -413,10 +416,19 @@ fn inside_cargo_rustc() {\n     };\n     args.splice(0..0, miri::miri_default_args().iter().map(ToString::to_string));\n \n-    // see if we have cargo-miri-marker, which means we want to interpret this crate in Miri\n-    // (and remove the marker).\n-    let needs_miri = if let Some(pos) = args.iter().position(|arg| arg == \"cargo-miri-marker\") {\n-        args.remove(pos);\n+    // See if we can find the cargo-miri markers.  Those only get added to the binary we want to\n+    // run.  They also serve to mark the user-defined arguments, which we have to move all the way to the\n+    // end (they get added somewhere in the middle).\n+    let needs_miri = if let Some(begin) = args.iter().position(|arg| arg == \"cargo-miri-marker-begin\") {\n+        let end = args.iter().position(|arg| arg == \"cargo-miri-marker-end\").expect(\"Cannot find end marker\");\n+        // These mark the user arguments.  We remove the first and last as they are the markers.\n+        let mut user_args = args.drain(begin..=end);\n+        assert_eq!(user_args.next().unwrap(), \"cargo-miri-marker-begin\");\n+        assert_eq!(user_args.next_back().unwrap(), \"cargo-miri-marker-end\");\n+        // Collect the rest and add it back at the end\n+        let mut user_args = user_args.collect::<Vec<String>>();\n+        args.append(&mut user_args);\n+        // Run this in Miri\n         true\n     } else {\n         false"}, {"sha": "3a70577cb7f22c00f0a02f4a0bb125ba987ecc12", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -25,6 +25,8 @@ use rustc::ty::TyCtxt;\n use syntax::ast;\n use rustc::hir::def_id::LOCAL_CRATE;\n \n+use miri::MiriConfig;\n+\n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n     /// whether we are building for the host\n@@ -94,9 +96,10 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n             fn visit_item(&mut self, i: &'hir hir::Item) {\n                 if let hir::ItemKind::Fn(.., body_id) = i.node {\n                     if i.attrs.iter().any(|attr| attr.name() == \"test\") {\n+                        let config = MiriConfig { validate: true, args: vec![] };\n                         let did = self.0.hir().body_owner_def_id(body_id);\n                         println!(\"running test: {}\", self.0.def_path_debug_str(did));\n-                        miri::eval_main(self.0, did, /*validate*/true);\n+                        miri::eval_main(self.0, did, config);\n                         self.1.session.abort_if_errors();\n                     }\n                 }\n@@ -106,7 +109,8 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         }\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(tcx, state));\n     } else if let Some((entry_def_id, _)) = tcx.entry_fn(LOCAL_CRATE) {\n-        miri::eval_main(tcx, entry_def_id, /*validate*/true);\n+        let config = MiriConfig { validate: true, args: vec![] };\n+        miri::eval_main(tcx, entry_def_id, config);\n \n         state.session.abort_if_errors();\n     } else {"}, {"sha": "31bd1deb10f57e6c3df135caa65f75dc39a13bc7", "filename": "src/bin/miri.rs", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -27,11 +27,11 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::hir::def_id::LOCAL_CRATE;\n use syntax::ast;\n \n+use miri::MiriConfig;\n+\n struct MiriCompilerCalls {\n     default: Box<RustcDefaultCalls>,\n-\n-    /// Whether to enforce the validity invariant.\n-    validate: bool,\n+    miri_config: MiriConfig,\n }\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n@@ -79,6 +79,8 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         odir: &Option<PathBuf>,\n         ofile: &Option<PathBuf>,\n     ) -> Compilation {\n+        // Called *before* build_controller. Add filename to miri arguments.\n+        self.miri_config.args.insert(0, input.filestem().to_string());\n         self.default.late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n     }\n     fn build_controller(\n@@ -89,9 +91,9 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         let this = *self;\n         let mut control = this.default.build_controller(sess, matches);\n         control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n-        let validate = this.validate;\n+        let miri_config = this.miri_config;\n         control.after_analysis.callback =\n-            Box::new(move |state| after_analysis(state, validate));\n+            Box::new(move |state| after_analysis(state, miri_config.clone()));\n         control.after_analysis.stop = Compilation::Stop;\n         control\n     }\n@@ -107,7 +109,7 @@ fn after_hir_lowering(state: &mut CompileState) {\n \n fn after_analysis<'a, 'tcx>(\n     state: &mut CompileState<'a, 'tcx>,\n-    validate: bool,\n+    miri_config: MiriConfig,\n ) {\n     init_late_loggers();\n     state.session.abort_if_errors();\n@@ -117,7 +119,7 @@ fn after_analysis<'a, 'tcx>(\n \n     let (entry_def_id, _) = tcx.entry_fn(LOCAL_CRATE).expect(\"no main function found!\");\n \n-    miri::eval_main(tcx, entry_def_id, validate);\n+    miri::eval_main(tcx, entry_def_id, miri_config);\n \n     state.session.abort_if_errors();\n }\n@@ -188,34 +190,51 @@ fn find_sysroot() -> String {\n \n fn main() {\n     init_early_loggers();\n-    let mut args: Vec<String> = std::env::args().collect();\n \n-    // Parse our own -Z flags and remove them before rustc gets their hand on them.\n+    // Parse our arguments and split them across rustc and miri\n     let mut validate = true;\n-    args.retain(|arg| {\n-        match arg.as_str() {\n-            \"-Zmiri-disable-validation\" => {\n-                validate = false;\n-                false\n-            },\n-            _ => true\n+    let mut rustc_args = vec![];\n+    let mut miri_args = vec![];\n+    let mut after_dashdash = false;\n+    for arg in std::env::args() {\n+        if rustc_args.is_empty() {\n+            // Very first arg: for rustc\n+            rustc_args.push(arg);\n         }\n-    });\n+        else if after_dashdash {\n+            // Everything that comes is Miri args\n+            miri_args.push(arg);\n+        } else {\n+            match arg.as_str() {\n+                \"-Zmiri-disable-validation\" => {\n+                    validate = false;\n+                },\n+                \"--\" => {\n+                    after_dashdash = true;\n+                }\n+                _ => {\n+                    rustc_args.push(arg);\n+                }\n+            }\n+        }\n+    }\n \n     // Determine sysroot and let rustc know about it\n     let sysroot_flag = String::from(\"--sysroot\");\n-    if !args.contains(&sysroot_flag) {\n-        args.push(sysroot_flag);\n-        args.push(find_sysroot());\n+    if !rustc_args.contains(&sysroot_flag) {\n+        rustc_args.push(sysroot_flag);\n+        rustc_args.push(find_sysroot());\n     }\n     // Finally, add the default flags all the way in the beginning, but after the binary name.\n-    args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n+    rustc_args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n \n-    trace!(\"rustc arguments: {:?}\", args);\n+    debug!(\"rustc arguments: {:?}\", rustc_args);\n+    debug!(\"miri arguments: {:?}\", miri_args);\n+    let miri_config = MiriConfig { validate, args: miri_args };\n     let result = rustc_driver::run(move || {\n-        rustc_driver::run_compiler(&args, Box::new(MiriCompilerCalls {\n+        rustc_driver::run_compiler(&rustc_args, Box::new(MiriCompilerCalls {\n             default: Box::new(RustcDefaultCalls),\n-            validate,\n+            miri_config,\n         }), None, None)\n     });\n     std::process::exit(result as i32);"}, {"sha": "09df91b3ab3885754eef9f7a00f36eb1ee24b206", "filename": "src/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -245,7 +245,13 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 this.binop_ignore_overflow(mir::BinOp::Div, a, b, dest)?;\n             },\n \n-            \"likely\" | \"unlikely\" | \"forget\" => {}\n+            \"forget\" => {}\n+\n+            \"likely\" | \"unlikely\" => {\n+                // These just return their argument\n+                let b = this.read_immediate(args[0])?;\n+                this.write_immediate(*b, dest)?;\n+            }\n \n             \"init\" => {\n                 // Check fast path: we don't want to force an allocation in case the destination is a simple value,"}, {"sha": "f59a476ed94e8478af52371d267d80053e631b1f", "filename": "src/lib.rs", "status": "modified", "additions": 42, "deletions": 15, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -57,16 +57,23 @@ pub fn miri_default_args() -> &'static [&'static str] {\n     &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\", \"--cfg=miri\"]\n }\n \n+/// Configuration needed to spawn a Miri instance\n+#[derive(Clone)]\n+pub struct MiriConfig {\n+    pub validate: bool,\n+    pub args: Vec<String>,\n+}\n+\n // Used by priroda\n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n-    validate: bool,\n+    config: MiriConfig,\n ) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, Evaluator<'tcx>>> {\n     let mut ecx = EvalContext::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(validate),\n+        Evaluator::new(config.validate),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n@@ -120,7 +127,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n \n     // Second argument (argc): 1\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    let argc = Scalar::from_int(1, dest.layout.size);\n+    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n     ecx.write_scalar(argc, dest)?;\n     // Store argc for macOS _NSGetArgc\n     {\n@@ -130,26 +137,46 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     }\n \n     // FIXME: extract main source file path\n-    // Third argument (argv): &[b\"foo\"]\n-    const CMD: &str = \"running-in-miri\\0\";\n+    // Third argument (argv): Created from config.args\n     let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-    let cmd = ecx.memory_mut().allocate_static_bytes(CMD.as_bytes()).with_default_tag();\n-    let raw_str_layout = ecx.layout_of(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8))?;\n-    let cmd_place = ecx.allocate(raw_str_layout, MiriMemoryKind::Env.into());\n-    ecx.write_scalar(Scalar::Ptr(cmd), cmd_place.into())?;\n-    ecx.memory_mut().mark_immutable(cmd_place.to_ptr()?.alloc_id)?;\n+    // For Windows, construct a command string with all the aguments\n+    let mut cmd = String::new();\n+    for arg in config.args.iter() {\n+        if !cmd.is_empty() {\n+            cmd.push(' ');\n+        }\n+        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n+    }\n+    cmd.push(std::char::from_u32(0).unwrap()); // don't forget 0 terminator\n+    // Collect the pointers to the individual strings.\n+    let mut argvs = Vec::<Pointer<Borrow>>::new();\n+    for arg in config.args {\n+        // Add 0 terminator\n+        let mut arg = arg.into_bytes();\n+        arg.push(0);\n+        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice()).with_default_tag());\n+    }\n+    // Make an array with all these pointers, in the Miri memory.\n+    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n+    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n+    for (idx, arg) in argvs.into_iter().enumerate() {\n+        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n+        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n+    }\n+    ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n+    // Write a pointe to that place as the argument.\n+    let argv = argvs_place.ptr;\n+    ecx.write_scalar(argv, dest)?;\n     // Store argv for macOS _NSGetArgv\n     {\n-        let argv = cmd_place.ptr;\n-        ecx.write_scalar(argv, dest)?;\n         let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n         ecx.write_scalar(argv, argv_place.into())?;\n         ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n     }\n     // Store cmdline as UTF-16 for Windows GetCommandLineW\n     {\n         let tcx = &{ecx.tcx.tcx};\n-        let cmd_utf16: Vec<u16> = CMD.encode_utf16().collect();\n+        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n         let cmd_ptr = ecx.memory_mut().allocate(\n             Size::from_bytes(cmd_utf16.len() as u64 * 2),\n             Align::from_bytes(2).unwrap(),\n@@ -179,9 +206,9 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n-    validate: bool,\n+    config: MiriConfig,\n ) {\n-    let mut ecx = create_ecx(tcx, main_id, validate).expect(\"Couldn't create ecx\");\n+    let mut ecx = create_ecx(tcx, main_id, config).expect(\"Couldn't create ecx\");\n \n     // Run! The main execution.\n     let res: EvalResult = (|| {"}, {"sha": "a52e115323c6ff98ae90b53f3d887ef1eb0ac049", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -21,19 +21,19 @@ pub type CallId = u64;\n pub enum Borrow {\n     /// A unique (mutable) reference.\n     Uniq(Timestamp),\n-    /// A shared reference.  This is also used by raw pointers, which do not track details\n+    /// An aliasing reference.  This is also used by raw pointers, which do not track details\n     /// of how or when they were created, hence the timestamp is optional.\n     /// Shr(Some(_)) does NOT mean that the destination of this reference is frozen;\n     /// that depends on the type!  Only those parts outside of an `UnsafeCell` are actually\n     /// frozen.\n-    Shr(Option<Timestamp>),\n+    Alias(Option<Timestamp>),\n }\n \n impl Borrow {\n     #[inline(always)]\n-    pub fn is_shared(self) -> bool {\n+    pub fn is_aliasing(self) -> bool {\n         match self {\n-            Borrow::Shr(_) => true,\n+            Borrow::Alias(_) => true,\n             _ => false,\n         }\n     }\n@@ -49,7 +49,7 @@ impl Borrow {\n \n impl Default for Borrow {\n     fn default() -> Self {\n-        Borrow::Shr(None)\n+        Borrow::Alias(None)\n     }\n }\n \n@@ -58,10 +58,9 @@ impl Default for Borrow {\n pub enum BorStackItem {\n     /// Indicates the unique reference that may mutate.\n     Uniq(Timestamp),\n-    /// Indicates that the location has been shared.  Used for raw pointers, but\n-    /// also for shared references.  The latter *additionally* get frozen\n-    /// when there is no `UnsafeCell`.\n-    Shr,\n+    /// Indicates that the location has been mutably shared.  Used for raw pointers as\n+    /// well as for unfrozen shared references.\n+    Raw,\n     /// A barrier, tracking the function it belongs to by its index on the call stack\n     FnBarrier(CallId)\n }\n@@ -186,19 +185,19 @@ impl<'tcx> Stack {\n         kind: RefKind,\n     ) -> Result<Option<usize>, String> {\n         // Exclude unique ref with frozen tag.\n-        if let (RefKind::Unique, Borrow::Shr(Some(_))) = (kind, bor) {\n+        if let (RefKind::Unique, Borrow::Alias(Some(_))) = (kind, bor) {\n             return Err(format!(\"Encountered mutable reference with frozen tag ({:?})\", bor));\n         }\n         // Checks related to freezing\n         match bor {\n-            Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n+            Borrow::Alias(Some(bor_t)) if kind == RefKind::Frozen => {\n                 // We need the location to be frozen. This ensures F3.\n                 let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n                 return if frozen { Ok(None) } else {\n                     Err(format!(\"Location is not frozen long enough\"))\n                 }\n             }\n-            Borrow::Shr(_) if self.frozen_since.is_some() => {\n+            Borrow::Alias(_) if self.frozen_since.is_some() => {\n                 return Ok(None) // Shared deref to frozen location, looking good\n             }\n             _ => {} // Not sufficient, go on looking.\n@@ -210,8 +209,8 @@ impl<'tcx> Stack {\n                     // Found matching unique item.  This satisfies U3.\n                     return Ok(Some(idx))\n                 }\n-                (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared/raw item.\n+                (BorStackItem::Raw, Borrow::Alias(_)) => {\n+                    // Found matching aliasing/raw item.\n                     return Ok(Some(idx))\n                 }\n                 // Go on looking.  We ignore barriers!  When an `&mut` and an `&` alias,\n@@ -221,7 +220,7 @@ impl<'tcx> Stack {\n             }\n         }\n         // If we got here, we did not find our item.  We have to error to satisfy U3.\n-        Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the stack\", bor))\n+        Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the borrow stack\", bor))\n     }\n \n     /// Perform an actual memory access using `bor`.  We do not know any types here\n@@ -258,14 +257,15 @@ impl<'tcx> Stack {\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n                     // Found matching unique item.  Continue after the match.\n                 }\n-                (BorStackItem::Shr, _) if kind == AccessKind::Read => {\n-                    // When reading, everything can use a shared item!\n+                (BorStackItem::Raw, _) if kind == AccessKind::Read => {\n+                    // When reading, everything can use a raw item!\n                     // We do not want to do this when writing: Writing to an `&mut`\n                     // should reaffirm its exclusivity (i.e., make sure it is\n-                    // on top of the stack).  Continue after the match.\n+                    // on top of the stack).\n+                    // Continue after the match.\n                 }\n-                (BorStackItem::Shr, Borrow::Shr(_)) => {\n-                    // Found matching shared item.  Continue after the match.\n+                (BorStackItem::Raw, Borrow::Alias(_)) => {\n+                    // Found matching raw item.  Continue after the match.\n                 }\n                 _ => {\n                     // Pop this, go on.  This ensures U2.\n@@ -294,7 +294,7 @@ impl<'tcx> Stack {\n         }\n         // If we got here, we did not find our item.\n         err!(MachineError(format!(\n-            \"Borrow being accessed ({:?}) does not exist on the stack\",\n+            \"Borrow being accessed ({:?}) does not exist on the borrow stack\",\n             bor\n         )))\n     }\n@@ -309,7 +309,7 @@ impl<'tcx> Stack {\n         // of access (like writing through raw pointers) is permitted.\n         if kind == RefKind::Frozen {\n             let bor_t = match bor {\n-                Borrow::Shr(Some(t)) => t,\n+                Borrow::Alias(Some(t)) => t,\n                 _ => bug!(\"Creating illegal borrow {:?} for frozen ref\", bor),\n             };\n             // It is possible that we already are frozen (e.g. if we just pushed a barrier,\n@@ -328,12 +328,12 @@ impl<'tcx> Stack {\n         // Push new item to the stack.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n-            Borrow::Shr(_) => BorStackItem::Shr,\n+            Borrow::Alias(_) => BorStackItem::Raw,\n         };\n         if *self.borrows.last().unwrap() == itm {\n             // This is just an optimization, no functional change: Avoid stacking\n             // multiple `Shr` on top of each other.\n-            assert!(bor.is_shared());\n+            assert!(bor.is_aliasing());\n             trace!(\"create: Sharing a shared location is a NOP\");\n         } else {\n             // This ensures U1.\n@@ -440,7 +440,7 @@ impl<'tcx> Stacks {\n                     _ => false,\n                 };\n             if bor_redundant {\n-                assert!(new_bor.is_shared(), \"A unique reborrow can never be redundant\");\n+                assert!(new_bor.is_aliasing(), \"A unique reborrow can never be redundant\");\n                 trace!(\"reborrow is redundant\");\n                 continue;\n             }\n@@ -465,7 +465,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n     #[inline(always)]\n     fn memory_allocated<'tcx>(size: Size, extra: &MemoryState) -> Self {\n         let stack = Stack {\n-            borrows: vec![BorStackItem::Shr],\n+            borrows: vec![BorStackItem::Raw],\n             frozen_since: None,\n         };\n         Stacks {\n@@ -511,7 +511,7 @@ impl<'tcx> Stacks {\n     ) {\n         for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n             assert!(stack.borrows.len() == 1);\n-            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Shr);\n+            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Raw);\n             stack.borrows.push(itm);\n         }\n     }\n@@ -536,7 +536,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n-        if let Borrow::Shr(Some(_)) = new_bor {\n+        if let Borrow::Alias(Some(_)) = new_bor {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                 let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n@@ -574,7 +574,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let time = this.machine.stacked_borrows.increment_clock();\n         let new_bor = match mutbl {\n             Some(MutMutable) => Borrow::Uniq(time),\n-            Some(MutImmutable) => Borrow::Shr(Some(time)),\n+            Some(MutImmutable) => Borrow::Alias(Some(time)),\n             None => Borrow::default(),\n         };\n \n@@ -586,7 +586,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             assert!(mutbl == Some(MutMutable), \"two-phase shared borrows make no sense\");\n             // We immediately share it, to allow read accesses\n             let two_phase_time = this.machine.stacked_borrows.increment_clock();\n-            let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n+            let two_phase_bor = Borrow::Alias(Some(two_phase_time));\n             this.reborrow(new_place, size, /*fn_barrier*/false, two_phase_bor)?;\n         }\n \n@@ -651,7 +651,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n-        if let Borrow::Shr(Some(_)) = ptr.tag {\n+        if let Borrow::Alias(Some(_)) = ptr.tag {\n             assert_eq!(mutability, Some(MutImmutable));\n             // We need a frozen-sensitive check\n             this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {"}, {"sha": "8c59b6bcdead616496035b3d17b001011daeb946", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -37,10 +37,19 @@ def test(name, cmd, stdout_ref, stderr_ref):\n \n def test_cargo_miri_run():\n     test(\"cargo miri run\", [\"cargo\", \"miri\", \"run\", \"-q\"], \"stdout.ref\", \"stderr.ref\")\n+    test(\"cargo miri run (with arguments)\",\n+        [\"cargo\", \"miri\", \"run\", \"-q\", \"--\", \"--\", \"hello world\", '\"hello world\"'],\n+        \"stdout.ref\", \"stderr.ref2\"\n+    )\n \n def test_cargo_miri_test():\n     test(\"cargo miri test\", [\"cargo\", \"miri\", \"test\", \"-q\"], \"test.stdout.ref\", \"test.stderr.ref\")\n+    test(\"cargo miri test (with filter)\",\n+        [\"cargo\", \"miri\", \"test\", \"-q\", \"--\", \"--\", \"impl\"],\n+        \"test.stdout.ref2\", \"test.stderr.ref\"\n+    )\n \n test_cargo_miri_run()\n test_cargo_miri_test()\n+print(\"TEST SUCCESSFUL!\")\n sys.exit(0)"}, {"sha": "32f1bac57d20ff4e5fe26a4a36c56567d33df613", "filename": "test-cargo-miri/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Fmain.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -9,7 +9,9 @@ fn main() {\n     let n = <BigEndian as ByteOrder>::read_u32(buf);\n     assert_eq!(n, 0x01020304);\n     println!(\"{:#010x}\", n);\n-    eprintln!(\"standard error\");\n+    for arg in std::env::args() {\n+        eprintln!(\"{}\", arg);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "ba2906d0666cf726c7eaadd2cd3db615dedfdf3a", "filename": "test-cargo-miri/stderr.ref", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Fstderr.ref", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Fstderr.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstderr.ref?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -1 +1 @@\n-standard error\n+main"}, {"sha": "8226b1b7cdec7f93577fa8dd1a7e8a5147d5145b", "filename": "test-cargo-miri/stderr.ref2", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Fstderr.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Fstderr.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fstderr.ref2?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -0,0 +1,3 @@\n+main\n+hello world\n+\"hello world\""}, {"sha": "ce3506709d5a09b46c0f09981b198d4d6b7b8dd5", "filename": "test-cargo-miri/test.stdout.ref2", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Ftest.stdout.ref2", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/test-cargo-miri%2Ftest.stdout.ref2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref2?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -0,0 +1,11 @@\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+\n+\n+running 1 test\n+test simple ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+"}, {"sha": "30f5921202c3ffb02b76fc126ee06bf03fcf21da", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR does not exist on the stack\n+    let _val = *target_alias; //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "e3c59d1566142f6255dea8ea5addf2316564ea82", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut3.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &mut i32, _y: &i32) {} //~ ERROR does not exist on the stack\n+pub fn safe(_x: &mut i32, _y: &i32) {} //~ ERROR does not exist on the borrow stack\n \n fn main() {\n     let mut x = 0;"}, {"sha": "481915faed0401260af9e9a76a0004b1bbc250ac", "filename": "tests/compile-fail/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -8,7 +8,7 @@ fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n   unknown_code_2();\n \n   // We know this will return 5\n-  *our //~ ERROR does not exist on the stack\n+  *our //~ ERROR does not exist on the borrow stack\n }\n \n // Now comes the evil context"}, {"sha": "98d4e6f22965dd24353bafe66f7e9ac430cbd394", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     let v1 = safe::as_mut_slice(&v);\n     let _v2 = safe::as_mut_slice(&v);\n     v1[1] = 5;\n-    //~^ ERROR does not exist on the stack\n+    //~^ ERROR does not exist on the borrow stack\n }"}, {"sha": "42f345f55144cd8a718d71fc860892d381d6397c", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -9,7 +9,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR does not exist on the stack\n+            //~^ ERROR does not exist on the borrow stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "0181f739a899d5d6478c371767ee236e47534553", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "b55fe1c6c88a443b113fd3ff9f117ba0e86f543e", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "9da4ca09606e73e3347532871688c10cb2aa9632", "filename": "tests/compile-fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read3.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     let xref2 = &mut *xref1; // derived from xref1, so using raw is still okay...\n     callee(xref1_sneaky);\n     let _val = *xref2; // ...but any use of it will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xref1: usize) {"}, {"sha": "bb889de8f839eb7fdc07b16e369a50a4f3291dc5", "filename": "tests/compile-fail/stacked_borrows/illegal_read4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read4.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xraw = xref1 as *mut _;\n     let xref2 = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs\n-    let _illegal = *xref2; //~ ERROR does not exist on the stack\n+    let _illegal = *xref2; //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "5f800e754a5d02749346efbd0f0e5d9302cd6aeb", "filename": "tests/compile-fail/stacked_borrows/illegal_read5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read5.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -12,5 +12,5 @@ fn main() {\n     let _val = *xref; // we can even still use our mutable reference\n     mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref\n     let _val = *xref; // the mutable one is dead and gone\n-    //~^ ERROR does not exist on the stack\n+    //~^ ERROR does not exist on the borrow stack\n }"}, {"sha": "affa21c7625ead98ae207921dc55d799ca4545f1", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     let target2 = target as *mut _;\n     drop(&mut *target); // reborrow\n     // Now make sure our ref is still the only one.\n-    unsafe { *target2 = 13; } //~ ERROR does not exist on the stack\n+    unsafe { *target2 = 13; } //~ ERROR does not exist on the borrow stack\n     let _val = *target;\n }"}, {"sha": "dc4edcc3a5b4496c5e0424ba68905379f2f52368", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the borrow stack\n     let _val = *r#ref;\n }"}, {"sha": "af57221260ce893750beecef0161092edc22676f", "filename": "tests/compile-fail/stacked_borrows/illegal_write5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write5.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: does not exist on the stack\n+    //~^ ERROR: does not exist on the borrow stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "f2e4b36f85cc242234914854df72397a0b8eedea", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n+    let _val = *xref_in_mem; //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "ba36e43e0c5d4c39ab960bdc0bc0c9d2f2ce8aa2", "filename": "tests/compile-fail/stacked_borrows/outdated_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -3,7 +3,7 @@ fn main() {\n     let y: *const i32 = &x;\n     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local\n \n-    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the stack\n+    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the borrow stack\n \n     assert_eq!(x, 1);\n }"}, {"sha": "b239237f019928e4a22209fba51a97859f143128", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    foo(xref); //~ ERROR does not exist on the stack\n+    foo(xref); //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "a8207d58e99b23dccaf4a144175b61c8c96ab8d4", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -8,7 +8,7 @@ fn fun1(x: &mut u8) {\n \n fn fun2() {\n     // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR }; //~ ERROR does not exist on the stack\n+    let _x = unsafe { *PTR }; //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "31f8a4e33afd906a77efb2d6ee58622d374bdc59", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the stack\n+    ret //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "750d507d6f660150f7ef96d20cbd2dea93768e59", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n     let xraw = x as *mut (i32, i32);\n     let ret = Some(unsafe { &mut (*xraw).1 });\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the stack\n+    ret //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "bb712e9e486cd6d977edaa4cafe5b5e18c2f24d3", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut_tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n     let xraw = x as *mut (i32, i32);\n     let ret = (unsafe { &mut (*xraw).1 },);\n     let _val = unsafe { *xraw }; // invalidate xref\n-    ret //~ ERROR does not exist on the stack\n+    ret //~ ERROR does not exist on the borrow stack\n }\n \n fn main() {"}, {"sha": "45ada88977788968f3f15be18ed4cae423f02ae1", "filename": "tests/compile-fail/stacked_borrows/transmute-is-no-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let _raw: *mut i32 = unsafe { mem::transmute(&mut x[0]) };\n     // `raw` still carries a tag, so we get another pointer to the same location that does not carry a tag\n     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n-    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "1db14ea7eda545e6f0bc72162fb05e5516a07452", "filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     let mut x = 42;\n     let raw = &mut x as *mut i32 as usize as *mut i32;\n     let _ptr = &mut x;\n-    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the borrow stack\n }"}, {"sha": "0116dce4992dcab2c92df739ed408773f601ee99", "filename": "tests/run-pass/args.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Frun-pass%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Frun-pass%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fargs.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    for arg in std::env::args() {\n+        println!(\"{}\", arg);\n+    }\n+}"}, {"sha": "9564f5a1aa056804e6b7f35d533c3a06afd76af9", "filename": "tests/run-pass/args.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Frun-pass%2Fargs.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Frun-pass%2Fargs.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fargs.stdout?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -0,0 +1 @@\n+args"}, {"sha": "1bef21d83bda3c5e14a1bb172a02e9f278c8f70a", "filename": "tests/run-pass/iter.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/604095fff205fa73e634a074472b5483823f054f/tests%2Frun-pass%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604095fff205fa73e634a074472b5483823f054f/tests%2Frun-pass%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter.rs?ref=604095fff205fa73e634a074472b5483823f054f", "patch": "@@ -0,0 +1,40 @@\n+fn iter_empty_and_zst() {\n+    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n+        panic!(\"We should never be here.\");\n+    }\n+\n+    // Iterate over a ZST (uses arith_offset internally)\n+    let mut count = 0;\n+    for _ in &[(), (), ()] {\n+        count += 1;\n+    }\n+    assert_eq!(count, 3);\n+}\n+\n+fn test_iterator_step_by_nth() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth(0), Some(0));\n+    assert_eq!(it.nth(0), Some(5));\n+    assert_eq!(it.nth(0), Some(10));\n+    assert_eq!(it.nth(0), Some(15));\n+    assert_eq!(it.nth(0), None);\n+}\n+\n+fn iter_any() {\n+    let f = |x: &u8| { 10u8 == *x };\n+    f(&1u8);\n+\n+    let g = |(), x: &u8| { 10u8 == *x };\n+    g((), &1u8);\n+\n+    let h = |(), (), x: &u8| { 10u8 == *x };\n+    h((), (), &1u8);\n+\n+    [1, 2, 3u8].into_iter().any(|elt| 10 == *elt);\n+}\n+\n+fn main() {\n+    test_iterator_step_by_nth();\n+    iter_any();\n+    iter_empty_and_zst();\n+}"}, {"sha": "b14eb074488b29244744dd496a86dff277c5955d", "filename": "tests/run-pass/iter_any.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7827924bfc920bc171f3c68e25dc47065f5ae6e4/tests%2Frun-pass%2Fiter_any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7827924bfc920bc171f3c68e25dc47065f5ae6e4/tests%2Frun-pass%2Fiter_any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_any.rs?ref=7827924bfc920bc171f3c68e25dc47065f5ae6e4", "patch": "@@ -1,12 +0,0 @@\n-pub fn main() {\n-    let f = |x: &u8| { 10u8 == *x };\n-    f(&1u8);\n-\n-    let g = |(), x: &u8| { 10u8 == *x };\n-    g((), &1u8);\n-\n-    let h = |(), (), x: &u8| { 10u8 == *x };\n-    h((), (), &1u8);\n-\n-    [1, 2, 3u8].into_iter().any(|elt| 10 == *elt);\n-}"}, {"sha": "fd7229c3455e4da6a491d289b056fad62c91282a", "filename": "tests/run-pass/iter_slice.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7827924bfc920bc171f3c68e25dc47065f5ae6e4/tests%2Frun-pass%2Fiter_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7827924bfc920bc171f3c68e25dc47065f5ae6e4/tests%2Frun-pass%2Fiter_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fiter_slice.rs?ref=7827924bfc920bc171f3c68e25dc47065f5ae6e4", "patch": "@@ -1,12 +0,0 @@\n-fn main() {\n-    for _ in Vec::<u32>::new().iter() { // this iterates over a Unique::empty()\n-        panic!(\"We should never be here.\");\n-    }\n-\n-    // Iterate over a ZST (uses arith_offset internally)\n-    let mut count = 0;\n-    for _ in &[(), (), ()] {\n-        count += 1;\n-    }\n-    assert_eq!(count, 3);\n-}"}]}