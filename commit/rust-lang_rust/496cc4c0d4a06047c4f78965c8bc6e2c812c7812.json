{"sha": "496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5NmNjNGMwZDRhMDYwNDdjNGY3ODk2NWM4YmM2ZTJjODEyYzc4MTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-09-23T23:07:21Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-09-30T21:38:04Z"}, "message": "librustc: Fix up mutability in method autoderefs if incorrect, and\nprefer `Deref` over `DerefMut` in all other circumstances.\n\nCloses #12825.", "tree": {"sha": "d9c23d209c21b1363d34d9c6bb739e624a2ede35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9c23d209c21b1363d34d9c6bb739e624a2ede35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "html_url": "https://github.com/rust-lang/rust/commit/496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "823f10802fc8940aeb094185cecd5958c7f23d53", "url": "https://api.github.com/repos/rust-lang/rust/commits/823f10802fc8940aeb094185cecd5958c7f23d53", "html_url": "https://github.com/rust-lang/rust/commit/823f10802fc8940aeb094185cecd5958c7f23d53"}], "stats": {"total": 164, "additions": 154, "deletions": 10}, "files": [{"sha": "129d37638a3168dd1167534f78e036e347b51b37", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -116,7 +116,7 @@ impl EventLoop for BasicLoop {\n             }\n \n             unsafe {\n-                let mut messages = self.messages.lock();\n+                let messages = self.messages.lock();\n                 // We block here if we have no messages to process and we may\n                 // receive a message at a later date\n                 if self.remotes.len() > 0 && messages.len() == 0 &&"}, {"sha": "73f36e3bd296a5c39a4ff41717e54e8122f0a50c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -405,6 +405,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AdjustAddEnv(..) => {\n+                        debug!(\"cat_expr(AdjustAddEnv): {}\",\n+                               expr.repr(self.tcx()));\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n@@ -414,6 +416,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     ty::AdjustDerefRef(\n                         ty::AutoDerefRef {\n                             autoref: Some(_), ..}) => {\n+                        debug!(\"cat_expr(AdjustDerefRef): {}\",\n+                               expr.repr(self.tcx()));\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n@@ -436,6 +440,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                autoderefs: uint)\n                                -> McResult<cmt> {\n         let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n+        debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n+               autoderefs,\n+               cmt.repr(self.tcx()));\n         for deref in range(1u, autoderefs + 1) {\n             cmt = self.cat_deref(expr, cmt, deref, false);\n         }\n@@ -454,6 +461,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n           ast::ExprField(ref base, f_name, _) => {\n             let base_cmt = if_ok!(self.cat_expr(&**base));\n+            debug!(\"cat_expr(cat_field): id={} expr={} base={}\",\n+                   expr.id,\n+                   expr.repr(self.tcx()),\n+                   base_cmt.repr(self.tcx()));\n             Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n           }\n "}, {"sha": "3d522a7c54860bc3bb0da46b7a0b351609caa27f", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 83, "deletions": 7, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -86,10 +86,11 @@ use middle::traits;\n use middle::ty::*;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n-use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n+use middle::typeck::check::{FnCtxt, NoPreference, PreferMutLvalue};\n+use middle::typeck::check::{impl_self_ty};\n use middle::typeck::check;\n use middle::typeck::infer;\n-use middle::typeck::MethodCallee;\n+use middle::typeck::{MethodCall, MethodCallee};\n use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n@@ -353,11 +354,15 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         let (_, _, result) =\n             check::autoderef(\n-                self.fcx, span, self_ty, self_expr_id, PreferMutLvalue,\n+                self.fcx, span, self_ty, self_expr_id, NoPreference,\n                 |self_ty, autoderefs| self.search_step(self_ty, autoderefs));\n \n         match result {\n-            Some(Some(result)) => Some(result),\n+            Some(Some(result)) => {\n+                self.fixup_derefs_on_method_receiver_if_necessary(&result,\n+                                                                  self_ty);\n+                Some(result)\n+            }\n             _ => None\n         }\n     }\n@@ -430,7 +435,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n          */\n \n         let span = self.self_expr.map_or(self.span, |e| e.span);\n-        check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n+        check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_trait(box TyTrait { def_id, ref substs, bounds, .. }) => {\n                     self.push_inherent_candidates_from_object(\n@@ -458,7 +463,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n     fn push_bound_candidates(&mut self, self_ty: ty::t, restrict_to: Option<DefId>) {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n-        check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n+        check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n             match get(self_ty).sty {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, restrict_to, p);\n@@ -1135,7 +1140,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         };\n \n         // This is hokey. We should have mutability inference as a\n-        // variable.  But for now, try &const, then &, then &mut:\n+        // variable.  But for now, try &, then &mut:\n         let region =\n             self.infcx().next_region_var(infer::Autoref(self.span));\n         for mutbl in mutbls.iter() {\n@@ -1381,6 +1386,77 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n     }\n \n+    fn fixup_derefs_on_method_receiver_if_necessary(\n+            &self,\n+            method_callee: &MethodCallee,\n+            self_ty: ty::t) {\n+        let sig = match ty::get(method_callee.ty).sty {\n+            ty::ty_bare_fn(ref f) => f.sig.clone(),\n+            ty::ty_closure(ref f) => f.sig.clone(),\n+            _ => return,\n+        };\n+\n+        match ty::get(*sig.inputs.get(0)).sty {\n+            ty::ty_rptr(_, ty::mt {\n+                ty: _,\n+                mutbl: ast::MutMutable,\n+            }) => {}\n+            _ => return,\n+        }\n+\n+        // Fix up autoderefs and derefs.\n+        let mut self_expr = match self.self_expr {\n+            Some(expr) => expr,\n+            None => return,\n+        };\n+        loop {\n+            // Count autoderefs.\n+            let autoderef_count = match self.fcx\n+                                            .inh\n+                                            .adjustments\n+                                            .borrow()\n+                                            .find(&self_expr.id) {\n+                Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n+                    autoderefs: autoderef_count,\n+                    autoref: _\n+                })) if autoderef_count > 0 => autoderef_count,\n+                Some(_) | None => return,\n+            };\n+\n+            check::autoderef(self.fcx,\n+                             self_expr.span,\n+                             self.fcx.expr_ty(self_expr),\n+                             Some(self_expr.id),\n+                             PreferMutLvalue,\n+                             |_, autoderefs| {\n+                                 if autoderefs == autoderef_count + 1 {\n+                                     Some(())\n+                                 } else {\n+                                     None\n+                                 }\n+                             });\n+\n+            match self_expr.node {\n+                ast::ExprParen(ref expr) |\n+                ast::ExprIndex(ref expr, _) |\n+                ast::ExprField(ref expr, _, _) |\n+                ast::ExprTupField(ref expr, _, _) |\n+                ast::ExprSlice(ref expr, _, _, _) => self_expr = &**expr,\n+                ast::ExprUnary(ast::UnDeref, ref expr) => {\n+                    drop(check::try_overloaded_deref(\n+                            self.fcx,\n+                            self_expr.span,\n+                            Some(MethodCall::expr(self_expr.id)),\n+                            Some(self_expr),\n+                            self_ty,\n+                            PreferMutLvalue));\n+                    self_expr = &**expr\n+                }\n+                _ => break,\n+            }\n+        }\n+    }\n+\n     fn enforce_object_limitations(&self, candidate: &Candidate) {\n         /*!\n          * There are some limitations to calling functions through an"}, {"sha": "97bbc8a9bc83d5993a6fa25f2f28f0a7314b1d2b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -2078,6 +2078,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n+#[deriving(Show)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n     NoPreference"}, {"sha": "cd215c1d68c51bb9f693268515088643d1346745", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -290,6 +290,9 @@ impl FileMap {\n     }\n \n     /// get a line from the list of pre-computed line-beginnings\n+    ///\n+    /// NOTE(stage0, pcwalton): Remove `#[allow(unused_mut)]` after snapshot.\n+    #[allow(unused_mut)]\n     pub fn get_line(&self, line: int) -> String {\n         let mut lines = self.lines.borrow_mut();\n         let begin: BytePos = *lines.get(line as uint) - self.start_pos;\n@@ -512,6 +515,8 @@ impl CodeMap {\n         return a;\n     }\n \n+    // NOTE(stage0, pcwalton): Remove `#[allow(unused_mut)]` after snapshot.\n+    #[allow(unused_mut)]\n     fn lookup_line(&self, pos: BytePos) -> FileMapAndLine {\n         let idx = self.lookup_filemap_idx(pos);\n "}, {"sha": "465529ac90941e1006bc0375aa56c3d344127f8a", "filename": "src/test/run-pass/dst-deref-mut.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Ftest%2Frun-pass%2Fdst-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Ftest%2Frun-pass%2Fdst-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-deref-mut.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -27,7 +27,6 @@ impl DerefMut<[uint]> for Arr {\n }\n \n pub fn foo(arr: &mut Arr) {\n-    assert!(arr.len() == 3);\n     let x: &mut [uint] = &mut **arr;\n     assert!(x[0] == 1);\n     assert!(x[1] == 2);"}, {"sha": "d2812ce1d2ce9c19254d22782b0a5d52ed691c05", "filename": "src/test/run-pass/fixup-deref-mut.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Ftest%2Frun-pass%2Ffixup-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Ftest%2Frun-pass%2Ffixup-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixup-deref-mut.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Generic unique/owned smaht pointer.\n+struct Own<T> {\n+    value: *mut T\n+}\n+\n+impl<T> Deref<T> for Own<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+impl<T> DerefMut<T> for Own<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut *self.value }\n+    }\n+}\n+\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+impl Point {\n+    fn get(&mut self) -> (int, int) {\n+        (self.x, self.y)\n+    }\n+}\n+\n+fn test0(mut x: Own<Point>) {\n+    let _ = x.get();\n+}\n+\n+fn test1(mut x: Own<Own<Own<Point>>>) {\n+    let _ = x.get();\n+}\n+\n+fn test2(mut x: Own<Own<Own<Point>>>) {\n+    let _ = (**x).get();\n+}\n+\n+fn main() {}\n+"}, {"sha": "4cf5e074139351f9176b2e32eff0788166b7b8cf", "filename": "src/test/run-pass/overloaded-autoderef-count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/496cc4c0d4a06047c4f78965c8bc6e2c812c7812/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef-count.rs?ref=496cc4c0d4a06047c4f78965c8bc6e2c812c7812", "patch": "@@ -74,7 +74,7 @@ pub fn main() {\n     assert_eq!(p.counts(), (2, 2));\n \n     p.get();\n-    assert_eq!(p.counts(), (2, 3));\n+    assert_eq!(p.counts(), (3, 2));\n \n     // Check the final state.\n     assert_eq!(*p, Point {x: 3, y: 0});"}]}