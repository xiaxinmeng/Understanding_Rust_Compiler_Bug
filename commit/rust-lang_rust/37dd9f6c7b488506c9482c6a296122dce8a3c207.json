{"sha": "37dd9f6c7b488506c9482c6a296122dce8a3c207", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZGQ5ZjZjN2I0ODg1MDZjOTQ4MmM2YTI5NjEyMmRjZThhM2MyMDc=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-01T15:46:34Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:34:26Z"}, "message": "Add Builder::sess and Builder::tcx methods", "tree": {"sha": "9175186dbf95bad8dfe33620e3753b6cdb83dc54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9175186dbf95bad8dfe33620e3753b6cdb83dc54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37dd9f6c7b488506c9482c6a296122dce8a3c207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37dd9f6c7b488506c9482c6a296122dce8a3c207", "html_url": "https://github.com/rust-lang/rust/commit/37dd9f6c7b488506c9482c6a296122dce8a3c207", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37dd9f6c7b488506c9482c6a296122dce8a3c207/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f67e7d6b4ab61acc7de258fd555f79c55b433cbe", "html_url": "https://github.com/rust-lang/rust/commit/f67e7d6b4ab61acc7de258fd555f79c55b433cbe"}], "stats": {"total": 137, "additions": 73, "deletions": 64}, "files": [{"sha": "365f86c0245008c5ac6c53ecfda65461e942d76b", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -359,7 +359,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx,\n-                monomorphize::field_ty(bcx.ccx.tcx(), substs,\n+                monomorphize::field_ty(bcx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]));\n             bcx.icmp(cmp, bcx.load(scrutinee), C_null(llptrty))\n         }\n@@ -486,7 +486,7 @@ pub fn trans_set_discr<'a, 'tcx>(\n }\n \n fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n-    bcx.ccx.sess().target.target.arch == \"arm\" || bcx.ccx.sess().target.target.arch == \"aarch64\"\n+    bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n@@ -524,7 +524,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n         }\n         layout::General { discr: d, ref variants, .. } => {\n             let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n-            fields.insert(0, d.to_ty(&bcx.ccx.tcx(), false));\n+            fields.insert(0, d.to_ty(&bcx.tcx(), false));\n             struct_field_ptr(bcx, &variants[discr.0 as usize],\n              &fields,\n              val, ix + 1, true)"}, {"sha": "c95d414701876ef6a4d4c9e19d57b12925db5bc5", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -62,7 +62,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Default per-arch clobbers\n     // Basically what clang does\n-    let arch_clobbers = match &bcx.ccx.sess().target.target.arch[..] {\n+    let arch_clobbers = match &bcx.sess().target.target.arch[..] {\n         \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n         _                => Vec::new()\n     };"}, {"sha": "f87b44604c7b8ff91a1fd2d039bd777a7fd36014", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -272,10 +272,10 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             assert_eq!(def_a, def_b);\n \n             let src_fields = def_a.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.ccx.tcx(), substs_a, f)\n+                monomorphize::field_ty(bcx.tcx(), substs_a, f)\n             });\n             let dst_fields = def_b.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.ccx.tcx(), substs_b, f)\n+                monomorphize::field_ty(bcx.tcx(), substs_b, f)\n             });\n \n             let src = adt::MaybeSizedValue::sized(src);"}, {"sha": "6112e29f72f4d366a3fe1994afb553afba3ec3e0", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -19,7 +19,8 @@ use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n-use rustc::ty::{Ty, TypeFoldable};\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::session::Session;\n use type_of;\n \n use std::borrow::Cow;\n@@ -93,6 +94,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         builder\n     }\n \n+    pub fn sess(&self) -> &Session {\n+        self.ccx.sess()\n+    }\n+\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.ccx.tcx()\n+    }\n+\n     pub fn llfn(&self) -> ValueRef {\n         unsafe {\n             llvm::LLVMGetBasicBlockParent(self.llbb())"}, {"sha": "8b296e9ad2988d9d65ed6a53c4dad4c97f96f925", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> DropValue<'tcx> {\n         let llpersonality = bcx.ccx.eh_personality();\n         bcx.set_personality_fn(llpersonality);\n \n-        if base::wants_msvc_seh(bcx.ccx.sess()) {\n+        if base::wants_msvc_seh(bcx.sess()) {\n             let pad = bcx.cleanup_pad(None, &[]);\n             let funclet = Some(Funclet::new(pad));\n             self.trans(funclet.as_ref(), &bcx);\n@@ -80,7 +80,7 @@ impl<'tcx> DropValue<'tcx> {\n             // Insert cleanup instructions into the cleanup block\n             self.trans(None, &bcx);\n \n-            if !bcx.ccx.sess().target.target.options.custom_unwind_resume {\n+            if !bcx.sess().target.target.options.custom_unwind_resume {\n                 bcx.resume(llretval);\n             } else {\n                 let exc_ptr = bcx.extract_value(llretval, 0);\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> CleanupScope<'tcx> {\n     fn new(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n             cleanup: Some(drop_val),\n-            landing_pad: if !bcx.ccx.sess().no_landing_pads() {\n+            landing_pad: if !bcx.sess().no_landing_pads() {\n                 Some(drop_val.get_landing_pad(bcx))\n             } else {\n                 None"}, {"sha": "e99e26261a3a1017d366f2a4af32142c1e358866", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -38,7 +38,7 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", builder.ccx.sess().codemap().span_to_string(span));\n+        debug!(\"set_source_location: {}\", builder.sess().codemap().span_to_string(span));\n         let loc = span_start(builder.ccx, span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {"}, {"sha": "8b7df0128b00b9a855b2124d1f3cff4f6035a06e", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -44,8 +44,8 @@ pub fn trans_exchange_free_ty<'a, 'tcx>(\n     ptr: MaybeSizedValue,\n     content_ty: Ty<'tcx>\n ) {\n-    let def_id = langcall(bcx.ccx.tcx(), None, \"\", BoxFreeFnLangItem);\n-    let substs = bcx.ccx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n+    let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n+    let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n     let callee = Callee::def(bcx.ccx, def_id, substs);\n \n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n@@ -232,7 +232,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n             let shallow_drop = def.is_union();\n-            let tcx = bcx.ccx.tcx();\n+            let tcx = bcx.tcx();\n \n             let def = t.ty_adt_def().unwrap();\n \n@@ -330,7 +330,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n             let last_field = def.struct_variant().fields.last().unwrap();\n-            let field_ty = monomorphize::field_ty(bcx.ccx.tcx(), substs, last_field);\n+            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n@@ -382,7 +382,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             (bcx.load(size_ptr), bcx.load(align_ptr))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(bcx.ccx.tcx());\n+            let unit_ty = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx, unit_ty);\n@@ -405,7 +405,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n                               av: adt::MaybeSizedValue,\n                               variant: &'tcx ty::VariantDef,\n                               substs: &Substs<'tcx>) {\n-        let tcx = cx.ccx.tcx();\n+        let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n             let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n@@ -416,20 +416,20 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n     let mut cx = cx;\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n-            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.ccx.tcx()).enumerate() {\n+            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n                 let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n                 drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n             }\n         }\n         ty::TyArray(_, n) => {\n             let base = get_dataptr(&cx, ptr.value);\n             let len = C_uint(cx.ccx, n);\n-            let unit_ty = t.sequence_element_type(cx.ccx.tcx());\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n                 |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(cx.ccx.tcx());\n+            let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n                 |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n@@ -441,7 +441,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n-                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.ccx.tcx(), t, None);\n+                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n                     let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n                     let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n@@ -469,7 +469,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n-                        let tcx = cx.ccx.tcx();\n+                        let tcx = cx.tcx();\n                         drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n \n                         // Create a fall-through basic block for the \"else\" case of\n@@ -501,13 +501,13 @@ fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n                         }\n                         cx = next_cx;\n                     }\n-                    _ => cx.ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+                    _ => cx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n                 }\n             }\n         },\n \n         _ => {\n-            cx.ccx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n+            cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n         }\n     }\n     return cx;"}, {"sha": "41155935a6353e61d42768f4b8d4eb0f664a2c99", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -694,7 +694,7 @@ fn try_intrinsic<'a, 'tcx>(\n     local_ptr: ValueRef,\n     dest: ValueRef,\n ) {\n-    if bcx.ccx.sess().no_landing_pads() {\n+    if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n         bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n     } else if wants_msvc_seh(bcx.sess()) {\n@@ -937,7 +937,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bcx.ccx.sess(), span,\n+                bcx.sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n                                  $msg),\n                          name, $($fmt)*));\n@@ -959,7 +959,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n \n-    let tcx = bcx.ccx.tcx();\n+    let tcx = bcx.tcx();\n     let sig = tcx.erase_late_bound_regions_and_normalize(callee_ty.fn_sig());\n     let arg_tys = sig.inputs();\n "}, {"sha": "ae0d847072a59ae502f5185748101c1bad9d9299", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let ps = self.get_personality_slot(&bcx);\n                     let lp = bcx.load(ps);\n                     Lifetime::End.call(&bcx, ps);\n-                    if !bcx.ccx.sess().target.target.options.custom_unwind_resume {\n+                    if !bcx.sess().target.target.options.custom_unwind_resume {\n                         bcx.resume(lp);\n                     } else {\n                         let exc_ptr = bcx.extract_value(lp, 0);\n@@ -146,7 +146,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::TerminatorKind::Switch { ref discr, ref adt_def, ref targets } => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, discr);\n-                let ty = discr_lvalue.ty.to_ty(bcx.ccx.tcx());\n+                let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n                 let discr = adt::trans_get_discr(&bcx, ty, discr_lvalue.llval, None, true);\n \n                 let mut bb_hist = FxHashMap();\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         LocalRef::Lvalue(tr_lvalue) => {\n                             OperandRef {\n                                 val: Ref(tr_lvalue.llval),\n-                                ty: tr_lvalue.ty.to_ty(bcx.ccx.tcx())\n+                                ty: tr_lvalue.ty.to_ty(bcx.tcx())\n                             }\n                         }\n                     };\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = location.ty(&self.mir, bcx.ccx.tcx()).to_ty(bcx.ccx.tcx());\n+                let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n \n                 // Double check for necessity to drop\n@@ -314,7 +314,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 self.set_debug_loc(&bcx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bcx.ccx.sess().codemap().lookup_char_pos(span.lo);\n+                let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n@@ -364,15 +364,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n                         let err = ConstEvalErr{ span: span, kind: err };\n-                        let mut diag = bcx.ccx.tcx().sess.struct_span_warn(\n+                        let mut diag = bcx.tcx().sess.struct_span_warn(\n                             span, \"this expression will panic at run-time\");\n-                        note_const_eval_err(bcx.ccx.tcx(), &err, span, \"expression\", &mut diag);\n+                        note_const_eval_err(bcx.tcx(), &err, span, \"expression\", &mut diag);\n                         diag.emit();\n                     }\n                 }\n \n                 // Obtain the panic entry point.\n-                let def_id = common::langcall(bcx.ccx.tcx(), Some(span), \"\", lang_item);\n+                let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let callee = Callee::def(bcx.ccx, def_id,\n                     bcx.ccx.empty_substs_for_def_id(def_id));\n                 let llfn = callee.reify(bcx.ccx);\n@@ -411,12 +411,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n-                let sig = bcx.ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n+                let sig = bcx.tcx().erase_late_bound_regions_and_normalize(sig);\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match (&callee.ty.sty, &callee.data) {\n                     (&ty::TyFnDef(def_id, ..), &Intrinsic) => {\n-                        Some(bcx.ccx.tcx().item_name(def_id).as_str())\n+                        Some(bcx.tcx().item_name(def_id).as_str())\n                     }\n                     _ => None\n                 };\n@@ -444,7 +444,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = op_arg.ty(&self.mir, bcx.ccx.tcx());\n+                    let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n                 let fn_ty = callee.direct_fn_type(bcx.ccx, &extra_args);\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let imm_op = |x| OperandRef {\n                     val: Immediate(x),\n                     // We won't be checking the type again.\n-                    ty: bcx.ccx.tcx().types.err\n+                    ty: bcx.tcx().types.err\n                 };\n                 self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, callee);\n                 self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n@@ -875,13 +875,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n-            let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.ccx.tcx()));\n+            let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.tcx()));\n             let out_type_size = llbitsize_of_real(bcx.ccx, llouttype);\n             if out_type_size != 0 {\n                 // FIXME #19925 Remove this hack after a release cycle.\n                 let f = Callee::def(bcx.ccx, def_id, substs);\n                 let ty = match f.ty.sty {\n-                    ty::TyFnDef(.., f) => bcx.ccx.tcx().mk_fn_ptr(f),\n+                    ty::TyFnDef(.., f) => bcx.tcx().mk_fn_ptr(f),\n                     _ => f.ty\n                 };\n                 val = OperandRef {"}, {"sha": "5a926c7f7555985f671a514254e5813ef7e2390f", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let llindex = C_uint(bcx.ccx, from);\n                         let llbase = project_index(llindex);\n \n-                        let base_ty = tr_base.ty.to_ty(bcx.ccx.tcx());\n+                        let base_ty = tr_base.ty.to_ty(bcx.tcx());\n                         match base_ty.sty {\n                             ty::TyArray(..) => {\n                                 // must cast the lvalue pointer type to the new"}, {"sha": "d9c0f047d3cb265d2d61fb4c01b6e20c374dafd8", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -268,7 +268,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 // User variable\n                 let source_info = decl.source_info.unwrap();\n                 let debug_scope = mircx.scopes[source_info.scope];\n-                let dbg = debug_scope.is_valid() && bcx.ccx.sess().opts.debuginfo == FullDebugInfo;\n+                let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n                 if !lvalue_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n@@ -367,13 +367,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             lvalue_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = mircx.mir;\n-    let tcx = bcx.ccx.tcx();\n+    let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n-    let arg_scope = if arg_scope.is_valid() && bcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n+    let arg_scope = if arg_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo {\n         Some(arg_scope.scope_metadata)\n     } else {\n         None\n@@ -433,7 +433,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() && bcx.ccx.sess().opts.debuginfo != FullDebugInfo {\n+        let llval = if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up, unless\n             // we emit extra-debug-info, which requires local allocas :(."}, {"sha": "28a247ee612a9078b6ba32322613439e40abb8b4", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // for most lvalues, to consume them we just load them\n         // out from their home\n         let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-        let ty = tr_lvalue.ty.to_ty(bcx.ccx.tcx());\n+        let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n         self.trans_load(bcx, tr_lvalue.llval, ty)\n     }\n "}, {"sha": "a23c3d4b2e3589c98375ad874023113313001e23", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37dd9f6c7b488506c9482c6a296122dce8a3c207/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=37dd9f6c7b488506c9482c6a296122dce8a3c207", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.value.as_u64(bcx.ccx.tcx().sess.target.uint_type);\n+                let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n@@ -104,7 +104,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n-                        let dest_ty = dest.ty.to_ty(bcx.ccx.tcx());\n+                        let dest_ty = dest.ty.to_ty(bcx.tcx());\n                         adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     },\n                     _ => {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n-                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.ccx.tcx()));\n+                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n                         let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n                             Some(&variant.memory_index)\n                         } else {\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n                     let lvalue = self.trans_lvalue(&bcx, output);\n-                    (lvalue.llval, lvalue.ty.to_ty(bcx.ccx.tcx()))\n+                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {\n@@ -345,9 +345,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Ref(_, bk, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n \n-                let ty = tr_lvalue.ty.to_ty(bcx.ccx.tcx());\n-                let ref_ty = bcx.ccx.tcx().mk_ref(\n-                    bcx.ccx.tcx().mk_region(ty::ReErased),\n+                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+                let ref_ty = bcx.tcx().mk_ref(\n+                    bcx.tcx().mk_region(ty::ReErased),\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n                 );\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(tr_lvalue.len(bcx.ccx)),\n-                    ty: bcx.ccx.tcx().types.usize,\n+                    ty: bcx.tcx().types.usize,\n                 };\n                 (bcx, operand)\n             }\n@@ -399,7 +399,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    ty: op.ty(bcx.ccx.tcx(), lhs.ty, rhs.ty),\n+                    ty: op.ty(bcx.tcx(), lhs.ty, rhs.ty),\n                 };\n                 (bcx, operand)\n             }\n@@ -409,8 +409,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let result = self.trans_scalar_checked_binop(&bcx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.ty);\n-                let val_ty = op.ty(bcx.ccx.tcx(), lhs.ty, rhs.ty);\n-                let operand_ty = bcx.ccx.tcx().intern_tup(&[val_ty, bcx.ccx.tcx().types.bool]);\n+                let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n+                let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool]);\n                 let operand = OperandRef {\n                     val: result,\n                     ty: operand_ty\n@@ -444,16 +444,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let align = type_of::align_of(bcx.ccx, content_ty);\n                 let llalign = C_uint(bcx.ccx, align);\n                 let llty_ptr = llty.ptr_to();\n-                let box_ty = bcx.ccx.tcx().mk_box(content_ty);\n+                let box_ty = bcx.tcx().mk_box(content_ty);\n \n                 // Allocate space:\n-                let def_id = match bcx.ccx.tcx().lang_items.require(ExchangeMallocFnLangItem) {\n+                let def_id = match bcx.tcx().lang_items.require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n-                        bcx.ccx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n+                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n                     }\n                 };\n-                let r = Callee::def(bcx.ccx, def_id, bcx.ccx.tcx().intern_substs(&[]))\n+                let r = Callee::def(bcx.ccx, def_id, bcx.tcx().intern_substs(&[]))\n                     .reify(bcx.ccx);\n                 let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n \n@@ -618,7 +618,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // will only succeed if both operands are constant.\n         // This is necessary to determine when an overflow Assert\n         // will always panic at runtime, and produce a warning.\n-        if let Some((val, of)) = const_scalar_checked_binop(bcx.ccx.tcx(), op, lhs, rhs, input_ty) {\n+        if let Some((val, of)) = const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n             return OperandValue::Pair(val, C_bool(bcx.ccx, of));\n         }\n \n@@ -687,7 +687,7 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};\n \n-    let tcx = bcx.ccx.tcx();\n+    let tcx = bcx.tcx();\n \n     let new_sty = match ty.sty {\n         TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {"}]}