{"sha": "67d6ce42063732d7c7b12d94f872dcafb5efb607", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZDZjZTQyMDYzNzMyZDdjN2IxMmQ5NGY4NzJkY2FmYjVlZmI2MDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T22:44:55Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-15T17:38:12Z"}, "message": "syntax_pos: `NO_EXPANSION`/`SyntaxContext::empty()` -> `SyntaxContext::root()`\n\nFor consistency with `ExpnId::root`.\n\nAlso introduce a helper `Span::with_root_ctxt` for creating spans with `SyntaxContext::root()` context", "tree": {"sha": "4e9a94b42b8eeb2bd71603ea5fdabef42bc8b134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e9a94b42b8eeb2bd71603ea5fdabef42bc8b134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67d6ce42063732d7c7b12d94f872dcafb5efb607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67d6ce42063732d7c7b12d94f872dcafb5efb607", "html_url": "https://github.com/rust-lang/rust/commit/67d6ce42063732d7c7b12d94f872dcafb5efb607", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67d6ce42063732d7c7b12d94f872dcafb5efb607/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfcbe75900f2cb813754ef104526ebce568fd75b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfcbe75900f2cb813754ef104526ebce568fd75b", "html_url": "https://github.com/rust-lang/rust/commit/dfcbe75900f2cb813754ef104526ebce568fd75b"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "39f6b0d434440abfa7429406bd8f9bad07108979", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -350,7 +350,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         let line_col_len = col | line | len;\n         std_hash::Hash::hash(&line_col_len, hasher);\n \n-        if span.ctxt == SyntaxContext::empty() {\n+        if span.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(hcx, hasher);"}, {"sha": "1c5baa638c2b1a6921946ad07bfdfec1f804fb76", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -592,7 +592,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n-        let location = || Span::new(lo, hi, SyntaxContext::empty());\n+        let location = || Span::with_root_ctxt(lo, hi);\n         let recover_from_expn_info = |this: &Self, expn_info, pos| {\n             let span = location().fresh_expansion(ExpnId::root(), expn_info);\n             this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n@@ -816,7 +816,7 @@ where\n         col_lo.encode(self)?;\n         len.encode(self)?;\n \n-        if span_data.ctxt == SyntaxContext::empty() {\n+        if span_data.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPANSION_INFO.encode(self)\n         } else {\n             let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();"}, {"sha": "4018a667bf26497ac9e88c4850538dae7558fe03", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -43,8 +43,7 @@ use syntax_pos::{BytePos,\n                  SourceFile,\n                  FileName,\n                  MultiSpan,\n-                 Span,\n-                 NO_EXPANSION};\n+                 Span};\n \n /// Indicates the confidence in the correctness of a suggestion.\n ///\n@@ -189,7 +188,7 @@ impl CodeSuggestion {\n             // Find the bounding span.\n             let lo = substitution.parts.iter().map(|part| part.span.lo()).min().unwrap();\n             let hi = substitution.parts.iter().map(|part| part.span.hi()).min().unwrap();\n-            let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n+            let bounding_span = Span::with_root_ctxt(lo, hi);\n             let lines = cm.span_to_lines(bounding_span).unwrap();\n             assert!(!lines.lines.is_empty());\n "}, {"sha": "b46758abb5f2c31439bfc71e645f0cc44c8106bb", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -35,7 +35,7 @@ use syntax::ext::proc_macro::BangProcMacro;\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{Span, NO_EXPANSION, FileName};\n+use syntax_pos::{Span, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n macro_rules! provide {\n@@ -443,7 +443,7 @@ impl cstore::CStore {\n         let source_name = FileName::Macros(macro_full_name);\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n-        let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n+        let local_span = Span::with_root_ctxt(source_file.start_pos, source_file.end_pos);\n         let (body, mut errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n         emit_unclosed_delims(&mut errors, &sess.diagnostic());\n "}, {"sha": "3de9bf4da11ea7421f1a37d3dabd36e36c4155ba", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map;\n use syntax::symbol::{Symbol, sym};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP, NO_EXPANSION};\n+use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n use log::debug;\n \n pub struct DecodeContext<'a, 'tcx> {\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let hi = (hi + source_file.translated_source_file.start_pos)\n                  - source_file.original_start_pos;\n \n-        Ok(Span::new(lo, hi, NO_EXPANSION))\n+        Ok(Span::with_root_ctxt(lo, hi))\n     }\n }\n "}, {"sha": "8b2e371f0f6121f8b603f96077b838e728405fb5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -1430,7 +1430,7 @@ impl<'a> Resolver<'a> {\n         }\n         let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n-            let empty_span = ident.span.with_ctxt(SyntaxContext::empty());\n+            let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n             let modern_span = ident.span.modern();"}, {"sha": "d9fd31db4dd60d2cf763e989d8b2fe73ff290376", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -762,7 +762,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n-        SyntaxContext::empty().apply_mark(self.current_expansion.id)\n+        SyntaxContext::root().apply_mark(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen."}, {"sha": "aa409199afd6d3fd6096cc29fd9d14eb20b78137", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -759,7 +759,7 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"macro expansion ignores token `{}` and any following\",\n                               self.this_token_to_string());\n             // Avoid emitting backtrace info twice.\n-            let def_site_span = self.token.span.with_ctxt(SyntaxContext::empty());\n+            let def_site_span = self.token.span.with_ctxt(SyntaxContext::root());\n             let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!("}, {"sha": "fd93910004efe87b75ce776c15eccb701a5619d2", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -365,7 +365,7 @@ impl<'a> Rustc<'a> {\n         let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n-                SyntaxContext::empty()\n+                SyntaxContext::root()\n                     .apply_mark_with_transparency(cx.current_expansion.id, transparency),\n             )\n         };"}, {"sha": "17629d392cd3d25acc18079c88ee8ac19045ee8c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -4,7 +4,7 @@ use crate::symbol::{sym, Symbol};\n use crate::parse::unescape_error_reporting::{emit_unescape_error, push_escaped_char};\n \n use errors::{FatalError, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n+use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n@@ -84,7 +84,7 @@ impl<'a> StringReader<'a> {\n \n \n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n-        self.override_span.unwrap_or_else(|| Span::new(lo, hi, NO_EXPANSION))\n+        self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }\n \n     /// Returns the next token, including trivia like whitespace or comments."}, {"sha": "1e4d9048b41b875e0fdf8a014ba51090c284ea70", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -9,7 +9,7 @@ use crate::diagnostics::plugin::ErrorMap;\n use crate::with_default_globals;\n use std::io;\n use std::path::PathBuf;\n-use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n+use syntax_pos::{BytePos, Span, edition::Edition};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_data_structures::sync::{Lock, Once};\n \n@@ -61,7 +61,7 @@ fn t1() {\n         let tok1 = string_reader.next_token();\n         let tok2 = Token::new(\n             mk_ident(\"fn\"),\n-            Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(21), BytePos(23)),\n         );\n         assert_eq!(tok1.kind, tok2.kind);\n         assert_eq!(tok1.span, tok2.span);\n@@ -71,7 +71,7 @@ fn t1() {\n         assert_eq!(string_reader.pos.clone(), BytePos(28));\n         let tok4 = Token::new(\n             mk_ident(\"main\"),\n-            Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n+            Span::with_root_ctxt(BytePos(24), BytePos(28)),\n         );\n         assert_eq!(tok3.kind, tok4.kind);\n         assert_eq!(tok3.span, tok4.span);"}, {"sha": "525b4215affb180c710009c4d2c8ac1383628c90", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -3,7 +3,7 @@\n \n use super::StringReader;\n use errors::{Applicability, DiagnosticBuilder};\n-use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION, symbol::kw};\n+use syntax_pos::{BytePos, Pos, Span, symbol::kw};\n use crate::parse::token;\n \n #[rustfmt::skip] // for line breaks\n@@ -343,7 +343,7 @@ crate fn check_for_substitution<'a>(\n         None => return None,\n     };\n \n-    let span = Span::new(pos, pos + Pos::from_usize(ch.len_utf8()), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(pos, pos + Pos::from_usize(ch.len_utf8()));\n \n     let (ascii_name, token) = match ASCII_ARRAY.iter().find(|&&(c, _, _)| c == ascii_char) {\n         Some((_ascii_char, ascii_name, token)) => (ascii_name, token),\n@@ -362,10 +362,9 @@ crate fn check_for_substitution<'a>(\n             ascii_char, ascii_name\n         );\n         err.span_suggestion(\n-            Span::new(\n+            Span::with_root_ctxt(\n                 pos,\n                 pos + Pos::from_usize('\u201c'.len_utf8() + s.len() + '\u201d'.len_utf8()),\n-                NO_EXPANSION,\n             ),\n             &msg,\n             format!(\"\\\"{}\\\"\", s),"}, {"sha": "6a789ef99d672c3d21655325382a56402b1283b8", "filename": "src/libsyntax/parse/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -12,7 +12,7 @@ use crate::symbol::{kw, sym};\n use crate::tests::{matches_codepattern, string_to_stream, with_error_checking_parse};\n use crate::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use crate::with_default_globals;\n-use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n+use syntax_pos::{Span, BytePos, Pos};\n \n use std::path::PathBuf;\n \n@@ -27,7 +27,7 @@ fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n \n // produce a syntax_pos::span\n fn sp(a: u32, b: u32) -> Span {\n-    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n /// Parse a string, return an expr"}, {"sha": "c7b8332c53ef721eec7decfd282a2391e9d5be64", "filename": "src/libsyntax/source_map/tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map%2Ftests.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -91,7 +91,7 @@ fn t6() {\n fn t7() {\n     // Test span_to_lines for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let file_lines = sm.span_to_lines(span).unwrap();\n \n     assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n@@ -107,7 +107,7 @@ fn span_from_selection(input: &str, selection: &str) -> Span {\n     assert_eq!(input.len(), selection.len());\n     let left_index = selection.find('~').unwrap() as u32;\n     let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-    Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(left_index), BytePos(right_index + 1))\n }\n \n /// Tests span_to_snippet and span_to_lines for a span converting 3\n@@ -137,7 +137,7 @@ fn span_to_snippet_and_lines_spanning_multiple_lines() {\n fn t8() {\n     // Test span_to_snippet for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let snippet = sm.span_to_snippet(span);\n \n     assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -147,7 +147,7 @@ fn t8() {\n fn t9() {\n     // Test span_to_str for a span ending at the end of source_file\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let sstr =  sm.span_to_string(span);\n \n     assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n@@ -198,10 +198,9 @@ impl SourceMapExtension for SourceMap {\n             let lo = hi + offset;\n             hi = lo + substring.len();\n             if i == n {\n-                let span = Span::new(\n+                let span = Span::with_root_ctxt(\n                     BytePos(lo as u32 + file.start_pos.0),\n                     BytePos(hi as u32 + file.start_pos.0),\n-                    NO_EXPANSION,\n                 );\n                 assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n                         substring);"}, {"sha": "4c0e1e3704dffa9df5b758fe68edd9440a5c527f", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -9,7 +9,7 @@ use crate::with_default_globals;\n use errors::emitter::EmitterWriter;\n use errors::Handler;\n use rustc_data_structures::sync::Lrc;\n-use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n+use syntax_pos::{BytePos, Span, MultiSpan};\n \n use std::io;\n use std::io::prelude::*;\n@@ -169,7 +169,7 @@ fn make_span(file_text: &str, start: &Position, end: &Position) -> Span {\n     let start = make_pos(file_text, start);\n     let end = make_pos(file_text, end) + end.string.len(); // just after matching thing ends\n     assert!(start <= end);\n-    Span::new(BytePos(start as u32), BytePos(end as u32), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(start as u32), BytePos(end as u32))\n }\n \n fn make_pos(file_text: &str, pos: &Position) -> usize {"}, {"sha": "5017e5f5424c10fa78a172e3059133e4f8bce23b", "filename": "src/libsyntax/tokenstream/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream%2Ftests.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -3,14 +3,14 @@ use super::*;\n use crate::ast::Name;\n use crate::with_default_globals;\n use crate::tests::string_to_stream;\n-use syntax_pos::{Span, BytePos, NO_EXPANSION};\n+use syntax_pos::{Span, BytePos};\n \n fn string_to_ts(string: &str) -> TokenStream {\n     string_to_stream(string.to_owned())\n }\n \n fn sp(a: u32, b: u32) -> Span {\n-    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n #[test]"}, {"sha": "b1f6f55732a935c8c6bc5cf66dc306dd8c622a06", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -29,7 +29,7 @@ pub fn expand(\n     };\n \n     // Generate a bunch of new items using the AllocFnFactory\n-    let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let span = item.span.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n     let f = AllocFnFactory {\n         span,\n         kind: AllocatorKind::Global,"}, {"sha": "08582e714ccb26aba0bb51c4b627740b8451af0e", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -29,7 +29,7 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let sp = attr_sp.with_ctxt(SyntaxContext::root().apply_mark(ecx.current_expansion.id));\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n@@ -93,7 +93,7 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let ctxt = SyntaxContext::empty().apply_mark(cx.current_expansion.id);\n+    let ctxt = SyntaxContext::root().apply_mark(cx.current_expansion.id);\n     let (sp, attr_sp) = (item.span.with_ctxt(ctxt), attr_sp.with_ctxt(ctxt));\n \n     // Gensym \"test\" so we can extern crate without conflicting with any local names"}, {"sha": "c832e058cdf2404388cad7f76d90303d107d65f0", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -246,7 +246,7 @@ impl HygieneData {\n \n     fn marks(&self, mut ctxt: SyntaxContext) -> Vec<(ExpnId, Transparency)> {\n         let mut marks = Vec::new();\n-        while ctxt != SyntaxContext::empty() {\n+        while ctxt != SyntaxContext::root() {\n             marks.push((self.outer_expn(ctxt), self.outer_transparency(ctxt)));\n             ctxt = self.parent_ctxt(ctxt);\n         }\n@@ -286,14 +286,14 @@ impl HygieneData {\n         }\n \n         let call_site_ctxt =\n-            self.expn_info(expn_id).map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n+            self.expn_info(expn_id).map_or(SyntaxContext::root(), |info| info.call_site.ctxt());\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n             self.modern_and_legacy(call_site_ctxt)\n         };\n \n-        if call_site_ctxt == SyntaxContext::empty() {\n+        if call_site_ctxt == SyntaxContext::root() {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n@@ -400,7 +400,7 @@ pub fn update_dollar_crate_names(mut get_name: impl FnMut(SyntaxContext) -> Symb\n \n impl SyntaxContext {\n     #[inline]\n-    pub const fn empty() -> Self {\n+    pub const fn root() -> Self {\n         SyntaxContext(0)\n     }\n \n@@ -615,7 +615,7 @@ impl Span {\n     pub fn fresh_expansion(self, parent: ExpnId, expn_info: ExpnInfo) -> Span {\n         HygieneData::with(|data| {\n             let expn_id = data.fresh_expn(parent, Some(expn_info));\n-            self.with_ctxt(data.apply_mark(SyntaxContext::empty(), expn_id))\n+            self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id))\n         })\n     }\n }\n@@ -775,6 +775,6 @@ impl Encodable for SyntaxContext {\n \n impl Decodable for SyntaxContext {\n     fn decode<D: Decoder>(_: &mut D) -> Result<SyntaxContext, D::Error> {\n-        Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n+        Ok(SyntaxContext::root()) // FIXME(jseyfried) intercrate hygiene\n     }\n }"}, {"sha": "7c8539198b96e78e9022483b147d3885fb4d76e4", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d6ce42063732d7c7b12d94f872dcafb5efb607/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=67d6ce42063732d7c7b12d94f872dcafb5efb607", "patch": "@@ -291,7 +291,12 @@ impl Span {\n     /// Returns `true` if this span comes from a macro or desugaring.\n     #[inline]\n     pub fn from_expansion(self) -> bool {\n-        self.ctxt() != SyntaxContext::empty()\n+        self.ctxt() != SyntaxContext::root()\n+    }\n+\n+    #[inline]\n+    pub fn with_root_ctxt(lo: BytePos, hi: BytePos) -> Span {\n+        Span::new(lo, hi, SyntaxContext::root())\n     }\n \n     /// Returns a new span representing an empty span at the beginning of this span\n@@ -474,9 +479,9 @@ impl Span {\n         // Return the macro span on its own to avoid weird diagnostic output. It is preferable to\n         // have an incomplete span than a completely nonsensical one.\n         if span_data.ctxt != end_data.ctxt {\n-            if span_data.ctxt == SyntaxContext::empty() {\n+            if span_data.ctxt == SyntaxContext::root() {\n                 return end;\n-            } else if end_data.ctxt == SyntaxContext::empty() {\n+            } else if end_data.ctxt == SyntaxContext::root() {\n                 return self;\n             }\n             // Both spans fall within a macro.\n@@ -485,7 +490,7 @@ impl Span {\n         Span::new(\n             cmp::min(span_data.lo, end_data.lo),\n             cmp::max(span_data.hi, end_data.hi),\n-            if span_data.ctxt == SyntaxContext::empty() { end_data.ctxt } else { span_data.ctxt },\n+            if span_data.ctxt == SyntaxContext::root() { end_data.ctxt } else { span_data.ctxt },\n         )\n     }\n \n@@ -496,7 +501,7 @@ impl Span {\n         Span::new(\n             span.hi,\n             end.lo,\n-            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n+            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n@@ -507,7 +512,7 @@ impl Span {\n         Span::new(\n             span.lo,\n             end.lo,\n-            if end.ctxt == SyntaxContext::empty() { end.ctxt } else { span.ctxt },\n+            if end.ctxt == SyntaxContext::root() { end.ctxt } else { span.ctxt },\n         )\n     }\n \n@@ -617,7 +622,7 @@ impl rustc_serialize::UseSpecializedDecodable for Span {\n         d.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(Span::new(lo, hi, NO_EXPANSION))\n+            Ok(Span::with_root_ctxt(lo, hi))\n         })\n     }\n }\n@@ -761,8 +766,6 @@ impl From<Vec<Span>> for MultiSpan {\n     }\n }\n \n-pub const NO_EXPANSION: SyntaxContext = SyntaxContext::empty();\n-\n /// Identifies an offset of a multi-byte character in a `SourceFile`.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {"}]}