{"sha": "a17735cfb590b18f297771360616bc3ccf785406", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNzczNWNmYjU5MGIxOGYyOTc3NzEzNjA2MTZiYzNjY2Y3ODU0MDY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-26T21:47:44Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-26T21:47:44Z"}, "message": "Some simple cleanup of trans_bind.", "tree": {"sha": "ebcb8b5316381e59c012e46bac2ff497bb567817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebcb8b5316381e59c012e46bac2ff497bb567817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a17735cfb590b18f297771360616bc3ccf785406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a17735cfb590b18f297771360616bc3ccf785406", "html_url": "https://github.com/rust-lang/rust/commit/a17735cfb590b18f297771360616bc3ccf785406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a17735cfb590b18f297771360616bc3ccf785406/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be0629d88059a8cd7ce97534385bf513315a3685", "url": "https://api.github.com/repos/rust-lang/rust/commits/be0629d88059a8cd7ce97534385bf513315a3685", "html_url": "https://github.com/rust-lang/rust/commit/be0629d88059a8cd7ce97534385bf513315a3685"}], "stats": {"total": 334, "additions": 162, "deletions": 172}, "files": [{"sha": "28e3f42f70ce82382aebdd5d85d03a2a52bfc36e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 162, "deletions": 172, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/a17735cfb590b18f297771360616bc3ccf785406/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17735cfb590b18f297771360616bc3ccf785406/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a17735cfb590b18f297771360616bc3ccf785406", "patch": "@@ -4616,187 +4616,177 @@ fn trans_bind_1(&@block_ctxt cx, &@ast::expr f, &lval_result f_res,\n                 &(option::t[@ast::expr])[] args, ast::node_id id) -> result {\n     if (f_res.is_mem) {\n         bcx_ccx(cx).sess.unimpl(\"re-binding existing function\");\n-    } else {\n-        let (@ast::expr)[] bound = ~[];\n-        for (option::t[@ast::expr] argopt in args) {\n-            alt (argopt) {\n-                case (none) { }\n-                case (some(?e)) { bound += ~[e]; }\n-            }\n-        }\n+    }\n \n-        // Figure out which tydescs we need to pass, if any.\n-        let ty::t outgoing_fty;\n-        let ValueRef[] lltydescs;\n-        alt (f_res.generic) {\n-            case (none) {\n-                outgoing_fty = ty::expr_ty(bcx_tcx(cx), f);\n-                lltydescs = ~[];\n-            }\n-            case (some(?ginfo)) {\n-                lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n-                outgoing_fty = ginfo.item_type;\n-                lltydescs = ginfo.tydescs;\n-            }\n+    let (@ast::expr)[] bound = ~[];\n+    for (option::t[@ast::expr] argopt in args) {\n+        alt (argopt) {\n+          case (none) { }\n+          case (some(?e)) { bound += ~[e]; }\n         }\n-        auto ty_param_count = std::ivec::len[ValueRef](lltydescs);\n-        if (std::ivec::len[@ast::expr](bound) == 0u && ty_param_count == 0u) {\n-\n-            // Trivial 'binding': just return the static pair-ptr.\n-            ret f_res.res;\n-        } else {\n-            auto bcx = f_res.res.bcx;\n-            auto pair_t = node_type(bcx_ccx(cx), cx.sp, id);\n-            auto pair_v = alloca(bcx, pair_t);\n-\n-            // Translate the bound expressions.\n-            let ty::t[] bound_tys = ~[];\n-            let lval_result[] bound_vals = ~[];\n-            for (@ast::expr e in bound) {\n-                auto lv = trans_lval(bcx, e);\n-                bcx = lv.res.bcx;\n-                bound_vals += ~[lv];\n-                bound_tys += ~[ty::expr_ty(bcx_tcx(cx), e)];\n-            }\n-\n-            // Synthesize a closure type.\n-\n-            // First, synthesize a tuple type containing the types of all the\n-            // bound expressions.\n-            // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n-\n-            let ty::t bindings_ty = ty::mk_imm_tup(bcx_tcx(cx),\n-                                                   bound_tys);\n-\n-            // NB: keep this in sync with T_closure_ptr; we're making\n-            // a ty::t structure that has the same \"shape\" as the LLVM type\n-            // it constructs.\n-\n-            // Make a vector that contains ty_param_count copies of tydesc_ty.\n-            // (We'll need room for that many tydescs in the closure.)\n-            let ty::t tydesc_ty = ty::mk_type(bcx_tcx(cx));\n-            let ty::t[] captured_tys =\n-                std::ivec::init_elt[ty::t](tydesc_ty, ty_param_count);\n-\n-            // Get all the types we've got (some of which we synthesized\n-            // ourselves) into a vector.  The whole things ends up looking\n-            // like:\n-\n-            // closure_tys = [tydesc_ty, outgoing_fty, [bound_ty1, bound_ty2,\n-            // ...], [tydesc_ty, tydesc_ty, ...]]\n-            let ty::t[] closure_tys =\n-                ~[tydesc_ty, outgoing_fty, bindings_ty,\n-                  ty::mk_imm_tup(bcx_tcx(cx), captured_tys)];\n+    }\n \n-            // Finally, synthesize a type for that whole vector.\n-            let ty::t closure_ty =\n-                ty::mk_imm_tup(bcx_tcx(cx), closure_tys);\n+    // Figure out which tydescs we need to pass, if any.\n+    let ty::t outgoing_fty;\n+    let ValueRef[] lltydescs;\n+    alt (f_res.generic) {\n+      case (none) {\n+        outgoing_fty = ty::expr_ty(bcx_tcx(cx), f);\n+        lltydescs = ~[];\n+      }\n+      case (some(?ginfo)) {\n+        lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n+        outgoing_fty = ginfo.item_type;\n+        lltydescs = ginfo.tydescs;\n+      }\n+    }\n+    auto ty_param_count = std::ivec::len[ValueRef](lltydescs);\n+    if (std::ivec::len[@ast::expr](bound) == 0u && ty_param_count == 0u) {\n \n-            // Allocate a box that can hold something closure-sized, including\n-            // space for a refcount.\n-            auto r = trans_malloc_boxed(bcx, closure_ty);\n-            auto box = r.val;\n-            bcx = r.bcx;\n+        // Trivial 'binding': just return the static pair-ptr.\n+        ret f_res.res;\n+    }\n+    auto bcx = f_res.res.bcx;\n+    auto pair_t = node_type(bcx_ccx(cx), cx.sp, id);\n+    auto pair_v = alloca(bcx, pair_t);\n \n-            // Grab onto the refcount and body parts of the box we allocated.\n-            auto rc =\n-                bcx.build.GEP(box,\n-                              ~[C_int(0), C_int(abi::box_rc_field_refcnt)]);\n-            auto closure =\n-                bcx.build.GEP(box, ~[C_int(0),\n-                                     C_int(abi::box_rc_field_body)]);\n-            bcx.build.Store(C_int(1), rc);\n-\n-            // Store bindings tydesc.\n-            auto bound_tydesc =\n-                bcx.build.GEP(closure,\n-                              ~[C_int(0), C_int(abi::closure_elt_tydesc)]);\n-            auto ti = none[@tydesc_info];\n-            auto bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n-            lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n-            lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n-            bcx = bindings_tydesc.bcx;\n-            bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n-\n-            // Determine the LLVM type for the outgoing function type. This\n-            // may be different from the type returned by trans_malloc_boxed()\n-            // since we have more information than that function does;\n-            // specifically, we know how many type descriptors the outgoing\n-            // function has, which type_of() doesn't, as only we know which\n-            // item the function refers to.\n-            auto llfnty =\n-                type_of_fn(bcx_ccx(bcx), cx.sp,\n-                           ty::ty_fn_proto(bcx_tcx(bcx), outgoing_fty),\n-                           ty::ty_fn_args(bcx_tcx(bcx), outgoing_fty),\n-                           ty::ty_fn_ret(bcx_tcx(bcx), outgoing_fty),\n-                           ty_param_count);\n-            auto llclosurety = T_ptr(T_fn_pair(*bcx_ccx(bcx), llfnty));\n-\n-            // Store thunk-target.\n-            auto bound_target =\n-                bcx.build.GEP(closure,\n-                              ~[C_int(0), C_int(abi::closure_elt_target)]);\n-            auto src = bcx.build.Load(f_res.res.val);\n-            bound_target = bcx.build.PointerCast(bound_target, llclosurety);\n-            bcx.build.Store(src, bound_target);\n-\n-            // Copy expr values into boxed bindings.\n-            auto i = 0u;\n-            auto bindings =\n-                bcx.build.GEP(closure,\n-                              ~[C_int(0), C_int(abi::closure_elt_bindings)]);\n-            for (lval_result lv in bound_vals) {\n-                auto bound =\n-                    bcx.build.GEP(bindings, ~[C_int(0), C_int(i as int)]);\n-                bcx = move_val_if_temp(bcx, INIT, bound, lv,\n-                                       bound_tys.(i)).bcx;\n-                i += 1u;\n-            }\n+    // Translate the bound expressions.\n+    let ty::t[] bound_tys = ~[];\n+    let lval_result[] bound_vals = ~[];\n+    for (@ast::expr e in bound) {\n+        auto lv = trans_lval(bcx, e);\n+        bcx = lv.res.bcx;\n+        bound_vals += ~[lv];\n+        bound_tys += ~[ty::expr_ty(bcx_tcx(cx), e)];\n+    }\n+\n+    // Synthesize a closure type.\n+\n+    // First, synthesize a tuple type containing the types of all the\n+    // bound expressions.\n+    // bindings_ty = ~[bound_ty1, bound_ty2, ...]\n+\n+    let ty::t bindings_ty = ty::mk_imm_tup(bcx_tcx(cx), bound_tys);\n+\n+    // NB: keep this in sync with T_closure_ptr; we're making\n+    // a ty::t structure that has the same \"shape\" as the LLVM type\n+    // it constructs.\n+\n+    // Make a vector that contains ty_param_count copies of tydesc_ty.\n+    // (We'll need room for that many tydescs in the closure.)\n+    let ty::t tydesc_ty = ty::mk_type(bcx_tcx(cx));\n+    let ty::t[] captured_tys = std::ivec::init_elt(tydesc_ty, ty_param_count);\n+\n+    // Get all the types we've got (some of which we synthesized\n+    // ourselves) into a vector.  The whole things ends up looking\n+    // like:\n+\n+    // closure_tys = [tydesc_ty, outgoing_fty, [bound_ty1, bound_ty2,\n+    // ...], [tydesc_ty, tydesc_ty, ...]]\n+    let ty::t[] closure_tys =\n+        ~[tydesc_ty, outgoing_fty, bindings_ty,\n+          ty::mk_imm_tup(bcx_tcx(cx), captured_tys)];\n+\n+    // Finally, synthesize a type for that whole vector.\n+    let ty::t closure_ty =\n+        ty::mk_imm_tup(bcx_tcx(cx), closure_tys);\n+\n+    // Allocate a box that can hold something closure-sized, including\n+    // space for a refcount.\n+    auto r = trans_malloc_boxed(bcx, closure_ty);\n+    auto box = r.val;\n+    bcx = r.bcx;\n+\n+    // Grab onto the refcount and body parts of the box we allocated.\n+    auto rc =\n+        bcx.build.GEP(box, ~[C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+    auto closure =\n+        bcx.build.GEP(box, ~[C_int(0), C_int(abi::box_rc_field_body)]);\n+    bcx.build.Store(C_int(1), rc);\n+\n+    // Store bindings tydesc.\n+    auto bound_tydesc =\n+        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_tydesc)]);\n+    auto ti = none;\n+    auto bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n+    bcx = bindings_tydesc.bcx;\n+    bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n+\n+    // Determine the LLVM type for the outgoing function type. This\n+    // may be different from the type returned by trans_malloc_boxed()\n+    // since we have more information than that function does;\n+    // specifically, we know how many type descriptors the outgoing\n+    // function has, which type_of() doesn't, as only we know which\n+    // item the function refers to.\n+    auto llfnty =\n+        type_of_fn(bcx_ccx(bcx), cx.sp,\n+                   ty::ty_fn_proto(bcx_tcx(bcx), outgoing_fty),\n+                   ty::ty_fn_args(bcx_tcx(bcx), outgoing_fty),\n+                   ty::ty_fn_ret(bcx_tcx(bcx), outgoing_fty),\n+                   ty_param_count);\n+    auto llclosurety = T_ptr(T_fn_pair(*bcx_ccx(bcx), llfnty));\n+\n+    // Store thunk-target.\n+    auto bound_target =\n+        bcx.build.GEP(closure, ~[C_int(0), C_int(abi::closure_elt_target)]);\n+    auto src = bcx.build.Load(f_res.res.val);\n+    bound_target = bcx.build.PointerCast(bound_target, llclosurety);\n+    bcx.build.Store(src, bound_target);\n+\n+    // Copy expr values into boxed bindings.\n+    auto i = 0u;\n+    auto bindings =\n+        bcx.build.GEP(closure,\n+                      ~[C_int(0), C_int(abi::closure_elt_bindings)]);\n+    for (lval_result lv in bound_vals) {\n+        auto bound =\n+            bcx.build.GEP(bindings, ~[C_int(0), C_int(i as int)]);\n+        bcx = move_val_if_temp(bcx, INIT, bound, lv, bound_tys.(i)).bcx;\n+        i += 1u;\n+    }\n \n-            // If necessary, copy tydescs describing type parameters into the\n-            // appropriate slot in the closure.\n-            alt (f_res.generic) {\n-                case (none) {/* nothing to do */ }\n-                case (some(?ginfo)) {\n-                    lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n-                    auto ty_params_slot =\n-                        bcx.build.GEP(closure,\n-                                      ~[C_int(0),\n-                                        C_int(abi::closure_elt_ty_params)]);\n-                    auto i = 0;\n-                    for (ValueRef td in ginfo.tydescs) {\n-                        auto ty_param_slot =\n-                            bcx.build.GEP(ty_params_slot,\n-                                          ~[C_int(0), C_int(i)]);\n-                        bcx.build.Store(td, ty_param_slot);\n-                        i += 1;\n-                    }\n-                    outgoing_fty = ginfo.item_type;\n-                }\n-            }\n+    // If necessary, copy tydescs describing type parameters into the\n+    // appropriate slot in the closure.\n+    alt (f_res.generic) {\n+      case (none) {/* nothing to do */ }\n+      case (some(?ginfo)) {\n+        lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n+        auto ty_params_slot =\n+            bcx.build.GEP(closure,\n+                          ~[C_int(0), C_int(abi::closure_elt_ty_params)]);\n+        auto i = 0;\n+        for (ValueRef td in ginfo.tydescs) {\n+            auto ty_param_slot = bcx.build.GEP(ty_params_slot,\n+                                               ~[C_int(0), C_int(i)]);\n+            bcx.build.Store(td, ty_param_slot);\n+            i += 1;\n+        }\n+        outgoing_fty = ginfo.item_type;\n+      }\n+    }\n \n-            // Make thunk and store thunk-ptr in outer pair's code slot.\n-            auto pair_code =\n-                bcx.build.GEP(pair_v, ~[C_int(0), C_int(abi::fn_field_code)]);\n-            // The type of the entire bind expression.\n-            let ty::t pair_ty = node_id_type(bcx_ccx(cx), id);\n+    // Make thunk and store thunk-ptr in outer pair's code slot.\n+    auto pair_code =\n+        bcx.build.GEP(pair_v, ~[C_int(0), C_int(abi::fn_field_code)]);\n+    // The type of the entire bind expression.\n+    let ty::t pair_ty = node_id_type(bcx_ccx(cx), id);\n \n-            let ValueRef llthunk =\n-                trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty,\n-                                 args, closure_ty, bound_tys, ty_param_count);\n-            bcx.build.Store(llthunk, pair_code);\n+    let ValueRef llthunk =\n+        trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty,\n+                         args, closure_ty, bound_tys, ty_param_count);\n+    bcx.build.Store(llthunk, pair_code);\n \n-            // Store box ptr in outer pair's box slot.\n-            auto ccx = *bcx_ccx(bcx);\n-            auto pair_box =\n-                bcx.build.GEP(pair_v, ~[C_int(0), C_int(abi::fn_field_box)]);\n-            bcx.build.Store(bcx.build.PointerCast(box,\n-                                                  T_opaque_closure_ptr(ccx)),\n-                            pair_box);\n-            add_clean_temp(cx, pair_v, pair_ty);\n-            ret rslt(bcx, pair_v);\n-        }\n-    }\n+    // Store box ptr in outer pair's box slot.\n+    auto ccx = *bcx_ccx(bcx);\n+    auto pair_box =\n+        bcx.build.GEP(pair_v, ~[C_int(0), C_int(abi::fn_field_box)]);\n+    bcx.build.Store(\n+        bcx.build.PointerCast(box, T_opaque_closure_ptr(ccx)),\n+        pair_box);\n+    add_clean_temp(cx, pair_v, pair_ty);\n+    ret rslt(bcx, pair_v);\n }\n \n fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,"}]}