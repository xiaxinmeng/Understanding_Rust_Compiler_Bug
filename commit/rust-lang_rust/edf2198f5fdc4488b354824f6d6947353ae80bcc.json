{"sha": "edf2198f5fdc4488b354824f6d6947353ae80bcc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZjIxOThmNWZkYzQ0ODhiMzU0ODI0ZjZkNjk0NzM1M2FlODBiY2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-25T08:14:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-25T08:14:39Z"}, "message": "Auto merge of #30034 - brson:rust_path, r=alexcrichton\n\nThis was to support rustpkg but is unused now.", "tree": {"sha": "c6ba75273ecde625644f4fcdfeb4d0c4d13eb6f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6ba75273ecde625644f4fcdfeb4d0c4d13eb6f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edf2198f5fdc4488b354824f6d6947353ae80bcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edf2198f5fdc4488b354824f6d6947353ae80bcc", "html_url": "https://github.com/rust-lang/rust/commit/edf2198f5fdc4488b354824f6d6947353ae80bcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edf2198f5fdc4488b354824f6d6947353ae80bcc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ed03c81d906f55754d892bb2f7fda7f38e2217e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed03c81d906f55754d892bb2f7fda7f38e2217e", "html_url": "https://github.com/rust-lang/rust/commit/8ed03c81d906f55754d892bb2f7fda7f38e2217e"}, {"sha": "1b7b2fe36b3e9cdf05d0f80d36fc2a8a2798733d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b7b2fe36b3e9cdf05d0f80d36fc2a8a2798733d", "html_url": "https://github.com/rust-lang/rust/commit/1b7b2fe36b3e9cdf05d0f80d36fc2a8a2798733d"}], "stats": {"total": 102, "additions": 4, "deletions": 98}, "files": [{"sha": "09c6b54d99cf88242a6e5e09c9dc0690a650046b", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 95, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/edf2198f5fdc4488b354824f6d6947353ae80bcc/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf2198f5fdc4488b354824f6d6947353ae80bcc/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=edf2198f5fdc4488b354824f6d6947353ae80bcc", "patch": "@@ -40,52 +40,23 @@ pub struct FileSearch<'a> {\n \n impl<'a> FileSearch<'a> {\n     pub fn for_each_lib_search_path<F>(&self, mut f: F) where\n-        F: FnMut(&Path, PathKind) -> FileMatch,\n+        F: FnMut(&Path, PathKind)\n     {\n         let mut visited_dirs = HashSet::new();\n-        let mut found = false;\n \n         for (path, kind) in self.search_paths.iter(self.kind) {\n-            match f(path, kind) {\n-                FileMatches => found = true,\n-                FileDoesntMatch => ()\n-            }\n+            f(path, kind);\n             visited_dirs.insert(path.to_path_buf());\n         }\n \n         debug!(\"filesearch: searching lib path\");\n         let tlib_path = make_target_lib_path(self.sysroot,\n                                              self.triple);\n         if !visited_dirs.contains(&tlib_path) {\n-            match f(&tlib_path, PathKind::All) {\n-                FileMatches => found = true,\n-                FileDoesntMatch => ()\n-            }\n+            f(&tlib_path, PathKind::All);\n         }\n \n         visited_dirs.insert(tlib_path);\n-        // Try RUST_PATH\n-        if !found {\n-            let rustpath = rust_path();\n-            for path in &rustpath {\n-                let tlib_path = make_rustpkg_lib_path(\n-                    self.sysroot, path, self.triple);\n-                debug!(\"is {} in visited_dirs? {}\", tlib_path.display(),\n-                        visited_dirs.contains(&tlib_path));\n-\n-                if !visited_dirs.contains(&tlib_path) {\n-                    visited_dirs.insert(tlib_path.clone());\n-                    // Don't keep searching the RUST_PATH if one match turns up --\n-                    // if we did, we'd get a \"multiple matching crates\" error\n-                    match f(&tlib_path, PathKind::All) {\n-                       FileMatches => {\n-                           break;\n-                       }\n-                       FileDoesntMatch => ()\n-                    }\n-                }\n-            }\n-        }\n     }\n \n     pub fn get_lib_path(&self) -> PathBuf {\n@@ -101,7 +72,6 @@ impl<'a> FileSearch<'a> {\n                 Ok(files) => {\n                     let files = files.filter_map(|p| p.ok().map(|s| s.path()))\n                                      .collect::<Vec<_>>();\n-                    let mut rslt = FileDoesntMatch;\n                     fn is_rlib(p: &Path) -> bool {\n                         p.extension().and_then(|s| s.to_str()) == Some(\"rlib\")\n                     }\n@@ -117,16 +87,14 @@ impl<'a> FileSearch<'a> {\n                         match maybe_picked {\n                             FileMatches => {\n                                 debug!(\"picked {}\", path.display());\n-                                rslt = FileMatches;\n                             }\n                             FileDoesntMatch => {\n                                 debug!(\"rejected {}\", path.display());\n                             }\n                         }\n                     }\n-                    rslt\n                 }\n-                Err(..) => FileDoesntMatch,\n+                Err(..) => (),\n             }\n         });\n     }\n@@ -149,7 +117,6 @@ impl<'a> FileSearch<'a> {\n         let mut paths = Vec::new();\n         self.for_each_lib_search_path(|lib_search_path, _| {\n             paths.push(lib_search_path.to_path_buf());\n-            FileDoesntMatch\n         });\n         paths\n     }\n@@ -179,14 +146,6 @@ fn make_target_lib_path(sysroot: &Path,\n     sysroot.join(&relative_target_lib_path(sysroot, target_triple))\n }\n \n-fn make_rustpkg_lib_path(sysroot: &Path,\n-                         dir: &Path,\n-                         triple: &str) -> PathBuf {\n-    let mut p = dir.join(&find_libdir(sysroot));\n-    p.push(triple);\n-    p\n-}\n-\n pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n     fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n@@ -207,56 +166,6 @@ pub fn get_or_default_sysroot() -> PathBuf {\n     }\n }\n \n-#[cfg(windows)]\n-const PATH_ENTRY_SEPARATOR: char = ';';\n-#[cfg(not(windows))]\n-const PATH_ENTRY_SEPARATOR: char = ':';\n-\n-/// Returns RUST_PATH as a string, without default paths added\n-pub fn get_rust_path() -> Option<String> {\n-    env::var(\"RUST_PATH\").ok()\n-}\n-\n-/// Returns the value of RUST_PATH, as a list\n-/// of Paths. Includes default entries for, if they exist:\n-/// $HOME/.rust\n-/// DIR/.rust for any DIR that's the current working directory\n-/// or an ancestor of it\n-pub fn rust_path() -> Vec<PathBuf> {\n-    let mut env_rust_path: Vec<PathBuf> = match get_rust_path() {\n-        Some(env_path) => {\n-            let env_path_components =\n-                env_path.split(PATH_ENTRY_SEPARATOR);\n-            env_path_components.map(|s| PathBuf::from(s)).collect()\n-        }\n-        None => Vec::new()\n-    };\n-    let cwd = env::current_dir().unwrap();\n-    // now add in default entries\n-    let cwd_dot_rust = cwd.join(\".rust\");\n-    if !env_rust_path.contains(&cwd_dot_rust) {\n-        env_rust_path.push(cwd_dot_rust);\n-    }\n-    if !env_rust_path.contains(&cwd) {\n-        env_rust_path.push(cwd.clone());\n-    }\n-    let mut cur = &*cwd;\n-    while let Some(parent) = cur.parent() {\n-        let candidate = parent.join(\".rust\");\n-        if !env_rust_path.contains(&candidate) && candidate.exists() {\n-            env_rust_path.push(candidate.clone());\n-        }\n-        cur = parent;\n-    }\n-    if let Some(h) = env::home_dir() {\n-        let p = h.join(\".rust\");\n-        if !env_rust_path.contains(&p) && p.exists() {\n-            env_rust_path.push(p);\n-        }\n-    }\n-    env_rust_path\n-}\n-\n // The name of the directory rustc expects libraries to be located.\n fn find_libdir(sysroot: &Path) -> String {\n     // FIXME: This is a quick hack to make the rustc binary able to locate"}, {"sha": "e0cbdbeaef3e33b4cd48e231c609a8bf0af93125", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/edf2198f5fdc4488b354824f6d6947353ae80bcc/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edf2198f5fdc4488b354824f6d6947353ae80bcc/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=edf2198f5fdc4488b354824f6d6947353ae80bcc", "patch": "@@ -20,7 +20,6 @@ use session::config::{OutputFilenames, Input, OutputType};\n use session::search_paths::PathKind;\n use session::Session;\n use metadata::common::LinkMeta;\n-use metadata::filesearch::FileDoesntMatch;\n use metadata::loader::METADATA_FILENAME;\n use metadata::{encoder, cstore, filesearch, csearch, creader};\n use middle::dependency_format::Linkage;\n@@ -588,7 +587,6 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     let mut search = Vec::new();\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n         search.push(path.to_path_buf());\n-        FileDoesntMatch\n     });\n     return search;\n }\n@@ -1085,7 +1083,6 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n             PathKind::Framework => { cmd.framework_path(path); }\n             _ => { cmd.include_path(&fix_windows_verbatim_for_gcc(path)); }\n         }\n-        FileDoesntMatch\n     });\n \n     let libs = sess.cstore.get_used_libraries();"}]}