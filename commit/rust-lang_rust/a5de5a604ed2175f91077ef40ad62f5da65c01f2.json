{"sha": "a5de5a604ed2175f91077ef40ad62f5da65c01f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZGU1YTYwNGVkMjE3NWY5MTA3N2VmNDBhZDYyZjVkYTY1YzAxZjI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-09-21T11:49:14Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril@gmail.com", "date": "2019-10-27T17:34:21Z"}, "message": "Run `rustfmt`", "tree": {"sha": "213e8b6f7da5933f867859ca4bd48a3d534bc8d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/213e8b6f7da5933f867859ca4bd48a3d534bc8d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5de5a604ed2175f91077ef40ad62f5da65c01f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5de5a604ed2175f91077ef40ad62f5da65c01f2", "html_url": "https://github.com/rust-lang/rust/commit/a5de5a604ed2175f91077ef40ad62f5da65c01f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5de5a604ed2175f91077ef40ad62f5da65c01f2/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6", "html_url": "https://github.com/rust-lang/rust/commit/0f677c65e867d93a47ccbaeaf6e6725cde8c5ff6"}], "stats": {"total": 973, "additions": 497, "deletions": 476}, "files": [{"sha": "322ab115cda44a67987907f9f6167d2534f00fba", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 364, "deletions": 372, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/a5de5a604ed2175f91077ef40ad62f5da65c01f2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de5a604ed2175f91077ef40ad62f5da65c01f2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a5de5a604ed2175f91077ef40ad62f5da65c01f2", "patch": "@@ -155,39 +155,38 @@\n ///     + If some constructors are missing from the matrix, it turns out we don't need to do\n ///       anything special (because we know none of the integers are actually wildcards: i.e., we\n ///       can't span wildcards using ranges).\n-\n use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n+use super::{compare_const_vals, PatternFoldable, PatternFolder};\n use super::{FieldPat, Pat, PatKind, PatRange};\n-use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::{RangeEnd, HirId};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n-use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n+use rustc::hir::{HirId, RangeEnd};\n+use rustc::ty::layout::{Integer, IntegerExt, Size, VariantIdx};\n+use rustc::ty::{self, Const, Ty, TyCtxt, TypeFoldable};\n \n+use rustc::lint;\n+use rustc::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n use rustc::mir::Field;\n-use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n use rustc::util::common::ErrorReported;\n-use rustc::lint;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n \n-use smallvec::{SmallVec, smallvec};\n-use std::cmp::{self, Ordering, min, max};\n+use smallvec::{smallvec, SmallVec};\n+use std::cmp::{self, max, min, Ordering};\n+use std::convert::TryInto;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n use std::u128;\n-use std::convert::TryInto;\n \n pub fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n     LiteralExpander { tcx: cx.tcx }.fold_pattern(&pat)\n@@ -216,11 +215,8 @@ impl LiteralExpander<'tcx> {\n             // the easy case, deref a reference\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n                 let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n-                ConstValue::ByRef {\n-                    alloc,\n-                    offset: p.offset,\n-                }\n-            },\n+                ConstValue::ByRef { alloc, offset: p.offset }\n+            }\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n@@ -229,12 +225,11 @@ impl LiteralExpander<'tcx> {\n                     start: p.offset.bytes().try_into().unwrap(),\n                     end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n                 }\n-            },\n+            }\n             // fat pointers stay the same\n-            | (ConstValue::Slice { .. }, _, _)\n+            (ConstValue::Slice { .. }, _, _)\n             | (_, ty::Slice(_), ty::Slice(_))\n-            | (_, ty::Str, ty::Str)\n-            => val,\n+            | (_, ty::Str, ty::Str) => val,\n             // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n             _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n         }\n@@ -247,40 +242,36 @@ impl PatternFolder<'tcx> for LiteralExpander<'tcx> {\n         match (&pat.ty.kind, &*pat.kind) {\n             (\n                 &ty::Ref(_, rty, _),\n-                &PatKind::Constant { value: Const {\n-                    val,\n-                    ty: ty::TyS { kind: ty::Ref(_, crty, _), .. },\n-                } },\n-            ) => {\n-                Pat {\n-                    ty: pat.ty,\n-                    span: pat.span,\n-                    kind: box PatKind::Deref {\n-                        subpattern: Pat {\n-                            ty: rty,\n-                            span: pat.span,\n-                            kind: box PatKind::Constant { value: self.tcx.mk_const(Const {\n+                &PatKind::Constant {\n+                    value: Const { val, ty: ty::TyS { kind: ty::Ref(_, crty, _), .. } },\n+                },\n+            ) => Pat {\n+                ty: pat.ty,\n+                span: pat.span,\n+                kind: box PatKind::Deref {\n+                    subpattern: Pat {\n+                        ty: rty,\n+                        span: pat.span,\n+                        kind: box PatKind::Constant {\n+                            value: self.tcx.mk_const(Const {\n                                 val: self.fold_const_value_deref(*val, rty, crty),\n                                 ty: rty,\n-                            }) },\n-                        }\n-                    }\n-                }\n-            }\n-            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => {\n-                s.fold_with(self)\n-            }\n-            _ => pat.super_fold_with(self)\n+                            }),\n+                        },\n+                    },\n+                },\n+            },\n+            (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n+            _ => pat.super_fold_with(self),\n         }\n     }\n }\n \n impl<'tcx> Pat<'tcx> {\n     fn is_wildcard(&self) -> bool {\n         match *self.kind {\n-            PatKind::Binding { subpattern: None, .. } | PatKind::Wild =>\n-                true,\n-            _ => false\n+            PatKind::Binding { subpattern: None, .. } | PatKind::Wild => true,\n+            _ => false,\n         }\n     }\n }\n@@ -316,15 +307,14 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n         write!(f, \"\\n\")?;\n \n         let &Matrix(ref m) = self;\n-        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n-            row.iter().map(|pat| format!(\"{:?}\", pat)).collect()\n-        }).collect();\n+        let pretty_printed_matrix: Vec<Vec<String>> =\n+            m.iter().map(|row| row.iter().map(|pat| format!(\"{:?}\", pat)).collect()).collect();\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n-        }).collect();\n+        let column_widths: Vec<usize> = (0..column_count)\n+            .map(|col| pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0))\n+            .collect();\n \n         let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n         let br = \"+\".repeat(total_width);\n@@ -345,7 +335,8 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n \n impl<'p, 'tcx> FromIterator<SmallVec<[&'p Pat<'tcx>; 2]>> for Matrix<'p, 'tcx> {\n     fn from_iter<T>(iter: T) -> Self\n-        where T: IntoIterator<Item=SmallVec<[&'p Pat<'tcx>; 2]>>\n+    where\n+        T: IntoIterator<Item = SmallVec<[&'p Pat<'tcx>; 2]>>,\n     {\n         Matrix(iter.into_iter().collect())\n     }\n@@ -461,7 +452,7 @@ impl<'tcx> Constructor<'tcx> {\n                 VariantIdx::new(0)\n             }\n             ConstantValue(c, _) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n-            _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n+            _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n \n@@ -488,22 +479,22 @@ impl<'tcx> Constructor<'tcx> {\n pub enum Usefulness<'tcx> {\n     Useful,\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n-    NotUseful\n+    NotUseful,\n }\n \n impl<'tcx> Usefulness<'tcx> {\n     fn is_useful(&self) -> bool {\n         match *self {\n             NotUseful => false,\n-            _ => true\n+            _ => true,\n         }\n     }\n }\n \n #[derive(Copy, Clone, Debug)]\n pub enum WitnessPreference {\n     ConstructWitness,\n-    LeaveOutWitness\n+    LeaveOutWitness,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -558,16 +549,13 @@ impl<'tcx> Witness<'tcx> {\n         mut self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>)\n-        -> Self\n-    {\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n         let sub_pattern_tys = constructor_sub_pattern_tys(cx, ctor, ty);\n-        self.0.extend(sub_pattern_tys.into_iter().map(|ty| {\n-            Pat {\n-                ty,\n-                span: DUMMY_SP,\n-                kind: box PatKind::Wild,\n-            }\n+        self.0.extend(sub_pattern_tys.into_iter().map(|ty| Pat {\n+            ty,\n+            span: DUMMY_SP,\n+            kind: box PatKind::Wild,\n         }));\n         self.apply_constructor(cx, ctor, ty)\n     }\n@@ -587,33 +575,29 @@ impl<'tcx> Witness<'tcx> {\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n     fn apply_constructor<'a>(\n         mut self,\n-        cx: &MatchCheckCtxt<'a,'tcx>,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>)\n-        -> Self\n-    {\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n         let arity = constructor_arity(cx, ctor, ty);\n         let pat = {\n             let len = self.0.len() as u64;\n             let mut pats = self.0.drain((len - arity) as usize..).rev();\n \n             match ty.kind {\n-                ty::Adt(..) |\n-                ty::Tuple(..) => {\n-                    let pats = pats.enumerate().map(|(i, p)| {\n-                        FieldPat {\n-                            field: Field::new(i),\n-                            pattern: p\n-                        }\n-                    }).collect();\n+                ty::Adt(..) | ty::Tuple(..) => {\n+                    let pats = pats\n+                        .enumerate()\n+                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .collect();\n \n                     if let ty::Adt(adt, substs) = ty.kind {\n                         if adt.is_enum() {\n                             PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n                                 variant_index: ctor.variant_index_for_adt(cx, adt),\n-                                subpatterns: pats\n+                                subpatterns: pats,\n                             }\n                         } else {\n                             PatKind::Leaf { subpatterns: pats }\n@@ -623,37 +607,25 @@ impl<'tcx> Witness<'tcx> {\n                     }\n                 }\n \n-                ty::Ref(..) => {\n-                    PatKind::Deref { subpattern: pats.nth(0).unwrap() }\n-                }\n+                ty::Ref(..) => PatKind::Deref { subpattern: pats.nth(0).unwrap() },\n \n                 ty::Slice(_) | ty::Array(..) => {\n-                    PatKind::Slice {\n-                        prefix: pats.collect(),\n-                        slice: None,\n-                        suffix: vec![]\n-                    }\n+                    PatKind::Slice { prefix: pats.collect(), slice: None, suffix: vec![] }\n                 }\n \n-                _ => {\n-                    match *ctor {\n-                        ConstantValue(value, _) => PatKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n-                            lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                            hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                            end,\n-                        }),\n-                        _ => PatKind::Wild,\n-                    }\n-                }\n+                _ => match *ctor {\n+                    ConstantValue(value, _) => PatKind::Constant { value },\n+                    ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n+                        lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                        hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                        end,\n+                    }),\n+                    _ => PatKind::Wild,\n+                },\n             }\n         };\n \n-        self.0.push(Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: Box::new(pat),\n-        });\n+        self.0.push(Pat { ty, span: DUMMY_SP, kind: Box::new(pat) });\n \n         self\n     }\n@@ -672,37 +644,33 @@ fn all_constructors<'a, 'tcx>(\n ) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     let ctors = match pcx.ty.kind {\n-        ty::Bool => {\n-            [true, false].iter().map(|&b| {\n-                ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span)\n-            }).collect()\n-        }\n+        ty::Bool => [true, false]\n+            .iter()\n+            .map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span))\n+            .collect(),\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n-            if len != 0 && cx.is_uninhabited(sub_ty) {\n-                vec![]\n-            } else {\n-                vec![Slice(len)]\n-            }\n+            if len != 0 && cx.is_uninhabited(sub_ty) { vec![] } else { vec![Slice(len)] }\n         }\n         // Treat arrays of a constant but unknown length like slices.\n-        ty::Array(ref sub_ty, _) |\n-        ty::Slice(ref sub_ty) => {\n+        ty::Array(ref sub_ty, _) | ty::Slice(ref sub_ty) => {\n             if cx.is_uninhabited(sub_ty) {\n                 vec![Slice(0)]\n             } else {\n-                (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n+                (0..pcx.max_slice_length + 1).map(|length| Slice(length)).collect()\n             }\n         }\n-        ty::Adt(def, substs) if def.is_enum() => {\n-            def.variants.iter()\n-                .filter(|v| {\n-                    !cx.tcx.features().exhaustive_patterns ||\n-                    !v.uninhabited_from(cx.tcx, substs, def.adt_kind()).contains(cx.tcx, cx.module)\n-                })\n-                .map(|v| Variant(v.def_id))\n-                .collect()\n-        }\n+        ty::Adt(def, substs) if def.is_enum() => def\n+            .variants\n+            .iter()\n+            .filter(|v| {\n+                !cx.tcx.features().exhaustive_patterns\n+                    || !v\n+                        .uninhabited_from(cx.tcx, substs, def.adt_kind())\n+                        .contains(cx.tcx, cx.module)\n+            })\n+            .map(|v| Variant(v.def_id))\n+            .collect(),\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n@@ -822,15 +790,13 @@ where\n             PatKind::Constant { value } => {\n                 // extract the length of an array/slice from a constant\n                 match (value.val, &value.ty.kind) {\n-                    (_, ty::Array(_, n)) => max_fixed_len = cmp::max(\n-                        max_fixed_len,\n-                        n.eval_usize(cx.tcx, cx.param_env),\n-                    ),\n-                    (ConstValue::Slice{ start, end, .. }, ty::Slice(_)) => max_fixed_len = cmp::max(\n-                        max_fixed_len,\n-                        (end - start) as u64,\n-                    ),\n-                    _ => {},\n+                    (_, ty::Array(_, n)) => {\n+                        max_fixed_len = cmp::max(max_fixed_len, n.eval_usize(cx.tcx, cx.param_env))\n+                    }\n+                    (ConstValue::Slice { start, end, .. }, ty::Slice(_)) => {\n+                        max_fixed_len = cmp::max(max_fixed_len, (end - start) as u64)\n+                    }\n+                    _ => {}\n                 }\n             }\n             PatKind::Slice { ref prefix, slice: None, ref suffix } => {\n@@ -907,7 +873,7 @@ impl<'tcx> IntRange<'tcx> {\n                 // This is a more general form of the previous branch.\n                 val\n             } else {\n-                return None\n+                return None;\n             };\n             let val = val ^ bias;\n             Some(IntRange { range: val..=val, ty, span })\n@@ -978,7 +944,7 @@ impl<'tcx> IntRange<'tcx> {\n                 }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n                     pat = subpattern;\n-                },\n+                }\n                 _ => return None,\n             }\n         }\n@@ -991,7 +957,7 @@ impl<'tcx> IntRange<'tcx> {\n                 let bits = Integer::from_attr(&tcx, SignedInt(ity)).size().bits() as u128;\n                 1u128 << (bits - 1)\n             }\n-            _ => 0\n+            _ => 0,\n         }\n     }\n \n@@ -1020,34 +986,43 @@ impl<'tcx> IntRange<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         ranges: Vec<Constructor<'tcx>>,\n     ) -> Vec<Constructor<'tcx>> {\n-        let ranges = ranges.into_iter().filter_map(|r| {\n-            IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range)\n-        });\n+        let ranges = ranges\n+            .into_iter()\n+            .filter_map(|r| IntRange::from_ctor(tcx, param_env, &r).map(|i| i.range));\n         let mut remaining_ranges = vec![];\n         let ty = self.ty;\n         let (lo, hi) = self.range.into_inner();\n         for subrange in ranges {\n             let (subrange_lo, subrange_hi) = subrange.into_inner();\n-            if lo > subrange_hi || subrange_lo > hi  {\n+            if lo > subrange_hi || subrange_lo > hi {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(\n-                    Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi, self.span),\n-                );\n+                remaining_ranges.push(Self::range_to_ctor(\n+                    tcx,\n+                    ty,\n+                    subrange_lo..=subrange_hi,\n+                    self.span,\n+                ));\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(\n-                        Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1), self.span),\n-                    );\n+                    remaining_ranges.push(Self::range_to_ctor(\n+                        tcx,\n+                        ty,\n+                        subrange_lo..=(lo - 1),\n+                        self.span,\n+                    ));\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(\n-                        Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi, self.span),\n-                    );\n+                    remaining_ranges.push(Self::range_to_ctor(\n+                        tcx,\n+                        ty,\n+                        (hi + 1)..=subrange_hi,\n+                        self.span,\n+                    ));\n                 }\n             }\n         }\n@@ -1205,12 +1180,13 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             }\n         } else {\n             NotUseful\n-        }\n+        };\n     };\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    let (ty, span) = rows.iter()\n+    let (ty, span) = rows\n+        .iter()\n         .map(|r| (r[0].ty, r[0].span))\n         .find(|(ty, _)| !ty.references_error())\n         .unwrap_or((v[0].ty, v[0].span));\n@@ -1244,16 +1220,25 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n         debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n         split_grouped_constructors(\n-            cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n-        ).into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n-        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+            cx.tcx,\n+            cx.param_env,\n+            constructors,\n+            matrix,\n+            pcx.ty,\n+            pcx.span,\n+            Some(hir_id),\n+        )\n+        .into_iter()\n+        .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n+        .find(|result| result.is_useful())\n+        .unwrap_or(NotUseful)\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n \n-        let used_ctors: Vec<Constructor<'_>> = rows.iter().flat_map(|row| {\n-            pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n-        }).collect();\n+        let used_ctors: Vec<Constructor<'_>> = rows\n+            .iter()\n+            .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n+            .collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n         // `all_ctors` are all the constructors for the given type, which\n         // should all be represented (or caught with the wild pattern `_`).\n@@ -1284,35 +1269,47 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // the set is empty, but we only fully construct them on-demand,\n         // because they're rarely used and can be big.\n         let cheap_missing_ctors = compute_missing_ctors(\n-            MissingCtorsInfo::Emptiness, cx.tcx, cx.param_env, &all_ctors, &used_ctors,\n+            MissingCtorsInfo::Emptiness,\n+            cx.tcx,\n+            cx.param_env,\n+            &all_ctors,\n+            &used_ctors,\n         );\n \n         let is_privately_empty = all_ctors.is_empty() && !cx.is_uninhabited(pcx.ty);\n         let is_declared_nonexhaustive = cx.is_non_exhaustive_enum(pcx.ty) && !cx.is_local(pcx.ty);\n-        debug!(\"cheap_missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n-               cheap_missing_ctors, is_privately_empty, is_declared_nonexhaustive);\n+        debug!(\n+            \"cheap_missing_ctors={:#?} is_privately_empty={:#?} is_declared_nonexhaustive={:#?}\",\n+            cheap_missing_ctors, is_privately_empty, is_declared_nonexhaustive\n+        );\n \n         // For privately empty and non-exhaustive enums, we work as if there were an \"extra\"\n         // `_` constructor for the type, so we can never match over all constructors.\n-        let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive ||\n-            (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n+        let is_non_exhaustive = is_privately_empty\n+            || is_declared_nonexhaustive\n+            || (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n             split_grouped_constructors(\n-                cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty, DUMMY_SP, None,\n+                cx.tcx,\n+                cx.param_env,\n+                all_ctors,\n+                matrix,\n+                pcx.ty,\n+                DUMMY_SP,\n+                None,\n             )\n-                .into_iter()\n-                .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n-                .find(|result| result.is_useful())\n-                .unwrap_or(NotUseful)\n+            .into_iter()\n+            .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n+            .find(|result| result.is_useful())\n+            .unwrap_or(NotUseful)\n         } else {\n-            let matrix = rows.iter().filter_map(|r| {\n-                if r[0].is_wildcard() {\n-                    Some(SmallVec::from_slice(&r[1..]))\n-                } else {\n-                    None\n-                }\n-            }).collect();\n+            let matrix = rows\n+                .iter()\n+                .filter_map(|r| {\n+                    if r[0].is_wildcard() { Some(SmallVec::from_slice(&r[1..])) } else { None }\n+                })\n+                .collect();\n             match is_useful(cx, &matrix, &v[1..], witness, hir_id) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n@@ -1363,35 +1360,43 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                     let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor.\n-                        pats.into_iter().map(|mut witness| {\n-                            witness.0.push(Pat {\n-                                ty: pcx.ty,\n-                                span: DUMMY_SP,\n-                                kind: box PatKind::Wild,\n-                            });\n-                            witness\n-                        }).collect()\n+                        pats.into_iter()\n+                            .map(|mut witness| {\n+                                witness.0.push(Pat {\n+                                    ty: pcx.ty,\n+                                    span: DUMMY_SP,\n+                                    kind: box PatKind::Wild,\n+                                });\n+                                witness\n+                            })\n+                            .collect()\n                     } else {\n                         let expensive_missing_ctors = compute_missing_ctors(\n-                            MissingCtorsInfo::Ctors, cx.tcx, cx.param_env, &all_ctors, &used_ctors,\n+                            MissingCtorsInfo::Ctors,\n+                            cx.tcx,\n+                            cx.param_env,\n+                            &all_ctors,\n+                            &used_ctors,\n                         );\n                         if let MissingCtors::Ctors(missing_ctors) = expensive_missing_ctors {\n-                            pats.into_iter().flat_map(|witness| {\n-                                missing_ctors.iter().map(move |ctor| {\n-                                    // Extends the witness with a \"wild\" version of this\n-                                    // constructor, that matches everything that can be built with\n-                                    // it. For example, if `ctor` is a `Constructor::Variant` for\n-                                    // `Option::Some`, this pushes the witness for `Some(_)`.\n-                                    witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                            pats.into_iter()\n+                                .flat_map(|witness| {\n+                                    missing_ctors.iter().map(move |ctor| {\n+                                        // Extends the witness with a \"wild\" version of this\n+                                        // constructor, that matches everything that can be built with\n+                                        // it. For example, if `ctor` is a `Constructor::Variant` for\n+                                        // `Option::Some`, this pushes the witness for `Some(_)`.\n+                                        witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                                    })\n                                 })\n-                            }).collect()\n+                                .collect()\n                         } else {\n                             bug!(\"cheap missing ctors\")\n                         }\n                     };\n                     UsefulWithWitness(new_witnesses)\n                 }\n-                result => result\n+                result => result,\n             }\n         }\n     }\n@@ -1410,29 +1415,22 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n-    let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n-        Pat {\n-            ty,\n-            span: DUMMY_SP,\n-            kind: box PatKind::Wild,\n-        }\n-    }).collect();\n+    let wild_patterns_owned: Vec<_> =\n+        sub_pat_tys.iter().map(|ty| Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild }).collect();\n     let wild_patterns: Vec<_> = wild_patterns_owned.iter().collect();\n-    let matrix = Matrix(\n-        m.iter()\n-            .filter_map(|r| specialize(cx, &r, &ctor, &wild_patterns))\n-            .collect()\n-    );\n+    let matrix =\n+        Matrix(m.iter().filter_map(|r| specialize(cx, &r, &ctor, &wild_patterns)).collect());\n     match specialize(cx, v, &ctor, &wild_patterns) {\n         Some(v) => match is_useful(cx, &matrix, &v, witness, hir_id) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n-                witnesses.into_iter()\n+                witnesses\n+                    .into_iter()\n                     .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n-                    .collect()\n+                    .collect(),\n             ),\n-            result => result\n-        }\n-        None => NotUseful\n+            result => result,\n+        },\n+        None => NotUseful,\n     }\n }\n \n@@ -1450,32 +1448,28 @@ fn pat_constructors<'tcx>(\n     pcx: PatCtxt<'tcx>,\n ) -> Option<Vec<Constructor<'tcx>>> {\n     match *pat.kind {\n-        PatKind::AscribeUserType { ref subpattern, .. } =>\n-            pat_constructors(cx, subpattern, pcx),\n+        PatKind::AscribeUserType { ref subpattern, .. } => pat_constructors(cx, subpattern, pcx),\n         PatKind::Binding { .. } | PatKind::Wild => None,\n         PatKind::Leaf { .. } | PatKind::Deref { .. } => Some(vec![Single]),\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n         PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n-        PatKind::Range(PatRange { lo, hi, end }) =>\n-            Some(vec![ConstantRange(\n-                lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-                hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n-                lo.ty,\n-                end,\n-                pat.span,\n-            )]),\n+        PatKind::Range(PatRange { lo, hi, end }) => Some(vec![ConstantRange(\n+            lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+            hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+            lo.ty,\n+            end,\n+            pat.span,\n+        )]),\n         PatKind::Array { .. } => match pcx.ty.kind {\n-            ty::Array(_, length) => Some(vec![\n-                Slice(length.eval_usize(cx.tcx, cx.param_env))\n-            ]),\n-            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty)\n+            ty::Array(_, length) => Some(vec![Slice(length.eval_usize(cx.tcx, cx.param_env))]),\n+            _ => span_bug!(pat.span, \"bad ty {:?} for array pattern\", pcx.ty),\n         },\n         PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n             let pat_len = prefix.len() as u64 + suffix.len() as u64;\n             if slice.is_some() {\n-                Some((pat_len..pcx.max_slice_length+1).map(Slice).collect())\n+                Some((pat_len..pcx.max_slice_length + 1).map(Slice).collect())\n             } else {\n                 Some(vec![Slice(pat_len)])\n             }\n@@ -1498,13 +1492,11 @@ fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty\n         ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n             ConstantValue(..) => 0,\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        }\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n+        },\n         ty::Ref(..) => 1,\n-        ty::Adt(adt, _) => {\n-            adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64\n-        }\n-        _ => 0\n+        ty::Adt(adt, _) => adt.variants[ctor.variant_index_for_adt(cx, adt)].fields.len() as u64,\n+        _ => 0,\n     }\n }\n \n@@ -1523,8 +1515,8 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n             ConstantValue(..) => vec![],\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        }\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty),\n+        },\n         ty::Ref(_, rty, _) => vec![rty],\n         ty::Adt(adt, substs) => {\n             if adt.is_box() {\n@@ -1533,30 +1525,36 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n             } else {\n                 let variant = &adt.variants[ctor.variant_index_for_adt(cx, adt)];\n                 let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                variant.fields.iter().map(|field| {\n-                    let is_visible = adt.is_enum()\n-                        || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                    let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                    match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                        // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n-                        (_, true, true) => cx.tcx.types.err,\n-                        // Treat all non-visible fields as `TyErr`. They can't appear in any\n-                        // other pattern from this match (because they are private), so their\n-                        // type does not matter - but we don't want to know they are uninhabited.\n-                        (false, ..) => cx.tcx.types.err,\n-                        (true, ..) => {\n-                            let ty = field.ty(cx.tcx, substs);\n-                            match ty.kind {\n-                                // If the field type returned is an array of an unknown\n-                                // size return an TyErr.\n-                                ty::Array(_, len)\n-                                    if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n-                                    cx.tcx.types.err,\n-                                _ => ty,\n+                variant\n+                    .fields\n+                    .iter()\n+                    .map(|field| {\n+                        let is_visible =\n+                            adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                        let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                        match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                            // Treat all uninhabited types in non-exhaustive variants as `TyErr`.\n+                            (_, true, true) => cx.tcx.types.err,\n+                            // Treat all non-visible fields as `TyErr`. They can't appear in any\n+                            // other pattern from this match (because they are private), so their\n+                            // type does not matter - but we don't want to know they are uninhabited.\n+                            (false, ..) => cx.tcx.types.err,\n+                            (true, ..) => {\n+                                let ty = field.ty(cx.tcx, substs);\n+                                match ty.kind {\n+                                    // If the field type returned is an array of an unknown\n+                                    // size return an TyErr.\n+                                    ty::Array(_, len)\n+                                        if len.try_eval_usize(cx.tcx, cx.param_env).is_none() =>\n+                                    {\n+                                        cx.tcx.types.err\n+                                    }\n+                                    _ => ty,\n+                                }\n                             }\n-                        },\n-                    }\n-                }).collect()\n+                        }\n+                    })\n+                    .collect()\n             }\n         }\n         _ => vec![],\n@@ -1581,17 +1579,20 @@ fn slice_pat_covered_by_const<'tcx>(\n             let n = n.eval_usize(tcx, param_env);\n             let ptr = Pointer::new(AllocId(0), offset);\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-        },\n+        }\n         (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let ptr = Pointer::new(AllocId(0), Size::from_bytes(start as u64));\n             data.get_bytes(&tcx, ptr, Size::from_bytes((end - start) as u64)).unwrap()\n-        },\n+        }\n         // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n         (_, ty::Slice(_)) => return Ok(false),\n         _ => bug!(\n             \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val, prefix, slice, suffix,\n+            const_val,\n+            prefix,\n+            slice,\n+            suffix,\n         ),\n     };\n \n@@ -1600,9 +1601,10 @@ fn slice_pat_covered_by_const<'tcx>(\n         return Ok(false);\n     }\n \n-    for (ch, pat) in\n-        data[..prefix.len()].iter().zip(prefix).chain(\n-            data[data.len()-suffix.len()..].iter().zip(suffix))\n+    for (ch, pat) in data[..prefix.len()]\n+        .iter()\n+        .zip(prefix)\n+        .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n     {\n         match pat.kind {\n             box PatKind::Constant { value } => {\n@@ -1715,7 +1717,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 let mut overlaps = vec![];\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n-                let row_borders = m.iter()\n+                let row_borders = m\n+                    .iter()\n                     .flat_map(|row| {\n                         IntRange::from_pat(tcx, param_env, row[0]).map(|r| (r, row.len()))\n                     })\n@@ -1745,8 +1748,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // We're going to iterate through every pair of borders, making sure that each\n                 // represents an interval of nonnegative length, and convert each such interval\n                 // into a constructor.\n-                for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n-                    match (window[0], window[1]) {\n+                for IntRange { range, .. } in\n+                    borders.windows(2).filter_map(|window| match (window[0], window[1]) {\n                         (Border::JustBefore(n), Border::JustBefore(m)) => {\n                             if n < m {\n                                 Some(IntRange { range: n..=(m - 1), ty, span })\n@@ -1758,8 +1761,8 @@ fn split_grouped_constructors<'p, 'tcx>(\n                             Some(IntRange { range: n..=u128::MAX, ty, span })\n                         }\n                         (Border::AfterMax, _) => None,\n-                    }\n-                }) {\n+                    })\n+                {\n                     split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n@@ -1788,10 +1791,13 @@ fn lint_overlapping_patterns(\n         err.span_label(ctor_range.span, \"overlapping patterns\");\n         for int_range in overlaps {\n             // Use the real type for user display of the ranges:\n-            err.span_label(int_range.span, &format!(\n-                \"this range overlaps on `{}`\",\n-                IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n-            ));\n+            err.span_label(\n+                int_range.span,\n+                &format!(\n+                    \"this range overlaps on `{}`\",\n+                    IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n+                ),\n+            );\n         }\n         err.emit();\n     }\n@@ -1809,8 +1815,9 @@ fn constructor_covered_by_range<'tcx>(\n         _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n     };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n-    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, param_env, ty)\n-        .map(|res| res != Ordering::Less);\n+    let cmp_from = |c_from| {\n+        compare_const_vals(tcx, c_from, from, param_env, ty).map(|res| res != Ordering::Less)\n+    };\n     let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, param_env, ty);\n     macro_rules! some_or_ok {\n         ($e:expr) => {\n@@ -1823,37 +1830,31 @@ fn constructor_covered_by_range<'tcx>(\n     match *ctor {\n         ConstantValue(value, _) => {\n             let to = some_or_ok!(cmp_to(value));\n-            let end = (to == Ordering::Less) ||\n-                      (end == RangeEnd::Included && to == Ordering::Equal);\n+            let end =\n+                (to == Ordering::Less) || (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n-        },\n+        }\n         ConstantRange(from, to, ty, RangeEnd::Included, _) => {\n-            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n-                tcx,\n-                to,\n-                ty::ParamEnv::empty().and(ty),\n-            )));\n-            let end = (to == Ordering::Less) ||\n-                      (end == RangeEnd::Included && to == Ordering::Equal);\n+            let to =\n+                some_or_ok!(cmp_to(ty::Const::from_bits(tcx, to, ty::ParamEnv::empty().and(ty),)));\n+            let end =\n+                (to == Ordering::Less) || (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n                 tcx,\n                 from,\n                 ty::ParamEnv::empty().and(ty),\n             ))) && end)\n-        },\n+        }\n         ConstantRange(from, to, ty, RangeEnd::Excluded, _) => {\n-            let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n-                tcx,\n-                to,\n-                ty::ParamEnv::empty().and(ty)\n-            )));\n-            let end = (to == Ordering::Less) ||\n-                      (end == RangeEnd::Excluded && to == Ordering::Equal);\n+            let to =\n+                some_or_ok!(cmp_to(ty::Const::from_bits(tcx, to, ty::ParamEnv::empty().and(ty))));\n+            let end =\n+                (to == Ordering::Less) || (end == RangeEnd::Excluded && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(ty::Const::from_bits(\n                 tcx,\n                 from,\n-                ty::ParamEnv::empty().and(ty)))\n-            ) && end)\n+                ty::ParamEnv::empty().and(ty)\n+            ))) && end)\n         }\n         Single => Ok(true),\n         _ => bug!(),\n@@ -1899,9 +1900,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns)\n         }\n \n-        PatKind::Binding { .. } | PatKind::Wild => {\n-            Some(SmallVec::from_slice(wild_patterns))\n-        }\n+        PatKind::Binding { .. } | PatKind::Wild => Some(SmallVec::from_slice(wild_patterns)),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n@@ -1915,49 +1914,36 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             Some(patterns_for_variant(cx, subpatterns, wild_patterns, false))\n         }\n \n-        PatKind::Deref { ref subpattern } => {\n-            Some(smallvec![subpattern])\n-        }\n+        PatKind::Deref { ref subpattern } => Some(smallvec![subpattern]),\n \n         PatKind::Constant { value } if constructor.is_slice() => {\n             // We extract an `Option` for the pointer because slices of zero\n             // elements don't necessarily point to memory, they are usually\n             // just integers. The only time they should be pointing to memory\n             // is when they are subslices of nonzero slices.\n             let (alloc, offset, n, ty) = match value.ty.kind {\n-                ty::Array(t, n) => {\n-                    match value.val {\n-                        ConstValue::ByRef { offset, alloc, .. } => (\n-                            alloc,\n-                            offset,\n-                            n.eval_usize(cx.tcx, cx.param_env),\n-                            t,\n-                        ),\n-                        _ => span_bug!(\n-                            pat.span,\n-                            \"array pattern is {:?}\", value,\n-                        ),\n+                ty::Array(t, n) => match value.val {\n+                    ConstValue::ByRef { offset, alloc, .. } => {\n+                        (alloc, offset, n.eval_usize(cx.tcx, cx.param_env), t)\n                     }\n+                    _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n                 },\n                 ty::Slice(t) => {\n                     match value.val {\n-                        ConstValue::Slice { data, start, end } => (\n-                            data,\n-                            Size::from_bytes(start as u64),\n-                            (end - start) as u64,\n-                            t,\n-                        ),\n+                        ConstValue::Slice { data, start, end } => {\n+                            (data, Size::from_bytes(start as u64), (end - start) as u64, t)\n+                        }\n                         ConstValue::ByRef { .. } => {\n                             // FIXME(oli-obk): implement `deref` for `ConstValue`\n                             return None;\n-                        },\n+                        }\n                         _ => span_bug!(\n                             pat.span,\n                             \"slice pattern constant must be scalar pair but is {:?}\",\n                             value,\n                         ),\n                     }\n-                },\n+                }\n                 _ => span_bug!(\n                     pat.span,\n                     \"unexpected const-val {:?} with ctor {:?}\",\n@@ -1969,41 +1955,37 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                 // convert a constant slice/array pattern to a list of patterns.\n                 let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n                 let ptr = Pointer::new(AllocId(0), offset);\n-                (0..n).map(|i| {\n-                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                    let scalar = alloc.read_scalar(\n-                        &cx.tcx, ptr, layout.size,\n-                    ).ok()?;\n-                    let scalar = scalar.not_undef().ok()?;\n-                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                    let pattern = Pat {\n-                        ty,\n-                        span: pat.span,\n-                        kind: box PatKind::Constant { value },\n-                    };\n-                    Some(&*cx.pattern_arena.alloc(pattern))\n-                }).collect()\n+                (0..n)\n+                    .map(|i| {\n+                        let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                        let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n+                        let scalar = scalar.not_undef().ok()?;\n+                        let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                        let pattern =\n+                            Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n+                        Some(&*cx.pattern_arena.alloc(pattern))\n+                    })\n+                    .collect()\n             } else {\n                 None\n             }\n         }\n \n-        PatKind::Constant { .. } |\n-        PatKind::Range { .. } => {\n+        PatKind::Constant { .. } | PatKind::Range { .. } => {\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n             if should_treat_range_exhaustively(cx.tcx, constructor) {\n-                match (IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n-                       IntRange::from_pat(cx.tcx, cx.param_env, pat)) {\n-                    (Some(ctor), Some(pat)) => {\n-                        ctor.intersection(&pat).map(|_| {\n-                            let (pat_lo, pat_hi) = pat.range.into_inner();\n-                            let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n-                            assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n-                            smallvec![]\n-                        })\n-                    }\n+                match (\n+                    IntRange::from_ctor(cx.tcx, cx.param_env, constructor),\n+                    IntRange::from_pat(cx.tcx, cx.param_env, pat),\n+                ) {\n+                    (Some(ctor), Some(pat)) => ctor.intersection(&pat).map(|_| {\n+                        let (pat_lo, pat_hi) = pat.range.into_inner();\n+                        let (ctor_lo, ctor_hi) = ctor.range.into_inner();\n+                        assert!(pat_lo <= ctor_lo && ctor_hi <= pat_hi);\n+                        smallvec![]\n+                    }),\n                     _ => None,\n                 }\n             } else {\n@@ -2019,39 +2001,49 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n             }\n         }\n \n-        PatKind::Array { ref prefix, ref slice, ref suffix } |\n-        PatKind::Slice { ref prefix, ref slice, ref suffix } => {\n-            match *constructor {\n-                Slice(..) => {\n-                    let pat_len = prefix.len() + suffix.len();\n-                    if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n-                        if slice_count == 0 || slice.is_some() {\n-                            Some(prefix.iter().chain(\n-                                    wild_patterns.iter().map(|p| *p)\n-                                                 .skip(prefix.len())\n-                                                 .take(slice_count)\n-                                                 .chain(suffix.iter())\n-                            ).collect())\n-                        } else {\n-                            None\n-                        }\n+        PatKind::Array { ref prefix, ref slice, ref suffix }\n+        | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n+            Slice(..) => {\n+                let pat_len = prefix.len() + suffix.len();\n+                if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n+                    if slice_count == 0 || slice.is_some() {\n+                        Some(\n+                            prefix\n+                                .iter()\n+                                .chain(\n+                                    wild_patterns\n+                                        .iter()\n+                                        .map(|p| *p)\n+                                        .skip(prefix.len())\n+                                        .take(slice_count)\n+                                        .chain(suffix.iter()),\n+                                )\n+                                .collect(),\n+                        )\n                     } else {\n                         None\n                     }\n+                } else {\n+                    None\n                 }\n-                ConstantValue(cv, _) => {\n-                    match slice_pat_covered_by_const(\n-                        cx.tcx, pat.span, cv, prefix, slice, suffix, cx.param_env,\n-                    ) {\n-                        Ok(true) => Some(smallvec![]),\n-                        Ok(false) => None,\n-                        Err(ErrorReported) => None\n-                    }\n+            }\n+            ConstantValue(cv, _) => {\n+                match slice_pat_covered_by_const(\n+                    cx.tcx,\n+                    pat.span,\n+                    cv,\n+                    prefix,\n+                    slice,\n+                    suffix,\n+                    cx.param_env,\n+                ) {\n+                    Ok(true) => Some(smallvec![]),\n+                    Ok(false) => None,\n+                    Err(ErrorReported) => None,\n                 }\n-                _ => span_bug!(pat.span,\n-                    \"unexpected ctor {:?} for slice pat\", constructor)\n             }\n-        }\n+            _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n+        },\n \n         PatKind::Or { .. } => {\n             bug!(\"support for or-patterns has not been fully implemented yet.\");\n@@ -2060,7 +2052,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n     debug!(\"specialize({:#?}, {:#?}) = {:#?}\", r[0], wild_patterns, head);\n \n     head.map(|mut head| {\n-        head.extend_from_slice(&r[1 ..]);\n+        head.extend_from_slice(&r[1..]);\n         head\n     })\n }"}, {"sha": "ecfe43c657475745b28e3211e475c1c9f202437f", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 133, "deletions": 104, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/a5de5a604ed2175f91077ef40ad62f5da65c01f2/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de5a604ed2175f91077ef40ad62f5da65c01f2/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a5de5a604ed2175f91077ef40ad62f5da65c01f2", "patch": "@@ -1,25 +1,25 @@\n-use super::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n use super::_match::Usefulness::*;\n use super::_match::WitnessPreference::*;\n+use super::_match::{expand_pattern, is_useful, MatchCheckCtxt, Matrix};\n \n-use super::{PatCtxt, PatternError, PatKind};\n+use super::{PatCtxt, PatKind, PatternError};\n \n+use rustc::lint;\n use rustc::session::Session;\n-use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::lint;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n \n-use rustc::hir::HirId;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc::hir::HirId;\n use rustc::hir::{self, Pat};\n \n use smallvec::smallvec;\n use std::slice;\n \n-use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match tcx.hir().as_local_hir_id(def_id) {\n@@ -100,13 +100,15 @@ impl PatCtxt<'_, '_> {\n                     ::rustc::mir::interpret::struct_error(\n                         self.tcx.at(pat_span),\n                         \"could not evaluate float literal (see issue #31407)\",\n-                    ).emit();\n+                    )\n+                    .emit();\n                 }\n                 PatternError::NonConstPath(span) => {\n                     ::rustc::mir::interpret::struct_error(\n                         self.tcx.at(span),\n                         \"runtime values cannot be referenced in patterns\",\n-                    ).emit();\n+                    )\n+                    .emit();\n                 }\n             }\n         }\n@@ -123,12 +125,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         check_legality_of_bindings_in_at_patterns(self, pat);\n     }\n \n-    fn check_match(\n-        &mut self,\n-        scrut: &hir::Expr,\n-        arms: &'tcx [hir::Arm],\n-        source: hir::MatchSource\n-    ) {\n+    fn check_match(&mut self, scrut: &hir::Expr, arms: &'tcx [hir::Arm], source: hir::MatchSource) {\n         for arm in arms {\n             // First, check legality of move bindings.\n             self.check_patterns(arm.guard.is_some(), &arm.pat);\n@@ -141,31 +138,41 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n-            let inlined_arms : Vec<(Vec<_>, _)> = arms.iter().map(|arm| (\n-                // HACK(or_patterns; Centril | dlrobertson): Remove this and\n-                // correctly handle exhaustiveness checking for nested or-patterns.\n-                match &arm.pat.kind {\n-                    hir::PatKind::Or(pats) => pats,\n-                    _ => std::slice::from_ref(&arm.pat),\n-                }.iter().map(|pat| {\n-                    let mut patcx = PatCtxt::new(\n-                        self.tcx,\n-                        self.param_env.and(self.identity_substs),\n-                        self.tables\n-                    );\n-                    patcx.include_lint_checks();\n-                    let pattern =\n-                        cx.pattern_arena.alloc(expand_pattern(cx, patcx.lower_pattern(&pat))) as &_;\n-                    if !patcx.errors.is_empty() {\n-                        patcx.report_inlining_errors(pat.span);\n-                        have_errors = true;\n-                    }\n-                    (pattern, &**pat)\n-                }).collect(),\n-                arm.guard.as_ref().map(|g| match g {\n-                    hir::Guard::If(ref e) => &**e,\n+            let inlined_arms: Vec<(Vec<_>, _)> = arms\n+                .iter()\n+                .map(|arm| {\n+                    (\n+                        // HACK(or_patterns; Centril | dlrobertson): Remove this and\n+                        // correctly handle exhaustiveness checking for nested or-patterns.\n+                        match &arm.pat.kind {\n+                            hir::PatKind::Or(pats) => pats,\n+                            _ => std::slice::from_ref(&arm.pat),\n+                        }\n+                        .iter()\n+                        .map(|pat| {\n+                            let mut patcx = PatCtxt::new(\n+                                self.tcx,\n+                                self.param_env.and(self.identity_substs),\n+                                self.tables,\n+                            );\n+                            patcx.include_lint_checks();\n+                            let pattern = cx\n+                                .pattern_arena\n+                                .alloc(expand_pattern(cx, patcx.lower_pattern(&pat)))\n+                                as &_;\n+                            if !patcx.errors.is_empty() {\n+                                patcx.report_inlining_errors(pat.span);\n+                                have_errors = true;\n+                            }\n+                            (pattern, &**pat)\n+                        })\n+                        .collect(),\n+                        arm.guard.as_ref().map(|g| match g {\n+                            hir::Guard::If(ref e) => &**e,\n+                        }),\n+                    )\n                 })\n-            )).collect();\n+                .collect();\n \n             // Bail out early if inlining failed.\n             if have_errors {\n@@ -191,36 +198,42 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                             def_span = self.tcx.hir().span_if_local(def.did);\n                             if def.variants.len() < 4 && !def.variants.is_empty() {\n                                 // keep around to point at the definition of non-covered variants\n-                                missing_variants = def.variants.iter()\n-                                    .map(|variant| variant.ident)\n-                                    .collect();\n+                                missing_variants =\n+                                    def.variants.iter().map(|variant| variant.ident).collect();\n                             }\n \n                             let is_non_exhaustive_and_non_local =\n                                 def.is_variant_list_non_exhaustive() && !def.did.is_local();\n \n                             !(is_non_exhaustive_and_non_local) && def.variants.is_empty()\n-                        },\n-                        _ => false\n+                        }\n+                        _ => false,\n                     }\n                 };\n                 if !scrutinee_is_uninhabited {\n                     // We know the type is inhabited, so this must be wrong\n                     let mut err = create_e0004(\n                         self.tcx.sess,\n                         scrut.span,\n-                        format!(\"non-exhaustive patterns: {}\", match missing_variants.len() {\n-                            0 => format!(\"type `{}` is non-empty\", pat_ty),\n-                            1 => format!(\n-                                \"pattern `{}` of type `{}` is not handled\",\n-                                missing_variants[0].name,\n-                                pat_ty,\n-                            ),\n-                            _ => format!(\"multiple patterns of type `{}` are not handled\", pat_ty),\n-                        }),\n+                        format!(\n+                            \"non-exhaustive patterns: {}\",\n+                            match missing_variants.len() {\n+                                0 => format!(\"type `{}` is non-empty\", pat_ty),\n+                                1 => format!(\n+                                    \"pattern `{}` of type `{}` is not handled\",\n+                                    missing_variants[0].name, pat_ty,\n+                                ),\n+                                _ => format!(\n+                                    \"multiple patterns of type `{}` are not handled\",\n+                                    pat_ty\n+                                ),\n+                            }\n+                        ),\n+                    );\n+                    err.help(\n+                        \"ensure that all possible cases are being handled, \\\n+                         possibly by adding wildcards or more match arms\",\n                     );\n-                    err.help(\"ensure that all possible cases are being handled, \\\n-                              possibly by adding wildcards or more match arms\");\n                     if let Some(sp) = def_span {\n                         err.span_label(sp, format!(\"`{}` defined here\", pat_ty));\n                     }\n@@ -248,16 +261,13 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str, sp: Option<Span>) {\n         let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n-            let mut patcx = PatCtxt::new(self.tcx,\n-                                                self.param_env.and(self.identity_substs),\n-                                                self.tables);\n+            let mut patcx =\n+                PatCtxt::new(self.tcx, self.param_env.and(self.identity_substs), self.tables);\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n             let pattern = expand_pattern(cx, pattern);\n-            let pats: Matrix<'_, '_> = vec![smallvec![\n-                &pattern\n-            ]].into_iter().collect();\n+            let pats: Matrix<'_, '_> = vec![smallvec![&pattern]].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n@@ -266,9 +276,12 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n             let joined_patterns = joined_uncovered_patterns(&witnesses);\n             let mut err = struct_span_err!(\n-                self.tcx.sess, pat.span, E0005,\n+                self.tcx.sess,\n+                pat.span,\n+                E0005,\n                 \"refutable pattern in {}: {} not covered\",\n-                origin, joined_patterns\n+                origin,\n+                joined_patterns\n             );\n             let suggest_if_let = match &pat.kind {\n                 hir::PatKind::Path(hir::QPath::Resolved(None, path))\n@@ -287,8 +300,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             };\n \n             if let (Some(span), true) = (sp, suggest_if_let) {\n-                err.note(\"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n-                          an `enum` with only one variant\");\n+                err.note(\n+                    \"`let` bindings require an \\\"irrefutable pattern\\\", like a `struct` or \\\n+                     an `enum` with only one variant\",\n+                );\n                 if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                     err.span_suggestion(\n                         span,\n@@ -297,8 +312,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                         Applicability::HasPlaceholders,\n                     );\n                 }\n-                err.note(\"for more information, visit \\\n-                          https://doc.rust-lang.org/book/ch18-02-refutability.html\");\n+                err.note(\n+                    \"for more information, visit \\\n+                     https://doc.rust-lang.org/book/ch18-02-refutability.html\",\n+                );\n             }\n \n             adt_defined_here(cx, &mut err, pattern_ty, &witnesses);\n@@ -311,11 +328,10 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n /// This caused an irrefutable match failure in e.g. `let`.\n fn const_not_var(err: &mut DiagnosticBuilder<'_>, tcx: TyCtxt<'_>, pat: &Pat, path: &hir::Path) {\n     let descr = path.res.descr();\n-    err.span_label(pat.span, format!(\n-        \"interpreted as {} {} pattern, not a new variable\",\n-        path.res.article(),\n-        descr,\n-    ));\n+    err.span_label(\n+        pat.span,\n+        format!(\"interpreted as {} {} pattern, not a new variable\", path.res.article(), descr,),\n+    );\n \n     err.span_suggestion(\n         pat.span,\n@@ -342,19 +358,26 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                 }\n                 let pat_ty = cx.tables.pat_ty(p);\n                 if let ty::Adt(edef, _) = pat_ty.kind {\n-                    if edef.is_enum() && edef.variants.iter().any(|variant| {\n-                        variant.ident == ident && variant.ctor_kind == CtorKind::Const\n-                    }) {\n+                    if edef.is_enum()\n+                        && edef.variants.iter().any(|variant| {\n+                            variant.ident == ident && variant.ctor_kind == CtorKind::Const\n+                        })\n+                    {\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n-                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                        let mut err = struct_span_warn!(\n+                            cx.tcx.sess,\n+                            p.span,\n+                            E0170,\n                             \"pattern binding `{}` is named the same as one \\\n-                            of the variants of the type `{}`\",\n-                            ident, ty_path);\n+                             of the variants of the type `{}`\",\n+                            ident,\n+                            ty_path\n+                        );\n                         err.span_suggestion(\n                             p.span,\n                             \"to match on the variant, qualify the path\",\n                             format!(\"{}::{}\", ty_path, ident),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         );\n                         err.emit();\n                     }\n@@ -373,10 +396,8 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n         hir::PatKind::Binding(.., None) => true,\n         hir::PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n         hir::PatKind::Ref(ref s, _) => pat_is_catchall(s),\n-        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n-            pat_is_catchall(&p)\n-        }),\n-        _ => false\n+        hir::PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(&p)),\n+        _ => false,\n     }\n }\n \n@@ -395,8 +416,9 @@ fn check_arms<'tcx>(\n             match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n                 NotUseful => {\n                     match source {\n-                        hir::MatchSource::IfDesugar { .. } |\n-                        hir::MatchSource::WhileDesugar => bug!(),\n+                        hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => {\n+                            bug!()\n+                        }\n                         hir::MatchSource::IfLetDesugar { .. } => {\n                             cx.tcx.lint_hir(\n                                 lint::builtin::IRREFUTABLE_LET_PATTERNS,\n@@ -413,9 +435,11 @@ fn check_arms<'tcx>(\n                                 0 => {\n                                     cx.tcx.lint_hir(\n                                         lint::builtin::UNREACHABLE_PATTERNS,\n-                                        hir_pat.hir_id, pat.span,\n-                                        \"unreachable pattern\");\n-                                },\n+                                        hir_pat.hir_id,\n+                                        pat.span,\n+                                        \"unreachable pattern\",\n+                                    );\n+                                }\n                                 // The arm with the wildcard pattern.\n                                 1 => {\n                                     cx.tcx.lint_hir(\n@@ -424,13 +448,12 @@ fn check_arms<'tcx>(\n                                         pat.span,\n                                         \"irrefutable while-let pattern\",\n                                     );\n-                                },\n+                                }\n                                 _ => bug!(),\n                             }\n                         }\n \n-                        hir::MatchSource::ForLoopDesugar |\n-                        hir::MatchSource::Normal => {\n+                        hir::MatchSource::ForLoopDesugar | hir::MatchSource::Normal => {\n                             let mut err = cx.tcx.struct_span_lint_hir(\n                                 lint::builtin::UNREACHABLE_PATTERNS,\n                                 hir_pat.hir_id,\n@@ -447,12 +470,11 @@ fn check_arms<'tcx>(\n \n                         // Unreachable patterns in try and await expressions occur when one of\n                         // the arms are an uninhabited type. Which is OK.\n-                        hir::MatchSource::AwaitDesugar |\n-                        hir::MatchSource::TryDesugar => {}\n+                        hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                     }\n                 }\n                 Useful => (),\n-                UsefulWithWitness(_) => bug!()\n+                UsefulWithWitness(_) => bug!(),\n             }\n             if guard.is_none() {\n                 seen.push(v);\n@@ -496,14 +518,15 @@ fn check_exhaustive<'tcx>(\n \n     let joined_patterns = joined_uncovered_patterns(&witnesses);\n     let mut err = create_e0004(\n-        cx.tcx.sess, sp,\n+        cx.tcx.sess,\n+        sp,\n         format!(\"non-exhaustive patterns: {} not covered\", joined_patterns),\n     );\n     err.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n     adt_defined_here(cx, &mut err, scrut_ty, &witnesses);\n     err.help(\n         \"ensure that all possible cases are being handled, \\\n-        possibly by adding wildcards or more match arms\"\n+         possibly by adding wildcards or more match arms\",\n     )\n     .emit();\n }\n@@ -556,7 +579,7 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter.\n         for pattern in patterns {\n-            use PatKind::{AscribeUserType, Deref, Variant, Or, Leaf};\n+            use PatKind::{AscribeUserType, Deref, Leaf, Or, Variant};\n             match &*pattern.kind {\n                 AscribeUserType { subpattern, .. } | Deref { subpattern } => {\n                     covered.extend(maybe_point_at_variant(ty, slice::from_ref(&subpattern)));\n@@ -568,13 +591,15 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n                     }\n                     covered.push(sp);\n \n-                    let pats = subpatterns.iter()\n+                    let pats = subpatterns\n+                        .iter()\n                         .map(|field_pattern| field_pattern.pattern.clone())\n                         .collect::<Box<[_]>>();\n                     covered.extend(maybe_point_at_variant(ty, &pats));\n                 }\n                 Leaf { subpatterns } => {\n-                    let pats = subpatterns.iter()\n+                    let pats = subpatterns\n+                        .iter()\n                         .map(|field_pattern| field_pattern.pattern.clone())\n                         .collect::<Box<[_]>>();\n                     covered.extend(maybe_point_at_variant(ty, &pats));\n@@ -659,7 +684,7 @@ fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pa\n \n struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     cx: &'a MatchVisitor<'b, 'tcx>,\n-    bindings_allowed: bool\n+    bindings_allowed: bool,\n }\n \n impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n@@ -671,10 +696,14 @@ impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n         match pat.kind {\n             hir::PatKind::Binding(.., ref subpat) => {\n                 if !self.bindings_allowed {\n-                    struct_span_err!(self.cx.tcx.sess, pat.span, E0303,\n-                                     \"pattern bindings are not allowed after an `@`\")\n-                        .span_label(pat.span,  \"not allowed after `@`\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.cx.tcx.sess,\n+                        pat.span,\n+                        E0303,\n+                        \"pattern bindings are not allowed after an `@`\"\n+                    )\n+                    .span_label(pat.span, \"not allowed after `@`\")\n+                    .emit();\n                 }\n \n                 if subpat.is_some() {"}]}