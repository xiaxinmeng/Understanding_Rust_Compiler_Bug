{"sha": "c31b7044c1a1fceb9b22813b9e7219967cf478f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMWI3MDQ0YzFhMWZjZWI5YjIyODEzYjllNzIxOTk2N2NmNDc4ZjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-08T15:53:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-08T15:53:36Z"}, "message": "Rollup merge of #69646 - RalfJung:layout-visitor, r=eddyb\n\nMiri visitor: detect primitive types based on type, not layout (also, more tests)\n\nI also converted the union-based transmutes to use `mem::transmute` for increased readability.\n\nr? @eddyb @oli-obk", "tree": {"sha": "6579808b52ad945e660d4049c5dd34d11e0975db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6579808b52ad945e660d4049c5dd34d11e0975db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c31b7044c1a1fceb9b22813b9e7219967cf478f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZRUBCRBK7hj4Ov3rIwAAdHIIAFrKyWdhijUb3oVVU/mWOdT+\nIWgaMgBPzkLc9GM9rt/NYd2JeFlUV5PYIiY+eyj24LhI3fvKHePDdcajwEHoUyXp\nTj6se+DA+b2wkx2QnHAomZv8ezhV722dQoeUG+DMIJPsOsRcjngT8GtbFPzVqYGH\nwdO4bSQiRoNCTdcANYei/OXSze1R2LWawhu3TFEm1Suxb5hwj4FCcMXfnbfgWSBH\nXQhODmEsCsAYb9Krv+PkjpjHNLHhEJW0jIj+7JtrOFlb1cdb4M8CbqVnyC5axtYs\nk35qWTp9gXlw4JC/UsM+zeBa4wvZVx6H2hSRuCymZo4u3JUxsK4yll2eZ8/wnp4=\n=8sXO\n-----END PGP SIGNATURE-----\n", "payload": "tree 6579808b52ad945e660d4049c5dd34d11e0975db\nparent b3c405cf46f47ff175be2670e15569f4693df1bf\nparent a95f00fe1b064f548b6513fbf88afc223f6c4f9c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583682816 +0100\ncommitter GitHub <noreply@github.com> 1583682816 +0100\n\nRollup merge of #69646 - RalfJung:layout-visitor, r=eddyb\n\nMiri visitor: detect primitive types based on type, not layout (also, more tests)\n\nI also converted the union-based transmutes to use `mem::transmute` for increased readability.\n\nr? @eddyb @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c31b7044c1a1fceb9b22813b9e7219967cf478f3", "html_url": "https://github.com/rust-lang/rust/commit/c31b7044c1a1fceb9b22813b9e7219967cf478f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c31b7044c1a1fceb9b22813b9e7219967cf478f3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3c405cf46f47ff175be2670e15569f4693df1bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c405cf46f47ff175be2670e15569f4693df1bf", "html_url": "https://github.com/rust-lang/rust/commit/b3c405cf46f47ff175be2670e15569f4693df1bf"}, {"sha": "a95f00fe1b064f548b6513fbf88afc223f6c4f9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a95f00fe1b064f548b6513fbf88afc223f6c4f9c", "html_url": "https://github.com/rust-lang/rust/commit/a95f00fe1b064f548b6513fbf88afc223f6c4f9c"}], "stats": {"total": 828, "additions": 472, "deletions": 356}, "files": [{"sha": "84717cbeaa9c4ec0181b17ce482f9c376c4756a8", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 166, "deletions": 127, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -306,23 +306,127 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    fn visit_primitive(&mut self, value: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n+    /// Check a reference or `Box`.\n+    fn check_safe_pointer(\n+        &mut self,\n+        value: OpTy<'tcx, M::PointerTag>,\n+        kind: &str,\n+    ) -> InterpResult<'tcx> {\n         let value = self.ecx.read_immediate(value)?;\n+        // Handle wide pointers.\n+        // Check metadata early, for better diagnostics\n+        let place = try_validation!(self.ecx.ref_to_mplace(value), \"undefined pointer\", self.path);\n+        if place.layout.is_unsized() {\n+            self.check_wide_ptr_meta(place.meta, place.layout)?;\n+        }\n+        // Make sure this is dereferenceable and all.\n+        let (size, align) = self\n+            .ecx\n+            .size_and_align_of(place.meta, place.layout)?\n+            // for the purpose of validity, consider foreign types to have\n+            // alignment and size determined by the layout (size will be 0,\n+            // alignment should take attributes into account).\n+            .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n+        let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n+            place.ptr,\n+            size,\n+            Some(align),\n+            CheckInAllocMsg::InboundsTest,\n+        ) {\n+            Ok(ptr) => ptr,\n+            Err(err) => {\n+                info!(\n+                    \"{:?} did not pass access check for size {:?}, align {:?}\",\n+                    place.ptr, size, align\n+                );\n+                match err.kind {\n+                    err_unsup!(InvalidNullPointerUsage) => {\n+                        throw_validation_failure!(format_args!(\"a NULL {}\", kind), self.path)\n+                    }\n+                    err_unsup!(AlignmentCheckFailed { required, has }) => {\n+                        throw_validation_failure!(\n+                            format_args!(\n+                                \"an unaligned {} \\\n+                                    (required {} byte alignment but found {})\",\n+                                kind,\n+                                required.bytes(),\n+                                has.bytes()\n+                            ),\n+                            self.path\n+                        )\n+                    }\n+                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n+                        format_args!(\"a dangling {} (created from integer)\", kind),\n+                        self.path\n+                    ),\n+                    _ => throw_validation_failure!(\n+                        format_args!(\"a dangling {} (not entirely in bounds)\", kind),\n+                        self.path\n+                    ),\n+                }\n+            }\n+        };\n+        // Recursive checking\n+        if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n+            if let Some(ptr) = ptr {\n+                // not a ZST\n+                // Skip validation entirely for some external statics\n+                let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n+                    // `extern static` cannot be validated as they have no body.\n+                    // FIXME: Statics from other crates are also skipped.\n+                    // They might be checked at a different type, but for now we\n+                    // want to avoid recursing too deeply.  This is not sound!\n+                    if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n+                        return Ok(());\n+                    }\n+                }\n+            }\n+            // Proceed recursively even for ZST, no reason to skip them!\n+            // `!` is a ZST and we want to validate it.\n+            // Normalize before handing `place` to tracking because that will\n+            // check for duplicates.\n+            let place = if size.bytes() > 0 {\n+                self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n+            } else {\n+                place\n+            };\n+            let path = &self.path;\n+            ref_tracking.track(place, || {\n+                // We need to clone the path anyway, make sure it gets created\n+                // with enough space for the additional `Deref`.\n+                let mut new_path = Vec::with_capacity(path.len() + 1);\n+                new_path.clone_from(path);\n+                new_path.push(PathElem::Deref);\n+                new_path\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    /// Check if this is a value of primitive type, and if yes check the validity of the value\n+    /// at that type.  Return `true` if the type is indeed primitive.\n+    fn try_visit_primitive(\n+        &mut self,\n+        value: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, bool> {\n         // Go over all the primitive types\n         let ty = value.layout.ty;\n         match ty.kind {\n             ty::Bool => {\n-                let value = value.to_scalar_or_undef();\n+                let value = self.ecx.read_scalar(value)?;\n                 try_validation!(value.to_bool(), value, self.path, \"a boolean\");\n+                Ok(true)\n             }\n             ty::Char => {\n-                let value = value.to_scalar_or_undef();\n+                let value = self.ecx.read_scalar(value)?;\n                 try_validation!(value.to_char(), value, self.path, \"a valid unicode codepoint\");\n+                Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n+                let value = self.ecx.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                let value = value.to_scalar_or_undef();\n                 if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n@@ -337,120 +441,68 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     // At run-time, for now, we accept *anything* for these types, including\n                     // undef. We should fix that, but let's start low.\n                 }\n+                Ok(true)\n             }\n             ty::RawPtr(..) => {\n                 // We are conservative with undef for integers, but try to\n                 // actually enforce our current rules for raw pointers.\n-                let place =\n-                    try_validation!(self.ecx.ref_to_mplace(value), \"undefined pointer\", self.path);\n+                let place = try_validation!(\n+                    self.ecx.ref_to_mplace(self.ecx.read_immediate(value)?),\n+                    \"undefined pointer\",\n+                    self.path\n+                );\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n+                Ok(true)\n             }\n-            _ if ty.is_box() || ty.is_region_ptr() => {\n-                // Handle wide pointers.\n-                // Check metadata early, for better diagnostics\n-                let place =\n-                    try_validation!(self.ecx.ref_to_mplace(value), \"undefined pointer\", self.path);\n-                if place.layout.is_unsized() {\n-                    self.check_wide_ptr_meta(place.meta, place.layout)?;\n-                }\n-                // Make sure this is dereferenceable and all.\n-                let (size, align) = self\n-                    .ecx\n-                    .size_and_align_of(place.meta, place.layout)?\n-                    // for the purpose of validity, consider foreign types to have\n-                    // alignment and size determined by the layout (size will be 0,\n-                    // alignment should take attributes into account).\n-                    .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n-                let ptr: Option<_> = match self.ecx.memory.check_ptr_access_align(\n-                    place.ptr,\n-                    size,\n-                    Some(align),\n-                    CheckInAllocMsg::InboundsTest,\n-                ) {\n-                    Ok(ptr) => ptr,\n-                    Err(err) => {\n-                        info!(\n-                            \"{:?} did not pass access check for size {:?}, align {:?}\",\n-                            place.ptr, size, align\n-                        );\n-                        match err.kind {\n-                            err_unsup!(InvalidNullPointerUsage) => {\n-                                throw_validation_failure!(\"a NULL reference\", self.path)\n-                            }\n-                            err_unsup!(AlignmentCheckFailed { required, has }) => {\n-                                throw_validation_failure!(\n-                                    format_args!(\n-                                        \"an unaligned reference \\\n-                                         (required {} byte alignment but found {})\",\n-                                        required.bytes(),\n-                                        has.bytes()\n-                                    ),\n-                                    self.path\n-                                )\n-                            }\n-                            err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n-                                \"a dangling reference (created from integer)\",\n-                                self.path\n-                            ),\n-                            _ => throw_validation_failure!(\n-                                \"a dangling reference (not entirely in bounds)\",\n-                                self.path\n-                            ),\n-                        }\n-                    }\n-                };\n-                // Recursive checking\n-                if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n-                    if let Some(ptr) = ptr {\n-                        // not a ZST\n-                        // Skip validation entirely for some external statics\n-                        let alloc_kind = self.ecx.tcx.alloc_map.lock().get(ptr.alloc_id);\n-                        if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n-                            // `extern static` cannot be validated as they have no body.\n-                            // FIXME: Statics from other crates are also skipped.\n-                            // They might be checked at a different type, but for now we\n-                            // want to avoid recursing too deeply.  This is not sound!\n-                            if !did.is_local() || self.ecx.tcx.is_foreign_item(did) {\n-                                return Ok(());\n-                            }\n-                        }\n-                    }\n-                    // Proceed recursively even for ZST, no reason to skip them!\n-                    // `!` is a ZST and we want to validate it.\n-                    // Normalize before handing `place` to tracking because that will\n-                    // check for duplicates.\n-                    let place = if size.bytes() > 0 {\n-                        self.ecx.force_mplace_ptr(place).expect(\"we already bounds-checked\")\n-                    } else {\n-                        place\n-                    };\n-                    let path = &self.path;\n-                    ref_tracking.track(place, || {\n-                        // We need to clone the path anyway, make sure it gets created\n-                        // with enough space for the additional `Deref`.\n-                        let mut new_path = Vec::with_capacity(path.len() + 1);\n-                        new_path.clone_from(path);\n-                        new_path.push(PathElem::Deref);\n-                        new_path\n-                    });\n-                }\n+            ty::Ref(..) => {\n+                self.check_safe_pointer(value, \"reference\")?;\n+                Ok(true)\n+            }\n+            ty::Adt(def, ..) if def.is_box() => {\n+                self.check_safe_pointer(value, \"box\")?;\n+                Ok(true)\n             }\n             ty::FnPtr(_sig) => {\n-                let value = value.to_scalar_or_undef();\n+                let value = self.ecx.read_scalar(value)?;\n                 let _fn = try_validation!(\n                     value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n                     value,\n                     self.path,\n                     \"a function pointer\"\n                 );\n                 // FIXME: Check if the signature matches\n+                Ok(true)\n             }\n-            // This should be all the (inhabited) primitive types\n-            _ => bug!(\"Unexpected primitive type {}\", value.layout.ty),\n+            ty::Never => throw_validation_failure!(\"a value of the never type `!`\", self.path),\n+            ty::Foreign(..) | ty::FnDef(..) => {\n+                // Nothing to check.\n+                Ok(true)\n+            }\n+            // The above should be all the (inhabited) primitive types. The rest is compound, we\n+            // check them by visiting their fields/variants.\n+            // (`Str` UTF-8 check happens in `visit_aggregate`, too.)\n+            ty::Adt(..)\n+            | ty::Tuple(..)\n+            | ty::Array(..)\n+            | ty::Slice(..)\n+            | ty::Str\n+            | ty::Dynamic(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..) => Ok(false),\n+            // Some types only occur during typechecking, they have no layout.\n+            // We should not see them here and we could not check them anyway.\n+            ty::Error\n+            | ty::Infer(..)\n+            | ty::Placeholder(..)\n+            | ty::Bound(..)\n+            | ty::Param(..)\n+            | ty::Opaque(..)\n+            | ty::UnnormalizedProjection(..)\n+            | ty::Projection(..)\n+            | ty::GeneratorWitness(..) => bug!(\"Encountered invalid type {:?}\", ty),\n         }\n-        Ok(())\n     }\n \n     fn visit_scalar(\n@@ -558,41 +610,23 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     }\n \n     #[inline(always)]\n-    fn visit_union(&mut self, _v: Self::V, fields: usize) -> InterpResult<'tcx> {\n-        // Empty unions are not accepted by rustc. That's great, it means we can\n-        // use that as a signal for detecting primitives.  Make sure\n-        // we did not miss any primitive.\n-        assert!(fields > 0);\n+    fn visit_union(&mut self, op: OpTy<'tcx, M::PointerTag>, fields: usize) -> InterpResult<'tcx> {\n+        // Empty unions are not accepted by rustc. But uninhabited enums\n+        // claim to be unions, so allow them, too.\n+        assert!(op.layout.abi.is_uninhabited() || fields > 0);\n         Ok(())\n     }\n \n     #[inline]\n     fn visit_value(&mut self, op: OpTy<'tcx, M::PointerTag>) -> InterpResult<'tcx> {\n         trace!(\"visit_value: {:?}, {:?}\", *op, op.layout);\n \n-        if op.layout.abi.is_uninhabited() {\n-            // Uninhabited types do not have sensible layout, stop right here.\n-            throw_validation_failure!(\n-                format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n-                self.path\n-            )\n-        }\n-\n-        // Check primitive types.  We do this after checking for uninhabited types,\n-        // to exclude fieldless enums (that also appear as fieldless unions here).\n-        // Primitives can have varying layout, so we check them separately and before aggregate\n-        // handling.\n-        // It is CRITICAL that we get this check right, or we might be validating the wrong thing!\n-        let primitive = match op.layout.fields {\n-            // Primitives appear as Union with 0 fields - except for Boxes and fat pointers.\n-            // (Fieldless enums also appear here, but they are uninhabited and thus handled above.)\n-            layout::FieldPlacement::Union(0) => true,\n-            _ => op.layout.ty.builtin_deref(true).is_some(),\n-        };\n-        if primitive {\n-            // No need to recurse further or check scalar layout, this is a leaf type.\n-            return self.visit_primitive(op);\n+        // Check primitive types -- the leafs of our recursive descend.\n+        if self.try_visit_primitive(op)? {\n+            return Ok(());\n         }\n+        // Sanity check: `builtin_deref` does not know any pointers that are not primitive.\n+        assert!(op.layout.ty.builtin_deref(true).is_none());\n \n         // Recursively walk the type. Translate some possible errors to something nicer.\n         match self.walk_value(op) {\n@@ -619,7 +653,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // scalars, we do the same check on every \"level\" (e.g., first we check\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n-            layout::Abi::Uninhabited => unreachable!(), // checked above\n+            layout::Abi::Uninhabited => {\n+                throw_validation_failure!(\n+                    format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n+                    self.path\n+                );\n+            }\n             layout::Abi::Scalar(ref scalar_layout) => {\n                 self.visit_scalar(op, scalar_layout)?;\n             }"}, {"sha": "a3a9b5427678ded3e4a0e38b327d1dca5d8e9d31", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -872,7 +872,7 @@ impl Niche {\n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct LayoutDetails {\n     /// Says where the fields are located within the layout.\n-    /// Primitives and fieldless enums appear as unions without fields.\n+    /// Primitives and uninhabited enums appear as unions without fields.\n     pub fields: FieldPlacement,\n \n     /// Encodes information about multi-variant layouts."}, {"sha": "1922d59891f1e1ea3ef2631eba97f97b598993cc", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 52, "deletions": 31, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -1,74 +1,95 @@\n+#![feature(const_transmute, never_type)]\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n+use std::mem;\n \n #[repr(transparent)]\n #[derive(Copy, Clone)]\n struct Wrap<T>(T);\n \n+#[derive(Copy, Clone)]\n+enum Never {}\n+\n+// # simple enum with discriminant 0\n+\n #[repr(usize)]\n #[derive(Copy, Clone)]\n enum Enum {\n     A = 0,\n }\n-#[repr(C)]\n-union TransmuteEnum {\n-    in1: &'static u8,\n-    in2: usize,\n-    out1: Enum,\n-    out2: Wrap<Enum>,\n-}\n \n-const GOOD_ENUM: Enum = unsafe { TransmuteEnum { in2: 0 }.out1 };\n+const GOOD_ENUM: Enum = unsafe { mem::transmute(0usize) };\n \n-const BAD_ENUM: Enum = unsafe { TransmuteEnum { in2: 1 }.out1 };\n+const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n //~^ ERROR is undefined behavior\n \n-const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n //~^ ERROR is undefined behavior\n \n-const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n+const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n //~^ ERROR is undefined behavior\n \n+// # simple enum with discriminant 2\n+\n // (Potentially) invalid enum discriminant\n #[repr(usize)]\n #[derive(Copy, Clone)]\n enum Enum2 {\n     A = 2,\n }\n \n-#[repr(C)]\n-union TransmuteEnum2 {\n-    in1: usize,\n-    in2: &'static u8,\n-    in3: (),\n-    out1: Enum2,\n-    out2: Wrap<Enum2>, // something wrapping the enum so that we test layout first, not enum\n-    out3: Option<Enum2>,\n-}\n-const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n+const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n //~^ ERROR is undefined behavior\n-const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n+const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n //~^ ERROR is undefined behavior\n-const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n+// something wrapping the enum so that we test layout first, not enum\n+const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n //~^ ERROR is undefined behavior\n \n // Undef enum discriminant.\n-const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+#[repr(C)]\n+union MaybeUninit<T: Copy> {\n+    uninit: (),\n+    init: T,\n+}\n+const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n //~^ ERROR is undefined behavior\n \n // Pointer value in an enum with a niche that is not just 0.\n-const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n //~^ ERROR is undefined behavior\n \n+// # valid discriminant for uninhabited variant\n+\n+// An enum with 3 variants of which some are uninhabited -- so the uninhabited variants *do*\n+// have a discriminant.\n+enum UninhDiscriminant {\n+    A,\n+    B(!),\n+    C,\n+    D(Never),\n+}\n+\n+const GOOD_INHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(0u8) }; // variant A\n+const GOOD_INHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(2u8) }; // variant C\n+\n+const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+//~^ ERROR is undefined behavior\n+const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+//~^ ERROR is undefined behavior\n+\n+// # other\n+\n // Invalid enum field content (mostly to test printing of paths for enum tuple\n // variants and tuples).\n-#[repr(C)]\n-union TransmuteChar {\n-    a: u32,\n-    b: char,\n-}\n // Need to create something which does not clash with enum layout optimizations.\n-const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+//~^ ERROR is undefined behavior\n+\n+// All variants are uninhabited but also have data.\n+const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(1u64) };\n+//~^ ERROR is undefined behavior\n+const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(1u64) };\n //~^ ERROR is undefined behavior\n \n fn main() {"}, {"sha": "10a3d2fa1ab9995efb1d879a7090fd6591a140c0", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -1,75 +1,107 @@\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:23:1\n    |\n-LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in2: 1 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 1, but expected a valid enum discriminant\n+LL | const BAD_ENUM: Enum = unsafe { mem::transmute(1usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 1, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:26:1\n    |\n-LL | const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n+LL | const BAD_ENUM_PTR: Enum = unsafe { mem::transmute(&1) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:29:1\n    |\n-LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n+LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { mem::transmute(&1) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:48:1\n+  --> $DIR/ub-enum.rs:41:1\n    |\n-LL | const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n+LL | const BAD_ENUM2: Enum2 = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:50:1\n+  --> $DIR/ub-enum.rs:43:1\n    |\n-LL | const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n+LL | const BAD_ENUM2_PTR: Enum2 = unsafe { mem::transmute(&0) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:52:1\n+  --> $DIR/ub-enum.rs:46:1\n    |\n-LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n+LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .0.<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:56:1\n+  --> $DIR/ub-enum.rs:55:1\n    |\n-LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:60:1\n+  --> $DIR/ub-enum.rs:59:1\n    |\n-LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n+LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<enum-tag>, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:71:1\n+  --> $DIR/ub-enum.rs:76:1\n    |\n-LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<enum-variant(Some)>.0.1, but expected a valid unicode codepoint\n+LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<enum-variant(B)>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: aborting due to 9 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:78:1\n+   |\n+LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Never at .<enum-variant(D)>.0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:86:1\n+   |\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<enum-variant(Some)>.0.1, but expected a valid unicode codepoint\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:90:1\n+   |\n+LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(1u64) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<enum-variant(Err)>.0.1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:92:1\n+   |\n+LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(1u64) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Never at .<enum-variant(Err)>.0.1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: aborting due to 13 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "1f46b6c98ad2fad012095465feb98417bdf193f2", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -25,11 +25,11 @@ const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n #[repr(C)]\n-union Transmute {\n+union MaybeUninit<T: Copy> {\n     uninit: (),\n-    out: NonZeroU8,\n+    init: T,\n }\n-const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n+const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n //~^ ERROR it is undefined behavior to use this value\n \n // Also test other uses of rustc_layout_scalar_valid_range_start"}, {"sha": "edfc7ac837fc765d664fdac34d81e158aee14a67", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -43,8 +43,8 @@ LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-nonnull.rs:32:1\n    |\n-LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .0, but expected initialized plain (non-pointer) bytes\n+LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes at .0, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "562ec99111b69f56b13b4a6bc49bcc145aad5b7c", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -8,9 +8,16 @@ const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n //~^ ERROR it is undefined behavior to use this value\n //~^^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n \n+const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+//~^ ERROR it is undefined behavior to use this value\n+//~^^ type validation failed: encountered an unaligned box (required 2 byte alignment but found 1)\n+\n const NULL: &u16 = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n // It is very important that we reject this: We do promote `&(4 * REF_AS_USIZE)`,\n // but that would fail to compile; so we ended up breaking user code that would\n // have worked fine had we not promoted.\n@@ -20,7 +27,13 @@ const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n //~^ ERROR it is undefined behavior to use this value\n \n+const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+//~^ ERROR it is undefined behavior to use this value\n+\n fn main() {}"}, {"sha": "fb3df8ace4e153983717275357b378d87bd12a95", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -9,35 +9,67 @@ LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref.rs:11:1\n    |\n+LL | const UNALIGNED_BOX: Box<u16> = unsafe { mem::transmute(&[0u8; 4]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered an unaligned box (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-ref.rs:15:1\n+   |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL reference\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:17:1\n+  --> $DIR/ub-ref.rs:18:1\n+   |\n+LL | const NULL_BOX: Box<u16> = unsafe { mem::transmute(0usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a NULL box\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-ref.rs:24:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:20:1\n+  --> $DIR/ub-ref.rs:27:1\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:23:1\n+  --> $DIR/ub-ref.rs:30:1\n+   |\n+LL | const REF_AS_USIZE_BOX_SLICE: Box<[usize]> = unsafe { mem::transmute::<&[usize], _>(&[mem::transmute(&0)]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-ref.rs:33:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (created from integer)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: aborting due to 5 previous errors\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-ref.rs:36:1\n+   |\n+LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (created from integer)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "e7350ae271673778b5656a3815ecf5ab9f727a9b", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -7,18 +7,18 @@ use std::mem;\n enum Bar {}\n \n #[repr(C)]\n-union TransmuteUnion<A: Clone + Copy, B: Clone + Copy> {\n-    a: A,\n-    b: B,\n+union MaybeUninit<T: Copy> {\n+    uninit: (),\n+    init: T,\n }\n \n-const BAD_BAD_BAD: Bar = unsafe { (TransmuteUnion::<(), Bar> { a: () }).b };\n+const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n //~^ ERROR it is undefined behavior to use this value\n \n const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n-const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n+const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n //~^ ERROR it is undefined behavior to use this value\n \n fn main() {}"}, {"sha": "8ce4279a8b7dd7db11c0cec64c62e24332a3e04e", "filename": "src/test/ui/consts/const-eval/ub-uninhabit.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-uninhabit.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -1,8 +1,8 @@\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:15:1\n    |\n-LL | const BAD_BAD_BAD: Bar = unsafe { (TransmuteUnion::<(), Bar> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar\n+LL | const BAD_BAD_BAD: Bar = unsafe { MaybeUninit { uninit: () }.init };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n@@ -17,8 +17,8 @@ LL | const BAD_BAD_REF: &Bar = unsafe { mem::transmute(1usize) };\n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-uninhabit.rs:21:1\n    |\n-LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { (TransmuteUnion::<(), [Bar; 1]> { a: () }).b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Bar; 1]\n+LL | const BAD_BAD_ARRAY: [Bar; 1] = unsafe { MaybeUninit { uninit: () }.init };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Bar at [0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "26d378847462d0a8569636196fbbf0d7315dfdc1", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 45, "deletions": 90, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -1,72 +1,18 @@\n // ignore-tidy-linelength\n+#![feature(const_transmute)]\n #![allow(unused)]\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n+use std::mem;\n+\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"allocation \\d+\" -> \"allocation N\"\n // normalize-stderr-test \"size \\d+\" -> \"size N\"\n \n #[repr(C)]\n-union BoolTransmute {\n-  val: u8,\n-  bl: bool,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-struct SliceRepr {\n-    ptr: *const u8,\n-    len: usize,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-struct BadSliceRepr {\n-    ptr: *const u8,\n-    len: &'static u8,\n-}\n-\n-#[repr(C)]\n-union SliceTransmute {\n-    repr: SliceRepr,\n-    bad: BadSliceRepr,\n-    addr: usize,\n-    slice: &'static [u8],\n-    raw_slice: *const [u8],\n-    str: &'static str,\n-    my_str: &'static MyStr,\n-    my_slice: &'static MySliceBool,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-struct DynRepr {\n-    ptr: *const u8,\n-    vtable: *const u8,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-struct DynRepr2 {\n-    ptr: *const u8,\n-    vtable: *const u64,\n-}\n-\n-#[repr(C)]\n-#[derive(Copy, Clone)]\n-struct BadDynRepr {\n-    ptr: *const u8,\n-    vtable: usize,\n-}\n-\n-#[repr(C)]\n-union DynTransmute {\n-    repr: DynRepr,\n-    repr2: DynRepr2,\n-    bad: BadDynRepr,\n-    addr: usize,\n-    rust: &'static dyn Trait,\n-    raw_rust: *const dyn Trait,\n+union MaybeUninit<T: Copy> {\n+    uninit: (),\n+    init: T,\n }\n \n trait Trait {}\n@@ -81,90 +27,99 @@ type MySliceBool = MySlice<[bool]>;\n \n // # str\n // OK\n-const STR_VALID: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n+const STR_VALID: &str = unsafe { mem::transmute((&42u8, 1usize)) };\n // bad str\n-const STR_TOO_LONG: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad str\n-const STR_LENGTH_PTR: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n+const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad str in user-defined unsized type\n-const MY_STR_LENGTH_PTR: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n \n // invalid UTF-8\n-const STR_NO_UTF8: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n //~^ ERROR it is undefined behavior to use this value\n // invalid UTF-8 in user-defined str-like\n-const MYSTR_NO_UTF8: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+const MYSTR_NO_UTF8: &MyStr = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n //~^ ERROR it is undefined behavior to use this value\n \n // # slice\n // OK\n-const SLICE_VALID: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n+const SLICE_VALID: &[u8] = unsafe { mem::transmute((&42u8, 1usize)) };\n // bad slice: length uninit\n-const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n+const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n //~^ ERROR it is undefined behavior to use this value\n+    let uninit_len = MaybeUninit::<usize> { uninit: () };\n+    mem::transmute((42, uninit_len))\n+};\n // bad slice: length too big\n-const SLICE_TOO_LONG: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad slice: length not an int\n-const SLICE_LENGTH_PTR: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n+//~^ ERROR it is undefined behavior to use this value\n+// bad slice box: length too big\n+const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+//~^ ERROR it is undefined behavior to use this value\n+// bad slice box: length not an int\n+const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n //~^ ERROR it is undefined behavior to use this value\n \n // bad data *inside* the slice\n-const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n+const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n //~^ ERROR it is undefined behavior to use this value\n \n // good MySliceBool\n const MYSLICE_GOOD: &MySliceBool = &MySlice(true, [false]);\n // bad: sized field is not okay\n-const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n+const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n //~^ ERROR it is undefined behavior to use this value\n // bad: unsized part is not okay\n-const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n+const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n //~^ ERROR it is undefined behavior to use this value\n \n // # raw slice\n-const RAW_SLICE_VALID: *const [u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.raw_slice}; // ok\n-const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.raw_slice}; // ok because raw\n-const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: usize::max_value() } }.raw_slice}; // ok because raw\n-const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n+const RAW_SLICE_VALID: *const [u8] = unsafe { mem::transmute((&42u8, 1usize)) }; // ok\n+const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, 999usize)) }; // ok because raw\n+const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::max_value())) }; // ok because raw\n+const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n //~^ ERROR it is undefined behavior to use this value\n+    let uninit_len = MaybeUninit::<usize> { uninit: () };\n+    mem::transmute((42, uninit_len))\n+};\n \n // # trait object\n // bad trait object\n-const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n+const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad trait object\n-const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n+const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n //~^ ERROR it is undefined behavior to use this value\n // bad trait object\n-const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n+const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n //~^ ERROR it is undefined behavior to use this value\n \n // bad data *inside* the trait object\n-const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n+const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n //~^ ERROR it is undefined behavior to use this value\n \n // # raw trait object\n-const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.raw_rust};\n+const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n //~^ ERROR it is undefined behavior to use this value\n-const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.raw_rust};\n+const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n //~^ ERROR it is undefined behavior to use this value\n-const RAW_TRAIT_OBJ_CONTENT_INVALID: *const dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl } as *const _; // ok because raw\n+const RAW_TRAIT_OBJ_CONTENT_INVALID: *const dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) } as *const dyn Trait; // ok because raw\n \n // Const eval fails for these, so they need to be statics to error.\n static mut RAW_TRAIT_OBJ_VTABLE_NULL_THROUGH_REF: *const dyn Trait = unsafe {\n-    DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust\n+    mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n     //~^ ERROR could not evaluate static initializer\n };\n static mut RAW_TRAIT_OBJ_VTABLE_INVALID_THROUGH_REF: *const dyn Trait = unsafe {\n-    DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust\n+    mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n     //~^ ERROR could not evaluate static initializer\n };\n \n-fn main() {\n-    let _ = RAW_TRAIT_OBJ_VTABLE_NULL;\n-    let _ = RAW_TRAIT_OBJ_VTABLE_INVALID;\n-}\n+fn main() {}"}, {"sha": "22adf0e55ee8c302f8c566960fac409f92474b81", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -1,159 +1,183 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:86:1\n+  --> $DIR/ub-wide-ptr.rs:32:1\n    |\n-LL | const STR_TOO_LONG: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n+LL | const STR_TOO_LONG: &str = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:89:1\n+  --> $DIR/ub-wide-ptr.rs:35:1\n    |\n-LL | const STR_LENGTH_PTR: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n+LL | const STR_LENGTH_PTR: &str = unsafe { mem::transmute((&42u8, &3)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:92:1\n+  --> $DIR/ub-wide-ptr.rs:38:1\n    |\n-LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n+LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:96:1\n+  --> $DIR/ub-wide-ptr.rs:42:1\n    |\n-LL | const STR_NO_UTF8: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n+LL | const STR_NO_UTF8: &str = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:99:1\n+  --> $DIR/ub-wide-ptr.rs:45:1\n    |\n-LL | const MYSTR_NO_UTF8: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n+LL | const MYSTR_NO_UTF8: &MyStr = unsafe { mem::transmute::<&[u8], _>(&[0xFF]) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:106:1\n+  --> $DIR/ub-wide-ptr.rs:52:1\n    |\n-LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n+LL | / const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n+LL | |\n+LL | |     let uninit_len = MaybeUninit::<usize> { uninit: () };\n+LL | |     mem::transmute((42, uninit_len))\n+LL | | };\n+   | |__^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:109:1\n+  --> $DIR/ub-wide-ptr.rs:58:1\n+   |\n+LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:61:1\n    |\n-LL | const SLICE_TOO_LONG: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (not entirely in bounds)\n+LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:112:1\n+  --> $DIR/ub-wide-ptr.rs:64:1\n    |\n-LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n+LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling box (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:116:1\n+  --> $DIR/ub-wide-ptr.rs:67:1\n    |\n-LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n+LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:122:1\n+  --> $DIR/ub-wide-ptr.rs:71:1\n    |\n-LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n+LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+  --> $DIR/ub-wide-ptr.rs:77:1\n    |\n-LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n+LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:132:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n-LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined pointer\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected a boolean\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n+  --> $DIR/ub-wide-ptr.rs:87:1\n    |\n-LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+LL | / const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n+LL | |\n+LL | |     let uninit_len = MaybeUninit::<usize> { uninit: () };\n+LL | |     mem::transmute((42, uninit_len))\n+LL | | };\n+   | |__^ type validation failed: encountered undefined pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:140:1\n+  --> $DIR/ub-wide-ptr.rs:95:1\n    |\n-LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+LL | const TRAIT_OBJ_SHORT_VTABLE_1: &dyn Trait = unsafe { mem::transmute((&92u8, &3u8)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:143:1\n+  --> $DIR/ub-wide-ptr.rs:98:1\n    |\n-LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+LL | const TRAIT_OBJ_SHORT_VTABLE_2: &dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:147:1\n+  --> $DIR/ub-wide-ptr.rs:101:1\n    |\n-LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n+LL | const TRAIT_OBJ_INT_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, 4usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:151:1\n+  --> $DIR/ub-wide-ptr.rs:105:1\n+   |\n+LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:109:1\n    |\n-LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.raw_rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:153:1\n+  --> $DIR/ub-wide-ptr.rs:111:1\n    |\n-LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.raw_rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:159:5\n+  --> $DIR/ub-wide-ptr.rs:117:5\n    |\n-LL |     DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid use of NULL pointer\n+LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ invalid use of NULL pointer\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:163:5\n+  --> $DIR/ub-wide-ptr.rs:121:5\n    |\n-LL |     DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n+LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset N, but is outside bounds of allocation N which has size N\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 22 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "d0e35615dab42f3944a7c35b82f40b29e8ad7cff", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -20,7 +20,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_uninhabited_zsts.rs:17:1\n    |\n LL | const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [Empty; 3]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Empty at [0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "77f0a2ebd4021721434ab61aff16a7f11b7d25e0", "filename": "src/test/ui/consts/validate_never_arrays.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c31b7044c1a1fceb9b22813b9e7219967cf478f3/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fvalidate_never_arrays.stderr?ref=c31b7044c1a1fceb9b22813b9e7219967cf478f3", "patch": "@@ -2,23 +2,23 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:3:1\n    |\n LL | const _: &[!; 1] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type [!; 1] at .<deref>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:6:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 1]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n error[E0080]: it is undefined behavior to use this value\n   --> $DIR/validate_never_arrays.rs:7:1\n    |\n LL | const _: &[!] = unsafe { &*(1_usize as *const [!; 42]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type ! at .<deref>[0]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of the never type `!` at .<deref>[0]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}