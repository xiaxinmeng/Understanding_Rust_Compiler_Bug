{"sha": "cca7ee58110726983951a19d5fb7316d9243925d", "node_id": "C_kwDOAAsO6NoAKGNjYTdlZTU4MTEwNzI2OTgzOTUxYTE5ZDVmYjczMTZkOTI0MzkyNWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T20:27:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T20:27:23Z"}, "message": "Auto merge of #112025 - matthiaskrgr:rollup-j693v67, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #108630 (Fix docs for `alloc::realloc`)\n - #109084 (rustc driver: Remove argument 0 before at-expansion to prevent ICE)\n - #111181 (fix(parse): return unpected when current token is EOF)\n - #111656 (Use an unbounded lifetime in `String::leak`.)\n - #111946 (rustdoc: Add `ItemTemplate` trait and related functions to avoid repetitively wrapping existing functions)\n - #112018 (Clean up usage of `cx.tcx` when `tcx` is already set into a variable)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9700cd93278056f3beb0c5da9844fbe60a4c73ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9700cd93278056f3beb0c5da9844fbe60a4c73ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cca7ee58110726983951a19d5fb7316d9243925d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cca7ee58110726983951a19d5fb7316d9243925d", "html_url": "https://github.com/rust-lang/rust/commit/cca7ee58110726983951a19d5fb7316d9243925d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cca7ee58110726983951a19d5fb7316d9243925d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc428f82f5cfbaeca46122efe4784c8e819be4ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc428f82f5cfbaeca46122efe4784c8e819be4ac", "html_url": "https://github.com/rust-lang/rust/commit/bc428f82f5cfbaeca46122efe4784c8e819be4ac"}, {"sha": "9f5dce7d757583967bcd0a9da7cc489968c4542f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f5dce7d757583967bcd0a9da7cc489968c4542f", "html_url": "https://github.com/rust-lang/rust/commit/9f5dce7d757583967bcd0a9da7cc489968c4542f"}], "stats": {"total": 235, "additions": 141, "deletions": 94}, "files": [{"sha": "eb92ccc17b20ff84cdcd715b3b95b5ea78b4528d", "filename": "compiler/rustc_driver_impl/src/args.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fargs.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -18,6 +18,9 @@ fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n     }\n }\n \n+/// **Note:** This function doesn't interpret argument 0 in any special way.\n+/// If this function is intended to be used with command line arguments,\n+/// `argv[0]` must be removed prior to calling it manually.\n pub fn arg_expand_all(at_args: &[String]) -> Vec<String> {\n     let mut args = Vec::new();\n     for arg in at_args {"}, {"sha": "0b5d737091e4c20444a5916e024ea8a8607a7cb2", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -250,6 +250,16 @@ fn run_compiler(\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n     >,\n ) -> interface::Result<()> {\n+    // Throw away the first argument, the name of the binary.\n+    // In case of at_args being empty, as might be the case by\n+    // passing empty argument array to execve under some platforms,\n+    // just use an empty slice.\n+    //\n+    // This situation was possible before due to arg_expand_all being\n+    // called before removing the argument, enabling a crash by calling\n+    // the compiler with @empty_file as argv[0] and no more arguments.\n+    let at_args = at_args.get(1..).unwrap_or_default();\n+\n     let args = args::arg_expand_all(at_args);\n \n     let Some(matches) = handle_options(&args) else { return Ok(()) };\n@@ -1074,9 +1084,6 @@ fn print_flag_list<T>(\n /// So with all that in mind, the comments below have some more detail about the\n /// contortions done here to get things to work out correctly.\n pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n-    // Throw away the first argument, the name of the binary\n-    let args = &args[1..];\n-\n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not\n         // include that extra information."}, {"sha": "c23420661fa595f871327b272fe7226f61dc2f34", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -536,7 +536,9 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token.kind) {\n             // leave it in the input\n             Ok(false)\n-        } else if self.last_unexpected_token_span == Some(self.token.span) {\n+        } else if self.token.kind != token::Eof\n+            && self.last_unexpected_token_span == Some(self.token.span)\n+        {\n             FatalError.raise();\n         } else {\n             self.expected_one_of_not_found(edible, inedible)"}, {"sha": "c524d4c036709c4c8f4fb3f49adfb5cc9a330199", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -1851,7 +1851,7 @@ impl String {\n     }\n \n     /// Consumes and leaks the `String`, returning a mutable reference to the contents,\n-    /// `&'static mut str`.\n+    /// `&'a mut str`.\n     ///\n     /// This is mainly useful for data that lives for the remainder of\n     /// the program's life. Dropping the returned reference will cause a memory\n@@ -1874,7 +1874,7 @@ impl String {\n     /// ```\n     #[unstable(feature = \"string_leak\", issue = \"102929\")]\n     #[inline]\n-    pub fn leak(self) -> &'static mut str {\n+    pub fn leak<'a>(self) -> &'a mut str {\n         let slice = self.vec.leak();\n         unsafe { from_utf8_unchecked_mut(slice) }\n     }"}, {"sha": "c582111701a998b70618ce5e48151cf0ea482d5b", "filename": "library/core/src/alloc/global.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/library%2Fcore%2Fsrc%2Falloc%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/library%2Fcore%2Fsrc%2Falloc%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fglobal.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -235,7 +235,8 @@ pub unsafe trait GlobalAlloc {\n     /// * `new_size` must be greater than zero.\n     ///\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n-    ///   must not overflow (i.e., the rounded value must be less than `usize::MAX`).\n+    ///   must not overflow isize (i.e., the rounded value must be less than or\n+    ///   equal to `isize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n     /// behavior, e.g., guarantee a sentinel address or a null pointer"}, {"sha": "7dc08b3b1ffa672737049afc16c90c6776eebc1a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -355,9 +355,9 @@ pub(crate) fn build_impl(\n         return;\n     }\n \n-    let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_impl\");\n-\n     let tcx = cx.tcx;\n+    let _prof_timer = tcx.sess.prof.generic_activity(\"build_impl\");\n+\n     let associated_trait = tcx.impl_trait_ref(did).map(ty::EarlyBinder::skip_binder);\n \n     // Only inline impl if the implemented trait is"}, {"sha": "366f93952963ff6faa7418989a3f0db6de72cd4b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -193,7 +193,7 @@ pub(crate) fn build_deref_target_impls(\n         };\n \n         if let Some(prim) = target.primitive_type() {\n-            let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n+            let _prof_timer = tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n             for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, did, None, ret);\n             }"}, {"sha": "9f08609a6d1a6bce27d9d0854be12724cc89110d", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -314,7 +314,6 @@ impl Options {\n         matches: &getopts::Matches,\n         args: Vec<String>,\n     ) -> Result<(Options, RenderOptions), i32> {\n-        let args = &args[1..];\n         // Check for unstable options.\n         nightly_options::check_nightly_options(matches, &opts());\n "}, {"sha": "8aaad8bce1b6e88be7a77a16f86e070eb545376d", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -147,7 +147,7 @@ impl Cache {\n \n         // Cache where all our extern crates are located\n         // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n-        for &crate_num in cx.tcx.crates(()) {\n+        for &crate_num in tcx.crates(()) {\n             let e = ExternalCrate { crate_num };\n \n             let name = e.name(tcx);"}, {"sha": "62027a3fa194174819ade6091defcb61490bbed1", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -9,6 +9,8 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use std::borrow::Borrow;\n+use std::cell::{RefCell, RefMut};\n use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n@@ -216,6 +218,53 @@ fn toggle_close(mut w: impl fmt::Write) {\n     w.write_str(\"</details>\").unwrap();\n }\n \n+trait ItemTemplate<'a, 'cx: 'a>: askama::Template + fmt::Display {\n+    fn item_and_mut_cx(&self) -> (&'a clean::Item, RefMut<'_, &'a mut Context<'cx>>);\n+}\n+\n+fn item_template_document<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, mut cx) = templ.item_and_mut_cx();\n+        let v = document(*cx, item, None, HeadingOffset::H2);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n+fn item_template_document_type_layout<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, cx) = templ.item_and_mut_cx();\n+        let def_id = item.item_id.expect_def_id();\n+        let v = document_type_layout(*cx, def_id);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n+fn item_template_render_attributes_in_pre<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, cx) = templ.item_and_mut_cx();\n+        let tcx = cx.tcx();\n+        let v = render_attributes_in_pre(item, \"\", tcx);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n+fn item_template_render_assoc_items<'a: 'b, 'b, 'cx: 'a>(\n+    templ: &'b impl ItemTemplate<'a, 'cx>,\n+) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n+    display_fn(move |f| {\n+        let (item, mut cx) = templ.item_and_mut_cx();\n+        let def_id = item.item_id.expect_def_id();\n+        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n+        write!(f, \"{v}\")\n+    })\n+}\n+\n fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items: &[clean::Item]) {\n     write!(w, \"{}\", document(cx, item, None, HeadingOffset::H2));\n \n@@ -356,18 +405,18 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n             clean::ImportItem(ref import) => {\n                 let stab_tags = if let Some(import_def_id) = import.source.did {\n-                    let ast_attrs = cx.tcx().get_attrs_unchecked(import_def_id);\n+                    let ast_attrs = tcx.get_attrs_unchecked(import_def_id);\n                     let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs));\n \n                     // Just need an item with the correct def_id and attrs\n                     let import_item = clean::Item {\n                         item_id: import_def_id.into(),\n                         attrs: import_attrs,\n-                        cfg: ast_attrs.cfg(cx.tcx(), &cx.cache().hidden_cfg),\n+                        cfg: ast_attrs.cfg(tcx, &cx.cache().hidden_cfg),\n                         ..myitem.clone()\n                     };\n \n-                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()).to_string());\n+                    let stab_tags = Some(extra_info_tags(&import_item, item, tcx).to_string());\n                     stab_tags\n                 } else {\n                     None\n@@ -405,8 +454,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n                 let unsafety_flag = match *myitem.kind {\n                     clean::FunctionItem(_) | clean::ForeignFunctionItem(_)\n-                        if myitem.fn_header(cx.tcx()).unwrap().unsafety\n-                            == hir::Unsafety::Unsafe =>\n+                        if myitem.fn_header(tcx).unwrap().unsafety == hir::Unsafety::Unsafe =>\n                     {\n                         \"<sup title=\\\"unsafe function\\\">\u26a0</sup>\"\n                     }\n@@ -439,7 +487,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                      {docs_before}{docs}{docs_after}\",\n                     name = myitem.name.unwrap(),\n                     visibility_emoji = visibility_emoji,\n-                    stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n+                    stab_tags = extra_info_tags(myitem, item, tcx),\n                     class = myitem.type_(),\n                     unsafety_flag = unsafety_flag,\n                     href = item_path(myitem.type_(), myitem.name.unwrap().as_str()),\n@@ -886,7 +934,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n \n             for implementor in foreign {\n-                let provided_methods = implementor.inner_impl().provided_trait_methods(cx.tcx());\n+                let provided_methods = implementor.inner_impl().provided_trait_methods(tcx);\n                 let assoc_link =\n                     AssocItemLink::GotoSource(implementor.impl_item.item_id, &provided_methods);\n                 render_impl(\n@@ -919,7 +967,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n         }\n         w.write_str(\"</div>\");\n \n-        if t.is_auto(cx.tcx()) {\n+        if t.is_auto(tcx) {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -948,7 +996,7 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n             \"<div id=\\\"implementors-list\\\"></div>\",\n         );\n \n-        if t.is_auto(cx.tcx()) {\n+        if t.is_auto(tcx) {\n             write_small_section_header(\n                 w,\n                 \"synthetic-implementors\",\n@@ -1131,55 +1179,25 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n     #[derive(Template)]\n     #[template(path = \"item_union.html\")]\n     struct ItemUnion<'a, 'cx> {\n-        cx: std::cell::RefCell<&'a mut Context<'cx>>,\n+        cx: RefCell<&'a mut Context<'cx>>,\n         it: &'a clean::Item,\n         s: &'a clean::Union,\n     }\n \n-    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {\n-        fn render_assoc_items<'b>(\n-            &'b self,\n-        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let def_id = self.it.item_id.expect_def_id();\n-                let mut cx = self.cx.borrow_mut();\n-                let v = render_assoc_items(*cx, self.it, def_id, AssocItemRender::All);\n-                write!(f, \"{v}\")\n-            })\n-        }\n-        fn document_type_layout<'b>(\n-            &'b self,\n-        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let def_id = self.it.item_id.expect_def_id();\n-                let cx = self.cx.borrow_mut();\n-                let v = document_type_layout(*cx, def_id);\n-                write!(f, \"{v}\")\n-            })\n+    impl<'a, 'cx: 'a> ItemTemplate<'a, 'cx> for ItemUnion<'a, 'cx> {\n+        fn item_and_mut_cx(&self) -> (&'a clean::Item, RefMut<'_, &'a mut Context<'cx>>) {\n+            (self.it, self.cx.borrow_mut())\n         }\n+    }\n+\n+    impl<'a, 'cx: 'a> ItemUnion<'a, 'cx> {\n         fn render_union<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n             display_fn(move |f| {\n                 let cx = self.cx.borrow_mut();\n                 let v = render_union(self.it, Some(&self.s.generics), &self.s.fields, *cx);\n                 write!(f, \"{v}\")\n             })\n         }\n-        fn render_attributes_in_pre<'b>(\n-            &'b self,\n-        ) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let tcx = self.cx.borrow().tcx();\n-                let v = render_attributes_in_pre(self.it, \"\", tcx);\n-                write!(f, \"{v}\")\n-            })\n-        }\n-        fn document<'b>(&'b self) -> impl fmt::Display + Captures<'a> + 'b + Captures<'cx> {\n-            display_fn(move |f| {\n-                let mut cx = self.cx.borrow_mut();\n-                let v = document(*cx, self.it, None, HeadingOffset::H2);\n-                write!(f, \"{v}\")\n-            })\n-        }\n         fn document_field<'b>(\n             &'b self,\n             field: &'a clean::Item,\n@@ -1219,7 +1237,7 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n         }\n     }\n \n-    ItemUnion { cx: std::cell::RefCell::new(cx), it, s }.render_into(w).unwrap();\n+    ItemUnion { cx: RefCell::new(cx), it, s }.render_into(w).unwrap();\n }\n \n fn print_tuple_struct_fields<'a, 'cx: 'a>("}, {"sha": "c9b95b1e64599fe42dc6056fec76cb33333ad3ad", "filename": "src/librustdoc/html/render/type_layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftype_layout.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -54,13 +54,13 @@ pub(crate) fn document_type_layout<'a, 'cx: 'a>(\n                     } else if let Primitive::Int(i, _) = tag.primitive() {\n                         i.size().bytes()\n                     } else {\n-                        span_bug!(cx.tcx().def_span(ty_def_id), \"tag is neither niche nor int\")\n+                        span_bug!(tcx.def_span(ty_def_id), \"tag is neither niche nor int\")\n                     };\n                 variants\n                     .iter_enumerated()\n                     .map(|(variant_idx, variant_layout)| {\n                         let Adt(adt, _) = type_layout.ty.kind() else {\n-                            span_bug!(cx.tcx().def_span(ty_def_id), \"not an adt\")\n+                            span_bug!(tcx.def_span(ty_def_id), \"not an adt\")\n                         };\n                         let name = adt.variant(variant_idx).name;\n                         let is_unsized = variant_layout.abi.is_unsized();"}, {"sha": "c2196700513326a5970f87271514b48e1c55aad6", "filename": "src/librustdoc/html/templates/item_union.html", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_union.html?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -1,8 +1,8 @@\n <pre class=\"rust item-decl\"><code>\n-    {{ self.render_attributes_in_pre() | safe }}\n+    {{ self::item_template_render_attributes_in_pre(self.borrow()) | safe }}\n     {{ self.render_union() | safe }}\n </code></pre>\n-{{ self.document() | safe }}\n+{{ self::item_template_document(self.borrow()) | safe }}\n {% if self.fields_iter().peek().is_some() %}\n     <h2 id=\"fields\" class=\"fields small-section-header\">\n         Fields<a href=\"#fields\" class=\"anchor\">\u00a7</a>\n@@ -19,5 +19,5 @@ <h2 id=\"fields\" class=\"fields small-section-header\">\n         {{ self.document_field(field) | safe }}\n     {% endfor %}\n {% endif %}\n-{{ self.render_assoc_items() | safe }}\n-{{ self.document_type_layout() | safe }}\n+{{ self::item_template_render_assoc_items(self.borrow()) | safe }}\n+{{ self::item_template_document_type_layout(self.borrow()) | safe }}"}, {"sha": "12c622e026f1efabb599d9b758d0d70c6a0172a0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -712,13 +712,23 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n }\n \n fn main_args(at_args: &[String]) -> MainResult {\n+    // Throw away the first argument, the name of the binary.\n+    // In case of at_args being empty, as might be the case by\n+    // passing empty argument array to execve under some platforms,\n+    // just use an empty slice.\n+    //\n+    // This situation was possible before due to arg_expand_all being\n+    // called before removing the argument, enabling a crash by calling\n+    // the compiler with @empty_file as argv[0] and no more arguments.\n+    let at_args = at_args.get(1..).unwrap_or_default();\n+\n     let args = rustc_driver::args::arg_expand_all(at_args);\n \n     let mut options = getopts::Options::new();\n     for option in opts() {\n         (option.apply)(&mut options);\n     }\n-    let matches = match options.parse(&args[1..]) {\n+    let matches = match options.parse(&args) {\n         Ok(m) => m,\n         Err(err) => {\n             early_error(ErrorOutputType::default(), err.to_string());"}, {"sha": "061a572c46b6c5340b94aa07babe357242dfd83b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -723,7 +723,7 @@ fn resolve_associated_trait_item<'a>(\n         .iter()\n         .flat_map(|&(impl_, trait_)| {\n             filter_assoc_items_by_name_and_namespace(\n-                cx.tcx,\n+                tcx,\n                 trait_,\n                 Ident::with_dummy_span(item_name),\n                 ns,\n@@ -1743,7 +1743,7 @@ fn resolution_failure(\n                             if let Ok(v_res) = collector.resolve(start, ns, item_id, module_id) {\n                                 debug!(\"found partial_res={:?}\", v_res);\n                                 if !v_res.is_empty() {\n-                                    *partial_res = Some(full_res(collector.cx.tcx, v_res[0]));\n+                                    *partial_res = Some(full_res(tcx, v_res[0]));\n                                     *unresolved = end.into();\n                                     break 'outer;\n                                 }"}, {"sha": "fbf827cce0984cf101774bf55c7d5d49d51c7d65", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -19,9 +19,10 @@ pub(crate) const COLLECT_TRAIT_IMPLS: Pass = Pass {\n };\n \n pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let tcx = cx.tcx;\n     // We need to check if there are errors before running this pass because it would crash when\n     // we try to get auto and blanket implementations.\n-    if cx.tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n+    if tcx.sess.diagnostic().has_errors_or_lint_errors().is_some() {\n         return krate;\n     }\n \n@@ -32,8 +33,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     });\n \n     let local_crate = ExternalCrate { crate_num: LOCAL_CRATE };\n-    let prims: FxHashSet<PrimitiveType> =\n-        local_crate.primitives(cx.tcx).iter().map(|p| p.1).collect();\n+    let prims: FxHashSet<PrimitiveType> = local_crate.primitives(tcx).iter().map(|p| p.1).collect();\n \n     let crate_items = {\n         let mut coll = ItemCollector::new();\n@@ -46,24 +46,23 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n \n     // External trait impls.\n     {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n-        for &cnum in cx.tcx.crates(()) {\n-            for &impl_def_id in cx.tcx.trait_impls_in_crate(cnum) {\n+        let _prof_timer = tcx.sess.prof.generic_activity(\"build_extern_trait_impls\");\n+        for &cnum in tcx.crates(()) {\n+            for &impl_def_id in tcx.trait_impls_in_crate(cnum) {\n                 inline::build_impl(cx, impl_def_id, None, &mut new_items_external);\n             }\n         }\n     }\n \n     // Local trait impls.\n     {\n-        let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n+        let _prof_timer = tcx.sess.prof.generic_activity(\"build_local_trait_impls\");\n         let mut attr_buf = Vec::new();\n-        for &impl_def_id in cx.tcx.trait_impls_in_crate(LOCAL_CRATE) {\n-            let mut parent = Some(cx.tcx.parent(impl_def_id));\n+        for &impl_def_id in tcx.trait_impls_in_crate(LOCAL_CRATE) {\n+            let mut parent = Some(tcx.parent(impl_def_id));\n             while let Some(did) = parent {\n                 attr_buf.extend(\n-                    cx.tcx\n-                        .get_attrs(did, sym::doc)\n+                    tcx.get_attrs(did, sym::doc)\n                         .filter(|attr| {\n                             if let Some([attr]) = attr.meta_item_list().as_deref() {\n                                 attr.has_name(sym::cfg)\n@@ -73,25 +72,24 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n                         })\n                         .cloned(),\n                 );\n-                parent = cx.tcx.opt_parent(did);\n+                parent = tcx.opt_parent(did);\n             }\n             inline::build_impl(cx, impl_def_id, Some((&attr_buf, None)), &mut new_items_local);\n             attr_buf.clear();\n         }\n     }\n \n-    cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n-        for def_id in PrimitiveType::all_impls(cx.tcx) {\n+    tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n+        for def_id in PrimitiveType::all_impls(tcx) {\n             // Try to inline primitive impls from other crates.\n             if !def_id.is_local() {\n                 inline::build_impl(cx, def_id, None, &mut new_items_external);\n             }\n         }\n-        for (prim, did) in PrimitiveType::primitive_locations(cx.tcx) {\n+        for (prim, did) in PrimitiveType::primitive_locations(tcx) {\n             // Do not calculate blanket impl list for docs that are not going to be rendered.\n             // While the `impl` blocks themselves are only in `libcore`, the module with `doc`\n             // attached is directly included in `libstd` as well.\n-            let tcx = cx.tcx;\n             if did.is_local() {\n                 for def_id in prim.impls(tcx).filter(|def_id| {\n                     // Avoid including impl blocks with filled-in generics.\n@@ -157,7 +155,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in new_items_external.iter().chain(new_items_local.iter()) {\n         if let ImplItem(box Impl { ref for_, ref trait_, ref items, .. }) = *it.kind &&\n-            trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait() &&\n+            trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait() &&\n             cleaner.keep_impl(for_, true)\n         {\n             let target = items\n@@ -199,7 +197,7 @@ pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) ->\n         if let ImplItem(box Impl { ref for_, ref trait_, ref kind, .. }) = *it.kind {\n             cleaner.keep_impl(\n                 for_,\n-                trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n+                trait_.as_ref().map(|t| t.def_id()) == tcx.lang_items().deref_trait(),\n             ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || kind.is_blanket()\n         } else {"}, {"sha": "865212205ed1885668cd4898cb3987b689032171", "filename": "src/librustdoc/passes/lint/unescaped_backticks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -56,7 +56,7 @@ pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n                 )\n                 .unwrap_or_else(|| item.attr_span(tcx));\n \n-                cx.tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n+                tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n                     let mut help_emitted = false;\n \n                     match element.prev_code_guess {"}, {"sha": "6b7ad4cf21ae71af4a0e0dbbada5341a7e97b7df", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -280,26 +280,25 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let is_private =\n-            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did, None);\n+        let is_private = !self.cx.cache.effective_visibilities.is_directly_public(tcx, ori_res_did);\n+        let is_hidden = inherits_doc_hidden(tcx, res_did, None);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false;\n         }\n \n         if !please_inline &&\n-            let Some(item_def_id) = reexport_chain(self.cx.tcx, def_id, res_did).iter()\n+            let Some(item_def_id) = reexport_chain(tcx, def_id, res_did).iter()\n                 .flat_map(|reexport| reexport.id()).map(|id| id.expect_local())\n                 .chain(iter::once(res_did)).nth(1) &&\n             item_def_id != def_id &&\n             self\n                 .cx\n                 .cache\n                 .effective_visibilities\n-                .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(self.cx.tcx, item_def_id, None)\n+                .is_directly_public(tcx, item_def_id.to_def_id()) &&\n+            !inherits_doc_hidden(tcx, item_def_id, None)\n         {\n             // The imported item is public and not `doc(hidden)` so no need to inline it.\n             return false;\n@@ -329,7 +328,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n-                    let i = self.cx.tcx.hir().item(i);\n+                    let i = tcx.hir().item(i);\n                     self.visit_item_inner(i, None, Some(def_id));\n                 }\n                 self.inlining = prev;"}, {"sha": "2502beab443738adfad219b2dac7ffb0057b26a1", "filename": "tests/ui/parser/issues/issue-111148.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.rs?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -0,0 +1,2 @@\n+fn a<<i<Y<w<>#\n+//~^ ERROR expected one of `#`, `>`, `const`, identifier, or lifetime, found `<`"}, {"sha": "e6595a5cbcc45cfa879fc6accdcdf9b78b7a7d64", "filename": "tests/ui/parser/issues/issue-111148.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cca7ee58110726983951a19d5fb7316d9243925d/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cca7ee58110726983951a19d5fb7316d9243925d/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-111148.stderr?ref=cca7ee58110726983951a19d5fb7316d9243925d", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `<`\n+  --> $DIR/issue-111148.rs:1:6\n+   |\n+LL | fn a<<i<Y<w<>#\n+   |      ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n+\n+error: aborting due to previous error\n+"}]}