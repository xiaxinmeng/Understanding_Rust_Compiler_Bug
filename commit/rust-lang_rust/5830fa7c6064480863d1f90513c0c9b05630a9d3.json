{"sha": "5830fa7c6064480863d1f90513c0c9b05630a9d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MzBmYTdjNjA2NDQ4MDg2M2QxZjkwNTEzYzBjOWIwNTYzMGE5ZDM=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-27T17:39:02Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata Collection: Collecting direct emission applicabilities (324/455)", "tree": {"sha": "cfb2efba8b962a44b77348c6c767c0e648e1fa5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfb2efba8b962a44b77348c6c767c0e648e1fa5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5830fa7c6064480863d1f90513c0c9b05630a9d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5830fa7c6064480863d1f90513c0c9b05630a9d3", "html_url": "https://github.com/rust-lang/rust/commit/5830fa7c6064480863d1f90513c0c9b05630a9d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5830fa7c6064480863d1f90513c0c9b05630a9d3/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee8a99a1140880e10677fa0b03167cd364fece3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee8a99a1140880e10677fa0b03167cd364fece3f", "html_url": "https://github.com/rust-lang/rust/commit/ee8a99a1140880e10677fa0b03167cd364fece3f"}], "stats": {"total": 126, "additions": 93, "deletions": 33}, "files": [{"sha": "964ddb36e26e0f32109125d563d85c092e8da7d5", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 93, "deletions": 33, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5830fa7c6064480863d1f90513c0c9b05630a9d3/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5830fa7c6064480863d1f90513c0c9b05630a9d3/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=5830fa7c6064480863d1f90513c0c9b05630a9d3", "patch": "@@ -14,16 +14,19 @@\n //! - [ ] TODO The Applicability for each lint for [#4310](https://github.com/rust-lang/rust-clippy/issues/4310)\n \n // # Applicability\n-// - TODO xFrednet 2021-01-17: Find all methods that take and modify applicability or predefine\n-//   them?\n // - TODO xFrednet 2021-01-17: Find lint emit and collect applicability\n+// - TODO xFrednet 2021-02-27: Link applicability from function parameters\n+//   - (Examples: suspicious_operation_groupings:267, needless_bool.rs:311)\n+// - TODO xFrednet 2021-02-27: Tuple if let thingy\n+//   - (Examples: unused_unit.rs:140, misc.rs:694)\n // # NITs\n // - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n \n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{self as hir, ExprKind, Item, ItemKind, Mutability};\n+use rustc_hir::{self as hir, intravisit, ExprKind, Item, ItemKind, Mutability};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n+use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{sym, Loc, Span, Symbol};\n use serde::Serialize;\n@@ -33,13 +36,15 @@ use std::path::Path;\n \n use crate::utils::internal_lints::is_lint_ref_type;\n use crate::utils::{\n-    last_path_segment, match_function_call, match_type, paths, span_lint, walk_ptrs_ty_depth, match_path,\n+    last_path_segment, match_function_call, match_path, match_type, paths, span_lint, walk_ptrs_ty_depth,\n };\n \n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"metadata_collection.json\";\n /// These lints are excluded from the export.\n const BLACK_LISTED_LINTS: [&str; 2] = [\"lint_author\", \"deep_code_inspection\"];\n+/// These groups will be ignored by the lint group matcher\n+const BLACK_LISTED_LINT_GROUP: [&str; 1] = [\"clippy::all\"];\n \n // TODO xFrednet 2021-02-15: `span_lint_and_then` & `span_lint_hir_and_then` requires special\n // handling\n@@ -52,6 +57,9 @@ const LINT_EMISSION_FUNCTIONS: [&[&str]; 5] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n ];\n \n+/// The index of the applicability name of `paths::APPLICABILITY_VALUES`\n+const APPLICABILITY_NAME_INDEX: usize = 2;\n+\n declare_clippy_lint! {\n     /// **What it does:** Collects metadata about clippy lints for the website.\n     ///\n@@ -297,6 +305,10 @@ fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Ite\n \n fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n     for (group_name, lints, _) in &cx.lint_store.get_lint_groups() {\n+        if BLACK_LISTED_LINT_GROUP.contains(group_name) {\n+            continue;\n+        }\n+\n         if lints.iter().any(|x| *x == lint_id) {\n             return Some((*group_name).to_string());\n         }\n@@ -341,7 +353,10 @@ fn match_simple_lint_emission<'hir>(\n }\n \n /// This returns the lint name and the possible applicability of this emission\n-fn extract_emission_info<'hir>(cx: &LateContext<'hir>, args: &[hir::Expr<'_>]) -> Option<(String, Option<String>)> {\n+fn extract_emission_info<'hir>(\n+    cx: &LateContext<'hir>,\n+    args: &'hir [hir::Expr<'hir>],\n+) -> Option<(String, Option<String>)> {\n     let mut lint_name = None;\n     let mut applicability = None;\n \n@@ -358,41 +373,38 @@ fn extract_emission_info<'hir>(cx: &LateContext<'hir>, args: &[hir::Expr<'_>]) -\n         }\n     }\n \n-    lint_name.map(|lint_name| {\n-        (\n-            sym_to_string(lint_name).to_ascii_lowercase(),\n-            applicability,\n-        )\n-    })\n+    lint_name.map(|lint_name| (sym_to_string(lint_name).to_ascii_lowercase(), applicability))\n }\n \n-fn resolve_applicability(cx: &LateContext<'hir>, expr: &hir::Expr<'_>) -> Option<String> {\n+/// This function tries to resolve the linked applicability to the given expression.\n+fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<String> {\n     match expr.kind {\n         // We can ignore ifs without an else block because those can't be used as an assignment\n-        hir::ExprKind::If(_con, _if_block, Some(_else_block)) => {\n-            // self.process_assign_expr(if_block);\n-            // self.process_assign_expr(else_block);\n-            return Some(\"TODO IF EXPR\".to_string());\n+        hir::ExprKind::If(_con, if_block, Some(else_block)) => {\n+            let mut visitor = ApplicabilityVisitor::new(cx);\n+            intravisit::walk_expr(&mut visitor, if_block);\n+            intravisit::walk_expr(&mut visitor, else_block);\n+            visitor.complete()\n         },\n-        hir::ExprKind::Match(_expr, _arms, _) => {\n-            // for arm in *arms {\n-            //     self.process_assign_expr(arm.body);\n-            // }\n-            return Some(\"TODO MATCH EXPR\".to_string());\n+        hir::ExprKind::Match(_expr, arms, _) => {\n+            let mut visitor = ApplicabilityVisitor::new(cx);\n+            arms.iter()\n+                .for_each(|arm| intravisit::walk_expr(&mut visitor, arm.body));\n+            visitor.complete()\n         },\n         hir::ExprKind::Loop(block, ..) | hir::ExprKind::Block(block, ..) => {\n-            if let Some(block_expr) = block.expr {\n-                return resolve_applicability(cx, block_expr);\n-            }\n+            let mut visitor = ApplicabilityVisitor::new(cx);\n+            intravisit::walk_block(&mut visitor, block);\n+            visitor.complete()\n         },\n         ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n             // direct applicabilities are simple:\n             for enum_value in &paths::APPLICABILITY_VALUES {\n                 if match_path(path, enum_value) {\n-                    return Some(enum_value[2].to_string());\n+                    return Some(enum_value[APPLICABILITY_NAME_INDEX].to_string());\n                 }\n             }\n-    \n+\n             // Values yay\n             if let hir::def::Res::Local(local_hir) = path.res {\n                 if let Some(local) = get_parent_local(cx, local_hir) {\n@@ -401,19 +413,67 @@ fn resolve_applicability(cx: &LateContext<'hir>, expr: &hir::Expr<'_>) -> Option\n                     }\n                 }\n             }\n+\n+            // This is true for paths that are linked to function parameters. They might be a bit more work so\n+            // not today :)\n+            None\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn get_parent_local(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n+    let map = cx.tcx.hir();\n+\n+    match map.find(map.get_parent_node(hir_id)) {\n+        Some(hir::Node::Local(local)) => Some(local),\n+        Some(hir::Node::Pat(pattern)) => get_parent_local(cx, pattern.hir_id),\n+        _ => None,\n+    }\n+}\n+\n+/// This visitor finds the highest applicability value in the visited expressions\n+struct ApplicabilityVisitor<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    /// This is the index of hightest `Applicability` for\n+    /// `clippy_utils::paths::APPLICABILITY_VALUES`\n+    applicability_index: Option<usize>,\n+}\n+\n+impl<'a, 'hir> ApplicabilityVisitor<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            applicability_index: None,\n         }\n-        _ => {}\n     }\n \n+    fn add_new_index(&mut self, new_index: usize) {\n+        self.applicability_index = self\n+            .applicability_index\n+            .map_or(new_index, |old_index| old_index.min(new_index))\n+            .into();\n+    }\n \n-    Some(\"TODO\".to_string())\n+    fn complete(self) -> Option<String> {\n+        self.applicability_index\n+            .map(|index| paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX].to_string())\n+    }\n }\n \n-fn get_parent_local(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n-    let map = cx.tcx.hir();\n-    if let Some(hir::Node::Local(local)) = map.find(map.get_parent_node(hir_id)) {\n-        return Some(local);\n+impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityVisitor<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n     }\n \n-    None\n+    fn visit_path(&mut self, path: &hir::Path<'_>, _id: hir::HirId) {\n+        for (index, enum_value) in paths::APPLICABILITY_VALUES.iter().enumerate() {\n+            if match_path(path, enum_value) {\n+                self.add_new_index(index);\n+                break;\n+            }\n+        }\n+    }\n }"}]}