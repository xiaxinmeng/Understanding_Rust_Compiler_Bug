{"sha": "b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZTQzODM4Y2Y3ZTk3YjgxYmYyZjdjZTZlM2QxZjhhMDVjMTY2ZjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-29T07:33:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-23T03:31:39Z"}, "message": "Implement native timers\n\nNative timers are a much hairier thing to deal with than green timers due to the\ninterface that we would like to expose (both a blocking sleep() and a\nchannel-based interface). I ended up implementing timers in three different ways\nfor the various platforms that we supports.\n\nIn all three of the implementations, there is a worker thread which does send()s\non channels for timers. This worker thread is initialized once and then\ncommunicated to in a platform-specific manner, but there's always a shared\nchannel available for sending messages to the worker thread.\n\n* Windows - I decided to use windows kernel timer objects via\n  CreateWaitableTimer and SetWaitableTimer in order to provide sleeping\n  capabilities. The worker thread blocks via WaitForMultipleObjects where one of\n  the objects is an event that is used to wake up the helper thread (which then\n  drains the incoming message channel for requests).\n\n* Linux/(Android?) - These have the ideal interface for implementing timers,\n  timerfd_create. Each timer corresponds to a timerfd, and the helper thread\n  uses epoll to wait for all active timers and then send() for the next one that\n  wakes up. The tricky part in this implementation is updating a timerfd, but\n  see the implementation for the fun details\n\n* OSX/FreeBSD - These obviously don't have the windows APIs, and sadly don't\n  have the timerfd api available to them, so I have thrown together a solution\n  which uses select() plus a timeout in order to ad-hoc-ly implement a timer\n  solution for threads. The implementation is backed by a sorted array of timers\n  which need to fire. As I said, this is an ad-hoc solution which is certainly\n  not accurate timing-wise. I have done this implementation due to the lack of\n  other primitives to provide an implementation, and I've done it the best that\n  I could, but I'm sure that there's room for improvement.\n\nI'm pretty happy with how these implementations turned out. In theory we could\ndrop the timerfd implementation and have linux use the select() + timeout\nimplementation, but it's so inaccurate that I would much rather continue to use\ntimerfd rather than my ad-hoc select() implementation.\n\nThe only change that I would make to the API in general is to have a generic\nsleep() method on an IoFactory which doesn't require allocating a Timer object.\nFor everything but windows it's super-cheap to request a blocking sleep for a\nset amount of time, and it's probably worth it to provide a sleep() which\ndoesn't do something like allocate a file descriptor on linux.", "tree": {"sha": "429ddb0b6f5287ee3dbe962261f68c09d910db42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/429ddb0b6f5287ee3dbe962261f68c09d910db42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "html_url": "https://github.com/rust-lang/rust/commit/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "530909f2d8595447ef95e15326549ab7a51874e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/530909f2d8595447ef95e15326549ab7a51874e7", "html_url": "https://github.com/rust-lang/rust/commit/530909f2d8595447ef95e15326549ab7a51874e7"}], "stats": {"total": 1179, "additions": 1149, "deletions": 30}, "files": [{"sha": "b07e4271ee448f69a70c110e2a95641e134b2254", "filename": "src/libnative/bookkeeping.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fbookkeeping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fbookkeeping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fbookkeeping.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -45,5 +45,6 @@ pub fn wait_for_other_tasks() {\n             TASK_LOCK.wait();\n         }\n         TASK_LOCK.unlock();\n+        TASK_LOCK.destroy();\n     }\n }"}, {"sha": "f3aca7820a50582124436b685acd3836853f62ae", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -46,6 +46,22 @@ pub mod file;\n pub mod process;\n pub mod net;\n \n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+#[path = \"timer_other.rs\"]\n+pub mod timer;\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+#[path = \"timer_timerfd.rs\"]\n+pub mod timer;\n+\n+#[cfg(target_os = \"win32\")]\n+#[path = \"timer_win32.rs\"]\n+pub mod timer;\n+\n+mod timer_helper;\n+\n type IoResult<T> = Result<T, IoError>;\n \n fn unimpl() -> IoError {\n@@ -249,7 +265,7 @@ impl rtio::IoFactory for IoFactory {\n \n     // misc\n     fn timer_init(&mut self) -> IoResult<~RtioTimer> {\n-        Err(unimpl())\n+        timer::Timer::new().map(|t| ~t as ~RtioTimer)\n     }\n     fn spawn(&mut self, config: ProcessConfig)\n             -> IoResult<(~RtioProcess, ~[Option<~RtioPipe>])> {"}, {"sha": "3c20d073f2913306532ebbb5ecea2ac393dfa015", "filename": "src/libnative/io/timer_helper.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the helper thread for the timer module\n+//!\n+//! This module contains the management necessary for the timer worker thread.\n+//! This thread is responsible for performing the send()s on channels for timers\n+//! that are using channels instead of a blocking call.\n+//!\n+//! The timer thread is lazily initialized, and it's shut down via the\n+//! `shutdown` function provided. It must be maintained as an invariant that\n+//! `shutdown` is only called when the entire program is finished. No new timers\n+//! can be created in the future and there must be no active timers at that\n+//! time.\n+\n+use std::cast;\n+use std::rt;\n+use std::unstable::mutex::{Once, ONCE_INIT};\n+\n+use bookkeeping;\n+use io::timer::{Req, Shutdown};\n+use task;\n+\n+// You'll note that these variables are *not* protected by a lock. These\n+// variables are initialized with a Once before any Timer is created and are\n+// only torn down after everything else has exited. This means that these\n+// variables are read-only during use (after initialization) and both of which\n+// are safe to use concurrently.\n+static mut HELPER_CHAN: *mut SharedChan<Req> = 0 as *mut SharedChan<Req>;\n+static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n+\n+pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n+    static mut INIT: Once = ONCE_INIT;\n+\n+    unsafe {\n+        INIT.doit(|| {\n+            let (msgp, msgc) = SharedChan::new();\n+            HELPER_CHAN = cast::transmute(~msgc);\n+            let (receive, send) = imp::new();\n+            HELPER_SIGNAL = send;\n+\n+            do task::spawn {\n+                bookkeeping::decrement();\n+                helper(receive, msgp);\n+            }\n+\n+            rt::at_exit(proc() { shutdown() });\n+        })\n+    }\n+}\n+\n+pub fn send(req: Req) {\n+    unsafe {\n+        assert!(!HELPER_CHAN.is_null());\n+        (*HELPER_CHAN).send(req);\n+        imp::signal(HELPER_SIGNAL);\n+    }\n+}\n+\n+fn shutdown() {\n+    // We want to wait for the entire helper task to exit, and in doing so it\n+    // will attempt to decrement the global task count. When the helper was\n+    // created, it decremented the count so it wouldn't count towards preventing\n+    // the program to exit, so here we pair that manual decrement with a manual\n+    // increment. We will then wait for the helper thread to exit by calling\n+    // wait_for_other_tasks.\n+    bookkeeping::increment();\n+\n+    // Request a shutdown, and then wait for the task to exit\n+    send(Shutdown);\n+    bookkeeping::wait_for_other_tasks();\n+\n+    // Clean up after ther helper thread\n+    unsafe {\n+        imp::close(HELPER_SIGNAL);\n+        let _chan: ~SharedChan<Req> = cast::transmute(HELPER_CHAN);\n+        HELPER_CHAN = 0 as *mut SharedChan<Req>;\n+        HELPER_SIGNAL = 0 as imp::signal;\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use std::libc;\n+    use std::os;\n+\n+    use io::file::FileDesc;\n+\n+    pub type signal = libc::c_int;\n+\n+    pub fn new() -> (signal, signal) {\n+        let pipe = os::pipe();\n+        (pipe.input, pipe.out)\n+    }\n+\n+    pub fn signal(fd: libc::c_int) {\n+        FileDesc::new(fd, false).inner_write([0]);\n+    }\n+\n+    pub fn close(fd: libc::c_int) {\n+        let _fd = FileDesc::new(fd, true);\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use std::libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n+    use std::ptr;\n+    use std::libc;\n+\n+    pub type signal = HANDLE;\n+\n+    pub fn new() -> (HANDLE, HANDLE) {\n+        unsafe {\n+            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+                                      ptr::null());\n+            (handle, handle)\n+        }\n+    }\n+\n+    pub fn signal(handle: HANDLE) {\n+        unsafe { SetEvent(handle); }\n+    }\n+\n+    pub fn close(handle: HANDLE) {\n+        unsafe { CloseHandle(handle); }\n+    }\n+\n+    extern \"system\" {\n+        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn SetEvent(hEvent: HANDLE) -> BOOL;\n+    }\n+}"}, {"sha": "24ffd7a4147782a42e8265b31fde2d6bcc68c6d0", "filename": "src/libnative/io/timer_other.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Timers for non-linux/non-windows OSes\n+//!\n+//! This module implements timers with a worker thread, select(), and a lot of\n+//! witchcraft that turns out to be horribly inaccurate timers. The unfortunate\n+//! part is that I'm at a loss of what else to do one these OSes. This is also\n+//! why linux has a specialized timerfd implementation and windows has its own\n+//! implementation (they're more accurate than this one).\n+//!\n+//! The basic idea is that there is a worker thread that's communicated to via a\n+//! channel and a pipe, the pipe is used by the worker thread in a select()\n+//! syscall with a timeout. The timeout is the \"next timer timeout\" while the\n+//! channel is used to send data over to the worker thread.\n+//!\n+//! Whenever the call to select() times out, then a channel receives a message.\n+//! Whenever the call returns that the file descriptor has information, then the\n+//! channel from timers is drained, enqueueing all incoming requests.\n+//!\n+//! The actual implementation of the helper thread is a sorted array of\n+//! timers in terms of target firing date. The target is the absolute time at\n+//! which the timer should fire. Timers are then re-enqueued after a firing if\n+//! the repeat boolean is set.\n+//!\n+//! Naturally, all this logic of adding times and keeping track of\n+//! relative/absolute time is a little lossy and not quite exact. I've done the\n+//! best I could to reduce the amount of calls to 'now()', but there's likely\n+//! still inaccuracies trickling in here and there.\n+//!\n+//! One of the tricky parts of this implementation is that whenever a timer is\n+//! acted upon, it must cancel whatever the previous action was (if one is\n+//! active) in order to act like the other implementations of this timer. In\n+//! order to do this, the timer's inner pointer is transferred to the worker\n+//! thread. Whenever the timer is modified, it first takes ownership back from\n+//! the worker thread in order to modify the same data structure. This has the\n+//! side effect of \"cancelling\" the previous requests while allowing a\n+//! re-enqueueing later on.\n+//!\n+//! Note that all time units in this file are in *milliseconds*.\n+\n+use std::comm::Data;\n+use std::hashmap::HashMap;\n+use std::libc;\n+use std::os;\n+use std::ptr;\n+use std::rt::rtio;\n+use std::sync::atomics;\n+use std::unstable::intrinsics;\n+\n+use io::file::FileDesc;\n+use io::IoResult;\n+use io::timer_helper;\n+\n+pub struct Timer {\n+    priv id: uint,\n+    priv inner: Option<~Inner>,\n+}\n+\n+struct Inner {\n+    chan: Option<Chan<()>>,\n+    interval: u64,\n+    repeat: bool,\n+    target: u64,\n+    id: uint,\n+}\n+\n+pub enum Req {\n+    // Add a new timer to the helper thread.\n+    NewTimer(~Inner),\n+\n+    // Remove a timer based on its id and then send it back on the channel\n+    // provided\n+    RemoveTimer(uint, Chan<~Inner>),\n+\n+    // Shut down the loop and then ACK this channel once it's shut down\n+    Shutdown,\n+}\n+\n+// returns the current time (in milliseconds)\n+fn now() -> u64 {\n+    unsafe {\n+        let mut now: libc::timeval = intrinsics::init();\n+        assert_eq!(imp::gettimeofday(&mut now, ptr::null()), 0);\n+        return (now.tv_sec as u64) * 1000 + (now.tv_usec as u64) / 1000;\n+    }\n+}\n+\n+fn helper(input: libc::c_int, messages: Port<Req>) {\n+    let mut set: imp::fd_set = unsafe { intrinsics::init() };\n+\n+    let mut fd = FileDesc::new(input, true);\n+    let mut timeout: libc::timeval = unsafe { intrinsics::init() };\n+\n+    // active timers are those which are able to be selected upon (and it's a\n+    // sorted list, and dead timers are those which have expired, but ownership\n+    // hasn't yet been transferred back to the timer itself.\n+    let mut active: ~[~Inner] = ~[];\n+    let mut dead = HashMap::new();\n+\n+    // inserts a timer into an array of timers (sorted by firing time)\n+    fn insert(t: ~Inner, active: &mut ~[~Inner]) {\n+        match active.iter().position(|tm| tm.target > t.target) {\n+            Some(pos) => { active.insert(pos, t); }\n+            None => { active.push(t); }\n+        }\n+    }\n+\n+    // signals the first requests in the queue, possible re-enqueueing it.\n+    fn signal(active: &mut ~[~Inner], dead: &mut HashMap<uint, ~Inner>) {\n+        let mut timer = match active.shift() {\n+            Some(timer) => timer, None => return\n+        };\n+        let chan = timer.chan.take_unwrap();\n+        if chan.try_send(()) && timer.repeat {\n+            timer.chan = Some(chan);\n+            timer.target += timer.interval;\n+            insert(timer, active);\n+        } else {\n+            drop(chan);\n+            dead.insert(timer.id, timer);\n+        }\n+    }\n+\n+    'outer: loop {\n+        let timeout = match active {\n+            // Empty array? no timeout (wait forever for the next request)\n+            [] => ptr::null(),\n+\n+            [~Inner { target, .. }, ..] => {\n+                let now = now();\n+                // If this request has already expired, then signal it and go\n+                // through another iteration\n+                if target <= now {\n+                    signal(&mut active, &mut dead);\n+                    continue;\n+                }\n+\n+                // The actual timeout listed in the requests array is an\n+                // absolute date, so here we translate the absolute time to a\n+                // relative time.\n+                let tm = target - now;\n+                timeout.tv_sec = (tm / 1000) as libc::time_t;\n+                timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n+                &timeout as *libc::timeval\n+            }\n+        };\n+\n+        imp::fd_set(&mut set, input);\n+        match unsafe {\n+            imp::select(input + 1, &set, ptr::null(), ptr::null(), timeout)\n+        } {\n+            // timed out\n+            0 => signal(&mut active, &mut dead),\n+\n+            // file descriptor write woke us up, we've got some new requests\n+            1 => {\n+                loop {\n+                    match messages.try_recv() {\n+                        Data(Shutdown) => {\n+                            assert!(active.len() == 0);\n+                            break 'outer;\n+                        }\n+\n+                        Data(NewTimer(timer)) => insert(timer, &mut active),\n+\n+                        Data(RemoveTimer(id, ack)) => {\n+                            match dead.pop(&id) {\n+                                Some(i) => { ack.send(i); continue }\n+                                None => {}\n+                            }\n+                            let i = active.iter().position(|i| i.id == id);\n+                            let i = i.expect(\"no timer found\");\n+                            let t = active.remove(i).unwrap();\n+                            ack.send(t);\n+                        }\n+                        _ => break\n+                    }\n+                }\n+\n+                // drain the file descriptor\n+                let mut buf = [0];\n+                fd.inner_read(buf);\n+            }\n+\n+            -1 if os::errno() == libc::EINTR as int => {}\n+            n => fail!(\"helper thread failed in select() with error: {} ({})\",\n+                       n, os::last_os_error())\n+        }\n+    }\n+}\n+\n+impl Timer {\n+    pub fn new() -> IoResult<Timer> {\n+        timer_helper::boot(helper);\n+\n+        static mut ID: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+        let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };\n+        Ok(Timer {\n+            id: id,\n+            inner: Some(~Inner {\n+                chan: None,\n+                interval: 0,\n+                target: 0,\n+                repeat: false,\n+                id: id,\n+            })\n+        })\n+    }\n+\n+    pub fn sleep(ms: u64) {\n+        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+    }\n+\n+    fn inner(&mut self) -> ~Inner {\n+        match self.inner.take() {\n+            Some(i) => i,\n+            None => {\n+                let (p, c) = Chan::new();\n+                timer_helper::send(RemoveTimer(self.id, c));\n+                p.recv()\n+            }\n+        }\n+    }\n+}\n+\n+impl rtio::RtioTimer for Timer {\n+    fn sleep(&mut self, msecs: u64) {\n+        let mut inner = self.inner();\n+        inner.chan = None; // cancel any previous request\n+        self.inner = Some(inner);\n+\n+        Timer::sleep(msecs);\n+    }\n+\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        let now = now();\n+        let mut inner = self.inner();\n+\n+        let (p, c) = Chan::new();\n+        inner.repeat = false;\n+        inner.chan = Some(c);\n+        inner.interval = msecs;\n+        inner.target = now + msecs;\n+\n+        timer_helper::send(NewTimer(inner));\n+        return p;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        let now = now();\n+        let mut inner = self.inner();\n+\n+        let (p, c) = Chan::new();\n+        inner.repeat = true;\n+        inner.chan = Some(c);\n+        inner.interval = msecs;\n+        inner.target = now + msecs;\n+\n+        timer_helper::send(NewTimer(inner));\n+        return p;\n+    }\n+}\n+\n+impl Drop for Timer {\n+    fn drop(&mut self) {\n+        self.inner = Some(self.inner());\n+    }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+mod imp {\n+    use std::libc;\n+\n+    pub static FD_SETSIZE: uint = 1024;\n+\n+    pub struct fd_set {\n+        fds_bits: [i32, ..(FD_SETSIZE / 32)]\n+    }\n+\n+    pub fn fd_set(set: &mut fd_set, fd: i32) {\n+        set.fds_bits[fd / 32] |= 1 << (fd % 32);\n+    }\n+\n+    extern {\n+        pub fn select(nfds: libc::c_int,\n+                      readfds: *fd_set,\n+                      writefds: *fd_set,\n+                      errorfds: *fd_set,\n+                      timeout: *libc::timeval) -> libc::c_int;\n+\n+        pub fn gettimeofday(timeval: *mut libc::timeval,\n+                            tzp: *libc::c_void) -> libc::c_int;\n+    }\n+}\n+\n+#[cfg(target_os = \"freebsd\")]\n+mod imp {\n+    use std::libc;\n+\n+    pub static FD_SETSIZE: uint = 1024;\n+\n+    pub struct fd_set {\n+        fds_bits: [u64, ..(FD_SETSIZE / 64)]\n+    }\n+\n+    pub fn fd_set(set: &mut fd_set, fd: i32) {\n+        set.fds_bits[fd / 64] |= (1 << (fd % 64)) as u64;\n+    }\n+\n+    extern {\n+        pub fn select(nfds: libc::c_int,\n+                      readfds: *fd_set,\n+                      writefds: *fd_set,\n+                      errorfds: *fd_set,\n+                      timeout: *libc::timeval) -> libc::c_int;\n+\n+        pub fn gettimeofday(timeval: *mut libc::timeval,\n+                            tzp: *libc::c_void) -> libc::c_int;\n+    }\n+}"}, {"sha": "4912f4f431f1f430f750628a70e83df6810b46cc", "filename": "src/libnative/io/timer_timerfd.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -0,0 +1,303 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Timers based on timerfd_create(2)\n+//!\n+//! On OSes which support timerfd_create, we can use these much more accurate\n+//! timers over select() + a timeout (see timer_other.rs). This strategy still\n+//! employs a worker thread which does the waiting on the timer fds (to send\n+//! messages away).\n+//!\n+//! The worker thread in this implementation uses epoll(7) to block. It\n+//! maintains a working set of *all* native timers in the process, along with a\n+//! pipe file descriptor used to communicate that there is data available on the\n+//! incoming channel to the worker thread. Timers send requests to update their\n+//! timerfd settings to the worker thread (see the comment above 'oneshot' for\n+//! why).\n+//!\n+//! As with timer_other, timers just using sleep() do not use the timerfd at\n+//! all. They remove the timerfd from the worker thread and then invoke usleep()\n+//! to block the calling thread.\n+//!\n+//! As with timer_other, all units in this file are in units of millseconds.\n+\n+use std::comm::Data;\n+use std::libc;\n+use std::ptr;\n+use std::os;\n+use std::rt::rtio;\n+use std::hashmap::HashMap;\n+use std::unstable::intrinsics;\n+\n+use io::file::FileDesc;\n+use io::IoResult;\n+use io::timer_helper;\n+\n+pub struct Timer {\n+    priv fd: FileDesc,\n+    priv on_worker: bool,\n+}\n+\n+pub enum Req {\n+    NewTimer(libc::c_int, Chan<()>, bool, imp::itimerspec),\n+    RemoveTimer(libc::c_int, Chan<()>),\n+    Shutdown,\n+}\n+\n+fn helper(input: libc::c_int, messages: Port<Req>) {\n+    let efd = unsafe { imp::epoll_create(10) };\n+    let _fd1 = FileDesc::new(input, true);\n+    let _fd2 = FileDesc::new(efd, true);\n+\n+    fn add(efd: libc::c_int, fd: libc::c_int) {\n+        let event = imp::epoll_event {\n+            events: imp::EPOLLIN as u32,\n+            data: imp::epoll_data_t { fd: fd, pad: 0, }\n+        };\n+        let ret = unsafe {\n+            imp::epoll_ctl(efd, imp::EPOLL_CTL_ADD, fd, &event)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+    fn del(efd: libc::c_int, fd: libc::c_int) {\n+        let event = imp::epoll_event {\n+            events: 0, data: imp::epoll_data_t { fd: 0, pad: 0, }\n+        };\n+        let ret = unsafe {\n+            imp::epoll_ctl(efd, imp::EPOLL_CTL_DEL, fd, &event)\n+        };\n+        assert_eq!(ret, 0);\n+    }\n+\n+    add(efd, input);\n+    let events: [imp::epoll_event, ..16] = unsafe { intrinsics::init() };\n+    let mut map: HashMap<libc::c_int, (Chan<()>, bool)> = HashMap::new();\n+    'outer: loop {\n+        let n = match unsafe {\n+            imp::epoll_wait(efd, events.as_ptr(),\n+                            events.len() as libc::c_int, -1)\n+        } {\n+            0 => fail!(\"epoll_wait returned immediately!\"),\n+            -1 => fail!(\"epoll wait failed: {}\", os::last_os_error()),\n+            n => n\n+        };\n+\n+        let mut incoming = false;\n+        debug!(\"{} events to process\", n);\n+        for event in events.slice_to(n as uint).iter() {\n+            let fd = event.data.fd;\n+            debug!(\"data on fd {} (input = {})\", fd, input);\n+            if fd == input {\n+                let mut buf = [0, ..1];\n+                // drain the input file descriptor of its input\n+                FileDesc::new(fd, false).inner_read(buf);\n+                incoming = true;\n+            } else {\n+                let mut bits = [0, ..8];\n+                // drain the timerfd of how many times its fired\n+                //\n+                // XXX: should this perform a send() this number of\n+                //      times?\n+                FileDesc::new(fd, false).inner_read(bits);\n+                let remove = {\n+                    match map.find(&fd).expect(\"fd unregistered\") {\n+                        &(ref c, oneshot) => !c.try_send(()) || oneshot\n+                    }\n+                };\n+                if remove {\n+                    map.remove(&fd);\n+                    del(efd, fd);\n+                }\n+            }\n+        }\n+\n+        while incoming {\n+            match messages.try_recv() {\n+                Data(NewTimer(fd, chan, one, timeval)) => {\n+                    // acknowledge we have the new channel, we will never send\n+                    // another message to the old channel\n+                    chan.send(());\n+\n+                    // If we haven't previously seen the file descriptor, then\n+                    // we need to add it to the epoll set.\n+                    if map.insert(fd, (chan, one)) {\n+                        add(efd, fd);\n+                    }\n+\n+                    // Update the timerfd's time value now that we have control\n+                    // of the timerfd\n+                    let ret = unsafe {\n+                        imp::timerfd_settime(fd, 0, &timeval, ptr::null())\n+                    };\n+                    assert_eq!(ret, 0);\n+                }\n+\n+                Data(RemoveTimer(fd, chan)) => {\n+                    if map.remove(&fd) {\n+                        del(efd, fd);\n+                    }\n+                    chan.send(());\n+                }\n+\n+                Data(Shutdown) => {\n+                    assert!(map.len() == 0);\n+                    break 'outer;\n+                }\n+\n+                _ => break,\n+            }\n+        }\n+    }\n+}\n+\n+impl Timer {\n+    pub fn new() -> IoResult<Timer> {\n+        timer_helper::boot(helper);\n+        match unsafe { imp::timerfd_create(imp::CLOCK_MONOTONIC, 0) } {\n+            -1 => Err(super::last_error()),\n+            n => Ok(Timer { fd: FileDesc::new(n, true), on_worker: false, }),\n+        }\n+    }\n+\n+    pub fn sleep(ms: u64) {\n+        unsafe { libc::usleep((ms * 1000) as libc::c_uint); }\n+    }\n+\n+    fn remove(&mut self) {\n+        if !self.on_worker { return }\n+\n+        let (p, c) = Chan::new();\n+        timer_helper::send(RemoveTimer(self.fd.fd(), c));\n+        p.recv();\n+        self.on_worker = false;\n+    }\n+}\n+\n+impl rtio::RtioTimer for Timer {\n+    fn sleep(&mut self, msecs: u64) {\n+        self.remove();\n+        Timer::sleep(msecs);\n+    }\n+\n+    // Periodic and oneshot channels are updated by updating the settings on the\n+    // corresopnding timerfd. The update is not performed on the thread calling\n+    // oneshot or period, but rather the helper epoll thread. The reason for\n+    // this is to avoid losing messages and avoid leaking messages across ports.\n+    //\n+    // By updating the timerfd on the helper thread, we're guaranteed that all\n+    // messages for a particular setting of the timer will be received by the\n+    // new channel/port pair rather than leaking old messages onto the new port\n+    // or leaking new messages onto the old port.\n+    //\n+    // We also wait for the remote thread to actually receive the new settings\n+    // before returning to guarantee the invariant that when oneshot() and\n+    // period() return that the old port will never receive any more messages.\n+\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        let (p, c) = Chan::new();\n+\n+        let new_value = imp::itimerspec {\n+            it_interval: imp::timespec { tv_sec: 0, tv_nsec: 0 },\n+            it_value: imp::timespec {\n+                tv_sec: (msecs / 1000) as libc::time_t,\n+                tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n+            }\n+        };\n+        timer_helper::send(NewTimer(self.fd.fd(), c, true, new_value));\n+        p.recv();\n+        self.on_worker = true;\n+\n+        return p;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        let (p, c) = Chan::new();\n+\n+        let spec = imp::timespec {\n+            tv_sec: (msecs / 1000) as libc::time_t,\n+            tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n+        };\n+        let new_value = imp::itimerspec { it_interval: spec, it_value: spec, };\n+        timer_helper::send(NewTimer(self.fd.fd(), c, false, new_value));\n+        p.recv();\n+        self.on_worker = true;\n+\n+        return p;\n+    }\n+}\n+\n+impl Drop for Timer {\n+    fn drop(&mut self) {\n+        // When the timerfd file descriptor is closed, it will be automatically\n+        // removed from the epoll set of the worker thread, but we want to make\n+        // sure that the associated channel is also removed from the worker's\n+        // hash map.\n+        self.remove();\n+    }\n+}\n+\n+#[allow(dead_code)]\n+mod imp {\n+    use std::libc;\n+\n+    pub static CLOCK_MONOTONIC: libc::c_int = 1;\n+    pub static EPOLL_CTL_ADD: libc::c_int = 1;\n+    pub static EPOLL_CTL_DEL: libc::c_int = 2;\n+    pub static EPOLL_CTL_MOD: libc::c_int = 3;\n+    pub static EPOLLIN: libc::c_int = 0x001;\n+    pub static EPOLLOUT: libc::c_int = 0x004;\n+    pub static EPOLLPRI: libc::c_int = 0x002;\n+    pub static EPOLLERR: libc::c_int = 0x008;\n+    pub static EPOLLRDHUP: libc::c_int = 0x2000;\n+    pub static EPOLLET: libc::c_int = 1 << 31;\n+    pub static EPOLLHUP: libc::c_int = 0x010;\n+    pub static EPOLLONESHOT: libc::c_int = 1 << 30;\n+\n+    pub struct epoll_event {\n+        events: u32,\n+        data: epoll_data_t,\n+    }\n+\n+    pub struct epoll_data_t {\n+        fd: i32,\n+        pad: u32,\n+    }\n+\n+    pub struct timespec {\n+        tv_sec: libc::time_t,\n+        tv_nsec: libc::c_long,\n+    }\n+\n+    pub struct itimerspec {\n+        it_interval: timespec,\n+        it_value: timespec,\n+    }\n+\n+    extern {\n+        pub fn timerfd_create(clockid: libc::c_int,\n+                              flags: libc::c_int) -> libc::c_int;\n+        pub fn timerfd_settime(fd: libc::c_int,\n+                               flags: libc::c_int,\n+                               new_value: *itimerspec,\n+                               old_value: *itimerspec) -> libc::c_int;\n+        pub fn timerfd_gettime(fd: libc::c_int,\n+                               curr_value: *itimerspec) -> libc::c_int;\n+\n+        pub fn epoll_create(size: libc::c_int) -> libc::c_int;\n+        pub fn epoll_ctl(epfd: libc::c_int,\n+                         op: libc::c_int,\n+                         fd: libc::c_int,\n+                         event: *epoll_event) -> libc::c_int;\n+        pub fn epoll_wait(epfd: libc::c_int,\n+                          events: *epoll_event,\n+                          maxevents: libc::c_int,\n+                          timeout: libc::c_int) -> libc::c_int;\n+    }\n+}"}, {"sha": "e359d99eedf659361cd02b816f6a11a7beb20d55", "filename": "src/libnative/io/timer_win32.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Timers based on win32 WaitableTimers\n+//!\n+//! This implementation is meant to be used solely on windows. As with other\n+//! implementations, there is a worker thread which is doing all the waiting on\n+//! a large number of timers for all active timers in the system. This worker\n+//! thread uses the select() equivalent, WaitForMultipleObjects. One of the\n+//! objects being waited on is a signal into the worker thread to notify that\n+//! the incoming channel should be looked at.\n+//!\n+//! Other than that, the implementation is pretty straightforward in terms of\n+//! the other two implementations of timers with nothing *that* new showing up.\n+\n+use std::comm::Data;\n+use std::libc;\n+use std::ptr;\n+use std::rt::rtio;\n+\n+use io::timer_helper;\n+use io::IoResult;\n+\n+pub struct Timer {\n+    priv obj: libc::HANDLE,\n+    priv on_worker: bool,\n+}\n+\n+pub enum Req {\n+    NewTimer(libc::HANDLE, Chan<()>, bool),\n+    RemoveTimer(libc::HANDLE, Chan<()>),\n+    Shutdown,\n+}\n+\n+fn helper(input: libc::HANDLE, messages: Port<Req>) {\n+    let mut objs = ~[input];\n+    let mut chans = ~[];\n+\n+    'outer: loop {\n+        let idx = unsafe {\n+            imp::WaitForMultipleObjects(objs.len() as libc::DWORD,\n+                                        objs.as_ptr(),\n+                                        0 as libc::BOOL,\n+                                        libc::INFINITE)\n+        };\n+\n+        if idx == 0 {\n+            loop {\n+                match messages.try_recv() {\n+                    Data(NewTimer(obj, c, one)) => {\n+                        objs.push(obj);\n+                        chans.push((c, one));\n+                    }\n+                    Data(RemoveTimer(obj, c)) => {\n+                        c.send(());\n+                        match objs.iter().position(|&o| o == obj) {\n+                            Some(i) => {\n+                                objs.remove(i);\n+                                chans.remove(i - 1);\n+                            }\n+                            None => {}\n+                        }\n+                    }\n+                    Data(Shutdown) => {\n+                        assert_eq!(objs.len(), 1);\n+                        assert_eq!(chans.len(), 0);\n+                        break 'outer;\n+                    }\n+                    _ => break\n+                }\n+            }\n+        } else {\n+            let remove = {\n+                match &chans[idx - 1] {\n+                    &(ref c, oneshot) => !c.try_send(()) || oneshot\n+                }\n+            };\n+            if remove {\n+                objs.remove(idx as uint);\n+                chans.remove(idx as uint - 1);\n+            }\n+        }\n+    }\n+}\n+\n+impl Timer {\n+    pub fn new() -> IoResult<Timer> {\n+        timer_helper::boot(helper);\n+\n+        let obj = unsafe {\n+            imp::CreateWaitableTimerA(ptr::mut_null(), 0, ptr::null())\n+        };\n+        if obj.is_null() {\n+            Err(super::last_error())\n+        } else {\n+            Ok(Timer { obj: obj, on_worker: false, })\n+        }\n+    }\n+\n+    pub fn sleep(ms: u64) {\n+        use std::rt::rtio::RtioTimer;\n+        let mut t = Timer::new().ok().expect(\"must allocate a timer!\");\n+        t.sleep(ms);\n+    }\n+\n+    fn remove(&mut self) {\n+        if !self.on_worker { return }\n+\n+        let (p, c) = Chan::new();\n+        timer_helper::send(RemoveTimer(self.obj, c));\n+        p.recv();\n+\n+        self.on_worker = false;\n+    }\n+}\n+\n+impl rtio::RtioTimer for Timer {\n+    fn sleep(&mut self, msecs: u64) {\n+        self.remove();\n+\n+        // there are 10^6 nanoseconds in a millisecond, and the parameter is in\n+        // 100ns intervals, so we multiply by 10^4.\n+        let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n+        assert_eq!(unsafe {\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+                                  ptr::mut_null(), 0)\n+        }, 1);\n+\n+        unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE); }\n+    }\n+\n+    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+        self.remove();\n+        let (p, c) = Chan::new();\n+\n+        // see above for the calculation\n+        let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n+        assert_eq!(unsafe {\n+            imp::SetWaitableTimer(self.obj, &due, 0, ptr::null(),\n+                                  ptr::mut_null(), 0)\n+        }, 1);\n+\n+        timer_helper::send(NewTimer(self.obj, c, true));\n+        self.on_worker = true;\n+        return p;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        self.remove();\n+        let (p, c) = Chan::new();\n+\n+        // see above for the calculation\n+        let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n+        assert_eq!(unsafe {\n+            imp::SetWaitableTimer(self.obj, &due, msecs as libc::LONG,\n+                                  ptr::null(), ptr::mut_null(), 0)\n+        }, 1);\n+\n+        timer_helper::send(NewTimer(self.obj, c, false));\n+        self.on_worker = true;\n+\n+        return p;\n+    }\n+}\n+\n+impl Drop for Timer {\n+    fn drop(&mut self) {\n+        self.remove();\n+        unsafe { libc::CloseHandle(self.obj); }\n+    }\n+}\n+\n+mod imp {\n+    use std::libc::{LPSECURITY_ATTRIBUTES, BOOL, LPCSTR, HANDLE, LARGE_INTEGER,\n+                    LONG, LPVOID, DWORD, c_void};\n+\n+    pub type PTIMERAPCROUTINE = *c_void;\n+\n+    extern \"system\" {\n+        pub fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES,\n+                                    bManualReset: BOOL,\n+                                    lpTimerName: LPCSTR) -> HANDLE;\n+        pub fn SetWaitableTimer(hTimer: HANDLE,\n+                                pDueTime: *LARGE_INTEGER,\n+                                lPeriod: LONG,\n+                                pfnCompletionRoutine: PTIMERAPCROUTINE,\n+                                lpArgToCompletionRoutine: LPVOID,\n+                                fResume: BOOL) -> BOOL;\n+        pub fn WaitForMultipleObjects(nCount: DWORD,\n+                                      lpHandles: *HANDLE,\n+                                      bWaitAll: BOOL,\n+                                      dwMilliseconds: DWORD) -> DWORD;\n+        pub fn WaitForSingleObject(hHandle: HANDLE,\n+                                   dwMilliseconds: DWORD) -> DWORD;\n+    }\n+}"}, {"sha": "d81de989df7d849cad657b7225a0480e03ec20d3", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -34,6 +34,7 @@ macro_rules! iotest (\n             use io::net::udp::*;\n             #[cfg(unix)]\n             use io::net::unix::*;\n+            use io::timer::*;\n             use io::process::*;\n             use str;\n             use util;"}, {"sha": "4bf89a1d5596cb641df9048ac6a3f374e538e1fc", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 145, "deletions": 29, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -96,61 +96,177 @@ impl Timer {\n \n #[cfg(test)]\n mod test {\n-    use prelude::*;\n-    use super::*;\n-\n-    #[test]\n-    fn test_io_timer_sleep_simple() {\n+    iotest!(fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(1);\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_oneshot() {\n+    iotest!(fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n         timer.oneshot(1).recv();\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_oneshot_forget() {\n+    iotest!(fn test_io_timer_sleep_oneshot_forget() {\n         let mut timer = Timer::new().unwrap();\n         timer.oneshot(100000000000);\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_twice() {\n+    iotest!(fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n         let port1 = timer.oneshot(10000);\n         let port = timer.oneshot(1);\n         port.recv();\n-        assert!(port1.recv_opt().is_none());\n-    }\n+        assert_eq!(port1.recv_opt(), None);\n+    })\n \n-    #[test]\n-    fn test_io_timer_oneshot_then_sleep() {\n+    iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n         let port = timer.oneshot(100000000000);\n         timer.sleep(1); // this should invalidate the port\n-        assert!(port.recv_opt().is_none());\n-    }\n \n-    #[test]\n-    fn test_io_timer_sleep_periodic() {\n+        assert_eq!(port.recv_opt(), None);\n+    })\n+\n+    iotest!(fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n         let port = timer.periodic(1);\n         port.recv();\n         port.recv();\n         port.recv();\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_periodic_forget() {\n+    iotest!(fn test_io_timer_sleep_periodic_forget() {\n         let mut timer = Timer::new().unwrap();\n         timer.periodic(100000000000);\n-    }\n+    })\n \n-    #[test]\n-    fn test_io_timer_sleep_standalone() {\n+    iotest!(fn test_io_timer_sleep_standalone() {\n         sleep(1)\n-    }\n+    })\n+\n+    iotest!(fn oneshot() {\n+        let mut timer = Timer::new().unwrap();\n+\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        assert!(port.recv_opt().is_none());\n+\n+        let port = timer.oneshot(1);\n+        port.recv();\n+        assert!(port.recv_opt().is_none());\n+    })\n+\n+    iotest!(fn override() {\n+        let mut timer = Timer::new().unwrap();\n+        let oport = timer.oneshot(100);\n+        let pport = timer.periodic(100);\n+        timer.sleep(1);\n+        assert_eq!(oport.recv_opt(), None);\n+        assert_eq!(pport.recv_opt(), None);\n+        timer.oneshot(1).recv();\n+    })\n+\n+    iotest!(fn period() {\n+        let mut timer = Timer::new().unwrap();\n+        let port = timer.periodic(1);\n+        port.recv();\n+        port.recv();\n+        let port2 = timer.periodic(1);\n+        port2.recv();\n+        port2.recv();\n+    })\n+\n+    iotest!(fn sleep() {\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(1);\n+        timer.sleep(1);\n+    })\n+\n+    iotest!(fn oneshot_fail() {\n+        let mut timer = Timer::new().unwrap();\n+        let _port = timer.oneshot(1);\n+        fail!();\n+    } #[should_fail])\n+\n+    iotest!(fn period_fail() {\n+        let mut timer = Timer::new().unwrap();\n+        let _port = timer.periodic(1);\n+        fail!();\n+    } #[should_fail])\n+\n+    iotest!(fn normal_fail() {\n+        let _timer = Timer::new().unwrap();\n+        fail!();\n+    } #[should_fail])\n+\n+    iotest!(fn closing_channel_during_drop_doesnt_kill_everything() {\n+        // see issue #10375\n+        let mut timer = Timer::new().unwrap();\n+        let timer_port = timer.periodic(1000);\n+\n+        do spawn {\n+            timer_port.recv_opt();\n+        }\n+\n+        // when we drop the TimerWatcher we're going to destroy the channel,\n+        // which must wake up the task on the other end\n+    })\n+\n+    iotest!(fn reset_doesnt_switch_tasks() {\n+        // similar test to the one above.\n+        let mut timer = Timer::new().unwrap();\n+        let timer_port = timer.periodic(1000);\n+\n+        do spawn {\n+            timer_port.recv_opt();\n+        }\n+\n+        timer.oneshot(1);\n+    })\n+\n+    iotest!(fn reset_doesnt_switch_tasks2() {\n+        // similar test to the one above.\n+        let mut timer = Timer::new().unwrap();\n+        let timer_port = timer.periodic(1000);\n+\n+        do spawn {\n+            timer_port.recv_opt();\n+        }\n+\n+        timer.sleep(1);\n+    })\n+\n+    iotest!(fn sender_goes_away_oneshot() {\n+        let port = {\n+            let mut timer = Timer::new().unwrap();\n+            timer.oneshot(1000)\n+        };\n+        assert_eq!(port.recv_opt(), None);\n+    })\n+\n+    iotest!(fn sender_goes_away_period() {\n+        let port = {\n+            let mut timer = Timer::new().unwrap();\n+            timer.periodic(1000)\n+        };\n+        assert_eq!(port.recv_opt(), None);\n+    })\n+\n+    iotest!(fn receiver_goes_away_oneshot() {\n+        let mut timer1 = Timer::new().unwrap();\n+        timer1.oneshot(1);\n+        let mut timer2 = Timer::new().unwrap();\n+        // while sleeping, the prevous timer should fire and not have its\n+        // callback do something terrible.\n+        timer2.sleep(2);\n+    })\n+\n+    iotest!(fn receiver_goes_away_period() {\n+        let mut timer1 = Timer::new().unwrap();\n+        timer1.periodic(1);\n+        let mut timer2 = Timer::new().unwrap();\n+        // while sleeping, the prevous timer should fire and not have its\n+        // callback do something terrible.\n+        timer2.sleep(2);\n+    })\n }"}, {"sha": "8975c2a7955bd9b271dc687783473b378ceb5c08", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -3548,6 +3548,7 @@ pub mod funcs {\n                 pub fn setsid() -> pid_t;\n                 pub fn setuid(uid: uid_t) -> c_int;\n                 pub fn sleep(secs: c_uint) -> c_uint;\n+                pub fn usleep(secs: c_uint) -> c_int;\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n                 pub fn ttyname(fd: c_int) -> *c_char;"}, {"sha": "6f9be64a73d04b0004ba7d4d0e468076b00e689d", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=b8e43838cf7e97b81bf2f7ce6e3d1f8a05c166f5", "patch": "@@ -13,13 +13,20 @@\n //! Documentation can be found on the `rt::at_exit` function.\n \n use cast;\n+use iter::Iterator;\n use option::{Some, None};\n use ptr::RawPtr;\n use unstable::sync::Exclusive;\n use util;\n+use vec::OwnedVector;\n \n type Queue = Exclusive<~[proc()]>;\n \n+// You'll note that these variables are *not* atomic, and this is done on\n+// purpose. This module is designed to have init() called *once* in a\n+// single-task context, and then run() is called only once in another\n+// single-task context. As a result of this, only the `push` function is\n+// thread-safe, and it assumes that the `init` function has run previously.\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n static mut RUNNING: bool = false;\n "}]}