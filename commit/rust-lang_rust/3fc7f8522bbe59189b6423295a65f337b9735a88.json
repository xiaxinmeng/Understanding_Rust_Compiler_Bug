{"sha": "3fc7f8522bbe59189b6423295a65f337b9735a88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYzdmODUyMmJiZTU5MTg5YjY0MjMyOTVhNjVmMzM3Yjk3MzVhODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-14T18:22:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-14T18:22:55Z"}, "message": "Auto merge of #46562 - michaelwoerister:faster-span-hashing, r=eddyb\n\nincr.comp.: Speed up span hashing by caching expansion context hashes.\n\nThis PR fixes the performance regressions from https://github.com/rust-lang/rust/pull/46338.\n\nr? @nikomatsakis", "tree": {"sha": "4f45444154f0da16d64b4c7bb711ac58216ed6ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f45444154f0da16d64b4c7bb711ac58216ed6ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fc7f8522bbe59189b6423295a65f337b9735a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc7f8522bbe59189b6423295a65f337b9735a88", "html_url": "https://github.com/rust-lang/rust/commit/3fc7f8522bbe59189b6423295a65f337b9735a88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fc7f8522bbe59189b6423295a65f337b9735a88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2974104276265858d74733d7ebcca1d3347fd34e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2974104276265858d74733d7ebcca1d3347fd34e", "html_url": "https://github.com/rust-lang/rust/commit/2974104276265858d74733d7ebcca1d3347fd34e"}, {"sha": "0b4c2cccac30ebcd436e0cfd77b34019c40d4ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4c2cccac30ebcd436e0cfd77b34019c40d4ce3", "html_url": "https://github.com/rust-lang/rust/commit/0b4c2cccac30ebcd436e0cfd77b34019c40d4ce3"}], "stats": {"total": 143, "additions": 99, "deletions": 44}, "files": [{"sha": "f9fb668110b108403eb7d414bb4bb05b9987c6f1", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -12,7 +12,7 @@ use hir;\n use hir::def_id::{DefId, DefIndex};\n use hir::map::DefPathHash;\n use hir::map::definitions::Definitions;\n-use ich::{self, CachingCodemapView};\n+use ich::{self, CachingCodemapView, Fingerprint};\n use middle::cstore::CrateStore;\n use ty::{TyCtxt, fast_reject};\n use session::Session;\n@@ -28,12 +28,13 @@ use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n                                            StableHasher, StableHasherResult,\n                                            ToStableHashKey};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n thread_local!(static IGNORED_ATTR_NAMES: RefCell<FxHashSet<Symbol>> =\n     RefCell::new(FxHashSet()));\n@@ -337,19 +338,46 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n             return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n         }\n \n-        let len = span.hi - span.lo;\n-\n         std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n-        std_hash::Hash::hash(&file_lo.name, hasher);\n-        std_hash::Hash::hash(&line_lo, hasher);\n-        std_hash::Hash::hash(&col_lo, hasher);\n-        std_hash::Hash::hash(&len, hasher);\n+        // We truncate the stable_id hash and line and col numbers. The chances\n+        // of causing a collision this way should be minimal.\n+        std_hash::Hash::hash(&(file_lo.stable_id.0 as u64), hasher);\n+\n+        let col = (col_lo.0 as u64) & 0xFF;\n+        let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n+        let len = ((span.hi - span.lo).0 as u64) << 32;\n+        let line_col_len = col | line | len;\n+        std_hash::Hash::hash(&line_col_len, hasher);\n \n         if span.ctxt == SyntaxContext::empty() {\n             TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(hcx, hasher);\n-            span.ctxt.outer().expn_info().hash_stable(hcx, hasher);\n+\n+            // Since the same expansion context is usually referenced many\n+            // times, we cache a stable hash of it and hash that instead of\n+            // recursing every time.\n+            thread_local! {\n+                static CACHE: RefCell<FxHashMap<hygiene::Mark, u64>> =\n+                    RefCell::new(FxHashMap());\n+            }\n+\n+            let sub_hash: u64 = CACHE.with(|cache| {\n+                let mark = span.ctxt.outer();\n+\n+                if let Some(&sub_hash) = cache.borrow().get(&mark) {\n+                    return sub_hash;\n+                }\n+\n+                let mut hasher = StableHasher::new();\n+                mark.expn_info().hash_stable(hcx, &mut hasher);\n+                let sub_hash: Fingerprint = hasher.finish();\n+                let sub_hash = sub_hash.to_smaller_hash();\n+                cache.borrow_mut().insert(mark, sub_hash);\n+                sub_hash\n+            });\n+\n+            sub_hash.hash_stable(hcx, hasher);\n         }\n     }\n }"}, {"sha": "dfb90a5d27feb2e6282fb575955648000a807759", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -394,6 +394,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n             // Do not hash the source as it is not encoded\n             src: _,\n             src_hash,\n+            // The stable id is just a hash of other fields\n+            stable_id: _,\n             external_src: _,\n             start_pos,\n             end_pos: _,"}, {"sha": "7d583a35477393d28a046c48911b46212f1e8ca4", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -176,7 +176,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 let index = FileMapIndex(index as u32);\n                 let file_ptr: *const FileMap = &**file as *const _;\n                 file_to_file_index.insert(file_ptr, index);\n-                file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n+                file_index_to_stable_id.insert(index, file.stable_id);\n             }\n \n             (file_to_file_index, file_index_to_stable_id)"}, {"sha": "aa7eee366d29b904f8f350633da2c5f6f4801733", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -1124,6 +1124,7 @@ impl<'a, 'tcx> CrateMetadata {\n             let syntax_pos::FileMap { name,\n                                       name_was_remapped,\n                                       src_hash,\n+                                      stable_id,\n                                       start_pos,\n                                       end_pos,\n                                       lines,\n@@ -1155,6 +1156,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                                                    name_was_remapped,\n                                                                    self.cnum.as_u32(),\n                                                                    src_hash,\n+                                                                   stable_id,\n                                                                    source_length,\n                                                                    lines,\n                                                                    multibyte_chars,"}, {"sha": "07bba29ca4b045f9aef3d1b2461e28656faba789", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -23,9 +23,7 @@ pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n pub use self::ExpnFormat::*;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::StableHasher;\n use std::cell::{RefCell, Ref};\n-use std::hash::Hash;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n@@ -102,24 +100,6 @@ impl FileLoader for RealFileLoader {\n     }\n }\n \n-// This is a FileMap identifier that is used to correlate FileMaps between\n-// subsequent compilation sessions (which is something we need to do during\n-// incremental compilation).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n-pub struct StableFilemapId(u128);\n-\n-impl StableFilemapId {\n-    pub fn new(filemap: &FileMap) -> StableFilemapId {\n-        let mut hasher = StableHasher::new();\n-\n-        filemap.name.hash(&mut hasher);\n-        filemap.name_was_remapped.hash(&mut hasher);\n-        filemap.unmapped_path.hash(&mut hasher);\n-\n-        StableFilemapId(hasher.finish())\n-    }\n-}\n-\n // _____________________________________________________________________________\n // CodeMap\n //\n@@ -217,7 +197,7 @@ impl CodeMap {\n \n         self.stable_id_to_filemap\n             .borrow_mut()\n-            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+            .insert(filemap.stable_id, filemap.clone());\n \n         filemap\n     }\n@@ -246,6 +226,7 @@ impl CodeMap {\n                                 name_was_remapped: bool,\n                                 crate_of_origin: u32,\n                                 src_hash: u128,\n+                                stable_id: StableFilemapId,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>,\n@@ -276,6 +257,7 @@ impl CodeMap {\n             crate_of_origin,\n             src: None,\n             src_hash,\n+            stable_id,\n             external_src: RefCell::new(ExternalSource::AbsentOk),\n             start_pos,\n             end_pos,\n@@ -288,7 +270,7 @@ impl CodeMap {\n \n         self.stable_id_to_filemap\n             .borrow_mut()\n-            .insert(StableFilemapId::new(&filemap), filemap.clone());\n+            .insert(stable_id, filemap.clone());\n \n         filemap\n     }"}, {"sha": "55342c2768a0e599984eb18b113813c9f2d7d66e", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -60,22 +60,27 @@ impl Mark {\n     }\n \n     /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    #[inline]\n     pub fn root() -> Self {\n         Mark(0)\n     }\n \n+    #[inline]\n     pub fn as_u32(self) -> u32 {\n         self.0\n     }\n \n+    #[inline]\n     pub fn from_u32(raw: u32) -> Mark {\n         Mark(raw)\n     }\n \n+    #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info.clone())\n     }\n \n+    #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n     }\n@@ -91,10 +96,12 @@ impl Mark {\n         })\n     }\n \n+    #[inline]\n     pub fn kind(self) -> MarkKind {\n         HygieneData::with(|data| data.marks[self.0 as usize].kind)\n     }\n \n+    #[inline]\n     pub fn set_kind(self, kind: MarkKind) {\n         HygieneData::with(|data| data.marks[self.0 as usize].kind = kind)\n     }\n@@ -309,10 +316,12 @@ impl SyntaxContext {\n         Some(scope)\n     }\n \n+    #[inline]\n     pub fn modern(self) -> SyntaxContext {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].modern)\n     }\n \n+    #[inline]\n     pub fn outer(self) -> Mark {\n         HygieneData::with(|data| data.syntax_contexts[self.0 as usize].outer_mark)\n     }"}, {"sha": "c3d2f0de21dcd0b6013a8849e53c3e50566c5540", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc7f8522bbe59189b6423295a65f337b9735a88/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=3fc7f8522bbe59189b6423295a65f337b9735a88", "patch": "@@ -678,6 +678,8 @@ pub struct FileMap {\n     pub src: Option<Rc<String>>,\n     /// The source code's hash\n     pub src_hash: u128,\n+    /// The stable id used during incr. comp.\n+    pub stable_id: StableFilemapId,\n     /// The external source code (used for external crates, which will have a `None`\n     /// value as `self.src`.\n     pub external_src: RefCell<ExternalSource>,\n@@ -693,15 +695,37 @@ pub struct FileMap {\n     pub non_narrow_chars: RefCell<Vec<NonNarrowChar>>,\n }\n \n+// This is a FileMap identifier that is used to correlate FileMaps between\n+// subsequent compilation sessions (which is something we need to do during\n+// incremental compilation).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+pub struct StableFilemapId(pub u128);\n+\n+impl StableFilemapId {\n+    pub fn new(name: &FileName,\n+               name_was_remapped: bool,\n+               unmapped_path: &FileName)\n+               -> StableFilemapId {\n+        use std::hash::Hash;\n+\n+        let mut hasher = StableHasher::new();\n+        name.hash(&mut hasher);\n+        name_was_remapped.hash(&mut hasher);\n+        unmapped_path.hash(&mut hasher);\n+        StableFilemapId(hasher.finish())\n+    }\n+}\n+\n impl Encodable for FileMap {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"FileMap\", 8, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n-            s.emit_struct_field(\"src_hash\", 6, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 2, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 3, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 4, |s| {\n+            s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n+            s.emit_struct_field(\"stable_id\", 3, |s| self.stable_id.encode(s))?;\n+            s.emit_struct_field(\"start_pos\", 4, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", 5, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", 6, |s| {\n                 let lines = self.lines.borrow();\n                 // store the length\n                 s.emit_u32(lines.len() as u32)?;\n@@ -747,10 +771,10 @@ impl Encodable for FileMap {\n \n                 Ok(())\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", 5, |s| {\n+            s.emit_struct_field(\"multibyte_chars\", 7, |s| {\n                 (*self.multibyte_chars.borrow()).encode(s)\n             })?;\n-            s.emit_struct_field(\"non_narrow_chars\", 7, |s| {\n+            s.emit_struct_field(\"non_narrow_chars\", 8, |s| {\n                 (*self.non_narrow_chars.borrow()).encode(s)\n             })\n         })\n@@ -765,11 +789,13 @@ impl Decodable for FileMap {\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let src_hash: u128 =\n-                d.read_struct_field(\"src_hash\", 6, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n+            let stable_id: StableFilemapId =\n+                d.read_struct_field(\"stable_id\", 3, |d| Decodable::decode(d))?;\n             let start_pos: BytePos =\n-                d.read_struct_field(\"start_pos\", 2, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 3, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 4, |d| {\n+                d.read_struct_field(\"start_pos\", 4, |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 5, |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 6, |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n@@ -798,9 +824,9 @@ impl Decodable for FileMap {\n                 Ok(lines)\n             })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 5, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", 7, |d| Decodable::decode(d))?;\n             let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"non_narrow_chars\", 8, |d| Decodable::decode(d))?;\n             Ok(FileMap {\n                 name,\n                 name_was_remapped,\n@@ -813,6 +839,7 @@ impl Decodable for FileMap {\n                 end_pos,\n                 src: None,\n                 src_hash,\n+                stable_id,\n                 external_src: RefCell::new(ExternalSource::AbsentOk),\n                 lines: RefCell::new(lines),\n                 multibyte_chars: RefCell::new(multibyte_chars),\n@@ -840,6 +867,10 @@ impl FileMap {\n         hasher.write(src.as_bytes());\n         let src_hash = hasher.finish();\n \n+        let stable_id = StableFilemapId::new(&name,\n+                                             name_was_remapped,\n+                                             &unmapped_path);\n+\n         let end_pos = start_pos.to_usize() + src.len();\n \n         FileMap {\n@@ -849,6 +880,7 @@ impl FileMap {\n             crate_of_origin: 0,\n             src: Some(Rc::new(src)),\n             src_hash,\n+            stable_id,\n             external_src: RefCell::new(ExternalSource::Unneeded),\n             start_pos,\n             end_pos: Pos::from_usize(end_pos),"}]}