{"sha": "5c47e3dbd893e22727058f9bf591f4450dfead21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNDdlM2RiZDg5M2UyMjcyNzA1OGY5YmY1OTFmNDQ1MGRmZWFkMjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-09T15:44:04Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2016-09-11T09:02:45Z"}, "message": "only allow the modification of `static mut` or statics with interior mutability", "tree": {"sha": "1f9fbbbd852e29c256d7294fda63397b2bc5f673", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f9fbbbd852e29c256d7294fda63397b2bc5f673"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c47e3dbd893e22727058f9bf591f4450dfead21", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX1R21AAoJEB1ctPxZfDAE4GkP/RAKJ5zynTbg85mL/dFt3WW2\n5APeGlzk97ZVYVKk0tTzopl+2b/qm2y4e5OWOXyQhEYGuDDj39InDYlG07BQZEoo\n+JCmo7UOv3lSBwXnuR87OPuWgBuaCYUkfUS5FjDdxZM74ZTKMOrZpVV4MLKqqEpx\nAWjfm36cYyiEkYx0cS/MoKvfxMyhhn/O1GTkmG8Ue68znJTUtXnArlc8sa897Jw/\nRHxaDt1cNRsGaqcB/hczybWPk7cAvNcSWeB2c+trElqckKzgyNuweBCP9jiI1t6H\nzjKXIx4/tK6kUd03hncaIsHwrN6NiYs+B0naQlgAeEiEX1eHU0Rrn3YSZKXMairb\n++bNju9Hz5ImWFn3up7d6dw3tkNRagC6B/F+w1m5S0eOB4TG/ow6Xn25ozundMQ2\nY+0jLyaCdyppeODnRZgXY92LOCfb6dbRJ2vsXPtRO/wLnE2Vl9VrJMMaDRkuBZCP\ne2u5pcXcfxKMd7wpf6kgTD9KQ5UxuGNqBgPu7MTL/P92z0XjLtZBhwPpSMnDnLmK\nY4SWxO6I6jeNelZyyY4q8FKEz4gLwpk6QvnyXsbya/7Le/DRUlyoV8YQ/dtwyMZ8\n6Afom3RUwsLjeJfkDDvM5cVgi6zJkw31NwaC4QAmm1tKp5un3/XdM2AU/POQiLxu\n+IrkDzX8Td8lgAc7/hvx\n=8ote\n-----END PGP SIGNATURE-----", "payload": "tree 1f9fbbbd852e29c256d7294fda63397b2bc5f673\nparent 0e58c2a31bc0c6e048d039e61f388b64c1b49793\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1473435844 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1473584565 +0200\n\nonly allow the modification of `static mut` or statics with interior mutability\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c47e3dbd893e22727058f9bf591f4450dfead21", "html_url": "https://github.com/rust-lang/rust/commit/5c47e3dbd893e22727058f9bf591f4450dfead21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c47e3dbd893e22727058f9bf591f4450dfead21/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e58c2a31bc0c6e048d039e61f388b64c1b49793", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e58c2a31bc0c6e048d039e61f388b64c1b49793", "html_url": "https://github.com/rust-lang/rust/commit/0e58c2a31bc0c6e048d039e61f388b64c1b49793"}], "stats": {"total": 94, "additions": 78, "deletions": 16}, "files": [{"sha": "e9312a1ef3e643026b002db8ac7fb3e7215e4bb8", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "patch": "@@ -42,6 +42,7 @@ pub enum EvalError<'tcx> {\n     },\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n+    ModifiedConstantMemory,\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -94,6 +95,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to call a closure through a function pointer\",\n             EvalError::VtableForArgumentlessMethod =>\n                 \"tried to call a vtable function without arguments\",\n+            EvalError::ModifiedConstantMemory =>\n+                \"tried to modify constant memory\",\n         }\n     }\n "}, {"sha": "6ba465cb5990cffb33e17cbb8aa743c688d38bf4", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "patch": "@@ -15,7 +15,7 @@ use std::iter;\n use syntax::codemap::{self, DUMMY_SP};\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, Pointer, AllocId};\n use primval::{self, PrimVal};\n \n use std::collections::HashMap;\n@@ -74,7 +74,7 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub return_ptr: Option<Pointer>,\n \n     /// The block to return to when returning from the current stack frame\n-    pub return_to_block: Option<mir::BasicBlock>,\n+    pub return_to_block: StackPopCleanup,\n \n     /// The list of locals for the current function, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n@@ -139,6 +139,18 @@ enum ConstantKind {\n     Global,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+pub enum StackPopCleanup {\n+    /// The stackframe existed to compute the initial value of a static/constant, make sure the\n+    /// static isn't modifyable afterwards\n+    Freeze(AllocId),\n+    /// A regular stackframe added due to a function call will need to get forwarded to the next\n+    /// block\n+    Goto(mir::BasicBlock),\n+    /// The main function and diverging functions have nowhere to return to\n+    None,\n+}\n+\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>, memory_size: usize, stack_limit: usize) -> Self {\n         EvalContext {\n@@ -313,7 +325,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         mir: CachedMir<'a, 'tcx>,\n         substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>,\n-        return_to_block: Option<mir::BasicBlock>,\n+        return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx, ()> {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n@@ -350,13 +362,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn pop_stack_frame(&mut self) {\n+    fn pop_stack_frame(&mut self) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\"tried to pop a stack frame, but there were none\");\n-        if let Some(target) = frame.return_to_block {\n-            self.goto_block(target);\n+        match frame.return_to_block {\n+            StackPopCleanup::Freeze(alloc_id) => self.memory.freeze(alloc_id)?,\n+            StackPopCleanup::Goto(target) => self.goto_block(target),\n+            StackPopCleanup::None => {},\n         }\n         // TODO(solson): Deallocate local variables.\n+        Ok(())\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n@@ -1036,7 +1051,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n         .expect(\"should at least be able to allocate space for the main function's return value\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), None)\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr), StackPopCleanup::None)\n         .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {"}, {"sha": "2509aba09000356aeb6e92814f167c6e690d9382", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "patch": "@@ -7,11 +7,13 @@ use super::{\n     ConstantId,\n     EvalContext,\n     ConstantKind,\n+    StackPopCleanup,\n };\n use error::EvalResult;\n use rustc::mir::repr as mir;\n use rustc::ty::{subst, self};\n use rustc::hir::def_id::DefId;\n+use rustc::hir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use std::rc::Rc;\n@@ -110,7 +112,7 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n-    fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span) {\n+    fn global_item(&mut self, def_id: DefId, substs: &'tcx subst::Substs<'tcx>, span: Span, immutable: bool) {\n         let cid = ConstantId {\n             def_id: def_id,\n             substs: substs,\n@@ -123,7 +125,12 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n         self.try(|this| {\n             let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n             this.ecx.statics.insert(cid.clone(), ptr);\n-            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), None)\n+            let cleanup = if immutable && !mir.return_ty.type_contents(this.ecx.tcx).interior_unsafe() {\n+                StackPopCleanup::Freeze(ptr.alloc_id)\n+            } else {\n+                StackPopCleanup::None\n+            };\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr), cleanup)\n         });\n     }\n     fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n@@ -150,7 +157,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     // because the type is the actual function, not the signature of the function.\n                     // Thus we can simply create a zero sized allocation in `evaluate_operand`\n                 } else {\n-                    self.global_item(def_id, substs, constant.span);\n+                    self.global_item(def_id, substs, constant.span, true);\n                 }\n             },\n             mir::Literal::Promoted { index } => {\n@@ -168,7 +175,12 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                     let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n                     let mir = CachedMir::Owned(Rc::new(mir));\n                     this.ecx.statics.insert(cid.clone(), return_ptr);\n-                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr), None)\n+                    this.ecx.push_stack_frame(this.def_id,\n+                                              constant.span,\n+                                              mir,\n+                                              this.substs,\n+                                              Some(return_ptr),\n+                                              StackPopCleanup::Freeze(return_ptr.alloc_id))\n                 });\n             }\n         }\n@@ -179,7 +191,17 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n             let substs = subst::Substs::empty(self.ecx.tcx);\n             let span = self.span;\n-            self.global_item(def_id, substs, span);\n+            if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = self.ecx.tcx.map.get_if_local(def_id).expect(\"static not found\") {\n+                if let hir::ItemStatic(_, m, _) = *node {\n+                    self.global_item(def_id, substs, span, m == hir::MutImmutable);\n+                    return;\n+                } else {\n+                    bug!(\"static def id doesn't point to static\");\n+                }\n+            } else {\n+                bug!(\"static def id doesn't point to item\");\n+            }\n+            self.global_item(def_id, substs, span, false);\n         }\n     }\n }"}, {"sha": "9984e1f14eaf1c06d7e6ac332c26e7de3b925b7d", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "patch": "@@ -10,7 +10,7 @@ use std::iter;\n use syntax::{ast, attr};\n use syntax::codemap::{DUMMY_SP, Span};\n \n-use super::{EvalContext, IntegerExt};\n+use super::{EvalContext, IntegerExt, StackPopCleanup};\n use error::{EvalError, EvalResult};\n use memory::Pointer;\n \n@@ -27,7 +27,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         use rustc::mir::repr::TerminatorKind::*;\n         match terminator.kind {\n-            Return => self.pop_stack_frame(),\n+            Return => self.pop_stack_frame()?,\n \n             Goto { target } => self.goto_block(target),\n \n@@ -210,8 +210,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let mir = self.load_mir(resolved_def_id);\n                 let (return_ptr, return_to_block) = match destination {\n-                    Some((ptr, block)) => (Some(ptr), Some(block)),\n-                    None => (None, None),\n+                    Some((ptr, block)) => (Some(ptr), StackPopCleanup::Goto(block)),\n+                    None => (None, StackPopCleanup::None),\n                 };\n                 self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n "}, {"sha": "c02ea22c1d997d4b369d7b24c9e6ebb6de326f63", "filename": "src/memory.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "patch": "@@ -36,6 +36,10 @@ pub struct Allocation {\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: usize,\n+    /// Whether the allocation may be modified.\n+    /// Use the `freeze` method of `Memory` to ensure that an error occurs, if the memory of this\n+    /// allocation is modified in the future.\n+    pub immutable: bool,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -117,6 +121,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(0),\n             align: 1,\n+            immutable: false, // must be mutable, because sometimes we \"move out\" of a ZST\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n@@ -185,6 +190,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align: align,\n+            immutable: false,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -293,6 +299,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation> {\n         match self.alloc_map.get_mut(&id) {\n+            Some(ref alloc) if alloc.immutable => Err(EvalError::ModifiedConstantMemory),\n             Some(alloc) => Ok(alloc),\n             None => match self.functions.get(&id) {\n                 Some(_) => Err(EvalError::DerefFunctionPointer),\n@@ -436,6 +443,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Reading and writing\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n+\n+    pub fn freeze(&mut self, alloc_id: AllocId) -> EvalResult<'tcx, ()> {\n+        self.get_mut(alloc_id)?.immutable = true;\n+        Ok(())\n+    }\n+\n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize, align: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n "}, {"sha": "11961becb246a2a0eae976af412a60941fb6cda3", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "patch": "@@ -0,0 +1,9 @@\n+static X: usize = 5;\n+\n+#[allow(mutable_transmutes)]\n+fn main() {\n+    unsafe {\n+        *std::mem::transmute::<&usize, &mut usize>(&X) = 6; //~ ERROR: tried to modify constant memory\n+        assert_eq!(X, 6);\n+    }\n+}"}, {"sha": "a68f727322e29910d4b72f01939dbcb02058189c", "filename": "tests/run-pass/static_memory_modification.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5c47e3dbd893e22727058f9bf591f4450dfead21/tests%2Frun-pass%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c47e3dbd893e22727058f9bf591f4450dfead21/tests%2Frun-pass%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstatic_memory_modification.rs?ref=5c47e3dbd893e22727058f9bf591f4450dfead21", "previous_filename": "tests/run-pass/bug.rs"}]}