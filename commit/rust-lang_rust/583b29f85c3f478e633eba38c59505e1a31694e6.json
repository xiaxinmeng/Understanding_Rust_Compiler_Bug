{"sha": "583b29f85c3f478e633eba38c59505e1a31694e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4M2IyOWY4NWMzZjQ3OGU2MzNlYmEzOGM1OTUwNWUxYTMxNjk0ZTY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-01-25T22:23:09Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-08T09:53:09Z"}, "message": "Handle comments in css selector and add tests", "tree": {"sha": "851b02805b13176a9e1105b3616abfc0ffd32892", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/851b02805b13176a9e1105b3616abfc0ffd32892"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/583b29f85c3f478e633eba38c59505e1a31694e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/583b29f85c3f478e633eba38c59505e1a31694e6", "html_url": "https://github.com/rust-lang/rust/commit/583b29f85c3f478e633eba38c59505e1a31694e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/583b29f85c3f478e633eba38c59505e1a31694e6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "649715d09b29c76f71eb5d213d34b4108b8dcf65", "url": "https://api.github.com/repos/rust-lang/rust/commits/649715d09b29c76f71eb5d213d34b4108b8dcf65", "html_url": "https://github.com/rust-lang/rust/commit/649715d09b29c76f71eb5d213d34b4108b8dcf65"}], "stats": {"total": 103, "additions": 80, "deletions": 23}, "files": [{"sha": "b64d61184e0dd599127e9c87262c9f9df19f6332", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 80, "deletions": 23, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/583b29f85c3f478e633eba38c59505e1a31694e6/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/583b29f85c3f478e633eba38c59505e1a31694e6/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=583b29f85c3f478e633eba38c59505e1a31694e6", "patch": "@@ -167,37 +167,53 @@ fn get_useful_next(events: &[Events], pos: &mut usize) -> Option<Events> {\n     None\n }\n \n+fn get_previous_positions(events: &[Events], mut pos: usize) -> Vec<usize> {\n+    let mut ret = Vec::with_capacity(3);\n+\n+    ret.push(events[pos].get_pos() - 1);\n+    if pos > 0 {\n+        pos -= 1;\n+    }\n+    loop {\n+        ret.push(events[pos].get_pos());\n+        if pos < 1 || !events[pos].is_comment() {\n+            break\n+        }\n+        pos -= 1;\n+    }\n+    if events[pos].is_comment() {\n+        ret.push(0);\n+    }\n+    ret.iter().rev().cloned().collect()\n+}\n+\n+fn build_rule(v: &[u8], positions: &[usize]) -> String {\n+    positions.chunks(2)\n+             .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\").to_owned())\n+             .collect::<String>()\n+             .trim()\n+             .replace(\"\\n\", \" \")\n+}\n+\n fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> HashSet<CssPath> {\n     let mut pathes = Vec::with_capacity(50);\n \n     while *pos < events.len() {\n         if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n-            println!(\"00 => {:?}\", events[*pos]);\n             *pos += 1;\n             break\n         }\n-        println!(\"a => {:?}\", events[*pos]);\n-        if let Some(Events::InBlock(start_pos)) = get_useful_next(events, pos) {\n-            println!(\"aa => {:?}\", events[*pos]);\n-            pathes.push(CssPath::new(::std::str::from_utf8(if *pos > 0 {\n-                &v[events[*pos - 1].get_pos()..start_pos - 1]\n-            } else {\n-                &v[..start_pos]\n-            }).unwrap_or(\"\").trim().to_owned()));\n+        if let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n+            pathes.push(CssPath::new(build_rule(v, &get_previous_positions(events, *pos))));\n             *pos += 1;\n         }\n-        println!(\"b => {:?}\", events[*pos]);\n         while let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n-            println!(\"bb => {:?}\", events[*pos]);\n             if let Some(ref mut path) = pathes.last_mut() {\n                 for entry in inner(v, events, pos).iter() {\n                     path.children.insert(entry.clone());\n                 }\n             }\n         }\n-        if *pos < events.len() {\n-            println!(\"c => {:?}\", events[*pos]);\n-        }\n         if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n             *pos += 1;\n         }\n@@ -209,13 +225,12 @@ pub fn load_css_pathes(v: &[u8]) -> CssPath {\n     let events = load_css_events(v);\n     let mut pos = 0;\n \n-    println!(\"\\n======> {:?}\", events);\n     let mut parent = CssPath::new(\"parent\".to_owned());\n     parent.children = inner(v, &events, &mut pos);\n     parent\n }\n \n-fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n+pub fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n     if against.name != other.name {\n         return\n     } else {\n@@ -250,16 +265,18 @@ pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath) -> Vec<Strin\n \n     try_something!(file.read_to_end(&mut data), Vec::new());\n     let pathes = load_css_pathes(&data);\n-    println!(\"========= {:?}\", pathes);\n-    println!(\"========= {:?}\", against);\n     let mut ret = Vec::new();\n     get_differences(against, &pathes, &mut ret);\n     ret\n }\n \n-/*#[test]\n-fn test_comments_in_rules() {\n-    let text = r#\"\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_comments_in_rules() {\n+        let text = r#\"\n rule a {}\n \n rule b, c\n@@ -284,6 +301,46 @@ rule j/*commeeeeent\n \n you like things like \"{}\" in there? :)\n */\n-end {}\n+end {}\"#;\n+\n+        let against = r#\"\n+rule a {}\n+\n+rule b, c {}\n+\n+rule d e {}\n+\n+rule f {}\n+\n+rule gh i {}\n+\n+rule j end {}\n+\"#;\n+\n+        assert!(get_differences(&load_css_pathes(against.as_bytes()),\n+                                &load_css_pathes(text.as_bytes())).is_empty());\n+    }\n+\n+    #[test]\n+    fn test_comparison() {\n+        let x = r#\"\n+a {\n+    b {\n+        c {}\n+    }\n+}\n+\"#;\n+\n+        let y = r#\"\n+a {\n+    b {}\n+}\n \"#;\n-}*/\n+\n+        let against = load_css_pathes(y.as_bytes());\n+        let other = load_css_pathes(x.as_bytes());\n+\n+        assert!(get_differences(&against, &other).is_empty());\n+        assert_eq!(get_differences(&other, &against), vec![\"  Missing \\\"c\\\" rule\".to_owned()])\n+    }\n+}"}]}