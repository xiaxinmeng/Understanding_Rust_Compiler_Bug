{"sha": "b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2M2E1ZWVkNmU4YTIzNzlhYWJlNGViMDMyOGFkMjM4YzA1N2M2MGY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-08T12:24:44Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:53Z"}, "message": "mir: Support RustCall ABI functions.", "tree": {"sha": "b50a4d7f61ec318c7d8b30e5c1866099c0f94fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b50a4d7f61ec318c7d8b30e5c1866099c0f94fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "html_url": "https://github.com/rust-lang/rust/commit/b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e485874e668fdc21855e0a288f526161576070", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e485874e668fdc21855e0a288f526161576070", "html_url": "https://github.com/rust-lang/rust/commit/92e485874e668fdc21855e0a288f526161576070"}], "stats": {"total": 64, "additions": 54, "deletions": 10}, "files": [{"sha": "84187d941a6b08b9722405a9e442ce5184875ba0", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "patch": "@@ -178,6 +178,10 @@ pub struct TempDecl<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n+\n+    /// If true, this argument is a tuple after monomorphization,\n+    /// and has to be collected from multiple actual arguments.\n+    pub spread: bool\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "7fd959390de374c635cc95081a133149d0902e66", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "patch": "@@ -149,7 +149,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                                                  pattern,\n                                                                  &lvalue));\n                     }\n-                    ArgDecl { ty: ty }\n+                    ArgDecl { ty: ty, spread: false }\n                 })\n                 .collect();\n "}, {"sha": "4717c54ca649161e6b692c2031761110c778459c", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "patch": "@@ -33,6 +33,7 @@ use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n@@ -181,13 +182,20 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n     let parameter_scope =\n         cx.tcx().region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n-    Ok(build::construct(cx,\n-                        span,\n-                        implicit_arg_tys,\n-                        arguments,\n-                        parameter_scope,\n-                        fn_sig.output,\n-                        body))\n+    let mut mir = build::construct(cx, span, implicit_arg_tys, arguments,\n+                                  parameter_scope, fn_sig.output, body);\n+\n+    match cx.tcx().node_id_to_type(fn_id).sty {\n+        ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n+            // RustCall pseudo-ABI untuples the last argument.\n+            if let Some(arg_decl) = mir.arg_decls.last_mut() {\n+                arg_decl.spread = true;\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    Ok(mir)\n }\n \n fn closure_self_ty<'a, 'tcx>(tcx: &TyCtxt<'tcx>,"}, {"sha": "c9269e9f793fefa6d62718e12a625bc6fa34f9e8", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63a5eed6e8a2379aabe4eb0328ad238c057c60f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=b63a5eed6e8a2379aabe4eb0328ad238c057c60f", "patch": "@@ -147,15 +147,47 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>)\n                               -> Vec<LvalueRef<'tcx>> {\n-    // FIXME tupled_args? I think I'd rather that mapping is done in MIR land though\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n     mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n+        let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+        if arg_decl.spread {\n+            // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+            // is a tuple that was spread at the ABI level and now we have\n+            // to reconstruct it into a tuple local variable, from multiple\n+            // individual LLVM function arguments.\n+\n+            let tupled_arg_tys = match arg_ty.sty {\n+                ty::TyTuple(ref tys) => tys,\n+                _ => unreachable!(\"spread argument isn't a tuple?!\")\n+            };\n+\n+            let llval = bcx.with_block(|bcx| {\n+                let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+                for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                    let dst = build::StructGEP(bcx, lltemp, i);\n+                    let arg = &fcx.fn_ty.args[idx];\n+                    idx += 1;\n+                    if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n+                        // We pass fat pointers as two words, but inside the tuple\n+                        // they are the two sub-fields of a single aggregate field.\n+                        let meta = &fcx.fn_ty.args[idx];\n+                        idx += 1;\n+                        arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                        meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                    } else {\n+                        arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                    }\n+                }\n+                lltemp\n+            });\n+            return LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty));\n+        }\n+\n         let arg = &fcx.fn_ty.args[idx];\n         idx += 1;\n-        let arg_ty = bcx.monomorphize(&arg_decl.ty);\n         let llval = if arg.is_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up, unless"}]}