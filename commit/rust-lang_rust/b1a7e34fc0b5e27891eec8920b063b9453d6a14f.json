{"sha": "b1a7e34fc0b5e27891eec8920b063b9453d6a14f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxYTdlMzRmYzBiNWUyNzg5MWVlYzg5MjBiMDYzYjk0NTNkNmExNGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T22:11:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T22:11:53Z"}, "message": "rollup merge of #21127: erickt/opt-stack\n\nlibsyntax compiled without optimization uses a lot of stack, which can cause it to run out of stack space. This PR factors out some arm handlers from `print_expr` as well as converts `advance_left` into a loop. This helps to cut down on the stack usage.", "tree": {"sha": "07c1bb630e69286dc97c6abc026e0110195f2218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c1bb630e69286dc97c6abc026e0110195f2218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1a7e34fc0b5e27891eec8920b063b9453d6a14f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a7e34fc0b5e27891eec8920b063b9453d6a14f", "html_url": "https://github.com/rust-lang/rust/commit/b1a7e34fc0b5e27891eec8920b063b9453d6a14f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1a7e34fc0b5e27891eec8920b063b9453d6a14f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c4092d73695fd162522e6b481d17a0b37b40e64", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c4092d73695fd162522e6b481d17a0b37b40e64", "html_url": "https://github.com/rust-lang/rust/commit/4c4092d73695fd162522e6b481d17a0b37b40e64"}, {"sha": "e14d053a509c31c6859ce630427c9053cb1bb261", "url": "https://api.github.com/repos/rust-lang/rust/commits/e14d053a509c31c6859ce630427c9053cb1bb261", "html_url": "https://github.com/rust-lang/rust/commit/e14d053a509c31c6859ce630427c9053cb1bb261"}], "stats": {"total": 426, "additions": 252, "deletions": 174}, "files": [{"sha": "06d510d37bd312dc6a032b0975a1db3380d2bcfb", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 100, "deletions": 89, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/b1a7e34fc0b5e27891eec8920b063b9453d6a14f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a7e34fc0b5e27891eec8920b063b9453d6a14f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b1a7e34fc0b5e27891eec8920b063b9453d6a14f", "patch": "@@ -59,10 +59,6 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n-pub use self::PrintStackBreak::*;\n-pub use self::Breaks::*;\n-pub use self::Token::*;\n-\n use std::io;\n use std::string;\n use std::iter::repeat;\n@@ -87,7 +83,7 @@ pub struct BeginToken {\n \n #[derive(Clone)]\n pub enum Token {\n-    String(string::String, int),\n+    String(String, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -96,12 +92,15 @@ pub enum Token {\n \n impl Token {\n     pub fn is_eof(&self) -> bool {\n-        match *self { Eof => true, _ => false }\n+        match *self {\n+            Token::Eof => true,\n+            _ => false,\n+        }\n     }\n \n     pub fn is_hardbreak_tok(&self) -> bool {\n         match *self {\n-            Break(BreakToken {\n+            Token::Break(BreakToken {\n                 offset: 0,\n                 blank_space: bs\n             }) if bs == SIZE_INFINITY =>\n@@ -112,22 +111,22 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(t: Token) -> string::String {\n-    match t {\n-        String(s, len) => return format!(\"STR({},{})\", s, len),\n-        Break(_) => return \"BREAK\".to_string(),\n-        Begin(_) => return \"BEGIN\".to_string(),\n-        End => return \"END\".to_string(),\n-        Eof => return \"EOF\".to_string()\n+pub fn tok_str(token: &Token) -> String {\n+    match *token {\n+        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n+        Token::Break(_) => \"BREAK\".to_string(),\n+        Token::Begin(_) => \"BEGIN\".to_string(),\n+        Token::End => \"END\".to_string(),\n+        Token::Eof => \"EOF\".to_string()\n     }\n }\n \n-pub fn buf_str(toks: Vec<Token>,\n-               szs: Vec<int>,\n+pub fn buf_str(toks: &[Token],\n+               szs: &[int],\n                left: uint,\n                right: uint,\n                lim: uint)\n-               -> string::String {\n+               -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n@@ -140,7 +139,7 @@ pub fn buf_str(toks: Vec<Token>,\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(toks[i].clone()))[]);\n+                           tok_str(&toks[i]))[]);\n         i += 1u;\n         i %= n;\n     }\n@@ -167,7 +166,7 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: Vec<Token> = repeat(Eof).take(n).collect();\n+    let token: Vec<Token> = repeat(Token::Eof).take(n).collect();\n     let size: Vec<int> = repeat(0i).take(n).collect();\n     let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n     Printer {\n@@ -312,20 +311,18 @@ impl Printer {\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, t: Token) -> io::IoResult<()> {\n+    pub fn pretty_print(&mut self, token: Token) -> io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n-        match t {\n-          Eof => {\n+        match token {\n+          Token::Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                let left = self.token[self.left].clone();\n-                let left_size = self.size[self.left];\n-                try!(self.advance_left(left, left_size));\n+                try!(self.advance_left());\n             }\n             self.indent(0);\n             Ok(())\n           }\n-          Begin(b) => {\n+          Token::Begin(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -334,27 +331,27 @@ impl Printer {\n             } else { self.advance_right(); }\n             debug!(\"pp Begin({})/buffer ~[{},{}]\",\n                    b.offset, self.left, self.right);\n-            self.token[self.right] = t;\n+            self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n             let right = self.right;\n             self.scan_push(right);\n             Ok(())\n           }\n-          End => {\n+          Token::End => {\n             if self.scan_stack_empty {\n                 debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n-                self.print(t, 0)\n+                self.print(token, 0)\n             } else {\n                 debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t;\n+                self.token[self.right] = token;\n                 self.size[self.right] = -1;\n                 let right = self.right;\n                 self.scan_push(right);\n                 Ok(())\n             }\n           }\n-          Break(b) => {\n+          Token::Break(b) => {\n             if self.scan_stack_empty {\n                 self.left_total = 1;\n                 self.right_total = 1;\n@@ -366,21 +363,21 @@ impl Printer {\n             self.check_stack(0);\n             let right = self.right;\n             self.scan_push(right);\n-            self.token[self.right] = t;\n+            self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n             self.right_total += b.blank_space;\n             Ok(())\n           }\n-          String(ref s, len) => {\n+          Token::String(s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp String('{}')/print ~[{},{}]\",\n-                       *s, self.left, self.right);\n-                self.print(t.clone(), len)\n+                       s, self.left, self.right);\n+                self.print(Token::String(s, len), len)\n             } else {\n                 debug!(\"pp String('{}')/buffer ~[{},{}]\",\n-                       *s, self.left, self.right);\n+                       s, self.left, self.right);\n                 self.advance_right();\n-                self.token[self.right] = t.clone();\n+                self.token[self.right] = Token::String(s, len);\n                 self.size[self.right] = len;\n                 self.right_total += len;\n                 self.check_stream()\n@@ -401,9 +398,7 @@ impl Printer {\n                     self.size[scanned] = SIZE_INFINITY;\n                 }\n             }\n-            let left = self.token[self.left].clone();\n-            let left_size = self.size[self.left];\n-            try!(self.advance_left(left, left_size));\n+            try!(self.advance_left());\n             if self.left != self.right {\n                 try!(self.check_stream());\n             }\n@@ -450,42 +445,52 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self, x: Token, l: int) -> io::IoResult<()> {\n+    pub fn advance_left(&mut self) -> io::IoResult<()> {\n         debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n-               self.left, l);\n-        if l >= 0 {\n-            let ret = self.print(x.clone(), l);\n-            match x {\n-              Break(b) => self.left_total += b.blank_space,\n-              String(_, len) => {\n-                assert_eq!(len, l); self.left_total += len;\n-              }\n-              _ => ()\n-            }\n-            if self.left != self.right {\n-                self.left += 1u;\n-                self.left %= self.buf_len;\n-                let left = self.token[self.left].clone();\n-                let left_size = self.size[self.left];\n-                try!(self.advance_left(left, left_size));\n+               self.left, self.size[self.left]);\n+\n+        let mut left_size = self.size[self.left];\n+\n+        while left_size >= 0 {\n+            let left = self.token[self.left].clone();\n+\n+            let len = match left {\n+                Token::Break(b) => b.blank_space,\n+                Token::String(_, len) => {\n+                    assert_eq!(len, left_size);\n+                    len\n+                }\n+                _ => 0\n+            };\n+\n+            try!(self.print(left, left_size));\n+\n+            self.left_total += len;\n+\n+            if self.left == self.right {\n+                break;\n             }\n-            ret\n-        } else {\n-            Ok(())\n+\n+            self.left += 1u;\n+            self.left %= self.buf_len;\n+\n+            left_size = self.size[self.left];\n         }\n+\n+        Ok(())\n     }\n     pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n             match self.token[x] {\n-                Begin(_) => {\n+                Token::Begin(_) => {\n                     if k > 0 {\n                         let popped = self.scan_pop();\n                         self.size[popped] = self.size[x] + self.right_total;\n                         self.check_stack(k - 1);\n                     }\n                 }\n-                End => {\n+                Token::End => {\n                     // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n                     self.size[popped] = 1;\n@@ -520,7 +525,7 @@ impl Printer {\n         } else {\n             PrintStackElem {\n                 offset: 0,\n-                pbreak: Broken(Inconsistent)\n+                pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n             }\n         }\n     }\n@@ -531,56 +536,56 @@ impl Printer {\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, x: Token, l: int) -> io::IoResult<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), l,\n+    pub fn print(&mut self, token: Token, l: int) -> io::IoResult<()> {\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n                self.space);\n-        debug!(\"{}\", buf_str(self.token.clone(),\n-                             self.size.clone(),\n+        debug!(\"{}\", buf_str(&self.token[],\n+                             &self.size[],\n                              self.left,\n                              self.right,\n                              6));\n-        match x {\n-          Begin(b) => {\n+        match token {\n+          Token::Begin(b) => {\n             if l > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 debug!(\"print Begin -> push broken block at col {}\", col);\n                 self.print_stack.push(PrintStackElem {\n                     offset: col,\n-                    pbreak: Broken(b.breaks)\n+                    pbreak: PrintStackBreak::Broken(b.breaks)\n                 });\n             } else {\n                 debug!(\"print Begin -> push fitting block\");\n                 self.print_stack.push(PrintStackElem {\n                     offset: 0,\n-                    pbreak: Fits\n+                    pbreak: PrintStackBreak::Fits\n                 });\n             }\n             Ok(())\n           }\n-          End => {\n+          Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n-          Break(b) => {\n+          Token::Break(b) => {\n             let top = self.get_top();\n             match top.pbreak {\n-              Fits => {\n+              PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n                 Ok(())\n               }\n-              Broken(Consistent) => {\n+              PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n                 let ret = self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n                 ret\n               }\n-              Broken(Inconsistent) => {\n+              PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n@@ -597,14 +602,14 @@ impl Printer {\n               }\n             }\n           }\n-          String(s, len) => {\n+          Token::String(s, len) => {\n             debug!(\"print String({})\", s);\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n             self.print_str(&s[])\n           }\n-          Eof => {\n+          Token::Eof => {\n             // Eof should never get here.\n             panic!();\n           }\n@@ -616,41 +621,45 @@ impl Printer {\n //\n // \"raw box\"\n pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) -> io::IoResult<()> {\n-    p.pretty_print(Begin(BeginToken {\n+    p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as int,\n         breaks: b\n     }))\n }\n \n pub fn ibox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n-    rbox(p, indent, Inconsistent)\n+    rbox(p, indent, Breaks::Inconsistent)\n }\n \n pub fn cbox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n-    rbox(p, indent, Consistent)\n+    rbox(p, indent, Breaks::Consistent)\n }\n \n pub fn break_offset(p: &mut Printer, n: uint, off: int) -> io::IoResult<()> {\n-    p.pretty_print(Break(BreakToken {\n+    p.pretty_print(Token::Break(BreakToken {\n         offset: off,\n         blank_space: n as int\n     }))\n }\n \n-pub fn end(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(End) }\n+pub fn end(p: &mut Printer) -> io::IoResult<()> {\n+    p.pretty_print(Token::End)\n+}\n \n-pub fn eof(p: &mut Printer) -> io::IoResult<()> { p.pretty_print(Eof) }\n+pub fn eof(p: &mut Printer) -> io::IoResult<()> {\n+    p.pretty_print(Token::Eof)\n+}\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), wrd.len() as int))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as int))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n-    p.pretty_print(String(/* bad */ wrd.to_string(), 0))\n+    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {\n@@ -670,7 +679,9 @@ pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n }\n \n pub fn hardbreak_tok_offset(off: int) -> Token {\n-    Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n+    Token::Break(BreakToken {offset: off, blank_space: SIZE_INFINITY})\n }\n \n-pub fn hardbreak_tok() -> Token { return hardbreak_tok_offset(0); }\n+pub fn hardbreak_tok() -> Token {\n+    hardbreak_tok_offset(0)\n+}"}, {"sha": "5d76dc710060b591e4bed8764fc01ce9a9dfc9c7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 152, "deletions": 85, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/b1a7e34fc0b5e27891eec8920b063b9453d6a14f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1a7e34fc0b5e27891eec8920b063b9453d6a14f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b1a7e34fc0b5e27891eec8920b063b9453d6a14f", "patch": "@@ -25,7 +25,8 @@ use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n-use print::pp::{Breaks, Consistent, Inconsistent, eof};\n+use print::pp::{Breaks, eof};\n+use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n \n use std::{ascii, mem};\n@@ -459,7 +460,7 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n \n impl<'a> State<'a> {\n     pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.push(pp::Inconsistent);\n+        self.boxes.push(pp::Breaks::Inconsistent);\n         pp::ibox(&mut self.s, u)\n     }\n \n@@ -469,7 +470,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn cbox(&mut self, u: uint) -> IoResult<()> {\n-        self.boxes.push(pp::Consistent);\n+        self.boxes.push(pp::Breaks::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n@@ -531,11 +532,17 @@ impl<'a> State<'a> {\n     }\n \n     pub fn is_begin(&mut self) -> bool {\n-        match self.s.last_token() { pp::Begin(_) => true, _ => false }\n+        match self.s.last_token() {\n+            pp::Token::Begin(_) => true,\n+            _ => false,\n+        }\n     }\n \n     pub fn is_end(&mut self) -> bool {\n-        match self.s.last_token() { pp::End => true, _ => false }\n+        match self.s.last_token() {\n+            pp::Token::End => true,\n+            _ => false,\n+        }\n     }\n \n     // is this the beginning of a line?\n@@ -545,7 +552,7 @@ impl<'a> State<'a> {\n \n     pub fn in_cbox(&self) -> bool {\n         match self.boxes.last() {\n-            Some(&last_box) => last_box == pp::Consistent,\n+            Some(&last_box) => last_box == pp::Breaks::Consistent,\n             None => false\n         }\n     }\n@@ -1497,108 +1504,168 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n+    fn print_expr_box(&mut self,\n+                      place: &Option<P<ast::Expr>>,\n+                      expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, \"box\"));\n+        try!(word(&mut self.s, \"(\"));\n+        try!(place.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n+        try!(self.word_space(\")\"));\n+        self.print_expr(expr)\n+    }\n+\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.ibox(indent_unit));\n+        try!(word(&mut self.s, \"[\"));\n+        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        try!(word(&mut self.s, \"]\"));\n+        self.end()\n+    }\n+\n+    fn print_expr_repeat(&mut self,\n+                         element: &ast::Expr,\n+                         count: &ast::Expr) -> IoResult<()> {\n+        try!(self.ibox(indent_unit));\n+        try!(word(&mut self.s, \"[\"));\n+        try!(self.print_expr(element));\n+        try!(self.word_space(\";\"));\n+        try!(self.print_expr(count));\n+        try!(word(&mut self.s, \"]\"));\n+        self.end()\n+    }\n+\n+    fn print_expr_struct(&mut self,\n+                         path: &ast::Path,\n+                         fields: &[ast::Field],\n+                         wth: &Option<P<ast::Expr>>) -> IoResult<()> {\n+        try!(self.print_path(path, true));\n+        if !(fields.is_empty() && wth.is_none()) {\n+            try!(word(&mut self.s, \"{\"));\n+            try!(self.commasep_cmnt(\n+                Consistent,\n+                &fields[],\n+                |s, field| {\n+                    try!(s.ibox(indent_unit));\n+                    try!(s.print_ident(field.ident.node));\n+                    try!(s.word_space(\":\"));\n+                    try!(s.print_expr(&*field.expr));\n+                    s.end()\n+                },\n+                |f| f.span));\n+            match *wth {\n+                Some(ref expr) => {\n+                    try!(self.ibox(indent_unit));\n+                    if !fields.is_empty() {\n+                        try!(word(&mut self.s, \",\"));\n+                        try!(space(&mut self.s));\n+                    }\n+                    try!(word(&mut self.s, \"..\"));\n+                    try!(self.print_expr(&**expr));\n+                    try!(self.end());\n+                }\n+                _ => try!(word(&mut self.s, \",\")),\n+            }\n+            try!(word(&mut self.s, \"}\"));\n+        }\n+        Ok(())\n+    }\n+\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.popen());\n+        try!(self.commasep_exprs(Inconsistent, &exprs[]));\n+        if exprs.len() == 1 {\n+            try!(word(&mut self.s, \",\"));\n+        }\n+        self.pclose()\n+    }\n+\n+    fn print_expr_call(&mut self,\n+                       func: &ast::Expr,\n+                       args: &[P<ast::Expr>]) -> IoResult<()> {\n+        try!(self.print_expr_maybe_paren(func));\n+        self.print_call_post(args)\n+    }\n+\n+    fn print_expr_method_call(&mut self,\n+                              ident: ast::SpannedIdent,\n+                              tys: &[P<ast::Ty>],\n+                              args: &[P<ast::Expr>]) -> IoResult<()> {\n+        let base_args = args.slice_from(1);\n+        try!(self.print_expr(&*args[0]));\n+        try!(word(&mut self.s, \".\"));\n+        try!(self.print_ident(ident.node));\n+        if tys.len() > 0u {\n+            try!(word(&mut self.s, \"::<\"));\n+            try!(self.commasep(Inconsistent, tys,\n+                               |s, ty| s.print_type(&**ty)));\n+            try!(word(&mut self.s, \">\"));\n+        }\n+        self.print_call_post(base_args)\n+    }\n+\n+    fn print_expr_binary(&mut self,\n+                         op: ast::BinOp,\n+                         lhs: &ast::Expr,\n+                         rhs: &ast::Expr) -> IoResult<()> {\n+        try!(self.print_expr(lhs));\n+        try!(space(&mut self.s));\n+        try!(self.word_space(ast_util::binop_to_string(op)));\n+        self.print_expr(rhs)\n+    }\n+\n+    fn print_expr_unary(&mut self,\n+                        op: ast::UnOp,\n+                        expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, ast_util::unop_to_string(op)));\n+        self.print_expr_maybe_paren(expr)\n+    }\n+\n+    fn print_expr_addr_of(&mut self,\n+                          mutability: ast::Mutability,\n+                          expr: &ast::Expr) -> IoResult<()> {\n+        try!(word(&mut self.s, \"&\"));\n+        try!(self.print_mutability(mutability));\n+        self.print_expr_maybe_paren(expr)\n+    }\n+\n     pub fn print_expr(&mut self, expr: &ast::Expr) -> IoResult<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n         try!(self.ibox(indent_unit));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n-            ast::ExprBox(ref p, ref e) => {\n-                try!(word(&mut self.s, \"box\"));\n-                try!(word(&mut self.s, \"(\"));\n-                try!(p.as_ref().map_or(Ok(()), |e|self.print_expr(&**e)));\n-                try!(self.word_space(\")\"));\n-                try!(self.print_expr(&**e));\n+            ast::ExprBox(ref place, ref expr) => {\n+                try!(self.print_expr_box(place, &**expr));\n             }\n             ast::ExprVec(ref exprs) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n-                try!(word(&mut self.s, \"]\"));\n-                try!(self.end());\n+                try!(self.print_expr_vec(&exprs[]));\n             }\n-\n             ast::ExprRepeat(ref element, ref count) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**element));\n-                try!(self.word_space(\";\"));\n-                try!(self.print_expr(&**count));\n-                try!(word(&mut self.s, \"]\"));\n-                try!(self.end());\n+                try!(self.print_expr_repeat(&**element, &**count));\n             }\n-\n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n-                try!(self.print_path(path, true));\n-                if !(fields.is_empty() && wth.is_none()) {\n-                    try!(word(&mut self.s, \"{\"));\n-                    try!(self.commasep_cmnt(\n-                        Consistent,\n-                        &fields[],\n-                        |s, field| {\n-                            try!(s.ibox(indent_unit));\n-                            try!(s.print_ident(field.ident.node));\n-                            try!(s.word_space(\":\"));\n-                            try!(s.print_expr(&*field.expr));\n-                            s.end()\n-                        },\n-                        |f| f.span));\n-                    match *wth {\n-                        Some(ref expr) => {\n-                            try!(self.ibox(indent_unit));\n-                            if !fields.is_empty() {\n-                                try!(word(&mut self.s, \",\"));\n-                                try!(space(&mut self.s));\n-                            }\n-                            try!(word(&mut self.s, \"..\"));\n-                            try!(self.print_expr(&**expr));\n-                            try!(self.end());\n-                        }\n-                        _ => try!(word(&mut self.s, \",\")),\n-                    }\n-                    try!(word(&mut self.s, \"}\"));\n-                }\n+                try!(self.print_expr_struct(path, &fields[], wth));\n             }\n             ast::ExprTup(ref exprs) => {\n-                try!(self.popen());\n-                try!(self.commasep_exprs(Inconsistent, &exprs[]));\n-                if exprs.len() == 1 {\n-                    try!(word(&mut self.s, \",\"));\n-                }\n-                try!(self.pclose());\n+                try!(self.print_expr_tup(&exprs[]));\n             }\n             ast::ExprCall(ref func, ref args) => {\n-                try!(self.print_expr_maybe_paren(&**func));\n-                try!(self.print_call_post(&args[]));\n+                try!(self.print_expr_call(&**func, &args[]));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n-                let base_args = args.slice_from(1);\n-                try!(self.print_expr(&*args[0]));\n-                try!(word(&mut self.s, \".\"));\n-                try!(self.print_ident(ident.node));\n-                if tys.len() > 0u {\n-                    try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(Inconsistent, &tys[],\n-                                       |s, ty| s.print_type(&**ty)));\n-                    try!(word(&mut self.s, \">\"));\n-                }\n-                try!(self.print_call_post(base_args));\n+                try!(self.print_expr_method_call(ident, &tys[], &args[]));\n             }\n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n-                try!(space(&mut self.s));\n-                try!(self.word_space(ast_util::binop_to_string(op)));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n             }\n             ast::ExprUnary(op, ref expr) => {\n-                try!(word(&mut self.s, ast_util::unop_to_string(op)));\n-                try!(self.print_expr_maybe_paren(&**expr));\n+                try!(self.print_expr_unary(op, &**expr));\n             }\n             ast::ExprAddrOf(m, ref expr) => {\n-                try!(word(&mut self.s, \"&\"));\n-                try!(self.print_mutability(m));\n-                try!(self.print_expr_maybe_paren(&**expr));\n+                try!(self.print_expr_addr_of(m, &**expr));\n+            }\n+            ast::ExprLit(ref lit) => {\n+                try!(self.print_literal(&**lit));\n             }\n-            ast::ExprLit(ref lit) => try!(self.print_literal(&**lit)),\n             ast::ExprCast(ref expr, ref ty) => {\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n@@ -2891,7 +2958,7 @@ impl<'a> State<'a> {\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let is_semi = match self.s.last_token() {\n-                    pp::String(s, _) => \";\" == s,\n+                    pp::Token::String(s, _) => \";\" == s,\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {"}]}