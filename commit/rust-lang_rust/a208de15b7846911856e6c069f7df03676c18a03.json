{"sha": "a208de15b7846911856e6c069f7df03676c18a03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDhkZTE1Yjc4NDY5MTE4NTZlNmMwNjlmN2RmMDM2NzZjMThhMDM=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-06T22:38:20Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2020-04-07T12:12:08Z"}, "message": "PR feedback implementation", "tree": {"sha": "9622890aebe6e35ad2e813b44dc8d6fdeff0559b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9622890aebe6e35ad2e813b44dc8d6fdeff0559b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a208de15b7846911856e6c069f7df03676c18a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a208de15b7846911856e6c069f7df03676c18a03", "html_url": "https://github.com/rust-lang/rust/commit/a208de15b7846911856e6c069f7df03676c18a03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a208de15b7846911856e6c069f7df03676c18a03/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da6752d5f9a18ba58adb6a2e72d30a83532ec8a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/da6752d5f9a18ba58adb6a2e72d30a83532ec8a6", "html_url": "https://github.com/rust-lang/rust/commit/da6752d5f9a18ba58adb6a2e72d30a83532ec8a6"}], "stats": {"total": 425, "additions": 331, "deletions": 94}, "files": [{"sha": "f29a25505b98bfc863c8083b28992b5bab0ce498", "filename": "crates/ra_hir_ty/src/_match.rs", "status": "modified", "additions": 331, "deletions": 94, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/a208de15b7846911856e6c069f7df03676c18a03/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a208de15b7846911856e6c069f7df03676c18a03/crates%2Fra_hir_ty%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2F_match.rs?ref=a208de15b7846911856e6c069f7df03676c18a03", "patch": "@@ -2,7 +2,191 @@\n //! for match arms.\n //!\n //! It is modeled on the rustc module `librustc_mir_build::hair::pattern::_match`, which\n-//! contains very detailed documentation about the algorithms used here.\n+//! contains very detailed documentation about the algorithms used here. I've duplicated\n+//! most of that documentation below.\n+//!\n+//! This file includes the logic for exhaustiveness and usefulness checking for\n+//! pattern-matching. Specifically, given a list of patterns for a type, we can\n+//! tell whether:\n+//! (a) the patterns cover every possible constructor for the type [exhaustiveness]\n+//! (b) each pattern is necessary [usefulness]\n+//!\n+//! The algorithm implemented here is a modified version of the one described in:\n+//! http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//! However, to save future implementors from reading the original paper, we\n+//! summarise the algorithm here to hopefully save time and be a little clearer\n+//! (without being so rigorous).\n+//!\n+//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n+//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n+//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n+//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n+//! uncovered values of the type).\n+//!\n+//! If we have this predicate, then we can easily compute both exhaustiveness of an\n+//! entire set of patterns and the individual usefulness of each one.\n+//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n+//! match doesn't increase the number of values we're matching)\n+//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n+//! pattern to those that have come before it doesn't increase the number of values\n+//! we're matching).\n+//!\n+//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n+//! but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n+//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n+//! new pattern `p`.\n+//!\n+//! For example, say we have the following:\n+//! ```\n+//!     // x: (Option<bool>, Result<()>)\n+//!     match x {\n+//!         (Some(true), _) => {}\n+//!         (None, Err(())) => {}\n+//!         (None, Err(_)) => {}\n+//!     }\n+//! ```\n+//! Here, the matrix `P` starts as:\n+//! [\n+//!     [(Some(true), _)],\n+//!     [(None, Err(()))],\n+//!     [(None, Err(_))],\n+//! ]\n+//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n+//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n+//! all the values it covers are already covered by row 2.\n+//!\n+//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n+//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n+//! To match the paper, the top of the stack is at the beginning / on the left.\n+//!\n+//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n+//!     1. We can pop a given constructor off the top of a stack. This operation is called\n+//!        `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n+//!        `None`) and `p` a pattern-stack.\n+//!        If the pattern on top of the stack can cover `c`, this removes the constructor and\n+//!        pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n+//!        Otherwise the pattern-stack is discarded.\n+//!        This essentially filters those pattern-stacks whose top covers the constructor `c` and\n+//!        discards the others.\n+//!\n+//!        For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n+//!        pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n+//!        `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n+//!        nothing back.\n+//!\n+//!        This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n+//!        on top of the stack, and we have four cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We\n+//!                  push onto the stack the arguments of this constructor, and return the result:\n+//!                     r_1, .., r_a, p_2, .., p_n\n+//!             1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and\n+//!                  return nothing.\n+//!             1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n+//!                  arguments (its arity), and return the resulting stack:\n+//!                     _, .., _, p_2, .., p_n\n+//!             1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!                  stack:\n+//!                     S(c, (r_1, p_2, .., p_n))\n+//!                     S(c, (r_2, p_2, .., p_n))\n+//!\n+//!     2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n+//!        a pattern-stack.\n+//!        This is used when we know there are missing constructor cases, but there might be\n+//!        existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n+//!        all its *other* components.\n+//!\n+//!        It is computed as follows. We look at the pattern `p_1` on top of the stack,\n+//!        and we have three cases:\n+//!             1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!             1.2. `p_1 = _`. We return the rest of the stack:\n+//!                     p_2, .., p_n\n+//!             1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!               stack.\n+//!                     D((r_1, p_2, .., p_n))\n+//!                     D((r_2, p_2, .., p_n))\n+//!\n+//!     Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n+//!     exhaustive integer matching rules, so they're written here for posterity.\n+//!\n+//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n+//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n+//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n+//!\n+//!\n+//! The algorithm for computing `U`\n+//! -------------------------------\n+//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n+//! That means we're going to check the components from left-to-right, so the algorithm\n+//! operates principally on the first component of the matrix and new pattern-stack `p`.\n+//! This algorithm is realised in the `is_useful` function.\n+//!\n+//! Base case. (`n = 0`, i.e., an empty tuple pattern)\n+//!     - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`),\n+//!       then `U(P, p)` is false.\n+//!     - Otherwise, `P` must be empty, so `U(P, p)` is true.\n+//!\n+//! Inductive step. (`n > 0`, i.e., whether there's at least one column\n+//!                  [which may then be expanded into further columns later])\n+//!     We're going to match on the top of the new pattern-stack, `p_1`.\n+//!         - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n+//!           Then, the usefulness of `p_1` can be reduced to whether it is useful when\n+//!           we ignore all the patterns in the first column of `P` that involve other constructors.\n+//!           This is where `S(c, P)` comes in:\n+//!           `U(P, p) := U(S(c, P), S(c, p))`\n+//!           This special case is handled in `is_useful_specialized`.\n+//!\n+//!           For example, if `P` is:\n+//!           [\n+//!               [Some(true), _],\n+//!               [None, 0],\n+//!           ]\n+//!           and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n+//!           matches values that row 2 doesn't. For row 1 however, we need to dig into the\n+//!           arguments of `Some` to know whether some new value is covered. So we compute\n+//!           `U([[true, _]], [false, 0])`.\n+//!\n+//!         - If `p_1 == _`, then we look at the list of constructors that appear in the first\n+//!               component of the rows of `P`:\n+//!             + If there are some constructors that aren't present, then we might think that the\n+//!               wildcard `_` is useful, since it covers those constructors that weren't covered\n+//!               before.\n+//!               That's almost correct, but only works if there were no wildcards in those first\n+//!               components. So we need to check that `p` is useful with respect to the rows that\n+//!               start with a wildcard, if there are any. This is where `D` comes in:\n+//!               `U(P, p) := U(D(P), D(p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [_, true, _],\n+//!                   [None, false, 1],\n+//!               ]\n+//!               and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n+//!               only had row 2, we'd know that `p` is useful. However row 1 starts with a\n+//!               wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n+//!\n+//!             + Otherwise, all possible constructors (for the relevant type) are present. In this\n+//!               case we must check whether the wildcard pattern covers any unmatched value. For\n+//!               that, we can think of the `_` pattern as a big OR-pattern that covers all\n+//!               possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n+//!               example. The wildcard pattern is useful in this case if it is useful when\n+//!               specialized to one of the possible constructors. So we compute:\n+//!               `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n+//!\n+//!               For example, if `P` is:\n+//!               [\n+//!                   [Some(true), _],\n+//!                   [None, false],\n+//!               ]\n+//!               and `p` is [_, false], both `None` and `Some` constructors appear in the first\n+//!               components of `P`. We will therefore try popping both constructors in turn: we\n+//!               compute U([[true, _]], [_, false]) for the `Some` constructor, and U([[false]],\n+//!               [false]) for the `None` constructor. The first case returns true, so we know that\n+//!               `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n+//!               before.\n+//!\n+//!         - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n+//!           `U(P, p) := U(P, (r_1, p_2, .., p_n))\n+//!                    || U(P, (r_2, p_2, .., p_n))`\n use std::sync::Arc;\n \n use smallvec::{smallvec, SmallVec};\n@@ -134,16 +318,26 @@ impl PatStack {\n     ) -> MatchCheckResult<Option<PatStack>> {\n         let result = match (self.head().as_pat(cx), constructor) {\n             (Pat::Tuple(ref pat_ids), Constructor::Tuple { arity }) => {\n-                if pat_ids.len() != *arity {\n-                    None\n-                } else {\n-                    Some(self.replace_head_with(pat_ids))\n+                debug_assert_eq!(\n+                    pat_ids.len(),\n+                    *arity,\n+                    \"we type check before calling this code, so we should never hit this case\",\n+                );\n+\n+                Some(self.replace_head_with(pat_ids))\n+            }\n+            (Pat::Lit(lit_expr), Constructor::Bool(constructor_val)) => {\n+                match cx.body.exprs[lit_expr] {\n+                    Expr::Literal(Literal::Bool(pat_val)) if *constructor_val == pat_val => {\n+                        Some(self.to_tail())\n+                    }\n+                    // it was a bool but the value doesn't match\n+                    Expr::Literal(Literal::Bool(_)) => None,\n+                    // perhaps this is actually unreachable given we have\n+                    // already checked that these match arms have the appropriate type?\n+                    _ => return Err(MatchCheckNotImplemented),\n                 }\n             }\n-            (Pat::Lit(_), Constructor::Bool(_)) => {\n-                // for now we only support bool literals\n-                Some(self.to_tail())\n-            }\n             (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n             (Pat::Path(_), Constructor::Enum(constructor)) => {\n                 // enums with no associated data become `Pat::Path`\n@@ -162,7 +356,7 @@ impl PatStack {\n                     Some(self.replace_head_with(pat_ids))\n                 }\n             }\n-            (Pat::Or(_), _) => unreachable!(\"we desugar or patterns so this should never happen\"),\n+            (Pat::Or(_), _) => return Err(MatchCheckNotImplemented),\n             (_, _) => return Err(MatchCheckNotImplemented),\n         };\n \n@@ -186,19 +380,8 @@ impl PatStack {\n         );\n \n         let mut patterns: PatStackInner = smallvec![];\n-        let arity = match constructor {\n-            Constructor::Bool(_) => 0,\n-            Constructor::Tuple { arity } => *arity,\n-            Constructor::Enum(e) => {\n-                match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n-                    VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n-                    VariantData::Unit => 0,\n-                    _ => return Err(MatchCheckNotImplemented),\n-                }\n-            }\n-        };\n \n-        for _ in 0..arity {\n+        for _ in 0..constructor.arity(cx)? {\n             patterns.push(PatIdOrWild::Wild);\n         }\n \n@@ -368,46 +551,23 @@ pub(crate) fn is_useful(\n                 // constructors are covered (`Some`/`None`), so we need\n                 // to perform specialization to see that our wildcard will cover\n                 // the `Some(false)` case.\n-                let mut constructor = None;\n-                for pat in matrix.heads() {\n-                    if let Some(c) = pat_constructor(cx, pat)? {\n-                        constructor = Some(c);\n-                        break;\n-                    }\n+                //\n+                // Here we create a constructor for each variant and then check\n+                // usefulness after specializing for that constructor.\n+                let mut found_unimplemented = false;\n+                for constructor in constructor.all_constructors(cx) {\n+                    let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n+                    let v = v.expand_wildcard(&cx, &constructor)?;\n+\n+                    match is_useful(&cx, &matrix, &v) {\n+                        Ok(Usefulness::Useful) => return Ok(Usefulness::Useful),\n+                        Ok(Usefulness::NotUseful) => continue,\n+                        _ => found_unimplemented = true,\n+                    };\n                 }\n \n-                if let Some(constructor) = constructor {\n-                    if let Constructor::Enum(e) = constructor {\n-                        // For enums we handle each variant as a distinct constructor, so\n-                        // here we create a constructor for each variant and then check\n-                        // usefulness after specializing for that constructor.\n-                        let mut found_unimplemented = false;\n-                        for constructor in\n-                            cx.db.enum_data(e.parent).variants.iter().map(|(local_id, _)| {\n-                                Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n-                            })\n-                        {\n-                            let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n-                            let v = v.expand_wildcard(&cx, &constructor)?;\n-\n-                            match is_useful(&cx, &matrix, &v) {\n-                                Ok(Usefulness::Useful) => return Ok(Usefulness::Useful),\n-                                Ok(Usefulness::NotUseful) => continue,\n-                                _ => found_unimplemented = true,\n-                            };\n-                        }\n-\n-                        if found_unimplemented {\n-                            Err(MatchCheckNotImplemented)\n-                        } else {\n-                            Ok(Usefulness::NotUseful)\n-                        }\n-                    } else {\n-                        let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n-                        let v = v.expand_wildcard(&cx, &constructor)?;\n-\n-                        is_useful(&cx, &matrix, &v)\n-                    }\n+                if found_unimplemented {\n+                    Err(MatchCheckNotImplemented)\n                 } else {\n                     Ok(Usefulness::NotUseful)\n                 }\n@@ -425,7 +585,7 @@ pub(crate) fn is_useful(\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, Copy)]\n /// Similar to TypeCtor, but includes additional information about the specific\n /// value being instantiated. For example, TypeCtor::Bool doesn't contain the\n /// boolean value.\n@@ -435,6 +595,40 @@ enum Constructor {\n     Enum(EnumVariantId),\n }\n \n+impl Constructor {\n+    fn arity(&self, cx: &MatchCheckCtx) -> MatchCheckResult<usize> {\n+        let arity = match self {\n+            Constructor::Bool(_) => 0,\n+            Constructor::Tuple { arity } => *arity,\n+            Constructor::Enum(e) => {\n+                match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n+                    VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n+                    VariantData::Unit => 0,\n+                    _ => return Err(MatchCheckNotImplemented),\n+                }\n+            }\n+        };\n+\n+        Ok(arity)\n+    }\n+\n+    fn all_constructors(&self, cx: &MatchCheckCtx) -> Vec<Constructor> {\n+        match self {\n+            Constructor::Bool(_) => vec![Constructor::Bool(true), Constructor::Bool(false)],\n+            Constructor::Tuple { .. } => vec![*self],\n+            Constructor::Enum(e) => cx\n+                .db\n+                .enum_data(e.parent)\n+                .variants\n+                .iter()\n+                .map(|(local_id, _)| {\n+                    Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n+                })\n+                .collect(),\n+        }\n+    }\n+}\n+\n /// Returns the constructor for the given pattern. Should only return None\n /// in the case of a Wild pattern.\n fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n@@ -501,14 +695,7 @@ fn all_constructors_covered(\n }\n \n fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: EnumVariantId) -> bool {\n-    if let Some(VariantId::EnumVariantId(pat_variant_id)) =\n-        cx.infer.variant_resolution_for_pat(pat_id)\n-    {\n-        if pat_variant_id.local_id == enum_variant_id.local_id {\n-            return true;\n-        }\n-    }\n-    false\n+    Some(enum_variant_id.into()) == cx.infer.variant_resolution_for_pat(pat_id)\n }\n \n #[cfg(test)]\n@@ -522,10 +709,10 @@ mod tests {\n         TestDB::with_single_file(content).0.diagnostics().0\n     }\n \n-    pub(super) fn check_diagnostic_with_no_fix(content: &str) {\n+    pub(super) fn check_diagnostic(content: &str) {\n         let diagnostic_count = TestDB::with_single_file(content).0.diagnostics().1;\n \n-        assert_eq!(1, diagnostic_count, \"no diagnotic reported\");\n+        assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n     }\n \n     pub(super) fn check_no_diagnostic(content: &str) {\n@@ -558,7 +745,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -596,7 +783,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -621,7 +808,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -646,7 +833,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -659,7 +846,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -685,7 +872,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -698,7 +885,37 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_missing_arm() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (false, true) => {},\n+                    (false, false) => {},\n+                    (true, false) => {},\n+                }\n+            }\n+        \";\n+\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn tuple_of_bools_with_wilds() {\n+        let content = r\"\n+            fn test_fn() {\n+                match (false, true) {\n+                    (false, _) => {},\n+                    (true, false) => {},\n+                    (_, true) => {},\n+                }\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n     }\n \n     #[test]\n@@ -727,7 +944,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -754,7 +971,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -767,7 +984,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -796,7 +1013,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -827,7 +1044,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -844,7 +1061,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -879,7 +1096,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -913,7 +1130,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -931,7 +1148,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -1004,7 +1221,7 @@ mod tests {\n             }\n         \";\n \n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -1089,7 +1306,7 @@ mod tests {\n         \";\n \n         // Match arms with the incorrect type are filtered out.\n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n     }\n \n     #[test]\n@@ -1104,7 +1321,23 @@ mod tests {\n         \";\n \n         // Match arms with the incorrect type are filtered out.\n-        check_diagnostic_with_no_fix(content);\n+        check_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn enum_not_in_scope() {\n+        let content = r\"\n+            fn test_fn() {\n+                match Foo::Bar {\n+                    Foo::Baz => (),\n+                }\n+            }\n+        \";\n+\n+        // The enum is not in scope so we don't perform exhaustiveness\n+        // checking, but we want to be sure we don't panic here (and\n+        // we don't create a diagnostic).\n+        check_no_diagnostic(content);\n     }\n }\n \n@@ -1158,17 +1391,21 @@ mod false_negatives {\n     }\n \n     #[test]\n-    fn enum_not_in_scope() {\n+    fn internal_or() {\n         let content = r\"\n             fn test_fn() {\n-                match Foo::Bar {\n-                    Foo::Baz => (),\n+                enum Either {\n+                    A(bool),\n+                    B,\n+                }\n+                match Either::B {\n+                    Either::A(true | false) => (),\n                 }\n             }\n         \";\n \n         // This is a false negative.\n-        // The enum is not in scope so we don't perform exhaustiveness checking.\n+        // We do not currently handle patterns with internal `or`s.\n         check_no_diagnostic(content);\n     }\n }"}]}