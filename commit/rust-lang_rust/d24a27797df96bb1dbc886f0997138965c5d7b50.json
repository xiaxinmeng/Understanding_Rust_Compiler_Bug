{"sha": "d24a27797df96bb1dbc886f0997138965c5d7b50", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNGEyNzc5N2RmOTZiYjFkYmM4ODZmMDk5NzEzODk2NWM1ZDdiNTA=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-05T01:37:10Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:30Z"}, "message": "refactor: moving SpecFromIter into spec_from_iter.rs", "tree": {"sha": "0f969058f8b2e29f283dcc0a96b72a5de800f5b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f969058f8b2e29f283dcc0a96b72a5de800f5b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d24a27797df96bb1dbc886f0997138965c5d7b50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d24a27797df96bb1dbc886f0997138965c5d7b50", "html_url": "https://github.com/rust-lang/rust/commit/d24a27797df96bb1dbc886f0997138965c5d7b50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d24a27797df96bb1dbc886f0997138965c5d7b50/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56d82b3dcc73e227dd2fa4dd4a8ef8d96ce75805", "url": "https://api.github.com/repos/rust-lang/rust/commits/56d82b3dcc73e227dd2fa4dd4a8ef8d96ce75805", "html_url": "https://github.com/rust-lang/rust/commit/56d82b3dcc73e227dd2fa4dd4a8ef8d96ce75805"}], "stats": {"total": 194, "additions": 102, "deletions": 92}, "files": [{"sha": "dfb837d54f5f77a2b95fa9edad7fa23ad8b30eec", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 4, "deletions": 92, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d24a27797df96bb1dbc886f0997138965c5d7b50/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d24a27797df96bb1dbc886f0997138965c5d7b50/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=d24a27797df96bb1dbc886f0997138965c5d7b50", "patch": "@@ -121,6 +121,10 @@ use self::spec_from_iter_nested::SpecFromIterNested;\n \n mod spec_from_iter_nested;\n \n+use self::spec_from_iter::SpecFromIter;\n+\n+mod spec_from_iter;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -2156,98 +2160,6 @@ impl<T, A: Allocator> Extend<T> for Vec<T, A> {\n     }\n }\n \n-/// Specialization trait used for Vec::from_iter\n-///\n-/// ## The delegation graph:\n-///\n-/// ```text\n-/// +-------------+\n-/// |FromIterator |\n-/// +-+-----------+\n-///   |\n-///   v\n-/// +-+-------------------------------+  +---------------------+\n-/// |SpecFromIter                  +---->+SpecFromIterNested   |\n-/// |where I:                      |  |  |where I:             |\n-/// |  Iterator (default)----------+  |  |  Iterator (default) |\n-/// |  vec::IntoIter               |  |  |  TrustedLen         |\n-/// |  SourceIterMarker---fallback-+  |  |                     |\n-/// |  slice::Iter                    |  |                     |\n-/// |  Iterator<Item = &Clone>        |  +---------------------+\n-/// +---------------------------------+\n-/// ```\n-trait SpecFromIter<T, I> {\n-    fn from_iter(iter: I) -> Self;\n-}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T>,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIterNested::from_iter(iterator)\n-    }\n-}\n-\n-impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n-    fn from_iter(iterator: IntoIter<T>) -> Self {\n-        // A common case is passing a vector into a function which immediately\n-        // re-collects into a vector. We can short circuit this if the IntoIter\n-        // has not been advanced at all.\n-        // When it has been advanced We can also reuse the memory and move the data to the front.\n-        // But we only do so when the resulting Vec wouldn't have more unused capacity\n-        // than creating it through the generic FromIterator implementation would. That limitation\n-        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n-        // But it is a conservative choice.\n-        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n-        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n-            unsafe {\n-                let it = ManuallyDrop::new(iterator);\n-                if has_advanced {\n-                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n-                }\n-                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n-            }\n-        }\n-\n-        let mut vec = Vec::new();\n-        // must delegate to spec_extend() since extend() itself delegates\n-        // to spec_from for empty Vecs\n-        vec.spec_extend(iterator);\n-        vec\n-    }\n-}\n-\n-impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecFromIter::from_iter(iterator.cloned())\n-    }\n-}\n-\n-// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n-// must take more steps to reason about the final capacity + length\n-// and thus do more work. `to_vec()` directly allocates the correct amount\n-// and fills it exactly.\n-impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n-    #[cfg(not(test))]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        iterator.as_slice().to_vec()\n-    }\n-\n-    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n-    // required for this method definition, is not available. Instead use the\n-    // `slice::to_vec`  function which is only available with cfg(test)\n-    // NB see the slice::hack module in slice.rs for more information\n-    #[cfg(test)]\n-    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n-        crate::slice::to_vec(iterator.as_slice(), Global)\n-    }\n-}\n-\n // Specialization trait used for Vec::extend\n trait SpecExtend<T, I> {\n     fn spec_extend(&mut self, iter: I);"}, {"sha": "bf07fc97f8943195a3f13005cf18f722183896ef", "filename": "library/alloc/src/vec/spec_from_iter.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d24a27797df96bb1dbc886f0997138965c5d7b50/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d24a27797df96bb1dbc886f0997138965c5d7b50/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fspec_from_iter.rs?ref=d24a27797df96bb1dbc886f0997138965c5d7b50", "patch": "@@ -0,0 +1,98 @@\n+use crate::alloc::Global;\n+use core::mem::{ManuallyDrop};\n+use core::ptr::{self};\n+use core::slice::{self};\n+\n+use super::{Vec, IntoIter, SpecFromIterNested, SpecExtend};\n+\n+/// Specialization trait used for Vec::from_iter\n+///\n+/// ## The delegation graph:\n+///\n+/// ```text\n+/// +-------------+\n+/// |FromIterator |\n+/// +-+-----------+\n+///   |\n+///   v\n+/// +-+-------------------------------+  +---------------------+\n+/// |SpecFromIter                  +---->+SpecFromIterNested   |\n+/// |where I:                      |  |  |where I:             |\n+/// |  Iterator (default)----------+  |  |  Iterator (default) |\n+/// |  vec::IntoIter               |  |  |  TrustedLen         |\n+/// |  SourceIterMarker---fallback-+  |  |                     |\n+/// |  slice::Iter                    |  |                     |\n+/// |  Iterator<Item = &Clone>        |  +---------------------+\n+/// +---------------------------------+\n+/// ```\n+pub(super) trait SpecFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+    where\n+        I: Iterator<Item = T>,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIterNested::from_iter(iterator)\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n+    fn from_iter(iterator: IntoIter<T>) -> Self {\n+        // A common case is passing a vector into a function which immediately\n+        // re-collects into a vector. We can short circuit this if the IntoIter\n+        // has not been advanced at all.\n+        // When it has been advanced We can also reuse the memory and move the data to the front.\n+        // But we only do so when the resulting Vec wouldn't have more unused capacity\n+        // than creating it through the generic FromIterator implementation would. That limitation\n+        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n+        // But it is a conservative choice.\n+        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n+        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n+            unsafe {\n+                let it = ManuallyDrop::new(iterator);\n+                if has_advanced {\n+                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n+                }\n+                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n+            }\n+        }\n+\n+        let mut vec = Vec::new();\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vec.spec_extend(iterator);\n+        vec\n+    }\n+}\n+\n+impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n+    where\n+        I: Iterator<Item = &'a T>,\n+        T: Clone,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIter::from_iter(iterator.cloned())\n+    }\n+}\n+\n+// This utilizes `iterator.as_slice().to_vec()` since spec_extend\n+// must take more steps to reason about the final capacity + length\n+// and thus do more work. `to_vec()` directly allocates the correct amount\n+// and fills it exactly.\n+impl<'a, T: 'a + Clone> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T> {\n+    #[cfg(not(test))]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        iterator.as_slice().to_vec()\n+    }\n+\n+    // HACK(japaric): with cfg(test) the inherent `[T]::to_vec` method, which is\n+    // required for this method definition, is not available. Instead use the\n+    // `slice::to_vec`  function which is only available with cfg(test)\n+    // NB see the slice::hack module in slice.rs for more information\n+    #[cfg(test)]\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        crate::slice::to_vec(iterator.as_slice(), Global)\n+    }\n+}"}]}