{"sha": "3d1d345f8f9badc83bad702b83ecca5feb85691f", "node_id": "C_kwDOAAsO6NoAKDNkMWQzNDVmOGY5YmFkYzgzYmFkNzAyYjgzZWNjYTVmZWI4NTY5MWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T10:04:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-22T10:04:08Z"}, "message": "Auto merge of #2255 - dtolnay-contrib:rustfmt7, r=oli-obk\n\nFormat tests with rustfmt (288-299 of 299)\n\nExtracted from #2097.\n\nI'll make a separate PR to enable checking the `tests` directory's formatting in CI. I'll need to rebase that after both this and #2254 have landed, and if any new non-rustfmt-formatted files appear in the meantime, we can include formatting those in the same PR that enables the CI.", "tree": {"sha": "f2fb089473dacf9e5988bc95584b61bbc0818062", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2fb089473dacf9e5988bc95584b61bbc0818062"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d1d345f8f9badc83bad702b83ecca5feb85691f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d1d345f8f9badc83bad702b83ecca5feb85691f", "html_url": "https://github.com/rust-lang/rust/commit/3d1d345f8f9badc83bad702b83ecca5feb85691f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d1d345f8f9badc83bad702b83ecca5feb85691f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6641963afe6de73650551111ee399df74ff55db", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6641963afe6de73650551111ee399df74ff55db", "html_url": "https://github.com/rust-lang/rust/commit/f6641963afe6de73650551111ee399df74ff55db"}, {"sha": "274085cebdbbe01522818c0b1e5f1f00af97ed9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/274085cebdbbe01522818c0b1e5f1f00af97ed9d", "html_url": "https://github.com/rust-lang/rust/commit/274085cebdbbe01522818c0b1e5f1f00af97ed9d"}], "stats": {"total": 349, "additions": 190, "deletions": 159}, "files": [{"sha": "730dd87cbb10f8d5a830cf34fcb0292fb6401bea", "filename": "tests/fail/unaligned_pointers/dyn_alignment.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -6,15 +6,18 @@\n struct MuchAlign;\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    // Try many times as this might work by chance.\n+    for _ in 0..10 {\n         let buf = [0u32; 256];\n         // `buf` is sufficiently aligned for `layout.align` on a `dyn Debug`, but not\n         // for the actual alignment required by `MuchAlign`.\n         // We craft a wide reference `&dyn Debug` with the vtable for `MuchAlign`. That should be UB,\n         // as the reference is not aligned to its dynamic alignment requirements.\n         let mut ptr = &MuchAlign as &dyn std::fmt::Debug;\n         // Overwrite the data part of `ptr` so it points to `buf`.\n-        unsafe { (&mut ptr as *mut _ as *mut *const u8).write(&buf as *const _ as *const u8); }\n+        unsafe {\n+            (&mut ptr as *mut _ as *mut *const u8).write(&buf as *const _ as *const u8);\n+        }\n         // Re-borrow that. This should be UB.\n         let _ptr = &*ptr; //~ERROR alignment 256 is required\n     }"}, {"sha": "c42f0e27aeada17718b7c8d0d5d96681f2792707", "filename": "tests/fail/unaligned_pointers/reference_to_packed.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -10,11 +10,9 @@ struct Foo {\n }\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n-        let foo = Foo {\n-            x: 42,\n-            y: 99,\n-        };\n+    // Try many times as this might work by chance.\n+    for _ in 0..10 {\n+        let foo = Foo { x: 42, y: 99 };\n         let p = &foo.x;\n         let i = *p; //~ERROR alignment 4 is required\n     }"}, {"sha": "7d192e5d3928b36ff0861b77226817c323a75d75", "filename": "tests/fail/unaligned_pointers/unaligned_ptr1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr1.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -2,7 +2,8 @@\n // compile-flags: -Zmiri-disable-validation -Zmiri-disable-stacked-borrows\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    // Try many times as this might work by chance.\n+    for _ in 0..10 {\n         let x = [2u16, 3, 4]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const u32;\n         // This must fail because alignment is violated: the allocation's base is not sufficiently aligned."}, {"sha": "748a31681a780560f1456a8ca1c733f13f8c6a2a", "filename": "tests/fail/unaligned_pointers/unaligned_ptr3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -2,7 +2,8 @@\n // compile-flags: -Zmiri-disable-validation -Zmiri-disable-stacked-borrows\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    // Try many times as this might work by chance.\n+    for _ in 0..10 {\n         let x = [2u16, 3, 4, 5]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const *const u8; // cast to ptr-to-ptr, so that we load a ptr\n         // This must fail because alignment is violated. Test specifically for loading pointers,"}, {"sha": "d01cabfa31cc85f24582a994f7a23b05129997cd", "filename": "tests/fail/unaligned_pointers/unaligned_ptr4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -4,7 +4,9 @@\n fn main() {\n     // Make sure we notice when a u16 is loaded at offset 1 into a u8 allocation.\n     // (This would be missed if u8 allocations are *always* at odd addresses.)\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    //\n+    // Try many times as this might work by chance.\n+    for _ in 0..10 {\n         let x = [0u8; 4];\n         let ptr = x.as_ptr().wrapping_offset(1).cast::<u16>();\n         let _val = unsafe { *ptr }; //~ERROR but alignment"}, {"sha": "dff92d56d70e87202c368f84748bdca35a3ba72d", "filename": "tests/fail/unaligned_pointers/unaligned_ptr_addr_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_addr_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_addr_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_addr_of.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -3,7 +3,8 @@\n use std::ptr;\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    // Try many times as this might work by chance.\n+    for _ in 0..10 {\n         let x = [2u16, 3, 4]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const u32;\n         // This must fail because alignment is violated: the allocation's base is not sufficiently aligned."}, {"sha": "8252ea83c870c60df3d95d22261aba979c44ae9c", "filename": "tests/fail/unaligned_pointers/unaligned_ptr_zst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -3,7 +3,8 @@\n // compile-flags: -Zmir-opt-level=0 -Zmiri-disable-validation\n \n fn main() {\n-    for i in 0..10 { // Try many times as this might work by chance.\n+    // Try many times as this might work by chance.\n+    for i in 0..10 {\n         let x = i as u8;\n         let x = &x as *const _ as *const [u32; 0];\n         // This must fail because alignment is violated. Test specifically for loading ZST."}, {"sha": "546931f6ff87560ebb8bc1ba5fd5c17c8c38ff6e", "filename": "tests/pass/intrinsics-integer.rs", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics-integer.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -13,110 +13,110 @@ use std::intrinsics::*;\n \n pub fn main() {\n     unsafe {\n-        assert_eq!(ctpop(0u8), 0); assert_eq!(ctpop(0i8), 0);\n-        assert_eq!(ctpop(0u16), 0); assert_eq!(ctpop(0i16), 0);\n-        assert_eq!(ctpop(0u32), 0); assert_eq!(ctpop(0i32), 0);\n-        assert_eq!(ctpop(0u64), 0); assert_eq!(ctpop(0i64), 0);\n-\n-        assert_eq!(ctpop(1u8), 1); assert_eq!(ctpop(1i8), 1);\n-        assert_eq!(ctpop(1u16), 1); assert_eq!(ctpop(1i16), 1);\n-        assert_eq!(ctpop(1u32), 1); assert_eq!(ctpop(1i32), 1);\n-        assert_eq!(ctpop(1u64), 1); assert_eq!(ctpop(1i64), 1);\n-\n-        assert_eq!(ctpop(10u8), 2); assert_eq!(ctpop(10i8), 2);\n-        assert_eq!(ctpop(10u16), 2); assert_eq!(ctpop(10i16), 2);\n-        assert_eq!(ctpop(10u32), 2); assert_eq!(ctpop(10i32), 2);\n-        assert_eq!(ctpop(10u64), 2); assert_eq!(ctpop(10i64), 2);\n-\n-        assert_eq!(ctpop(100u8), 3); assert_eq!(ctpop(100i8), 3);\n-        assert_eq!(ctpop(100u16), 3); assert_eq!(ctpop(100i16), 3);\n-        assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n-        assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n-\n-        assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n-        assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n-        assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n-        assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n-\n-        assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n-        assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n-        assert_eq!(ctlz(0u32), 32); assert_eq!(ctlz(0i32), 32);\n-        assert_eq!(ctlz(0u64), 64); assert_eq!(ctlz(0i64), 64);\n-\n-        assert_eq!(ctlz(1u8), 7); assert_eq!(ctlz(1i8), 7);\n-        assert_eq!(ctlz(1u16), 15); assert_eq!(ctlz(1i16), 15);\n-        assert_eq!(ctlz(1u32), 31); assert_eq!(ctlz(1i32), 31);\n-        assert_eq!(ctlz(1u64), 63); assert_eq!(ctlz(1i64), 63);\n-\n-        assert_eq!(ctlz(10u8), 4); assert_eq!(ctlz(10i8), 4);\n-        assert_eq!(ctlz(10u16), 12); assert_eq!(ctlz(10i16), 12);\n-        assert_eq!(ctlz(10u32), 28); assert_eq!(ctlz(10i32), 28);\n-        assert_eq!(ctlz(10u64), 60); assert_eq!(ctlz(10i64), 60);\n-\n-        assert_eq!(ctlz(100u8), 1); assert_eq!(ctlz(100i8), 1);\n-        assert_eq!(ctlz(100u16), 9); assert_eq!(ctlz(100i16), 9);\n-        assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n-        assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n-\n-        assert_eq!(ctlz_nonzero(1u8), 7); assert_eq!(ctlz_nonzero(1i8), 7);\n-        assert_eq!(ctlz_nonzero(1u16), 15); assert_eq!(ctlz_nonzero(1i16), 15);\n-        assert_eq!(ctlz_nonzero(1u32), 31); assert_eq!(ctlz_nonzero(1i32), 31);\n-        assert_eq!(ctlz_nonzero(1u64), 63); assert_eq!(ctlz_nonzero(1i64), 63);\n-\n-        assert_eq!(ctlz_nonzero(10u8), 4); assert_eq!(ctlz_nonzero(10i8), 4);\n-        assert_eq!(ctlz_nonzero(10u16), 12); assert_eq!(ctlz_nonzero(10i16), 12);\n-        assert_eq!(ctlz_nonzero(10u32), 28); assert_eq!(ctlz_nonzero(10i32), 28);\n-        assert_eq!(ctlz_nonzero(10u64), 60); assert_eq!(ctlz_nonzero(10i64), 60);\n-\n-        assert_eq!(ctlz_nonzero(100u8), 1); assert_eq!(ctlz_nonzero(100i8), 1);\n-        assert_eq!(ctlz_nonzero(100u16), 9); assert_eq!(ctlz_nonzero(100i16), 9);\n-        assert_eq!(ctlz_nonzero(100u32), 25); assert_eq!(ctlz_nonzero(100i32), 25);\n-        assert_eq!(ctlz_nonzero(100u64), 57); assert_eq!(ctlz_nonzero(100i64), 57);\n-\n-        assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n-        assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n-        assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n-        assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n-\n-        assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n-        assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);\n-        assert_eq!(cttz(0u32), 32); assert_eq!(cttz(0i32), 32);\n-        assert_eq!(cttz(0u64), 64); assert_eq!(cttz(0i64), 64);\n-\n-        assert_eq!(cttz(1u8), 0); assert_eq!(cttz(1i8), 0);\n-        assert_eq!(cttz(1u16), 0); assert_eq!(cttz(1i16), 0);\n-        assert_eq!(cttz(1u32), 0); assert_eq!(cttz(1i32), 0);\n-        assert_eq!(cttz(1u64), 0); assert_eq!(cttz(1i64), 0);\n-\n-        assert_eq!(cttz(10u8), 1); assert_eq!(cttz(10i8), 1);\n-        assert_eq!(cttz(10u16), 1); assert_eq!(cttz(10i16), 1);\n-        assert_eq!(cttz(10u32), 1); assert_eq!(cttz(10i32), 1);\n-        assert_eq!(cttz(10u64), 1); assert_eq!(cttz(10i64), 1);\n-\n-        assert_eq!(cttz(100u8), 2); assert_eq!(cttz(100i8), 2);\n-        assert_eq!(cttz(100u16), 2); assert_eq!(cttz(100i16), 2);\n-        assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n-        assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n-\n-        assert_eq!(cttz_nonzero(-1i8 as u8), 0); assert_eq!(cttz_nonzero(-1i8), 0);\n-        assert_eq!(cttz_nonzero(-1i16 as u16), 0); assert_eq!(cttz_nonzero(-1i16), 0);\n-        assert_eq!(cttz_nonzero(-1i32 as u32), 0); assert_eq!(cttz_nonzero(-1i32), 0);\n-        assert_eq!(cttz_nonzero(-1i64 as u64), 0); assert_eq!(cttz_nonzero(-1i64), 0);\n-\n-        assert_eq!(cttz_nonzero(1u8), 0); assert_eq!(cttz_nonzero(1i8), 0);\n-        assert_eq!(cttz_nonzero(1u16), 0); assert_eq!(cttz_nonzero(1i16), 0);\n-        assert_eq!(cttz_nonzero(1u32), 0); assert_eq!(cttz_nonzero(1i32), 0);\n-        assert_eq!(cttz_nonzero(1u64), 0); assert_eq!(cttz_nonzero(1i64), 0);\n-\n-        assert_eq!(cttz_nonzero(10u8), 1); assert_eq!(cttz_nonzero(10i8), 1);\n-        assert_eq!(cttz_nonzero(10u16), 1); assert_eq!(cttz_nonzero(10i16), 1);\n-        assert_eq!(cttz_nonzero(10u32), 1); assert_eq!(cttz_nonzero(10i32), 1);\n-        assert_eq!(cttz_nonzero(10u64), 1); assert_eq!(cttz_nonzero(10i64), 1);\n-\n-        assert_eq!(cttz_nonzero(100u8), 2); assert_eq!(cttz_nonzero(100i8), 2);\n-        assert_eq!(cttz_nonzero(100u16), 2); assert_eq!(cttz_nonzero(100i16), 2);\n-        assert_eq!(cttz_nonzero(100u32), 2); assert_eq!(cttz_nonzero(100i32), 2);\n-        assert_eq!(cttz_nonzero(100u64), 2); assert_eq!(cttz_nonzero(100i64), 2);\n+        [assert_eq!(ctpop(0u8), 0), assert_eq!(ctpop(0i8), 0)];\n+        [assert_eq!(ctpop(0u16), 0), assert_eq!(ctpop(0i16), 0)];\n+        [assert_eq!(ctpop(0u32), 0), assert_eq!(ctpop(0i32), 0)];\n+        [assert_eq!(ctpop(0u64), 0), assert_eq!(ctpop(0i64), 0)];\n+\n+        [assert_eq!(ctpop(1u8), 1), assert_eq!(ctpop(1i8), 1)];\n+        [assert_eq!(ctpop(1u16), 1), assert_eq!(ctpop(1i16), 1)];\n+        [assert_eq!(ctpop(1u32), 1), assert_eq!(ctpop(1i32), 1)];\n+        [assert_eq!(ctpop(1u64), 1), assert_eq!(ctpop(1i64), 1)];\n+\n+        [assert_eq!(ctpop(10u8), 2), assert_eq!(ctpop(10i8), 2)];\n+        [assert_eq!(ctpop(10u16), 2), assert_eq!(ctpop(10i16), 2)];\n+        [assert_eq!(ctpop(10u32), 2), assert_eq!(ctpop(10i32), 2)];\n+        [assert_eq!(ctpop(10u64), 2), assert_eq!(ctpop(10i64), 2)];\n+\n+        [assert_eq!(ctpop(100u8), 3), assert_eq!(ctpop(100i8), 3)];\n+        [assert_eq!(ctpop(100u16), 3), assert_eq!(ctpop(100i16), 3)];\n+        [assert_eq!(ctpop(100u32), 3), assert_eq!(ctpop(100i32), 3)];\n+        [assert_eq!(ctpop(100u64), 3), assert_eq!(ctpop(100i64), 3)];\n+\n+        [assert_eq!(ctpop(-1i8 as u8), 8), assert_eq!(ctpop(-1i8), 8)];\n+        [assert_eq!(ctpop(-1i16 as u16), 16), assert_eq!(ctpop(-1i16), 16)];\n+        [assert_eq!(ctpop(-1i32 as u32), 32), assert_eq!(ctpop(-1i32), 32)];\n+        [assert_eq!(ctpop(-1i64 as u64), 64), assert_eq!(ctpop(-1i64), 64)];\n+\n+        [assert_eq!(ctlz(0u8), 8), assert_eq!(ctlz(0i8), 8)];\n+        [assert_eq!(ctlz(0u16), 16), assert_eq!(ctlz(0i16), 16)];\n+        [assert_eq!(ctlz(0u32), 32), assert_eq!(ctlz(0i32), 32)];\n+        [assert_eq!(ctlz(0u64), 64), assert_eq!(ctlz(0i64), 64)];\n+\n+        [assert_eq!(ctlz(1u8), 7), assert_eq!(ctlz(1i8), 7)];\n+        [assert_eq!(ctlz(1u16), 15), assert_eq!(ctlz(1i16), 15)];\n+        [assert_eq!(ctlz(1u32), 31), assert_eq!(ctlz(1i32), 31)];\n+        [assert_eq!(ctlz(1u64), 63), assert_eq!(ctlz(1i64), 63)];\n+\n+        [assert_eq!(ctlz(10u8), 4), assert_eq!(ctlz(10i8), 4)];\n+        [assert_eq!(ctlz(10u16), 12), assert_eq!(ctlz(10i16), 12)];\n+        [assert_eq!(ctlz(10u32), 28), assert_eq!(ctlz(10i32), 28)];\n+        [assert_eq!(ctlz(10u64), 60), assert_eq!(ctlz(10i64), 60)];\n+\n+        [assert_eq!(ctlz(100u8), 1), assert_eq!(ctlz(100i8), 1)];\n+        [assert_eq!(ctlz(100u16), 9), assert_eq!(ctlz(100i16), 9)];\n+        [assert_eq!(ctlz(100u32), 25), assert_eq!(ctlz(100i32), 25)];\n+        [assert_eq!(ctlz(100u64), 57), assert_eq!(ctlz(100i64), 57)];\n+\n+        [assert_eq!(ctlz_nonzero(1u8), 7), assert_eq!(ctlz_nonzero(1i8), 7)];\n+        [assert_eq!(ctlz_nonzero(1u16), 15), assert_eq!(ctlz_nonzero(1i16), 15)];\n+        [assert_eq!(ctlz_nonzero(1u32), 31), assert_eq!(ctlz_nonzero(1i32), 31)];\n+        [assert_eq!(ctlz_nonzero(1u64), 63), assert_eq!(ctlz_nonzero(1i64), 63)];\n+\n+        [assert_eq!(ctlz_nonzero(10u8), 4), assert_eq!(ctlz_nonzero(10i8), 4)];\n+        [assert_eq!(ctlz_nonzero(10u16), 12), assert_eq!(ctlz_nonzero(10i16), 12)];\n+        [assert_eq!(ctlz_nonzero(10u32), 28), assert_eq!(ctlz_nonzero(10i32), 28)];\n+        [assert_eq!(ctlz_nonzero(10u64), 60), assert_eq!(ctlz_nonzero(10i64), 60)];\n+\n+        [assert_eq!(ctlz_nonzero(100u8), 1), assert_eq!(ctlz_nonzero(100i8), 1)];\n+        [assert_eq!(ctlz_nonzero(100u16), 9), assert_eq!(ctlz_nonzero(100i16), 9)];\n+        [assert_eq!(ctlz_nonzero(100u32), 25), assert_eq!(ctlz_nonzero(100i32), 25)];\n+        [assert_eq!(ctlz_nonzero(100u64), 57), assert_eq!(ctlz_nonzero(100i64), 57)];\n+\n+        [assert_eq!(cttz(-1i8 as u8), 0), assert_eq!(cttz(-1i8), 0)];\n+        [assert_eq!(cttz(-1i16 as u16), 0), assert_eq!(cttz(-1i16), 0)];\n+        [assert_eq!(cttz(-1i32 as u32), 0), assert_eq!(cttz(-1i32), 0)];\n+        [assert_eq!(cttz(-1i64 as u64), 0), assert_eq!(cttz(-1i64), 0)];\n+\n+        [assert_eq!(cttz(0u8), 8), assert_eq!(cttz(0i8), 8)];\n+        [assert_eq!(cttz(0u16), 16), assert_eq!(cttz(0i16), 16)];\n+        [assert_eq!(cttz(0u32), 32), assert_eq!(cttz(0i32), 32)];\n+        [assert_eq!(cttz(0u64), 64), assert_eq!(cttz(0i64), 64)];\n+\n+        [assert_eq!(cttz(1u8), 0), assert_eq!(cttz(1i8), 0)];\n+        [assert_eq!(cttz(1u16), 0), assert_eq!(cttz(1i16), 0)];\n+        [assert_eq!(cttz(1u32), 0), assert_eq!(cttz(1i32), 0)];\n+        [assert_eq!(cttz(1u64), 0), assert_eq!(cttz(1i64), 0)];\n+\n+        [assert_eq!(cttz(10u8), 1), assert_eq!(cttz(10i8), 1)];\n+        [assert_eq!(cttz(10u16), 1), assert_eq!(cttz(10i16), 1)];\n+        [assert_eq!(cttz(10u32), 1), assert_eq!(cttz(10i32), 1)];\n+        [assert_eq!(cttz(10u64), 1), assert_eq!(cttz(10i64), 1)];\n+\n+        [assert_eq!(cttz(100u8), 2), assert_eq!(cttz(100i8), 2)];\n+        [assert_eq!(cttz(100u16), 2), assert_eq!(cttz(100i16), 2)];\n+        [assert_eq!(cttz(100u32), 2), assert_eq!(cttz(100i32), 2)];\n+        [assert_eq!(cttz(100u64), 2), assert_eq!(cttz(100i64), 2)];\n+\n+        [assert_eq!(cttz_nonzero(-1i8 as u8), 0), assert_eq!(cttz_nonzero(-1i8), 0)];\n+        [assert_eq!(cttz_nonzero(-1i16 as u16), 0), assert_eq!(cttz_nonzero(-1i16), 0)];\n+        [assert_eq!(cttz_nonzero(-1i32 as u32), 0), assert_eq!(cttz_nonzero(-1i32), 0)];\n+        [assert_eq!(cttz_nonzero(-1i64 as u64), 0), assert_eq!(cttz_nonzero(-1i64), 0)];\n+\n+        [assert_eq!(cttz_nonzero(1u8), 0), assert_eq!(cttz_nonzero(1i8), 0)];\n+        [assert_eq!(cttz_nonzero(1u16), 0), assert_eq!(cttz_nonzero(1i16), 0)];\n+        [assert_eq!(cttz_nonzero(1u32), 0), assert_eq!(cttz_nonzero(1i32), 0)];\n+        [assert_eq!(cttz_nonzero(1u64), 0), assert_eq!(cttz_nonzero(1i64), 0)];\n+\n+        [assert_eq!(cttz_nonzero(10u8), 1), assert_eq!(cttz_nonzero(10i8), 1)];\n+        [assert_eq!(cttz_nonzero(10u16), 1), assert_eq!(cttz_nonzero(10i16), 1)];\n+        [assert_eq!(cttz_nonzero(10u32), 1), assert_eq!(cttz_nonzero(10i32), 1)];\n+        [assert_eq!(cttz_nonzero(10u64), 1), assert_eq!(cttz_nonzero(10i64), 1)];\n+\n+        [assert_eq!(cttz_nonzero(100u8), 2), assert_eq!(cttz_nonzero(100i8), 2)];\n+        [assert_eq!(cttz_nonzero(100u16), 2), assert_eq!(cttz_nonzero(100i16), 2)];\n+        [assert_eq!(cttz_nonzero(100u32), 2), assert_eq!(cttz_nonzero(100i32), 2)];\n+        [assert_eq!(cttz_nonzero(100u64), 2), assert_eq!(cttz_nonzero(100i64), 2)];\n \n         assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n         assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n@@ -127,20 +127,20 @@ pub fn main() {\n         assert_eq!(bswap(0x0122334455667708u64), 0x0877665544332201);\n         assert_eq!(bswap(0x0122334455667708i64), 0x0877665544332201);\n \n-        assert_eq!(exact_div(9*9u32, 3), 27);\n-        assert_eq!(exact_div(-9*9i32, 3), -27);\n-        assert_eq!(exact_div(9*9i8, -3), -27);\n-        assert_eq!(exact_div(-9*9i64, -3), 27);\n+        assert_eq!(exact_div(9 * 9u32, 3), 27);\n+        assert_eq!(exact_div(-9 * 9i32, 3), -27);\n+        assert_eq!(exact_div(9 * 9i8, -3), -27);\n+        assert_eq!(exact_div(-9 * 9i64, -3), 27);\n \n-        assert_eq!(unchecked_div(9*9u32, 2), 40);\n-        assert_eq!(unchecked_div(-9*9i32, 2), -40);\n-        assert_eq!(unchecked_div(9*9i8, -2), -40);\n-        assert_eq!(unchecked_div(-9*9i64, -2), 40);\n+        assert_eq!(unchecked_div(9 * 9u32, 2), 40);\n+        assert_eq!(unchecked_div(-9 * 9i32, 2), -40);\n+        assert_eq!(unchecked_div(9 * 9i8, -2), -40);\n+        assert_eq!(unchecked_div(-9 * 9i64, -2), 40);\n \n-        assert_eq!(unchecked_rem(9*9u32, 2), 1);\n-        assert_eq!(unchecked_rem(-9*9i32, 2), -1);\n-        assert_eq!(unchecked_rem(9*9i8, -2), 1);\n-        assert_eq!(unchecked_rem(-9*9i64, -2), -1);\n+        assert_eq!(unchecked_rem(9 * 9u32, 2), 1);\n+        assert_eq!(unchecked_rem(-9 * 9i32, 2), -1);\n+        assert_eq!(unchecked_rem(9 * 9i8, -2), 1);\n+        assert_eq!(unchecked_rem(-9 * 9i64, -2), -1);\n \n         assert_eq!(unchecked_add(23u8, 19), 42);\n         assert_eq!(unchecked_add(5, -10), -5);"}, {"sha": "2fb00391cd79527bd69f0b169eedbac2775b578a", "filename": "tests/pass/panic/catch_panic.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fcatch_panic.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -3,8 +3,8 @@\n #![feature(never_type)]\n #![allow(unconditional_panic, non_fmt_panics)]\n \n-use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::cell::Cell;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n \n thread_local! {\n     static MY_COUNTER: Cell<usize> = Cell::new(0);\n@@ -59,23 +59,29 @@ fn main() {\n     test(None, |old_val| core::panic!(\"Hello from panic: {:?}\", old_val));\n \n     // Built-in panics; also make sure the message is right.\n-    test(\n-        Some(\"index out of bounds: the len is 3 but the index is 4\"),\n-        |_old_val| { let _val = [0, 1, 2][4]; loop {} },\n-    );\n-    test(\n-        Some(\"attempt to divide by zero\"),\n-        |_old_val| { let _val = 1/0; loop {} },\n-    );\n-\n-    test(\n-        Some(\"align_offset: align is not a power-of-two\"),\n-        |_old_val| { (0usize as *const u8).align_offset(3); loop {} },\n-    );\n+    test(Some(\"index out of bounds: the len is 3 but the index is 4\"), |_old_val| {\n+        let _val = [0, 1, 2][4];\n+        loop {}\n+    });\n+    test(Some(\"attempt to divide by zero\"), |_old_val| {\n+        let _val = 1 / 0;\n+        loop {}\n+    });\n+\n+    test(Some(\"align_offset: align is not a power-of-two\"), |_old_val| {\n+        (0usize as *const u8).align_offset(3);\n+        loop {}\n+    });\n \n     // Assertion and debug assertion\n-    test(None, |_old_val| { assert!(false); loop {} });\n-    test(None, |_old_val| { debug_assert!(false); loop {} });\n+    test(None, |_old_val| {\n+        assert!(false);\n+        loop {}\n+    });\n+    test(None, |_old_val| {\n+        debug_assert!(false);\n+        loop {}\n+    });\n \n     eprintln!(\"Success!\"); // Make sure we get this in stderr\n }\n@@ -89,7 +95,8 @@ fn test(expect_msg: Option<&str>, do_panic: impl FnOnce(usize) -> !) {\n     let res = catch_unwind(AssertUnwindSafe(|| {\n         let _string = \"LEAKED FROM CLOSURE\".to_string();\n         do_panic_counter(do_panic)\n-    })).expect_err(\"do_panic() did not panic!\");\n+    }))\n+    .expect_err(\"do_panic() did not panic!\");\n \n     // See if we can extract the panic message.\n     let msg = if let Some(s) = res.downcast_ref::<String>() {"}, {"sha": "889b6bd04f9d5b16c58e5cfe549225dc2d458ac3", "filename": "tests/pass/ptr_int_casts.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_int_casts.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -5,20 +5,23 @@ fn eq_ref<T>(x: &T, y: &T) -> bool {\n     x as *const _ == y as *const _\n }\n \n-fn f() -> i32 { 42 }\n+fn f() -> i32 {\n+    42\n+}\n \n fn ptr_int_casts() {\n     // int-ptr-int\n     assert_eq!(1 as *const i32 as usize, 1);\n-    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4*4);\n+    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4 * 4);\n \n     // negative overflowing wrapping_offset (going through memory because\n     // this used to trigger an ICE on 32bit)\n     let val = &mut ptr::null();\n     *val = (1 as *const u8).wrapping_offset(-4);\n     assert_eq!(*val as usize, usize::MAX - 2);\n \n-    {   // ptr-int-ptr\n+    // ptr-int-ptr\n+    {\n         let x = 13;\n         let mut y = &x as &_ as *const _ as usize;\n         y += 13;\n@@ -27,13 +30,14 @@ fn ptr_int_casts() {\n         assert!(eq_ref(&x, unsafe { &*y }));\n     }\n \n-    {   // fnptr-int-fnptr\n-        let x : fn() -> i32 = f;\n-        let y : *mut u8 = unsafe { mem::transmute(x as fn() -> i32) };\n+    // fnptr-int-fnptr\n+    {\n+        let x: fn() -> i32 = f;\n+        let y: *mut u8 = unsafe { mem::transmute(x as fn() -> i32) };\n         let mut y = y as usize;\n         y += 13;\n         y -= 13;\n-        let x : fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n+        let x: fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n         assert_eq!(x(), 42);\n     }\n \n@@ -51,13 +55,13 @@ fn ptr_int_ops() {\n     // bit-operations, covered by alignment\n     assert_eq!(x & 1, 0);\n     assert_eq!(x & 0, 0);\n-    assert_eq!(1 & (x+1), 1);\n+    assert_eq!(1 & (x + 1), 1);\n     let _y = !1 & x;\n     let _y = !0 & x;\n     let _y = x & !1;\n     // remainder, covered by alignment\n     assert_eq!(x % 2, 0);\n-    assert_eq!((x+1) % 2, 1);\n+    assert_eq!((x + 1) % 2, 1);\n     // remainder with 1 is always 0\n     assert_eq!(x % 1, 0);\n }"}, {"sha": "c91ac36ed6b41eab29e58d4db264338cf0284a43", "filename": "tests/pass/regions-lifetime-nonfree-late-bound.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fregions-lifetime-nonfree-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fregions-lifetime-nonfree-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fregions-lifetime-nonfree-late-bound.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -16,15 +16,23 @@\n \n pub fn main() {\n     fn explicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<dyn for<'a> FnMut(&'a isize)>) {}\n+        fn test<F>(_x: Option<Box<F>>)\n+        where\n+            F: FnMut(Box<dyn for<'a> FnMut(&'a isize)>),\n+        {\n+        }\n         test(Some(box |_f: Box<dyn for<'a> FnMut(&'a isize)>| {}));\n     }\n \n     // The code below is shorthand for the code above (and more likely\n     // to represent what one encounters in practice).\n     fn implicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<dyn         FnMut(&   isize)>) {}\n-        test(Some(box |_f: Box<dyn         FnMut(&   isize)>| {}));\n+        fn test<F>(_x: Option<Box<F>>)\n+        where\n+            F: FnMut(Box<dyn FnMut(&isize)>),\n+        {\n+        }\n+        test(Some(box |_f: Box<dyn FnMut(&isize)>| {}));\n     }\n \n     explicit();"}, {"sha": "3256d4c65116a94b14b21e1a7191fcaff9bcafdc", "filename": "tests/pass/sums.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d1d345f8f9badc83bad702b83ecca5feb85691f/tests%2Fpass%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fsums.rs?ref=3d1d345f8f9badc83bad702b83ecca5feb85691f", "patch": "@@ -1,12 +1,17 @@\n #[derive(Debug, PartialEq)]\n-enum Unit { Unit(()) } // Force non-C-enum representation.\n+enum Unit {\n+    Unit(()), // Force non-C-enum representation.\n+}\n \n fn return_unit() -> Unit {\n     Unit::Unit(())\n }\n \n #[derive(Debug, PartialEq)]\n-enum MyBool { False(()), True(()) } // Force non-C-enum representation.\n+enum MyBool {\n+    False(()), // Force non-C-enum representation.\n+    True(()),\n+}\n \n fn return_true() -> MyBool {\n     MyBool::True(())"}]}