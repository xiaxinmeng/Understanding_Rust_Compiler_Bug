{"sha": "03df573c57b331df37fc3304c4d96293b069b522", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZGY1NzNjNTdiMzMxZGYzN2ZjMzMwNGM0ZDk2MjkzYjA2OWI1MjI=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-08-01T08:12:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-01T08:12:35Z"}, "message": "Rollup merge of #52628 - Mark-Simulacrum:rustdoc-cleanup-1, r=QuietMisdreavus\n\nCleanup some rustdoc code\n\nCommits are mostly individual though some do depend on others.", "tree": {"sha": "5935541e59f1d319841fdaba83ca0e67474255c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5935541e59f1d319841fdaba83ca0e67474255c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03df573c57b331df37fc3304c4d96293b069b522", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbYWtzCRBK7hj4Ov3rIwAAdHIIAIt3+Awl8xgNTsRxgMEPTyD1\nF2clqMB9PW+ZAMLdAbKssH2Mtxgqhrv+SlKj4SCincroks0HZiIul8P54S/56DsG\n6pXrtI0zRUwQfBBzyGh000+T0r1eRcgBgfPkWHqHzQLOahFYEKkH0QPuIsUZ4Zx9\nqCSGaRKEoiQDiDWm5bH1rIig9V7O9b7T36E01GXFeg1TIBMYock9roWLTj54Jvps\nCLkCqjL49/5LuL1t+07usHFqzBoHRN/7lr+YgGQjCmJGoPHaZffuwnG2BZ8vHwjw\nfBwRrIYu9LqjLHEtu5s4K9BztYuO10Dl3E2VDxNGX7TQaFqs1RI3Lmf+1Khv198=\n=kYhO\n-----END PGP SIGNATURE-----\n", "payload": "tree 5935541e59f1d319841fdaba83ca0e67474255c2\nparent b7ee110ea2c739e1819b437754b345deda3f3606\nparent 0f680b38d0be7e2621c288a8e77a7177a7ae3189\nauthor Pietro Albini <pietro@pietroalbini.org> 1533111155 +0200\ncommitter GitHub <noreply@github.com> 1533111155 +0200\n\nRollup merge of #52628 - Mark-Simulacrum:rustdoc-cleanup-1, r=QuietMisdreavus\n\nCleanup some rustdoc code\n\nCommits are mostly individual though some do depend on others.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03df573c57b331df37fc3304c4d96293b069b522", "html_url": "https://github.com/rust-lang/rust/commit/03df573c57b331df37fc3304c4d96293b069b522", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03df573c57b331df37fc3304c4d96293b069b522/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7ee110ea2c739e1819b437754b345deda3f3606", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ee110ea2c739e1819b437754b345deda3f3606", "html_url": "https://github.com/rust-lang/rust/commit/b7ee110ea2c739e1819b437754b345deda3f3606"}, {"sha": "0f680b38d0be7e2621c288a8e77a7177a7ae3189", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f680b38d0be7e2621c288a8e77a7177a7ae3189", "html_url": "https://github.com/rust-lang/rust/commit/0f680b38d0be7e2621c288a8e77a7177a7ae3189"}], "stats": {"total": 580, "additions": 318, "deletions": 262}, "files": [{"sha": "9631ea059cc4300f0337ac755716024033e3133a", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -12,7 +12,9 @@ use std::fs;\n use std::path::Path;\n use std::str;\n use errors;\n-use html::markdown::Markdown;\n+use syntax::feature_gate::UnstableFeatures;\n+use html::markdown::{IdMap, ErrorCodes, Markdown};\n+use std::cell::RefCell;\n \n #[derive(Clone)]\n pub struct ExternalHtml {\n@@ -29,24 +31,28 @@ pub struct ExternalHtml {\n \n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n-                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler)\n+                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler,\n+                id_map: &mut IdMap)\n             -> Option<ExternalHtml> {\n+        let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n         load_external_files(in_header, diag)\n             .and_then(|ih|\n                 load_external_files(before_content, diag)\n                     .map(|bc| (ih, bc))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(md_before_content, diag)\n-                    .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, &[]))))\n+                    .map(|m_bc| (ih,\n+                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map), codes))))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(after_content, diag)\n                     .map(|ac| (ih, bc, ac))\n             )\n             .and_then(|(ih, bc, ac)|\n                 load_external_files(md_after_content, diag)\n-                    .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, &[]))))\n+                    .map(|m_ac| (ih, bc,\n+                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map), codes))))\n             )\n             .map(|(ih, bc, ac)|\n                 ExternalHtml {"}, {"sha": "73d7a9ab8599d75015d62301eeb2c21e1cdddc3b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -13,12 +13,7 @@\n //! This module uses libsyntax's lexer to provide token-based highlighting for\n //! the HTML documentation generated by rustdoc.\n //!\n-//! If you just want to syntax highlighting for a Rust program, then you can use\n-//! the `render_inner_with_highlighting` or `render_with_highlighting`\n-//! functions. For more advanced use cases (if you want to supply your own css\n-//! classes or control how the HTML is generated, or even generate something\n-//! other then HTML), then you should implement the `Writer` trait and use a\n-//! `Classifier`.\n+//! Use the `render_with_highlighting` to highlight some rust code.\n \n use html::escape::Escape;\n \n@@ -33,7 +28,7 @@ use syntax::parse;\n use syntax_pos::{Span, FileName};\n \n /// Highlights `src`, returning the HTML output.\n-pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>,\n+pub fn render_with_highlighting(src: &str, class: Option<&str>,\n                                 extension: Option<&str>,\n                                 tooltip: Option<(&str, &str)>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n@@ -46,7 +41,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n                      class='tooltiptext'>{}</span></div></div>\",\n                class, tooltip).unwrap();\n     }\n-    write_header(class, id, &mut out).unwrap();\n+    write_header(class, &mut out).unwrap();\n \n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n     if let Err(_) = classifier.write_source(&mut out) {\n@@ -63,7 +58,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// Processes a program (nested in the internal `lexer`), classifying strings of\n /// text by highlighting category (`Class`). Calls out to a `Writer` to write\n /// each span of text in sequence.\n-pub struct Classifier<'a> {\n+struct Classifier<'a> {\n     lexer: lexer::StringReader<'a>,\n     codemap: &'a CodeMap,\n \n@@ -75,7 +70,7 @@ pub struct Classifier<'a> {\n \n /// How a span of text is classified. Mostly corresponds to token kinds.\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum Class {\n+enum Class {\n     None,\n     Comment,\n     DocComment,\n@@ -103,19 +98,17 @@ pub enum Class {\n /// The classifier will call into the `Writer` implementation as it finds spans\n /// of text to highlight. Exactly how that text should be highlighted is up to\n /// the implementation.\n-pub trait Writer {\n+trait Writer {\n     /// Called when we start processing a span of text that should be highlighted.\n     /// The `Class` argument specifies how it should be highlighted.\n     fn enter_span(&mut self, _: Class) -> io::Result<()>;\n \n     /// Called at the end of a span of highlighted text.\n     fn exit_span(&mut self) -> io::Result<()>;\n \n-    /// Called for a span of text, usually, but not always, a single token. If\n-    /// the string of text (`T`) does correspond to a token, then the token will\n-    /// also be passed. If the text should be highlighted differently from the\n-    /// surrounding text, then the `Class` argument will be a value other than\n-    /// `None`.\n+    /// Called for a span of text.  If the text should be highlighted differently from the\n+    /// surrounding text, then the `Class` argument will be a value other than `None`.\n+    ///\n     /// The following sequences of callbacks are equivalent:\n     /// ```plain\n     ///     enter_span(Foo), string(\"text\", None), exit_span()\n@@ -125,8 +118,7 @@ pub trait Writer {\n     /// more flexible.\n     fn string<T: Display>(&mut self,\n                           text: T,\n-                          klass: Class,\n-                          tok: Option<&TokenAndSpan>)\n+                          klass: Class)\n                           -> io::Result<()>;\n }\n \n@@ -135,8 +127,7 @@ pub trait Writer {\n impl<U: Write> Writer for U {\n     fn string<T: Display>(&mut self,\n                           text: T,\n-                          klass: Class,\n-                          _tas: Option<&TokenAndSpan>)\n+                          klass: Class)\n                           -> io::Result<()> {\n         match klass {\n             Class::None => write!(self, \"{}\", text),\n@@ -154,7 +145,7 @@ impl<U: Write> Writer for U {\n }\n \n impl<'a> Classifier<'a> {\n-    pub fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n+    fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n         Classifier {\n             lexer,\n             codemap,\n@@ -186,7 +177,7 @@ impl<'a> Classifier<'a> {\n     /// is used. All source code emission is done as slices from the source map,\n     /// not from the tokens themselves, in order to stay true to the original\n     /// source.\n-    pub fn write_source<W: Writer>(&mut self,\n+    fn write_source<W: Writer>(&mut self,\n                                    out: &mut W)\n                                    -> io::Result<()> {\n         loop {\n@@ -208,7 +199,7 @@ impl<'a> Classifier<'a> {\n                               -> io::Result<()> {\n         let klass = match tas.tok {\n             token::Shebang(s) => {\n-                out.string(Escape(&s.as_str()), Class::None, Some(&tas))?;\n+                out.string(Escape(&s.as_str()), Class::None)?;\n                 return Ok(());\n             },\n \n@@ -272,8 +263,8 @@ impl<'a> Classifier<'a> {\n                         self.in_attribute = true;\n                         out.enter_span(Class::Attribute)?;\n                     }\n-                    out.string(\"#\", Class::None, None)?;\n-                    out.string(\"!\", Class::None, None)?;\n+                    out.string(\"#\", Class::None)?;\n+                    out.string(\"!\", Class::None)?;\n                     return Ok(());\n                 }\n \n@@ -282,13 +273,13 @@ impl<'a> Classifier<'a> {\n                     self.in_attribute = true;\n                     out.enter_span(Class::Attribute)?;\n                 }\n-                out.string(\"#\", Class::None, None)?;\n+                out.string(\"#\", Class::None)?;\n                 return Ok(());\n             }\n             token::CloseDelim(token::Bracket) => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    out.string(\"]\", Class::None, None)?;\n+                    out.string(\"]\", Class::None)?;\n                     out.exit_span()?;\n                     return Ok(());\n                 } else {\n@@ -344,7 +335,7 @@ impl<'a> Classifier<'a> {\n \n         // Anything that didn't return above is the simple case where we the\n         // class just spans a single token, so we can use the `string` method.\n-        out.string(Escape(&self.snip(tas.sp)), klass, Some(&tas))\n+        out.string(Escape(&self.snip(tas.sp)), klass)\n     }\n \n     // Helper function to get a snippet from the codemap.\n@@ -355,7 +346,7 @@ impl<'a> Classifier<'a> {\n \n impl Class {\n     /// Returns the css class expected by rustdoc for each `Class`.\n-    pub fn rustdoc_class(self) -> &'static str {\n+    fn rustdoc_class(self) -> &'static str {\n         match self {\n             Class::None => \"\",\n             Class::Comment => \"comment\",\n@@ -379,15 +370,8 @@ impl Class {\n     }\n }\n \n-fn write_header(class: Option<&str>,\n-                id: Option<&str>,\n-                out: &mut dyn Write)\n-                -> io::Result<()> {\n-    write!(out, \"<pre \")?;\n-    if let Some(id) = id {\n-        write!(out, \"id='{}' \", id)?;\n-    }\n-    write!(out, \"class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n+fn write_header(class: Option<&str>, out: &mut dyn Write) -> io::Result<()> {\n+    write!(out, \"<pre class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n }\n \n fn write_footer(out: &mut dyn Write) -> io::Result<()> {"}, {"sha": "b22e239e20a0eeaf166b3b34935ceb6eaaed5655", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 169, "deletions": 91, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -18,27 +18,25 @@\n //! ```\n //! #![feature(rustc_private)]\n //!\n-//! use rustdoc::html::markdown::Markdown;\n+//! use rustdoc::html::markdown::{IdMap, Markdown, ErrorCodes};\n+//! use std::cell::RefCell;\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s, &[]));\n+//! let mut id_map = IdMap::new();\n+//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map), ErrorCodes::Yes));\n //! // ... something using html\n //! ```\n \n #![allow(non_camel_case_types)]\n \n-use rustc::session;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n use std::fmt::{self, Write};\n use std::borrow::Cow;\n use std::ops::Range;\n use std::str;\n-use syntax::feature_gate::UnstableFeatures;\n-use syntax::codemap::Span;\n \n-use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n use test;\n@@ -50,15 +48,38 @@ use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n /// The second parameter is a list of link replacements\n-pub struct Markdown<'a>(pub &'a str, pub &'a [(String, String)]);\n+pub struct Markdown<'a>(\n+    pub &'a str, pub &'a [(String, String)], pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str);\n+pub struct MarkdownWithToc<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str);\n+pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum ErrorCodes {\n+    Yes,\n+    No,\n+}\n+\n+impl ErrorCodes {\n+    pub fn from(b: bool) -> Self {\n+        match b {\n+            true => ErrorCodes::Yes,\n+            false => ErrorCodes::No,\n+        }\n+    }\n+\n+    pub fn as_bool(self) -> bool {\n+        match self {\n+            ErrorCodes::Yes => true,\n+            ErrorCodes::No => false,\n+        }\n+    }\n+}\n+\n /// Controls whether a line will be hidden or shown in HTML output.\n ///\n /// All lines are used in documentation tests.\n@@ -129,12 +150,14 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n /// Adds syntax highlighting and playground Run buttons to rust code blocks.\n struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n+    check_error_codes: ErrorCodes,\n }\n \n impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n-    fn new(iter: I) -> Self {\n+    fn new(iter: I, error_codes: ErrorCodes) -> Self {\n         CodeBlocks {\n             inner: iter,\n+            check_error_codes: error_codes,\n         }\n     }\n }\n@@ -147,7 +170,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n         let compile_fail;\n         let ignore;\n         if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n-            let parse_result = LangString::parse(&lang);\n+            let parse_result = LangString::parse(&lang, self.check_error_codes);\n             if !parse_result.rust {\n                 return Some(Event::Start(Tag::CodeBlock(lang)));\n             }\n@@ -224,7 +247,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                                       if ignore { \" ignore\" }\n                                       else if compile_fail { \" compile_fail\" }\n                                       else { \"\" })),\n-                        None,\n                         playground_button.as_ref().map(String::as_str),\n                         tooltip));\n             Some(Event::Html(s.into()))\n@@ -266,23 +288,25 @@ impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I>\n }\n \n /// Make headings links with anchor ids and build up TOC.\n-struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+struct HeadingLinks<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n     buf: VecDeque<Event<'a>>,\n+    id_map: &'ids mut IdMap,\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, I> {\n-    fn new(iter: I, toc: Option<&'b mut TocBuilder>) -> Self {\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, 'ids, I> {\n+    fn new(iter: I, toc: Option<&'b mut TocBuilder>, ids: &'ids mut IdMap) -> Self {\n         HeadingLinks {\n             inner: iter,\n             toc,\n             buf: VecDeque::new(),\n+            id_map: ids,\n         }\n     }\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I> {\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -301,7 +325,7 @@ impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I>\n                 }\n                 self.buf.push_back(event);\n             }\n-            let id = derive_id(id);\n+            let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n@@ -467,10 +491,17 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span,\n-                          sess: Option<&session::Session>) {\n-    tests.set_position(position);\n+pub struct TestableCodeError(());\n \n+impl fmt::Display for TestableCodeError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"invalid start of a new code block\")\n+    }\n+}\n+\n+pub fn find_testable_code(\n+    doc: &str, tests: &mut test::Collector, error_codes: ErrorCodes,\n+) -> Result<(), TestableCodeError> {\n     let mut parser = Parser::new(doc);\n     let mut prev_offset = 0;\n     let mut nb_lines = 0;\n@@ -481,7 +512,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                 let block_info = if s.is_empty() {\n                     LangString::all_false()\n                 } else {\n-                    LangString::parse(&*s)\n+                    LangString::parse(&*s, error_codes)\n                 };\n                 if !block_info.rust {\n                     continue\n@@ -510,18 +541,10 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                     let text = lines.collect::<Vec<Cow<str>>>().join(\"\\n\");\n                     nb_lines += doc[prev_offset..offset].lines().count();\n                     let line = tests.get_line() + (nb_lines - 1);\n-                    let filename = tests.get_filename();\n-                    tests.add_test(text.to_owned(),\n-                                   block_info.should_panic, block_info.no_run,\n-                                   block_info.ignore, block_info.test_harness,\n-                                   block_info.compile_fail, block_info.error_codes,\n-                                   line, filename, block_info.allow_fail);\n+                    tests.add_test(text, block_info, line);\n                     prev_offset = offset;\n                 } else {\n-                    if let Some(ref sess) = sess {\n-                        sess.span_warn(position, \"invalid start of a new code block\");\n-                    }\n-                    break;\n+                    return Err(TestableCodeError(()));\n                 }\n             }\n             Event::Start(Tag::Header(level)) => {\n@@ -539,19 +562,20 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n             _ => {}\n         }\n     }\n+    Ok(())\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-struct LangString {\n+pub struct LangString {\n     original: String,\n-    should_panic: bool,\n-    no_run: bool,\n-    ignore: bool,\n-    rust: bool,\n-    test_harness: bool,\n-    compile_fail: bool,\n-    error_codes: Vec<String>,\n-    allow_fail: bool,\n+    pub should_panic: bool,\n+    pub no_run: bool,\n+    pub ignore: bool,\n+    pub rust: bool,\n+    pub test_harness: bool,\n+    pub compile_fail: bool,\n+    pub error_codes: Vec<String>,\n+    pub allow_fail: bool,\n }\n \n impl LangString {\n@@ -569,14 +593,11 @@ impl LangString {\n         }\n     }\n \n-    fn parse(string: &str) -> LangString {\n+    fn parse(string: &str, allow_error_code_check: ErrorCodes) -> LangString {\n+        let allow_error_code_check = allow_error_code_check.as_bool();\n         let mut seen_rust_tags = false;\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n-        let mut allow_error_code_check = false;\n-        if UnstableFeatures::from_environment().is_nightly_build() {\n-            allow_error_code_check = true;\n-        }\n \n         data.original = string.to_owned();\n         let tokens = string.split(|c: char|\n@@ -623,7 +644,8 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, links) = *self;\n+        let Markdown(md, links, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n@@ -643,20 +665,20 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(\n-                            CodeBlocks::new(\n-                                LinkReplacer::new(\n-                                    HeadingLinks::new(p, None),\n-                                    links))));\n+        let p = HeadingLinks::new(p, None, &mut ids);\n+        let p = LinkReplacer::new(p, links);\n+        let p = CodeBlocks::new(p, codes);\n+        let p = Footnotes::new(p);\n+        html::push_html(&mut s, p);\n \n         fmt.write_str(&s)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownWithToc(md) = *self;\n+        let MarkdownWithToc(md, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         let mut opts = Options::empty();\n         opts.insert(OPTION_ENABLE_TABLES);\n@@ -668,8 +690,12 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n         let mut toc = TocBuilder::new();\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+        {\n+            let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n+            let p = CodeBlocks::new(p, codes);\n+            let p = Footnotes::new(p);\n+            html::push_html(&mut s, p);\n+        }\n \n         write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n \n@@ -679,7 +705,8 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownHtml(md) = *self;\n+        let MarkdownHtml(md, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n@@ -697,8 +724,10 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+        let p = HeadingLinks::new(p, None, &mut ids);\n+        let p = CodeBlocks::new(p, codes);\n+        let p = Footnotes::new(p);\n+        html::push_html(&mut s, p);\n \n         fmt.write_str(&s)\n     }\n@@ -812,7 +841,10 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n         let p = Parser::new_with_broken_link_callback(md, opts,\n             Some(&push));\n \n-        let iter = Footnotes::new(HeadingLinks::new(p, None));\n+        // There's no need to thread an IdMap through to here because\n+        // the IDs generated aren't going to be emitted anywhere.\n+        let mut ids = IdMap::new();\n+        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n \n         for ev in iter {\n             if let Event::Start(Tag::Link(dest, _)) = ev {\n@@ -831,18 +863,74 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     links\n }\n \n+#[derive(Default)]\n+pub struct IdMap {\n+    map: HashMap<String, usize>,\n+}\n+\n+impl IdMap {\n+    pub fn new() -> Self {\n+        IdMap::default()\n+    }\n+\n+    pub fn populate<I: IntoIterator<Item=String>>(&mut self, ids: I) {\n+        for id in ids {\n+            let _ = self.derive(id);\n+        }\n+    }\n+\n+    pub fn reset(&mut self) {\n+        self.map = HashMap::new();\n+    }\n+\n+    pub fn derive(&mut self, candidate: String) -> String {\n+        let id = match self.map.get_mut(&candidate) {\n+            None => candidate,\n+            Some(a) => {\n+                let id = format!(\"{}-{}\", candidate, *a);\n+                *a += 1;\n+                id\n+            }\n+        };\n+\n+        self.map.insert(id.clone(), 1);\n+        id\n+    }\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_unique_id() {\n+    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n+                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n+                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n+    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n+                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n+                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n+\n+    let map = RefCell::new(IdMap::new());\n+    let test = || {\n+        let mut map = map.borrow_mut();\n+        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n+        assert_eq!(&actual[..], expected);\n+    };\n+    test();\n+    map.borrow_mut().reset();\n+    test();\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml};\n+    use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n     use super::plain_summary_line;\n-    use html::render::reset_ids;\n+    use std::cell::RefCell;\n \n     #[test]\n     fn test_lang_string_parse() {\n         fn t(s: &str,\n             should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n             compile_fail: bool, allow_fail: bool, error_codes: Vec<String>) {\n-            assert_eq!(LangString::parse(s), LangString {\n+            assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n                 should_panic,\n                 no_run,\n                 ignore,\n@@ -878,19 +966,12 @@ mod tests {\n         t(\"text,no_run\",           false,        true,   false,  false, false, false, false, v());\n     }\n \n-    #[test]\n-    fn issue_17736() {\n-        let markdown = \"# title\";\n-        Markdown(markdown, &[]).to_string();\n-        reset_ids(true);\n-    }\n-\n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = Markdown(input, &[]).to_string();\n+            let mut map = IdMap::new();\n+            let output = Markdown(input, &[], RefCell::new(&mut map), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n-            reset_ids(true);\n         }\n \n         t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n@@ -909,28 +990,24 @@ mod tests {\n \n     #[test]\n     fn test_header_ids_multiple_blocks() {\n-        fn t(input: &str, expect: &str) {\n-            let output = Markdown(input, &[]).to_string();\n+        let mut map = IdMap::new();\n+        fn t(map: &mut IdMap, input: &str, expect: &str) {\n+            let output = Markdown(input, &[], RefCell::new(map), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        let test = || {\n-            t(\"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example\\\">Example</a></h1>\");\n-            t(\"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#panics\\\">Panics</a></h1>\");\n-            t(\"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example-1\\\">Example</a></h1>\");\n-            t(\"# Main\", \"<h1 id=\\\"main-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#main-1\\\">Main</a></h1>\");\n-            t(\"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example-2\\\">Example</a></h1>\");\n-            t(\"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n-        };\n-        test();\n-        reset_ids(true);\n-        test();\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example\\\">Example</a></h1>\");\n+        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#panics\\\">Panics</a></h1>\");\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example-1\\\">Example</a></h1>\");\n+        t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#main\\\">Main</a></h1>\");\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example-2\\\">Example</a></h1>\");\n+        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n     }\n \n     #[test]\n@@ -951,7 +1028,8 @@ mod tests {\n     #[test]\n     fn test_markdown_html_escape() {\n         fn t(input: &str, expect: &str) {\n-            let output = MarkdownHtml(input).to_string();\n+            let mut idmap = IdMap::new();\n+            let output = MarkdownHtml(input, RefCell::new(&mut idmap), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n "}, {"sha": "c2978a62489a0d86bd787212f9abc144d2d4dc81", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 68, "deletions": 95, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -50,12 +50,14 @@ use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n+use std::rc::Rc;\n \n use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n use syntax::codemap::FileName;\n+use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n@@ -72,7 +74,7 @@ use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n use html::{highlight, layout};\n \n use minifier;\n@@ -88,7 +90,7 @@ pub type NameDoc = (String, Option<String>);\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-pub struct Context {\n+struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n@@ -99,10 +101,13 @@ pub struct Context {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n+    pub codes: ErrorCodes,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n }\n \n-pub struct SharedContext {\n+struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     pub src_root: PathBuf,\n@@ -450,9 +455,8 @@ impl ToJson for IndexItemFunctionType {\n \n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> = RefCell::new(Vec::new()));\n-thread_local!(pub static USED_ID_MAP: RefCell<FxHashMap<String, usize>> = RefCell::new(init_ids()));\n \n-fn init_ids() -> FxHashMap<String, usize> {\n+pub fn initial_ids() -> Vec<String> {\n     [\n      \"main\",\n      \"search\",\n@@ -470,36 +474,7 @@ fn init_ids() -> FxHashMap<String, usize> {\n      \"methods\",\n      \"deref-methods\",\n      \"implementations\",\n-    ].into_iter().map(|id| (String::from(*id), 1)).collect()\n-}\n-\n-/// This method resets the local table of used ID attributes. This is typically\n-/// used at the beginning of rendering an entire HTML page to reset from the\n-/// previous state (if any).\n-pub fn reset_ids(embedded: bool) {\n-    USED_ID_MAP.with(|s| {\n-        *s.borrow_mut() = if embedded {\n-            init_ids()\n-        } else {\n-            FxHashMap()\n-        };\n-    });\n-}\n-\n-pub fn derive_id(candidate: String) -> String {\n-    USED_ID_MAP.with(|map| {\n-        let id = match map.borrow_mut().get_mut(&candidate) {\n-            None => candidate,\n-            Some(a) => {\n-                let id = format!(\"{}-{}\", candidate, *a);\n-                *a += 1;\n-                id\n-            }\n-        };\n-\n-        map.borrow_mut().insert(id.clone(), 1);\n-        id\n-    })\n+    ].into_iter().map(|id| (String::from(*id))).collect()\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n@@ -513,7 +488,8 @@ pub fn run(mut krate: clean::Crate,\n            renderinfo: RenderInfo,\n            sort_modules_alphabetically: bool,\n            themes: Vec<PathBuf>,\n-           enable_minification: bool) -> Result<(), Error> {\n+           enable_minification: bool,\n+           id_map: IdMap) -> Result<(), Error> {\n     let src_root = match krate.src {\n         FileName::Real(ref p) => match p.parent() {\n             Some(p) => p.to_path_buf(),\n@@ -581,6 +557,8 @@ pub fn run(mut krate: clean::Crate,\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n+        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+        id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n     };\n \n@@ -1708,6 +1686,11 @@ impl<'a> fmt::Display for Settings<'a> {\n }\n \n impl Context {\n+    fn derive_id(&self, id: String) -> String {\n+        let mut map = self.id_map.borrow_mut();\n+        map.derive(id)\n+    }\n+\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     fn root_path(&self) -> String {\n@@ -1862,7 +1845,10 @@ impl Context {\n             resource_suffix: &self.shared.resource_suffix,\n         };\n \n-        reset_ids(true);\n+        {\n+            self.id_map.borrow_mut().reset();\n+            self.id_map.borrow_mut().populate(initial_ids());\n+        }\n \n         if !self.render_redirect_pages {\n             layout::render(writer, &self.shared.layout, &page,\n@@ -2219,14 +2205,17 @@ fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Re\n \n /// Render md_text as markdown.\n fn render_markdown(w: &mut fmt::Formatter,\n+                   cx: &Context,\n                    md_text: &str,\n                    links: Vec<(String, String)>,\n-                   prefix: &str,)\n+                   prefix: &str)\n                    -> fmt::Result {\n-    write!(w, \"<div class='docblock'>{}{}</div>\", prefix, Markdown(md_text, &links))\n+    let mut ids = cx.id_map.borrow_mut();\n+    write!(w, \"<div class='docblock'>{}{}</div>\",\n+        prefix, Markdown(md_text, &links, RefCell::new(&mut ids), cx.codes))\n }\n \n-fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n+fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link: AssocItemLink,\n                   prefix: &str) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n@@ -2235,7 +2224,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n         } else {\n             plain_summary_line(Some(s)).to_string()\n         };\n-        render_markdown(w, &markdown, item.links(), prefix)?;\n+        render_markdown(w, cx, &markdown, item.links(), prefix)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2250,7 +2239,6 @@ fn render_assoc_const_value(item: &clean::Item) -> String {\n                 None,\n                 None,\n                 None,\n-                None,\n             )\n         }\n         _ => String::new(),\n@@ -2261,7 +2249,7 @@ fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n                  cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, &*s, item.links(), prefix)?;\n+        render_markdown(w, cx, &*s, item.links(), prefix)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2427,7 +2415,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             let (short, name) = item_ty_to_strs(&myty.unwrap());\n             write!(w, \"<h2 id='{id}' class='section-header'>\\\n                        <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                   id = derive_id(short.to_owned()), name = name)?;\n+                   id = cx.derive_id(short.to_owned()), name = name)?;\n         }\n \n         match myitem.inner {\n@@ -2508,6 +2496,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<String> {\n     let mut stability = vec![];\n+    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n \n     if let Some(stab) = item.stability.as_ref() {\n         let deprecated_reason = if show_reason && !stab.deprecated_reason.is_empty() {\n@@ -2521,14 +2510,12 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             } else {\n                 String::new()\n             };\n+            let mut ids = cx.id_map.borrow_mut();\n+            let html = MarkdownHtml(&deprecated_reason, RefCell::new(&mut ids), error_codes);\n             let text = if stability::deprecation_in_effect(&stab.deprecated_since) {\n-                format!(\"Deprecated{}{}\",\n-                        since,\n-                        MarkdownHtml(&deprecated_reason))\n+                format!(\"Deprecated{}{}\", since, html)\n             } else {\n-                format!(\"Deprecating in {}{}\",\n-                        Escape(&stab.deprecated_since),\n-                        MarkdownHtml(&deprecated_reason))\n+                format!(\"Deprecating in {}{}\", Escape(&stab.deprecated_since), html)\n             };\n             stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n         };\n@@ -2555,11 +2542,15 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                                             </div>\",\n                                            unstable_extra));\n                 } else {\n+                    let mut ids = cx.id_map.borrow_mut();\n                     let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n                                         This is a nightly-only experimental API. {}\\\n                                         </summary>{}\",\n                                        unstable_extra,\n-                                       MarkdownHtml(&stab.unstable_reason));\n+                                       MarkdownHtml(\n+                                           &stab.unstable_reason,\n+                                           RefCell::new(&mut ids),\n+                                           error_codes));\n                     stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\",\n                                    text));\n                 }\n@@ -2579,14 +2570,15 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             String::new()\n         };\n \n+        let mut ids = cx.id_map.borrow_mut();\n         let text = if stability::deprecation_in_effect(&depr.since) {\n             format!(\"Deprecated{}{}\",\n                     since,\n-                    MarkdownHtml(&note))\n+                    MarkdownHtml(&note, RefCell::new(&mut ids), error_codes))\n         } else {\n             format!(\"Deprecating in {}{}\",\n                     Escape(&depr.since),\n-                    MarkdownHtml(&note))\n+                    MarkdownHtml(&note, RefCell::new(&mut ids), error_codes))\n         };\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n@@ -2827,8 +2819,8 @@ fn item_trait(\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let item_type = m.type_();\n-        let id = derive_id(format!(\"{}.{}\", item_type, name));\n-        let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n         write!(w, \"{extra}<h3 id='{id}' class='method'>\\\n                    <span id='{ns_id}' class='invisible'><code>\",\n                extra = render_spotlight_traits(m)?,\n@@ -3183,10 +3175,10 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                        document_non_exhaustive_header(it))?;\n             document_non_exhaustive(w, it)?;\n             for (field, ty) in fields {\n-                let id = derive_id(format!(\"{}.{}\",\n+                let id = cx.derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n                                            field.name.as_ref().unwrap()));\n-                let ns_id = derive_id(format!(\"{}.{}\",\n+                let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n                 write!(w, \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\n@@ -3317,10 +3309,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                    document_non_exhaustive_header(it))?;\n         document_non_exhaustive(w, it)?;\n         for variant in &e.variants {\n-            let id = derive_id(format!(\"{}.{}\",\n+            let id = cx.derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n                                        variant.name.as_ref().unwrap()));\n-            let ns_id = derive_id(format!(\"{}.{}\",\n+            let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                           variant.name.as_ref().unwrap(),\n                                           ItemType::Variant.name_space()));\n             write!(w, \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n@@ -3348,7 +3340,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             if let clean::VariantItem(Variant {\n                 kind: VariantKind::Struct(ref s)\n             }) = variant.inner {\n-                let variant_id = derive_id(format!(\"{}.{}.fields\",\n+                let variant_id = cx.derive_id(format!(\"{}.{}.fields\",\n                                                    ItemType::Variant,\n                                                    variant.name.as_ref().unwrap()));\n                 write!(w, \"<span class='docblock autohide sub-variant' id='{id}'>\",\n@@ -3358,10 +3350,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 for field in &s.fields {\n                     use clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n-                        let id = derive_id(format!(\"variant.{}.field.{}\",\n+                        let id = cx.derive_id(format!(\"variant.{}.field.{}\",\n                                                    variant.name.as_ref().unwrap(),\n                                                    field.name.as_ref().unwrap()));\n-                        let ns_id = derive_id(format!(\"{}.{}.{}.{}\",\n+                        let ns_id = cx.derive_id(format!(\"{}.{}.{}.{}\",\n                                                       variant.name.as_ref().unwrap(),\n                                                       ItemType::Variant.name_space(),\n                                                       field.name.as_ref().unwrap(),\n@@ -3790,7 +3782,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                render_mode: RenderMode, outer_version: Option<&str>,\n                show_def_docs: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n-        let id = derive_id(match i.inner_impl().trait_ {\n+        let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t))),\n             None => \"impl\".to_string(),\n         });\n@@ -3810,8 +3802,9 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n         write!(w, \"</span></td></tr></tbody></table></h3>\")?;\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n+            let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(&*dox, &i.impl_item.links()))?;\n+                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids), cx.codes))?;\n         }\n     }\n \n@@ -3832,8 +3825,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::TyMethodItem(clean::TyMethod{ ref decl, .. }) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n-                    let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                    let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                    let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                    let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                     write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                     write!(w, \"{}\", spotlight_decl(decl)?)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n@@ -3854,24 +3847,24 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n-                let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n@@ -3897,7 +3890,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         } else if show_def_docs {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, it, link, &prefix)?;\n+                            document_short(w, cx, it, link, &prefix)?;\n                         }\n                     }\n                 } else {\n@@ -3909,7 +3902,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             } else {\n                 document_stability(w, cx, item)?;\n                 if show_def_docs {\n-                    document_short(w, item, link, &prefix)?;\n+                    document_short(w, cx, item, link, &prefix)?;\n                 }\n             }\n         }\n@@ -4557,7 +4550,7 @@ impl<'a> fmt::Display for Source<'a> {\n         }\n         write!(fmt, \"</pre>\")?;\n         write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None, None))?;\n+               highlight::render_with_highlighting(s, None, None, None))?;\n         Ok(())\n     }\n }\n@@ -4568,7 +4561,6 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         w.write_str(&highlight::render_with_highlighting(&t.source,\n                                                          Some(\"macro\"),\n                                                          None,\n-                                                         None,\n                                                          None))\n     })?;\n     document(w, cx, it)\n@@ -4715,25 +4707,6 @@ pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }\n \n-#[cfg(test)]\n-#[test]\n-fn test_unique_id() {\n-    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n-                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n-                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n-    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n-                    \"method.into_iter-1\", \"foo-1\", \"main-1\", \"search-1\", \"methods-1\",\n-                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n-\n-    let test = || {\n-        let actual: Vec<String> = input.iter().map(|s| derive_id(s.to_string())).collect();\n-        assert_eq!(&actual[..], expected);\n-    };\n-    test();\n-    reset_ids(true);\n-    test();\n-}\n-\n #[cfg(test)]\n #[test]\n fn test_name_key() {"}, {"sha": "0a4955f4fbd10a83448eaee3a115d719b5191233", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -500,12 +500,14 @@ fn main_args(args: &[String]) -> isize {\n         }\n     }\n \n+    let mut id_map = html::markdown::IdMap::new();\n+    id_map.populate(html::render::initial_ids());\n     let external_html = match ExternalHtml::load(\n             &matches.opt_strs(\"html-in-header\"),\n             &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\"), &diag) {\n+            &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n         Some(eh) => eh,\n         None => return 3,\n     };\n@@ -562,7 +564,7 @@ fn main_args(args: &[String]) -> isize {\n                                   renderinfo,\n                                   sort_modules_alphabetically,\n                                   themes,\n-                                  enable_minification)\n+                                  enable_minification, id_map)\n                     .expect(\"failed to generate documentation\");\n                 0\n             }"}, {"sha": "05661dc6856637f0c97410136318d2e60e26da26", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -12,21 +12,22 @@ use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::{PathBuf, Path};\n+use std::cell::RefCell;\n \n use errors;\n use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{Externs, CodegenOptions};\n use syntax::codemap::DUMMY_SP;\n+use syntax::feature_gate::UnstableFeatures;\n use syntax::edition::Edition;\n \n use externalfiles::{ExternalHtml, LoadStringError, load_string};\n \n-use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n+use html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -86,12 +87,12 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n     }\n     let title = metadata[0];\n \n-    reset_ids(false);\n-\n+    let mut ids = IdMap::new();\n+    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let text = if include_toc {\n-        MarkdownWithToc(text).to_string()\n+        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes).to_string()\n     } else {\n-        Markdown(text, &[]).to_string()\n+        Markdown(text, &[], RefCell::new(&mut ids), error_codes).to_string()\n     };\n \n     let err = write!(\n@@ -156,7 +157,12 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                                        true, opts, maybe_sysroot, None,\n                                        Some(PathBuf::from(input)),\n                                        linker, edition);\n-    find_testable_code(&input_str, &mut collector, DUMMY_SP, None);\n+    collector.set_position(DUMMY_SP);\n+    let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+    let res = find_testable_code(&input_str, &mut collector, codes);\n+    if let Err(err) = res {\n+        diag.span_warn(DUMMY_SP, &err.to_string());\n+    }\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests,\n                        testing::Options::new().display_output(display_warnings));"}, {"sha": "650a2408aa6edba9d60ab6e73d67902ff8cc4e3a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -42,7 +42,7 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use clean::Attributes;\n-use html::markdown;\n+use html::markdown::{self, ErrorCodes, LangString};\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -145,7 +145,8 @@ pub fn run(input_path: &Path,\n             let mut hir_collector = HirCollector {\n                 sess: &sess,\n                 collector: &mut collector,\n-                map: &map\n+                map: &map,\n+                codes: ErrorCodes::from(sess.opts.unstable_features.is_nightly_build()),\n             };\n             hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n                 intravisit::walk_crate(this, krate);\n@@ -533,10 +534,8 @@ impl Collector {\n         format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n     }\n \n-    pub fn add_test(&mut self, test: String,\n-                    should_panic: bool, no_run: bool, should_ignore: bool,\n-                    as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n-                    line: usize, filename: FileName, allow_fail: bool) {\n+    pub fn add_test(&mut self, test: String, config: LangString, line: usize) {\n+        let filename = self.get_filename();\n         let name = self.generate_name(line, &filename);\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n@@ -551,10 +550,10 @@ impl Collector {\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n                 name: testing::DynTestName(name.clone()),\n-                ignore: should_ignore,\n+                ignore: config.ignore,\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n-                allow_fail,\n+                allow_fail: config.allow_fail,\n             },\n             testfn: testing::DynTestFn(box move || {\n                 let panic = io::set_panic(None);\n@@ -572,11 +571,11 @@ impl Collector {\n                                  libs,\n                                  cg,\n                                  externs,\n-                                 should_panic,\n-                                 no_run,\n-                                 as_test_harness,\n-                                 compile_fail,\n-                                 error_codes,\n+                                 config.should_panic,\n+                                 config.no_run,\n+                                 config.test_harness,\n+                                 config.compile_fail,\n+                                 config.error_codes,\n                                  &opts,\n                                  maybe_sysroot,\n                                  linker,\n@@ -604,7 +603,7 @@ impl Collector {\n         self.position = position;\n     }\n \n-    pub fn get_filename(&self) -> FileName {\n+    fn get_filename(&self) -> FileName {\n         if let Some(ref codemap) = self.codemap {\n             let filename = codemap.span_to_filename(self.position);\n             if let FileName::Real(ref filename) = filename {\n@@ -664,7 +663,8 @@ impl Collector {\n struct HirCollector<'a, 'hir: 'a> {\n     sess: &'a session::Session,\n     collector: &'a mut Collector,\n-    map: &'a hir::map::Map<'hir>\n+    map: &'a hir::map::Map<'hir>,\n+    codes: ErrorCodes,\n }\n \n impl<'a, 'hir> HirCollector<'a, 'hir> {\n@@ -689,10 +689,12 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         // the collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us\n         if let Some(doc) = attrs.collapsed_doc_value() {\n-            markdown::find_testable_code(&doc,\n-                                         self.collector,\n-                                         attrs.span.unwrap_or(DUMMY_SP),\n-                                         Some(self.sess));\n+            self.collector.set_position(attrs.span.unwrap_or(DUMMY_SP));\n+            let res = markdown::find_testable_code(&doc, self.collector, self.codes);\n+            if let Err(err) = res {\n+                self.sess.diagnostic().span_warn(attrs.span.unwrap_or(DUMMY_SP),\n+                    &err.to_string());\n+            }\n         }\n \n         nested(self);"}, {"sha": "dbc65569afa876bab3c59bd270d7073c4ccd9483", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -12,7 +12,7 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 26)' panicked at 'couldn't compile the test', librustdoc/test.rs:332:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 26)' panicked at 'couldn't compile the test', librustdoc/test.rs:333:13\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 20) stdout ----\n@@ -21,7 +21,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 20)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n-', librustdoc/test.rs:367:17\n+', librustdoc/test.rs:368:17\n \n \n failures:"}, {"sha": "40917cc5db0d5f6eba8086615706c1774d4d9793", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03df573c57b331df37fc3304c4d96293b069b522/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03df573c57b331df37fc3304c4d96293b069b522/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=03df573c57b331df37fc3304c4d96293b069b522", "patch": "@@ -21,10 +21,11 @@ use std::fs::{read_dir, File};\n use std::io::{Read, Write};\n use std::path::Path;\n use std::path::PathBuf;\n+use std::cell::RefCell;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -36,7 +37,7 @@ enum OutputFormat {\n impl OutputFormat {\n     fn from(format: &str) -> OutputFormat {\n         match &*format.to_lowercase() {\n-            \"html\"     => OutputFormat::HTML(HTMLFormatter),\n+            \"html\"     => OutputFormat::HTML(HTMLFormatter(RefCell::new(IdMap::new()))),\n             \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n             s          => OutputFormat::Unknown(s.to_owned()),\n         }\n@@ -51,7 +52,7 @@ trait Formatter {\n     fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n }\n \n-struct HTMLFormatter;\n+struct HTMLFormatter(RefCell<IdMap>);\n struct MarkdownFormatter;\n \n impl Formatter for HTMLFormatter {\n@@ -100,7 +101,11 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, &[]))?,\n+            Some(ref desc) => {\n+                let mut id_map = self.0.borrow_mut();\n+                write!(output, \"{}\",\n+                    Markdown(desc, &[], RefCell::new(&mut id_map), ErrorCodes::Yes))?\n+            },\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}