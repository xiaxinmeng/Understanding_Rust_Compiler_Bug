{"sha": "0728b710347aa80dfc05de29bfed4ed5fc023818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MjhiNzEwMzQ3YWE4MGRmYzA1ZGUyOWJmZWQ0ZWQ1ZmMwMjM4MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-06T09:43:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-06T09:43:37Z"}, "message": "Auto merge of #38833 - arielb1:constant-mir-overflow, r=eddyb\n\nfix promotion of MIR terminators\n\npromotion of MIR terminators used to try to promote the destination it\nis trying to promote, leading to stack overflow.\n\nAlso clean up the code in `promote_temp` a bit to make it more understandable.\n\nFixes #37991.\n\ncc @nikomatsakis\nr? @eddyb", "tree": {"sha": "b836125ef45999f285e9c92949bf4b3e8137b349", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b836125ef45999f285e9c92949bf4b3e8137b349"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0728b710347aa80dfc05de29bfed4ed5fc023818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0728b710347aa80dfc05de29bfed4ed5fc023818", "html_url": "https://github.com/rust-lang/rust/commit/0728b710347aa80dfc05de29bfed4ed5fc023818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0728b710347aa80dfc05de29bfed4ed5fc023818/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7907a9910f416f39f9d212f6d204b29061cc194", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7907a9910f416f39f9d212f6d204b29061cc194", "html_url": "https://github.com/rust-lang/rust/commit/e7907a9910f416f39f9d212f6d204b29061cc194"}, {"sha": "99aa48de2903f2b2a1fdc056f8791b21672f3346", "url": "https://api.github.com/repos/rust-lang/rust/commits/99aa48de2903f2b2a1fdc056f8791b21672f3346", "html_url": "https://github.com/rust-lang/rust/commit/99aa48de2903f2b2a1fdc056f8791b21672f3346"}], "stats": {"total": 166, "additions": 87, "deletions": 79}, "files": [{"sha": "2a4b2b515cc680e7bb67229d37ed1c77105b674e", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 66, "deletions": 78, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/0728b710347aa80dfc05de29bfed4ed5fc023818/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0728b710347aa80dfc05de29bfed4ed5fc023818/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=0728b710347aa80dfc05de29bfed4ed5fc023818", "patch": "@@ -66,6 +66,7 @@ impl TempState {\n /// A \"root candidate\" for promotion, which will become the\n /// returned value in a promoted MIR, unless it's a subset\n /// of a larger candidate.\n+#[derive(Debug)]\n pub enum Candidate {\n     /// Borrow of a constant temporary.\n     Ref(Location),\n@@ -190,15 +191,12 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     /// promoted MIR, recursing through temps.\n     fn promote_temp(&mut self, temp: Local) -> Local {\n         let old_keep_original = self.keep_original;\n-        let (bb, stmt_idx) = match self.temps[temp] {\n-            TempState::Defined {\n-                location: Location { block, statement_index },\n-                uses\n-            } if uses > 0 => {\n+        let loc = match self.temps[temp] {\n+            TempState::Defined { location, uses } if uses > 0 => {\n                 if uses > 1 {\n                     self.keep_original = true;\n                 }\n-                (block, statement_index)\n+                location\n             }\n             state =>  {\n                 span_bug!(self.promoted.span, \"{:?} not promotable: {:?}\",\n@@ -209,91 +207,80 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             self.temps[temp] = TempState::PromotedOut;\n         }\n \n-        let no_stmts = self.source[bb].statements.len();\n+        let no_stmts = self.source[loc.block].statements.len();\n+        let new_temp = self.promoted.local_decls.push(\n+            LocalDecl::new_temp(self.source.local_decls[temp].ty));\n+\n+        debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n+               temp, loc, no_stmts, self.keep_original);\n \n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n-        let (mut rvalue, mut call) = (None, None);\n-        let source_info = if stmt_idx < no_stmts {\n-            let statement = &mut self.source[bb].statements[stmt_idx];\n-            let rhs = match statement.kind {\n-                StatementKind::Assign(_, ref mut rhs) => rhs,\n-                _ => {\n-                    span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n-                              statement);\n-                }\n+        if loc.statement_index < no_stmts {\n+            let (mut rvalue, source_info) = {\n+                let statement = &mut self.source[loc.block].statements[loc.statement_index];\n+                let rhs = match statement.kind {\n+                    StatementKind::Assign(_, ref mut rhs) => rhs,\n+                    _ => {\n+                        span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n+                                  statement);\n+                    }\n+                };\n+\n+                (if self.keep_original {\n+                    rhs.clone()\n+                } else {\n+                    let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n+                    mem::replace(rhs, unit)\n+                }, statement.source_info)\n             };\n-            if self.keep_original {\n-                rvalue = Some(rhs.clone());\n-            } else {\n-                let unit = Rvalue::Aggregate(AggregateKind::Tuple, vec![]);\n-                rvalue = Some(mem::replace(rhs, unit));\n-            }\n-            statement.source_info\n-        } else if self.keep_original {\n-            let terminator = self.source[bb].terminator().clone();\n-            call = Some(terminator.kind);\n-            terminator.source_info\n+\n+            self.visit_rvalue(&mut rvalue, loc);\n+            self.assign(new_temp, rvalue, source_info.span);\n         } else {\n-            let terminator = self.source[bb].terminator_mut();\n-            let target = match terminator.kind {\n-                TerminatorKind::Call {\n-                    destination: ref mut dest @ Some(_),\n-                    ref mut cleanup, ..\n-                } => {\n-                    // No cleanup necessary.\n-                    cleanup.take();\n-\n-                    // We'll put a new destination in later.\n-                    dest.take().unwrap().1\n-                }\n-                ref kind => {\n-                    span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+            let mut terminator = if self.keep_original {\n+                self.source[loc.block].terminator().clone()\n+            } else {\n+                let terminator = self.source[loc.block].terminator_mut();\n+                let target = match terminator.kind {\n+                    TerminatorKind::Call { destination: Some((_, target)), .. } => target,\n+                    ref kind => {\n+                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                    }\n+                };\n+                Terminator {\n+                    source_info: terminator.source_info,\n+                    kind: mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n+                        target: target\n+                    })\n                 }\n             };\n-            call = Some(mem::replace(&mut terminator.kind, TerminatorKind::Goto {\n-                target: target\n-            }));\n-            terminator.source_info\n-        };\n \n-        // Then, recurse for components in the Rvalue or Call.\n-        if stmt_idx < no_stmts {\n-            self.visit_rvalue(rvalue.as_mut().unwrap(), Location {\n-                block: bb,\n-                statement_index: stmt_idx\n-            });\n-        } else {\n-            self.visit_terminator_kind(bb, call.as_mut().unwrap(), Location {\n-                block: bb,\n-                statement_index: no_stmts\n-            });\n-        }\n-\n-        let new_temp = self.promoted.local_decls.push(\n-            LocalDecl::new_temp(self.source.local_decls[temp].ty));\n-\n-        // Inject the Rvalue or Call into the promoted MIR.\n-        if stmt_idx < no_stmts {\n-            self.assign(new_temp, rvalue.unwrap(), source_info.span);\n-        } else {\n             let last = self.promoted.basic_blocks().last().unwrap();\n             let new_target = self.new_block();\n-            let mut call = call.unwrap();\n-            match call {\n-                TerminatorKind::Call { ref mut destination, ..}  => {\n-                    *destination = Some((Lvalue::Local(new_temp), new_target));\n+\n+            terminator.kind = match terminator.kind {\n+                TerminatorKind::Call { mut func, mut args, .. } => {\n+                    self.visit_operand(&mut func, loc);\n+                    for arg in &mut args {\n+                        self.visit_operand(arg, loc);\n+                    }\n+                    TerminatorKind::Call {\n+                        func: func,\n+                        args: args,\n+                        cleanup: None,\n+                        destination: Some((Lvalue::Local(new_temp), new_target))\n+                    }\n                 }\n-                _ => bug!()\n-            }\n-            let terminator = self.promoted[last].terminator_mut();\n-            terminator.source_info.span = source_info.span;\n-            terminator.kind = call;\n-        }\n+                ref kind => {\n+                    span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n+                }\n+            };\n \n-        // Restore the old duplication state.\n-        self.keep_original = old_keep_original;\n+            *self.promoted[last].terminator_mut() = terminator;\n+        };\n \n+        self.keep_original = old_keep_original;\n         new_temp\n     }\n \n@@ -355,6 +342,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     mut temps: IndexVec<Local, TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n+    debug!(\"promote_candidates({:?})\", candidates);\n     for candidate in candidates.into_iter().rev() {\n         let (span, ty) = match candidate {\n             Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {"}, {"sha": "d144651fb7db62e3e31391256b232e86f3ece4b6", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0728b710347aa80dfc05de29bfed4ed5fc023818/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0728b710347aa80dfc05de29bfed4ed5fc023818/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=0728b710347aa80dfc05de29bfed4ed5fc023818", "patch": "@@ -993,9 +993,9 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants {\n                     Entry::Vacant(entry) => {\n                         // Guard against `const` recursion.\n                         entry.insert(Qualif::RECURSIVE);\n+                        Mode::Const\n                     }\n                 }\n-                Mode::Const\n             }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,"}, {"sha": "cacc653871ad5c1687ca2d3302720fada8b4cc15", "filename": "src/test/run-pass/issue-37991.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0728b710347aa80dfc05de29bfed4ed5fc023818/src%2Ftest%2Frun-pass%2Fissue-37991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0728b710347aa80dfc05de29bfed4ed5fc023818/src%2Ftest%2Frun-pass%2Fissue-37991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37991.rs?ref=0728b710347aa80dfc05de29bfed4ed5fc023818", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+const fn foo() -> i64 {\n+    3\n+}\n+\n+fn main() {\n+    let val = &(foo() % 2);\n+    assert_eq!(*val, 1);\n+}"}]}