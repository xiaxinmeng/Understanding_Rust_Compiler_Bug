{"sha": "73a28e595c2aacf38c12a56807547e7cda6839ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYTI4ZTU5NWMyYWFjZjM4YzEyYTU2ODA3NTQ3ZTdjZGE2ODM5ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-01T23:15:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-01T23:15:41Z"}, "message": "auto merge of #8920 : Kimundi/rust/master, r=thestinger", "tree": {"sha": "7cfb11be2843774595371087f2829d0e2e830fe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cfb11be2843774595371087f2829d0e2e830fe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73a28e595c2aacf38c12a56807547e7cda6839ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73a28e595c2aacf38c12a56807547e7cda6839ee", "html_url": "https://github.com/rust-lang/rust/commit/73a28e595c2aacf38c12a56807547e7cda6839ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73a28e595c2aacf38c12a56807547e7cda6839ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4aba8cbf7caa3a82b52b6f171221ed6067eed5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4aba8cbf7caa3a82b52b6f171221ed6067eed5", "html_url": "https://github.com/rust-lang/rust/commit/1f4aba8cbf7caa3a82b52b6f171221ed6067eed5"}, {"sha": "857f8673206fd2d8803e02c68cdeb38e26b95df0", "url": "https://api.github.com/repos/rust-lang/rust/commits/857f8673206fd2d8803e02c68cdeb38e26b95df0", "html_url": "https://github.com/rust-lang/rust/commit/857f8673206fd2d8803e02c68cdeb38e26b95df0"}], "stats": {"total": 1024, "additions": 513, "deletions": 511}, "files": [{"sha": "5419ed3791b0bf59dd5eccbd282b1b046b8c2a0c", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -337,12 +337,12 @@ impl Session_ {\n     }\n \n     // pointless function, now...\n-    pub fn str_of(@self, id: ast::ident) -> @str {\n+    pub fn str_of(@self, id: ast::Ident) -> @str {\n         token::ident_to_str(&id)\n     }\n \n     // pointless function, now...\n-    pub fn ident_of(@self, st: &str) -> ast::ident {\n+    pub fn ident_of(@self, st: &str) -> ast::Ident {\n         token::str_to_ident(st)\n     }\n "}, {"sha": "e0914bcec6eaaade61f3078383e48552cf511365", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -30,7 +30,7 @@ type node_id_gen = @fn() -> ast::NodeId;\n \n struct Test {\n     span: Span,\n-    path: ~[ast::ident],\n+    path: ~[ast::Ident],\n     bench: bool,\n     ignore: bool,\n     should_fail: bool\n@@ -39,7 +39,7 @@ struct Test {\n struct TestCtxt {\n     sess: session::Session,\n     crate: @ast::Crate,\n-    path: ~[ast::ident],\n+    path: ~[ast::Ident],\n     ext_cx: @ExtCtxt,\n     testfns: ~[Test]\n }\n@@ -383,7 +383,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n     codemap::Spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(ids: ~[ast::ident]) -> ast::Path {\n+fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n     ast::Path {\n         span: dummy_sp(),\n         global: false,\n@@ -395,7 +395,7 @@ fn path_node(ids: ~[ast::ident]) -> ast::Path {\n     }\n }\n \n-fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n+fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n     ast::Path {\n         span: dummy_sp(),\n         global: true,"}, {"sha": "a1a07d8bf3f8483dbafb19a2fe02387c0baf33a5", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -25,7 +25,7 @@ use syntax::ast_map;\n use syntax::diagnostic::expect;\n \n pub struct StaticMethodInfo {\n-    ident: ast::ident,\n+    ident: ast::Ident,\n     def_id: ast::def_id,\n     purity: ast::purity\n }\n@@ -52,7 +52,7 @@ pub fn each_lang_item(cstore: @mut cstore::CStore,\n /// Iterates over each child of the given item.\n pub fn each_child_of_item(cstore: @mut cstore::CStore,\n                           def_id: ast::def_id,\n-                          callback: &fn(decoder::DefLike, ast::ident)) {\n+                          callback: &fn(decoder::DefLike, ast::Ident)) {\n     let crate_data = cstore::get_crate_data(cstore, def_id.crate);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -68,7 +68,7 @@ pub fn each_child_of_item(cstore: @mut cstore::CStore,\n pub fn each_top_level_item_of_crate(cstore: @mut cstore::CStore,\n                                     cnum: ast::CrateNum,\n                                     callback: &fn(decoder::DefLike,\n-                                                  ast::ident)) {\n+                                                  ast::Ident)) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -129,7 +129,7 @@ pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {\n \n pub fn get_method_name_and_explicit_self(cstore: @mut cstore::CStore,\n                                          def: ast::def_id)\n-                                     -> (ast::ident, ast::explicit_self_)\n+                                     -> (ast::Ident, ast::explicit_self_)\n {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_method_name_and_explicit_self(cstore.intr, cdata, def.node)\n@@ -156,7 +156,7 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[@ty::TraitRef] {\n }\n \n pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::def_id)\n-                          -> Option<ast::ident> {\n+                          -> Option<ast::Ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type_name_if_impl(cdata, def.node)\n }\n@@ -245,7 +245,7 @@ pub fn get_impl_vtables(tcx: ty::ctxt,\n \n pub fn get_impl_method(cstore: @mut cstore::CStore,\n                        def: ast::def_id,\n-                       mname: ast::ident)\n+                       mname: ast::Ident)\n                     -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)"}, {"sha": "0200ca49bad9af5ac972e7cd2836114b4f304a0c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -312,12 +312,12 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n     return result;\n }\n \n-fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n+fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::Ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n     match intr.find_equiv(&string) {\n         None => token::str_to_ident(string),\n-        Some(val) => ast::new_ident(val),\n+        Some(val) => ast::Ident::new(val),\n     }\n }\n \n@@ -452,7 +452,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n \n \n pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n-                       name: ast::ident) -> Option<ast::def_id> {\n+                       name: ast::Ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     do reader::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n@@ -706,7 +706,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                cdata: Cmd,\n                                item_doc: ebml::Doc,\n                                get_crate_data: GetCrateDataCb,\n-                               callback: &fn(DefLike, ast::ident)) {\n+                               callback: &fn(DefLike, ast::Ident)) {\n     // Iterate over all children.\n     let _ = do reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n         let child_def_id = reader::with_doc_data(child_info_doc,\n@@ -829,7 +829,7 @@ pub fn each_child_of_item(intr: @ident_interner,\n                           cdata: Cmd,\n                           id: ast::NodeId,\n                           get_crate_data: GetCrateDataCb,\n-                          callback: &fn(DefLike, ast::ident)) {\n+                          callback: &fn(DefLike, ast::Ident)) {\n     // Find the item.\n     let root_doc = reader::Doc(cdata.data);\n     let items = reader::get_doc(root_doc, tag_items);\n@@ -849,7 +849,7 @@ pub fn each_child_of_item(intr: @ident_interner,\n pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                     cdata: Cmd,\n                                     get_crate_data: GetCrateDataCb,\n-                                    callback: &fn(DefLike, ast::ident)) {\n+                                    callback: &fn(DefLike, ast::Ident)) {\n     let root_doc = reader::Doc(cdata.data);\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n@@ -995,7 +995,7 @@ pub fn get_impl(intr: @ident_interner, cdata: Cmd, impl_id: ast::NodeId,\n pub fn get_method_name_and_explicit_self(\n     intr: @ident_interner,\n     cdata: Cmd,\n-    id: ast::NodeId) -> (ast::ident, ast::explicit_self_)\n+    id: ast::NodeId) -> (ast::Ident, ast::explicit_self_)\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let name = item_name(intr, method_doc);\n@@ -1093,7 +1093,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n }\n \n pub fn get_type_name_if_impl(cdata: Cmd,\n-                             node_id: ast::NodeId) -> Option<ast::ident> {\n+                             node_id: ast::NodeId) -> Option<ast::Ident> {\n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != Impl {\n         return None;\n@@ -1352,7 +1352,7 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n #[deriving(Clone)]\n pub struct CrateDep {\n     cnum: ast::CrateNum,\n-    name: ast::ident,\n+    name: ast::Ident,\n     vers: @str,\n     hash: @str\n }"}, {"sha": "d2ad7889649948a3e131a24edb0e210ad903c969", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -102,13 +102,13 @@ pub fn reachable(ecx: &EncodeContext, id: NodeId) -> bool {\n \n fn encode_name(ecx: &EncodeContext,\n                ebml_w: &mut writer::Encoder,\n-               name: ident) {\n+               name: Ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n fn encode_impl_type_basename(ecx: &EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n-                             name: ident) {\n+                             name: Ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n                          ecx.tcx.sess.str_of(name));\n }\n@@ -135,9 +135,9 @@ struct entry<T> {\n }\n \n fn add_to_index(ebml_w: &mut writer::Encoder,\n-                path: &[ident],\n+                path: &[Ident],\n                 index: &mut ~[entry<~str>],\n-                name: ident) {\n+                name: Ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n     full_path.push(name);\n@@ -379,7 +379,7 @@ fn encode_reexported_static_method(ecx: &EncodeContext,\n                                    ebml_w: &mut writer::Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: def_id,\n-                                   method_ident: ident) {\n+                                   method_ident: Ident) {\n     debug!(\"(encode reexported static method) %s::%s\",\n             exp.name, ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n@@ -541,7 +541,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        md: &_mod,\n                        id: NodeId,\n                        path: &[ast_map::path_elt],\n-                       name: ident,\n+                       name: Ident,\n                        vis: visibility) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -700,7 +700,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n                                ebml_w: &mut writer::Encoder,\n                                path: &[ast_map::path_elt],\n-                               name: ast::ident,\n+                               name: ast::Ident,\n                                ctor_id: NodeId,\n                                index: @mut ~[entry<i64>]) {\n     index.push(entry { val: ctor_id as i64, pos: ebml_w.writer.tell() });"}, {"sha": "3e520522ba5adb5b2081e4442261ec52485b4b92", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -90,13 +90,13 @@ fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n     return op(st.data.slice(start_pos, end_pos));\n }\n \n-pub fn parse_ident(st: &mut PState, last: char) -> ast::ident {\n+pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n fn parse_ident_(st: &mut PState, is_last: @fn(char) -> bool) ->\n-   ast::ident {\n+   ast::Ident {\n     let rslt = scan(st, is_last, str::from_bytes);\n     return st.tcx.sess.ident_of(rslt);\n }\n@@ -130,7 +130,7 @@ pub fn parse_trait_ref_data(data: &[u8], crate_num: int, pos: uint, tcx: ty::ctx\n }\n \n fn parse_path(st: &mut PState) -> @ast::Path {\n-    let mut idents: ~[ast::ident] = ~[];\n+    let mut idents: ~[ast::Ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     idents.push(parse_ident_(st, is_last));\n     loop {"}, {"sha": "faf4ac76a039d560ca015c06bbe074d3ba72053d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -1256,7 +1256,7 @@ trait fake_ext_ctxt {\n     fn cfg(&self) -> ast::CrateConfig;\n     fn parse_sess(&self) -> @mut parse::ParseSess;\n     fn call_site(&self) -> Span;\n-    fn ident_of(&self, st: &str) -> ast::ident;\n+    fn ident_of(&self, st: &str) -> ast::Ident;\n }\n \n #[cfg(test)]\n@@ -1273,7 +1273,7 @@ impl fake_ext_ctxt for fake_session {\n             expn_info: None\n         }\n     }\n-    fn ident_of(&self, st: &str) -> ast::ident {\n+    fn ident_of(&self, st: &str) -> ast::Ident {\n         token::str_to_ident(st)\n     }\n }"}, {"sha": "a8de2c9e7732570962c85e5befeab6a0c3776193", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -488,7 +488,7 @@ impl CFGBuilder {\n \n     fn find_scope(&self,\n                   expr: @ast::expr,\n-                  label: Option<ast::ident>) -> LoopScope {\n+                  label: Option<ast::Ident>) -> LoopScope {\n         match label {\n             None => {\n                 return *self.loop_scopes.last();"}, {"sha": "42dae2017bc8bdcb2eed2d3b7a95f3b1c138878e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -867,7 +867,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n     fn find_scope<'a>(&self,\n                       expr: @ast::expr,\n-                      label: Option<ast::ident>,\n+                      label: Option<ast::Ident>,\n                       loop_scopes: &'a mut ~[LoopScope]) -> &'a mut LoopScope {\n         let index = match label {\n             None => {"}, {"sha": "1ad6e409fc3645bc08f2dc6c7cb1bf0eb9469a9b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -1033,7 +1033,7 @@ fn lint_path_statement() -> @mut OuterLint {\n }\n \n fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n-    fn is_camel_case(cx: ty::ctxt, ident: ast::ident) -> bool {\n+    fn is_camel_case(cx: ty::ctxt, ident: ast::Ident) -> bool {\n         let ident = cx.sess.str_of(ident);\n         assert!(!ident.is_empty());\n         let ident = ident.trim_chars(&'_');\n@@ -1044,7 +1044,7 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n             !ident.contains_char('_')\n     }\n \n-    fn check_case(cx: &Context, sort: &str, ident: ast::ident, span: Span) {\n+    fn check_case(cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         if !is_camel_case(cx.tcx, ident) {\n             cx.span_lint(\n                 non_camel_case_types, span,"}, {"sha": "cbfab25f133710385a621477f18047b711c7d437", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -227,13 +227,13 @@ enum LocalKind {\n \n struct LocalInfo {\n     id: NodeId,\n-    ident: ident,\n+    ident: Ident,\n     is_mutbl: bool,\n     kind: LocalKind,\n }\n \n enum VarKind {\n-    Arg(NodeId, ident),\n+    Arg(NodeId, Ident),\n     Local(LocalInfo),\n     ImplicitRet\n }\n@@ -756,7 +756,7 @@ impl Liveness {\n     }\n \n     pub fn find_loop_scope(&self,\n-                           opt_label: Option<ident>,\n+                           opt_label: Option<Ident>,\n                            id: NodeId,\n                            sp: Span)\n                            -> NodeId {"}, {"sha": "1fc670312f0c6f15ff0ac73c74e954148680472a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -99,7 +99,7 @@ pub enum InteriorKind {\n \n #[deriving(Eq, IterBytes)]\n pub enum FieldName {\n-    NamedField(ast::ident),\n+    NamedField(ast::Ident),\n     PositionalField(uint)\n }\n \n@@ -613,7 +613,7 @@ impl mem_categorization_ctxt {\n     pub fn cat_field<N:ast_node>(&self,\n                                  node: N,\n                                  base_cmt: cmt,\n-                                 f_name: ast::ident,\n+                                 f_name: ast::Ident,\n                                  f_ty: ty::t)\n                                  -> cmt {\n         @cmt_ {\n@@ -1058,7 +1058,7 @@ impl mem_categorization_ctxt {\n /// an enum to determine which variant is in use.\n pub fn field_mutbl(tcx: ty::ctxt,\n                    base_ty: ty::t,\n-                   f_name: ast::ident,\n+                   f_name: ast::Ident,\n                    node_id: ast::NodeId)\n                 -> Option<ast::mutability> {\n     // Need to refactor so that struct/enum fields can be treated uniformly."}, {"sha": "a41ab09fdbb796396816e15ede3e77d400e796ac", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -16,7 +16,7 @@ use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::Span;\n \n-pub type PatIdMap = HashMap<ident, NodeId>;\n+pub type PatIdMap = HashMap<Ident, NodeId>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern."}, {"sha": "5c7ab126c91604f34cc0ec6ab2da3e554f1fc426", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::{method_static, method_object};\n use std::util::ignore;\n use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n-use syntax::ast::{expr_struct, expr_unary, ident, inherited, item_enum};\n+use syntax::ast::{expr_struct, expr_unary, Ident, inherited, item_enum};\n use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n use syntax::ast::{item_trait, LOCAL_CRATE, NodeId, pat_struct, Path};\n use syntax::ast::{private, provided, public, required, stmt_decl, visibility};\n@@ -203,7 +203,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private field is in scope.\n-    fn check_field(&mut self, span: Span, id: ast::def_id, ident: ast::ident) {\n+    fn check_field(&mut self, span: Span, id: ast::def_id, ident: ast::Ident) {\n         let fields = ty::lookup_struct_fields(self.tcx, id);\n         for field in fields.iter() {\n             if field.ident != ident { loop; }\n@@ -216,7 +216,7 @@ impl PrivacyVisitor {\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_method_common(&mut self, span: Span, method_id: def_id, name: &ident) {\n+    fn check_method_common(&mut self, span: Span, method_id: def_id, name: &Ident) {\n         // If the method is a default method, we need to use the def_id of\n         // the default implementation.\n         // Having to do this this is really unfortunate.\n@@ -280,7 +280,7 @@ impl PrivacyVisitor {\n     }\n \n     // Checks that a private method is in scope.\n-    fn check_method(&mut self, span: Span, origin: &method_origin, ident: ast::ident) {\n+    fn check_method(&mut self, span: Span, origin: &method_origin, ident: ast::Ident) {\n         match *origin {\n             method_static(method_id) => {\n                 self.check_method_common(span, method_id, &ident)"}, {"sha": "05545862f90081dd7a04ebf176bf2c2d59c7fd10", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -51,7 +51,7 @@ pub struct binding_info {\n }\n \n // Map from the name in a pattern to its binding mode.\n-pub type BindingMap = HashMap<ident,binding_info>;\n+pub type BindingMap = HashMap<Ident,binding_info>;\n \n // Trait method resolution\n pub type TraitMap = HashMap<NodeId,@mut ~[def_id]>;\n@@ -162,7 +162,7 @@ impl Visitor<()> for ResolveVisitor {\n \n /// Contains data for specific types of import directives.\n pub enum ImportDirectiveSubclass {\n-    SingleImport(ident /* target */, ident /* source */),\n+    SingleImport(Ident /* target */, Ident /* source */),\n     GlobImport\n }\n \n@@ -311,7 +311,7 @@ pub enum DuplicateCheckingMode {\n \n /// One local scope.\n pub struct Rib {\n-    bindings: @mut HashMap<ident, DefLike>,\n+    bindings: @mut HashMap<Ident, DefLike>,\n     self_binding: @mut Option<DefLike>,\n     kind: RibKind,\n }\n@@ -329,15 +329,15 @@ impl Rib {\n /// One import directive.\n pub struct ImportDirective {\n     privacy: Privacy,\n-    module_path: ~[ident],\n+    module_path: ~[Ident],\n     subclass: @ImportDirectiveSubclass,\n     span: Span,\n     id: NodeId,\n }\n \n impl ImportDirective {\n     pub fn new(privacy: Privacy,\n-               module_path: ~[ident],\n+               module_path: ~[Ident],\n                subclass: @ImportDirectiveSubclass,\n                span: Span,\n                id: NodeId)\n@@ -425,7 +425,7 @@ impl ImportResolution {\n /// The link from a module up to its nearest parent node.\n pub enum ParentLink {\n     NoParentLink,\n-    ModuleParentLink(@mut Module, ident),\n+    ModuleParentLink(@mut Module, Ident),\n     BlockParentLink(@mut Module, NodeId)\n }\n \n@@ -445,12 +445,12 @@ pub struct Module {\n     def_id: Option<def_id>,\n     kind: ModuleKind,\n \n-    children: @mut HashMap<ident, @mut NameBindings>,\n+    children: @mut HashMap<Ident, @mut NameBindings>,\n     imports: @mut ~[@ImportDirective],\n \n     // The external module children of this node that were declared with\n     // `extern mod`.\n-    external_module_children: @mut HashMap<ident, @mut Module>,\n+    external_module_children: @mut HashMap<Ident, @mut Module>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n     // modules that are implicitly created around items contained within\n@@ -469,7 +469,7 @@ pub struct Module {\n     anonymous_children: @mut HashMap<NodeId,@mut Module>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: @mut HashMap<ident, @mut ImportResolution>,\n+    import_resolutions: @mut HashMap<Ident, @mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     glob_count: uint,\n@@ -759,7 +759,7 @@ pub fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n pub struct PrimitiveTypeTable {\n-    primitive_types: HashMap<ident,prim_ty>,\n+    primitive_types: HashMap<Ident,prim_ty>,\n }\n \n impl PrimitiveTypeTable {\n@@ -873,7 +873,7 @@ pub struct Resolver {\n \n     graph_root: @mut NameBindings,\n \n-    method_map: @mut HashMap<ident, HashSet<def_id>>,\n+    method_map: @mut HashMap<Ident, HashSet<def_id>>,\n     structs: HashSet<def_id>,\n \n     // The number of imports that are currently unresolved.\n@@ -900,9 +900,9 @@ pub struct Resolver {\n     current_trait_refs: Option<~[def_id]>,\n \n     // The ident for the keyword \"self\".\n-    self_ident: ident,\n+    self_ident: Ident,\n     // The ident for the non-keyword \"Self\".\n-    type_self_ident: ident,\n+    type_self_ident: Ident,\n \n     // The idents for the primitive types.\n     primitive_type_table: @PrimitiveTypeTable,\n@@ -1017,7 +1017,7 @@ impl Resolver {\n      * a block, fails.\n      */\n     pub fn add_child(@mut self,\n-                     name: ident,\n+                     name: Ident,\n                      reduced_graph_parent: ReducedGraphParent,\n                      duplicate_checking_mode: DuplicateCheckingMode,\n                      // For printing errors\n@@ -1153,7 +1153,7 @@ impl Resolver {\n         return false;\n     }\n \n-    pub fn get_parent_link(@mut self, parent: ReducedGraphParent, name: ident)\n+    pub fn get_parent_link(@mut self, parent: ReducedGraphParent, name: Ident)\n                            -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n@@ -1659,7 +1659,7 @@ impl Resolver {\n                            visibility: ast::visibility,\n                            child_name_bindings: @mut NameBindings,\n                            final_ident: &str,\n-                           ident: ident,\n+                           ident: Ident,\n                            new_parent: ReducedGraphParent) {\n         let privacy = visibility_to_privacy(visibility);\n         match def {\n@@ -1783,7 +1783,7 @@ impl Resolver {\n     fn build_reduced_graph_for_external_crate_def(@mut self,\n                                                   root: @mut Module,\n                                                   def_like: DefLike,\n-                                                  ident: ident) {\n+                                                  ident: Ident) {\n         match def_like {\n             DlDef(def) => {\n                 // Add the new child item, if necessary.\n@@ -1962,7 +1962,7 @@ impl Resolver {\n     pub fn build_import_directive(@mut self,\n                                   privacy: Privacy,\n                                   module_: @mut Module,\n-                                  module_path: ~[ident],\n+                                  module_path: ~[Ident],\n                                   subclass: @ImportDirectiveSubclass,\n                                   span: Span,\n                                   id: NodeId) {\n@@ -2107,7 +2107,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn idents_to_str(@mut self, idents: &[ident]) -> ~str {\n+    pub fn idents_to_str(@mut self, idents: &[Ident]) -> ~str {\n         let mut first = true;\n         let mut result = ~\"\";\n         for ident in idents.iter() {\n@@ -2122,7 +2122,7 @@ impl Resolver {\n     }\n \n     fn path_idents_to_str(@mut self, path: &Path) -> ~str {\n-        let identifiers: ~[ast::ident] = path.segments\n+        let identifiers: ~[ast::Ident] = path.segments\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n                                              .collect();\n@@ -2139,7 +2139,7 @@ impl Resolver {\n     }\n \n     pub fn import_path_to_str(@mut self,\n-                              idents: &[ident],\n+                              idents: &[Ident],\n                               subclass: ImportDirectiveSubclass)\n                               -> @str {\n         if idents.is_empty() {\n@@ -2262,8 +2262,8 @@ impl Resolver {\n     pub fn resolve_single_import(@mut self,\n                                  module_: @mut Module,\n                                  containing_module: @mut Module,\n-                                 target: ident,\n-                                 source: ident,\n+                                 target: Ident,\n+                                 source: Ident,\n                                  directive: &ImportDirective)\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n@@ -2620,7 +2620,7 @@ impl Resolver {\n     /// Resolves the given module path from the given root `module_`.\n     pub fn resolve_module_path_from_root(@mut self,\n                                          module_: @mut Module,\n-                                         module_path: &[ident],\n+                                         module_path: &[Ident],\n                                          index: uint,\n                                          span: Span,\n                                          mut name_search_type: NameSearchType)\n@@ -2729,7 +2729,7 @@ impl Resolver {\n     /// rooted at the given module.\n     pub fn resolve_module_path(@mut self,\n                                module_: @mut Module,\n-                               module_path: &[ident],\n+                               module_path: &[Ident],\n                                use_lexical_scope: UseLexicalScopeFlag,\n                                span: Span,\n                                name_search_type: NameSearchType)\n@@ -2822,7 +2822,7 @@ impl Resolver {\n     /// import resolution.\n     pub fn resolve_item_in_lexical_scope(@mut self,\n                                          module_: @mut Module,\n-                                         name: ident,\n+                                         name: Ident,\n                                          namespace: Namespace,\n                                          search_through_modules:\n                                          SearchThroughModulesFlag)\n@@ -2951,7 +2951,7 @@ impl Resolver {\n     /// Resolves a module name in the current lexical scope.\n     pub fn resolve_module_in_lexical_scope(@mut self,\n                                            module_: @mut Module,\n-                                           name: ident)\n+                                           name: Ident)\n                                            -> ResolveResult<@mut Module> {\n         // If this module is an anonymous module, resolve the item in the\n         // lexical scope. Otherwise, resolve the item from the crate root.\n@@ -3038,7 +3038,7 @@ impl Resolver {\n     /// (b) some chain of `super::`.\n     pub fn resolve_module_prefix(@mut self,\n                                  module_: @mut Module,\n-                                 module_path: &[ident])\n+                                 module_path: &[Ident])\n                                  -> ResolveResult<ModulePrefixResult> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n@@ -3081,7 +3081,7 @@ impl Resolver {\n     /// the name.\n     pub fn resolve_name_in_module(@mut self,\n                                   module_: @mut Module,\n-                                  name: ident,\n+                                  name: Ident,\n                                   namespace: Namespace,\n                                   name_search_type: NameSearchType)\n                                   -> ResolveResult<Target> {\n@@ -3273,7 +3273,7 @@ impl Resolver {\n \n     pub fn add_exports_of_namebindings(@mut self,\n                                        exports2: &mut ~[Export2],\n-                                       ident: ident,\n+                                       ident: Ident,\n                                        namebindings: @mut NameBindings,\n                                        ns: Namespace,\n                                        reexport: bool) {\n@@ -3344,7 +3344,7 @@ impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    pub fn with_scope(@mut self, name: Option<ident>, f: &fn()) {\n+    pub fn with_scope(@mut self, name: Option<Ident>, f: &fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3498,7 +3498,7 @@ impl Resolver {\n \n     pub fn search_ribs(@mut self,\n                        ribs: &mut ~[@Rib],\n-                       name: ident,\n+                       name: Ident,\n                        span: Span,\n                        allow_capturing_self: AllowCapturingSelfFlag)\n                        -> Option<DefLike> {\n@@ -3892,7 +3892,7 @@ impl Resolver {\n                           generics: &Generics,\n                           fields: &[@struct_field],\n                           visitor: &mut ResolveVisitor) {\n-        let mut ident_map: HashMap<ast::ident,@struct_field> = HashMap::new();\n+        let mut ident_map: HashMap<ast::Ident,@struct_field> = HashMap::new();\n         for &field in fields.iter() {\n             match field.node.kind {\n                 named_field(ident, _) => {\n@@ -4035,7 +4035,7 @@ impl Resolver {\n     pub fn resolve_module(@mut self,\n                           module_: &_mod,\n                           _span: Span,\n-                          _name: ident,\n+                          _name: Ident,\n                           id: NodeId,\n                           visitor: &mut ResolveVisitor) {\n         // Write the implementations in scope into the module metadata.\n@@ -4272,7 +4272,7 @@ impl Resolver {\n                            mutability: Mutability,\n                            // Maps idents to the node ID for the (outermost)\n                            // pattern that binds them\n-                           bindings_list: Option<@mut HashMap<ident,NodeId>>,\n+                           bindings_list: Option<@mut HashMap<Ident,NodeId>>,\n                            visitor: &mut ResolveVisitor) {\n         let pat_id = pattern.id;\n         do walk_pat(pattern) |pattern| {\n@@ -4517,7 +4517,7 @@ impl Resolver {\n         };\n     }\n \n-    pub fn resolve_bare_identifier_pattern(@mut self, name: ident)\n+    pub fn resolve_bare_identifier_pattern(@mut self, name: Ident)\n                                            ->\n                                            BareIdentifierPatternResolution {\n         match self.resolve_item_in_lexical_scope(self.current_module,\n@@ -4604,7 +4604,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_identifier(@mut self,\n-                              identifier: ident,\n+                              identifier: Ident,\n                               namespace: Namespace,\n                               check_ribs: bool,\n                               span: Span)\n@@ -4629,7 +4629,7 @@ impl Resolver {\n     // FIXME #4952: Merge me with resolve_name_in_module?\n     pub fn resolve_definition_of_name_in_module(@mut self,\n                                                 containing_module: @mut Module,\n-                                                name: ident,\n+                                                name: Ident,\n                                                 namespace: Namespace,\n                                                 xray: XrayFlag)\n                                                 -> NameDefinition {\n@@ -4702,7 +4702,7 @@ impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[ident] {\n+    pub fn intern_module_part_of_path(@mut self, path: &Path) -> ~[Ident] {\n         let mut module_path_idents = ~[];\n         for (index, segment) in path.segments.iter().enumerate() {\n             if index == path.segments.len() - 1 {\n@@ -4829,7 +4829,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_identifier_in_local_ribs(@mut self,\n-                                            ident: ident,\n+                                            ident: Ident,\n                                             namespace: Namespace,\n                                             span: Span)\n                                             -> Option<def> {\n@@ -4895,7 +4895,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_item_by_identifier_in_lexical_scope(@mut self,\n-                                                       ident: ident,\n+                                                       ident: Ident,\n                                                        namespace: Namespace)\n                                                        -> Option<def> {\n         // Check the items.\n@@ -5273,7 +5273,7 @@ impl Resolver {\n         }\n     }\n \n-    pub fn search_for_traits_containing_method(@mut self, name: ident)\n+    pub fn search_for_traits_containing_method(@mut self, name: Ident)\n                                                -> ~[def_id] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                self.session.str_of(name));\n@@ -5376,7 +5376,7 @@ impl Resolver {\n     pub fn add_trait_info(&self,\n                           found_traits: &mut ~[def_id],\n                           trait_def_id: def_id,\n-                          name: ident) {\n+                          name: Ident) {\n         debug!(\"(adding trait info) found trait %d:%d for method '%s'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n@@ -5493,7 +5493,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::ident]>());\n+        return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::Ident]>());\n     }\n \n     pub fn dump_module(@mut self, module_: @mut Module) {"}, {"sha": "e42700fea76fd3220c10130f2c7a5ce0bfdb5661", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -222,7 +222,7 @@ use util::ppaux::{Repr, vec_map_to_str};\n use std::hashmap::HashMap;\n use std::vec;\n use syntax::ast;\n-use syntax::ast::ident;\n+use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n use syntax::ast_util;\n use syntax::codemap::{Span, dummy_sp};\n@@ -390,7 +390,7 @@ struct BindingInfo {\n     ty: ty::t,\n }\n \n-type BindingsMap = HashMap<ident, BindingInfo>;\n+type BindingsMap = HashMap<Ident, BindingInfo>;\n \n #[deriving(Clone)]\n struct ArmData<'self> {\n@@ -409,7 +409,7 @@ struct ArmData<'self> {\n struct Match<'self> {\n     pats: ~[@ast::pat],\n     data: ArmData<'self>,\n-    bound_ptrs: ~[(ident, ValueRef)]\n+    bound_ptrs: ~[(Ident, ValueRef)]\n }\n \n impl<'self> Repr for Match<'self> {\n@@ -736,7 +736,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n                                dm: DefMap,\n                                m: &[Match<'r>],\n                                col: uint,\n-                               fields: &[ast::ident],\n+                               fields: &[ast::Ident],\n                                val: ValueRef)\n                             -> ~[Match<'r>] {\n     debug!(\"enter_rec_or_struct(bcx=%s, m=%s, col=%u, val=%s)\",\n@@ -1076,8 +1076,8 @@ fn extract_vec_elems(bcx: @mut Block,\n fn collect_record_or_struct_fields(bcx: @mut Block,\n                                        m: &[Match],\n                                        col: uint)\n-                                    -> Option<~[ast::ident]> {\n-    let mut fields: ~[ast::ident] = ~[];\n+                                    -> Option<~[ast::Ident]> {\n+    let mut fields: ~[ast::Ident] = ~[];\n     let mut found = false;\n     for br in m.iter() {\n         match br.pats[col].node {\n@@ -1099,7 +1099,7 @@ fn collect_record_or_struct_fields(bcx: @mut Block,\n         return None;\n     }\n \n-    fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n+    fn extend(idents: &mut ~[ast::Ident], field_pats: &[ast::field_pat]) {\n         for field_pat in field_pats.iter() {\n             let field_ident = field_pat.ident;\n             if !idents.iter().any(|x| *x == field_ident) {"}, {"sha": "79440b03d761f8b26dcebc48d9ef72161dd56bf0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -76,7 +76,7 @@ use std::vec;\n use std::local_data;\n use extra::time;\n use extra::sort;\n-use syntax::ast::ident;\n+use syntax::ast::Ident;\n use syntax::ast_map::{path, path_elt_to_str, path_name};\n use syntax::ast_util::{local_def};\n use syntax::attr;\n@@ -1203,7 +1203,7 @@ pub fn scope_block(bcx: @mut Block,\n \n pub fn loop_scope_block(bcx: @mut Block,\n                         loop_break: @mut Block,\n-                        loop_label: Option<ident>,\n+                        loop_label: Option<Ident>,\n                         n: &str,\n                         opt_node_info: Option<NodeInfo>) -> @mut Block {\n     return new_block(bcx.fcx, Some(bcx), Some(@mut ScopeInfo {"}, {"sha": "9b608d126695068ca9afa1e880a887d8e131d585", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -38,15 +38,15 @@ use std::cast;\n use std::hashmap::{HashMap};\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n use std::vec;\n-use syntax::ast::ident;\n+use syntax::ast::Ident;\n use syntax::ast_map::{path, path_elt};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_map};\n \n pub use middle::trans::context::CrateContext;\n \n-pub fn gensym_name(name: &str) -> ident {\n+pub fn gensym_name(name: &str) -> Ident {\n     token::str_to_ident(fmt!(\"%s_%u\", name, token::gensym(name)))\n }\n \n@@ -460,7 +460,7 @@ pub fn block_cleanups(bcx: @mut Block) -> ~[cleanup] {\n pub struct ScopeInfo {\n     parent: Option<@mut ScopeInfo>,\n     loop_break: Option<@mut Block>,\n-    loop_label: Option<ident>,\n+    loop_label: Option<Ident>,\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n@@ -562,7 +562,7 @@ impl Block {\n     pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n-    pub fn ident(&self, ident: ident) -> @str {\n+    pub fn ident(&self, ident: Ident) -> @str {\n         token::ident_to_str(&ident)\n     }\n "}, {"sha": "02659b99afcf7262331d1d05376cafa7b6871042", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -87,7 +87,7 @@ pub struct CrateContext {\n      // Cache of external const values\n      extern_const_values: HashMap<ast::def_id, ValueRef>,\n \n-     impl_method_cache: HashMap<(ast::def_id, ast::ident), ast::def_id>,\n+     impl_method_cache: HashMap<(ast::def_id, ast::Ident), ast::def_id>,\n \n      module_data: HashMap<~str, ValueRef>,\n      lltypes: HashMap<ty::t, Type>,"}, {"sha": "be4fef369347874866649cc9b471bbdedaef284b", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -27,7 +27,7 @@ use util::ppaux;\n use middle::trans::type_::Type;\n \n use syntax::ast;\n-use syntax::ast::ident;\n+use syntax::ast::Ident;\n use syntax::ast_map::path_mod;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -194,7 +194,7 @@ pub fn trans_while(bcx: @mut Block, cond: @ast::expr, body: &ast::Block) -> @mut\n \n pub fn trans_loop(bcx:@mut Block,\n                   body: &ast::Block,\n-                  opt_label: Option<ident>)\n+                  opt_label: Option<Ident>)\n                -> @mut Block {\n     let _icx = push_ctxt(\"trans_loop\");\n     let next_bcx = sub_block(bcx, \"next\");\n@@ -273,7 +273,7 @@ pub fn trans_log(log_ex: &ast::expr,\n }\n \n pub fn trans_break_cont(bcx: @mut Block,\n-                        opt_label: Option<ident>,\n+                        opt_label: Option<Ident>,\n                         to_end: bool)\n                      -> @mut Block {\n     let _icx = push_ctxt(\"trans_break_cont\");\n@@ -326,11 +326,11 @@ pub fn trans_break_cont(bcx: @mut Block,\n     return bcx;\n }\n \n-pub fn trans_break(bcx: @mut Block, label_opt: Option<ident>) -> @mut Block {\n+pub fn trans_break(bcx: @mut Block, label_opt: Option<Ident>) -> @mut Block {\n     return trans_break_cont(bcx, label_opt, true);\n }\n \n-pub fn trans_cont(bcx: @mut Block, label_opt: Option<ident>) -> @mut Block {\n+pub fn trans_cont(bcx: @mut Block, label_opt: Option<Ident>) -> @mut Block {\n     return trans_break_cont(bcx, label_opt, false);\n }\n "}, {"sha": "b69b9b308ba44a611a525b7dc5c60c2fb483daa3", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -155,7 +155,7 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata(bcx: @mut Block,\n-                                     variable_ident: ast::ident,\n+                                     variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n                                      span: Span) {\n@@ -640,7 +640,7 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n }\n \n fn declare_local(bcx: @mut Block,\n-                 variable_ident: ast::ident,\n+                 variable_ident: ast::Ident,\n                  node_id: ast::NodeId,\n                  variable_type: ty::t,\n                  span: Span) {\n@@ -1539,7 +1539,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n \n     struct ScopeStackEntry {\n         scope_metadata: DIScope,\n-        ident: Option<ast::ident>\n+        ident: Option<ast::Ident>\n     }\n \n     let mut scope_stack = ~[ScopeStackEntry { scope_metadata: fn_metadata, ident: None }];"}, {"sha": "1aedf1ab62358c03ec155fc8e4cfc3f9b7c465f9", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -894,7 +894,7 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: @ast::expr) -> DatumBlock {\n \n     fn trans_rec_field(bcx: @mut Block,\n                        base: @ast::expr,\n-                       field: ast::ident) -> DatumBlock {\n+                       field: ast::Ident) -> DatumBlock {\n         //! Translates `base.field`.\n \n         let mut bcx = bcx;"}, {"sha": "fa10b8a8e44931e42fd38eeb0a4d9dd57cf7afe3", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -47,7 +47,7 @@ see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n pub fn trans_impl(ccx: @mut CrateContext,\n                   path: path,\n-                  name: ast::ident,\n+                  name: ast::Ident,\n                   methods: &[@ast::method],\n                   generics: &ast::Generics,\n                   id: ast::NodeId) {\n@@ -294,7 +294,7 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n \n pub fn method_with_name(ccx: &mut CrateContext,\n                         impl_id: ast::def_id,\n-                        name: ast::ident) -> ast::def_id {\n+                        name: ast::Ident) -> ast::def_id {\n     let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n     match meth_id_opt {\n         Some(m) => return m,"}, {"sha": "c548b18f72c89fe8b8dfac3f2c30d555c3833892", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -56,7 +56,7 @@ pub static INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n \n #[deriving(Eq, IterBytes)]\n pub struct field {\n-    ident: ast::ident,\n+    ident: ast::Ident,\n     mt: mt\n }\n \n@@ -68,7 +68,7 @@ pub enum MethodContainer {\n \n #[deriving(Clone)]\n pub struct Method {\n-    ident: ast::ident,\n+    ident: ast::Ident,\n     generics: ty::Generics,\n     transformed_self_ty: Option<ty::t>,\n     fty: BareFnTy,\n@@ -82,7 +82,7 @@ pub struct Method {\n }\n \n impl Method {\n-    pub fn new(ident: ast::ident,\n+    pub fn new(ident: ast::Ident,\n                generics: ty::Generics,\n                transformed_self_ty: Option<ty::t>,\n                fty: BareFnTy,\n@@ -122,7 +122,7 @@ impl Method {\n \n pub struct Impl {\n     did: def_id,\n-    ident: ident,\n+    ident: Ident,\n     methods: ~[@Method]\n }\n \n@@ -156,7 +156,7 @@ pub enum SelfMode {\n }\n \n pub struct field_ty {\n-    ident: ident,\n+    ident: Ident,\n     id: def_id,\n     vis: ast::visibility,\n }\n@@ -431,7 +431,7 @@ pub struct ClosureTy {\n  * - `output` is the return type. */\n #[deriving(Clone, Eq, IterBytes)]\n pub struct FnSig {\n-    bound_lifetime_names: OptVec<ast::ident>,\n+    bound_lifetime_names: OptVec<ast::Ident>,\n     inputs: ~[t],\n     output: t\n }\n@@ -504,7 +504,7 @@ pub enum bound_region {\n     br_anon(uint),\n \n     /// Named region parameters for functions (a in &'a T)\n-    br_named(ast::ident),\n+    br_named(ast::Ident),\n \n     /// Fresh bound identifiers created during GLB computations.\n     br_fresh(uint),\n@@ -684,7 +684,7 @@ pub enum type_err {\n     terr_ty_param_size(expected_found<uint>),\n     terr_record_size(expected_found<uint>),\n     terr_record_mutability,\n-    terr_record_fields(expected_found<ident>),\n+    terr_record_fields(expected_found<Ident>),\n     terr_arg_count,\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n@@ -693,7 +693,7 @@ pub enum type_err {\n     terr_regions_overly_polymorphic(bound_region, Region),\n     terr_vstores_differ(terr_vstore_kind, expected_found<vstore>),\n     terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n-    terr_in_field(@type_err, ast::ident),\n+    terr_in_field(@type_err, ast::Ident),\n     terr_sorts(expected_found<t>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n@@ -848,7 +848,7 @@ impl ToStr for IntVarValue {\n \n #[deriving(Clone)]\n pub struct TypeParameterDef {\n-    ident: ast::ident,\n+    ident: ast::Ident,\n     def_id: ast::def_id,\n     bounds: @ParamBounds\n }\n@@ -3359,13 +3359,13 @@ pub fn stmt_node_id(s: &ast::stmt) -> ast::NodeId {\n     }\n }\n \n-pub fn field_idx(id: ast::ident, fields: &[field]) -> Option<uint> {\n+pub fn field_idx(id: ast::Ident, fields: &[field]) -> Option<uint> {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident == id { return Some(i); } i += 1u; }\n     return None;\n }\n \n-pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n+pub fn field_idx_strict(tcx: ty::ctxt, id: ast::Ident, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.ident == id { return i; } i += 1u; }\n@@ -3375,7 +3375,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n-pub fn method_idx(id: ast::ident, meths: &[@Method]) -> Option<uint> {\n+pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n     meths.iter().position(|m| m.ident == id)\n }\n \n@@ -3823,9 +3823,9 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n #[deriving(Clone)]\n pub struct VariantInfo {\n     args: ~[t],\n-    arg_names: Option<~[ast::ident]>,\n+    arg_names: Option<~[ast::Ident]>,\n     ctor_ty: t,\n-    name: ast::ident,\n+    name: ast::Ident,\n     id: ast::def_id,\n     disr_val: Disr,\n     vis: visibility"}, {"sha": "8ba6234e6095a2c8308279ba113529a50961e30f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -555,7 +555,7 @@ pub fn ty_of_arg<AC:AstConv,\n \n pub fn bound_lifetimes<AC:AstConv>(\n     this: &AC,\n-    ast_lifetimes: &OptVec<ast::Lifetime>) -> OptVec<ast::ident>\n+    ast_lifetimes: &OptVec<ast::Lifetime>) -> OptVec<ast::Ident>\n {\n     /*!\n      *"}, {"sha": "c45f1c6ac4a103592ef1292f84769d1e02e820d6", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -126,7 +126,7 @@ pub fn lookup(\n         self_expr: @ast::expr,              // The expression `a`.\n         callee_id: NodeId,                  /* Where to store `a.b`'s type,\n                                              * also the scope of the call */\n-        m_name: ast::ident,                 // The ident `b`.\n+        m_name: ast::Ident,                 // The ident `b`.\n         self_ty: ty::t,                     // The type of `a`.\n         supplied_tps: &[ty::t],             // The list of types X, Y, ... .\n         deref_args: check::DerefArgs,       // Whether we autopointer first.\n@@ -173,7 +173,7 @@ pub struct LookupContext<'self> {\n     expr: @ast::expr,\n     self_expr: @ast::expr,\n     callee_id: NodeId,\n-    m_name: ast::ident,\n+    m_name: ast::Ident,\n     supplied_tps: &'self [ty::t],\n     impl_dups: @mut HashSet<def_id>,\n     inherent_candidates: @mut ~[Candidate],"}, {"sha": "8d5f257ebd6bfe8f980b1ce75ee15950f8a09138", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -557,7 +557,7 @@ pub fn check_method(ccx: @mut CrateCtxt,\n }\n \n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n-                                 fields: ~[(ast::ident, Span)]) {\n+                                 fields: ~[(ast::Ident, Span)]) {\n     let mut field_names = HashMap::new();\n \n     for p in fields.iter() {\n@@ -714,7 +714,7 @@ impl RegionScope for FnCtxt {\n     }\n     fn named_region(&self,\n                     span: Span,\n-                    id: ast::ident) -> Result<ty::Region, RegionError> {\n+                    id: ast::Ident) -> Result<ty::Region, RegionError> {\n         self.search_in_scope_regions(span, ty::br_named(id))\n     }\n }\n@@ -1116,7 +1116,7 @@ pub fn impl_self_ty(vcx: &VtableContext,\n pub fn lookup_field_ty(tcx: ty::ctxt,\n                        class_id: ast::def_id,\n                        items: &[ty::field_ty],\n-                       fieldname: ast::ident,\n+                       fieldname: ast::Ident,\n                        substs: &ty::substs) -> Option<ty::t> {\n \n     let o_field = items.iter().find(|f| f.ident == fieldname);\n@@ -1536,7 +1536,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          callee_id: ast::NodeId,\n                          expr: @ast::expr,\n                          rcvr: @ast::expr,\n-                         method_name: ast::ident,\n+                         method_name: ast::Ident,\n                          args: &[@ast::expr],\n                          tps: &[ast::Ty],\n                          sugar: ast::CallSugar) {\n@@ -1636,7 +1636,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         op_ex: @ast::expr,\n                         self_ex: @ast::expr,\n                         self_t: ty::t,\n-                        opname: ast::ident,\n+                        opname: ast::Ident,\n                         args: ~[@ast::expr],\n                         deref_args: DerefArgs,\n                         autoderef_receiver: AutoderefReceiverFlag,\n@@ -1936,7 +1936,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     fn check_field(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    base: @ast::expr,\n-                   field: ast::ident,\n+                   field: ast::Ident,\n                    tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);"}, {"sha": "f882a25ba80865a3d77405115184b9a748ce2f0c", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -368,7 +368,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  trait_rp: Option<ty::region_variance>,\n                                  trait_generics: &ast::Generics,\n                                  m_id: &ast::NodeId,\n-                                 m_ident: &ast::ident,\n+                                 m_ident: &ast::Ident,\n                                  m_explicit_self: &ast::explicit_self,\n                                  m_generics: &ast::Generics,\n                                  m_purity: &ast::purity,"}, {"sha": "d3dc3d1fb1c9abf6a732a15dc59fbcf92cd963cf", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -27,7 +27,7 @@ pub struct RegionError {\n pub trait RegionScope {\n     fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n     fn self_region(&self, span: Span) -> Result<ty::Region, RegionError>;\n-    fn named_region(&self, span: Span, id: ast::ident)\n+    fn named_region(&self, span: Span, id: ast::Ident)\n                       -> Result<ty::Region, RegionError>;\n }\n \n@@ -43,22 +43,22 @@ impl RegionScope for EmptyRscope {\n     fn self_region(&self, _span: Span) -> Result<ty::Region, RegionError> {\n         self.anon_region(_span)\n     }\n-    fn named_region(&self, _span: Span, _id: ast::ident)\n+    fn named_region(&self, _span: Span, _id: ast::Ident)\n         -> Result<ty::Region, RegionError>\n     {\n         self.anon_region(_span)\n     }\n }\n \n #[deriving(Clone)]\n-pub struct RegionParamNames(OptVec<ast::ident>);\n+pub struct RegionParamNames(OptVec<ast::Ident>);\n \n impl RegionParamNames {\n     fn has_self(&self) -> bool {\n         self.has_ident(special_idents::self_)\n     }\n \n-    fn has_ident(&self, ident: ast::ident) -> bool {\n+    fn has_ident(&self, ident: ast::Ident) -> bool {\n         for region_param_name in self.iter() {\n             if *region_param_name == ident {\n                 return true;\n@@ -197,7 +197,7 @@ impl RegionScope for MethodRscope {\n         }\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n-    fn named_region(&self, span: Span, id: ast::ident)\n+    fn named_region(&self, span: Span, id: ast::Ident)\n                       -> Result<ty::Region, RegionError> {\n         if !self.region_param_names.has_ident(id) {\n             return RegionParamNames::undeclared_name(None);\n@@ -249,7 +249,7 @@ impl RegionScope for TypeRscope {\n         }\n         result::Ok(ty::re_bound(ty::br_self))\n     }\n-    fn named_region(&self, span: Span, id: ast::ident)\n+    fn named_region(&self, span: Span, id: ast::Ident)\n                       -> Result<ty::Region, RegionError> {\n         do EmptyRscope.named_region(span, id).chain_err |_e| {\n             result::Err(RegionError {\n@@ -308,7 +308,7 @@ impl RegionScope for BindingRscope {\n     }\n     fn named_region(&self,\n                     span: Span,\n-                    id: ast::ident) -> Result<ty::Region, RegionError>\n+                    id: ast::Ident) -> Result<ty::Region, RegionError>\n     {\n         do self.base.named_region(span, id).chain_err |_e| {\n             let result = ty::re_bound(ty::br_named(id));"}, {"sha": "fe33205171430be245872d0fc666bfda44064984", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -305,7 +305,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn bare_fn_to_str(cx: ctxt,\n                       purity: ast::purity,\n                       abis: AbiSet,\n-                      ident: Option<ast::ident>,\n+                      ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n                       -> ~str {\n         let mut s = ~\"extern \";\n@@ -693,7 +693,7 @@ impl Repr for ty::Method {\n     }\n }\n \n-impl Repr for ast::ident {\n+impl Repr for ast::Ident {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n         token::ident_to_str(self).to_owned()\n     }"}, {"sha": "88a63a9cb59daee5815b173b30700d6682b80ace", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -22,7 +22,7 @@ use syntax::parse::token;\n // Hack; rather than thread an interner through everywhere, rely on\n // thread-local data\n // Hack-Becomes-Feature: using thread-local-state everywhere...\n-pub fn to_str(id: ast::ident) -> ~str {\n+pub fn to_str(id: ast::Ident) -> ~str {\n     /* bad */ ident_to_str(&id).to_owned()\n }\n "}, {"sha": "1b06f78abb911e84099e2c98451479ce6499d028", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -54,14 +54,14 @@ pub fn is_cmd(cmd: &str) -> bool {\n struct ListenerFn {\n     cmds: ~[~str],\n     span: codemap::Span,\n-    path: ~[ast::ident]\n+    path: ~[ast::Ident]\n }\n \n struct ReadyCtx {\n     sess: session::Session,\n     crate: @ast::Crate,\n     ext_cx: @ExtCtxt,\n-    path: ~[ast::ident],\n+    path: ~[ast::Ident],\n     fns: ~[ListenerFn]\n }\n "}, {"sha": "d7a05667a988390f12c495ca5fd0ce881702741e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -25,10 +25,12 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n #[deriving(Clone, Eq, IterBytes, ToStr)]\n-pub struct ident { name: Name, ctxt: SyntaxContext }\n+pub struct Ident { name: Name, ctxt: SyntaxContext }\n \n-/// Construct an identifier with the given name and an empty context:\n-pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: empty_ctxt}}\n+impl Ident {\n+    /// Construct an identifier with the given name and an empty context:\n+    pub fn new(name: Name) -> Ident { Ident {name: name, ctxt: empty_ctxt}}\n+}\n \n /// A SyntaxContext represents a chain of macro-expandings\n /// and renamings. Each macro expansion corresponds to\n@@ -48,7 +50,7 @@ pub type SyntaxContext = uint;\n pub struct SCTable {\n     table : ~[SyntaxContext_],\n     mark_memo : HashMap<(SyntaxContext,Mrk),SyntaxContext>,\n-    rename_memo : HashMap<(SyntaxContext,ident,Name),SyntaxContext>\n+    rename_memo : HashMap<(SyntaxContext,Ident,Name),SyntaxContext>\n }\n // NB: these must be placed in any SCTable...\n pub static empty_ctxt : uint = 0;\n@@ -66,7 +68,7 @@ pub enum SyntaxContext_ {\n     // \"to\" slot must have the same name and context\n     // in the \"from\" slot. In essence, they're all\n     // pointers to a single \"rename\" event node.\n-    Rename (ident,Name,SyntaxContext),\n+    Rename (Ident,Name,SyntaxContext),\n     IllegalCtxt()\n }\n \n@@ -76,27 +78,27 @@ pub type Name = uint;\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = uint;\n \n-impl<S:Encoder> Encodable<S> for ident {\n+impl<S:Encoder> Encodable<S> for Ident {\n     fn encode(&self, s: &mut S) {\n         s.emit_str(interner_get(self.name));\n     }\n }\n \n #[deriving(IterBytes)]\n-impl<D:Decoder> Decodable<D> for ident {\n-    fn decode(d: &mut D) -> ident {\n+impl<D:Decoder> Decodable<D> for Ident {\n+    fn decode(d: &mut D) -> Ident {\n         str_to_ident(d.read_str())\n     }\n }\n \n /// Function name (not all functions have names)\n-pub type fn_ident = Option<ident>;\n+pub type fn_ident = Option<Ident>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Lifetime {\n     id: NodeId,\n     span: Span,\n-    ident: ident\n+    ident: Ident\n }\n \n // a \"Path\" is essentially Rust's notion of a name;\n@@ -118,7 +120,7 @@ pub struct Path {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n-    identifier: ident,\n+    identifier: Ident,\n     /// The lifetime parameter for this path segment. Currently only one\n     /// lifetime parameter is allowed.\n     lifetime: Option<Lifetime>,\n@@ -151,7 +153,7 @@ pub enum TyParamBound {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct TyParam {\n-    ident: ident,\n+    ident: Ident,\n     id: NodeId,\n     bounds: OptVec<TyParamBound>\n }\n@@ -275,7 +277,7 @@ pub struct pat {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct field_pat {\n-    ident: ident,\n+    ident: Ident,\n     pat: @pat,\n }\n \n@@ -430,7 +432,7 @@ pub struct arm {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct Field {\n-    ident: ident,\n+    ident: Ident,\n     expr: @expr,\n     span: Span,\n }\n@@ -473,7 +475,7 @@ pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(NodeId, @expr, ident, ~[Ty], ~[@expr], CallSugar),\n+    expr_method_call(NodeId, @expr, Ident, ~[Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n     expr_binary(NodeId, binop, @expr, @expr),\n     expr_unary(NodeId, unop, @expr),\n@@ -485,23 +487,23 @@ pub enum expr_ {\n     /* Conditionless loop (can be exited with break, cont, or ret)\n        Same semantics as while(true) { body }, but typestate knows that the\n        (implicit) condition is always true. */\n-    expr_loop(Block, Option<ident>),\n+    expr_loop(Block, Option<Ident>),\n     expr_match(@expr, ~[arm]),\n     expr_fn_block(fn_decl, Block),\n     expr_do_body(@expr),\n     expr_block(Block),\n \n     expr_assign(@expr, @expr),\n     expr_assign_op(NodeId, binop, @expr, @expr),\n-    expr_field(@expr, ident, ~[Ty]),\n+    expr_field(@expr, Ident, ~[Ty]),\n     expr_index(NodeId, @expr, @expr),\n     expr_path(Path),\n \n     /// The special identifier `self`.\n     expr_self,\n     expr_addr_of(mutability, @expr),\n-    expr_break(Option<ident>),\n-    expr_again(Option<ident>),\n+    expr_break(Option<Ident>),\n+    expr_again(Option<Ident>),\n     expr_ret(Option<@expr>),\n     expr_log(@expr, @expr),\n \n@@ -550,7 +552,7 @@ pub enum token_tree {\n     tt_seq(Span, @mut ~[token_tree], Option<::parse::token::Token>, bool),\n \n     // a syntactic variable that will be filled in by macro expansion.\n-    tt_nonterminal(Span, ident)\n+    tt_nonterminal(Span, Ident)\n }\n \n //\n@@ -615,7 +617,7 @@ pub enum matcher_ {\n     // lo, hi position-in-match-array used:\n     match_seq(~[matcher], Option<::parse::token::Token>, bool, uint, uint),\n     // parse a Rust NT: name to bind, name of NT, position in match array:\n-    match_nonterminal(ident, ident, uint)\n+    match_nonterminal(Ident, Ident, uint)\n }\n \n pub type mac = Spanned<mac_>;\n@@ -649,14 +651,14 @@ pub struct mt {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct TypeField {\n-    ident: ident,\n+    ident: Ident,\n     mt: mt,\n     span: Span,\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct TypeMethod {\n-    ident: ident,\n+    ident: Ident,\n     attrs: ~[Attribute],\n     purity: purity,\n     decl: fn_decl,\n@@ -868,7 +870,7 @@ pub type explicit_self = Spanned<explicit_self_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct method {\n-    ident: ident,\n+    ident: Ident,\n     attrs: ~[Attribute],\n     generics: Generics,\n     explicit_self: explicit_self,\n@@ -921,7 +923,7 @@ pub struct enum_def {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct variant_ {\n-    name: ident,\n+    name: Ident,\n     attrs: ~[Attribute],\n     kind: variant_kind,\n     id: NodeId,\n@@ -933,7 +935,7 @@ pub type variant = Spanned<variant_>;\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct path_list_ident_ {\n-    name: ident,\n+    name: Ident,\n     id: NodeId,\n }\n \n@@ -949,7 +951,7 @@ pub enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, Path, NodeId),\n+    view_path_simple(Ident, Path, NodeId),\n \n     // foo::bar::*\n     view_path_glob(Path, NodeId),\n@@ -972,7 +974,7 @@ pub enum view_item_ {\n     // optional @str: if present, this is a location (containing\n     // arbitrary characters) from which to fetch the crate sources\n     // For example, extern mod whatever = \"github.com/mozilla/rust\"\n-    view_item_extern_mod(ident, Option<@str>, ~[@MetaItem], NodeId),\n+    view_item_extern_mod(Ident, Option<@str>, ~[@MetaItem], NodeId),\n     view_item_use(~[@view_path]),\n }\n \n@@ -1037,7 +1039,7 @@ pub type struct_field = Spanned<struct_field_>;\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum struct_field_kind {\n-    named_field(ident, visibility),\n+    named_field(Ident, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n@@ -1055,7 +1057,7 @@ pub struct struct_def {\n  */\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct item {\n-    ident: ident,\n+    ident: Ident,\n     attrs: ~[Attribute],\n     id: NodeId,\n     node: item_,\n@@ -1083,7 +1085,7 @@ pub enum item_ {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct foreign_item {\n-    ident: ident,\n+    ident: Ident,\n     attrs: ~[Attribute],\n     node: foreign_item_,\n     id: NodeId,"}, {"sha": "6e022e9804b412536dd057b98c9e2a8c00c6a621", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -27,8 +27,8 @@ use std::vec;\n \n #[deriving(Clone, Eq)]\n pub enum path_elt {\n-    path_mod(ident),\n-    path_name(ident)\n+    path_mod(Ident),\n+    path_name(Ident)\n }\n \n pub type path = ~[path_elt];\n@@ -44,7 +44,7 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n     strs.connect(sep)\n }\n \n-pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n+pub fn path_ident_to_str(p: &path, i: Ident, itr: @ident_interner) -> ~str {\n     if p.is_empty() {\n         itr.get(i.name).to_owned()\n     } else {\n@@ -74,7 +74,7 @@ pub enum ast_node {\n     node_expr(@expr),\n     node_stmt(@stmt),\n     node_arg,\n-    node_local(ident),\n+    node_local(Ident),\n     node_block(Block),\n     node_struct_ctor(@struct_def, @item, @path),\n     node_callee_scope(@expr)\n@@ -89,7 +89,7 @@ pub struct Ctx {\n }\n \n impl Ctx {\n-    fn extend(&self, elt: ident) -> @path {\n+    fn extend(&self, elt: Ident) -> @path {\n         @vec::append(self.path.clone(), [path_name(elt)])\n     }\n \n@@ -110,7 +110,7 @@ impl Ctx {\n     fn map_struct_def(&mut self,\n                       struct_def: @ast::struct_def,\n                       parent_node: ast_node,\n-                      ident: ast::ident) {\n+                      ident: ast::Ident) {\n         let p = self.extend(ident);\n \n         // If this is a tuple-like struct, register the constructor.\n@@ -356,7 +356,7 @@ impl Visitor<()> for Ctx {\n \n     fn visit_struct_def(&mut self,\n                         struct_def: @struct_def,\n-                        ident: ident,\n+                        ident: Ident,\n                         generics: &Generics,\n                         node_id: NodeId,\n                         _: ()) {"}, {"sha": "810ce9940f2e1e35195fc2adc9b7b614ada3138b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -23,12 +23,12 @@ use std::local_data;\n use std::num;\n use std::option;\n \n-pub fn path_name_i(idents: &[ident]) -> ~str {\n+pub fn path_name_i(idents: &[Ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(path: &Path) -> ident {\n+pub fn path_to_ident(path: &Path) -> Ident {\n     path.segments.last().identifier\n }\n \n@@ -217,7 +217,7 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: Span, identifier: ident) -> Path {\n+pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n     ast::Path {\n         span: s,\n         global: false,\n@@ -231,7 +231,7 @@ pub fn ident_to_path(s: Span, identifier: ident) -> Path {\n     }\n }\n \n-pub fn ident_to_pat(id: NodeId, s: Span, i: ident) -> @pat {\n+pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @pat {\n     @ast::pat { id: id,\n                 node: pat_ident(bind_infer, ident_to_path(s, i), None),\n                 span: s }\n@@ -302,13 +302,13 @@ pub fn struct_field_visibility(field: ast::struct_field) -> visibility {\n }\n \n pub trait inlined_item_utils {\n-    fn ident(&self) -> ident;\n+    fn ident(&self) -> Ident;\n     fn id(&self) -> ast::NodeId;\n     fn accept<E: Clone, V:Visitor<E>>(&self, e: E, v: &mut V);\n }\n \n impl inlined_item_utils for inlined_item {\n-    fn ident(&self) -> ident {\n+    fn ident(&self) -> Ident {\n         match *self {\n             ii_item(i) => i.ident,\n             ii_foreign(i) => i.ident,\n@@ -608,7 +608,7 @@ impl Visitor<()> for IdVisitor {\n     // XXX: Default\n     fn visit_struct_def(&mut self,\n                         struct_definition: @struct_def,\n-                        identifier: ident,\n+                        identifier: Ident,\n                         generics: &Generics,\n                         node_id: NodeId,\n                         env: ()) {\n@@ -749,7 +749,7 @@ impl SimpleVisitor for EachViewItemData {\n     }\n     fn visit_struct_def(&mut self,\n                         _: @struct_def,\n-                        _: ident,\n+                        _: Ident,\n                         _: &Generics,\n                         _: NodeId) {\n         // XXX: Default method.\n@@ -827,7 +827,7 @@ pub fn pat_is_ident(pat: @ast::pat) -> bool {\n // HYGIENE FUNCTIONS\n \n /// Construct an identifier with the given name and an empty context:\n-pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: 0}}\n+pub fn new_ident(name: Name) -> Ident { Ident {name: name, ctxt: 0}}\n \n /// Extend a syntax context with a given mark\n pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n@@ -859,13 +859,13 @@ pub fn new_mark_internal(m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n }\n \n /// Extend a syntax context with a given rename\n-pub fn new_rename(id:ident, to:Name, tail:SyntaxContext) -> SyntaxContext {\n+pub fn new_rename(id:Ident, to:Name, tail:SyntaxContext) -> SyntaxContext {\n     new_rename_internal(id, to, tail, get_sctable())\n }\n \n // Extend a syntax context with a given rename and sctable\n // FIXME #4536 : currently pub to allow testing\n-pub fn new_rename_internal(id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n+pub fn new_rename_internal(id:Ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n     -> SyntaxContext {\n     let key = (tail,id,to);\n     // FIXME #5074\n@@ -916,22 +916,22 @@ fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve(id : ident) -> Name {\n+pub fn resolve(id : Ident) -> Name {\n     resolve_internal(id, get_sctable())\n }\n \n // Resolve a syntax object to a name, per MTWT.\n // FIXME #4536 : currently pub to allow testing\n-pub fn resolve_internal(id : ident, table : &mut SCTable) -> Name {\n+pub fn resolve_internal(id : Ident, table : &mut SCTable) -> Name {\n     match table.table[id.ctxt] {\n         EmptyCtxt => id.name,\n         // ignore marks here:\n-        Mark(_,subctxt) => resolve_internal(ident{name:id.name, ctxt: subctxt},table),\n+        Mark(_,subctxt) => resolve_internal(Ident{name:id.name, ctxt: subctxt},table),\n         // do the rename if necessary:\n-        Rename(ident{name,ctxt},toname,subctxt) => {\n+        Rename(Ident{name,ctxt},toname,subctxt) => {\n             // this could be cached or computed eagerly:\n-            let resolvedfrom = resolve_internal(ident{name:name,ctxt:ctxt},table);\n-            let resolvedthis = resolve_internal(ident{name:id.name,ctxt:subctxt},table);\n+            let resolvedfrom = resolve_internal(Ident{name:name,ctxt:ctxt},table);\n+            let resolvedthis = resolve_internal(Ident{name:id.name,ctxt:subctxt},table);\n             if ((resolvedthis == resolvedfrom)\n                 && (marksof(ctxt,resolvedthis,table)\n                     == marksof(subctxt,resolvedthis,table))) {\n@@ -1014,20 +1014,20 @@ mod test {\n \n     // convert a list of uints to an @[ident]\n     // (ignores the interner completely)\n-    fn uints_to_idents (uints: &~[uint]) -> @~[ident] {\n-        @uints.map(|u| ident {name:*u, ctxt: empty_ctxt})\n+    fn uints_to_idents (uints: &~[uint]) -> @~[Ident] {\n+        @uints.map(|u| Ident {name:*u, ctxt: empty_ctxt})\n     }\n \n-    fn id (u : uint, s: SyntaxContext) -> ident {\n-        ident{name:u, ctxt: s}\n+    fn id (u : uint, s: SyntaxContext) -> Ident {\n+        Ident{name:u, ctxt: s}\n     }\n \n     // because of the SCTable, I now need a tidy way of\n     // creating syntax objects. Sigh.\n     #[deriving(Clone, Eq)]\n     enum TestSC {\n         M(Mrk),\n-        R(ident,Name)\n+        R(Ident,Name)\n     }\n \n     // unfold a vector of TestSC values into a SCTable,"}, {"sha": "913b68da0cb47bf4709f256b4da981f79d20e1c8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -57,7 +57,7 @@ pub struct SyntaxExpanderTTItem {\n \n pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n                                        Span,\n-                                       ast::ident,\n+                                       ast::Ident,\n                                        ~[ast::token_tree])\n                                     -> MacResult;\n \n@@ -114,7 +114,7 @@ pub struct BlockInfo {\n }\n \n // a list of ident->name renamings\n-type RenameList = ~[(ast::ident,Name)];\n+type RenameList = ~[(ast::Ident,Name)];\n \n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n@@ -228,7 +228,7 @@ pub struct ExtCtxt {\n     // and there are bugs in the code for object\n     // types that make this hard to get right at the\n     // moment. - nmatsakis\n-    mod_path: @mut ~[ast::ident],\n+    mod_path: @mut ~[ast::Ident],\n     trace_mac: @mut bool\n }\n \n@@ -255,9 +255,9 @@ impl ExtCtxt {\n     }\n     pub fn print_backtrace(&self) { }\n     pub fn backtrace(&self) -> Option<@ExpnInfo> { *self.backtrace }\n-    pub fn mod_push(&self, i: ast::ident) { self.mod_path.push(i); }\n+    pub fn mod_push(&self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&self) { self.mod_path.pop(); }\n-    pub fn mod_path(&self) -> ~[ast::ident] { (*self.mod_path).clone() }\n+    pub fn mod_path(&self) -> ~[ast::Ident] { (*self.mod_path).clone() }\n     pub fn bt_push(&self, ei: codemap::ExpnInfo) {\n         match ei {\n             ExpnInfo {call_site: cs, callee: ref callee} => {\n@@ -311,10 +311,10 @@ impl ExtCtxt {\n     pub fn set_trace_macros(&self, x: bool) {\n         *self.trace_mac = x\n     }\n-    pub fn str_of(&self, id: ast::ident) -> @str {\n+    pub fn str_of(&self, id: ast::Ident) -> @str {\n         ident_to_str(&id)\n     }\n-    pub fn ident_of(&self, st: &str) -> ast::ident {\n+    pub fn ident_of(&self, st: &str) -> ast::Ident {\n         str_to_ident(st)\n     }\n }"}, {"sha": "55f7a35e1df52030c5635e7c9e64e27837e05141", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::AbiSet;\n-use ast::ident;\n+use ast::Ident;\n use ast;\n use ast_util;\n use codemap::{Span, respan, dummy_sp};\n@@ -20,7 +20,7 @@ use opt_vec;\n use opt_vec::OptVec;\n \n pub struct Field {\n-    ident: ast::ident,\n+    ident: ast::Ident,\n     ex: @ast::expr\n }\n \n@@ -32,12 +32,12 @@ mod syntax {\n \n pub trait AstBuilder {\n     // paths\n-    fn path(&self, span: Span, strs: ~[ast::ident]) -> ast::Path;\n-    fn path_ident(&self, span: Span, id: ast::ident) -> ast::Path;\n-    fn path_global(&self, span: Span, strs: ~[ast::ident]) -> ast::Path;\n+    fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path;\n+    fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path;\n+    fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path;\n     fn path_all(&self, sp: Span,\n                 global: bool,\n-                idents: ~[ast::ident],\n+                idents: ~[ast::Ident],\n                 rp: Option<ast::Lifetime>,\n                 types: ~[ast::Ty])\n         -> ast::Path;\n@@ -47,7 +47,7 @@ pub trait AstBuilder {\n \n     fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty;\n     fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n-    fn ty_ident(&self, span: Span, idents: ast::ident) -> ast::Ty;\n+    fn ty_ident(&self, span: Span, idents: ast::Ident) -> ast::Ty;\n \n     fn ty_rptr(&self, span: Span,\n                ty: ast::Ty,\n@@ -62,22 +62,22 @@ pub trait AstBuilder {\n \n     fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n-    fn ty_field_imm(&self, span: Span, name: ident, ty: ast::Ty) -> ast::TypeField;\n+    fn ty_field_imm(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::TypeField;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n-    fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n+    fn typaram(&self, id: ast::Ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::trait_ref;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n-    fn lifetime(&self, span: Span, ident: ast::ident) -> ast::Lifetime;\n+    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime;\n \n     // statements\n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt;\n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt;\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::expr) -> @ast::stmt;\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n-                      ident: ast::ident,\n+                      ident: ast::Ident,\n                       typ: ast::Ty,\n                       ex: @ast::expr)\n                       -> @ast::stmt;\n@@ -93,7 +93,7 @@ pub trait AstBuilder {\n     // expressions\n     fn expr(&self, span: Span, node: ast::expr_) -> @ast::expr;\n     fn expr_path(&self, path: ast::Path) -> @ast::expr;\n-    fn expr_ident(&self, span: Span, id: ast::ident) -> @ast::expr;\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::expr;\n \n     fn expr_self(&self, span: Span) -> @ast::expr;\n     fn expr_binary(&self, sp: Span, op: ast::binop,\n@@ -104,19 +104,19 @@ pub trait AstBuilder {\n     fn expr_managed(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n     fn expr_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n     fn expr_mut_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr;\n-    fn expr_field_access(&self, span: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+    fn expr_field_access(&self, span: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr;\n     fn expr_call(&self, span: Span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_call_ident(&self, span: Span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::ident],\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::expr]) -> @ast::expr;\n+    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n                         args: ~[@ast::expr]) -> @ast::expr;\n     fn expr_method_call(&self, span: Span,\n-                        expr: @ast::expr, ident: ast::ident,\n+                        expr: @ast::expr, ident: ast::Ident,\n                         args: ~[@ast::expr]) -> @ast::expr;\n     fn expr_block(&self, b: ast::Block) -> @ast::expr;\n \n-    fn field_imm(&self, span: Span, name: ident, e: @ast::expr) -> ast::Field;\n+    fn field_imm(&self, span: Span, name: Ident, e: @ast::expr) -> ast::Field;\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr;\n-    fn expr_struct_ident(&self, span: Span, id: ast::ident, fields: ~[ast::Field]) -> @ast::expr;\n+    fn expr_struct_ident(&self, span: Span, id: ast::Ident, fields: ~[ast::Field]) -> @ast::expr;\n \n     fn expr_lit(&self, sp: Span, lit: ast::lit_) -> @ast::expr;\n \n@@ -137,11 +137,11 @@ pub trait AstBuilder {\n     fn pat(&self, span: Span, pat: ast::pat_) -> @ast::pat;\n     fn pat_wild(&self, span: Span) -> @ast::pat;\n     fn pat_lit(&self, span: Span, expr: @ast::expr) -> @ast::pat;\n-    fn pat_ident(&self, span: Span, ident: ast::ident) -> @ast::pat;\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::pat;\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n-                              ident: ast::ident,\n+                              ident: ast::Ident,\n                               bm: ast::binding_mode) -> @ast::pat;\n     fn pat_enum(&self, span: Span, path: ast::Path, subpats: ~[@ast::pat]) -> @ast::pat;\n     fn pat_struct(&self, span: Span,\n@@ -156,65 +156,65 @@ pub trait AstBuilder {\n \n     fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr;\n \n-    fn lambda(&self, span: Span, ids: ~[ast::ident], blk: ast::Block) -> @ast::expr;\n+    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::expr;\n     fn lambda0(&self, span: Span, blk: ast::Block) -> @ast::expr;\n-    fn lambda1(&self, span: Span, blk: ast::Block, ident: ast::ident) -> @ast::expr;\n+    fn lambda1(&self, span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::expr;\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::ident], blk: @ast::expr) -> @ast::expr;\n+    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], blk: @ast::expr) -> @ast::expr;\n     fn lambda_expr_0(&self, span: Span, expr: @ast::expr) -> @ast::expr;\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr;\n+    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr;\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::ident], blk: ~[@ast::stmt]) -> @ast::expr;\n+    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], blk: ~[@ast::stmt]) -> @ast::expr;\n     fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::stmt]) -> @ast::expr;\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr;\n+    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::Ident) -> @ast::expr;\n \n     // items\n     fn item(&self, span: Span,\n-            name: ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item;\n+            name: Ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, span: Span, name: ident, ty: ast::Ty) -> ast::arg;\n+    fn arg(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::arg;\n     // XXX unused self\n     fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl;\n \n     fn item_fn_poly(&self,\n                     span: Span,\n-                    name: ident,\n+                    name: Ident,\n                     inputs: ~[ast::arg],\n                     output: ast::Ty,\n                     generics: Generics,\n                     body: ast::Block) -> @ast::item;\n     fn item_fn(&self,\n                span: Span,\n-               name: ident,\n+               name: Ident,\n                inputs: ~[ast::arg],\n                output: ast::Ty,\n                body: ast::Block) -> @ast::item;\n \n-    fn variant(&self, span: Span, name: ident, tys: ~[ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: Span, name: Ident, tys: ~[ast::Ty]) -> ast::variant;\n     fn item_enum_poly(&self,\n                       span: Span,\n-                      name: ident,\n+                      name: Ident,\n                       enum_definition: ast::enum_def,\n                       generics: Generics) -> @ast::item;\n-    fn item_enum(&self, span: Span, name: ident, enum_def: ast::enum_def) -> @ast::item;\n+    fn item_enum(&self, span: Span, name: Ident, enum_def: ast::enum_def) -> @ast::item;\n \n     fn item_struct_poly(&self,\n                         span: Span,\n-                        name: ident,\n+                        name: Ident,\n                         struct_def: ast::struct_def,\n                         generics: Generics) -> @ast::item;\n-    fn item_struct(&self, span: Span, name: ident, struct_def: ast::struct_def) -> @ast::item;\n+    fn item_struct(&self, span: Span, name: Ident, struct_def: ast::struct_def) -> @ast::item;\n \n     fn item_mod(&self, span: Span,\n-                name: ident, attrs: ~[ast::Attribute],\n+                name: Ident, attrs: ~[ast::Attribute],\n                 vi: ~[ast::view_item], items: ~[@ast::item]) -> @ast::item;\n \n     fn item_ty_poly(&self,\n                     span: Span,\n-                    name: ident,\n+                    name: Ident,\n                     ty: ast::Ty,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: Span, name: ident, ty: ast::Ty) -> @ast::item;\n+    fn item_ty(&self, span: Span, name: Ident, ty: ast::Ty) -> @ast::item;\n \n     fn attribute(&self, sp: Span, mi: @ast::MetaItem) -> ast::Attribute;\n \n@@ -225,25 +225,25 @@ pub trait AstBuilder {\n     fn view_use(&self, sp: Span,\n                 vis: ast::visibility, vp: ~[@ast::view_path]) -> ast::view_item;\n     fn view_use_list(&self, sp: Span, vis: ast::visibility,\n-                     path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item;\n+                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::view_item;\n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item;\n+                     vis: ast::visibility, path: ~[ast::Ident]) -> ast::view_item;\n }\n \n impl AstBuilder for @ExtCtxt {\n-    fn path(&self, span: Span, strs: ~[ast::ident]) -> ast::Path {\n+    fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n         self.path_all(span, false, strs, None, ~[])\n     }\n-    fn path_ident(&self, span: Span, id: ast::ident) -> ast::Path {\n+    fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n-    fn path_global(&self, span: Span, strs: ~[ast::ident]) -> ast::Path {\n+    fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n         self.path_all(span, true, strs, None, ~[])\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n-                mut idents: ~[ast::ident],\n+                mut idents: ~[ast::Ident],\n                 rp: Option<ast::Lifetime>,\n                 types: ~[ast::Ty])\n                 -> ast::Path {\n@@ -291,7 +291,7 @@ impl AstBuilder for @ExtCtxt {\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n-    fn ty_ident(&self, span: Span, ident: ast::ident)\n+    fn ty_ident(&self, span: Span, ident: ast::Ident)\n         -> ast::Ty {\n         self.ty_path(self.path_ident(span, ident), None)\n     }\n@@ -326,7 +326,7 @@ impl AstBuilder for @ExtCtxt {\n                           ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: Span, name: ident, ty: ast::Ty) -> ast::TypeField {\n+    fn ty_field_imm(&self, span: Span, name: Ident, ty: ast::Ty) -> ast::TypeField {\n         ast::TypeField {\n             ident: name,\n             mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n@@ -346,7 +346,7 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam {\n+    fn typaram(&self, id: ast::Ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam {\n         ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n     }\n \n@@ -385,15 +385,15 @@ impl AstBuilder for @ExtCtxt {\n         ast::TraitTyParamBound(self.trait_ref(path))\n     }\n \n-    fn lifetime(&self, span: Span, ident: ast::ident) -> ast::Lifetime {\n+    fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n         ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n     }\n \n     fn stmt_expr(&self, expr: @ast::expr) -> @ast::stmt {\n         @respan(expr.span, ast::stmt_semi(expr, self.next_id()))\n     }\n \n-    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n+    fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::expr) -> @ast::stmt {\n         let pat = self.pat_ident(sp, ident);\n         let local = @ast::Local {\n             is_mutbl: mutbl,\n@@ -410,7 +410,7 @@ impl AstBuilder for @ExtCtxt {\n     fn stmt_let_typed(&self,\n                       sp: Span,\n                       mutbl: bool,\n-                      ident: ast::ident,\n+                      ident: ast::Ident,\n                       typ: ast::Ty,\n                       ex: @ast::expr)\n                       -> @ast::stmt {\n@@ -461,7 +461,7 @@ impl AstBuilder for @ExtCtxt {\n         self.expr(path.span, ast::expr_path(path))\n     }\n \n-    fn expr_ident(&self, span: Span, id: ast::ident) -> @ast::expr {\n+    fn expr_ident(&self, span: Span, id: ast::Ident) -> @ast::expr {\n         self.expr_path(self.path_ident(span, id))\n     }\n     fn expr_self(&self, span: Span) -> @ast::expr {\n@@ -485,7 +485,7 @@ impl AstBuilder for @ExtCtxt {\n         self.expr_unary(sp, ast::box(ast::m_imm), e)\n     }\n \n-    fn expr_field_access(&self, sp: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+    fn expr_field_access(&self, sp: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr {\n         self.expr(sp, ast::expr_field(expr, ident, ~[]))\n     }\n     fn expr_addr_of(&self, sp: Span, e: @ast::expr) -> @ast::expr {\n@@ -498,33 +498,33 @@ impl AstBuilder for @ExtCtxt {\n     fn expr_call(&self, span: Span, expr: @ast::expr, args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n-    fn expr_call_ident(&self, span: Span, id: ast::ident, args: ~[@ast::expr]) -> @ast::expr {\n+    fn expr_call_ident(&self, span: Span, id: ast::Ident, args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span,\n                   ast::expr_call(self.expr_ident(span, id), args, ast::NoSugar))\n     }\n-    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::ident],\n+    fn expr_call_global(&self, sp: Span, fn_path: ~[ast::Ident],\n                       args: ~[@ast::expr]) -> @ast::expr {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n     fn expr_method_call(&self, span: Span,\n                         expr: @ast::expr,\n-                        ident: ast::ident,\n+                        ident: ast::Ident,\n                         args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span,\n                   ast::expr_method_call(self.next_id(), expr, ident, ~[], args, ast::NoSugar))\n     }\n     fn expr_block(&self, b: ast::Block) -> @ast::expr {\n         self.expr(b.span, ast::expr_block(b))\n     }\n-    fn field_imm(&self, span: Span, name: ident, e: @ast::expr) -> ast::Field {\n+    fn field_imm(&self, span: Span, name: Ident, e: @ast::expr) -> ast::Field {\n         ast::Field { ident: name, expr: e, span: span }\n     }\n     fn expr_struct(&self, span: Span, path: ast::Path, fields: ~[ast::Field]) -> @ast::expr {\n         self.expr(span, ast::expr_struct(path, fields, None))\n     }\n     fn expr_struct_ident(&self, span: Span,\n-                         id: ast::ident, fields: ~[ast::Field]) -> @ast::expr {\n+                         id: ast::Ident, fields: ~[ast::Field]) -> @ast::expr {\n         self.expr_struct(span, self.path_ident(span, id), fields)\n     }\n \n@@ -591,13 +591,13 @@ impl AstBuilder for @ExtCtxt {\n     fn pat_lit(&self, span: Span, expr: @ast::expr) -> @ast::pat {\n         self.pat(span, ast::pat_lit(expr))\n     }\n-    fn pat_ident(&self, span: Span, ident: ast::ident) -> @ast::pat {\n+    fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::pat {\n         self.pat_ident_binding_mode(span, ident, ast::bind_infer)\n     }\n \n     fn pat_ident_binding_mode(&self,\n                               span: Span,\n-                              ident: ast::ident,\n+                              ident: ast::Ident,\n                               bm: ast::binding_mode) -> @ast::pat {\n         let path = self.path_ident(span, ident);\n         let pat = ast::pat_ident(bm, path, None);\n@@ -638,7 +638,7 @@ impl AstBuilder for @ExtCtxt {\n     fn lambda_fn_decl(&self, span: Span, fn_decl: ast::fn_decl, blk: ast::Block) -> @ast::expr {\n         self.expr(span, ast::expr_fn_block(fn_decl, blk))\n     }\n-    fn lambda(&self, span: Span, ids: ~[ast::ident], blk: ast::Block) -> @ast::expr {\n+    fn lambda(&self, span: Span, ids: ~[ast::Ident], blk: ast::Block) -> @ast::expr {\n         let fn_decl = self.fn_decl(\n             ids.map(|id| self.arg(span, *id, self.ty_infer(span))),\n             self.ty_infer(span));\n@@ -658,38 +658,38 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     #[cfg(stage0)]\n-    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n+    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|$ident| $blk_e )\n     }\n     #[cfg(not(stage0))]\n-    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n+    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::expr {\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(*self, |$ident| $blk_e )\n     }\n \n-    fn lambda_expr(&self, span: Span, ids: ~[ast::ident], expr: @ast::expr) -> @ast::expr {\n+    fn lambda_expr(&self, span: Span, ids: ~[ast::Ident], expr: @ast::expr) -> @ast::expr {\n         self.lambda(span, ids, self.block_expr(expr))\n     }\n     fn lambda_expr_0(&self, span: Span, expr: @ast::expr) -> @ast::expr {\n         self.lambda0(span, self.block_expr(expr))\n     }\n-    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::ident) -> @ast::expr {\n+    fn lambda_expr_1(&self, span: Span, expr: @ast::expr, ident: ast::Ident) -> @ast::expr {\n         self.lambda1(span, self.block_expr(expr), ident)\n     }\n \n-    fn lambda_stmts(&self, span: Span, ids: ~[ast::ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n+    fn lambda_stmts(&self, span: Span, ids: ~[ast::Ident], stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda(span, ids, self.block(span, stmts, None))\n     }\n     fn lambda_stmts_0(&self, span: Span, stmts: ~[@ast::stmt]) -> @ast::expr {\n         self.lambda0(span, self.block(span, stmts, None))\n     }\n-    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::ident) -> @ast::expr {\n+    fn lambda_stmts_1(&self, span: Span, stmts: ~[@ast::stmt], ident: ast::Ident) -> @ast::expr {\n         self.lambda1(span, self.block(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: Span, ident: ast::ident, ty: ast::Ty) -> ast::arg {\n+    fn arg(&self, span: Span, ident: ast::Ident, ty: ast::Ty) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             is_mutbl: false,\n@@ -709,7 +709,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn item(&self, span: Span,\n-            name: ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item {\n+            name: Ident, attrs: ~[ast::Attribute], node: ast::item_) -> @ast::item {\n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         @ast::item { ident: name,\n@@ -722,7 +722,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn item_fn_poly(&self,\n                     span: Span,\n-                    name: ident,\n+                    name: Ident,\n                     inputs: ~[ast::arg],\n                     output: ast::Ty,\n                     generics: Generics,\n@@ -739,7 +739,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn item_fn(&self,\n                span: Span,\n-               name: ident,\n+               name: Ident,\n                inputs: ~[ast::arg],\n                output: ast::Ty,\n                body: ast::Block\n@@ -753,7 +753,7 @@ impl AstBuilder for @ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: Span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n+    fn variant(&self, span: Span, name: Ident, tys: ~[ast::Ty]) -> ast::variant {\n         let args = tys.move_iter().map(|ty| {\n             ast::variant_arg { ty: ty, id: self.next_id() }\n         }).collect();\n@@ -769,13 +769,13 @@ impl AstBuilder for @ExtCtxt {\n                })\n     }\n \n-    fn item_enum_poly(&self, span: Span, name: ident,\n+    fn item_enum_poly(&self, span: Span, name: Ident,\n                       enum_definition: ast::enum_def,\n                       generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_enum(enum_definition, generics))\n     }\n \n-    fn item_enum(&self, span: Span, name: ident,\n+    fn item_enum(&self, span: Span, name: Ident,\n                  enum_definition: ast::enum_def) -> @ast::item {\n         self.item_enum_poly(span, name, enum_definition,\n                             ast_util::empty_generics())\n@@ -784,7 +784,7 @@ impl AstBuilder for @ExtCtxt {\n     fn item_struct(\n         &self,\n         span: Span,\n-        name: ident,\n+        name: Ident,\n         struct_def: ast::struct_def\n     ) -> @ast::item {\n         self.item_struct_poly(\n@@ -798,14 +798,14 @@ impl AstBuilder for @ExtCtxt {\n     fn item_struct_poly(\n         &self,\n         span: Span,\n-        name: ident,\n+        name: Ident,\n         struct_def: ast::struct_def,\n         generics: Generics\n     ) -> @ast::item {\n         self.item(span, name, ~[], ast::item_struct(@struct_def, generics))\n     }\n \n-    fn item_mod(&self, span: Span, name: ident,\n+    fn item_mod(&self, span: Span, name: Ident,\n                 attrs: ~[ast::Attribute],\n                 vi: ~[ast::view_item],\n                 items: ~[@ast::item]) -> @ast::item {\n@@ -820,12 +820,12 @@ impl AstBuilder for @ExtCtxt {\n         )\n     }\n \n-    fn item_ty_poly(&self, span: Span, name: ident, ty: ast::Ty,\n+    fn item_ty_poly(&self, span: Span, name: Ident, ty: ast::Ty,\n                     generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: Span, name: ident, ty: ast::Ty) -> @ast::item {\n+    fn item_ty(&self, span: Span, name: Ident, ty: ast::Ty) -> @ast::item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n \n@@ -858,7 +858,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use_list(&self, sp: Span, vis: ast::visibility,\n-                     path: ~[ast::ident], imports: &[ast::ident]) -> ast::view_item {\n+                     path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::view_item {\n         let imports = do imports.map |id| {\n             respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n         };\n@@ -871,7 +871,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn view_use_glob(&self, sp: Span,\n-                     vis: ast::visibility, path: ~[ast::ident]) -> ast::view_item {\n+                     vis: ast::visibility, path: ~[ast::Ident]) -> ast::view_item {\n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n                                 ast::view_path_glob(self.path(sp, path), self.next_id()))])"}, {"sha": "eb05f87a8ceacbcf18fffb0458f3d0c511d866a8", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -163,7 +163,7 @@ StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n */\n \n use ast;\n-use ast::{enum_def, expr, ident, Generics, struct_def};\n+use ast::{enum_def, expr, Ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -216,9 +216,9 @@ pub struct MethodDef<'self> {\n /// All the data about the data structure/method being derived upon.\n pub struct Substructure<'self> {\n     /// ident of self\n-    type_ident: ident,\n+    type_ident: Ident,\n     /// ident of the method\n-    method_ident: ident,\n+    method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n     self_args: &'self [@expr],\n     /// verbatim access to any other arguments\n@@ -234,26 +234,26 @@ pub enum SubstructureFields<'self> {\n     ident is the ident of the current field (`None` for all fields in tuple\n     structs).\n     */\n-    Struct(~[(Option<ident>, @expr, ~[@expr])]),\n+    Struct(~[(Option<Ident>, @expr, ~[@expr])]),\n \n     /**\n     Matching variants of the enum: variant index, ast::variant,\n     fields: `(field ident, self, [others])`, where the field ident is\n     only non-`None` in the case of a struct variant.\n     */\n-    EnumMatching(uint, &'self ast::variant, ~[(Option<ident>, @expr, ~[@expr])]),\n+    EnumMatching(uint, &'self ast::variant, ~[(Option<Ident>, @expr, ~[@expr])]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n     [field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<ident>, @expr)])]),\n+    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<Ident>, @expr)])]),\n \n     /// A static method where Self is a struct\n-    StaticStruct(&'self ast::struct_def, Either<uint, ~[ident]>),\n+    StaticStruct(&'self ast::struct_def, Either<uint, ~[Ident]>),\n     /// A static method where Self is an enum\n-    StaticEnum(&'self ast::enum_def, ~[(ident, Either<uint, ~[ident]>)])\n+    StaticEnum(&'self ast::enum_def, ~[(Ident, Either<uint, ~[Ident]>)])\n }\n \n \n@@ -273,7 +273,7 @@ representing each variant: (variant index, ast::variant instance,\n pub type EnumNonMatchFunc<'self> =\n     &'self fn(@ExtCtxt, Span,\n               &[(uint, ast::variant,\n-                 ~[(Option<ident>, @expr)])],\n+                 ~[(Option<Ident>, @expr)])],\n               &[@expr]) -> @expr;\n \n \n@@ -315,7 +315,7 @@ impl<'self> TraitDef<'self> {\n      *\n      */\n     fn create_derived_impl(&self, cx: @ExtCtxt, span: Span,\n-                           type_ident: ident, generics: &Generics,\n+                           type_ident: Ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n         let trait_path = self.path.to_path(cx, span, type_ident, generics);\n \n@@ -375,7 +375,7 @@ impl<'self> TraitDef<'self> {\n     fn expand_struct_def(&self, cx: @ExtCtxt,\n                          span: Span,\n                          struct_def: &struct_def,\n-                         type_ident: ident,\n+                         type_ident: Ident,\n                          generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n@@ -406,7 +406,7 @@ impl<'self> TraitDef<'self> {\n     fn expand_enum_def(&self,\n                        cx: @ExtCtxt, span: Span,\n                        enum_def: &enum_def,\n-                       type_ident: ident,\n+                       type_ident: Ident,\n                        generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n@@ -439,7 +439,7 @@ impl<'self> MethodDef<'self> {\n     fn call_substructure_method(&self,\n                                 cx: @ExtCtxt,\n                                 span: Span,\n-                                type_ident: ident,\n+                                type_ident: Ident,\n                                 self_args: &[@expr],\n                                 nonself_args: &[@expr],\n                                 fields: &SubstructureFields)\n@@ -456,7 +456,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn get_ret_ty(&self, cx: @ExtCtxt, span: Span,\n-                     generics: &Generics, type_ident: ident) -> ast::Ty {\n+                     generics: &Generics, type_ident: Ident) -> ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n \n@@ -465,8 +465,8 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn split_self_nonself_args(&self, cx: @ExtCtxt, span: Span,\n-                             type_ident: ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, ast::Ty)]) {\n+                             type_ident: Ident, generics: &Generics)\n+        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(Ident, ast::Ty)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -511,10 +511,10 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn create_method(&self, cx: @ExtCtxt, span: Span,\n-                     type_ident: ident,\n+                     type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n-                     arg_types: ~[(ident, ast::Ty)],\n+                     arg_types: ~[(Ident, ast::Ty)],\n                      body: @expr) -> @ast::method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n@@ -571,7 +571,7 @@ impl<'self> MethodDef<'self> {\n                                  cx: @ExtCtxt,\n                                  span: Span,\n                                  struct_def: &struct_def,\n-                                 type_ident: ident,\n+                                 type_ident: Ident,\n                                  self_args: &[@expr],\n                                  nonself_args: &[@expr])\n         -> @expr {\n@@ -625,7 +625,7 @@ impl<'self> MethodDef<'self> {\n                                         cx: @ExtCtxt,\n                                         span: Span,\n                                         struct_def: &struct_def,\n-                                        type_ident: ident,\n+                                        type_ident: Ident,\n                                         self_args: &[@expr],\n                                         nonself_args: &[@expr])\n         -> @expr {\n@@ -667,7 +667,7 @@ impl<'self> MethodDef<'self> {\n                                cx: @ExtCtxt,\n                                span: Span,\n                                enum_def: &enum_def,\n-                               type_ident: ident,\n+                               type_ident: Ident,\n                                self_args: &[@expr],\n                                nonself_args: &[@expr])\n         -> @expr {\n@@ -702,12 +702,12 @@ impl<'self> MethodDef<'self> {\n     fn build_enum_match(&self,\n                         cx: @ExtCtxt, span: Span,\n                         enum_def: &enum_def,\n-                        type_ident: ident,\n+                        type_ident: Ident,\n                         self_args: &[@expr],\n                         nonself_args: &[@expr],\n                         matching: Option<uint>,\n                         matches_so_far: &mut ~[(uint, ast::variant,\n-                                              ~[(Option<ident>, @expr)])],\n+                                              ~[(Option<Ident>, @expr)])],\n                         match_count: uint) -> @expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n@@ -852,7 +852,7 @@ impl<'self> MethodDef<'self> {\n                                cx: @ExtCtxt,\n                                span: Span,\n                                enum_def: &enum_def,\n-                               type_ident: ident,\n+                               type_ident: Ident,\n                                self_args: &[@expr],\n                                nonself_args: &[@expr])\n         -> @expr {\n@@ -874,7 +874,7 @@ impl<'self> MethodDef<'self> {\n }\n \n fn summarise_struct(cx: @ExtCtxt, span: Span,\n-                    struct_def: &struct_def) -> Either<uint, ~[ident]> {\n+                    struct_def: &struct_def) -> Either<uint, ~[Ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n     for field in struct_def.fields.iter() {\n@@ -913,11 +913,11 @@ enum StructType {\n \n fn create_struct_pattern(cx: @ExtCtxt,\n                              span: Span,\n-                             struct_ident: ident,\n+                             struct_ident: Ident,\n                              struct_def: &struct_def,\n                              prefix: &str,\n                              mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+    -> (@ast::pat, ~[(Option<Ident>, @expr)]) {\n     if struct_def.fields.is_empty() {\n         return (\n             cx.pat_ident_binding_mode(\n@@ -977,7 +977,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n                                    variant: &ast::variant,\n                                    prefix: &str,\n                                    mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+    -> (@ast::pat, ~[(Option<Ident>, @expr)]) {\n \n     let variant_ident = variant.node.name;\n     match variant.node.kind {"}, {"sha": "7fd44bfad01f2eef961578f487ad28acc04f69cf", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -18,7 +18,7 @@ library.\n \n */\n \n-use ast::{enum_def, ident, item, Generics, struct_def};\n+use ast::{enum_def, Ident, item, Generics, struct_def};\n use ast::{MetaItem, MetaList, MetaNameValue, MetaWord};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -47,13 +47,13 @@ pub mod generic;\n pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ExtCtxt,\n                                                        Span,\n                                                        x: &struct_def,\n-                                                       ident,\n+                                                       Ident,\n                                                        y: &Generics)\n                                                  -> @item;\n pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ExtCtxt,\n                                                     Span,\n                                                     x: &enum_def,\n-                                                    ident,\n+                                                    Ident,\n                                                     y: &Generics)\n                                                  -> @item;\n "}, {"sha": "b24c8eb84abdd1c60fd4186ded68af2261d83300", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, item, expr, ident};\n+use ast::{MetaItem, item, expr, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder, Duplicate};\n@@ -129,8 +129,8 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @expr {\n     };\n \n     fn rand_thing(cx: @ExtCtxt, span: Span,\n-                  ctor_ident: ident,\n-                  summary: &Either<uint, ~[ident]>,\n+                  ctor_ident: Ident,\n+                  summary: &Either<uint, ~[Ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {\n         match *summary {\n             Left(count) => {"}, {"sha": "eecce06f69f0b19cbca11d9eb4293c311372904e", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -47,8 +47,8 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n                        substr: &Substructure) -> @expr {\n     let to_str = cx.ident_of(\"to_str\");\n \n-    let doit = |start: &str, end: @str, name: ast::ident,\n-                fields: &[(Option<ast::ident>, @expr, ~[@expr])]| {\n+    let doit = |start: &str, end: @str, name: ast::Ident,\n+                fields: &[(Option<ast::Ident>, @expr, ~[@expr])]| {\n         if fields.len() == 0 {\n             cx.expr_str_uniq(span, cx.str_of(name))\n         } else {"}, {"sha": "6c1b8100f4204f7d286a6d55c87f7809ab8f336c", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -14,7 +14,7 @@ explicit `Self` type to use when specifying impls to be derived.\n */\n \n use ast;\n-use ast::{expr,Generics,ident};\n+use ast::{expr,Generics,Ident};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n@@ -59,15 +59,15 @@ impl<'self> Path<'self> {\n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n                  span: Span,\n-                 self_ty: ident,\n+                 self_ty: Ident,\n                  self_generics: &Generics)\n                  -> ast::Ty {\n         cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n                    span: Span,\n-                   self_ty: ident,\n+                   self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n@@ -120,7 +120,7 @@ impl<'self> Ty<'self> {\n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n                  span: Span,\n-                 self_ty: ident,\n+                 self_ty: Ident,\n                  self_generics: &Generics)\n                  -> ast::Ty {\n         match *self {\n@@ -158,7 +158,7 @@ impl<'self> Ty<'self> {\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n                    span: Span,\n-                   self_ty: ident,\n+                   self_ty: Ident,\n                    self_generics: &Generics)\n                    -> ast::Path {\n         match *self {\n@@ -186,7 +186,7 @@ impl<'self> Ty<'self> {\n \n \n fn mk_ty_param(cx: @ExtCtxt, span: Span, name: &str, bounds: &[Path],\n-               self_ident: ident, self_generics: &Generics) -> ast::TyParam {\n+               self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n         do bounds.map |b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n@@ -217,7 +217,7 @@ impl<'self> LifetimeBounds<'self> {\n     pub fn to_generics(&self,\n                        cx: @ExtCtxt,\n                        span: Span,\n-                       self_ty: ident,\n+                       self_ty: Ident,\n                        self_generics: &Generics)\n                        -> Generics {\n         let lifetimes = do self.lifetimes.map |lt| {"}, {"sha": "0827a9fabee5c437e25059a257896ef2c451bfc2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, NodeId, expr_, expr_mac, ident, mac_invoc_tt};\n+use ast::{Block, Crate, NodeId, expr_, expr_mac, Ident, mac_invoc_tt};\n use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use ast::{illegal_ctxt};\n use ast;\n@@ -140,7 +140,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                 }\n             }\n \n-            fn mk_simple_path(ident: ast::ident, span: Span) -> ast::Path {\n+            fn mk_simple_path(ident: ast::Ident, span: Span) -> ast::Path {\n                 ast::Path {\n                     span: span,\n                     global: false,\n@@ -523,7 +523,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n #[deriving(Clone)]\n struct NewNameFinderContext {\n-    ident_accumulator: @mut ~[ast::ident],\n+    ident_accumulator: @mut ~[ast::Ident],\n }\n \n impl Visitor<()> for NewNameFinderContext {\n@@ -645,7 +645,7 @@ impl Visitor<()> for NewNameFinderContext {\n \n     fn visit_struct_def(&mut self,\n                         struct_def: @ast::struct_def,\n-                        ident: ident,\n+                        ident: Ident,\n                         generics: &ast::Generics,\n                         node_id: NodeId,\n                         _: ()) {\n@@ -667,7 +667,7 @@ impl Visitor<()> for NewNameFinderContext {\n // return a visitor that extracts the pat_ident paths\n // from a given pattern and puts them in a mutable\n // array (passed in to the traversal)\n-pub fn new_name_finder(idents: @mut ~[ast::ident]) -> @mut Visitor<()> {\n+pub fn new_name_finder(idents: @mut ~[ast::Ident]) -> @mut Visitor<()> {\n     let context = @mut NewNameFinderContext {\n         ident_accumulator: idents,\n     };\n@@ -697,7 +697,7 @@ fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n \n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n-fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n+fn renames_to_fold(renames : @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n     let afp = default_ast_fold();\n     let f_pre = @AstFoldFns {\n         fold_ident: |id,_| {\n@@ -706,7 +706,7 @@ fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n             let new_ctxt = renames.iter().fold(id.ctxt,|ctxt,&(from,to)| {\n                 new_rename(from,to,ctxt)\n             });\n-            ast::ident{name:id.name,ctxt:new_ctxt}\n+            ast::Ident{name:id.name,ctxt:new_ctxt}\n         },\n         .. *afp\n     };\n@@ -1144,7 +1144,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n \n // given a function from idents to idents, produce\n // an ast_fold that applies that function:\n-pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n+pub fn fun_to_ident_folder(f: @fn(ast::Ident)->ast::Ident) -> @ast_fold{\n     let afp = default_ast_fold();\n     let f_pre = @AstFoldFns{\n         fold_ident : |id, _| f(id),\n@@ -1154,11 +1154,11 @@ pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n }\n \n // update the ctxts in a path to get a rename node\n-pub fn new_ident_renamer(from: ast::ident,\n+pub fn new_ident_renamer(from: ast::Ident,\n                       to: ast::Name) ->\n-    @fn(ast::ident)->ast::ident {\n-    |id : ast::ident|\n-    ast::ident{\n+    @fn(ast::Ident)->ast::Ident {\n+    |id : ast::Ident|\n+    ast::Ident{\n         name: id.name,\n         ctxt: new_rename(from,to,id.ctxt)\n     }\n@@ -1167,9 +1167,9 @@ pub fn new_ident_renamer(from: ast::ident,\n \n // update the ctxts in a path to get a mark node\n pub fn new_ident_marker(mark: uint) ->\n-    @fn(ast::ident)->ast::ident {\n-    |id : ast::ident|\n-    ast::ident{\n+    @fn(ast::Ident)->ast::Ident {\n+    |id : ast::Ident|\n+    ast::Ident{\n         name: id.name,\n         ctxt: new_mark(mark,id.ctxt)\n     }\n@@ -1178,9 +1178,9 @@ pub fn new_ident_marker(mark: uint) ->\n // perform resolution (in the MTWT sense) on all of the\n // idents in the tree. This is the final step in expansion.\n pub fn new_ident_resolver() ->\n-    @fn(ast::ident)->ast::ident {\n-    |id : ast::ident|\n-    ast::ident {\n+    @fn(ast::Ident)->ast::Ident {\n+    |id : ast::Ident|\n+    ast::Ident {\n         name : resolve(id),\n         ctxt : illegal_ctxt\n     }\n@@ -1304,7 +1304,7 @@ mod test {\n         };\n         let a_name = intern(\"a\");\n         let a2_name = intern(\"a2\");\n-        let renamer = new_ident_renamer(ast::ident{name:a_name,ctxt:empty_ctxt},\n+        let renamer = new_ident_renamer(ast::Ident{name:a_name,ctxt:empty_ctxt},\n                                         a2_name);\n         let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).unwrap();\n         let resolver = new_ident_resolver();"}, {"sha": "4e7275b75c8ef43a3d91960ecc78ecad0705ab89", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -50,7 +50,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n fn pieces_to_expr(cx: @ExtCtxt, sp: Span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(ident: &str) -> ~[ast::ident] {\n+    fn make_path_vec(ident: &str) -> ~[ast::Ident] {\n         return ~[str_to_ident(\"std\"),\n                  str_to_ident(\"unstable\"),\n                  str_to_ident(\"extfmt\"),"}, {"sha": "474c0ce60a782733149584aac8c02076fe5620aa", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -637,7 +637,7 @@ impl Context {\n     }\n \n     fn format_arg(&self, sp: Span, arg: Either<uint, @str>,\n-                  ident: ast::ident) -> @ast::expr {\n+                  ident: ast::Ident) -> @ast::expr {\n         let ty = match arg {\n             Left(i) => self.arg_types[i].unwrap(),\n             Right(s) => *self.name_types.get(&s)"}, {"sha": "bea18d868a0d11db5f4bd6647f566acbb4e7e8af", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -68,7 +68,7 @@ pub mod rt {\n         fn to_source(&self) -> @str;\n     }\n \n-    impl ToSource for ast::ident {\n+    impl ToSource for ast::Ident {\n         fn to_source(&self) -> @str {\n             ident_to_str(self)\n         }\n@@ -216,7 +216,7 @@ pub mod rt {\n         )\n     )\n \n-    impl_to_tokens!(ast::ident)\n+    impl_to_tokens!(ast::Ident)\n     impl_to_tokens!(@ast::item)\n     impl_to_tokens_self!(&'self [@ast::item])\n     impl_to_tokens!(ast::Ty)\n@@ -334,16 +334,16 @@ pub fn expand_quote_stmt(cx: @ExtCtxt,\n                                     ~[e_attrs], tts))\n }\n \n-fn ids_ext(strs: ~[~str]) -> ~[ast::ident] {\n+fn ids_ext(strs: ~[~str]) -> ~[ast::Ident] {\n     strs.map(|str| str_to_ident(*str))\n }\n \n-fn id_ext(str: &str) -> ast::ident {\n+fn id_ext(str: &str) -> ast::Ident {\n     str_to_ident(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::ident) -> @ast::expr {\n+fn mk_ident(cx: @ExtCtxt, sp: Span, ident: ast::Ident) -> @ast::expr {\n     let e_str = cx.expr_str(sp, cx.str_of(ident));\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),"}, {"sha": "7a9e916421c0f74e84e48badc94b0412eb36f5dc", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -11,7 +11,7 @@\n // Earley-like parser for macros.\n \n use ast;\n-use ast::{matcher, match_tok, match_seq, match_nonterminal, ident};\n+use ast::{matcher, match_tok, match_seq, match_nonterminal, Ident};\n use codemap::{BytePos, mk_sp};\n use codemap;\n use parse::lexer::*; //resolve bug?\n@@ -189,9 +189,9 @@ pub enum named_match {\n pub type earley_item = ~MatcherPos;\n \n pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n-            -> HashMap<ident,@named_match> {\n+            -> HashMap<Ident,@named_match> {\n     fn n_rec(p_s: @mut ParseSess, m: &matcher, res: &[@named_match],\n-             ret_val: &mut HashMap<ident, @named_match>) {\n+             ret_val: &mut HashMap<Ident, @named_match>) {\n         match *m {\n           codemap::Spanned {node: match_tok(_), _} => (),\n           codemap::Spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n@@ -216,7 +216,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n }\n \n pub enum parse_result {\n-    success(HashMap<ident, @named_match>),\n+    success(HashMap<Ident, @named_match>),\n     failure(codemap::Span, ~str),\n     error(codemap::Span, ~str)\n }\n@@ -226,7 +226,7 @@ pub fn parse_or_else(\n     cfg: ast::CrateConfig,\n     rdr: @mut reader,\n     ms: ~[matcher]\n-) -> HashMap<ident, @named_match> {\n+) -> HashMap<Ident, @named_match> {\n     match parse(sess, cfg, rdr, ms) {\n       success(m) => m,\n       failure(sp, str) => sess.span_diagnostic.span_fatal(sp, str),"}, {"sha": "732ae2ccb9608bb100be0a1c94a877691c42c7e4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n+use ast::{Ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n use codemap::{Span, Spanned, dummy_sp};\n@@ -25,7 +25,7 @@ use print;\n \n pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: Span,\n-                         name: ident,\n+                         name: Ident,\n                          arg: ~[ast::token_tree])\n                       -> base::MacResult {\n     // these spans won't matter, anyways\n@@ -74,7 +74,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ExtCtxt, sp: Span, name: ident,\n+    fn generic_extension(cx: @ExtCtxt, sp: Span, name: Ident,\n                          arg: &[ast::token_tree],\n                          lhses: &[@named_match], rhses: &[@named_match])\n     -> MacResult {"}, {"sha": "8a858f3d9858f4de21d624898c35f395312cf6cd", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n+use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,Ident};\n use codemap::{Span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n@@ -34,7 +34,7 @@ pub struct TtReader {\n     // the unzipped tree:\n     stack: @mut TtFrame,\n     /* for MBE-style macro transcription */\n-    interpolations: HashMap<ident, @named_match>,\n+    interpolations: HashMap<Ident, @named_match>,\n     repeat_idx: ~[uint],\n     repeat_len: ~[uint],\n     /* cached: */\n@@ -46,7 +46,7 @@ pub struct TtReader {\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @mut span_handler,\n-                     interp: Option<HashMap<ident,@named_match>>,\n+                     interp: Option<HashMap<Ident,@named_match>>,\n                      src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n@@ -113,7 +113,7 @@ fn lookup_cur_matched_by_matched(r: &mut TtReader,\n     r.repeat_idx.iter().fold(start, red)\n }\n \n-fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n+fn lookup_cur_matched(r: &mut TtReader, name: Ident) -> @named_match {\n     match r.interpolations.find_copy(&name) {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n@@ -126,7 +126,7 @@ fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n #[deriving(Clone)]\n enum lis {\n     lis_unconstrained,\n-    lis_constraint(uint, ident),\n+    lis_constraint(uint, Ident),\n     lis_contradiction(~str),\n }\n "}, {"sha": "7e3695614ae38c5f6b54cabf53e0eb3273677c43", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -32,7 +32,7 @@ pub trait ast_fold {\n     fn fold_mod(@self, &_mod) -> _mod;\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n-    fn fold_ident(@self, ident) -> ident;\n+    fn fold_ident(@self, Ident) -> Ident;\n     fn fold_path(@self, &Path) -> Path;\n     fn fold_local(@self, @Local) -> @Local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n@@ -61,7 +61,7 @@ pub struct AstFoldFns {\n     fold_mod: @fn(&_mod, @ast_fold) -> _mod,\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n     fold_variant: @fn(&variant_, Span, @ast_fold) -> (variant_, Span),\n-    fold_ident: @fn(ident, @ast_fold) -> ident,\n+    fold_ident: @fn(Ident, @ast_fold) -> Ident,\n     fold_path: @fn(&Path, @ast_fold) -> Path,\n     fold_local: @fn(@Local, @ast_fold) -> @Local,\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n@@ -758,7 +758,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n     }\n }\n \n-fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n+fn noop_fold_ident(i: Ident, _fld: @ast_fold) -> Ident {\n     i\n }\n \n@@ -913,7 +913,7 @@ impl ast_fold for AstFoldFns {\n         let (n, s) = (self.fold_variant)(&x.node, x.span, self as @ast_fold);\n         Spanned { node: n, span: (self.new_span)(s) }\n     }\n-    fn fold_ident(@self, x: ident) -> ident {\n+    fn fold_ident(@self, x: Ident) -> Ident {\n         (self.fold_ident)(x, self as @ast_fold)\n     }\n     fn fold_path(@self, x: &Path) -> Path {\n@@ -961,7 +961,7 @@ mod test {\n     // taken from expand\n     // given a function from idents to idents, produce\n     // an ast_fold that applies that function:\n-    pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n+    pub fn fun_to_ident_folder(f: @fn(ast::Ident)->ast::Ident) -> @ast_fold{\n         let afp = default_ast_fold();\n         let f_pre = @AstFoldFns{\n             fold_ident : |id, _| f(id),\n@@ -976,7 +976,7 @@ mod test {\n     }\n \n     // change every identifier to \"zz\"\n-    pub fn to_zz() -> @fn(ast::ident)->ast::ident {\n+    pub fn to_zz() -> @fn(ast::Ident)->ast::Ident {\n         let zz_id = token::str_to_ident(\"zz\");\n         |_id| {zz_id}\n     }"}, {"sha": "ac3a2d1316fbf6dc7db8f2219eda494b89e48d3a", "filename": "src/libsyntax/oldvisit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Foldvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Foldvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Foldvisit.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -34,10 +34,10 @@ pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind<'self> {\n     // fn foo() or extern \"Abi\" fn foo()\n-    fk_item_fn(ident, &'self Generics, purity, AbiSet),\n+    fk_item_fn(Ident, &'self Generics, purity, AbiSet),\n \n     // fn foo(&self)\n-    fk_method(ident, &'self Generics, &'self method),\n+    fk_method(Ident, &'self Generics, &'self method),\n \n     // @fn(x, y) { ... }\n     fk_anon(ast::Sigil),\n@@ -46,7 +46,7 @@ pub enum fn_kind<'self> {\n     fk_fn_block,\n }\n \n-pub fn name_of_fn(fk: &fn_kind) -> ident {\n+pub fn name_of_fn(fk: &fn_kind) -> Ident {\n     match *fk {\n       fk_item_fn(name, _, _, _) | fk_method(name, _, _) => {\n           name\n@@ -88,7 +88,7 @@ pub struct Visitor<E> {\n     visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId, (E, vt<E>)),\n     visit_ty_method: @fn(&TypeMethod, (E, vt<E>)),\n     visit_trait_method: @fn(&trait_method, (E, vt<E>)),\n-    visit_struct_def: @fn(@struct_def, ident, &Generics, NodeId, (E, vt<E>)),\n+    visit_struct_def: @fn(@struct_def, Ident, &Generics, NodeId, (E, vt<E>)),\n     visit_struct_field: @fn(@struct_field, (E, vt<E>)),\n }\n \n@@ -422,7 +422,7 @@ pub fn visit_trait_method<E:Clone>(m: &trait_method, (e, v): (E, vt<E>)) {\n \n pub fn visit_struct_def<E:Clone>(\n     sd: @struct_def,\n-    _nm: ast::ident,\n+    _nm: ast::Ident,\n     _generics: &Generics,\n     _id: NodeId,\n     (e, v): (E, vt<E>)\n@@ -612,7 +612,7 @@ pub struct SimpleVisitor {\n     visit_fn: @fn(&fn_kind, &fn_decl, &Block, Span, NodeId),\n     visit_ty_method: @fn(&TypeMethod),\n     visit_trait_method: @fn(&trait_method),\n-    visit_struct_def: @fn(@struct_def, ident, &Generics, NodeId),\n+    visit_struct_def: @fn(@struct_def, Ident, &Generics, NodeId),\n     visit_struct_field: @fn(@struct_field),\n     visit_struct_method: @fn(@method)\n }\n@@ -715,9 +715,9 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         visit_trait_method(m, (e, v));\n     }\n     fn v_struct_def(\n-        f: @fn(@struct_def, ident, &Generics, NodeId),\n+        f: @fn(@struct_def, Ident, &Generics, NodeId),\n         sd: @struct_def,\n-        nm: ident,\n+        nm: Ident,\n         generics: &Generics,\n         id: NodeId,\n         (e, v): ((), vt<()>)"}, {"sha": "02af6d23b441568b3a5eac4a4755a784bb242c1f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -34,7 +34,7 @@ use ast::{expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, expr_for_loop, extern_fn, Field, fn_decl};\n use ast::{expr_vstore_uniq, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_static, foreign_item_fn, foreign_mod};\n-use ast::{ident, impure_fn, inherited, item, item_, item_static};\n+use ast::{Ident, impure_fn, inherited, item, item_, item_static};\n use ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n use ast::{item_mac, item_mod, item_struct, item_trait, item_ty, lit, lit_};\n use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int};\n@@ -95,7 +95,7 @@ enum restriction {\n }\n \n type arg_or_capture_item = Either<arg, ()>;\n-type item_info = (ident, item_, Option<~[Attribute]>);\n+type item_info = (Ident, item_, Option<~[Attribute]>);\n \n /// How to parse a path. There are four different kinds of paths, all of which\n /// are parsed somewhat differently.\n@@ -476,7 +476,7 @@ impl Parser {\n         self.commit_stmt(s, &[edible], &[])\n     }\n \n-    pub fn parse_ident(&self) -> ast::ident {\n+    pub fn parse_ident(&self) -> ast::Ident {\n         self.check_strict_keywords();\n         self.check_reserved_keywords();\n         match *self.token {\n@@ -756,7 +756,7 @@ impl Parser {\n     }\n     pub fn get_id(&self) -> NodeId { next_node_id(self.sess) }\n \n-    pub fn id_to_str(&self, id: ident) -> @str {\n+    pub fn id_to_str(&self, id: Ident) -> @str {\n         get_ident_interner().get(id.name)\n     }\n \n@@ -775,7 +775,7 @@ impl Parser {\n         }\n     }\n \n-    pub fn get_lifetime(&self, tok: &token::Token) -> ast::ident {\n+    pub fn get_lifetime(&self, tok: &token::Token) -> ast::Ident {\n         match *tok {\n             token::LIFETIME(ref ident) => *ident,\n             _ => self.bug(\"not a lifetime\"),\n@@ -1664,7 +1664,7 @@ impl Parser {\n \n     pub fn mk_method_call(&self,\n                       rcvr: @expr,\n-                      ident: ident,\n+                      ident: Ident,\n                       tps: ~[Ty],\n                       args: ~[@expr],\n                       sugar: CallSugar) -> ast::expr_ {\n@@ -1675,7 +1675,7 @@ impl Parser {\n         expr_index(self.get_id(), expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[Ty]) -> ast::expr_ {\n+    pub fn mk_field(&self, expr: @expr, ident: Ident, tys: ~[Ty]) -> ast::expr_ {\n         expr_field(expr, ident, tys)\n     }\n \n@@ -2550,7 +2550,7 @@ impl Parser {\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n-    pub fn parse_loop_expr(&self, opt_ident: Option<ast::ident>) -> @expr {\n+    pub fn parse_loop_expr(&self, opt_ident: Option<ast::Ident>) -> @expr {\n         // loop headers look like 'loop {' or 'loop unsafe {'\n         let is_loop_header =\n             *self.token == token::LBRACE\n@@ -3713,13 +3713,13 @@ impl Parser {\n     }\n \n     // parse the name and optional generic types of a function header.\n-    fn parse_fn_header(&self) -> (ident, ast::Generics) {\n+    fn parse_fn_header(&self) -> (Ident, ast::Generics) {\n         let id = self.parse_ident();\n         let generics = self.parse_generics();\n         (id, generics)\n     }\n \n-    fn mk_item(&self, lo: BytePos, hi: BytePos, ident: ident,\n+    fn mk_item(&self, lo: BytePos, hi: BytePos, ident: Ident,\n                node: item_, vis: visibility,\n                attrs: ~[Attribute]) -> @item {\n         @ast::item { ident: ident,\n@@ -4107,7 +4107,7 @@ impl Parser {\n         }\n     }\n \n-    fn push_mod_path(&self, id: ident, attrs: &[Attribute]) {\n+    fn push_mod_path(&self, id: Ident, attrs: &[Attribute]) {\n         let default_path = token::interner_get(id.name);\n         let file_path = match ::attr::first_attr_value_str_by_name(attrs,\n                                                                    \"path\") {\n@@ -4123,7 +4123,7 @@ impl Parser {\n \n     // read a module from a source file.\n     fn eval_src_mod(&self,\n-                    id: ast::ident,\n+                    id: ast::Ident,\n                     outer_attrs: &[ast::Attribute],\n                     id_sp: Span)\n                     -> (ast::item_, ~[ast::Attribute]) {"}, {"sha": "3d47b1141ddd0110f0dd2f8a47ddc8b04ac54a67", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -76,22 +76,22 @@ pub enum Token {\n     LIT_INT(i64, ast::int_ty),\n     LIT_UINT(u64, ast::uint_ty),\n     LIT_INT_UNSUFFIXED(i64),\n-    LIT_FLOAT(ast::ident, ast::float_ty),\n-    LIT_FLOAT_UNSUFFIXED(ast::ident),\n-    LIT_STR(ast::ident),\n+    LIT_FLOAT(ast::Ident, ast::float_ty),\n+    LIT_FLOAT_UNSUFFIXED(ast::Ident),\n+    LIT_STR(ast::Ident),\n \n     /* Name components */\n     // an identifier contains an \"is_mod_name\" boolean,\n     // indicating whether :: follows this token with no\n     // whitespace in between.\n-    IDENT(ast::ident, bool),\n+    IDENT(ast::Ident, bool),\n     UNDERSCORE,\n-    LIFETIME(ast::ident),\n+    LIFETIME(ast::Ident),\n \n     /* For interpolation */\n     INTERPOLATED(nonterminal),\n \n-    DOC_COMMENT(ast::ident),\n+    DOC_COMMENT(ast::Ident),\n     EOF,\n }\n \n@@ -104,7 +104,7 @@ pub enum nonterminal {\n     nt_pat( @ast::pat),\n     nt_expr(@ast::expr),\n     nt_ty(  ~ast::Ty),\n-    nt_ident(~ast::ident, bool),\n+    nt_ident(~ast::Ident, bool),\n     nt_attr(@ast::Attribute),   // #[foo]\n     nt_path(~ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n@@ -307,46 +307,46 @@ pub fn is_bar(t: &Token) -> bool {\n \n \n pub mod special_idents {\n-    use ast::ident;\n+    use ast::Ident;\n \n-    pub static underscore : ident = ident { name: 0, ctxt: 0};\n-    pub static anon : ident = ident { name: 1, ctxt: 0};\n-    pub static invalid : ident = ident { name: 2, ctxt: 0}; // ''\n-    pub static unary : ident = ident { name: 3, ctxt: 0};\n-    pub static not_fn : ident = ident { name: 4, ctxt: 0};\n-    pub static idx_fn : ident = ident { name: 5, ctxt: 0};\n-    pub static unary_minus_fn : ident = ident { name: 6, ctxt: 0};\n-    pub static clownshoes_extensions : ident = ident { name: 7, ctxt: 0};\n+    pub static underscore : Ident = Ident { name: 0, ctxt: 0};\n+    pub static anon : Ident = Ident { name: 1, ctxt: 0};\n+    pub static invalid : Ident = Ident { name: 2, ctxt: 0}; // ''\n+    pub static unary : Ident = Ident { name: 3, ctxt: 0};\n+    pub static not_fn : Ident = Ident { name: 4, ctxt: 0};\n+    pub static idx_fn : Ident = Ident { name: 5, ctxt: 0};\n+    pub static unary_minus_fn : Ident = Ident { name: 6, ctxt: 0};\n+    pub static clownshoes_extensions : Ident = Ident { name: 7, ctxt: 0};\n \n-    pub static self_ : ident = ident { name: 8, ctxt: 0}; // 'self'\n+    pub static self_ : Ident = Ident { name: 8, ctxt: 0}; // 'self'\n \n     /* for matcher NTs */\n-    pub static item : ident = ident { name: 9, ctxt: 0};\n-    pub static block : ident = ident { name: 10, ctxt: 0};\n-    pub static stmt : ident = ident { name: 11, ctxt: 0};\n-    pub static pat : ident = ident { name: 12, ctxt: 0};\n-    pub static expr : ident = ident { name: 13, ctxt: 0};\n-    pub static ty : ident = ident { name: 14, ctxt: 0};\n-    pub static ident : ident = ident { name: 15, ctxt: 0};\n-    pub static path : ident = ident { name: 16, ctxt: 0};\n-    pub static tt : ident = ident { name: 17, ctxt: 0};\n-    pub static matchers : ident = ident { name: 18, ctxt: 0};\n-\n-    pub static str : ident = ident { name: 19, ctxt: 0}; // for the type\n+    pub static item : Ident = Ident { name: 9, ctxt: 0};\n+    pub static block : Ident = Ident { name: 10, ctxt: 0};\n+    pub static stmt : Ident = Ident { name: 11, ctxt: 0};\n+    pub static pat : Ident = Ident { name: 12, ctxt: 0};\n+    pub static expr : Ident = Ident { name: 13, ctxt: 0};\n+    pub static ty : Ident = Ident { name: 14, ctxt: 0};\n+    pub static ident : Ident = Ident { name: 15, ctxt: 0};\n+    pub static path : Ident = Ident { name: 16, ctxt: 0};\n+    pub static tt : Ident = Ident { name: 17, ctxt: 0};\n+    pub static matchers : Ident = Ident { name: 18, ctxt: 0};\n+\n+    pub static str : Ident = Ident { name: 19, ctxt: 0}; // for the type\n \n     /* outside of libsyntax */\n-    pub static arg : ident = ident { name: 20, ctxt: 0};\n-    pub static descrim : ident = ident { name: 21, ctxt: 0};\n-    pub static clownshoe_abi : ident = ident { name: 22, ctxt: 0};\n-    pub static clownshoe_stack_shim : ident = ident { name: 23, ctxt: 0};\n-    pub static main : ident = ident { name: 24, ctxt: 0};\n-    pub static opaque : ident = ident { name: 25, ctxt: 0};\n-    pub static blk : ident = ident { name: 26, ctxt: 0};\n-    pub static statik : ident = ident { name: 27, ctxt: 0};\n-    pub static clownshoes_foreign_mod: ident = ident { name: 28, ctxt: 0};\n-    pub static unnamed_field: ident = ident { name: 29, ctxt: 0};\n-    pub static c_abi: ident = ident { name: 30, ctxt: 0};\n-    pub static type_self: ident = ident { name: 31, ctxt: 0};    // `Self`\n+    pub static arg : Ident = Ident { name: 20, ctxt: 0};\n+    pub static descrim : Ident = Ident { name: 21, ctxt: 0};\n+    pub static clownshoe_abi : Ident = Ident { name: 22, ctxt: 0};\n+    pub static clownshoe_stack_shim : Ident = Ident { name: 23, ctxt: 0};\n+    pub static main : Ident = Ident { name: 24, ctxt: 0};\n+    pub static opaque : Ident = Ident { name: 25, ctxt: 0};\n+    pub static blk : Ident = Ident { name: 26, ctxt: 0};\n+    pub static statik : Ident = Ident { name: 27, ctxt: 0};\n+    pub static clownshoes_foreign_mod: Ident = Ident { name: 28, ctxt: 0};\n+    pub static unnamed_field: Ident = Ident { name: 29, ctxt: 0};\n+    pub static c_abi: Ident = Ident { name: 30, ctxt: 0};\n+    pub static type_self: Ident = Ident { name: 31, ctxt: 0};    // `Self`\n }\n \n /**\n@@ -525,18 +525,18 @@ pub fn interner_get(name : Name) -> @str {\n }\n \n // maps an identifier to the string that it corresponds to\n-pub fn ident_to_str(id : &ast::ident) -> @str {\n+pub fn ident_to_str(id : &ast::Ident) -> @str {\n     interner_get(id.name)\n }\n \n // maps a string to an identifier with an empty syntax context\n-pub fn str_to_ident(str : &str) -> ast::ident {\n-    ast::new_ident(intern(str))\n+pub fn str_to_ident(str : &str) -> ast::Ident {\n+    ast::Ident::new(intern(str))\n }\n \n // maps a string to a gensym'ed identifier\n-pub fn gensym_ident(str : &str) -> ast::ident {\n-    ast::new_ident(gensym(str))\n+pub fn gensym_ident(str : &str) -> ast::Ident {\n+    ast::Ident::new(gensym(str))\n }\n \n \n@@ -561,7 +561,7 @@ pub fn fresh_name(src_name : &str) -> Name {\n  * the language and may not appear as identifiers.\n  */\n pub mod keywords {\n-    use ast::ident;\n+    use ast::Ident;\n \n     pub enum Keyword {\n         // Strict keywords\n@@ -608,46 +608,46 @@ pub mod keywords {\n     }\n \n     impl Keyword {\n-        pub fn to_ident(&self) -> ident {\n+        pub fn to_ident(&self) -> Ident {\n             match *self {\n-                As => ident { name: 32, ctxt: 0 },\n-                Break => ident { name: 33, ctxt: 0 },\n-                Const => ident { name: 34, ctxt: 0 },\n-                Do => ident { name: 35, ctxt: 0 },\n-                Else => ident { name: 36, ctxt: 0 },\n-                Enum => ident { name: 37, ctxt: 0 },\n-                Extern => ident { name: 38, ctxt: 0 },\n-                False => ident { name: 39, ctxt: 0 },\n-                Fn => ident { name: 40, ctxt: 0 },\n-                For => ident { name: 41, ctxt: 0 },\n-                If => ident { name: 42, ctxt: 0 },\n-                Impl => ident { name: 43, ctxt: 0 },\n-                In => ident { name: 63, ctxt: 0 },\n-                Let => ident { name: 44, ctxt: 0 },\n-                __Log => ident { name: 45, ctxt: 0 },\n-                Loop => ident { name: 46, ctxt: 0 },\n-                Match => ident { name: 47, ctxt: 0 },\n-                Mod => ident { name: 48, ctxt: 0 },\n-                Mut => ident { name: 49, ctxt: 0 },\n-                Once => ident { name: 50, ctxt: 0 },\n-                Priv => ident { name: 51, ctxt: 0 },\n-                Pub => ident { name: 52, ctxt: 0 },\n-                Ref => ident { name: 53, ctxt: 0 },\n-                Return => ident { name: 54, ctxt: 0 },\n-                Static => ident { name: 27, ctxt: 0 },\n-                Self => ident { name: 8, ctxt: 0 },\n-                Struct => ident { name: 55, ctxt: 0 },\n-                Super => ident { name: 56, ctxt: 0 },\n-                True => ident { name: 57, ctxt: 0 },\n-                Trait => ident { name: 58, ctxt: 0 },\n-                Type => ident { name: 59, ctxt: 0 },\n-                Typeof => ident { name: 67, ctxt: 0 },\n-                Unsafe => ident { name: 60, ctxt: 0 },\n-                Use => ident { name: 61, ctxt: 0 },\n-                While => ident { name: 62, ctxt: 0 },\n-                Be => ident { name: 64, ctxt: 0 },\n-                Pure => ident { name: 65, ctxt: 0 },\n-                Yield => ident { name: 66, ctxt: 0 },\n+                As => Ident { name: 32, ctxt: 0 },\n+                Break => Ident { name: 33, ctxt: 0 },\n+                Const => Ident { name: 34, ctxt: 0 },\n+                Do => Ident { name: 35, ctxt: 0 },\n+                Else => Ident { name: 36, ctxt: 0 },\n+                Enum => Ident { name: 37, ctxt: 0 },\n+                Extern => Ident { name: 38, ctxt: 0 },\n+                False => Ident { name: 39, ctxt: 0 },\n+                Fn => Ident { name: 40, ctxt: 0 },\n+                For => Ident { name: 41, ctxt: 0 },\n+                If => Ident { name: 42, ctxt: 0 },\n+                Impl => Ident { name: 43, ctxt: 0 },\n+                In => Ident { name: 63, ctxt: 0 },\n+                Let => Ident { name: 44, ctxt: 0 },\n+                __Log => Ident { name: 45, ctxt: 0 },\n+                Loop => Ident { name: 46, ctxt: 0 },\n+                Match => Ident { name: 47, ctxt: 0 },\n+                Mod => Ident { name: 48, ctxt: 0 },\n+                Mut => Ident { name: 49, ctxt: 0 },\n+                Once => Ident { name: 50, ctxt: 0 },\n+                Priv => Ident { name: 51, ctxt: 0 },\n+                Pub => Ident { name: 52, ctxt: 0 },\n+                Ref => Ident { name: 53, ctxt: 0 },\n+                Return => Ident { name: 54, ctxt: 0 },\n+                Static => Ident { name: 27, ctxt: 0 },\n+                Self => Ident { name: 8, ctxt: 0 },\n+                Struct => Ident { name: 55, ctxt: 0 },\n+                Super => Ident { name: 56, ctxt: 0 },\n+                True => Ident { name: 57, ctxt: 0 },\n+                Trait => Ident { name: 58, ctxt: 0 },\n+                Type => Ident { name: 59, ctxt: 0 },\n+                Typeof => Ident { name: 67, ctxt: 0 },\n+                Unsafe => Ident { name: 60, ctxt: 0 },\n+                Use => Ident { name: 61, ctxt: 0 },\n+                While => Ident { name: 62, ctxt: 0 },\n+                Be => Ident { name: 64, ctxt: 0 },\n+                Pure => Ident { name: 65, ctxt: 0 },\n+                Yield => Ident { name: 66, ctxt: 0 },\n             }\n         }\n     }"}, {"sha": "c03bcca7bf9e840d30b5fc030ddedcf368f080cf", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -185,7 +185,7 @@ pub fn path_to_str(p: &ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n-pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::ident,\n+pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::explicit_self_>,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n@@ -639,7 +639,7 @@ fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n }\n \n pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n-                      generics: &ast::Generics, ident: ast::ident,\n+                      generics: &ast::Generics, ident: ast::Ident,\n                       span: codemap::Span, visibility: ast::visibility) {\n     head(s, visibility_qualified(visibility, \"enum\"));\n     print_ident(s, ident);\n@@ -691,7 +691,7 @@ pub fn print_visibility(s: @ps, vis: ast::visibility) {\n pub fn print_struct(s: @ps,\n                     struct_def: &ast::struct_def,\n                     generics: &ast::Generics,\n-                    ident: ast::ident,\n+                    ident: ast::Ident,\n                     span: codemap::Span) {\n     print_ident(s, ident);\n     print_generics(s, generics);\n@@ -1495,7 +1495,7 @@ pub fn print_decl(s: @ps, decl: &ast::decl) {\n     }\n }\n \n-pub fn print_ident(s: @ps, ident: ast::ident) {\n+pub fn print_ident(s: @ps, ident: ast::Ident) {\n     word(s.s, ident_to_str(&ident));\n }\n \n@@ -1698,7 +1698,7 @@ pub fn print_fn(s: @ps,\n                 decl: &ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 abis: AbiSet,\n-                name: ast::ident,\n+                name: ast::Ident,\n                 generics: &ast::Generics,\n                 opt_explicit_self: Option<ast::explicit_self_>,\n                 vis: ast::visibility) {\n@@ -1946,7 +1946,7 @@ pub fn print_ty_fn(s: @ps,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n                    decl: &ast::fn_decl,\n-                   id: Option<ast::ident>,\n+                   id: Option<ast::Ident>,\n                    opt_bounds: &Option<OptVec<ast::TyParamBound>>,\n                    generics: Option<&ast::Generics>,\n                    opt_explicit_self: Option<ast::explicit_self_>) {"}, {"sha": "a421d44e2e36d506daafd39a4a7e475c584112c6", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -82,7 +82,7 @@ pub fn string_to_pat(source_str : @str) -> @ast::pat {\n }\n \n // convert a vector of strings to a vector of ast::idents\n-pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::ident] {\n+pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::Ident] {\n     ids.map(|u| token::str_to_ident(*u))\n }\n "}, {"sha": "6ccaece27b9818a97f03a6088be63b212880de57", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a28e595c2aacf38c12a56807547e7cda6839ee/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=73a28e595c2aacf38c12a56807547e7cda6839ee", "patch": "@@ -30,10 +30,10 @@ use opt_vec::OptVec;\n \n pub enum fn_kind<'self> {\n     // fn foo() or extern \"Abi\" fn foo()\n-    fk_item_fn(ident, &'self Generics, purity, AbiSet),\n+    fk_item_fn(Ident, &'self Generics, purity, AbiSet),\n \n     // fn foo(&self)\n-    fk_method(ident, &'self Generics, &'self method),\n+    fk_method(Ident, &'self Generics, &'self method),\n \n     // @fn(x, y) { ... }\n     fk_anon(ast::Sigil),\n@@ -42,7 +42,7 @@ pub enum fn_kind<'self> {\n     fk_fn_block,\n }\n \n-pub fn name_of_fn(fk: &fn_kind) -> ident {\n+pub fn name_of_fn(fk: &fn_kind) -> Ident {\n     match *fk {\n       fk_item_fn(name, _, _, _) | fk_method(name, _, _) => {\n           name\n@@ -86,7 +86,7 @@ pub trait Visitor<E:Clone> {\n     }\n     fn visit_ty_method(&mut self, t:&TypeMethod, e:E) { walk_ty_method(self, t, e) }\n     fn visit_trait_method(&mut self, t:&trait_method, e:E) { walk_trait_method(self, t, e) }\n-    fn visit_struct_def(&mut self, s:@struct_def, i:ident, g:&Generics, n:NodeId, e:E) {\n+    fn visit_struct_def(&mut self, s:@struct_def, i:Ident, g:&Generics, n:NodeId, e:E) {\n         walk_struct_def(self, s, i, g, n, e)\n     }\n     fn visit_struct_field(&mut self, s:@struct_field, e:E) { walk_struct_field(self, s, e) }\n@@ -144,7 +144,7 @@ impl<E:Clone> Visitor<E> for @mut Visitor<E> {\n     fn visit_trait_method(&mut self, a:&trait_method, e:E) {\n         (*self).visit_trait_method(a, e)\n     }\n-    fn visit_struct_def(&mut self, a:@struct_def, b:ident, c:&Generics, d:NodeId, e:E) {\n+    fn visit_struct_def(&mut self, a:@struct_def, b:Ident, c:&Generics, d:NodeId, e:E) {\n         (*self).visit_struct_def(a, b, c, d, e)\n     }\n     fn visit_struct_field(&mut self, a:@struct_field, e:E) {\n@@ -476,7 +476,7 @@ pub fn walk_trait_method<E:Clone, V:Visitor<E>>(visitor: &mut V,\n \n pub fn walk_struct_def<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                                  struct_definition: @struct_def,\n-                                 _: ast::ident,\n+                                 _: ast::Ident,\n                                  _: &Generics,\n                                  _: NodeId,\n                                  env: E) {\n@@ -693,7 +693,7 @@ pub trait SimpleVisitor {\n     fn visit_fn(&mut self, &fn_kind, &fn_decl, &Block, Span, NodeId);\n     fn visit_ty_method(&mut self, &TypeMethod);\n     fn visit_trait_method(&mut self, &trait_method);\n-    fn visit_struct_def(&mut self, @struct_def, ident, &Generics, NodeId);\n+    fn visit_struct_def(&mut self, @struct_def, Ident, &Generics, NodeId);\n     fn visit_struct_field(&mut self, @struct_field);\n     fn visit_struct_method(&mut self, @method);\n }\n@@ -792,7 +792,7 @@ impl Visitor<()> for SimpleVisitorVisitor {\n     }\n     fn visit_struct_def(&mut self,\n                         struct_definition: @struct_def,\n-                        identifier: ident,\n+                        identifier: Ident,\n                         generics: &Generics,\n                         node_id: NodeId,\n                         env: ()) {"}]}