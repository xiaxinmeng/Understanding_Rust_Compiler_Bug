{"sha": "9c5e9a500da3210735160ee24736d2cae09eb4fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNWU5YTUwMGRhMzIxMDczNTE2MGVlMjQ3MzZkMmNhZTA5ZWI0ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-14T13:47:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-14T13:47:44Z"}, "message": "Auto merge of #45167 - pnkfelix:migrate-remaining-ast-diagnostics, r=arielb1\n\nMIR-borrowck: Migrate remaining ast diagnostics\n\nThis PR migrates all of the remaining diagnostics in `rustc_borrowck` over to `rustc_mir`, exposing them for use by both AST-borrowck and MIR-borrowck.\n\nThis should hopefully resolve all remaining cases of diagnostic messages emitted from borrowck under `-Z borrowck-mir` without an origin annotation.", "tree": {"sha": "e00ea8d3e522fb2838d7c32c7f200ed9affe29f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e00ea8d3e522fb2838d7c32c7f200ed9affe29f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c5e9a500da3210735160ee24736d2cae09eb4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e9a500da3210735160ee24736d2cae09eb4fb", "html_url": "https://github.com/rust-lang/rust/commit/9c5e9a500da3210735160ee24736d2cae09eb4fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c5e9a500da3210735160ee24736d2cae09eb4fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af7de7b6774b061b7809ce9aa6db31ea29df33c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/af7de7b6774b061b7809ce9aa6db31ea29df33c8", "html_url": "https://github.com/rust-lang/rust/commit/af7de7b6774b061b7809ce9aa6db31ea29df33c8"}, {"sha": "5b68e1f8da35ed361633d1838988e9ce15f51620", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b68e1f8da35ed361633d1838988e9ce15f51620", "html_url": "https://github.com/rust-lang/rust/commit/5b68e1f8da35ed361633d1838988e9ce15f51620"}], "stats": {"total": 1152, "additions": 622, "deletions": 530}, "files": [{"sha": "fc3c2a3f68fedfcfaec97f3f7b21ee7e284312d7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 27, "deletions": 52, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9c5e9a500da3210735160ee24736d2cae09eb4fb", "patch": "@@ -614,11 +614,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let partial = moved_lp.depth() > lp.depth();\n                 let msg = if !has_fork && partial { \"partially \" }\n                           else if has_fork && !has_common { \"collaterally \"}\n-                          else { \"\" };\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, use_span, E0382,\n-                    \"{} of {}moved value: `{}`\",\n-                    verb, msg, nl);\n+                else { \"\" };\n+                let mut err = self.cannot_act_on_moved_value(use_span,\n+                                                             verb,\n+                                                             msg,\n+                                                             &format!(\"{}\", nl),\n+                                                             Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n@@ -698,10 +699,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             &self,\n             span: Span,\n             lp: &LoanPath<'tcx>) {\n-        span_err!(\n-            self.tcx.sess, span, E0383,\n-            \"partial reinitialization of uninitialized structure `{}`\",\n-            self.loan_path_to_string(lp));\n+        self.cannot_partially_reinit_an_uninit_struct(span,\n+                                                      &self.loan_path_to_string(lp),\n+                                                      Origin::Ast)\n+            .emit();\n     }\n \n     pub fn report_reassigned_immutable_variable(&self,\n@@ -776,8 +777,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         db\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0595,\n-                                         \"closure cannot assign to {}\", descr)\n+                        self.closure_cannot_assign_to_borrowed(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n                     BorrowViolation(euv::AddrOf) |\n@@ -786,8 +786,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0596,\n-                                         \"cannot borrow {} as mutable\", descr)\n+                        self.cannot_borrow_path_as_mutable(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n@@ -869,21 +868,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n-                    struct_span_err!(self.tcx.sess,\n-                                     error_span,\n-                                     E0626,\n-                                     \"borrow may still be in use when generator yields\")\n-                        .span_label(yield_span, \"possible yield occurs here\")\n+                    self.cannot_borrow_across_generator_yield(error_span, yield_span, Origin::Ast)\n                         .emit();\n                     return;\n                 }\n \n-                let mut db = struct_span_err!(self.tcx.sess,\n-                                              error_span,\n-                                              E0597,\n-                                              \"{} does not live long enough\",\n-                                              msg);\n-\n+                let mut db = self.path_does_not_live_long_enough(error_span, &msg, Origin::Ast);\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n                         (\"temporary value\", \"temporary value created here\"),\n@@ -992,11 +982,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                let mut db = struct_span_err!(self.tcx.sess, error_span, E0598,\n-                                              \"lifetime of {} is too short to guarantee \\\n-                                               its contents can be safely reborrowed\",\n-                                              descr);\n-\n+                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n@@ -1068,12 +1054,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         let blame = cmt.immutability_blame();\n         let mut err = match blame {\n             Some(ImmutabilityBlame::ClosureEnv(id)) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0387,\n-                    \"{} in a captured outer variable in an `Fn` closure\", prefix);\n-\n                 // FIXME: the distinction between these 2 messages looks wrong.\n-                let help = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n+                let help_msg = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n@@ -1084,15 +1066,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n                 let node_id = self.tcx.hir.def_index_to_node_id(id);\n-                err.span_help(self.tcx.hir.span(node_id), help);\n-                err\n+                let help_span = self.tcx.hir.span(node_id);\n+                self.cannot_act_on_capture_in_sharable_fn(span,\n+                                                          prefix,\n+                                                          (help_span, help_msg),\n+                                                          Origin::Ast)\n             }\n             _ =>  {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0389,\n-                    \"{} in a `&` reference\", prefix);\n-                err.span_label(span, \"assignment into an immutable reference\");\n-                err\n+                self.cannot_assign_into_immutable_reference(span, prefix,\n+                                                            Origin::Ast)\n             }\n         };\n         self.note_immutability_blame(&mut err, blame);\n@@ -1244,17 +1226,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 Err(_) => format!(\"move |<args>| <body>\")\n             };\n \n-        struct_span_err!(self.tcx.sess, err.span, E0373,\n-                         \"closure may outlive the current function, \\\n-                          but it borrows {}, \\\n-                          which is owned by the current function\",\n-                         cmt_path_or_string)\n-            .span_label(capture_span,\n-                       format!(\"{} is borrowed here\",\n-                                cmt_path_or_string))\n-            .span_label(err.span,\n-                       format!(\"may outlive borrowed value {}\",\n-                                cmt_path_or_string))\n+        self.cannot_capture_in_long_lived_closure(err.span,\n+                                                  &cmt_path_or_string,\n+                                                  capture_span,\n+                                                  Origin::Ast)\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\"}, {"sha": "3fea01443be4b9d34fa31d68024bdea9ed4037dd", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 469, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=9c5e9a500da3210735160ee24736d2cae09eb4fb", "patch": "@@ -9,472 +9,3 @@\n // except according to those terms.\n \n #![allow(non_snake_case)]\n-\n-register_long_diagnostics! {\n-\n-E0373: r##\"\n-This error occurs when an attempt is made to use data captured by a closure,\n-when that data may no longer exist. It's most commonly seen when attempting to\n-return a closure:\n-\n-```compile_fail,E0373\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(|y| x + y)\n-}\n-```\n-\n-Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n-closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be\n-unsafe.\n-\n-Another situation where this might be encountered is when spawning threads:\n-\n-```compile_fail,E0373\n-fn foo() {\n-    let x = 0u32;\n-    let y = 1u32;\n-\n-    let thr = std::thread::spawn(|| {\n-        x + y\n-    });\n-}\n-```\n-\n-Since our new thread runs in parallel, the stack frame containing `x` and `y`\n-may well have disappeared by the time we try to use them. Even if we call\n-`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n-stack frame won't disappear), we will not succeed: the compiler cannot prove\n-that this behaviour is safe, and so won't let us do it.\n-\n-The solution to this problem is usually to switch to using a `move` closure.\n-This approach moves (or copies, where possible) data into the closure, rather\n-than taking references to it. For example:\n-\n-```\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(move |y| x + y)\n-}\n-```\n-\n-Now that the closure has its own copy of the data, there's no need to worry\n-about safety.\n-\"##,\n-\n-E0382: r##\"\n-This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere. For example:\n-\n-```compile_fail,E0382\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n-of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n-of workarounds like `Rc`, a value cannot be owned by more than one variable.\n-\n-If we own the type, the easiest way to address this problem is to implement\n-`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n-information in `x`, while leaving the original version owned by `x`. Subsequent\n-changes to `x` will not be reflected when accessing `y`.\n-\n-```\n-#[derive(Copy, Clone)]\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Alternatively, if we don't control the struct's definition, or mutable shared\n-ownership is truly required, we can use `Rc` and `RefCell`:\n-\n-```\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n-    let y = x.clone();\n-    x.borrow_mut().s = 6;\n-    println!(\"{}\", x.borrow().s);\n-}\n-```\n-\n-With this approach, x and y share ownership of the data via the `Rc` (reference\n-count type). `RefCell` essentially performs runtime borrow checking: ensuring\n-that at most one writer or multiple readers can access the data at any one time.\n-\n-If you wish to learn more about ownership in Rust, start with the chapter in the\n-Book:\n-\n-https://doc.rust-lang.org/book/first-edition/ownership.html\n-\"##,\n-\n-E0383: r##\"\n-This error occurs when an attempt is made to partially reinitialize a\n-structure that is currently uninitialized.\n-\n-For example, this can happen when a drop has taken place:\n-\n-```compile_fail,E0383\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x); // `x` is now uninitialized\n-x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n-```\n-\n-This error can be fixed by fully reinitializing the structure in question:\n-\n-```\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x);\n-x = Foo { a: 2 };\n-```\n-\"##,\n-\n-/*E0386: r##\"\n-This error occurs when an attempt is made to mutate the target of a mutable\n-reference stored inside an immutable container.\n-\n-For example, this can happen when storing a `&mut` inside an immutable `Box`:\n-\n-```compile_fail,E0386\n-let mut x: i64 = 1;\n-let y: Box<_> = Box::new(&mut x);\n-**y = 2; // error, cannot assign to data in an immutable container\n-```\n-\n-This error can be fixed by making the container mutable:\n-\n-```\n-let mut x: i64 = 1;\n-let mut y: Box<_> = Box::new(&mut x);\n-**y = 2;\n-```\n-\n-It can also be fixed by using a type with interior mutability, such as `Cell`\n-or `RefCell`:\n-\n-```\n-use std::cell::Cell;\n-\n-let x: i64 = 1;\n-let y: Box<Cell<_>> = Box::new(Cell::new(x));\n-y.set(2);\n-```\n-\"##,*/\n-\n-E0387: r##\"\n-This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably. Examples of this error are shown below:\n-\n-```compile_fail,E0387\n-// Accepts a function or a closure that captures its environment immutably.\n-// Closures passed to foo will not be able to mutate their closed-over state.\n-fn foo<F: Fn()>(f: F) { }\n-\n-// Attempts to mutate closed-over data. Error message reads:\n-// `cannot assign to data in a captured outer variable...`\n-fn mutable() {\n-    let mut x = 0u32;\n-    foo(|| x = 2);\n-}\n-\n-// Attempts to take a mutable reference to closed-over data.  Error message\n-// reads: `cannot borrow data mutably in a captured outer variable...`\n-fn mut_addr() {\n-    let mut x = 0u32;\n-    foo(|| { let y = &mut x; });\n-}\n-```\n-\n-The problem here is that foo is defined as accepting a parameter of type `Fn`.\n-Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n-they capture their context immutably.\n-\n-If the definition of `foo` is under your control, the simplest solution is to\n-capture the data mutably. This can be done by defining `foo` to take FnMut\n-rather than Fn:\n-\n-```\n-fn foo<F: FnMut()>(f: F) { }\n-```\n-\n-Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable`\n-function could be redefined as below:\n-\n-```\n-use std::cell::Cell;\n-\n-fn foo<F: Fn()>(f: F) { }\n-\n-fn mutable() {\n-    let x = Cell::new(0u32);\n-    foo(|| x.set(2));\n-}\n-```\n-\n-You can read more about cell types in the API documentation:\n-\n-https://doc.rust-lang.org/std/cell/\n-\"##,\n-\n-E0388: r##\"\n-E0388 was removed and is no longer issued.\n-\"##,\n-\n-E0389: r##\"\n-An attempt was made to mutate data using a non-mutable reference. This\n-commonly occurs when attempting to assign to a non-mutable reference of a\n-mutable reference (`&(&mut T)`).\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0389\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-    let fancy_ref = &(&mut fancy);\n-    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n-immutable reference to a value borrows it immutably. There can be multiple\n-references of type `&(&mut T)` that point to the same value, so they must be\n-immutable to prevent multiple mutable references to the same value.\n-\n-To fix this, either remove the outer reference:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut fancy;\n-    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Or make the outer reference mutable:\n-\n-```\n-struct FancyNum {\n-    num: u8\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut (&mut fancy);\n-    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0595: r##\"\n-Closures cannot mutate immutable captured variables.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0595\n-let x = 3; // error: closure cannot assign to immutable local variable `x`\n-let mut c = || { x += 1 };\n-```\n-\n-Make the variable binding mutable:\n-\n-```\n-let mut x = 3; // ok!\n-let mut c = || { x += 1 };\n-```\n-\"##,\n-\n-E0596: r##\"\n-This error occurs because you tried to mutably borrow a non-mutable variable.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0596\n-let x = 1;\n-let y = &mut x; // error: cannot borrow mutably\n-```\n-\n-In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n-fails. To fix this error, you need to make `x` mutable:\n-\n-```\n-let mut x = 1;\n-let y = &mut x; // ok!\n-```\n-\"##,\n-\n-E0597: r##\"\n-This error occurs because a borrow was made inside a variable which has a\n-greater lifetime than the borrowed one.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0597\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-let y = 0;\n-x.x = Some(&y); // error: `y` does not live long enough\n-```\n-\n-In here, `x` is created before `y` and therefore has a greater lifetime. Always\n-keep in mind that values in a scope are dropped in the opposite order they are\n-created. So to fix the previous example, just make the `y` lifetime greater than\n-the `x`'s one:\n-\n-```\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let y = 0;\n-let mut x = Foo { x: None };\n-x.x = Some(&y);\n-```\n-\"##,\n-\n-E0626: r##\"\n-This error occurs because a borrow in a generator persists across a\n-yield point.\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-    let a = &String::new(); // <-- This borrow...\n-    yield (); // ...is still in scope here, when the yield occurs.\n-    println!(\"{}\", a);\n-};\n-b.resume();\n-```\n-\n-At present, it is not permitted to have a yield that occurs while a\n-borrow is still in scope. To resolve this error, the borrow must\n-either be \"contained\" to a smaller scope that does not overlap the\n-yield or else eliminated in another way. So, for example, we might\n-resolve the previous example by removing the borrow and just storing\n-the integer by value:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-    let a = 3;\n-    yield ();\n-    println!(\"{}\", a);\n-};\n-b.resume();\n-```\n-\n-This is a very simple case, of course. In more complex cases, we may\n-wish to have more than one reference to the value that was borrowed --\n-in those cases, something like the `Rc` or `Arc` types may be useful.\n-\n-This error also frequently arises with iteration:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for &x in &v { // <-- borrow of `v` is still in scope...\n-    yield x; // ...when this yield occurs.\n-  }\n-};\n-b.resume();\n-```\n-\n-Such cases can sometimes be resolved by iterating \"by value\" (or using\n-`into_iter()`) to avoid borrowing:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for x in v { // <-- Take ownership of the values instead!\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-b.resume();\n-```\n-\n-If taking ownership is not an option, using indices can work too:\n-\n-```\n-# #![feature(generators, generator_trait)]\n-# use std::ops::Generator;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  let len = v.len(); // (*)\n-  for i in 0..len {\n-    let x = v[i]; // (*)\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-b.resume();\n-\n-// (*) -- Unfortunately, these temporaries are currently required.\n-// See <https://github.com/rust-lang/rust/issues/43122>.\n-```\n-\"##,\n-\n-}\n-\n-register_diagnostics! {\n-//    E0385, // {} in an aliasable location\n-    E0598, // lifetime of {} is too short to guarantee its contents can be...\n-}"}, {"sha": "11120d2e46f2af6ed09d7a316bfeeec19610908c", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=9c5e9a500da3210735160ee24736d2cae09eb4fb", "patch": "@@ -16,10 +16,9 @@\n #![allow(non_camel_case_types)]\n \n #![feature(quote)]\n-#![feature(rustc_diagnostic_macros)]\n \n #[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n@@ -33,14 +32,8 @@ extern crate rustc_mir;\n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n \n-// NB: This module needs to be declared first so diagnostics are\n-// registered before they are used.\n-mod diagnostics;\n-\n mod borrowck;\n \n pub mod graphviz;\n \n pub use borrowck::provide;\n-\n-__build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "3514302c6c8f3e49ea18c1e6aa700450944b15e1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9c5e9a500da3210735160ee24736d2cae09eb4fb", "patch": "@@ -1259,7 +1259,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     let mut all_errors = Vec::new();\n     all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     #[cfg(feature=\"llvm\")]"}, {"sha": "98c5345c69d35fbc25c6d8d6260bd693e5d422eb", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=9c5e9a500da3210735160ee24736d2cae09eb4fb", "patch": "@@ -229,6 +229,57 @@ fn main() {\n See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n \"##,\n \n+E0373: r##\"\n+This error occurs when an attempt is made to use data captured by a closure,\n+when that data may no longer exist. It's most commonly seen when attempting to\n+return a closure:\n+\n+```compile_fail,E0373\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(|y| x + y)\n+}\n+```\n+\n+Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n+closed-over data by reference. This means that once `foo()` returns, `x` no\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n+\n+Another situation where this might be encountered is when spawning threads:\n+\n+```compile_fail,E0373\n+fn foo() {\n+    let x = 0u32;\n+    let y = 1u32;\n+\n+    let thr = std::thread::spawn(|| {\n+        x + y\n+    });\n+}\n+```\n+\n+Since our new thread runs in parallel, the stack frame containing `x` and `y`\n+may well have disappeared by the time we try to use them. Even if we call\n+`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n+stack frame won't disappear), we will not succeed: the compiler cannot prove\n+that this behaviour is safe, and so won't let us do it.\n+\n+The solution to this problem is usually to switch to using a `move` closure.\n+This approach moves (or copies, where possible) data into the closure, rather\n+than taking references to it. For example:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(move |y| x + y)\n+}\n+```\n+\n+Now that the closure has its own copy of the data, there's no need to worry\n+about safety.\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n \n@@ -250,6 +301,104 @@ fn main() {\n ```\n \"##,\n \n+E0382: r##\"\n+This error occurs when an attempt is made to use a variable after its contents\n+have been moved elsewhere. For example:\n+\n+```compile_fail,E0382\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n+of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n+of workarounds like `Rc`, a value cannot be owned by more than one variable.\n+\n+If we own the type, the easiest way to address this problem is to implement\n+`Copy` and `Clone` on it, as shown below. This allows `y` to copy the\n+information in `x`, while leaving the original version owned by `x`. Subsequent\n+changes to `x` will not be reflected when accessing `y`.\n+\n+```\n+#[derive(Copy, Clone)]\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Alternatively, if we don't control the struct's definition, or mutable shared\n+ownership is truly required, we can use `Rc` and `RefCell`:\n+\n+```\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n+    let y = x.clone();\n+    x.borrow_mut().s = 6;\n+    println!(\"{}\", x.borrow().s);\n+}\n+```\n+\n+With this approach, x and y share ownership of the data via the `Rc` (reference\n+count type). `RefCell` essentially performs runtime borrow checking: ensuring\n+that at most one writer or multiple readers can access the data at any one time.\n+\n+If you wish to learn more about ownership in Rust, start with the chapter in the\n+Book:\n+\n+https://doc.rust-lang.org/book/first-edition/ownership.html\n+\"##,\n+\n+E0383: r##\"\n+This error occurs when an attempt is made to partially reinitialize a\n+structure that is currently uninitialized.\n+\n+For example, this can happen when a drop has taken place:\n+\n+```compile_fail,E0383\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x); // `x` is now uninitialized\n+x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n+```\n+\n+This error can be fixed by fully reinitializing the structure in question:\n+\n+```\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x);\n+x = Foo { a: 2 };\n+```\n+\"##,\n+\n E0384: r##\"\n This error occurs when an attempt is made to reassign an immutable variable.\n For example:\n@@ -272,6 +421,161 @@ fn main() {\n ```\n \"##,\n \n+/*E0386: r##\"\n+This error occurs when an attempt is made to mutate the target of a mutable\n+reference stored inside an immutable container.\n+\n+For example, this can happen when storing a `&mut` inside an immutable `Box`:\n+\n+```compile_fail,E0386\n+let mut x: i64 = 1;\n+let y: Box<_> = Box::new(&mut x);\n+**y = 2; // error, cannot assign to data in an immutable container\n+```\n+\n+This error can be fixed by making the container mutable:\n+\n+```\n+let mut x: i64 = 1;\n+let mut y: Box<_> = Box::new(&mut x);\n+**y = 2;\n+```\n+\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n+\n+```\n+use std::cell::Cell;\n+\n+let x: i64 = 1;\n+let y: Box<Cell<_>> = Box::new(Cell::new(x));\n+y.set(2);\n+```\n+\"##,*/\n+\n+E0387: r##\"\n+This error occurs when an attempt is made to mutate or mutably reference data\n+that a closure has captured immutably. Examples of this error are shown below:\n+\n+```compile_fail,E0387\n+// Accepts a function or a closure that captures its environment immutably.\n+// Closures passed to foo will not be able to mutate their closed-over state.\n+fn foo<F: Fn()>(f: F) { }\n+\n+// Attempts to mutate closed-over data. Error message reads:\n+// `cannot assign to data in a captured outer variable...`\n+fn mutable() {\n+    let mut x = 0u32;\n+    foo(|| x = 2);\n+}\n+\n+// Attempts to take a mutable reference to closed-over data.  Error message\n+// reads: `cannot borrow data mutably in a captured outer variable...`\n+fn mut_addr() {\n+    let mut x = 0u32;\n+    foo(|| { let y = &mut x; });\n+}\n+```\n+\n+The problem here is that foo is defined as accepting a parameter of type `Fn`.\n+Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n+they capture their context immutably.\n+\n+If the definition of `foo` is under your control, the simplest solution is to\n+capture the data mutably. This can be done by defining `foo` to take FnMut\n+rather than Fn:\n+\n+```\n+fn foo<F: FnMut()>(f: F) { }\n+```\n+\n+Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n+\n+```\n+use std::cell::Cell;\n+\n+fn foo<F: Fn()>(f: F) { }\n+\n+fn mutable() {\n+    let x = Cell::new(0u32);\n+    foo(|| x.set(2));\n+}\n+```\n+\n+You can read more about cell types in the API documentation:\n+\n+https://doc.rust-lang.org/std/cell/\n+\"##,\n+\n+E0388: r##\"\n+E0388 was removed and is no longer issued.\n+\"##,\n+\n+E0389: r##\"\n+An attempt was made to mutate data using a non-mutable reference. This\n+commonly occurs when attempting to assign to a non-mutable reference of a\n+mutable reference (`&(&mut T)`).\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0389\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+    let fancy_ref = &(&mut fancy);\n+    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n+immutable reference to a value borrows it immutably. There can be multiple\n+references of type `&(&mut T)` that point to the same value, so they must be\n+immutable to prevent multiple mutable references to the same value.\n+\n+To fix this, either remove the outer reference:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut fancy;\n+    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Or make the outer reference mutable:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut (&mut fancy);\n+    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\"##,\n \n E0394: r##\"\n A static was referred to by value by another static.\n@@ -1265,12 +1569,169 @@ fn main() {\n ```\n \"##,\n \n+E0595: r##\"\n+Closures cannot mutate immutable captured variables.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0595\n+let x = 3; // error: closure cannot assign to immutable local variable `x`\n+let mut c = || { x += 1 };\n+```\n+\n+Make the variable binding mutable:\n+\n+```\n+let mut x = 3; // ok!\n+let mut c = || { x += 1 };\n+```\n+\"##,\n+\n+E0596: r##\"\n+This error occurs because you tried to mutably borrow a non-mutable variable.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0596\n+let x = 1;\n+let y = &mut x; // error: cannot borrow mutably\n+```\n+\n+In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n+fails. To fix this error, you need to make `x` mutable:\n+\n+```\n+let mut x = 1;\n+let y = &mut x; // ok!\n+```\n+\"##,\n+\n+E0597: r##\"\n+This error occurs because a borrow was made inside a variable which has a\n+greater lifetime than the borrowed one.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0597\n+struct Foo<'a> {\n+    x: Option<&'a u32>,\n+}\n+\n+let mut x = Foo { x: None };\n+let y = 0;\n+x.x = Some(&y); // error: `y` does not live long enough\n+```\n+\n+In here, `x` is created before `y` and therefore has a greater lifetime. Always\n+keep in mind that values in a scope are dropped in the opposite order they are\n+created. So to fix the previous example, just make the `y` lifetime greater than\n+the `x`'s one:\n+\n+```\n+struct Foo<'a> {\n+    x: Option<&'a u32>,\n+}\n+\n+let y = 0;\n+let mut x = Foo { x: None };\n+x.x = Some(&y);\n+```\n+\"##,\n+\n+E0626: r##\"\n+This error occurs because a borrow in a generator persists across a\n+yield point.\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = &String::new(); // <-- This borrow...\n+    yield (); // ...is still in scope here, when the yield occurs.\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+At present, it is not permitted to have a yield that occurs while a\n+borrow is still in scope. To resolve this error, the borrow must\n+either be \"contained\" to a smaller scope that does not overlap the\n+yield or else eliminated in another way. So, for example, we might\n+resolve the previous example by removing the borrow and just storing\n+the integer by value:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+    let a = 3;\n+    yield ();\n+    println!(\"{}\", a);\n+};\n+b.resume();\n+```\n+\n+This is a very simple case, of course. In more complex cases, we may\n+wish to have more than one reference to the value that was borrowed --\n+in those cases, something like the `Rc` or `Arc` types may be useful.\n+\n+This error also frequently arises with iteration:\n+\n+```compile_fail,E0626\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for &x in &v { // <-- borrow of `v` is still in scope...\n+    yield x; // ...when this yield occurs.\n+  }\n+};\n+b.resume();\n+```\n+\n+Such cases can sometimes be resolved by iterating \"by value\" (or using\n+`into_iter()`) to avoid borrowing:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  for x in v { // <-- Take ownership of the values instead!\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+```\n+\n+If taking ownership is not an option, using indices can work too:\n+\n+```\n+# #![feature(generators, generator_trait)]\n+# use std::ops::Generator;\n+let mut b = || {\n+  let v = vec![1,2,3];\n+  let len = v.len(); // (*)\n+  for i in 0..len {\n+    let x = v[i]; // (*)\n+    yield x; // <-- Now yield is OK.\n+  }\n+};\n+b.resume();\n+\n+// (*) -- Unfortunately, these temporaries are currently required.\n+// See <https://github.com/rust-lang/rust/issues/43122>.\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n+//    E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n     E0524, // two closures require unique access to `..` at the same time\n     E0526, // shuffle indices are not constant\n     E0594, // cannot assign to {}\n+    E0598, // lifetime of {} is too short to guarantee its contents can be...\n     E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "216f6e4457096d28d6c51590c46840d579a57f36", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5e9a500da3210735160ee24736d2cae09eb4fb/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=9c5e9a500da3210735160ee24736d2cae09eb4fb", "patch": "@@ -294,6 +294,139 @@ pub trait BorrowckErrors {\n         err.span_label(move_from_span, \"cannot move out of here\");\n         err\n     }\n+\n+    fn cannot_act_on_moved_value(&self,\n+                                 use_span: Span,\n+                                 verb: &str,\n+                                 optional_adverb_for_moved: &str,\n+                                 moved_path: &str,\n+                                 o: Origin)\n+                                 -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, use_span, E0382,\n+                                   \"{} of {}moved value: `{}`{OGN}\",\n+                                   verb, optional_adverb_for_moved, moved_path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_partially_reinit_an_uninit_struct(&self,\n+                                                span: Span,\n+                                                uninit_path: &str,\n+                                                o: Origin)\n+                                                -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self,\n+                                   span,\n+                                   E0383,\n+                                   \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+                                   uninit_path, OGN=o);\n+        err\n+    }\n+\n+    fn closure_cannot_assign_to_borrowed(&self,\n+                                         span: Span,\n+                                         descr: &str,\n+                                         o: Origin)\n+                                         -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n+                                   descr, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_borrow_path_as_mutable(&self,\n+                                     span: Span,\n+                                     path: &str,\n+                                     o: Origin)\n+                                     -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_borrow_across_generator_yield(&self,\n+                                            span: Span,\n+                                            yield_span: Span,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self,\n+                                       span,\n+                                       E0626,\n+                                       \"borrow may still be in use when generator yields{OGN}\",\n+                                       OGN=o);\n+        err.span_label(yield_span, \"possible yield occurs here\");\n+        err\n+    }\n+\n+    fn path_does_not_live_long_enough(&self,\n+                                      span: Span,\n+                                      path: &str,\n+                                      o: Origin)\n+                                      -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn lifetime_too_short_for_reborrow(&self,\n+                                       span: Span,\n+                                       path: &str,\n+                                       o: Origin)\n+                                       -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0598,\n+                                   \"lifetime of {} is too short to guarantee \\\n+                                    its contents can be safely reborrowed{OGN}\",\n+                                   path, OGN=o);\n+        err\n+    }\n+\n+    fn cannot_act_on_capture_in_sharable_fn(&self,\n+                                            span: Span,\n+                                            bad_thing: &str,\n+                                            help: (Span, &str),\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let (help_span, help_msg) = help;\n+        let mut err = struct_span_err!(self, span, E0387,\n+                                       \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+                                       bad_thing, OGN=o);\n+        err.span_help(help_span, help_msg);\n+        err\n+    }\n+\n+    fn cannot_assign_into_immutable_reference(&self,\n+                                              span: Span,\n+                                              bad_thing: &str,\n+                                              o: Origin)\n+                                              -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n+                                       bad_thing, OGN=o);\n+        err.span_label(span, \"assignment into an immutable reference\");\n+        err\n+    }\n+\n+    fn cannot_capture_in_long_lived_closure(&self,\n+                                            closure_span: Span,\n+                                            borrowed_path: &str,\n+                                            capture_span: Span,\n+                                            o: Origin)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, closure_span, E0373,\n+                                       \"closure may outlive the current function, \\\n+                                        but it borrows {}, \\\n+                                        which is owned by the current function{OGN}\",\n+                                       borrowed_path, OGN=o);\n+        err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n+            .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n+        err\n+    }\n }\n \n impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {"}]}