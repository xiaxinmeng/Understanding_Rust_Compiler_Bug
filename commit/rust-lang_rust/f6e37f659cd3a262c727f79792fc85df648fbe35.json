{"sha": "f6e37f659cd3a262c727f79792fc85df648fbe35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZTM3ZjY1OWNkM2EyNjJjNzI3Zjc5NzkyZmM4NWRmNjQ4ZmJlMzU=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-07T23:24:35Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-08T01:22:27Z"}, "message": "Made TRACK_ALLOCATIONS add only constant time overhead. This makes it\nfeasible to turn it on and run rustc.", "tree": {"sha": "41c2d9e84638621069473a0493e86fa0d21c4103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41c2d9e84638621069473a0493e86fa0d21c4103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e37f659cd3a262c727f79792fc85df648fbe35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e37f659cd3a262c727f79792fc85df648fbe35", "html_url": "https://github.com/rust-lang/rust/commit/f6e37f659cd3a262c727f79792fc85df648fbe35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e37f659cd3a262c727f79792fc85df648fbe35/comments", "author": null, "committer": null, "parents": [{"sha": "5d9a5b7d556f6573508c83242a0e7b7795d2c2dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d9a5b7d556f6573508c83242a0e7b7795d2c2dd", "html_url": "https://github.com/rust-lang/rust/commit/5d9a5b7d556f6573508c83242a0e7b7795d2c2dd"}], "stats": {"total": 53, "additions": 48, "deletions": 5}, "files": [{"sha": "61ab29bfa1258a16d30550948b2d1f1ec5de433b", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f6e37f659cd3a262c727f79792fc85df648fbe35/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f6e37f659cd3a262c727f79792fc85df648fbe35/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=f6e37f659cd3a262c727f79792fc85df648fbe35", "patch": "@@ -34,11 +34,17 @@ void memory_region::free(void *mem) {\n     if (!mem) { return; }\n     if (_synchronized) { _lock.lock(); }\n #ifdef TRACK_ALLOCATIONS\n-    if (_allocation_list.replace(mem, NULL) == false) {\n+    int index = ((int  *)mem)[-1];\n+    if (_allocation_list[index] != (uint8_t *)mem - sizeof(int)) {\n         printf(\"free: ptr 0x%\" PRIxPTR \" is not in allocation_list\\n\",\n-            (uintptr_t) mem);\n+               (uintptr_t) mem);\n         _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n     }\n+    else {\n+        // printf(\"freed index %d\\n\", index);\n+        _allocation_list[index] = NULL;\n+    }\n+    mem = (void*)((uint8_t*)mem - sizeof(int));\n #endif\n     if (_live_allocations < 1) {\n         _srv->fatal(\"live_allocs < 1\", __FILE__, __LINE__, \"\");\n@@ -54,47 +60,83 @@ memory_region::realloc(void *mem, size_t size) {\n     if (!mem) {\n         add_alloc();\n     }\n+#ifdef TRACK_ALLOCATIONS\n+    size += sizeof(int);\n+    mem = (void*)((uint8_t*)mem - sizeof(int));\n+    int index = *(int  *)mem;\n+#endif\n     void *newMem = _srv->realloc(mem, size);\n #ifdef TRACK_ALLOCATIONS\n-    if (_allocation_list.replace(mem, newMem) == false) {\n+    if (_allocation_list[index] != mem) {\n+        printf(\"at index %d, found %p, expected %p\\n\", \n+               index, _allocation_list[index], mem);\n         printf(\"realloc: ptr 0x%\" PRIxPTR \" is not in allocation_list\\n\",\n             (uintptr_t) mem);\n         _srv->fatal(\"not in allocation_list\", __FILE__, __LINE__, \"\");\n     }\n+    else {\n+        _allocation_list[index] = newMem;\n+        (*(int*)newMem) = index;\n+        // printf(\"realloc: stored %p at index %d, replacing %p\\n\", \n+        //        newMem, index, mem);\n+    }\n #endif\n     if (_synchronized) { _lock.unlock(); }\n+#ifdef TRACK_ALLOCATIONS\n+    newMem = (void *)((uint8_t*)newMem + sizeof(int));\n+#endif\n     return newMem;\n }\n \n void *\n memory_region::malloc(size_t size) {\n     if (_synchronized) { _lock.lock(); }\n     add_alloc();\n+#ifdef TRACK_ALLOCATIONS\n+    size += sizeof(int);\n+#endif\n     void *mem = _srv->malloc(size);\n #ifdef TRACK_ALLOCATIONS\n-    _allocation_list.append(mem);\n+    int index = _allocation_list.append(mem);\n+    int *p = (int *)mem;\n+    *p = index;\n+    // printf(\"malloc: stored %p at index %d\\n\", mem, index);\n #endif\n     // printf(\"malloc: ptr 0x%\" PRIxPTR \" region=%p\\n\", \n     //        (uintptr_t) mem, this);\n     if (_synchronized) { _lock.unlock(); }\n+#ifdef TRACK_ALLOCATIONS\n+    mem = (void*)((uint8_t*)mem + sizeof(int));\n+#endif\n     return mem;\n }\n \n void *\n memory_region::calloc(size_t size) {\n     if (_synchronized) { _lock.lock(); }\n     add_alloc();\n+#ifdef TRACK_ALLOCATIONS\n+    size += sizeof(int);\n+#endif\n     void *mem = _srv->malloc(size);\n     memset(mem, 0, size);\n #ifdef TRACK_ALLOCATIONS\n-    _allocation_list.append(mem);\n+    int index = _allocation_list.append(mem);\n+    int *p = (int *)mem;\n+    *p = index;\n+    // printf(\"calloc: stored %p at index %d\\n\", mem, index);\n #endif\n     if (_synchronized) { _lock.unlock(); }\n+#ifdef TRACK_ALLOCATIONS\n+    mem = (void*)((uint8_t*)mem + sizeof(int));\n+#endif\n     return mem;\n }\n \n memory_region::~memory_region() {\n+    if (_synchronized) { _lock.lock(); }\n     if (_live_allocations == 0) {\n+        if (_synchronized) { _lock.unlock(); }\n         return;\n     }\n     char msg[128];\n@@ -112,6 +154,7 @@ memory_region::~memory_region() {\n     }\n #endif\n     _srv->fatal(msg, __FILE__, __LINE__, \"%d objects\", _live_allocations);\n+    if (_synchronized) { _lock.unlock(); }\n }\n \n //"}]}