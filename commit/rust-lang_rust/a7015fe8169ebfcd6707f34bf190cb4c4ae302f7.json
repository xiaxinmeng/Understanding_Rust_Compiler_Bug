{"sha": "a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "node_id": "C_kwDOAAsO6NoAKGE3MDE1ZmU4MTY5ZWJmY2Q2NzA3ZjM0YmYxOTBjYjRjNGFlMzAyZjc", "commit": {"author": {"name": "Wilco Kusee", "email": "wilcokusee@gmail.com", "date": "2021-01-31T09:32:34Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-28T18:38:22Z"}, "message": "Move things to rustc_type_ir", "tree": {"sha": "e443b532f373659632e8005baccce82eef3f5e91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e443b532f373659632e8005baccce82eef3f5e91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "html_url": "https://github.com/rust-lang/rust/commit/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/comments", "author": {"login": "detrumi", "id": 5758008, "node_id": "MDQ6VXNlcjU3NTgwMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5758008?v=4", "gravatar_id": "", "url": "https://api.github.com/users/detrumi", "html_url": "https://github.com/detrumi", "followers_url": "https://api.github.com/users/detrumi/followers", "following_url": "https://api.github.com/users/detrumi/following{/other_user}", "gists_url": "https://api.github.com/users/detrumi/gists{/gist_id}", "starred_url": "https://api.github.com/users/detrumi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/detrumi/subscriptions", "organizations_url": "https://api.github.com/users/detrumi/orgs", "repos_url": "https://api.github.com/users/detrumi/repos", "events_url": "https://api.github.com/users/detrumi/events{/privacy}", "received_events_url": "https://api.github.com/users/detrumi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f39fb1f34d4bd25d9ce96afe7b2d109f073e286", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f39fb1f34d4bd25d9ce96afe7b2d109f073e286", "html_url": "https://github.com/rust-lang/rust/commit/4f39fb1f34d4bd25d9ce96afe7b2d109f073e286"}], "stats": {"total": 1271, "additions": 1030, "deletions": 241}, "files": [{"sha": "871ff8f9cdb4074f1f18ddb7949d7553eabcc802", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -4262,6 +4262,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"rustc_type_ir\",\n  \"tracing\",\n ]\n \n@@ -4283,6 +4284,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec\",\n  \"tracing\",\n ]\n@@ -4484,6 +4486,7 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"smallvec\",\n ]\n \n [[package]]"}, {"sha": "be34a77bdba966e265ccec946bec6b464ef9ef64", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -8,6 +8,7 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, FloatTy, Ty, TypeAndMut};\n use rustc_target::abi::{Integer, Variants};\n+use rustc_type_ir::sty::TyKind::*;\n \n use super::{\n     util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy,\n@@ -102,7 +103,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: &ImmTy<'tcx, M::PointerTag>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::PointerTag>> {\n-        use rustc_middle::ty::TyKind::*;\n+        use rustc_type_ir::sty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind() {\n@@ -205,7 +206,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let v = scalar.to_bits(src_layout.size)?;\n         let v = if signed { self.sign_extend(v, src_layout) } else { v };\n         trace!(\"cast_from_scalar: {}, {} -> {}\", v, src_layout.ty, cast_ty);\n-        use rustc_middle::ty::TyKind::*;\n \n         Ok(match *cast_ty.kind() {\n             Int(_) | Uint(_) => {\n@@ -247,7 +247,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     where\n         F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>,\n     {\n-        use rustc_middle::ty::TyKind::*;\n+        use rustc_type_ir::sty::TyKind::*;\n         match *dest_ty.kind() {\n             // float -> uint\n             Uint(t) => {"}, {"sha": "6be78c52f99e3d77932696f6d8199c0532e77662", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -2489,7 +2489,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             ty: Ty<'tcx>,\n             init: InitKind,\n         ) -> Option<InitError> {\n-            use rustc_middle::ty::TyKind::*;\n+            use rustc_type_ir::sty::TyKind::*;\n             match ty.kind() {\n                 // Primitive types that don't like 0 as a value.\n                 Ref(..) => Some((\"references must be non-null\".to_string(), None)),\n@@ -2801,7 +2801,7 @@ impl ClashingExternDeclarations {\n                 true\n             } else {\n                 // Do a full, depth-first comparison between the two.\n-                use rustc_middle::ty::TyKind::*;\n+                use rustc_type_ir::sty::TyKind::*;\n                 let a_kind = a.kind();\n                 let b_kind = b.kind();\n "}, {"sha": "653c728ee42935c0d6c522813aef6be9db34b009", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -8,7 +8,7 @@ pub fn type_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n     if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n         s.add_impl_generic(parse_quote! { 'tcx });\n     }\n-    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_middle::ty::codec::TyDecoder<'tcx>});\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_type_ir::codec::TyDecoder<I = ::rustc_middle::ty::TyInterner<'tcx>>});\n     s.add_bounds(synstructure::AddBounds::Generics);\n \n     decodable_body(s, decoder_ty)\n@@ -95,7 +95,7 @@ pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2:\n         s.add_impl_generic(parse_quote! {'tcx});\n     }\n     let encoder_ty = quote! { __E };\n-    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_middle::ty::codec::TyEncoder<'tcx>});\n+    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_type_ir::codec::TyEncoder<I = ::rustc_middle::ty::TyInterner<'tcx>>});\n     s.add_bounds(synstructure::AddBounds::Generics);\n \n     encodable_body(s, encoder_ty, false)"}, {"sha": "926afa8ccb6bb83e1b4bd42ecbd4977b464d68f3", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -115,7 +115,7 @@ use rustc_target::abi::Endian;\n use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Instance, Ty, TyCtxt};\n+use crate::ty::{self, Instance, Ty, TyCtxt, TyInterner};\n \n pub use self::error::{\n     struct_error, CheckInAllocMsg, ErrorHandled, EvalToAllocationRawResult, EvalToConstValueResult,\n@@ -203,7 +203,7 @@ enum AllocDiscriminant {\n     Static,\n }\n \n-pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<'tcx>>(\n+pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<I = TyInterner<'tcx>>>(\n     encoder: &mut E,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -277,7 +277,7 @@ impl<'s> AllocDecodingSession<'s> {\n     /// Decodes an `AllocId` in a thread-safe way.\n     pub fn decode_alloc_id<'tcx, D>(&self, decoder: &mut D) -> AllocId\n     where\n-        D: TyDecoder<'tcx>,\n+        D: TyDecoder<I = TyInterner<'tcx>>,\n     {\n         // Read the index of the allocation.\n         let idx = usize::try_from(decoder.read_u32()).unwrap();\n@@ -305,7 +305,7 @@ impl<'s> AllocDecodingSession<'s> {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n                             // `AllocId` so we can decode cyclic graphs.\n-                            let alloc_id = decoder.tcx().reserve_alloc_id();\n+                            let alloc_id = decoder.interner().tcx.reserve_alloc_id();\n                             *entry =\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n@@ -349,23 +349,23 @@ impl<'s> AllocDecodingSession<'s> {\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n-                    decoder.tcx().set_alloc_id_same_memory(alloc_id, alloc);\n+                    decoder.interner().tcx.set_alloc_id_same_memory(alloc_id, alloc);\n                     alloc_id\n                 }\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder);\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n-                    let alloc_id = decoder.tcx().create_fn_alloc(instance);\n+                    let alloc_id = decoder.interner().tcx.create_fn_alloc(instance);\n                     alloc_id\n                 }\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n                     let did = <DefId as Decodable<D>>::decode(decoder);\n                     trace!(\"decoded static def-ID: {:?}\", did);\n-                    let alloc_id = decoder.tcx().create_static_alloc(did);\n+                    let alloc_id = decoder.interner().tcx.create_static_alloc(did);\n                     alloc_id\n                 }\n             }"}, {"sha": "71cea005cf8583e8b7293602b40ea9fcf13c31d6", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -668,7 +668,7 @@ impl<T> ClearCrossCrate<T> {\n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n+impl<E: TyEncoder, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n     #[inline]\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         if E::CLEAR_CROSS_CRATE {\n@@ -684,7 +684,7 @@ impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate\n         }\n     }\n }\n-impl<'tcx, D: TyDecoder<'tcx>, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n+impl<D: TyDecoder, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n     #[inline]\n     fn decode(d: &mut D) -> ClearCrossCrate<T> {\n         if D::CLEAR_CROSS_CRATE {"}, {"sha": "234649f1056c71e55a38dac6ce018c4bf9d1fe85", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -15,10 +15,12 @@ use crate::mir::{\n use crate::thir;\n use crate::traits;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::{self, AdtDef, Ty};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Encodable};\n+use rustc_middle::ty::TyInterner;\n use rustc_span::Span;\n+pub use rustc_type_ir::{TyDecoder, TyEncoder};\n use std::hash::Hash;\n use std::intrinsics;\n use std::marker::DiscriminantKind;\n@@ -28,13 +30,13 @@ use std::marker::DiscriminantKind;\n /// This offset is also chosen so that the first byte is never < 0x80.\n pub const SHORTHAND_OFFSET: usize = 0x80;\n \n-pub trait EncodableWithShorthand<'tcx, E: TyEncoder<'tcx>>: Copy + Eq + Hash {\n+pub trait EncodableWithShorthand<E: TyEncoder>: Copy + Eq + Hash {\n     type Variant: Encodable<E>;\n     fn variant(&self) -> &Self::Variant;\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> EncodableWithShorthand<E> for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n \n     #[inline]\n@@ -43,7 +45,9 @@ impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::PredicateKind<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> EncodableWithShorthand<E>\n+    for ty::PredicateKind<'tcx>\n+{\n     type Variant = ty::PredicateKind<'tcx>;\n \n     #[inline]\n@@ -52,15 +56,6 @@ impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::Predicate\n     }\n }\n \n-pub trait TyEncoder<'tcx>: Encoder {\n-    const CLEAR_CROSS_CRATE: bool;\n-\n-    fn position(&self) -> usize;\n-    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize>;\n-    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize>;\n-    fn encode_alloc_id(&mut self, alloc_id: &AllocId) -> Result<(), Self::Error>;\n-}\n-\n /// Trait for decoding to a reference.\n ///\n /// This is a separate trait from `Decodable` so that we can implement it for\n@@ -71,7 +66,7 @@ pub trait TyEncoder<'tcx>: Encoder {\n ///\n /// `Decodable` can still be implemented in cases where `Decodable` is required\n /// by a trait bound.\n-pub trait RefDecodable<'tcx, D: TyDecoder<'tcx>> {\n+pub trait RefDecodable<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> {\n     fn decode(d: &mut D) -> &'tcx Self;\n }\n \n@@ -82,9 +77,9 @@ pub fn encode_with_shorthand<'tcx, E, T, M>(\n     cache: M,\n ) -> Result<(), E::Error>\n where\n-    E: TyEncoder<'tcx>,\n+    E: TyEncoder<I = TyInterner<'tcx>>,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n-    T: EncodableWithShorthand<'tcx, E>,\n+    T: EncodableWithShorthand<E>,\n     // The discriminant and shorthand must have the same size.\n     T::Variant: DiscriminantKind<Discriminant = isize>,\n {\n@@ -119,100 +114,105 @@ where\n     Ok(())\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for Ty<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         encode_with_shorthand(e, self, TyEncoder::type_shorthands)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E>\n+    for ty::Binder<'tcx, ty::PredicateKind<'tcx>>\n+{\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.bound_vars().encode(e)?;\n         encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Predicate<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Predicate<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.kind().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Region<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Region<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.kind().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Const<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Const<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.0.0.encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ConstAllocation<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ConstAllocation<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.inner().encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AdtDef<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for AdtDef<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.0.0.encode(e)\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for AllocId {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.encode_alloc_id(self)\n     }\n }\n \n-pub trait TyDecoder<'tcx>: Decoder {\n-    const CLEAR_CROSS_CRATE: bool;\n-\n-    fn tcx(&self) -> TyCtxt<'tcx>;\n-\n-    fn peek_byte(&self) -> u8;\n-\n-    fn position(&self) -> usize;\n-\n-    fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> Ty<'tcx>\n-    where\n-        F: FnOnce(&mut Self) -> Ty<'tcx>;\n-\n-    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n-    where\n-        F: FnOnce(&mut Self) -> R;\n-\n-    fn positioned_at_shorthand(&self) -> bool {\n-        (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n+macro_rules! encodable_via_deref {\n+    ($($t:ty),+) => {\n+        $(impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for $t {\n+            fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                (**self).encode(e)\n+            }\n+        })*\n     }\n+}\n \n-    fn decode_alloc_id(&mut self) -> AllocId;\n+encodable_via_deref! {\n+    &'tcx ty::TypeckResults<'tcx>,\n+    &'tcx traits::ImplSource<'tcx, ()>,\n+    &'tcx mir::Body<'tcx>,\n+    &'tcx mir::UnsafetyCheckResult,\n+    &'tcx mir::BorrowCheckResult<'tcx>,\n+    &'tcx mir::coverage::CodeRegion\n }\n \n #[inline]\n-fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable<\n+    'tcx,\n+    D: TyDecoder<I = TyInterner<'tcx>>,\n+    T: ArenaAllocatable<'tcx> + Decodable<D>,\n+>(\n     decoder: &mut D,\n ) -> &'tcx T\n where\n-    D: TyDecoder<'tcx>,\n+    D: TyDecoder,\n {\n-    decoder.tcx().arena.alloc(Decodable::decode(decoder))\n+    decoder.interner().tcx.arena.alloc(Decodable::decode(decoder))\n }\n \n #[inline]\n-fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable_slice<\n+    'tcx,\n+    D: TyDecoder<I = TyInterner<'tcx>>,\n+    T: ArenaAllocatable<'tcx> + Decodable<D>,\n+>(\n     decoder: &mut D,\n ) -> &'tcx [T]\n where\n-    D: TyDecoder<'tcx>,\n+    D: TyDecoder,\n {\n-    decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n+    decoder.interner().tcx.arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder))\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for Ty<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     fn decode(decoder: &mut D) -> Ty<'tcx> {\n         // Handle shorthands first, if we have a usize > 0x80.\n@@ -225,13 +225,13 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n                 decoder.with_position(shorthand, Ty::decode)\n             })\n         } else {\n-            let tcx = decoder.tcx();\n-            tcx.mk_ty(ty::TyKind::decode(decoder))\n+            let tcx = decoder.interner().tcx;\n+            tcx.mk_ty(rustc_type_ir::TyKind::decode(decoder))\n         }\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n     fn decode(decoder: &mut D) -> ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n         let bound_vars = Decodable::decode(decoder);\n         // Handle shorthands first, if we have a usize > 0x80.\n@@ -250,143 +250,143 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKi\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Predicate<'tcx> {\n     fn decode(decoder: &mut D) -> ty::Predicate<'tcx> {\n         let predicate_kind = Decodable::decode(decoder);\n-        decoder.tcx().mk_predicate(predicate_kind)\n+        decoder.interner().tcx.mk_predicate(predicate_kind)\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for SubstsRef<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for SubstsRef<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let len = decoder.read_usize();\n-        let tcx = decoder.tcx();\n+        let tcx = decoder.interner().tcx;\n         tcx.mk_substs(\n             (0..len).map::<ty::subst::GenericArg<'tcx>, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for mir::Place<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for mir::Place<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let local: mir::Local = Decodable::decode(decoder);\n         let len = decoder.read_usize();\n-        let projection = decoder.tcx().mk_place_elems(\n+        let projection = decoder.interner().tcx.mk_place_elems(\n             (0..len).map::<mir::PlaceElem<'tcx>, _>(|_| Decodable::decode(decoder)),\n         );\n         mir::Place { local, projection }\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Region<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Region<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().mk_region(Decodable::decode(decoder))\n+        decoder.interner().tcx.mk_region(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for CanonicalVarInfos<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for CanonicalVarInfos<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n         let len = decoder.read_usize();\n         let interned: Vec<CanonicalVarInfo<'tcx>> =\n             (0..len).map(|_| Decodable::decode(decoder)).collect();\n-        decoder.tcx().intern_canonical_var_infos(interned.as_slice())\n+        decoder.interner().tcx.intern_canonical_var_infos(interned.as_slice())\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AllocId {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for AllocId {\n     fn decode(decoder: &mut D) -> Self {\n         decoder.decode_alloc_id()\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::SymbolName<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::SymbolName<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        ty::SymbolName::new(decoder.tcx(), &decoder.read_str())\n+        ty::SymbolName::new(decoder.interner().tcx, &decoder.read_str())\n     }\n }\n \n macro_rules! impl_decodable_via_ref {\n     ($($t:ty),+) => {\n-        $(impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for $t {\n+        $(impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for $t {\n             fn decode(decoder: &mut D) -> Self {\n                 RefDecodable::decode(decoder)\n             }\n         })*\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.tcx().mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n+        decoder.interner().tcx.mk_type_list((0..len).map::<Ty<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D>\n     for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.tcx().mk_poly_existential_predicates(\n+        decoder.interner().tcx.mk_poly_existential_predicates(\n             (0..len).map::<ty::Binder<'tcx, _>, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Const<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Const<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().mk_const(Decodable::decode(decoder))\n+        decoder.interner().tcx.mk_const(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [ty::ValTree<'tcx>] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().tcx.arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ConstAllocation<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ConstAllocation<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().intern_const_alloc(Decodable::decode(decoder))\n+        decoder.interner().tcx.intern_const_alloc(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AdtDef<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for AdtDef<'tcx> {\n     fn decode(decoder: &mut D) -> Self {\n-        decoder.tcx().intern_adt_def(Decodable::decode(decoder))\n+        decoder.interner().tcx.intern_adt_def(Decodable::decode(decoder))\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().tcx.arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [thir::abstract_const::Node<'tcx>] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().tcx.arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [thir::abstract_const::NodeId] {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.tcx().arena.alloc_from_iter(\n+        decoder.interner().tcx.arena.alloc_from_iter(\n             (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.tcx().mk_bound_variable_kinds(\n+        decoder.interner().tcx.mk_bound_variable_kinds(\n             (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n@@ -420,14 +420,14 @@ macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n      [$name:ident: $ty:ty]) => {\n-        impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for $ty {\n+        impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for $ty {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable(decoder)\n             }\n         }\n \n-        impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [$ty] {\n+        impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> RefDecodable<'tcx, D> for [$ty] {\n             #[inline]\n             fn decode(decoder: &mut D) -> &'tcx Self {\n                 decode_arena_allocable_slice(decoder)\n@@ -518,13 +518,13 @@ macro_rules! implement_ty_decoder {\n macro_rules! impl_binder_encode_decode {\n     ($($t:ty),+ $(,)?) => {\n         $(\n-            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, $t> {\n+            impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for ty::Binder<'tcx, $t> {\n                 fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n                     self.bound_vars().encode(e)?;\n                     self.as_ref().skip_binder().encode(e)\n                 }\n             }\n-            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, $t> {\n+            impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for ty::Binder<'tcx, $t> {\n                 fn decode(decoder: &mut D) -> Self {\n                     let bound_vars = Decodable::decode(decoder);\n                     ty::Binder::bind_with_vars(Decodable::decode(decoder), bound_vars)"}, {"sha": "58a237ee6f825824fd0ffcf1f368635f726bd92a", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -2,7 +2,7 @@ use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::{LitToConstInput, Scalar};\n use crate::ty::{\n     self, InlineConstSubsts, InlineConstSubstsParts, InternalSubsts, ParamEnv, ParamEnvAnd, Ty,\n-    TyCtxt, TypeFoldable,\n+    TyCtxt, TyInterner, TypeFoldable,\n };\n use rustc_data_structures::intern::Interned;\n use rustc_errors::ErrorGuaranteed;\n@@ -40,6 +40,14 @@ pub struct ConstS<'tcx> {\n     pub val: ConstKind<'tcx>,\n }\n \n+impl<'tcx, S: rustc_type_ir::TyEncoder<I = TyInterner<'tcx>>> rustc_serialize::Encodable<S>\n+    for &'_ Const<'_>\n+{\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        (*self).encode(s)\n+    }\n+}\n+\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstS<'_>, 48);\n "}, {"sha": "efe7a54b5bf1c5fb4a004d0a1523610548a17c2f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 70, "deletions": 105, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -16,7 +16,6 @@ use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n-use crate::ty::TyKind::*;\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig,\n     ClosureSizeProfileData, Const, ConstS, ConstVid, DefIdTree, ExistentialPredicate, FloatTy,\n@@ -60,9 +59,9 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n+use rustc_type_ir::sty::TyKind::*;\n+use rustc_type_ir::{InternAs, InternIteratorElement, Interner, TypeFlags};\n \n-use rustc_type_ir::TypeFlags;\n-use smallvec::SmallVec;\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -91,6 +90,70 @@ pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     fn serialize(&self, tcx: TyCtxt<'tcx>, encoder: &mut FileEncoder) -> FileEncodeResult;\n }\n \n+pub struct TyInterner<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Hash for TyInterner<'tcx> {\n+    fn hash<H: Hasher>(&self, _state: &mut H) {}\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Ord for TyInterner<'tcx> {\n+    fn cmp(&self, _other: &Self) -> Ordering {\n+        Ordering::Equal\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> PartialOrd for TyInterner<'tcx> {\n+    fn partial_cmp(&self, _other: &Self) -> Option<Ordering> {\n+        None\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> PartialEq for TyInterner<'tcx> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        false\n+    }\n+}\n+\n+/// We don't ever actually need this. It's only required for derives.\n+impl<'tcx> Eq for TyInterner<'tcx> {}\n+\n+impl fmt::Debug for TyInterner<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"TyInterner\")\n+    }\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<'tcx> Interner for TyInterner<'tcx> {\n+    type AdtDef = ty::AdtDef<'tcx>;\n+    type SubstsRef = ty::SubstsRef<'tcx>;\n+    type DefId = DefId;\n+    type Ty = Ty<'tcx>;\n+    type Const = ty::Const<'tcx>;\n+    type Region = Region<'tcx>;\n+    type TypeAndMut = TypeAndMut<'tcx>;\n+    type Mutability = hir::Mutability;\n+    type Movability = hir::Movability;\n+    type PolyFnSig = PolyFnSig<'tcx>;\n+    type ListBinderExistentialPredicate = &'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>;\n+    type BinderListTy = Binder<'tcx, &'tcx List<Ty<'tcx>>>;\n+    type ListTy = &'tcx List<Ty<'tcx>>;\n+    type ProjectionTy = ty::ProjectionTy<'tcx>;\n+    type ParamTy = ParamTy;\n+    type BoundTy = ty::BoundTy;\n+    type PlaceholderType = ty::PlaceholderType;\n+    type InferTy = InferTy;\n+    type DelaySpanBugEmitted = DelaySpanBugEmitted;\n+    type PredicateKind = ty::PredicateKind<'tcx>;\n+    type AllocId = crate::mir::interpret::AllocId;\n+}\n+\n /// A type that is not publicly constructable. This prevents people from making [`TyKind::Error`]s\n /// except through the error-reporting functions on a [`tcx`][TyCtxt].\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -1075,6 +1138,10 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n+    pub fn interner(self) -> TyInterner<'tcx> {\n+        TyInterner { tcx: self }\n+    }\n+\n     /// Expects a body and returns its codegen attributes.\n     ///\n     /// Unlike `codegen_fn_attrs`, this returns `CodegenFnAttrs::EMPTY` for\n@@ -2848,108 +2915,6 @@ impl<'tcx> TyCtxtAt<'tcx> {\n     }\n }\n \n-pub trait InternAs<T: ?Sized, R> {\n-    type Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n-    where\n-        F: FnOnce(&T) -> R;\n-}\n-\n-impl<I, T, R, E> InternAs<[T], R> for I\n-where\n-    E: InternIteratorElement<T, R>,\n-    I: Iterator<Item = E>,\n-{\n-    type Output = E::Output;\n-    fn intern_with<F>(self, f: F) -> Self::Output\n-    where\n-        F: FnOnce(&[T]) -> R,\n-    {\n-        E::intern_with(self, f)\n-    }\n-}\n-\n-pub trait InternIteratorElement<T, R>: Sized {\n-    type Output;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n-}\n-\n-impl<T, R> InternIteratorElement<T, R> for T {\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n-        // This code is hot enough that it's worth specializing for the most\n-        // common length lists, to avoid the overhead of `SmallVec` creation.\n-        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n-        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n-        // `assert`.\n-        match iter.size_hint() {\n-            (0, Some(0)) => {\n-                assert!(iter.next().is_none());\n-                f(&[])\n-            }\n-            (1, Some(1)) => {\n-                let t0 = iter.next().unwrap();\n-                assert!(iter.next().is_none());\n-                f(&[t0])\n-            }\n-            (2, Some(2)) => {\n-                let t0 = iter.next().unwrap();\n-                let t1 = iter.next().unwrap();\n-                assert!(iter.next().is_none());\n-                f(&[t0, t1])\n-            }\n-            _ => f(&iter.collect::<SmallVec<[_; 8]>>()),\n-        }\n-    }\n-}\n-\n-impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n-where\n-    T: Clone + 'a,\n-{\n-    type Output = R;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        // This code isn't hot.\n-        f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n-    }\n-}\n-\n-impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n-    type Output = Result<R, E>;\n-    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n-        mut iter: I,\n-        f: F,\n-    ) -> Self::Output {\n-        // This code is hot enough that it's worth specializing for the most\n-        // common length lists, to avoid the overhead of `SmallVec` creation.\n-        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n-        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n-        // `assert`, unless a failure happens first, in which case the result\n-        // will be an error anyway.\n-        Ok(match iter.size_hint() {\n-            (0, Some(0)) => {\n-                assert!(iter.next().is_none());\n-                f(&[])\n-            }\n-            (1, Some(1)) => {\n-                let t0 = iter.next().unwrap()?;\n-                assert!(iter.next().is_none());\n-                f(&[t0])\n-            }\n-            (2, Some(2)) => {\n-                let t0 = iter.next().unwrap()?;\n-                let t1 = iter.next().unwrap()?;\n-                assert!(iter.next().is_none());\n-                f(&[t0, t1])\n-            }\n-            _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),\n-        })\n-    }\n-}\n-\n // We are comparing types with different invariant lifetimes, so `ptr::eq`\n // won't work for us.\n fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {"}, {"sha": "462fc27009de9ce1b9c462519ab6308c1d0c8b33", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -1,7 +1,6 @@\n //! Diagnostics related methods for `Ty`.\n \n use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::TyKind::*;\n use crate::ty::{\n     ConstKind, DefIdTree, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef,\n     InferTy, ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n@@ -13,6 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::WherePredicate;\n use rustc_span::Span;\n+use rustc_type_ir::sty::TyKind::*;\n \n impl<'tcx> IntoDiagnosticArg for Ty<'tcx> {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {"}, {"sha": "3d22f5a04a2bf1879c22dbd232c8904d95663f93", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -2,11 +2,12 @@ pub use self::def_id_forest::DefIdForest;\n \n use crate::ty;\n use crate::ty::context::TyCtxt;\n-use crate::ty::TyKind::*;\n use crate::ty::{AdtDef, FieldDef, Ty, VariantDef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::{DefId, SubstsRef};\n \n+use rustc_type_ir::sty::TyKind::*;\n+\n mod def_id_forest;\n \n // The methods in this module calculate `DefIdForest`s of modules in which an"}, {"sha": "2804912c9ab8a111c58a0d805a0948116fa9e311", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -51,6 +51,7 @@ use std::{fmt, str};\n \n pub use crate::ty::diagnostics::*;\n pub use rustc_type_ir::InferTy::*;\n+pub use rustc_type_ir::TyKind::*;\n pub use rustc_type_ir::*;\n \n pub use self::binding::BindingMode;\n@@ -67,7 +68,7 @@ pub use self::consts::{\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n-    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n+    GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TyInterner, TypeckResults, UserType,\n     UserTypeAnnotationIndex,\n };\n pub use self::instance::{Instance, InstanceDef};\n@@ -76,7 +77,6 @@ pub use self::parameterized::ParameterizedOverTcx;\n pub use self::rvalue_scopes::RvalueScopes;\n pub use self::sty::BoundRegionKind::*;\n pub use self::sty::RegionKind::*;\n-pub use self::sty::TyKind::*;\n pub use self::sty::{\n     Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, BoundVariableKind,\n     CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBinder, EarlyBoundRegion,\n@@ -449,13 +449,13 @@ pub(crate) struct TyS<'tcx> {\n }\n \n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(TyS<'_>, 40);\n+//#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+//static_assert_size!(TyS<'_>, 40);\n \n // We are actually storing a stable hash cache next to the type, so let's\n // also check the full size\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(WithStableHash<TyS<'_>>, 56);\n+//#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+//static_assert_size!(WithStableHash<TyS<'_>>, 56);\n \n /// Use this rather than `TyS`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]"}, {"sha": "314d0ef277136b0d2e54b79e3be3ecb557d0e97b", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -2,16 +2,14 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n-use self::TyKind::*;\n-\n use crate::infer::canonical::Canonical;\n use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::InferTy::{self, *};\n+use crate::ty::InferTy::*;\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Term, Ty, TyCtxt, TypeFlags, TypeFoldable, TypeVisitor,\n };\n-use crate::ty::{DelaySpanBugEmitted, List, ParamEnv};\n+use crate::ty::{List, ParamEnv};\n use polonius_engine::Atom;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::Interned;\n@@ -29,6 +27,10 @@ use std::marker::PhantomData;\n use std::ops::{ControlFlow, Deref, Range};\n use ty::util::IntTypeExt;\n \n+use rustc_type_ir::TyKind as IrTyKind;\n+pub type TyKind<'tcx> = IrTyKind<ty::TyInterner<'tcx>>;\n+use rustc_type_ir::sty::TyKind::*;\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct TypeAndMut<'tcx> {\n@@ -78,6 +80,7 @@ impl BoundRegionKind {\n     }\n }\n \n+/*\n /// Defines the kinds of types used by the type system.\n ///\n /// Types written by the user start out as [hir::TyKind](rustc_hir::TyKind) and get\n@@ -253,7 +256,9 @@ pub enum TyKind<'tcx> {\n     /// propagated to avoid useless error messages.\n     Error(DelaySpanBugEmitted),\n }\n+*/\n \n+/*\n impl<'tcx> TyKind<'tcx> {\n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n@@ -272,6 +277,25 @@ impl<'tcx> TyKind<'tcx> {\n         }\n     }\n }\n+*/\n+\n+pub trait Article {\n+    fn article(&self) -> &'static str;\n+}\n+\n+impl<'tcx> Article for TyKind<'tcx> {\n+    /// Get the article (\"a\" or \"an\") to use with this type.\n+    fn article(&self) -> &'static str {\n+        match self {\n+            Int(_) | Float(_) | Array(_, _) => \"an\",\n+            Adt(def, _) if def.is_enum() => \"an\",\n+            // This should never happen, but ICEing and causing the user's code\n+            // to not compile felt too harsh.\n+            Error(_) => \"a\",\n+            _ => \"a\",\n+        }\n+    }\n+}\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -930,7 +954,9 @@ impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n     }\n \n     #[inline]\n-    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n+    pub fn auto_traits<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = DefId> + rustc_data_structures::captures::Captures<'tcx> + 'a {\n         self.iter().filter_map(|predicate| match predicate.skip_binder() {\n             ExistentialPredicate::AutoTrait(did) => Some(did),\n             _ => None,"}, {"sha": "e50179face0adbc5eea66ed55b419663004f7120", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -4,7 +4,7 @@ use crate::mir;\n use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n-use crate::ty::{self, EarlyBinder, Lift, List, ParamConst, Ty, TyCtxt};\n+use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt, TyInterner};\n \n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_hir::def_id::DefId;\n@@ -216,13 +216,13 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for GenericArg<'tcx> {\n+impl<'tcx, E: TyEncoder<I = TyInterner<'tcx>>> Encodable<E> for GenericArg<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.unpack().encode(e)\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for GenericArg<'tcx> {\n+impl<'tcx, D: TyDecoder<I = TyInterner<'tcx>>> Decodable<D> for GenericArg<'tcx> {\n     fn decode(d: &mut D) -> GenericArg<'tcx> {\n         GenericArgKind::decode(d).pack()\n     }\n@@ -506,7 +506,7 @@ pub trait Subst<'tcx>: Sized {\n     fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self::Inner;\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for EarlyBinder<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> Subst<'tcx> for ty::EarlyBinder<T> {\n     type Inner = T;\n \n     fn subst(self, tcx: TyCtxt<'tcx>, substs: &[GenericArg<'tcx>]) -> Self::Inner {"}, {"sha": "084c47a1dc4baaa671794a064f79252b45d7a417", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -5,7 +5,9 @@ use crate::ty::fold::{FallibleTypeFolder, TypeFolder};\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{\n+    self, Const, DebruijnIndex, DefIdTree, List, ReEarlyBound, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_apfloat::Float as _;\n use rustc_ast as ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n@@ -20,6 +22,7 @@ use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi;\n+use rustc_type_ir::TyKind::*;\n use smallvec::SmallVec;\n use std::{fmt, iter};\n "}, {"sha": "bfc15f0c70b3e500931cfc5f8af42ba80bcede72", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -20,6 +20,7 @@ rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n tracing = \"0.1\"\n \n [features]"}, {"sha": "5282c317fc4bc3519e36dbf7c9759ecdb4c3b3e1", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -547,12 +547,13 @@ where\n     value\n }\n \n-impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder for CacheDecoder<'a, 'tcx> {\n+    type I = TyInterner<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     #[inline]\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+    fn interner(&self) -> TyInterner<'tcx> {\n+        TyInterner { tcx: self.tcx }\n     }\n \n     #[inline]\n@@ -569,7 +570,7 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Self) -> Ty<'tcx>,\n     {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         let cache_key = ty::CReaderCacheKey { cnum: None, pos: shorthand };\n \n@@ -750,7 +751,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n         // If we get to this point, then all of the query inputs were green,\n         // which means that the definition with this hash is guaranteed to\n         // still exist in the current compilation session.\n-        d.tcx().def_path_hash_to_def_id(def_path_hash, &mut || {\n+        d.tcx.def_path_hash_to_def_id(def_path_hash, &mut || {\n             panic!(\"Failed to convert DefPathHash {:?}\", def_path_hash)\n         })\n     }\n@@ -927,10 +928,11 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> TyEncoder<'tcx> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> TyEncoder for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + OpaqueEncoder,\n {\n+    type I = TyInterner<'tcx>;\n     const CLEAR_CROSS_CRATE: bool = false;\n \n     fn position(&self) -> usize {"}, {"sha": "0a80f014ae7927cfa07359cf5f484efd0d52be60", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -21,6 +21,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n parking_lot = \"0.11\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n "}, {"sha": "ddaac1c78a129f5002d165275ba48e2d48253869", "filename": "compiler/rustc_query_system/src/ich/mod.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fmod.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -1,6 +1,7 @@\n //! ICH - Incremental Compilation Hash\n \n pub use self::hcx::StableHashingContext;\n+use rustc_data_structures::stable_hasher::HashStable;\n use rustc_span::symbol::{sym, Symbol};\n \n mod hcx;\n@@ -17,3 +18,124 @@ pub const IGNORED_ATTRIBUTES: &[Symbol] = &[\n     sym::rustc_partition_codegened,\n     sym::rustc_expected_cgu_reuse,\n ];\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<'__ctx, I: rustc_type_ir::Interner> HashStable<StableHashingContext<'__ctx>>\n+    for rustc_type_ir::TyKind<I>\n+where\n+    I::AdtDef: HashStable<StableHashingContext<'__ctx>>,\n+    I::DefId: HashStable<StableHashingContext<'__ctx>>,\n+    I::SubstsRef: HashStable<StableHashingContext<'__ctx>>,\n+    I::Ty: HashStable<StableHashingContext<'__ctx>>,\n+    I::Const: HashStable<StableHashingContext<'__ctx>>,\n+    I::TypeAndMut: HashStable<StableHashingContext<'__ctx>>,\n+    I::PolyFnSig: HashStable<StableHashingContext<'__ctx>>,\n+    I::ListBinderExistentialPredicate: HashStable<StableHashingContext<'__ctx>>,\n+    I::Region: HashStable<StableHashingContext<'__ctx>>,\n+    I::Movability: HashStable<StableHashingContext<'__ctx>>,\n+    I::Mutability: HashStable<StableHashingContext<'__ctx>>,\n+    I::BinderListTy: HashStable<StableHashingContext<'__ctx>>,\n+    I::ListTy: HashStable<StableHashingContext<'__ctx>>,\n+    I::ProjectionTy: HashStable<StableHashingContext<'__ctx>>,\n+    I::BoundTy: HashStable<StableHashingContext<'__ctx>>,\n+    I::ParamTy: HashStable<StableHashingContext<'__ctx>>,\n+    I::PlaceholderType: HashStable<StableHashingContext<'__ctx>>,\n+    I::InferTy: HashStable<StableHashingContext<'__ctx>>,\n+    I::DelaySpanBugEmitted: HashStable<StableHashingContext<'__ctx>>,\n+{\n+    #[inline]\n+    fn hash_stable(\n+        &self,\n+        __hcx: &mut crate::ich::StableHashingContext<'__ctx>,\n+        __hasher: &mut rustc_data_structures::stable_hasher::StableHasher,\n+    ) {\n+        std::mem::discriminant(self).hash_stable(__hcx, __hasher);\n+        use rustc_type_ir::TyKind::*;\n+        match self {\n+            Bool => {}\n+            Char => {}\n+            Int(i) => {\n+                i.hash_stable(__hcx, __hasher);\n+            }\n+            Uint(u) => {\n+                u.hash_stable(__hcx, __hasher);\n+            }\n+            Float(f) => {\n+                f.hash_stable(__hcx, __hasher);\n+            }\n+            Adt(adt, substs) => {\n+                adt.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Foreign(def_id) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+            }\n+            Str => {}\n+            Array(t, c) => {\n+                t.hash_stable(__hcx, __hasher);\n+                c.hash_stable(__hcx, __hasher);\n+            }\n+            Slice(t) => {\n+                t.hash_stable(__hcx, __hasher);\n+            }\n+            RawPtr(tam) => {\n+                tam.hash_stable(__hcx, __hasher);\n+            }\n+            Ref(r, t, m) => {\n+                r.hash_stable(__hcx, __hasher);\n+                t.hash_stable(__hcx, __hasher);\n+                m.hash_stable(__hcx, __hasher);\n+            }\n+            FnDef(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            FnPtr(polyfnsig) => {\n+                polyfnsig.hash_stable(__hcx, __hasher);\n+            }\n+            Dynamic(l, r) => {\n+                l.hash_stable(__hcx, __hasher);\n+                r.hash_stable(__hcx, __hasher);\n+            }\n+            Closure(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Generator(def_id, substs, m) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+                m.hash_stable(__hcx, __hasher);\n+            }\n+            GeneratorWitness(b) => {\n+                b.hash_stable(__hcx, __hasher);\n+            }\n+            Never => {}\n+            Tuple(substs) => {\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Projection(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Opaque(def_id, substs) => {\n+                def_id.hash_stable(__hcx, __hasher);\n+                substs.hash_stable(__hcx, __hasher);\n+            }\n+            Param(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Bound(d, b) => {\n+                d.hash_stable(__hcx, __hasher);\n+                b.hash_stable(__hcx, __hasher);\n+            }\n+            Placeholder(p) => {\n+                p.hash_stable(__hcx, __hasher);\n+            }\n+            Infer(i) => {\n+                i.hash_stable(__hcx, __hasher);\n+            }\n+            Error(d) => {\n+                d.hash_stable(__hcx, __hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "8d04b8816ffbe59dce69ab985fe1bea9872cd744", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -13,7 +13,7 @@ fn sized_constraint_for_ty<'tcx>(\n     adtdef: ty::AdtDef<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Vec<Ty<'tcx>> {\n-    use ty::TyKind::*;\n+    use rustc_type_ir::sty::TyKind::*;\n \n     let result = match ty.kind() {\n         Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)"}, {"sha": "b8066f2e5d89186f73191fb623400c1ec3593065", "filename": "compiler/rustc_type_ir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2FCargo.toml?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -12,3 +12,4 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "e0138f8aad92f7b62a6ed63c863c0aad8796f3a8", "filename": "compiler/rustc_type_ir/src/codec.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fcodec.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -0,0 +1,63 @@\n+use crate::Interner;\n+\n+use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_serialize::{Decoder, Encoder};\n+\n+/// The shorthand encoding uses an enum's variant index `usize`\n+/// and is offset by this value so it never matches a real variant.\n+/// This offset is also chosen so that the first byte is never < 0x80.\n+pub const SHORTHAND_OFFSET: usize = 0x80;\n+\n+/// Trait for decoding to a reference.\n+///\n+/// This is a separate trait from `Decodable` so that we can implement it for\n+/// upstream types, such as `FxHashSet`.\n+///\n+/// The `TyDecodable` derive macro will use this trait for fields that are\n+/// references (and don't use a type alias to hide that).\n+///\n+/// `Decodable` can still be implemented in cases where `Decodable` is required\n+/// by a trait bound.\n+pub trait RefDecodable<'tcx, D: TyDecoder> {\n+    fn decode(d: &mut D) -> &'tcx Self;\n+}\n+\n+pub trait TyEncoder: Encoder {\n+    type I: Interner;\n+    const CLEAR_CROSS_CRATE: bool;\n+\n+    fn position(&self) -> usize;\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<<Self::I as Interner>::Ty, usize>;\n+    fn predicate_shorthands(\n+        &mut self,\n+    ) -> &mut FxHashMap<<Self::I as Interner>::PredicateKind, usize>;\n+    fn encode_alloc_id(\n+        &mut self,\n+        alloc_id: &<Self::I as Interner>::AllocId,\n+    ) -> Result<(), Self::Error>;\n+}\n+\n+pub trait TyDecoder: Decoder {\n+    type I: Interner;\n+    const CLEAR_CROSS_CRATE: bool;\n+\n+    fn interner(&self) -> Self::I;\n+\n+    fn peek_byte(&self) -> u8;\n+\n+    fn position(&self) -> usize;\n+\n+    fn cached_ty_for_shorthand<F>(&mut self, shorthand: usize, or_insert_with: F) -> <Self::I as Interner>::Ty\n+    where\n+        F: FnOnce(&mut Self) -> <Self::I as Interner>::Ty;\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+    where\n+        F: FnOnce(&mut Self) -> R;\n+\n+    fn positioned_at_shorthand(&self) -> bool {\n+        (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n+    }\n+\n+    fn decode_alloc_id(&mut self) -> <Self::I as Interner>::AllocId;\n+}\n\\ No newline at end of file"}, {"sha": "960e42d8006ac77dbafd5ea04e1b81d5c07967ec", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -1,4 +1,5 @@\n #![feature(min_specialization)]\n+#![feature(rustc_attrs)]\n \n #[macro_use]\n extern crate bitflags;\n@@ -7,9 +8,147 @@ extern crate rustc_macros;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::unify::{EqUnifyValue, UnifyKey};\n+//use rustc_serialize::{Decodable, Encodable};\n+use smallvec::SmallVec;\n use std::fmt;\n+use std::fmt::Debug;\n+use std::hash::Hash;\n use std::mem::discriminant;\n \n+pub mod codec;\n+pub mod sty;\n+\n+pub use codec::*;\n+pub use sty::*;\n+\n+extern crate self as rustc_type_ir;\n+\n+pub trait Interner {\n+    type AdtDef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type SubstsRef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type DefId: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Ty: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Const: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Region: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type TypeAndMut: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Mutability: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type Movability: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PolyFnSig: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ListBinderExistentialPredicate: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type BinderListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ListTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ProjectionTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type ParamTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type BoundTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PlaceholderType: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type InferTy: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type DelaySpanBugEmitted: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+    type PredicateKind: Clone + Debug + Hash + PartialEq + Eq;\n+    type AllocId: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n+}\n+\n+pub trait InternAs<T: ?Sized, R> {\n+    type Output;\n+    fn intern_with<F>(self, f: F) -> Self::Output\n+    where\n+        F: FnOnce(&T) -> R;\n+}\n+\n+impl<I, T, R, E> InternAs<[T], R> for I\n+where\n+    E: InternIteratorElement<T, R>,\n+    I: Iterator<Item = E>,\n+{\n+    type Output = E::Output;\n+    fn intern_with<F>(self, f: F) -> Self::Output\n+    where\n+        F: FnOnce(&[T]) -> R,\n+    {\n+        E::intern_with(self, f)\n+    }\n+}\n+\n+pub trait InternIteratorElement<T, R>: Sized {\n+    type Output;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output;\n+}\n+\n+impl<T, R> InternIteratorElement<T, R> for T {\n+    type Output = R;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n+        mut iter: I,\n+        f: F,\n+    ) -> Self::Output {\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n+        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n+        // `assert`.\n+        match iter.size_hint() {\n+            (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n+                f(&[])\n+            }\n+            (1, Some(1)) => {\n+                let t0 = iter.next().unwrap();\n+                assert!(iter.next().is_none());\n+                f(&[t0])\n+            }\n+            (2, Some(2)) => {\n+                let t0 = iter.next().unwrap();\n+                let t1 = iter.next().unwrap();\n+                assert!(iter.next().is_none());\n+                f(&[t0, t1])\n+            }\n+            _ => f(&iter.collect::<SmallVec<[_; 8]>>()),\n+        }\n+    }\n+}\n+\n+impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n+where\n+    T: Clone + 'a,\n+{\n+    type Output = R;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n+        // This code isn't hot.\n+        f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n+    }\n+}\n+\n+impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n+    type Output = Result<R, E>;\n+    fn intern_with<I: Iterator<Item = Self>, F: FnOnce(&[T]) -> R>(\n+        mut iter: I,\n+        f: F,\n+    ) -> Self::Output {\n+        // This code is hot enough that it's worth specializing for the most\n+        // common length lists, to avoid the overhead of `SmallVec` creation.\n+        // Lengths 0, 1, and 2 typically account for ~95% of cases. If\n+        // `size_hint` is incorrect a panic will occur via an `unwrap` or an\n+        // `assert`, unless a failure happens first, in which case the result\n+        // will be an error anyway.\n+        Ok(match iter.size_hint() {\n+            (0, Some(0)) => {\n+                assert!(iter.next().is_none());\n+                f(&[])\n+            }\n+            (1, Some(1)) => {\n+                let t0 = iter.next().unwrap()?;\n+                assert!(iter.next().is_none());\n+                f(&[t0])\n+            }\n+            (2, Some(2)) => {\n+                let t0 = iter.next().unwrap()?;\n+                let t1 = iter.next().unwrap()?;\n+                assert!(iter.next().is_none());\n+                f(&[t0, t1])\n+            }\n+            _ => f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?),\n+        })\n+    }\n+}\n+\n bitflags! {\n     /// Flags that we track on types. These flags are propagated upwards\n     /// through the type during type construction, so that we can quickly check"}, {"sha": "8f43904d96a314a1a0a69d7b3bf2320bdce99381", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -0,0 +1,454 @@\n+use crate::DebruijnIndex;\n+use crate::FloatTy;\n+use crate::IntTy;\n+use crate::Interner;\n+use crate::TyDecoder;\n+use crate::TyEncoder;\n+use crate::UintTy;\n+\n+use rustc_serialize::{Decodable, Encodable};\n+\n+/// Defines the kinds of types used by the type system.\n+///\n+/// Types written by the user start out as [hir::TyKind](rustc_hir::TyKind) and get\n+/// converted to this representation using `AstConv::ast_ty_to_ty`.\n+#[allow(rustc::usage_of_ty_tykind)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+//#[derive(TyEncodable, TyDecodable)]\n+//#[derive(HashStable)]\n+#[rustc_diagnostic_item = \"TyKind\"]\n+pub enum TyKind<I: Interner> {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point). Written as `char`.\n+    Char,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    Int(IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    Uint(UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(FloatTy),\n+\n+    /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n+    ///\n+    /// For example, the type `List<i32>` would be represented using the `AdtDef`\n+    /// for `struct List<T>` and the substs `[i32]`.\n+    ///\n+    /// Note that generic parameters in fields only get lazily substituted\n+    /// by using something like `adt_def.all_fields().map(|field| field.ty(tcx, substs))`.\n+    Adt(I::AdtDef, I::SubstsRef),\n+\n+    /// An unsized FFI type that is opaque to Rust. Written as `extern type T`.\n+    Foreign(I::DefId),\n+\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    /// An array with the given length. Written as `[T; N]`.\n+    Array(I::Ty, I::Const),\n+\n+    /// The pointee of an array slice. Written as `[T]`.\n+    Slice(I::Ty),\n+\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(I::TypeAndMut),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(I::Region, I::Ty, I::Mutability),\n+\n+    /// The anonymous type of a function declaration/definition. Each\n+    /// function has a unique type.\n+    ///\n+    /// For the function `fn foo() -> i32 { 3 }` this type would be\n+    /// shown to the user as `fn() -> i32 {foo}`.\n+    ///\n+    /// For example the type of `bar` here:\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar = foo; // bar: fn() -> i32 {foo}\n+    /// ```\n+    FnDef(I::DefId, I::SubstsRef),\n+\n+    /// A pointer to a function. Written as `fn() -> i32`.\n+    ///\n+    /// Note that both functions and closures start out as either\n+    /// [FnDef] or [Closure] which can be then be coerced to this variant.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    FnPtr(I::PolyFnSig),\n+\n+    /// A trait object. Written as `dyn for<'b> Trait<'b, Assoc = u32> + Send + 'a`.\n+    Dynamic(I::ListBinderExistentialPredicate, I::Region),\n+\n+    /// The anonymous type of a closure. Used to represent the type of `|a| a`.\n+    ///\n+    /// Closure substs contain both the - potentially substituted - generic parameters\n+    /// of its parent and some synthetic parameters. See the documentation for\n+    /// [ClosureSubsts] for more details.\n+    Closure(I::DefId, I::SubstsRef),\n+\n+    /// The anonymous type of a generator. Used to represent the type of\n+    /// `|a| yield a`.\n+    ///\n+    /// For more info about generator substs, visit the documentation for\n+    /// [GeneratorSubsts].\n+    Generator(I::DefId, I::SubstsRef, I::Movability),\n+\n+    /// A type representing the types stored inside a generator.\n+    /// This should only appear as part of the [GeneratorSubsts].\n+    ///\n+    /// Note that the captured variables for generators are stored separately\n+    /// using a tuple in the same way as for closures.\n+    ///\n+    /// Unlike upvars, the witness can reference lifetimes from\n+    /// inside of the generator itself. To deal with them in\n+    /// the type of the generator, we convert them to higher ranked\n+    /// lifetimes bound by the witness itself.\n+    ///\n+    /// Looking at the following example, the witness for this generator\n+    /// may end up as something like `for<'a> [Vec<i32>, &'a Vec<i32>]`:\n+    ///\n+    /// ```ignore UNSOLVED (ask @compiler-errors, should this error? can we just swap the yields?)\n+    /// #![feature(generators)]\n+    /// |a| {\n+    ///     let x = &vec![3];\n+    ///     yield a;\n+    ///     yield x[0];\n+    /// }\n+    /// # ;\n+    /// ```\n+    GeneratorWitness(I::BinderListTy),\n+\n+    /// The never type `!`.\n+    Never,\n+\n+    /// A tuple type. For example, `(i32, bool)`.\n+    Tuple(I::ListTy),\n+\n+    /// The projection of an associated type. For example,\n+    /// `<T as Trait<..>>::N`.\n+    Projection(I::ProjectionTy),\n+\n+    /// Opaque (`impl Trait`) type found in a return type.\n+    ///\n+    /// The `DefId` comes either from\n+    /// * the `impl Trait` ast::Ty node,\n+    /// * or the `type Foo = impl Trait` declaration\n+    ///\n+    /// For RPIT the substitutions are for the generics of the function,\n+    /// while for TAIT it is used for the generic parameters of the alias.\n+    ///\n+    /// During codegen, `tcx.type_of(def_id)` can be used to get the underlying type.\n+    Opaque(I::DefId, I::SubstsRef),\n+\n+    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}`.\n+    Param(I::ParamTy),\n+\n+    /// Bound type variable, used to represent the `'a` in `for<'a> fn(&'a ())`.\n+    ///\n+    /// For canonical queries, we replace inference variables with bound variables,\n+    /// so e.g. when checking whether `&'_ (): Trait<_>` holds, we canonicalize that to\n+    /// `for<'a, T> &'a (): Trait<T>` and then convert the introduced bound variables\n+    /// back to inference variables in a new inference context when inside of the query.\n+    ///\n+    /// See the `rustc-dev-guide` for more details about\n+    /// [higher-ranked trait bounds][1] and [canonical queries][2].\n+    ///\n+    /// [1]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n+    /// [2]: https://rustc-dev-guide.rust-lang.org/traits/canonical-queries.html\n+    Bound(DebruijnIndex, I::BoundTy),\n+\n+    /// A placeholder type, used during higher ranked subtyping to instantiate\n+    /// bound variables.\n+    Placeholder(I::PlaceholderType),\n+\n+    /// A type variable used during type checking.\n+    ///\n+    /// Similar to placeholders, inference variables also live in a universe to\n+    /// correctly deal with higher ranked types. Though unlike placeholders,\n+    /// that universe is stored in the `InferCtxt` instead of directly\n+    /// inside of the type.\n+    Infer(I::InferTy),\n+\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    Error(I::DelaySpanBugEmitted),\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<I: Interner> TyKind<I> {\n+    #[inline]\n+    pub fn is_primitive(&self) -> bool {\n+        use crate::TyKind::*;\n+        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n+    }\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<__I: Interner, __E: TyEncoder> Encodable<__E> for TyKind<__I>\n+where\n+    __I::DelaySpanBugEmitted: Encodable<__E>,\n+    __I::AdtDef: Encodable<__E>,\n+    __I::SubstsRef: Encodable<__E>,\n+    __I::DefId: Encodable<__E>,\n+    __I::Ty: Encodable<__E>,\n+    __I::Const: Encodable<__E>,\n+    __I::Region: Encodable<__E>,\n+    __I::TypeAndMut: Encodable<__E>,\n+    __I::Mutability: Encodable<__E>,\n+    __I::Movability: Encodable<__E>,\n+    __I::PolyFnSig: Encodable<__E>,\n+    __I::ListBinderExistentialPredicate: Encodable<__E>,\n+    __I::BinderListTy: Encodable<__E>,\n+    __I::ListTy: Encodable<__E>,\n+    __I::ProjectionTy: Encodable<__E>,\n+    __I::ParamTy: Encodable<__E>,\n+    __I::BoundTy: Encodable<__E>,\n+    __I::PlaceholderType: Encodable<__E>,\n+    __I::InferTy: Encodable<__E>,\n+    __I::DelaySpanBugEmitted: Encodable<__E>,\n+    __I::PredicateKind: Encodable<__E>,\n+    __I::AllocId: Encodable<__E>,\n+{\n+    fn encode(&self, e: &mut __E) -> Result<(), <__E as rustc_serialize::Encoder>::Error> {\n+        rustc_serialize::Encoder::emit_enum(e, |e| {\n+            use rustc_type_ir::TyKind::*;\n+            match self {\n+                Bool => e.emit_enum_variant(\"Bool\", 0, 0, |_| Ok(())),\n+                Char => e.emit_enum_variant(\"Char\", 1, 0, |_| Ok(())),\n+                Int(i) => e.emit_enum_variant(\"Int\", 2, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n+                    Ok(())\n+                }),\n+                Uint(u) => e.emit_enum_variant(\"Uint\", 3, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| u.encode(e))?;\n+                    Ok(())\n+                }),\n+                Float(f) => e.emit_enum_variant(\"Float\", 4, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| f.encode(e))?;\n+                    Ok(())\n+                }),\n+                Adt(adt, substs) => e.emit_enum_variant(\"Adt\", 5, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| adt.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Foreign(def_id) => e.emit_enum_variant(\"Foreign\", 6, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    Ok(())\n+                }),\n+                Str => e.emit_enum_variant(\"Str\", 7, 0, |_| Ok(())),\n+                Array(t, c) => e.emit_enum_variant(\"Array\", 8, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| c.encode(e))?;\n+                    Ok(())\n+                }),\n+                Slice(t) => e.emit_enum_variant(\"Slice\", 9, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n+                    Ok(())\n+                }),\n+                RawPtr(tam) => e.emit_enum_variant(\"RawPtr\", 10, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| tam.encode(e))?;\n+                    Ok(())\n+                }),\n+                Ref(r, t, m) => e.emit_enum_variant(\"Ref\", 11, 3, |e| {\n+                    e.emit_enum_variant_arg(true, |e| r.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| t.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n+                    Ok(())\n+                }),\n+                FnDef(def_id, substs) => e.emit_enum_variant(\"FnDef\", 12, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                FnPtr(polyfnsig) => e.emit_enum_variant(\"FnPtr\", 13, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| polyfnsig.encode(e))?;\n+                    Ok(())\n+                }),\n+                Dynamic(l, r) => e.emit_enum_variant(\"Dynamic\", 14, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| l.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| r.encode(e))?;\n+                    Ok(())\n+                }),\n+                Closure(def_id, substs) => e.emit_enum_variant(\"Closure\", 15, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Generator(def_id, substs, m) => e.emit_enum_variant(\"Generator\", 16, 3, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n+                    Ok(())\n+                }),\n+                GeneratorWitness(b) => e.emit_enum_variant(\"GeneratorWitness\", 17, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| b.encode(e))?;\n+                    Ok(())\n+                }),\n+                Never => e.emit_enum_variant(\"Never\", 18, 0, |_| Ok(())),\n+                Tuple(substs) => e.emit_enum_variant(\"Tuple\", 19, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Projection(p) => e.emit_enum_variant(\"Projection\", 20, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                    Ok(())\n+                }),\n+                Opaque(def_id, substs) => e.emit_enum_variant(\"Opaque\", 21, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n+                    Ok(())\n+                }),\n+                Param(p) => e.emit_enum_variant(\"Param\", 22, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                    Ok(())\n+                }),\n+                Bound(d, b) => e.emit_enum_variant(\"Bound\", 23, 2, |e| {\n+                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n+                    e.emit_enum_variant_arg(false, |e| b.encode(e))?;\n+                    Ok(())\n+                }),\n+                Placeholder(p) => e.emit_enum_variant(\"Placeholder\", 24, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n+                    Ok(())\n+                }),\n+                Infer(i) => e.emit_enum_variant(\"Infer\", 25, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n+                    Ok(())\n+                }),\n+                Error(d) => e.emit_enum_variant(\"Error\", 26, 1, |e| {\n+                    e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n+                    Ok(())\n+                }),\n+            }\n+        })\n+    }\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+impl<__I: Interner, __D: TyDecoder<I = __I>> Decodable<__D> for TyKind<__I>\n+where\n+    __I::DelaySpanBugEmitted: Decodable<__D>,\n+    __I::AdtDef: Decodable<__D>,\n+    __I::SubstsRef: Decodable<__D>,\n+    __I::DefId: Decodable<__D>,\n+    __I::Ty: Decodable<__D>,\n+    __I::Const: Decodable<__D>,\n+    __I::Region: Decodable<__D>,\n+    __I::TypeAndMut: Decodable<__D>,\n+    __I::Mutability: Decodable<__D>,\n+    __I::Movability: Decodable<__D>,\n+    __I::PolyFnSig: Decodable<__D>,\n+    __I::ListBinderExistentialPredicate: Decodable<__D>,\n+    __I::BinderListTy: Decodable<__D>,\n+    __I::ListTy: Decodable<__D>,\n+    __I::ProjectionTy: Decodable<__D>,\n+    __I::ParamTy: Decodable<__D>,\n+    __I::BoundTy: Decodable<__D>,\n+    __I::PlaceholderType: Decodable<__D>,\n+    __I::InferTy: Decodable<__D>,\n+    __I::DelaySpanBugEmitted: Decodable<__D>,\n+    __I::PredicateKind: Decodable<__D>,\n+    __I::AllocId: Decodable<__D>,\n+{\n+    fn decode(__decoder: &mut __D) -> Self {\n+        use TyKind::*;\n+\n+        match rustc_serialize::Decoder::read_usize(__decoder) {\n+            0 => Bool,\n+            1 => Char,\n+            2 => Int(rustc_serialize::Decodable::decode(__decoder)),\n+            3 => Uint(rustc_serialize::Decodable::decode(__decoder)),\n+            4 => Float(rustc_serialize::Decodable::decode(__decoder)),\n+            5 => Adt(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            6 => Foreign(rustc_serialize::Decodable::decode(__decoder)),\n+            7 => Str,\n+            8 => Array(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            9 => Slice(rustc_serialize::Decodable::decode(__decoder)),\n+            10 => RawPtr(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            11 => Ref(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            12 => FnDef(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            13 => FnPtr(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            14 => Dynamic(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            15 => Closure(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            16 => Generator(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            17 => GeneratorWitness(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            18 => Never,\n+            19 => Tuple(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            20 => Projection(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            21 => Opaque(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            22 => Param(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            23 => Bound(\n+                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            24 => Placeholder(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            25 => Infer(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            26 => Error(\n+                rustc_serialize::Decodable::decode(__decoder),\n+            ),\n+            _ => \n+                panic!(\n+                    \"{}\",\n+                    format!(\n+                        \"invalid enum variant tag while decoding `{}`, expected 0..{}\",\n+                        \"TyKind\", 27,\n+                    )\n+                ),\n+        }\n+    }\n+}"}, {"sha": "d08d9938708c914cfab09270c0519c4ef99f970a", "filename": "compiler/rustc_typeck/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7015fe8169ebfcd6707f34bf190cb4c4ae302f7/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=a7015fe8169ebfcd6707f34bf190cb4c4ae302f7", "patch": "@@ -177,7 +177,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n     tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_hir_id);\n \n-        use ty::TyKind::*;\n+        use rustc_type_ir::sty::TyKind::*;\n         match (source.kind(), target.kind()) {\n             (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n                 if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}"}]}