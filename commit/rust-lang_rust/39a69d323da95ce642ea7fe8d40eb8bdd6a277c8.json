{"sha": "39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YTY5ZDMyM2RhOTVjZTY0MmVhN2ZlOGQ0MGViOGJkZDZhMjc3Yzg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-22T10:51:57Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-09T11:22:42Z"}, "message": "std::rand: Add OSRng, ReaderRng wrappers around the OS RNG & generic Readers respectively.\n\nThe former reads from e.g. /dev/urandom, the latter just wraps any\nstd::rt::io::Reader into an interface that implements Rng.\n\nThis also adds Rng.fill_bytes for efficient implementations of the above\n(reading 8 bytes at a time is inefficient when you can read 1000), and\nremoves the dependence on src/rt (i.e. rand_gen_seed) although this last\none requires implementing hand-seeding of the XorShiftRng used in the\nscheduler on Linux/unixes, since OSRng relies on a scheduler existing to\nbe able to read from /dev/urandom.", "tree": {"sha": "00c17e0dc840f82fe747dfd1265282209e0005f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00c17e0dc840f82fe747dfd1265282209e0005f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "html_url": "https://github.com/rust-lang/rust/commit/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "html_url": "https://github.com/rust-lang/rust/commit/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a"}], "stats": {"total": 465, "additions": 435, "deletions": 30}, "files": [{"sha": "e6bf42a5aedcd2dda39316eb0ab68a557ca7b40a", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 93, "deletions": 29, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "patch": "@@ -44,24 +44,24 @@ fn main () {\n */\n \n use cast;\n-use cmp;\n use container::Container;\n use int;\n-use iter::{Iterator, range, range_step};\n+use iter::{Iterator, range};\n use local_data;\n use prelude::*;\n use str;\n-use sys;\n use u32;\n use u64;\n use uint;\n use vec;\n-use libc::size_t;\n \n pub use self::isaac::{IsaacRng, Isaac64Rng};\n+pub use self::os::OSRng;\n \n pub mod distributions;\n pub mod isaac;\n+pub mod os;\n+pub mod reader;\n \n /// A type that can be randomly generated using an Rng\n pub trait Rand {\n@@ -233,15 +233,6 @@ impl<T: Rand + 'static> Rand for @T {\n     fn rand<R: Rng>(rng: &mut R) -> @T { @rng.gen() }\n }\n \n-#[abi = \"cdecl\"]\n-pub mod rustrt {\n-    use libc::size_t;\n-\n-    extern {\n-        pub fn rand_gen_seed(buf: *mut u8, sz: size_t);\n-    }\n-}\n-\n /// A value with a particular weight compared to other values\n pub struct Weighted<T> {\n     /// The numerical weight of this item\n@@ -252,7 +243,8 @@ pub struct Weighted<T> {\n \n /// A random number generator\n pub trait Rng {\n-    /// Return the next random u32.\n+    /// Return the next random u32. This rarely needs to be called\n+    /// directly, prefer `r.gen()` to `r.next_u32()`.\n     ///\n     /// By default this is implemented in terms of `next_u64`. An\n     /// implementation of this trait must provide at least one of\n@@ -261,7 +253,8 @@ pub trait Rng {\n         self.next_u64() as u32\n     }\n \n-    /// Return the next random u64.\n+    /// Return the next random u64. This rarely needs to be called\n+    /// directly, prefer `r.gen()` to `r.next_u64()`.\n     ///\n     /// By default this is implemented in terms of `next_u32`. An\n     /// implementation of this trait must provide at least one of\n@@ -270,6 +263,76 @@ pub trait Rng {\n         (self.next_u32() as u64 << 32) | (self.next_u32() as u64)\n     }\n \n+    /// Fill `dest` with random data.\n+    ///\n+    /// This has a default implementation in terms of `next_u64` and\n+    /// `next_u32`, but should be overriden by implementations that\n+    /// offer a more efficient solution than just calling those\n+    /// methods repeatedly.\n+    ///\n+    /// This method does *not* have a requirement to bear any fixed\n+    /// relationship to the other methods, for example, it does *not*\n+    /// have to result in the same output as progressively filling\n+    /// `dest` with `self.gen::<u8>()`, and any such behaviour should\n+    /// not be relied upon.\n+    ///\n+    /// This method should guarantee that `dest` is entirely filled\n+    /// with new data, and may fail if this is impossible\n+    /// (e.g. reading past the end of a file that is being used as the\n+    /// source of randomness).\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~{.rust}\n+    /// use std::rand::{task_rng, Rng};\n+    ///\n+    /// fn main() {\n+    ///    let mut v = [0u8, .. 13579];\n+    ///    task_rng().fill_bytes(v);\n+    ///    printfln!(v);\n+    /// }\n+    /// ~~~\n+    fn fill_bytes(&mut self, mut dest: &mut [u8]) {\n+        // this relies on the lengths being transferred correctly when\n+        // transmuting between vectors like this.\n+        let as_u64: &mut &mut [u64] = unsafe { cast::transmute(&mut dest) };\n+        for dest in as_u64.mut_iter() {\n+            *dest = self.next_u64();\n+        }\n+\n+        // the above will have filled up the vector as much as\n+        // possible in multiples of 8 bytes.\n+        let mut remaining = dest.len() % 8;\n+\n+        // space for a u32\n+        if remaining >= 4 {\n+            let as_u32: &mut &mut [u32] = unsafe { cast::transmute(&mut dest) };\n+            as_u32[as_u32.len() - 1] = self.next_u32();\n+            remaining -= 4;\n+        }\n+        // exactly filled\n+        if remaining == 0 { return }\n+\n+        // now we know we've either got 1, 2 or 3 spots to go,\n+        // i.e. exactly one u32 is enough.\n+        let rand = self.next_u32();\n+        let remaining_index = dest.len() - remaining;\n+        match dest.mut_slice_from(remaining_index) {\n+            [ref mut a] => {\n+                *a = rand as u8;\n+            }\n+            [ref mut a, ref mut b] => {\n+                *a = rand as u8;\n+                *b = (rand >> 8) as u8;\n+            }\n+            [ref mut a, ref mut b, ref mut c] => {\n+                *a = rand as u8;\n+                *b = (rand >> 8) as u8;\n+                *c = (rand >> 16) as u8;\n+            }\n+            _ => fail2!(\"Rng.fill_bytes: the impossible occurred: remaining != 1, 2 or 3\")\n+        }\n+    }\n \n     /// Return a random value of a Rand type.\n     ///\n@@ -630,11 +693,9 @@ impl XorShiftRng {\n         // specific size, so we can just use a fixed buffer.\n         let mut s = [0u8, ..16];\n         loop {\n-            do s.as_mut_buf |p, sz| {\n-                unsafe {\n-                    rustrt::rand_gen_seed(p, sz as size_t);\n-                }\n-            }\n+            let mut r = OSRng::new();\n+            r.fill_bytes(s);\n+\n             if !s.iter().all(|x| *x == 0) {\n                 break;\n             }\n@@ -660,15 +721,10 @@ impl XorShiftRng {\n \n /// Create a new random seed of length `n`.\n pub fn seed(n: uint) -> ~[u8] {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    unsafe {\n-        let mut s = vec::from_elem(n as uint, 0_u8);\n-        do s.as_mut_buf |p, sz| {\n-            rustrt::rand_gen_seed(p, sz as size_t)\n-        }\n-        s\n-    }\n+    let mut s = vec::from_elem(n as uint, 0_u8);\n+    let mut r = OSRng::new();\n+    r.fill_bytes(s);\n+    s\n }\n \n // used to make space in TLS for a random number generator\n@@ -719,6 +775,14 @@ mod test {\n     use option::{Option, Some};\n     use super::*;\n \n+    #[test]\n+    fn test_fill_bytes_default() {\n+        let mut r = weak_rng();\n+\n+        let mut v = [0u8, .. 100];\n+        r.fill_bytes(v);\n+    }\n+\n     #[test]\n     fn test_gen_integer_range() {\n         let mut r = rng();"}, {"sha": "0e6472b4d37fdadf81bfff842c8c5ac6869f0748", "filename": "src/libstd/rand/os.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "patch": "@@ -0,0 +1,193 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Interfaces to the operating system provided random number\n+//! generators.\n+\n+use rand::Rng;\n+use ops::Drop;\n+\n+#[cfg(unix)]\n+use rand::reader::ReaderRng;\n+#[cfg(unix)]\n+use rt::io::{file, Open, Read};\n+\n+#[cfg(windows)]\n+use ptr;\n+#[cfg(windows)]\n+use cast;\n+#[cfg(windows)]\n+use libc::{GetLastError, FALSE};\n+\n+/// A random number generator that retrieves randomness straight from\n+/// the operating system. On Unix-like systems this reads from\n+/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+///\n+/// This does not block.\n+#[cfg(unix)]\n+pub struct OSRng {\n+    priv inner: ReaderRng<file::FileStream>\n+}\n+/// A random number generator that retrieves randomness straight from\n+/// the operating system. On Unix-like systems this reads from\n+/// `/dev/urandom`, on Windows this uses `CryptGenRandom`.\n+///\n+/// This does not block.\n+///\n+/// XXX: it is unlikely that this is threadsafe with the use of\n+/// GetLastError.\n+#[cfg(windows)]\n+pub struct OSRng {\n+    priv hcryptprov: raw::HCRYPTPROV\n+}\n+\n+impl OSRng {\n+    /// Create a new `OSRng`.\n+    #[cfg(unix)]\n+    pub fn new() -> OSRng {\n+        let reader = file::open(& &\"/dev/urandom\", Open, Read).expect(\"Error opening /dev/urandom\");\n+        let reader_rng = ReaderRng::new(reader);\n+\n+        OSRng { inner: reader_rng }\n+    }\n+\n+    /// Create a new `OSRng`.\n+    #[cfg(windows)]\n+    pub fn new() -> OSRng {\n+        let hcp = ptr::mut_null();\n+        // TODO these two 0 constants are incorrect!\n+        if unsafe { raw::CryptAcquireContext(hcp, ptr::null(), ptr::null(), 0, 0); } == FALSE {\n+            fail!(\"CryptAcquireContext failed with error %u\", unsafe {GetLastError()})\n+        }\n+\n+        OSRng { hcryptprov: hcp }\n+    }\n+}\n+\n+#[cfg(unix)]\n+impl Rng for OSRng {\n+    fn next_u32(&mut self) -> u32 {\n+        self.inner.next_u32()\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        self.inner.next_u64()\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        self.inner.fill_bytes(v)\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl Rng for OSRng {\n+    fn next_u32(&mut self) -> u32 {\n+        let mut v = [0u8, .. 4];\n+        self.fill_bytes(v);\n+        unsafe { cast::transmute(v) }\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        let mut v = [0u8, .. 8];\n+        self.fill_bytes(v);\n+        unsafe { cast::transmute(v) }\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        if unsafe { raw::CryptGenRandom(self.hcryptprov, v.len(), v.unsafe_mut_ref(0)) } == FALSE {\n+            fail!(\"CryptGenRandom failed with error %u\", unsafe {GetLastError()})\n+        }\n+    }\n+}\n+\n+impl Drop for OSRng {\n+    #[cfg(unix)]\n+    fn drop(&mut self) {\n+        // ensure that OSRng is not implicitly copyable on all\n+        // platforms, for consistency.\n+    }\n+\n+    #[cfg(windows)]\n+    fn drop(&mut self) {\n+        // TODO this 0 means?\n+        if unsafe { raw::CryptReleaseContext(self.hcryptprov, 0)} == FALSE {\n+            fail!(\"CryptReleaseContext failed with error %u\", unsafe {GetLastError()})\n+        }\n+    }\n+}\n+\n+#[abi = \"cdecl\"]\n+#[cfg(windows)]\n+mod raw {\n+    use libc::{LPCTSTR, DWORD, BOOL, BYTE};\n+\n+    enum HCRYPTPROV_opaque {}\n+    pub type HCRYPTPROV = *CRYPTPROV;\n+    extern {\n+        pub fn CryptAcquireContext(phProv: *mut HCRYPTPROV,\n+                                   pszContainer: LPCTSTR, pszProvider: LPCTSTR,\n+                                   dwProvType: DWORD, dwFlags: DWORD) -> BOOL;\n+        pub fn CryptGenRandom(hProv: HCRYPTPROV, dwLen: DWORD, pbBuffer: *mut BYTE) -> BOOL;\n+        pub fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rand::Rng;\n+\n+    #[test]\n+    fn test_os_rng() {\n+        let mut r = OSRng::new();\n+\n+        r.next_u32();\n+        r.next_u64();\n+\n+        let mut v = [0u8, .. 1000];\n+        r.fill_bytes(v);\n+    }\n+\n+    #[test]\n+    fn test_os_rng_tasks() {\n+        use task;\n+        use comm;\n+        use comm::{GenericChan, GenericPort};\n+        use option::{None, Some};\n+        use iter::{Iterator, range};\n+        use vec::{ImmutableVector, OwnedVector};\n+\n+        let mut chans = ~[];\n+        for _ in range(0, 20) {\n+            let (p, c) = comm::stream();\n+            chans.push(c);\n+            do task::spawn_with(p) |p| {\n+                // wait until all the tasks are ready to go.\n+                p.recv();\n+\n+                // deschedule to attempt to interleave things as much\n+                // as possible (XXX: is this a good test?)\n+                let mut r = OSRng::new();\n+                task::deschedule();\n+                let mut v = [0u8, .. 1000];\n+\n+                for _ in range(0, 100) {\n+                    r.next_u32();\n+                    task::deschedule();\n+                    r.next_u64();\n+                    task::deschedule();\n+                    r.fill_bytes(v);\n+                    task::deschedule();\n+                }\n+            }\n+        }\n+\n+        // start all the tasks\n+        for c in chans.iter() {\n+            c.send(())\n+        }\n+    }\n+}"}, {"sha": "f1164346fe6066d9dc711a2d62838844978353b4", "filename": "src/libstd/rand/reader.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rt::io::Reader;\n+use rt::io::ReaderByteConversions;\n+\n+use rand::Rng;\n+\n+/// An RNG that reads random bytes straight from a `Reader`. This will\n+/// work best with an infinite reader, but this is not required. The\n+/// semantics of reading past the end of the reader are the same as\n+/// those of the `read` method of the inner `Reader`.\n+pub struct ReaderRng<R> {\n+    priv reader: R\n+}\n+\n+impl<R: Reader> ReaderRng<R> {\n+    /// Create a new `ReaderRng` from a `Reader`.\n+    pub fn new(r: R) -> ReaderRng<R> {\n+        ReaderRng {\n+            reader: r\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Rng for ReaderRng<R> {\n+    fn next_u32(&mut self) -> u32 {\n+        // XXX which is better: consistency between big/little-endian\n+        // platforms, or speed.\n+        if cfg!(target_endian=\"little\") {\n+            self.reader.read_le_u32_()\n+        } else {\n+            self.reader.read_be_u32_()\n+        }\n+    }\n+    fn next_u64(&mut self) -> u64 {\n+        if cfg!(target_endian=\"little\") {\n+            self.reader.read_le_u64_()\n+        } else {\n+            self.reader.read_be_u64_()\n+        }\n+    }\n+    fn fill_bytes(&mut self, v: &mut [u8]) {\n+        // XXX: check that we filled `v``\n+        let _n = self.reader.read(v);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rt::io::mem::MemReader;\n+    use cast;\n+\n+    #[test]\n+    fn test_reader_rng_u64() {\n+        // transmute from the target to avoid endianness concerns.\n+        let v = ~[1u64, 2u64, 3u64];\n+        let bytes: ~[u8] = unsafe {cast::transmute(v)};\n+        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+\n+        assert_eq!(rng.next_u64(), 1);\n+        assert_eq!(rng.next_u64(), 2);\n+        assert_eq!(rng.next_u64(), 3);\n+    }\n+    #[test]\n+    fn test_reader_rng_u32() {\n+        // transmute from the target to avoid endianness concerns.\n+        let v = ~[1u32, 2u32, 3u32];\n+        let bytes: ~[u8] = unsafe {cast::transmute(v)};\n+        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+\n+        assert_eq!(rng.next_u32(), 1);\n+        assert_eq!(rng.next_u32(), 2);\n+        assert_eq!(rng.next_u32(), 3);\n+    }\n+    #[test]\n+    fn test_reader_rng_fill_bytes() {\n+        let v = [1u8, 2, 3, 4, 5, 6, 7, 8];\n+        let mut w = [0u8, .. 8];\n+\n+        let mut rng = ReaderRng::new(MemReader::new(v.to_owned()));\n+        rng.fill_bytes(w);\n+\n+        assert_eq!(v, w);\n+    }\n+}"}, {"sha": "004dab8d73a2356834971be747cc97445c3dded3", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39a69d323da95ce642ea7fe8d40eb8bdd6a277c8/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=39a69d323da95ce642ea7fe8d40eb8bdd6a277c8", "patch": "@@ -140,7 +140,7 @@ impl Scheduler {\n             cleanup_job: None,\n             run_anything: run_anything,\n             friend_handle: friend,\n-            rng: XorShiftRng::new(),\n+            rng: new_sched_rng(),\n             idle_callback: None,\n             yield_check_count: 0,\n             steal_for_yield: false\n@@ -844,6 +844,60 @@ impl ClosureConverter for UnsafeTaskReceiver {\n     fn to_fn(self) -> &fn(&mut Scheduler, ~Task) { unsafe { transmute(self) } }\n }\n \n+// On unix, we read randomness straight from /dev/urandom, but the\n+// default constructor of an XorShiftRng does this via io::file, which\n+// relies on the scheduler existing, so we have to manually load\n+// randomness. Windows has its own C API for this, so we don't need to\n+// worry there.\n+#[cfg(windows)]\n+fn new_sched_rng() -> XorShiftRng {\n+    XorShiftRng::new()\n+}\n+#[cfg(unix)]\n+#[fixed_stack_segment] #[inline(never)]\n+fn new_sched_rng() -> XorShiftRng {\n+    use libc;\n+    use sys;\n+    use c_str::ToCStr;\n+    use ptr::RawPtr;\n+    use vec::MutableVector;\n+    use iter::Iterator;\n+\n+    // XXX: this could use io::native::file, when it works.\n+    let file = do \"/dev/urandom\".with_c_str |name| {\n+        do \"r\".with_c_str |mode| {\n+            unsafe { libc::fopen(name, mode) }\n+        }\n+    };\n+    if file.is_null() {\n+        rtabort!(\"could not open /dev/urandom for reading.\")\n+    }\n+\n+    let mut seeds = [0u32, .. 4];\n+    loop {\n+        let nbytes = do seeds.as_mut_buf |buf, len| {\n+            unsafe {\n+                libc::fread(buf as *mut libc::c_void,\n+                            sys::size_of::<u32>() as libc::size_t,\n+                            len as libc::size_t,\n+                            file)\n+            }\n+        };\n+        rtassert!(nbytes == seeds.len() as libc::size_t);\n+\n+        if !seeds.iter().all(|x| *x == 0) {\n+            break;\n+        }\n+    }\n+\n+    // XXX: do we need to guarantee that this is closed with a finally\n+    // block (is that even possible without a scheduler?), or do we\n+    // know that the only way that we can fail here is `abort`ing?\n+    unsafe {libc::fclose(file);}\n+\n+    XorShiftRng::new_seeded(seeds[0], seeds[1], seeds[2], seeds[3])\n+}\n+\n #[cfg(test)]\n mod test {\n     extern mod extra;"}]}