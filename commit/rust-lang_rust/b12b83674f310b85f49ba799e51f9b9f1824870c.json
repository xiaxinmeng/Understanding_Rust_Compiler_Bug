{"sha": "b12b83674f310b85f49ba799e51f9b9f1824870c", "node_id": "C_kwDOAAsO6NoAKGIxMmI4MzY3NGYzMTBiODVmNDliYTc5OWU1MWY5YjlmMTgyNDg3MGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-10T11:16:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-10T11:16:18Z"}, "message": "Auto merge of #105525 - matthiaskrgr:rollup-ricyw5s, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #98391 (Reimplement std's thread parker on top of events on SGX)\n - #104019 (Compute generator sizes with `-Zprint_type_sizes`)\n - #104512 (Set `download-ci-llvm = \"if-available\"` by default when `channel = dev`)\n - #104901 (Implement masking in FileType comparison on Unix)\n - #105082 (Fix Async Generator ABI)\n - #105109 (Add LLVM KCFI support to the Rust compiler)\n - #105505 (Don't warn about unused parens when they are used by yeet expr)\n - #105514 (Introduce `Span::is_visible`)\n - #105516 (Update cargo)\n - #105522 (Remove wrong note for short circuiting operators)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "30a3fba4cc6a131f33f6da5df02a6416a4ae934d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30a3fba4cc6a131f33f6da5df02a6416a4ae934d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b12b83674f310b85f49ba799e51f9b9f1824870c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b12b83674f310b85f49ba799e51f9b9f1824870c", "html_url": "https://github.com/rust-lang/rust/commit/b12b83674f310b85f49ba799e51f9b9f1824870c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b12b83674f310b85f49ba799e51f9b9f1824870c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc70ff277dda8b7f227208eff789f1f68b6de5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc70ff277dda8b7f227208eff789f1f68b6de5a", "html_url": "https://github.com/rust-lang/rust/commit/cbc70ff277dda8b7f227208eff789f1f68b6de5a"}, {"sha": "f6c2add0ed76cf2723168f76989b1704eface686", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6c2add0ed76cf2723168f76989b1704eface686", "html_url": "https://github.com/rust-lang/rust/commit/f6c2add0ed76cf2723168f76989b1704eface686"}], "stats": {"total": 1197, "additions": 913, "deletions": 284}, "files": [{"sha": "37bbe95d633817484ca6f0f93cff859fca843f2b", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -4404,6 +4404,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"tracing\",\n+ \"twox-hash\",\n ]\n \n [[package]]\n@@ -5394,6 +5395,17 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"twox-hash\"\n+version = \"1.6.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"97fee6b57c6a41524a810daee9286c02d7752c4253064d0b05472833a438f675\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"rand 0.8.5\",\n+ \"static_assertions\",\n+]\n+\n [[package]]\n name = \"type-map\"\n version = \"0.4.0\""}, {"sha": "89a415cdb36cd2d8d98c0b1f132541e018364f39", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -300,4 +300,8 @@ impl<'gcc, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // Unsupported.\n         self.context.new_rvalue_from_int(self.int_type, 0)\n     }\n+\n+    fn set_kcfi_type_metadata(&self, _function: RValue<'gcc>, _kcfi_typeid: u32) {\n+        // Unsupported.\n+    }\n }"}, {"sha": "668d929270530023e08c94352b9d7522b3871e75", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -88,7 +88,8 @@ pub(crate) unsafe fn codegen(\n             callee,\n             args.as_ptr(),\n             args.len() as c_uint,\n-            None,\n+            [].as_ptr(),\n+            0 as c_uint,\n         );\n         llvm::LLVMSetTailCall(ret, True);\n         if output.is_some() {\n@@ -132,8 +133,15 @@ pub(crate) unsafe fn codegen(\n         .enumerate()\n         .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n         .collect::<Vec<_>>();\n-    let ret =\n-        llvm::LLVMRustBuildCall(llbuilder, ty, callee, args.as_ptr(), args.len() as c_uint, None);\n+    let ret = llvm::LLVMRustBuildCall(\n+        llbuilder,\n+        ty,\n+        callee,\n+        args.as_ptr(),\n+        args.len() as c_uint,\n+        [].as_ptr(),\n+        0 as c_uint,\n+    );\n     llvm::LLVMSetTailCall(ret, True);\n     llvm::LLVMBuildRetVoid(llbuilder);\n     llvm::LLVMDisposeBuilder(llbuilder);"}, {"sha": "83bffb20e0ce02c706f191199119627fefe1a4f5", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::layout::{\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n+use rustc_symbol_mangling::typeid::kcfi_typeid_for_fnabi;\n use rustc_target::abi::{self, call::FnAbi, Align, Size, WrappingRange};\n use rustc_target::spec::{HasTargetSpec, Target};\n use std::borrow::Cow;\n@@ -225,9 +226,25 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         debug!(\"invoke {:?} with args ({:?})\", llfn, args);\n \n         let args = self.check_call(\"invoke\", llty, llfn, args);\n-        let bundle = funclet.map(|funclet| funclet.bundle());\n-        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+        let funclet_bundle = funclet.map(|funclet| funclet.bundle());\n+        let funclet_bundle = funclet_bundle.as_ref().map(|b| &*b.raw);\n+        let mut bundles = vec![funclet_bundle];\n+\n+        // Set KCFI operand bundle\n+        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n+        let kcfi_bundle =\n+            if self.tcx.sess.is_sanitizer_kcfi_enabled() && fn_abi.is_some() && is_indirect_call {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap());\n+                Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n+            } else {\n+                None\n+            };\n+        if kcfi_bundle.is_some() {\n+            let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n+            bundles.push(kcfi_bundle);\n+        }\n \n+        bundles.retain(|bundle| bundle.is_some());\n         let invoke = unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n@@ -237,7 +254,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 args.len() as c_uint,\n                 then,\n                 catch,\n-                bundle,\n+                bundles.as_ptr(),\n+                bundles.len() as c_uint,\n                 UNNAMED,\n             )\n         };\n@@ -1143,7 +1161,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n-                None,\n+                [].as_ptr(),\n+                0 as c_uint,\n             );\n         }\n     }\n@@ -1159,17 +1178,34 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         debug!(\"call {:?} with args ({:?})\", llfn, args);\n \n         let args = self.check_call(\"call\", llty, llfn, args);\n-        let bundle = funclet.map(|funclet| funclet.bundle());\n-        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+        let funclet_bundle = funclet.map(|funclet| funclet.bundle());\n+        let funclet_bundle = funclet_bundle.as_ref().map(|b| &*b.raw);\n+        let mut bundles = vec![funclet_bundle];\n+\n+        // Set KCFI operand bundle\n+        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n+        let kcfi_bundle =\n+            if self.tcx.sess.is_sanitizer_kcfi_enabled() && fn_abi.is_some() && is_indirect_call {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap());\n+                Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n+            } else {\n+                None\n+            };\n+        if kcfi_bundle.is_some() {\n+            let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n+            bundles.push(kcfi_bundle);\n+        }\n \n+        bundles.retain(|bundle| bundle.is_some());\n         let call = unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n                 llty,\n                 llfn,\n                 args.as_ptr() as *const &llvm::Value,\n                 args.len() as c_uint,\n-                bundle,\n+                bundles.as_ptr(),\n+                bundles.len() as c_uint,\n             )\n         };\n         if let Some(fn_abi) = fn_abi {"}, {"sha": "aa1735f38acfd1e8c4c65e49f1998939407e84af", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -250,6 +250,11 @@ pub unsafe fn create_module<'ll>(\n         );\n     }\n \n+    if sess.is_sanitizer_kcfi_enabled() {\n+        let kcfi = \"kcfi\\0\".as_ptr().cast();\n+        llvm::LLVMRustAddModuleFlag(llmod, llvm::LLVMModFlagBehavior::Override, kcfi, 1);\n+    }\n+\n     // Control Flow Guard is currently only supported by the MSVC linker on Windows.\n     if sess.target.is_like_msvc {\n         match sess.opts.cg.control_flow_guard {"}, {"sha": "a9e3dcf4cb39a7c56663f6bb271c82e0003ea71f", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -27,9 +27,7 @@ use rustc_codegen_ssa::traits::*;\n use rustc_fs_util::path_to_c_string;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::bug;\n-use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n@@ -1026,33 +1024,6 @@ fn build_struct_type_di_node<'ll, 'tcx>(\n // Tuples\n //=-----------------------------------------------------------------------------\n \n-/// Returns names of captured upvars for closures and generators.\n-///\n-/// Here are some examples:\n-///  - `name__field1__field2` when the upvar is captured by value.\n-///  - `_ref__name__field` when the upvar is captured by reference.\n-///\n-/// For generators this only contains upvars that are shared by all states.\n-fn closure_saved_names_of_captured_variables(tcx: TyCtxt<'_>, def_id: DefId) -> SmallVec<String> {\n-    let body = tcx.optimized_mir(def_id);\n-\n-    body.var_debug_info\n-        .iter()\n-        .filter_map(|var| {\n-            let is_ref = match var.value {\n-                mir::VarDebugInfoContents::Place(place) if place.local == mir::Local::new(1) => {\n-                    // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n-                    // implies whether the variable is captured by value or by reference.\n-                    matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n-                }\n-                _ => return None,\n-            };\n-            let prefix = if is_ref { \"_ref__\" } else { \"\" };\n-            Some(prefix.to_owned() + var.name.as_str())\n-        })\n-        .collect()\n-}\n-\n /// Builds the DW_TAG_member debuginfo nodes for the upvars of a closure or generator.\n /// For a generator, this will handle upvars shared by all states.\n fn build_upvar_field_di_nodes<'ll, 'tcx>(\n@@ -1083,7 +1054,7 @@ fn build_upvar_field_di_nodes<'ll, 'tcx>(\n             .all(|&t| t == cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), t))\n     );\n \n-    let capture_names = closure_saved_names_of_captured_variables(cx.tcx, def_id);\n+    let capture_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n     let layout = cx.layout_of(closure_or_generator_ty);\n \n     up_var_tys\n@@ -1229,43 +1200,6 @@ fn build_union_type_di_node<'ll, 'tcx>(\n     )\n }\n \n-// FIXME(eddyb) maybe precompute this? Right now it's computed once\n-// per generator monomorphization, but it doesn't depend on substs.\n-fn generator_layout_and_saved_local_names<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> (&'tcx GeneratorLayout<'tcx>, IndexVec<mir::GeneratorSavedLocal, Option<Symbol>>) {\n-    let body = tcx.optimized_mir(def_id);\n-    let generator_layout = body.generator_layout().unwrap();\n-    let mut generator_saved_local_names = IndexVec::from_elem(None, &generator_layout.field_tys);\n-\n-    let state_arg = mir::Local::new(1);\n-    for var in &body.var_debug_info {\n-        let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n-        if place.local != state_arg {\n-            continue;\n-        }\n-        match place.projection[..] {\n-            [\n-                // Deref of the `Pin<&mut Self>` state argument.\n-                mir::ProjectionElem::Field(..),\n-                mir::ProjectionElem::Deref,\n-                // Field of a variant of the state.\n-                mir::ProjectionElem::Downcast(_, variant),\n-                mir::ProjectionElem::Field(field, _),\n-            ] => {\n-                let name = &mut generator_saved_local_names\n-                    [generator_layout.variant_fields[variant][field]];\n-                if name.is_none() {\n-                    name.replace(var.name);\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-    (generator_layout, generator_saved_local_names)\n-}\n-\n /// Computes the type parameters for a type, if any, for the given metadata.\n fn build_generic_type_param_di_nodes<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,"}, {"sha": "69443b9b828e2caf3a19ba382557c3431ada8169", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -22,9 +22,9 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            build_field_di_node, closure_saved_names_of_captured_variables,\n+            build_field_di_node,\n             enums::{tag_base_type, DiscrResult},\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n@@ -677,9 +677,9 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n     };\n \n     let (generator_layout, state_specific_upvar_names) =\n-        generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+        cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n-    let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+    let common_upvar_names = cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n     let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n     let variant_count = (variant_range.start.as_u32()..variant_range.end.as_u32()).len();\n "}, {"sha": "93419d27a6236c5356a1a4045c7e05b0225794a6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -4,9 +4,8 @@ use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n-            closure_saved_names_of_captured_variables,\n             enums::tag_base_type,\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            file_metadata, size_and_align_of, type_di_node,\n             type_map::{self, Stub, StubInfo, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS,\n             UNKNOWN_LINE_NUMBER,\n@@ -157,7 +156,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n         ),\n         |cx, generator_type_di_node| {\n             let (generator_layout, state_specific_upvar_names) =\n-                generator_layout_and_saved_local_names(cx.tcx, generator_def_id);\n+                cx.tcx.generator_layout_and_saved_local_names(generator_def_id);\n \n             let Variants::Multiple { tag_encoding: TagEncoding::Direct, ref variants, .. } = generator_type_and_layout.variants else {\n                 bug!(\n@@ -167,7 +166,7 @@ pub(super) fn build_generator_di_node<'ll, 'tcx>(\n             };\n \n             let common_upvar_names =\n-                closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n+                cx.tcx.closure_saved_names_of_captured_variables(generator_def_id);\n \n             // Build variant struct types\n             let variant_struct_type_di_nodes: SmallVec<_> = variants"}, {"sha": "6a575095f7e45dbc5e05a7b86cebd7ce2851925e", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -20,7 +20,7 @@ use crate::type_::Type;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::TypeMembershipMethods;\n use rustc_middle::ty::Ty;\n-use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n+use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi};\n use smallvec::SmallVec;\n \n /// Declare a function.\n@@ -136,6 +136,11 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             self.set_type_metadata(llfn, typeid);\n         }\n \n+        if self.tcx.sess.is_sanitizer_kcfi_enabled() {\n+            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n+            self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+        }\n+\n         llfn\n     }\n "}, {"sha": "e61dbe8b8fc50dfbd2c0fe6de8fc8c7604b06974", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -427,6 +427,7 @@ pub enum MetadataType {\n     MD_type = 19,\n     MD_vcall_visibility = 28,\n     MD_noundef = 29,\n+    MD_kcfi_type = 36,\n }\n \n /// LLVMRustAsmDialect\n@@ -1063,6 +1064,7 @@ extern \"C\" {\n     pub fn LLVMGlobalSetMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n     pub fn LLVMRustGlobalAddMetadata<'a>(Val: &'a Value, KindID: c_uint, Metadata: &'a Metadata);\n     pub fn LLVMValueAsMetadata(Node: &Value) -> &Metadata;\n+    pub fn LLVMIsAFunction(Val: &Value) -> Option<&Value>;\n \n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;\n@@ -1273,7 +1275,8 @@ extern \"C\" {\n         NumArgs: c_uint,\n         Then: &'a BasicBlock,\n         Catch: &'a BasicBlock,\n-        Bundle: Option<&OperandBundleDef<'a>>,\n+        OpBundles: *const Option<&OperandBundleDef<'a>>,\n+        NumOpBundles: c_uint,\n         Name: *const c_char,\n     ) -> &'a Value;\n     pub fn LLVMBuildLandingPad<'a>(\n@@ -1643,7 +1646,8 @@ extern \"C\" {\n         Fn: &'a Value,\n         Args: *const &'a Value,\n         NumArgs: c_uint,\n-        Bundle: Option<&OperandBundleDef<'a>>,\n+        OpBundles: *const Option<&OperandBundleDef<'a>>,\n+        NumOpBundles: c_uint,\n     ) -> &'a Value;\n     pub fn LLVMRustBuildMemCpy<'a>(\n         B: &Builder<'a>,"}, {"sha": "ff111d96f840b1bc817ceb7bfbecf29aa1ee0e6d", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -316,4 +316,19 @@ impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             )\n         }\n     }\n+\n+    fn set_kcfi_type_metadata(&self, function: &'ll Value, kcfi_typeid: u32) {\n+        let kcfi_type_metadata = self.const_u32(kcfi_typeid);\n+        unsafe {\n+            llvm::LLVMGlobalSetMetadata(\n+                function,\n+                llvm::MD_kcfi_type as c_uint,\n+                llvm::LLVMMDNodeInContext2(\n+                    self.llcx,\n+                    &llvm::LLVMValueAsMetadata(kcfi_type_metadata),\n+                    1,\n+                ),\n+            )\n+        }\n+    }\n }"}, {"sha": "109161ccc836865e36ea8151bc61f236125347db", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -122,6 +122,7 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n pub trait TypeMembershipMethods<'tcx>: Backend<'tcx> {\n     fn set_type_metadata(&self, function: Self::Function, typeid: String);\n     fn typeid_metadata(&self, typeid: String) -> Self::Value;\n+    fn set_kcfi_type_metadata(&self, function: Self::Function, typeid: u32);\n }\n \n pub trait ArgAbiMethods<'tcx>: HasCodegen<'tcx> {"}, {"sha": "6d8e78a0f185dc6a16c577b6bb2a6c386f51389a", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -394,7 +394,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(instruction_set, Normal, template!(List: \"set\"), ErrorPreceding),\n     gated!(\n         no_sanitize, Normal,\n-        template!(List: \"address, memory, thread\"), DuplicatesOk,\n+        template!(List: \"address, kcfi, memory, thread\"), DuplicatesOk,\n         experimental!(no_sanitize)\n     ),\n     gated!(no_coverage, Normal, template!(Word), WarnFollowing, experimental!(no_coverage)),"}, {"sha": "72288e5bc761f0e4ba9566e1f02c4d44d57f5420", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1846,6 +1846,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n                     } else if item.has_name(sym::cfi) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                    } else if item.has_name(sym::kcfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n                     } else if item.has_name(sym::memory) {\n                         codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n                     } else if item.has_name(sym::memtag) {\n@@ -1859,7 +1861,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                     } else {\n                         tcx.sess\n                             .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n                             .emit();\n                     }\n                 }"}, {"sha": "777f7ca5c9b50bbb5126e17c616baa130eb64fd1", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -617,7 +617,10 @@ trait UnusedDelimLint {\n         lhs_needs_parens\n             || (followed_by_block\n                 && match &inner.kind {\n-                    ExprKind::Ret(_) | ExprKind::Break(..) | ExprKind::Yield(..) => true,\n+                    ExprKind::Ret(_)\n+                    | ExprKind::Break(..)\n+                    | ExprKind::Yield(..)\n+                    | ExprKind::Yeet(..) => true,\n                     ExprKind::Range(_lhs, Some(rhs), _limits) => {\n                         matches!(rhs.kind, ExprKind::Block(..))\n                     }"}, {"sha": "5831d4693f18bbf12ae6436080ed59f8c8ce550b", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1476,13 +1476,13 @@ extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n \n extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n-                                          OperandBundleDef *Bundle) {\n+                                          OperandBundleDef **OpBundles,\n+                                          unsigned NumOpBundles) {\n   Value *Callee = unwrap(Fn);\n   FunctionType *FTy = unwrap<FunctionType>(Ty);\n-  unsigned Len = Bundle ? 1 : 0;\n-  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n-      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs), Bundles));\n+      FTy, Callee, makeArrayRef(unwrap(Args), NumArgs),\n+      makeArrayRef(*OpBundles, NumOpBundles)));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetInstrProfIncrementIntrinsic(LLVMModuleRef M) {\n@@ -1522,14 +1522,14 @@ extern \"C\" LLVMValueRef\n LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,\n                     LLVMValueRef *Args, unsigned NumArgs,\n                     LLVMBasicBlockRef Then, LLVMBasicBlockRef Catch,\n-                    OperandBundleDef *Bundle, const char *Name) {\n+                    OperandBundleDef **OpBundles, unsigned NumOpBundles,\n+                    const char *Name) {\n   Value *Callee = unwrap(Fn);\n   FunctionType *FTy = unwrap<FunctionType>(Ty);\n-  unsigned Len = Bundle ? 1 : 0;\n-  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateInvoke(FTy, Callee, unwrap(Then), unwrap(Catch),\n                                       makeArrayRef(unwrap(Args), NumArgs),\n-                                      Bundles, Name));\n+                                      makeArrayRef(*OpBundles, NumOpBundles),\n+                                      Name));\n }\n \n extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B,"}, {"sha": "9ea8dc6e69fdde0b172103282cd1c384bd3fb5b2", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1,6 +1,7 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use crate::mir;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -15,6 +16,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::GrowableBitSet;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_span::{sym, DUMMY_SP};\n use rustc_target::abi::{Integer, IntegerType, Size, TargetDataLayout};\n@@ -692,6 +694,80 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn bound_impl_subject(self, def_id: DefId) -> ty::EarlyBinder<ty::ImplSubject<'tcx>> {\n         ty::EarlyBinder(self.impl_subject(def_id))\n     }\n+\n+    /// Returns names of captured upvars for closures and generators.\n+    ///\n+    /// Here are some examples:\n+    ///  - `name__field1__field2` when the upvar is captured by value.\n+    ///  - `_ref__name__field` when the upvar is captured by reference.\n+    ///\n+    /// For generators this only contains upvars that are shared by all states.\n+    pub fn closure_saved_names_of_captured_variables(\n+        self,\n+        def_id: DefId,\n+    ) -> SmallVec<[String; 16]> {\n+        let body = self.optimized_mir(def_id);\n+\n+        body.var_debug_info\n+            .iter()\n+            .filter_map(|var| {\n+                let is_ref = match var.value {\n+                    mir::VarDebugInfoContents::Place(place)\n+                        if place.local == mir::Local::new(1) =>\n+                    {\n+                        // The projection is either `[.., Field, Deref]` or `[.., Field]`. It\n+                        // implies whether the variable is captured by value or by reference.\n+                        matches!(place.projection.last().unwrap(), mir::ProjectionElem::Deref)\n+                    }\n+                    _ => return None,\n+                };\n+                let prefix = if is_ref { \"_ref__\" } else { \"\" };\n+                Some(prefix.to_owned() + var.name.as_str())\n+            })\n+            .collect()\n+    }\n+\n+    // FIXME(eddyb) maybe precompute this? Right now it's computed once\n+    // per generator monomorphization, but it doesn't depend on substs.\n+    pub fn generator_layout_and_saved_local_names(\n+        self,\n+        def_id: DefId,\n+    ) -> (\n+        &'tcx ty::GeneratorLayout<'tcx>,\n+        IndexVec<mir::GeneratorSavedLocal, Option<rustc_span::Symbol>>,\n+    ) {\n+        let tcx = self;\n+        let body = tcx.optimized_mir(def_id);\n+        let generator_layout = body.generator_layout().unwrap();\n+        let mut generator_saved_local_names =\n+            IndexVec::from_elem(None, &generator_layout.field_tys);\n+\n+        let state_arg = mir::Local::new(1);\n+        for var in &body.var_debug_info {\n+            let mir::VarDebugInfoContents::Place(place) = &var.value else { continue };\n+            if place.local != state_arg {\n+                continue;\n+            }\n+            match place.projection[..] {\n+                [\n+                    // Deref of the `Pin<&mut Self>` state argument.\n+                    mir::ProjectionElem::Field(..),\n+                    mir::ProjectionElem::Deref,\n+                    // Field of a variant of the state.\n+                    mir::ProjectionElem::Downcast(_, variant),\n+                    mir::ProjectionElem::Field(field, _),\n+                ] => {\n+                    let name = &mut generator_saved_local_names\n+                        [generator_layout.variant_fields[variant][field]];\n+                    if name.is_none() {\n+                        name.replace(var.name);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        (generator_layout, generator_saved_local_names)\n+    }\n }\n \n struct OpaqueTypeExpander<'tcx> {"}, {"sha": "1085bce44758fe7235929e8c7ca2b703f23cbae3", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -19,7 +19,7 @@ pub enum SizeKind {\n     Min,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FieldInfo {\n     pub name: Symbol,\n     pub offset: u64,\n@@ -33,6 +33,7 @@ pub enum DataTypeKind {\n     Union,\n     Enum,\n     Closure,\n+    Generator,\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n@@ -114,7 +115,7 @@ impl CodeStats {\n \n             let struct_like = match kind {\n                 DataTypeKind::Struct | DataTypeKind::Closure => true,\n-                DataTypeKind::Enum | DataTypeKind::Union => false,\n+                DataTypeKind::Enum | DataTypeKind::Union | DataTypeKind::Generator => false,\n             };\n             for (i, variant_info) in variants.into_iter().enumerate() {\n                 let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;"}, {"sha": "dab9c736d14d59d496f8bbed8b2e2d52f57a5980", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -368,7 +368,7 @@ mod desc {\n     pub const parse_opt_panic_strategy: &str = parse_panic_strategy;\n     pub const parse_oom_strategy: &str = \"either `panic` or `abort`\";\n     pub const parse_relro_level: &str = \"one of: `full`, `partial`, or `off`\";\n-    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n+    pub const parse_sanitizers: &str = \"comma separated list of sanitizers: `address`, `cfi`, `hwaddress`, `kcfi`, `leak`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\";\n     pub const parse_sanitizer_memory_track_origins: &str = \"0, 1, or 2\";\n     pub const parse_cfguard: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `checks`, or `nochecks`\";\n@@ -675,6 +675,7 @@ mod parse {\n                 *slot |= match s {\n                     \"address\" => SanitizerSet::ADDRESS,\n                     \"cfi\" => SanitizerSet::CFI,\n+                    \"kcfi\" => SanitizerSet::KCFI,\n                     \"leak\" => SanitizerSet::LEAK,\n                     \"memory\" => SanitizerSet::MEMORY,\n                     \"memtag\" => SanitizerSet::MEMTAG,"}, {"sha": "8859b76d28972f7b36005f035f591300f22e9b79", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -686,6 +686,10 @@ impl Session {\n         self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n     }\n \n+    pub fn is_sanitizer_kcfi_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer.contains(SanitizerSet::KCFI)\n+    }\n+\n     /// Check whether this compile session and crate type use static crt.\n     pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n         if !self.target.crt_static_respected {\n@@ -1544,6 +1548,14 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         }\n     }\n \n+    // LLVM CFI and KCFI are mutually exclusive\n+    if sess.is_sanitizer_cfi_enabled() && sess.is_sanitizer_kcfi_enabled() {\n+        sess.emit_err(CannotMixAndMatchSanitizers {\n+            first: \"cfi\".to_string(),\n+            second: \"kcfi\".to_string(),\n+        });\n+    }\n+\n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n             sess.emit_warning(StackProtectorNotSupportedForTarget {"}, {"sha": "335bfc3302f27c34bd0dada4f2e93840574a55f0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -491,6 +491,10 @@ impl SpanData {\n     pub fn is_dummy(self) -> bool {\n         self.lo.0 == 0 && self.hi.0 == 0\n     }\n+    #[inline]\n+    pub fn is_visible(self, sm: &SourceMap) -> bool {\n+        !self.is_dummy() && sm.is_span_accessible(self.span())\n+    }\n     /// Returns `true` if `self` fully encloses `other`.\n     pub fn contains(self, other: Self) -> bool {\n         self.lo <= other.lo && other.hi <= self.hi\n@@ -556,6 +560,11 @@ impl Span {\n         self.data_untracked().is_dummy()\n     }\n \n+    #[inline]\n+    pub fn is_visible(self, sm: &SourceMap) -> bool {\n+        self.data_untracked().is_visible(sm)\n+    }\n+\n     /// Returns `true` if this span comes from any kind of macro, desugaring or inlining.\n     #[inline]\n     pub fn from_expansion(self) -> bool {"}, {"sha": "1fcf8c7a8bf13f06543603c5a9d1ff120861c01a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -828,6 +828,7 @@ symbols! {\n         item_like_imports,\n         iter,\n         iter_repeat,\n+        kcfi,\n         keyword,\n         kind,\n         kreg,"}, {"sha": "4e447eab02e7c9d7e9dd581355282fa6a52de6c9", "filename": "compiler/rustc_symbol_mangling/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_symbol_mangling%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_symbol_mangling%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2FCargo.toml?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -10,6 +10,7 @@ bitflags = \"1.2.1\"\n tracing = \"0.1\"\n punycode = \"0.4.0\"\n rustc-demangle = \"0.1.21\"\n+twox-hash = \"1.6.3\"\n \n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "53983bed718922b3521462a88794d327bd5eceae", "filename": "compiler/rustc_symbol_mangling/src/typeid.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -3,6 +3,8 @@\n \n use rustc_middle::ty::{FnSig, Ty, TyCtxt};\n use rustc_target::abi::call::FnAbi;\n+use std::hash::Hasher;\n+use twox_hash::XxHash64;\n \n mod typeid_itanium_cxx_abi;\n use typeid_itanium_cxx_abi::TypeIdOptions;\n@@ -16,3 +18,25 @@ pub fn typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>)\n pub fn typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> String {\n     typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS)\n }\n+\n+/// Returns an LLVM KCFI type metadata identifier for the specified FnAbi.\n+pub fn kcfi_typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> u32 {\n+    // An LLVM KCFI type metadata identifier is a 32-bit constant produced by taking the lower half\n+    // of the xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+    let mut hash: XxHash64 = Default::default();\n+    hash.write(\n+        typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, TypeIdOptions::NO_OPTIONS).as_bytes(),\n+    );\n+    hash.finish() as u32\n+}\n+\n+/// Returns an LLVM KCFI type metadata identifier for the specified FnSig.\n+pub fn kcfi_typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> u32 {\n+    // An LLVM KCFI type metadata identifier is a 32-bit constant produced by taking the lower half\n+    // of the xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+    let mut hash: XxHash64 = Default::default();\n+    hash.write(\n+        typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS).as_bytes(),\n+    );\n+    hash.finish() as u32\n+}"}, {"sha": "aca52e1478eb8ac44fd5294ac34a65422d27ec73", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_none.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_none.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -6,13 +6,16 @@\n //\n // For example, `-C target-cpu=cortex-a53`.\n \n-use super::{Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, Target, TargetOptions};\n+use super::{\n+    Cc, LinkerFlavor, Lld, PanicStrategy, RelocModel, SanitizerSet, Target, TargetOptions,\n+};\n \n pub fn target() -> Target {\n     let opts = TargetOptions {\n         linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::Yes),\n         linker: Some(\"rust-lld\".into()),\n         features: \"+strict-align,+neon,+fp-armv8\".into(),\n+        supported_sanitizers: SanitizerSet::KCFI,\n         relocation_model: RelocModel::Static,\n         disable_redzone: true,\n         max_atomic_width: Some(128),"}, {"sha": "1db1d7e85adcc5fde9d05b5d4f354e13b225f718", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -804,7 +804,7 @@ impl ToJson for StackProbeType {\n \n bitflags::bitflags! {\n     #[derive(Default, Encodable, Decodable)]\n-    pub struct SanitizerSet: u8 {\n+    pub struct SanitizerSet: u16 {\n         const ADDRESS = 1 << 0;\n         const LEAK    = 1 << 1;\n         const MEMORY  = 1 << 2;\n@@ -813,6 +813,7 @@ bitflags::bitflags! {\n         const CFI     = 1 << 5;\n         const MEMTAG  = 1 << 6;\n         const SHADOWCALLSTACK = 1 << 7;\n+        const KCFI    = 1 << 8;\n     }\n }\n \n@@ -824,6 +825,7 @@ impl SanitizerSet {\n         Some(match self {\n             SanitizerSet::ADDRESS => \"address\",\n             SanitizerSet::CFI => \"cfi\",\n+            SanitizerSet::KCFI => \"kcfi\",\n             SanitizerSet::LEAK => \"leak\",\n             SanitizerSet::MEMORY => \"memory\",\n             SanitizerSet::MEMTAG => \"memtag\",\n@@ -859,6 +861,7 @@ impl IntoIterator for SanitizerSet {\n         [\n             SanitizerSet::ADDRESS,\n             SanitizerSet::CFI,\n+            SanitizerSet::KCFI,\n             SanitizerSet::LEAK,\n             SanitizerSet::MEMORY,\n             SanitizerSet::MEMTAG,\n@@ -2327,6 +2330,7 @@ impl Target {\n                             base.$key_name |= match s.as_str() {\n                                 Some(\"address\") => SanitizerSet::ADDRESS,\n                                 Some(\"cfi\") => SanitizerSet::CFI,\n+                                Some(\"kcfi\") => SanitizerSet::KCFI,\n                                 Some(\"leak\") => SanitizerSet::LEAK,\n                                 Some(\"memory\") => SanitizerSet::MEMORY,\n                                 Some(\"memtag\") => SanitizerSet::MEMTAG,"}, {"sha": "32060c35c11b835da211d0dee16e652294082cd8", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -5,7 +5,7 @@\n // features.\n \n use super::{Cc, CodeModel, LinkerFlavor, Lld, PanicStrategy};\n-use super::{RelroLevel, StackProbeType, Target, TargetOptions};\n+use super::{RelroLevel, SanitizerSet, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let opts = TargetOptions {\n@@ -20,6 +20,7 @@ pub fn target() -> Target {\n         features:\n             \"-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float\"\n                 .into(),\n+        supported_sanitizers: SanitizerSet::KCFI,\n         disable_redzone: true,\n         panic_strategy: PanicStrategy::Abort,\n         code_model: Some(CodeModel::Kernel),"}, {"sha": "443d57aaf3dce8cc63b9606b1786b5be6d963e14", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -2413,19 +2413,19 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::ExprBindingObligation(item_def_id, span, ..) => {\n                 let item_name = tcx.def_path_str(item_def_id);\n                 let mut multispan = MultiSpan::from(span);\n+                let sm = tcx.sess.source_map();\n                 if let Some(ident) = tcx.opt_item_ident(item_def_id) {\n-                    let sm = tcx.sess.source_map();\n                     let same_line =\n                         match (sm.lookup_line(ident.span.hi()), sm.lookup_line(span.lo())) {\n                             (Ok(l), Ok(r)) => l.line == r.line,\n                             _ => true,\n                         };\n-                    if !ident.span.is_dummy() && !ident.span.overlaps(span) && !same_line {\n+                    if ident.span.is_visible(sm) && !ident.span.overlaps(span) && !same_line {\n                         multispan.push_span_label(ident.span, \"required by a bound in this\");\n                     }\n                 }\n                 let descr = format!(\"required by a bound in `{}`\", item_name);\n-                if !span.is_dummy() {\n+                if span.is_visible(sm) {\n                     let msg = format!(\"required by this bound in `{}`\", item_name);\n                     multispan.push_span_label(span, msg);\n                     err.span_note(multispan, &descr);"}, {"sha": "d644cbccea11b2df6c5080a2191ad3c1c8b8f4f1", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -85,7 +85,7 @@ fn fn_sig_for_fn_abi<'tcx>(\n                 bound_vars,\n             )\n         }\n-        ty::Generator(_, substs, _) => {\n+        ty::Generator(did, substs, _) => {\n             let sig = substs.as_generator().poly_sig();\n \n             let bound_vars = tcx.mk_bound_variable_kinds(\n@@ -104,10 +104,22 @@ fn fn_sig_for_fn_abi<'tcx>(\n             let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n             let sig = sig.skip_binder();\n-            let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n-            let state_adt_ref = tcx.adt_def(state_did);\n-            let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-            let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+            // The `FnSig` and the `ret_ty` here is for a generators main\n+            // `Generator::resume(...) -> GeneratorState` function in case we\n+            // have an ordinary generator, or the `Future::poll(...) -> Poll`\n+            // function in case this is a special generator backing an async construct.\n+            let ret_ty = if tcx.generator_is_async(did) {\n+                let state_did = tcx.require_lang_item(LangItem::Poll, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.return_ty.into()]);\n+                tcx.mk_adt(state_adt_ref, state_substs)\n+            } else {\n+                let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                tcx.mk_adt(state_adt_ref, state_substs)\n+            };\n+\n             ty::Binder::bind_with_vars(\n                 tcx.mk_fn_sig(\n                     [env_ty, sig.resume_ty].iter(),"}, {"sha": "f4672a70072b2b30ce8435d350d898bfa2e8c4c3", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 116, "deletions": 27, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1,3 +1,4 @@\n+use hir::def_id::DefId;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -6,7 +7,7 @@ use rustc_middle::ty::layout::{\n     IntegerExt, LayoutCx, LayoutError, LayoutOf, TyAndLayout, MAX_SIMD_LANES,\n };\n use rustc_middle::ty::{\n-    self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n+    self, subst::SubstsRef, AdtDef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use rustc_span::symbol::Symbol;\n@@ -814,27 +815,39 @@ fn record_layout_for_printing_outlined<'tcx>(\n         );\n     };\n \n-    let adt_def = match *layout.ty.kind() {\n-        ty::Adt(ref adt_def, _) => {\n+    match *layout.ty.kind() {\n+        ty::Adt(adt_def, _) => {\n             debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n-            adt_def\n+            let adt_kind = adt_def.adt_kind();\n+            let adt_packed = adt_def.repr().pack.is_some();\n+            let (variant_infos, opt_discr_size) = variant_info_for_adt(cx, layout, adt_def);\n+            record(adt_kind.into(), adt_packed, opt_discr_size, variant_infos);\n+        }\n+\n+        ty::Generator(def_id, substs, _) => {\n+            debug!(\"print-type-size t: `{:?}` record generator\", layout.ty);\n+            // Generators always have a begin/poisoned/end state with additional suspend points\n+            let (variant_infos, opt_discr_size) =\n+                variant_info_for_generator(cx, layout, def_id, substs);\n+            record(DataTypeKind::Generator, false, opt_discr_size, variant_infos);\n         }\n \n         ty::Closure(..) => {\n             debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n             record(DataTypeKind::Closure, false, None, vec![]);\n-            return;\n         }\n \n         _ => {\n             debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n-            return;\n         }\n     };\n+}\n \n-    let adt_kind = adt_def.adt_kind();\n-    let adt_packed = adt_def.repr().pack.is_some();\n-\n+fn variant_info_for_adt<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    adt_def: AdtDef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n     let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n         let mut min_size = Size::ZERO;\n         let field_info: Vec<_> = flds\n@@ -843,10 +856,7 @@ fn record_layout_for_printing_outlined<'tcx>(\n             .map(|(i, &name)| {\n                 let field_layout = layout.field(cx, i);\n                 let offset = layout.fields.offset(i);\n-                let field_end = offset + field_layout.size;\n-                if min_size < field_end {\n-                    min_size = field_end;\n-                }\n+                min_size = min_size.max(offset + field_layout.size);\n                 FieldInfo {\n                     name,\n                     offset: offset.bytes(),\n@@ -871,16 +881,9 @@ fn record_layout_for_printing_outlined<'tcx>(\n                 debug!(\"print-type-size `{:#?}` variant {}\", layout, adt_def.variant(index).name);\n                 let variant_def = &adt_def.variant(index);\n                 let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n-                record(\n-                    adt_kind.into(),\n-                    adt_packed,\n-                    None,\n-                    vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n-                );\n+                (vec![build_variant_info(Some(variant_def.name), &fields, layout)], None)\n             } else {\n-                // (This case arises for *empty* enums; so give it\n-                // zero variants.)\n-                record(adt_kind.into(), adt_packed, None, vec![]);\n+                (vec![], None)\n             }\n         }\n \n@@ -898,15 +901,101 @@ fn record_layout_for_printing_outlined<'tcx>(\n                     build_variant_info(Some(variant_def.name), &fields, layout.for_variant(cx, i))\n                 })\n                 .collect();\n-            record(\n-                adt_kind.into(),\n-                adt_packed,\n+\n+            (\n+                variant_infos,\n                 match tag_encoding {\n                     TagEncoding::Direct => Some(tag.size(cx)),\n                     _ => None,\n                 },\n-                variant_infos,\n-            );\n+            )\n         }\n     }\n }\n+\n+fn variant_info_for_generator<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    def_id: DefId,\n+    substs: ty::SubstsRef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n+    let Variants::Multiple { tag, ref tag_encoding, .. } = layout.variants else {\n+        return (vec![], None);\n+    };\n+\n+    let (generator, state_specific_names) = cx.tcx.generator_layout_and_saved_local_names(def_id);\n+    let upvar_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n+\n+    let mut upvars_size = Size::ZERO;\n+    let upvar_fields: Vec<_> = substs\n+        .as_generator()\n+        .upvar_tys()\n+        .zip(upvar_names)\n+        .enumerate()\n+        .map(|(field_idx, (_, name))| {\n+            let field_layout = layout.field(cx, field_idx);\n+            let offset = layout.fields.offset(field_idx);\n+            upvars_size = upvars_size.max(offset + field_layout.size);\n+            FieldInfo {\n+                name: Symbol::intern(&name),\n+                offset: offset.bytes(),\n+                size: field_layout.size.bytes(),\n+                align: field_layout.align.abi.bytes(),\n+            }\n+        })\n+        .collect();\n+\n+    let variant_infos: Vec<_> = generator\n+        .variant_fields\n+        .iter_enumerated()\n+        .map(|(variant_idx, variant_def)| {\n+            let variant_layout = layout.for_variant(cx, variant_idx);\n+            let mut variant_size = Size::ZERO;\n+            let fields = variant_def\n+                .iter()\n+                .enumerate()\n+                .map(|(field_idx, local)| {\n+                    let field_layout = variant_layout.field(cx, field_idx);\n+                    let offset = variant_layout.fields.offset(field_idx);\n+                    // The struct is as large as the last field's end\n+                    variant_size = variant_size.max(offset + field_layout.size);\n+                    FieldInfo {\n+                        name: state_specific_names.get(*local).copied().flatten().unwrap_or(\n+                            Symbol::intern(&format!(\".generator_field{}\", local.as_usize())),\n+                        ),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size.bytes(),\n+                        align: field_layout.align.abi.bytes(),\n+                    }\n+                })\n+                .chain(upvar_fields.iter().copied())\n+                .collect();\n+\n+            // If the variant has no state-specific fields, then it's the size of the upvars.\n+            if variant_size == Size::ZERO {\n+                variant_size = upvars_size;\n+            }\n+            // We need to add the discriminant size back into min_size, since it is subtracted\n+            // later during printing.\n+            variant_size += match tag_encoding {\n+                TagEncoding::Direct => tag.size(cx),\n+                _ => Size::ZERO,\n+            };\n+\n+            VariantInfo {\n+                name: Some(Symbol::intern(&ty::GeneratorSubsts::variant_name(variant_idx))),\n+                kind: SizeKind::Exact,\n+                size: variant_size.bytes(),\n+                align: variant_layout.align.abi.bytes(),\n+                fields,\n+            }\n+        })\n+        .collect();\n+    (\n+        variant_infos,\n+        match tag_encoding {\n+            TagEncoding::Direct => Some(tag.size(cx)),\n+            _ => None,\n+        },\n+    )\n+}"}, {"sha": "5e1d2f2e314ff904173d04c224797cd2b017b5f2", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -35,17 +35,16 @@ changelog-seen = 2\n # Unless you're developing for a target where Rust CI doesn't build a compiler\n # toolchain or changing LLVM locally, you probably want to set this to true.\n #\n-# This is false by default so that distributions don't unexpectedly download\n-# LLVM from the internet.\n-#\n # All tier 1 targets are currently supported; set this to `\"if-available\"` if\n # you are not sure whether you're on a tier 1 target.\n #\n # We also currently only support this when building LLVM for the build triple.\n #\n # Note that many of the LLVM options are not currently supported for\n # downloading. Currently only the \"assertions\" option can be toggled.\n-#download-ci-llvm = false\n+#\n+# Defaults to \"if-available\" when `channel = \"dev\"` and \"false\" otherwise.\n+#download-ci-llvm = \"if-available\"\n \n # Indicates whether LLVM rebuild should be skipped when running bootstrap. If\n # this is `false` then the compiler's LLVM will be rebuilt whenever the built"}, {"sha": "eb2a92f4644d11e8bc903cceb47ac527afbde4eb", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -17,10 +17,10 @@\n //! should have some resemblance to multiplication (and share expected\n //! properties like associativity).\n //!\n-//! Note that the `&&` and `||` operators short-circuit, i.e., they only\n-//! evaluate their second operand if it contributes to the result. Since this\n-//! behavior is not enforceable by traits, `&&` and `||` are not supported as\n-//! overloadable operators.\n+//! Note that the `&&` and `||` operators are currently not supported for\n+//! overloading. Due to their short circuiting nature, they require a different\n+//! design from traits for other operators like [`BitAnd`]. Designs for them are\n+//! under discussion.\n //!\n //! Many of the operators take their operands by value. In non-generic\n //! contexts involving built-in types, this is usually not a problem."}, {"sha": "4748ac9d97ef8fda19d11f2d2f48e403ef466fae", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1551,3 +1551,19 @@ fn hiberfil_sys() {\n     fs::metadata(hiberfil).unwrap();\n     assert_eq!(true, hiberfil.exists());\n }\n+\n+/// Test that two different ways of obtaining the FileType give the same result.\n+/// Cf. https://github.com/rust-lang/rust/issues/104900\n+#[test]\n+fn test_eq_direntry_metadata() {\n+    let tmpdir = tmpdir();\n+    let file_path = tmpdir.join(\"file\");\n+    File::create(file_path).unwrap();\n+    for e in fs::read_dir(tmpdir.path()).unwrap() {\n+        let e = e.unwrap();\n+        let p = e.path();\n+        let ft1 = e.file_type().unwrap();\n+        let ft2 = p.metadata().unwrap().file_type();\n+        assert_eq!(ft1, ft2);\n+    }\n+}"}, {"sha": "63e070207cd707cca701b47e7db0ca5e05b6b4eb", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -34,6 +34,7 @@ pub mod process;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n+pub mod thread_parker;\n pub mod time;\n \n mod condvar;"}, {"sha": "579f758c6cc339fe10f5eb65192851c5e48bf15c", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -65,39 +65,36 @@ mod task_queue {\n /// execution. The signal is sent once all TLS destructors have finished at\n /// which point no new thread locals should be created.\n pub mod wait_notify {\n-    use super::super::waitqueue::{SpinMutex, WaitQueue, WaitVariable};\n+    use super::super::thread_parker::Parker;\n+    use crate::pin::Pin;\n     use crate::sync::Arc;\n \n-    pub struct Notifier(Arc<SpinMutex<WaitVariable<bool>>>);\n+    pub struct Notifier(Arc<Parker>);\n \n     impl Notifier {\n         /// Notify the waiter. The waiter is either notified right away (if\n         /// currently blocked in `Waiter::wait()`) or later when it calls the\n         /// `Waiter::wait()` method.\n         pub fn notify(self) {\n-            let mut guard = self.0.lock();\n-            *guard.lock_var_mut() = true;\n-            let _ = WaitQueue::notify_one(guard);\n+            Pin::new(&*self.0).unpark()\n         }\n     }\n \n-    pub struct Waiter(Arc<SpinMutex<WaitVariable<bool>>>);\n+    pub struct Waiter(Arc<Parker>);\n \n     impl Waiter {\n         /// Wait for a notification. If `Notifier::notify()` has already been\n         /// called, this will return immediately, otherwise the current thread\n         /// is blocked until notified.\n         pub fn wait(self) {\n-            let guard = self.0.lock();\n-            if *guard.lock_var() {\n-                return;\n-            }\n-            WaitQueue::wait(guard, || {});\n+            // This is not actually `unsafe`, but it uses the `Parker` API,\n+            // which needs `unsafe` on some platforms.\n+            unsafe { Pin::new(&*self.0).park() }\n         }\n     }\n \n     pub fn new() -> (Notifier, Waiter) {\n-        let inner = Arc::new(SpinMutex::new(WaitVariable::new(false)));\n+        let inner = Arc::new(Parker::new_internal());\n         (Notifier(inner.clone()), Waiter(inner))\n     }\n }"}, {"sha": "1c55bcffb1e8c2dc3650e918177026d9b7cc2250", "filename": "library/std/src/sys/sgx/thread_parker.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread_parker.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,107 @@\n+//! Thread parking based on SGX events.\n+\n+use super::abi::{thread, usercalls};\n+use crate::io::ErrorKind;\n+use crate::pin::Pin;\n+use crate::ptr::{self, NonNull};\n+use crate::sync::atomic::AtomicPtr;\n+use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n+use crate::time::Duration;\n+use fortanix_sgx_abi::{EV_UNPARK, WAIT_INDEFINITE};\n+\n+// The TCS structure must be page-aligned (this is checked by EENTER), so these cannot\n+// be valid pointers\n+const EMPTY: *mut u8 = ptr::invalid_mut(1);\n+const NOTIFIED: *mut u8 = ptr::invalid_mut(2);\n+\n+pub struct Parker {\n+    /// The park state. One of EMPTY, NOTIFIED or a TCS address.\n+    /// A state change to NOTIFIED must be done with release ordering\n+    /// and be observed with acquire ordering so that operations after\n+    /// `thread::park` returns will not occur before the unpark message\n+    /// was sent.\n+    state: AtomicPtr<u8>,\n+}\n+\n+impl Parker {\n+    /// Construct the thread parker. The UNIX parker implementation\n+    /// requires this to happen in-place.\n+    pub unsafe fn new(parker: *mut Parker) {\n+        unsafe { parker.write(Parker::new_internal()) }\n+    }\n+\n+    pub(super) fn new_internal() -> Parker {\n+        Parker { state: AtomicPtr::new(EMPTY) }\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park(self: Pin<&Self>) {\n+        if self.state.load(Acquire) != NOTIFIED {\n+            let mut prev = EMPTY;\n+            loop {\n+                // Guard against changing TCS addresses by always setting the state to\n+                // the current value.\n+                let tcs = thread::current().as_ptr();\n+                if self.state.compare_exchange(prev, tcs, Relaxed, Acquire).is_ok() {\n+                    let event = usercalls::wait(EV_UNPARK, WAIT_INDEFINITE).unwrap();\n+                    assert!(event & EV_UNPARK == EV_UNPARK);\n+                    prev = tcs;\n+                } else {\n+                    // The state was definitely changed by another thread at this point.\n+                    // The only time this occurs is when the state is changed to NOTIFIED.\n+                    // We observed this change with acquire ordering, so we can simply\n+                    // change the state to EMPTY with a relaxed store.\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // At this point, the token was definately read with acquire ordering,\n+        // so this can be a relaxed store.\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n+    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n+        let timeout = u128::min(dur.as_nanos(), WAIT_INDEFINITE as u128 - 1) as u64;\n+        let tcs = thread::current().as_ptr();\n+\n+        if self.state.load(Acquire) != NOTIFIED {\n+            if self.state.compare_exchange(EMPTY, tcs, Relaxed, Acquire).is_ok() {\n+                match usercalls::wait(EV_UNPARK, timeout) {\n+                    Ok(event) => assert!(event & EV_UNPARK == EV_UNPARK),\n+                    Err(e) => {\n+                        assert!(matches!(e.kind(), ErrorKind::TimedOut | ErrorKind::WouldBlock))\n+                    }\n+                }\n+\n+                // Swap to provide acquire ordering even if the timeout occurred\n+                // before the token was set. This situation can result in spurious\n+                // wakeups on the next call to `park_timeout`, but it is better to let\n+                // those be handled by the user than do some perhaps unnecessary, but\n+                // always expensive guarding.\n+                self.state.swap(EMPTY, Acquire);\n+                return;\n+            }\n+        }\n+\n+        // The token was already read with `acquire` ordering, this can be a store.\n+        self.state.store(EMPTY, Relaxed);\n+    }\n+\n+    // This implementation doesn't require `Pin`, but other implementations do.\n+    pub fn unpark(self: Pin<&Self>) {\n+        let state = self.state.swap(NOTIFIED, Release);\n+\n+        if !matches!(state, EMPTY | NOTIFIED) {\n+            // There is a thread waiting, wake it up.\n+            let tcs = NonNull::new(state).unwrap();\n+            // This will fail if the thread has already terminated or its TCS is destroyed\n+            // by the time the signal is sent, but that is fine. If another thread receives\n+            // the same TCS, it will receive this notification as a spurious wakeup, but\n+            // all users of `wait` should and (internally) do guard against those where\n+            // necessary.\n+            let _ = usercalls::send(EV_UNPARK, Some(tcs));\n+        }\n+    }\n+}"}, {"sha": "fb8d06c66820cf0b47a41a48cfdfd8064d3c7f5f", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -332,11 +332,23 @@ pub struct FileTimes {\n     modified: Option<SystemTime>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, Eq, Debug)]\n pub struct FileType {\n     mode: mode_t,\n }\n \n+impl PartialEq for FileType {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.masked() == other.masked()\n+    }\n+}\n+\n+impl core::hash::Hash for FileType {\n+    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {\n+        self.masked().hash(state);\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct DirBuilder {\n     mode: mode_t,\n@@ -548,7 +560,11 @@ impl FileType {\n     }\n \n     pub fn is(&self, mode: mode_t) -> bool {\n-        self.mode & libc::S_IFMT == mode\n+        self.masked() == mode\n+    }\n+\n+    fn masked(&self) -> mode_t {\n+        self.mode & libc::S_IFMT\n     }\n }\n "}, {"sha": "08a2bdd82298b9f622e5589ff2550d20ccd0658a", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -16,6 +16,8 @@ cfg_if::cfg_if! {\n         pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parker::Parker;\n+    } else if #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] {\n+        pub use crate::sys::thread_parker::Parker;\n     } else {\n         mod generic;\n         pub use generic::Parker;"}, {"sha": "960fbdf75380448983b1f3650b9fd66b95dc3df8", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 108, "deletions": 94, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -3,6 +3,9 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n+#[cfg(test)]\n+mod tests;\n+\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::collections::{HashMap, HashSet};\n@@ -696,7 +699,7 @@ define_config! {\n     }\n }\n \n-#[derive(Deserialize)]\n+#[derive(Debug, Deserialize)]\n #[serde(untagged)]\n enum StringOrBool {\n     String(String),\n@@ -822,6 +825,29 @@ impl Config {\n     }\n \n     pub fn parse(args: &[String]) -> Config {\n+        #[cfg(test)]\n+        let get_toml = |_: &_| TomlConfig::default();\n+        #[cfg(not(test))]\n+        let get_toml = |file: &Path| {\n+            let contents =\n+                t!(fs::read_to_string(file), format!(\"config file {} not found\", file.display()));\n+            // Deserialize to Value and then TomlConfig to prevent the Deserialize impl of\n+            // TomlConfig and sub types to be monomorphized 5x by toml.\n+            match toml::from_str(&contents)\n+                .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n+            {\n+                Ok(table) => table,\n+                Err(err) => {\n+                    eprintln!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n+                    crate::detail_exit(2);\n+                }\n+            }\n+        };\n+\n+        Self::parse_inner(args, get_toml)\n+    }\n+\n+    fn parse_inner<'a>(args: &[String], get_toml: impl 'a + Fn(&Path) -> TomlConfig) -> Config {\n         let flags = Flags::parse(&args);\n         let mut config = Config::default_opts();\n \n@@ -907,25 +933,6 @@ impl Config {\n \n         config.stage0_metadata = t!(serde_json::from_slice::<Stage0Metadata>(&stage0_json));\n \n-        #[cfg(test)]\n-        let get_toml = |_| TomlConfig::default();\n-        #[cfg(not(test))]\n-        let get_toml = |file: &Path| {\n-            let contents =\n-                t!(fs::read_to_string(file), format!(\"config file {} not found\", file.display()));\n-            // Deserialize to Value and then TomlConfig to prevent the Deserialize impl of\n-            // TomlConfig and sub types to be monomorphized 5x by toml.\n-            match toml::from_str(&contents)\n-                .and_then(|table: toml::Value| TomlConfig::deserialize(table))\n-            {\n-                Ok(table) => table,\n-                Err(err) => {\n-                    eprintln!(\"failed to parse TOML configuration '{}': {}\", file.display(), err);\n-                    crate::detail_exit(2);\n-                }\n-            }\n-        };\n-\n         // Read from `--config`, then `RUST_BOOTSTRAP_CONFIG`, then `./config.toml`, then `config.toml` in the root directory.\n         let toml_path = flags\n             .config\n@@ -1063,6 +1070,79 @@ impl Config {\n         let mut optimize = None;\n         let mut ignore_git = None;\n \n+        if let Some(rust) = toml.rust {\n+            debug = rust.debug;\n+            debug_assertions = rust.debug_assertions;\n+            debug_assertions_std = rust.debug_assertions_std;\n+            overflow_checks = rust.overflow_checks;\n+            overflow_checks_std = rust.overflow_checks_std;\n+            debug_logging = rust.debug_logging;\n+            debuginfo_level = rust.debuginfo_level;\n+            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n+            debuginfo_level_std = rust.debuginfo_level_std;\n+            debuginfo_level_tools = rust.debuginfo_level_tools;\n+            debuginfo_level_tests = rust.debuginfo_level_tests;\n+            config.rust_split_debuginfo = rust\n+                .split_debuginfo\n+                .as_deref()\n+                .map(SplitDebuginfo::from_str)\n+                .map(|v| v.expect(\"invalid value for rust.split_debuginfo\"))\n+                .unwrap_or(SplitDebuginfo::default_for_platform(&config.build.triple));\n+            optimize = rust.optimize;\n+            ignore_git = rust.ignore_git;\n+            config.rust_new_symbol_mangling = rust.new_symbol_mangling;\n+            set(&mut config.rust_optimize_tests, rust.optimize_tests);\n+            set(&mut config.codegen_tests, rust.codegen_tests);\n+            set(&mut config.rust_rpath, rust.rpath);\n+            set(&mut config.jemalloc, rust.jemalloc);\n+            set(&mut config.test_compare_mode, rust.test_compare_mode);\n+            set(&mut config.backtrace, rust.backtrace);\n+            set(&mut config.channel, rust.channel);\n+            config.description = rust.description;\n+            set(&mut config.rust_dist_src, rust.dist_src);\n+            set(&mut config.verbose_tests, rust.verbose_tests);\n+            // in the case \"false\" is set explicitly, do not overwrite the command line args\n+            if let Some(true) = rust.incremental {\n+                config.incremental = true;\n+            }\n+            set(&mut config.use_lld, rust.use_lld);\n+            set(&mut config.lld_enabled, rust.lld);\n+            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n+            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n+            config.rustc_default_linker = rust.default_linker;\n+            config.musl_root = rust.musl_root.map(PathBuf::from);\n+            config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n+            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n+            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n+            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n+            config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n+            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n+            set(&mut config.control_flow_guard, rust.control_flow_guard);\n+            config.llvm_libunwind_default = rust\n+                .llvm_libunwind\n+                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n+\n+            if let Some(ref backends) = rust.codegen_backends {\n+                config.rust_codegen_backends =\n+                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n+            }\n+\n+            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n+            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n+            config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n+            config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n+            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n+\n+            config.rust_lto = rust\n+                .lto\n+                .as_deref()\n+                .map(|value| RustcLto::from_str(value).unwrap())\n+                .unwrap_or_default();\n+        } else {\n+            config.rust_profile_use = flags.rust_profile_use;\n+            config.rust_profile_generate = flags.rust_profile_generate;\n+        }\n+\n         if let Some(llvm) = toml.llvm {\n             match llvm.ccache {\n                 Some(StringOrBool::String(ref s)) => config.ccache = Some(s.to_string()),\n@@ -1099,13 +1179,17 @@ impl Config {\n             config.llvm_polly = llvm.polly.unwrap_or(false);\n             config.llvm_clang = llvm.clang.unwrap_or(false);\n             config.llvm_build_config = llvm.build_config.clone().unwrap_or(Default::default());\n+\n+            let asserts = llvm_assertions.unwrap_or(false);\n             config.llvm_from_ci = match llvm.download_ci_llvm {\n                 Some(StringOrBool::String(s)) => {\n                     assert!(s == \"if-available\", \"unknown option `{}` for download-ci-llvm\", s);\n-                    crate::native::is_ci_llvm_available(&config, llvm_assertions.unwrap_or(false))\n+                    crate::native::is_ci_llvm_available(&config, asserts)\n                 }\n                 Some(StringOrBool::Bool(b)) => b,\n-                None => false,\n+                None => {\n+                    config.channel == \"dev\" && crate::native::is_ci_llvm_available(&config, asserts)\n+                }\n             };\n \n             if config.llvm_from_ci {\n@@ -1145,79 +1229,9 @@ impl Config {\n                 // the link step) with each stage.\n                 config.llvm_link_shared.set(Some(true));\n             }\n-        }\n-\n-        if let Some(rust) = toml.rust {\n-            debug = rust.debug;\n-            debug_assertions = rust.debug_assertions;\n-            debug_assertions_std = rust.debug_assertions_std;\n-            overflow_checks = rust.overflow_checks;\n-            overflow_checks_std = rust.overflow_checks_std;\n-            debug_logging = rust.debug_logging;\n-            debuginfo_level = rust.debuginfo_level;\n-            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n-            debuginfo_level_std = rust.debuginfo_level_std;\n-            debuginfo_level_tools = rust.debuginfo_level_tools;\n-            debuginfo_level_tests = rust.debuginfo_level_tests;\n-            config.rust_split_debuginfo = rust\n-                .split_debuginfo\n-                .as_deref()\n-                .map(SplitDebuginfo::from_str)\n-                .map(|v| v.expect(\"invalid value for rust.split_debuginfo\"))\n-                .unwrap_or(SplitDebuginfo::default_for_platform(&config.build.triple));\n-            optimize = rust.optimize;\n-            ignore_git = rust.ignore_git;\n-            config.rust_new_symbol_mangling = rust.new_symbol_mangling;\n-            set(&mut config.rust_optimize_tests, rust.optimize_tests);\n-            set(&mut config.codegen_tests, rust.codegen_tests);\n-            set(&mut config.rust_rpath, rust.rpath);\n-            set(&mut config.jemalloc, rust.jemalloc);\n-            set(&mut config.test_compare_mode, rust.test_compare_mode);\n-            set(&mut config.backtrace, rust.backtrace);\n-            set(&mut config.channel, rust.channel);\n-            config.description = rust.description;\n-            set(&mut config.rust_dist_src, rust.dist_src);\n-            set(&mut config.verbose_tests, rust.verbose_tests);\n-            // in the case \"false\" is set explicitly, do not overwrite the command line args\n-            if let Some(true) = rust.incremental {\n-                config.incremental = true;\n-            }\n-            set(&mut config.use_lld, rust.use_lld);\n-            set(&mut config.lld_enabled, rust.lld);\n-            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n-            config.rustc_parallel = rust.parallel_compiler.unwrap_or(false);\n-            config.rustc_default_linker = rust.default_linker;\n-            config.musl_root = rust.musl_root.map(PathBuf::from);\n-            config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n-            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n-            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n-            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n-            config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;\n-            set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n-            set(&mut config.control_flow_guard, rust.control_flow_guard);\n-            config.llvm_libunwind_default = rust\n-                .llvm_libunwind\n-                .map(|v| v.parse().expect(\"failed to parse rust.llvm-libunwind\"));\n-\n-            if let Some(ref backends) = rust.codegen_backends {\n-                config.rust_codegen_backends =\n-                    backends.iter().map(|s| INTERNER.intern_str(s)).collect();\n-            }\n-\n-            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n-            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n-            config.rust_profile_use = flags.rust_profile_use.or(rust.profile_use);\n-            config.rust_profile_generate = flags.rust_profile_generate.or(rust.profile_generate);\n-            config.download_rustc_commit = config.download_ci_rustc_commit(rust.download_rustc);\n-\n-            config.rust_lto = rust\n-                .lto\n-                .as_deref()\n-                .map(|value| RustcLto::from_str(value).unwrap())\n-                .unwrap_or_default();\n         } else {\n-            config.rust_profile_use = flags.rust_profile_use;\n-            config.rust_profile_generate = flags.rust_profile_generate;\n+            config.llvm_from_ci =\n+                config.channel == \"dev\" && crate::native::is_ci_llvm_available(&config, false);\n         }\n \n         if let Some(t) = toml.target {"}, {"sha": "c30c9131745c81e2f41cf8277852685ac1df579c", "filename": "src/bootstrap/config/tests.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,24 @@\n+use super::{Config, TomlConfig};\n+use std::path::Path;\n+\n+fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n+    |&_| toml::from_str(config).unwrap()\n+}\n+\n+fn parse(config: &str) -> Config {\n+    Config::parse_inner(&[\"check\".to_owned(), \"--config=/does/not/exist\".to_owned()], toml(config))\n+}\n+\n+#[test]\n+fn download_ci_llvm() {\n+    let parse_llvm = |s| parse(s).llvm_from_ci;\n+    let if_available = parse_llvm(\"llvm.download-ci-llvm = \\\"if-available\\\"\");\n+\n+    assert!(parse_llvm(\"llvm.download-ci-llvm = true\"));\n+    assert!(!parse_llvm(\"llvm.download-ci-llvm = false\"));\n+    assert_eq!(parse_llvm(\"\"), if_available);\n+    assert_eq!(parse_llvm(\"rust.channel = \\\"dev\\\"\"), if_available);\n+    assert!(!parse_llvm(\"rust.channel = \\\"stable\\\"\"));\n+}\n+\n+// FIXME: add test for detecting `src` and `out`"}, {"sha": "48ae2fe448de2070ddcfd37b57b99434386b5ba4", "filename": "src/bootstrap/defaults/config.user.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdefaults%2Fconfig.user.toml?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -7,3 +7,7 @@ test-stage = 2\n doc-stage = 2\n # When compiling from source, you usually want all tools.\n extended = true\n+\n+[llvm]\n+# Most users installing from source want to build all parts of the project from source, not just rustc itself.\n+download-ci-llvm = false"}, {"sha": "570fe6484e3db32aa436633f4ebde35d369b57a0", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1639,10 +1639,10 @@ fn chmod(_path: &Path, _perms: u32) {}\n /// If the test is running and code is an error code, it will cause a panic.\n fn detail_exit(code: i32) -> ! {\n     // if in test and code is an error code, panic with status code provided\n-    if cfg!(test) && code != 0 {\n+    if cfg!(test) {\n         panic!(\"status code: {}\", code);\n     } else {\n-        //otherwise,exit with provided status code\n+        // otherwise,exit with provided status code\n         std::process::exit(code);\n     }\n }"}, {"sha": "9bbf9e28fffe2bdec384da186e4f2b1eec2f417b", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -14,6 +14,9 @@ This feature allows for use of one of following sanitizers:\n   forward-edge control flow protection.\n * [HWAddressSanitizer](#hwaddresssanitizer) a memory error detector similar to\n   AddressSanitizer, but based on partial hardware assistance.\n+* [KernelControlFlowIntegrity](#kernelcontrolflowintegrity) LLVM Kernel Control\n+  Flow Integrity (KCFI) provides forward-edge control flow protection for\n+  operating systems kernels.\n * [LeakSanitizer](#leaksanitizer) a run-time memory leak detector.\n * [MemorySanitizer](#memorysanitizer) a detector of uninitialized reads.\n * [MemTagSanitizer](#memtagsanitizer) fast memory error detector based on\n@@ -502,6 +505,32 @@ Registers where the failure occurred (pc 0xaaaae0ae4a98):\n SUMMARY: HWAddressSanitizer: tag-mismatch (/.../main+0x54a94)\n ```\n \n+# KernelControlFlowIntegrity\n+\n+The LLVM Kernel Control Flow Integrity (CFI) support to the Rust compiler\n+initially provides forward-edge control flow protection for operating systems\n+kernels for Rust-compiled code only by aggregating function pointers in groups\n+identified by their return and parameter types. (See [LLVM commit cff5bef \"KCFI\n+sanitizer\"](https://github.com/llvm/llvm-project/commit/cff5bef948c91e4919de8a5fb9765e0edc13f3de).)\n+\n+Forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed\n+binaries\" (i.e., for when C or C++ and Rust -compiled code share the same\n+virtual address space) will be provided in later work by defining and using\n+compatible type identifiers (see Type metadata in the design document in the\n+tracking issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n+\n+LLVM KCFI can be enabled with `-Zsanitizer=kcfi`.\n+\n+LLVM KCFI is supported on the following targets:\n+\n+* `aarch64-linux-android`\n+* `aarch64-unknown-linux-gnu`\n+* `x86_64-linux-android`\n+* `x86_64-unknown-linux-gnu`\n+\n+See the [Clang KernelControlFlowIntegrity documentation][clang-kcfi] for more\n+details.\n+\n # LeakSanitizer\n \n LeakSanitizer is run-time memory leak detector.\n@@ -693,6 +722,7 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n [clang-asan]: https://clang.llvm.org/docs/AddressSanitizer.html\n [clang-cfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html\n [clang-hwasan]: https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html\n+[clang-kcfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html#fsanitize-kcfi\n [clang-lsan]: https://clang.llvm.org/docs/LeakSanitizer.html\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html\n [clang-scs]: https://clang.llvm.org/docs/ShadowCallStack.html"}, {"sha": "c2eb852aec3c7662c1a7e1a3f92d23ecb3229631", "filename": "src/test/codegen/sanitizer-kcfi-add-kcfi-flag.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-add-kcfi-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-add-kcfi-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-add-kcfi-flag.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,11 @@\n+// Verifies that \"kcfi\" module flag is added.\n+//\n+// needs-sanitizer-kcfi\n+// compile-flags: -Ctarget-feature=-crt-static -Zsanitizer=kcfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo() {\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 4, !\"kcfi\", i32 1}"}, {"sha": "0afd9727517edf4c4e74930b08c9e87425250938", "filename": "src/test/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,47 @@\n+// Verifies that KCFI type metadata for functions are emitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // FIXME(rcvalle): Change <unknown kind #36> to !kcfi_type when Rust is updated to LLVM 16\n+    // CHECK-SAME: {{.*}}!<unknown kind #36> ![[TYPE1:[0-9]+]]\n+    // CHECK: call i32 %f(i32 %arg){{.*}}[ \"kcfi\"(i32 -1666898348) ]\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // FIXME(rcvalle): Change <unknown kind #36> to !kcfi_type when Rust is updated to LLVM 16\n+    // CHECK-SAME: {{.*}}!<unknown kind #36> ![[TYPE2:[0-9]+]]\n+    // CHECK: call i32 %f(i32 %arg1, i32 %arg2){{.*}}[ \"kcfi\"(i32 -1789026986) ]\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // FIXME(rcvalle): Change <unknown kind #36> to !kcfi_type when Rust is updated to LLVM 16\n+    // CHECK-SAME: {{.*}}!<unknown kind #36> ![[TYPE3:[0-9]+]]\n+    // CHECK: call i32 %f(i32 %arg1, i32 %arg2, i32 %arg3){{.*}}[ \"kcfi\"(i32 1248878270) ]\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i32 653723426}\n+// CHECK: ![[TYPE2]] = !{i32 412174924}\n+// CHECK: ![[TYPE3]] = !{i32 -636668840}"}, {"sha": "4600034952b395df64ffb824ea6a3b252be9beae", "filename": "src/test/ui/invalid/invalid-no-sanitize.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-no-sanitize.stderr?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -4,7 +4,7 @@ error: invalid argument for `no_sanitize`\n LL | #[no_sanitize(brontosaurus)]\n    |               ^^^^^^^^^^^^\n    |\n-   = note: expected one of: `address`, `cfi`, `hwaddress`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n+   = note: expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n \n error: aborting due to previous error\n "}, {"sha": "71ebaea8ed2c185cc296dab497d1e0eb638e96e5", "filename": "src/test/ui/lint/unused/issue-54538-unused-parens-lint.fixed", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.fixed?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(box_patterns, stmt_expr_attributes)]\n+#![feature(box_patterns, stmt_expr_attributes, yeet_expr)]\n \n #![allow(\n     dead_code,\n@@ -25,6 +25,13 @@ fn _no_lint_attr() {\n     let _x = #[allow(dead_code)] (1 + 2);\n }\n \n+fn _no_lint_yeet() -> Result<(), ()> {\n+    #[allow(unreachable_code)]\n+    if (do yeet) {}\n+\n+    Ok(())\n+}\n+\n // Don't lint in these cases (#64106).\n fn or_patterns_no_lint() {\n     match Box::new(0) {"}, {"sha": "28b662dd0242c8715c7ba5e8e22d34426f8537a4", "filename": "src/test/ui/lint/unused/issue-54538-unused-parens-lint.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(box_patterns, stmt_expr_attributes)]\n+#![feature(box_patterns, stmt_expr_attributes, yeet_expr)]\n \n #![allow(\n     dead_code,\n@@ -25,6 +25,13 @@ fn _no_lint_attr() {\n     let _x = #[allow(dead_code)] (1 + 2);\n }\n \n+fn _no_lint_yeet() -> Result<(), ()> {\n+    #[allow(unreachable_code)]\n+    if (do yeet) {}\n+\n+    Ok(())\n+}\n+\n // Don't lint in these cases (#64106).\n fn or_patterns_no_lint() {\n     match Box::new(0) {"}, {"sha": "a5e69e6d9385cc9db896856f81550bd1ce9cbf9c", "filename": "src/test/ui/lint/unused/issue-54538-unused-parens-lint.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-54538-unused-parens-lint.stderr?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -76,7 +76,7 @@ LL +     let _ = |a: u8| 0;\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:49:12\n+  --> $DIR/issue-54538-unused-parens-lint.rs:56:12\n    |\n LL |     if let (0 | 1) = 0 {}\n    |            ^     ^\n@@ -88,7 +88,7 @@ LL +     if let 0 | 1 = 0 {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:50:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:57:13\n    |\n LL |     if let ((0 | 1),) = (0,) {}\n    |             ^     ^\n@@ -100,7 +100,7 @@ LL +     if let (0 | 1,) = (0,) {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:51:13\n+  --> $DIR/issue-54538-unused-parens-lint.rs:58:13\n    |\n LL |     if let [(0 | 1)] = [0] {}\n    |             ^     ^\n@@ -112,7 +112,7 @@ LL +     if let [0 | 1] = [0] {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:52:16\n+  --> $DIR/issue-54538-unused-parens-lint.rs:59:16\n    |\n LL |     if let 0 | (1 | 2) = 0 {}\n    |                ^     ^\n@@ -124,7 +124,7 @@ LL +     if let 0 | 1 | 2 = 0 {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:54:15\n+  --> $DIR/issue-54538-unused-parens-lint.rs:61:15\n    |\n LL |     if let TS((0 | 1)) = TS(0) {}\n    |               ^     ^\n@@ -136,7 +136,7 @@ LL +     if let TS(0 | 1) = TS(0) {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:56:20\n+  --> $DIR/issue-54538-unused-parens-lint.rs:63:20\n    |\n LL |     if let NS { f: (0 | 1) } = (NS { f: 0 }) {}\n    |                    ^     ^\n@@ -148,7 +148,7 @@ LL +     if let NS { f: 0 | 1 } = (NS { f: 0 }) {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:66:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:73:9\n    |\n LL |         (_) => {}\n    |         ^ ^\n@@ -160,7 +160,7 @@ LL +         _ => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:67:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:74:9\n    |\n LL |         (y) => {}\n    |         ^ ^\n@@ -172,7 +172,7 @@ LL +         y => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:68:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:75:9\n    |\n LL |         (ref r) => {}\n    |         ^     ^\n@@ -184,7 +184,7 @@ LL +         ref r => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:69:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:76:9\n    |\n LL |         (e @ 1...2) => {}\n    |         ^         ^\n@@ -196,7 +196,7 @@ LL +         e @ 1...2 => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:75:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:82:9\n    |\n LL |         (e @ &(1...2)) => {}\n    |         ^            ^\n@@ -208,7 +208,7 @@ LL +         e @ &(1...2) => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:76:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:83:10\n    |\n LL |         &(_) => {}\n    |          ^ ^\n@@ -220,7 +220,7 @@ LL +         &_ => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:87:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:94:9\n    |\n LL |         (_) => {}\n    |         ^ ^\n@@ -232,7 +232,7 @@ LL +         _ => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:88:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:95:9\n    |\n LL |         (y) => {}\n    |         ^ ^\n@@ -244,7 +244,7 @@ LL +         y => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:89:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:96:9\n    |\n LL |         (ref r) => {}\n    |         ^     ^\n@@ -256,7 +256,7 @@ LL +         ref r => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:90:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:97:9\n    |\n LL |         (e @ 1..=2) => {}\n    |         ^         ^\n@@ -268,7 +268,7 @@ LL +         e @ 1..=2 => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:96:9\n+  --> $DIR/issue-54538-unused-parens-lint.rs:103:9\n    |\n LL |         (e @ &(1..=2)) => {}\n    |         ^            ^\n@@ -280,7 +280,7 @@ LL +         e @ &(1..=2) => {}\n    |\n \n error: unnecessary parentheses around pattern\n-  --> $DIR/issue-54538-unused-parens-lint.rs:97:10\n+  --> $DIR/issue-54538-unused-parens-lint.rs:104:10\n    |\n LL |         &(_) => {}\n    |          ^ ^"}, {"sha": "3491ad5afbc1501100d192a234e567a7f892bf47", "filename": "src/test/ui/print_type_sizes/async.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Z print-type-sizes\n+// edition:2021\n+// build-pass\n+// ignore-pass\n+\n+#![feature(start)]\n+\n+async fn wait() {}\n+\n+async fn test(arg: [u8; 8192]) {\n+    wait().await;\n+    drop(arg);\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    let _ = test([0; 8192]);\n+    0\n+}"}, {"sha": "94ad09ef296d3b15b713c3e5dc68adf8596671eb", "filename": "src/test/ui/print_type_sizes/async.stdout", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,34 @@\n+print-type-size type: `[async fn body@$DIR/async.rs:10:32: 13:2]`: 16386 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Suspend0`: 16385 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         field `.arg`: 8192 bytes\n+print-type-size         field `.__awaitee`: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 8192 bytes\n+print-type-size type: `std::mem::MaybeUninit<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 8192 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 8192 bytes\n+print-type-size type: `[async fn body@$DIR/async.rs:8:17: 8:19]`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n+print-type-size     variant `Returned`: 0 bytes\n+print-type-size     variant `Panicked`: 0 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n+print-type-size     field `.value`: 1 bytes\n+print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `MaybeUninit`: 1 bytes\n+print-type-size         field `.uninit`: 0 bytes\n+print-type-size         field `.value`: 1 bytes\n+print-type-size type: `std::task::Poll<()>`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Ready`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Pending`: 0 bytes"}, {"sha": "a46db6121046b999834f4ab76759263a687accc4", "filename": "src/test/ui/print_type_sizes/generator.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Z print-type-sizes\n+// build-pass\n+// ignore-pass\n+\n+#![feature(start, generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn generator<const C: usize>(array: [u8; C]) -> impl Generator<Yield = (), Return = ()> {\n+    move |()| {\n+        yield ();\n+        let _ = array;\n+    }\n+}\n+\n+#[start]\n+fn start(_: isize, _: *const *const u8) -> isize {\n+    let _ = generator([0; 8192]);\n+    0\n+}"}, {"sha": "28d4a6e6cff40de7cfa64a1c4cca2655ef26d27d", "filename": "src/test/ui/print_type_sizes/generator.stdout", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -0,0 +1,10 @@\n+print-type-size type: `[generator@$DIR/generator.rs:10:5: 10:14]`: 8193 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Suspend0`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes"}, {"sha": "6c7ea007ee03e4cb6fa00d649597517d10c3c8ad", "filename": "src/test/ui/span/issue-71363.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fspan%2Fissue-71363.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftest%2Fui%2Fspan%2Fissue-71363.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-71363.stderr?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -8,8 +8,6 @@ error[E0277]: `MyError` doesn't implement `std::fmt::Display`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n note: required by a bound in `std::error::Error`\n  --> $SRC_DIR/core/src/error.rs:LL:COL\n-  |\n-  = note: required by this bound in `std::error::Error`\n \n error[E0277]: `MyError` doesn't implement `Debug`\n  --> $DIR/issue-71363.rs:4:6\n@@ -21,8 +19,6 @@ error[E0277]: `MyError` doesn't implement `Debug`\n   = note: add `#[derive(Debug)]` to `MyError` or manually `impl Debug for MyError`\n note: required by a bound in `std::error::Error`\n  --> $SRC_DIR/core/src/error.rs:LL:COL\n-  |\n-  = note: required by this bound in `std::error::Error`\n help: consider annotating `MyError` with `#[derive(Debug)]`\n   |\n 3 | #[derive(Debug)]"}, {"sha": "70898e522116f6c23971e2a554b2dc85fd4c84cd", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -1 +1 @@\n-Subproject commit f6e737b1e3386adb89333bf06a01f68a91ac5306\n+Subproject commit 70898e522116f6c23971e2a554b2dc85fd4c84cd"}, {"sha": "c5767a795382e41a7af9413e8e30adc609b2c3ee", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -906,6 +906,7 @@ pub fn make_test_description<R: Read>(\n     let has_asm_support = config.has_asm_support();\n     let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_cfi = util::CFI_SUPPORTED_TARGETS.contains(&&*config.target);\n+    let has_kcfi = util::KCFI_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n     let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n@@ -957,6 +958,7 @@ pub fn make_test_description<R: Read>(\n             && config.parse_name_directive(ln, \"needs-sanitizer-support\");\n         ignore |= !has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\");\n         ignore |= !has_cfi && config.parse_name_directive(ln, \"needs-sanitizer-cfi\");\n+        ignore |= !has_kcfi && config.parse_name_directive(ln, \"needs-sanitizer-kcfi\");\n         ignore |= !has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\");\n         ignore |= !has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\");\n         ignore |= !has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\");"}, {"sha": "ccba313ee357bf10c387f58cc99a8f5c6e5ceca2", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -42,6 +42,8 @@ pub const CFI_SUPPORTED_TARGETS: &[&str] = &[\n     \"x86_64-unknown-netbsd\",\n ];\n \n+pub const KCFI_SUPPORTED_TARGETS: &[&str] = &[\"aarch64-linux-none\", \"x86_64-linux-none\"];\n+\n pub const LSAN_SUPPORTED_TARGETS: &[&str] = &[\n     // FIXME: currently broken, see #88132\n     // \"aarch64-apple-darwin\","}, {"sha": "7ee8c5d3bad1510fe76e701e8c78671ffbb15a9d", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12b83674f310b85f49ba799e51f9b9f1824870c/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=b12b83674f310b85f49ba799e51f9b9f1824870c", "patch": "@@ -219,6 +219,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"snap\",\n     \"stable_deref_trait\",\n     \"stacker\",\n+    \"static_assertions\",\n     \"syn\",\n     \"synstructure\",\n     \"tempfile\",\n@@ -239,6 +240,7 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"tracing-log\",\n     \"tracing-subscriber\",\n     \"tracing-tree\",\n+    \"twox-hash\",\n     \"type-map\",\n     \"typenum\",\n     \"unic-char-property\","}]}