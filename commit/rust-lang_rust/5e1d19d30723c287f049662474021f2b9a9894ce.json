{"sha": "5e1d19d30723c287f049662474021f2b9a9894ce", "node_id": "C_kwDOAAsO6NoAKDVlMWQxOWQzMDcyM2MyODdmMDQ5NjYyNDc0MDIxZjJiOWE5ODk0Y2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-29T17:48:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-29T17:48:40Z"}, "message": "Auto merge of #95433 - Dylan-DPC:rollup-xdfit9h, r=Dylan-DPC\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #94566 (Show ignore message in console and json output)\n - #95415 (diagnostics: regression test for HashMap iter_mut suggestion)\n - #95422 (Refactor: Use `format-args-capture` and remove an unnecessary nested block)\n - #95424 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "031c4b64139bbee02db55318098b6089aa087c13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/031c4b64139bbee02db55318098b6089aa087c13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e1d19d30723c287f049662474021f2b9a9894ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e1d19d30723c287f049662474021f2b9a9894ce", "html_url": "https://github.com/rust-lang/rust/commit/5e1d19d30723c287f049662474021f2b9a9894ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e1d19d30723c287f049662474021f2b9a9894ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05d22212e89588e7c443cc6b9bc0e4e02fdfbc8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/05d22212e89588e7c443cc6b9bc0e4e02fdfbc8d", "html_url": "https://github.com/rust-lang/rust/commit/05d22212e89588e7c443cc6b9bc0e4e02fdfbc8d"}, {"sha": "7fdde186bcc2d78e2b821413944f7c2446ecaa7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fdde186bcc2d78e2b821413944f7c2446ecaa7c", "html_url": "https://github.com/rust-lang/rust/commit/7fdde186bcc2d78e2b821413944f7c2446ecaa7c"}], "stats": {"total": 128, "additions": 93, "deletions": 35}, "files": [{"sha": "6e551e95cbb437cecff93540e6cd40b24d4e687c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d19d30723c287f049662474021f2b9a9894ce/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d19d30723c287f049662474021f2b9a9894ce/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=5e1d19d30723c287f049662474021f2b9a9894ce", "patch": "@@ -787,7 +787,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                         _,\n                                                         [\n                                                             Expr {\n-                                                                kind: MethodCall(path_segment, ..),\n+                                                                kind:\n+                                                                    MethodCall(\n+                                                                        path_segment,\n+                                                                        _args,\n+                                                                        span,\n+                                                                    ),\n                                                                 hir_id,\n                                                                 ..\n                                                             },\n@@ -831,7 +836,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(mut suggestions) = opt_suggestions {\n                     if suggestions.peek().is_some() {\n                         err.span_suggestions(\n-                            path_segment.ident.span,\n+                            *span,\n                             \"use mutable method\",\n                             suggestions,\n                             Applicability::MaybeIncorrect,"}, {"sha": "9b37985ce49329026dde73a4a15ced77df9d31d3", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d19d30723c287f049662474021f2b9a9894ce/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d19d30723c287f049662474021f2b9a9894ce/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=5e1d19d30723c287f049662474021f2b9a9894ce", "patch": "@@ -299,52 +299,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     IsAssign::No => {\n                         let (message, missing_trait, use_output) = match op.node {\n                             hir::BinOpKind::Add => (\n-                                format!(\"cannot add `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\"),\n                                 Some(\"std::ops::Add\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::Sub => (\n-                                format!(\"cannot subtract `{}` from `{}`\", rhs_ty, lhs_ty),\n+                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\"),\n                                 Some(\"std::ops::Sub\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::Mul => (\n-                                format!(\"cannot multiply `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\"),\n                                 Some(\"std::ops::Mul\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::Div => (\n-                                format!(\"cannot divide `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\"),\n                                 Some(\"std::ops::Div\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::Rem => (\n-                                format!(\"cannot mod `{}` by `{}`\", lhs_ty, rhs_ty),\n+                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\"),\n                                 Some(\"std::ops::Rem\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::BitAnd => (\n-                                format!(\"no implementation for `{} & {}`\", lhs_ty, rhs_ty),\n+                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\"),\n                                 Some(\"std::ops::BitAnd\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::BitXor => (\n-                                format!(\"no implementation for `{} ^ {}`\", lhs_ty, rhs_ty),\n+                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\"),\n                                 Some(\"std::ops::BitXor\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::BitOr => (\n-                                format!(\"no implementation for `{} | {}`\", lhs_ty, rhs_ty),\n+                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\"),\n                                 Some(\"std::ops::BitOr\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::Shl => (\n-                                format!(\"no implementation for `{} << {}`\", lhs_ty, rhs_ty),\n+                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\"),\n                                 Some(\"std::ops::Shl\"),\n                                 true,\n                             ),\n                             hir::BinOpKind::Shr => (\n-                                format!(\"no implementation for `{} >> {}`\", lhs_ty, rhs_ty),\n+                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\"),\n                                 Some(\"std::ops::Shr\"),\n                                 true,\n                             ),\n@@ -477,8 +477,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 // When we know that a missing bound is responsible, we don't show\n                                 // this note as it is redundant.\n                                 err.note(&format!(\n-                                    \"the trait `{}` is not implemented for `{}`\",\n-                                    missing_trait, lhs_ty\n+                                    \"the trait `{missing_trait}` is not implemented for `{lhs_ty}`\"\n                                 ));\n                             }\n                         } else {\n@@ -679,19 +678,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     };\n                     let mut visitor = TypeParamVisitor(vec![]);\n                     visitor.visit_ty(operand_ty);\n-                    if let [ty] = &visitor.0[..] {\n-                        if let ty::Param(p) = *operand_ty.kind() {\n-                            suggest_constraining_param(\n-                                self.tcx,\n-                                self.body_id,\n-                                &mut err,\n-                                *ty,\n-                                operand_ty,\n-                                missing_trait,\n-                                p,\n-                                true,\n-                            );\n-                        }\n+                    if let [ty] = &visitor.0[..] && let ty::Param(p) = *operand_ty.kind() {\n+                        suggest_constraining_param(\n+                            self.tcx,\n+                            self.body_id,\n+                            &mut err,\n+                            *ty,\n+                            operand_ty,\n+                            missing_trait,\n+                            p,\n+                            true,\n+                        );\n                     }\n \n                     let sp = self.tcx.sess.source_map().start_point(ex.span);\n@@ -722,10 +719,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     err.span_suggestion(\n                                         ex.span,\n                                         &format!(\n-                                            \"you may have meant the maximum value of `{}`\",\n-                                            actual\n+                                            \"you may have meant the maximum value of `{actual}`\",\n                                         ),\n-                                        format!(\"{}::MAX\", actual),\n+                                        format!(\"{actual}::MAX\"),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                 }\n@@ -988,7 +984,7 @@ fn suggest_constraining_param(\n     set_output: bool,\n ) {\n     let hir = tcx.hir();\n-    let msg = &format!(\"`{}` might need a bound for `{}`\", lhs_ty, missing_trait);\n+    let msg = &format!(\"`{lhs_ty}` might need a bound for `{missing_trait}`\");\n     // Try to find the def-id and details for the parameter p. We have only the index,\n     // so we have to find the enclosing function's def-id, then look through its declared\n     // generic parameters to get the declaration.\n@@ -1002,13 +998,13 @@ fn suggest_constraining_param(\n         .as_ref()\n         .and_then(|node| node.generics())\n     {\n-        let output = if set_output { format!(\"<Output = {}>\", rhs_ty) } else { String::new() };\n+        let output = if set_output { format!(\"<Output = {rhs_ty}>\") } else { String::new() };\n         suggest_constraining_type_param(\n             tcx,\n             generics,\n             &mut err,\n-            &format!(\"{}\", lhs_ty),\n-            &format!(\"{}{}\", missing_trait, output),\n+            &lhs_ty.to_string(),\n+            &format!(\"{missing_trait}{output}\"),\n             None,\n         );\n     } else {"}, {"sha": "b69bad98888e38eb65ac7ccdf1f289576a7408ea", "filename": "src/test/ui/suggestions/suggest-mut-method-for-loop-hashmap.fixed", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d19d30723c287f049662474021f2b9a9894ce/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d19d30723c287f049662474021f2b9a9894ce/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.fixed?ref=5e1d19d30723c287f049662474021f2b9a9894ce", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+// https://github.com/rust-lang/rust/issues/82081\n+\n+use std::collections::HashMap;\n+\n+struct Test {\n+    v: u32,\n+}\n+\n+fn main() {\n+    let mut map = HashMap::new();\n+    map.insert(\"a\", Test { v: 0 });\n+\n+    for (_k, mut v) in map.iter_mut() {\n+        //~^ HELP use mutable method\n+        //~| NOTE this iterator yields `&` references\n+        v.v += 1;\n+        //~^ ERROR cannot assign to `v.v`\n+        //~| NOTE `v` is a `&` reference\n+    }\n+}"}, {"sha": "9284410dfa383f9c44ee4ef9d7a027ad4cbd4329", "filename": "src/test/ui/suggestions/suggest-mut-method-for-loop-hashmap.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d19d30723c287f049662474021f2b9a9894ce/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d19d30723c287f049662474021f2b9a9894ce/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.rs?ref=5e1d19d30723c287f049662474021f2b9a9894ce", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+// https://github.com/rust-lang/rust/issues/82081\n+\n+use std::collections::HashMap;\n+\n+struct Test {\n+    v: u32,\n+}\n+\n+fn main() {\n+    let mut map = HashMap::new();\n+    map.insert(\"a\", Test { v: 0 });\n+\n+    for (_k, mut v) in map.iter() {\n+        //~^ HELP use mutable method\n+        //~| NOTE this iterator yields `&` references\n+        v.v += 1;\n+        //~^ ERROR cannot assign to `v.v`\n+        //~| NOTE `v` is a `&` reference\n+    }\n+}"}, {"sha": "74433daa6acf234fba783887588ce70aa50def13", "filename": "src/test/ui/suggestions/suggest-mut-method-for-loop-hashmap.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e1d19d30723c287f049662474021f2b9a9894ce/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e1d19d30723c287f049662474021f2b9a9894ce/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-mut-method-for-loop-hashmap.stderr?ref=5e1d19d30723c287f049662474021f2b9a9894ce", "patch": "@@ -0,0 +1,15 @@\n+error[E0594]: cannot assign to `v.v`, which is behind a `&` reference\n+  --> $DIR/suggest-mut-method-for-loop-hashmap.rs:17:9\n+   |\n+LL |     for (_k, mut v) in map.iter() {\n+   |                        ----------\n+   |                        |   |\n+   |                        |   help: use mutable method: `iter_mut()`\n+   |                        this iterator yields `&` references\n+...\n+LL |         v.v += 1;\n+   |         ^^^^^^^^ `v` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "bc08b8eff3f8e4da7c448d7b7f6461938c817a60", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=5e1d19d30723c287f049662474021f2b9a9894ce", "patch": "@@ -1 +1 @@\n-Subproject commit b594f9c441cf12319d10c14ba6a511d5c9db1b87\n+Subproject commit bc08b8eff3f8e4da7c448d7b7f6461938c817a60"}]}