{"sha": "def6393a8b707002aa94ee013cee8d0df1a5f38d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZjYzOTNhOGI3MDcwMDJhYTk0ZWUwMTNjZWU4ZDBkZjFhNWYzOGQ=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-08-19T17:30:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-19T17:30:04Z"}, "message": "Rollup merge of #86123 - Aaron1011:query-span, r=cjgillot\n\nPreserve more spans in internal `rustc_queries!` macro\n\nWe now preserve the span of the various query modifiers, and\nuse the span of the query's name for the commas that we\ngenerate to separate the modifiers. This makes debugging issues with the\ninternal query macro infrastructure much nicer - previously, we\nwould get errors messages pointing at the entire call site\n(the `rustc_queries!` invocation), which isn't very useful.\n\nThis should have no effect when compilation succeeds.\n\nA concrete example of an error message produced after this changed:\n\n```\nerror: local ambiguity: multiple parsing options: built-in NTs tt ('modifiers') or 1 other option.\n    --> /home/aaron/repos/rust/compiler/rustc_middle/src/query/mod.rs:23:11\n     |\n12   | / rustc_queries! {\n13   | |     query trigger_delay_span_bug(key: DefId) -> () {\n14   | |         desc { \"trigger a delay span bug\" }\n15   | |     }\n...    |\n23   | |     query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n     | |           ^^^^^^^^^\n...    |\n1715 | |     }\n1716 | | }\n     | |_- in this expansion of `rustc_query_append!`\n     |\n    ::: compiler/rustc_query_impl/src/lib.rs:51:1\n     |\n51   |   rustc_query_append! { [define_queries!][<'tcx>] }\n     |   ------------------------------------------------- in this macro invocation\n```\n\nThe particular bug shown in this error message will be fixed\nin a separate PR.", "tree": {"sha": "e4fff35be8e6d7637abb9ecb1f9041abdac08200", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4fff35be8e6d7637abb9ecb1f9041abdac08200"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/def6393a8b707002aa94ee013cee8d0df1a5f38d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhHpUdCRBK7hj4Ov3rIwAAOqwIABuDGkCoxjRlUawzwzndK3A/\n1ckC2O9xT89EJi7rGJ/WSixoM5/wt2Ow0Rki9hsbUBt3u7ZNOj1f77ksYcjmXVeG\nrDTLSdftYx6Okty5BhT1hHxcK1DnWS5UfqIHRrsN86OgaePhC80til/3Z2yfZaAm\ntGKQevEtUJSitUhAot1Q+IHCNxFBncU4kGzCLwdskDXiNpW505EfPsnBdAxfSZkH\nh7lubovxLBbUbfMuNaaWNeFenSxdEJ14bb94J1m1/bznHsRydJjKmrGxf3iY5KSp\nYXMpU9LSGTWOQXIGOjb7kByPDI8AaVa71K45q0UneleFizxaa5CH/1isj7UX70Y=\n=43d/\n-----END PGP SIGNATURE-----\n", "payload": "tree e4fff35be8e6d7637abb9ecb1f9041abdac08200\nparent 2451f42c1deb9379d5e8e5fa86b0bf857ae048ec\nparent 34f116101fa5e1f4a3c9597535357fa32db277af\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1629394204 +0200\ncommitter GitHub <noreply@github.com> 1629394204 +0200\n\nRollup merge of #86123 - Aaron1011:query-span, r=cjgillot\n\nPreserve more spans in internal `rustc_queries!` macro\n\nWe now preserve the span of the various query modifiers, and\nuse the span of the query's name for the commas that we\ngenerate to separate the modifiers. This makes debugging issues with the\ninternal query macro infrastructure much nicer - previously, we\nwould get errors messages pointing at the entire call site\n(the `rustc_queries!` invocation), which isn't very useful.\n\nThis should have no effect when compilation succeeds.\n\nA concrete example of an error message produced after this changed:\n\n```\nerror: local ambiguity: multiple parsing options: built-in NTs tt ('modifiers') or 1 other option.\n    --> /home/aaron/repos/rust/compiler/rustc_middle/src/query/mod.rs:23:11\n     |\n12   | / rustc_queries! {\n13   | |     query trigger_delay_span_bug(key: DefId) -> () {\n14   | |         desc { \"trigger a delay span bug\" }\n15   | |     }\n...    |\n23   | |     query hir_crate(key: ()) -> &'tcx Crate<'tcx> {\n     | |           ^^^^^^^^^\n...    |\n1715 | |     }\n1716 | | }\n     | |_- in this expansion of `rustc_query_append!`\n     |\n    ::: compiler/rustc_query_impl/src/lib.rs:51:1\n     |\n51   |   rustc_query_append! { [define_queries!][<'tcx>] }\n     |   ------------------------------------------------- in this macro invocation\n```\n\nThe particular bug shown in this error message will be fixed\nin a separate PR.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/def6393a8b707002aa94ee013cee8d0df1a5f38d", "html_url": "https://github.com/rust-lang/rust/commit/def6393a8b707002aa94ee013cee8d0df1a5f38d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/def6393a8b707002aa94ee013cee8d0df1a5f38d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2451f42c1deb9379d5e8e5fa86b0bf857ae048ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/2451f42c1deb9379d5e8e5fa86b0bf857ae048ec", "html_url": "https://github.com/rust-lang/rust/commit/2451f42c1deb9379d5e8e5fa86b0bf857ae048ec"}, {"sha": "34f116101fa5e1f4a3c9597535357fa32db277af", "url": "https://api.github.com/repos/rust-lang/rust/commits/34f116101fa5e1f4a3c9597535357fa32db277af", "html_url": "https://github.com/rust-lang/rust/commit/34f116101fa5e1f4a3c9597535357fa32db277af"}], "stats": {"total": 104, "additions": 56, "deletions": 48}, "files": [{"sha": "7ad36973f46c7d37493b783869650bb804533e2f", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/def6393a8b707002aa94ee013cee8d0df1a5f38d/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/def6393a8b707002aa94ee013cee8d0df1a5f38d/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=def6393a8b707002aa94ee013cee8d0df1a5f38d", "patch": "@@ -1,6 +1,6 @@\n use proc_macro::TokenStream;\n use proc_macro2::{Delimiter, TokenTree};\n-use quote::quote;\n+use quote::{quote, quote_spanned};\n use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n@@ -42,19 +42,19 @@ enum QueryModifier {\n     LoadCached(Ident, Ident, Block),\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n-    FatalCycle,\n+    FatalCycle(Ident),\n \n     /// A cycle error results in a delay_bug call\n-    CycleDelayBug,\n+    CycleDelayBug(Ident),\n \n     /// Don't hash the result, instead just mark a query red if it runs\n-    NoHash,\n+    NoHash(Ident),\n \n     /// Generate a dep node based on the dependencies of the query\n-    Anon,\n+    Anon(Ident),\n \n     /// Always evaluate the query, ignoring its dependencies\n-    EvalAlways,\n+    EvalAlways(Ident),\n }\n \n impl Parse for QueryModifier {\n@@ -111,15 +111,15 @@ impl Parse for QueryModifier {\n             let ty = args.parse()?;\n             Ok(QueryModifier::Storage(ty))\n         } else if modifier == \"fatal_cycle\" {\n-            Ok(QueryModifier::FatalCycle)\n+            Ok(QueryModifier::FatalCycle(modifier))\n         } else if modifier == \"cycle_delay_bug\" {\n-            Ok(QueryModifier::CycleDelayBug)\n+            Ok(QueryModifier::CycleDelayBug(modifier))\n         } else if modifier == \"no_hash\" {\n-            Ok(QueryModifier::NoHash)\n+            Ok(QueryModifier::NoHash(modifier))\n         } else if modifier == \"anon\" {\n-            Ok(QueryModifier::Anon)\n+            Ok(QueryModifier::Anon(modifier))\n         } else if modifier == \"eval_always\" {\n-            Ok(QueryModifier::EvalAlways)\n+            Ok(QueryModifier::EvalAlways(modifier))\n         } else {\n             Err(Error::new(modifier.span(), \"unknown query modifier\"))\n         }\n@@ -203,19 +203,19 @@ struct QueryModifiers {\n     load_cached: Option<(Ident, Ident, Block)>,\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n-    fatal_cycle: bool,\n+    fatal_cycle: Option<Ident>,\n \n     /// A cycle error results in a delay_bug call\n-    cycle_delay_bug: bool,\n+    cycle_delay_bug: Option<Ident>,\n \n     /// Don't hash the result, instead just mark a query red if it runs\n-    no_hash: bool,\n+    no_hash: Option<Ident>,\n \n     /// Generate a dep node based on the dependencies of the query\n-    anon: bool,\n+    anon: Option<Ident>,\n \n     // Always evaluate the query, ignoring its dependencies\n-    eval_always: bool,\n+    eval_always: Option<Ident>,\n }\n \n /// Process query modifiers into a struct, erroring on duplicates\n@@ -224,11 +224,11 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut storage = None;\n     let mut cache = None;\n     let mut desc = None;\n-    let mut fatal_cycle = false;\n-    let mut cycle_delay_bug = false;\n-    let mut no_hash = false;\n-    let mut anon = false;\n-    let mut eval_always = false;\n+    let mut fatal_cycle = None;\n+    let mut cycle_delay_bug = None;\n+    let mut no_hash = None;\n+    let mut anon = None;\n+    let mut eval_always = None;\n     for modifier in query.modifiers.0.drain(..) {\n         match modifier {\n             QueryModifier::LoadCached(tcx, id, block) => {\n@@ -289,35 +289,35 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 desc = Some((tcx, list));\n             }\n-            QueryModifier::FatalCycle => {\n-                if fatal_cycle {\n+            QueryModifier::FatalCycle(ident) => {\n+                if fatal_cycle.is_some() {\n                     panic!(\"duplicate modifier `fatal_cycle` for query `{}`\", query.name);\n                 }\n-                fatal_cycle = true;\n+                fatal_cycle = Some(ident);\n             }\n-            QueryModifier::CycleDelayBug => {\n-                if cycle_delay_bug {\n+            QueryModifier::CycleDelayBug(ident) => {\n+                if cycle_delay_bug.is_some() {\n                     panic!(\"duplicate modifier `cycle_delay_bug` for query `{}`\", query.name);\n                 }\n-                cycle_delay_bug = true;\n+                cycle_delay_bug = Some(ident);\n             }\n-            QueryModifier::NoHash => {\n-                if no_hash {\n+            QueryModifier::NoHash(ident) => {\n+                if no_hash.is_some() {\n                     panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n                 }\n-                no_hash = true;\n+                no_hash = Some(ident);\n             }\n-            QueryModifier::Anon => {\n-                if anon {\n+            QueryModifier::Anon(ident) => {\n+                if anon.is_some() {\n                     panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n                 }\n-                anon = true;\n+                anon = Some(ident);\n             }\n-            QueryModifier::EvalAlways => {\n-                if eval_always {\n+            QueryModifier::EvalAlways(ident) => {\n+                if eval_always.is_some() {\n                     panic!(\"duplicate modifier `eval_always` for query `{}`\", query.name);\n                 }\n-                eval_always = true;\n+                eval_always = Some(ident);\n             }\n         }\n     }\n@@ -454,31 +454,39 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         let mut attributes = Vec::new();\n \n         // Pass on the fatal_cycle modifier\n-        if modifiers.fatal_cycle {\n-            attributes.push(quote! { fatal_cycle });\n+        if let Some(fatal_cycle) = &modifiers.fatal_cycle {\n+            attributes.push(quote! { #fatal_cycle });\n         };\n         // Pass on the storage modifier\n         if let Some(ref ty) = modifiers.storage {\n-            attributes.push(quote! { storage(#ty) });\n+            let span = ty.span();\n+            attributes.push(quote_spanned! {span=> storage(#ty) });\n         };\n         // Pass on the cycle_delay_bug modifier\n-        if modifiers.cycle_delay_bug {\n-            attributes.push(quote! { cycle_delay_bug });\n+        if let Some(cycle_delay_bug) = &modifiers.cycle_delay_bug {\n+            attributes.push(quote! { #cycle_delay_bug });\n         };\n         // Pass on the no_hash modifier\n-        if modifiers.no_hash {\n-            attributes.push(quote! { no_hash });\n+        if let Some(no_hash) = &modifiers.no_hash {\n+            attributes.push(quote! { #no_hash });\n         };\n         // Pass on the anon modifier\n-        if modifiers.anon {\n-            attributes.push(quote! { anon });\n+        if let Some(anon) = &modifiers.anon {\n+            attributes.push(quote! { #anon });\n         };\n         // Pass on the eval_always modifier\n-        if modifiers.eval_always {\n-            attributes.push(quote! { eval_always });\n+        if let Some(eval_always) = &modifiers.eval_always {\n+            attributes.push(quote! { #eval_always });\n         };\n \n-        let attribute_stream = quote! {#(#attributes),*};\n+        // This uses the span of the query definition for the commas,\n+        // which can be important if we later encounter any ambiguity\n+        // errors with any of the numerous macro_rules! macros that\n+        // we use. Using the call-site span would result in a span pointing\n+        // at the entire `rustc_queries!` invocation, which wouldn't\n+        // be very useful.\n+        let span = name.span();\n+        let attribute_stream = quote_spanned! {span=> #(#attributes),*};\n         let doc_comments = query.doc_comments.iter();\n         // Add the query to the group\n         query_stream.extend(quote! {"}]}