{"sha": "5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYmVjNDRmZDkwNjZiM2Q0ZTI3ZGM2ZDA0NWQ0ZmY0ODQ4YWU4MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T12:16:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T12:16:48Z"}, "message": "Auto merge of #5198 - sinkuu:redundant_clone_df, r=flip1995\n\nredundant_clone: Migrate to new dataflow framework\n\nMigration to [the new dataflow framework](https://github.com/rust-lang/rust/pull/65672) is ongoing in rustc. This PR updates the dataflow impl in `redundant_clone` lint.\n\n---\n\nchangelog: none", "tree": {"sha": "9620ee738c140c07685a1e9cc8d23f2191e165b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9620ee738c140c07685a1e9cc8d23f2191e165b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e", "html_url": "https://github.com/rust-lang/rust/commit/5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06f0ab03ef63869eb159cf7d57d5d5e826ff10ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/06f0ab03ef63869eb159cf7d57d5d5e826ff10ca", "html_url": "https://github.com/rust-lang/rust/commit/06f0ab03ef63869eb159cf7d57d5d5e826ff10ca"}, {"sha": "9d254545f386552e27033f9e395cfb21fcd0f569", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d254545f386552e27033f9e395cfb21fcd0f569", "html_url": "https://github.com/rust-lang/rust/commit/9d254545f386552e27033f9e395cfb21fcd0f569"}], "stats": {"total": 89, "additions": 40, "deletions": 49}, "files": [{"sha": "e419ae09a3f96edbf698db9b7cbef8bebe006c66", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=5fbec44fd9066b3d4e27dc6d045d4ff4848ae82e", "patch": "@@ -15,9 +15,8 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{def_id, Body, FnDecl, HirId};\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_mir::dataflow::{\n-    do_dataflow, BitDenotation, BottomValue, DataflowResults, DataflowResultsCursor, DebugFormatted, GenKillSet,\n-};\n+use rustc_mir::dataflow::generic::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n+use rustc_mir::dataflow::BottomValue;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n use std::convert::TryFrom;\n@@ -83,16 +82,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         let mir = cx.tcx.optimized_mir(def_id);\n         let mir_read_only = mir.unwrap_read_only();\n \n-        let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n-        let maybe_storage_live_result = do_dataflow(\n-            cx.tcx,\n-            mir,\n-            def_id,\n-            &[],\n-            &dead_unwinds,\n-            MaybeStorageLive::new(mir),\n-            |bd, p| DebugFormatted::new(&bd.body.local_decls[p]),\n-        );\n+        let maybe_storage_live_result = MaybeStorageLive\n+            .into_engine(cx.tcx, mir, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(mir);\n         let mut possible_borrower = {\n             let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n             vis.visit_body(mir_read_only);\n@@ -377,55 +370,53 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n \n /// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n #[derive(Copy, Clone)]\n-struct MaybeStorageLive<'a, 'tcx> {\n-    body: &'a mir::Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx> MaybeStorageLive<'a, 'tcx> {\n-    fn new(body: &'a mir::Body<'tcx>) -> Self {\n-        MaybeStorageLive { body }\n-    }\n-}\n+struct MaybeStorageLive;\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n     type Idx = mir::Local;\n-    fn name() -> &'static str {\n-        \"maybe_storage_live\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+    const NAME: &'static str = \"maybe_storage_live\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, on_entry: &mut BitSet<mir::Local>) {\n-        for arg in self.body.args_iter() {\n-            on_entry.insert(arg);\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        for arg in body.args_iter() {\n+            state.insert(arg);\n         }\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<mir::Local>, loc: mir::Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n-\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n         match stmt.kind {\n             mir::StatementKind::StorageLive(l) => trans.gen(l),\n             mir::StatementKind::StorageDead(l) => trans.kill(l),\n             _ => (),\n         }\n     }\n \n-    fn terminator_effect(&self, _trans: &mut GenKillSet<mir::Local>, _loc: mir::Location) {}\n+    fn terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _loc: mir::Location,\n+    ) {\n+    }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        _in_out: &mut BitSet<mir::Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        _dest_place: &mir::Place<'tcx>,\n+        _in_out: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _return_place: &mir::Place<'tcx>,\n     ) {\n         // Nothing to do when a call returns successfully\n     }\n }\n \n-impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+impl BottomValue for MaybeStorageLive {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n@@ -451,8 +442,8 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n     fn into_map(\n         self,\n         cx: &LateContext<'a, 'tcx>,\n-        maybe_live: DataflowResults<'tcx, MaybeStorageLive<'a, 'tcx>>,\n-    ) -> PossibleBorrower<'a, 'tcx> {\n+        maybe_live: ResultsCursor<'tcx, 'tcx, MaybeStorageLive>,\n+    ) -> PossibleBorrowerMap<'a, 'tcx> {\n         let mut map = FxHashMap::default();\n         for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n             if is_copy(cx, self.body.local_decls[row].ty) {\n@@ -475,9 +466,9 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n         }\n \n         let bs = BitSet::new_empty(self.body.local_decls.len());\n-        PossibleBorrower {\n+        PossibleBorrowerMap {\n             map,\n-            maybe_live: DataflowResultsCursor::new(maybe_live, self.body),\n+            maybe_live,\n             bitset: (bs.clone(), bs),\n         }\n     }\n@@ -557,18 +548,18 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n }\n \n /// Result of `PossibleBorrowerVisitor`.\n-struct PossibleBorrower<'a, 'tcx> {\n+struct PossibleBorrowerMap<'a, 'tcx> {\n     /// Mapping `Local -> its possible borrowers`\n     map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    maybe_live: DataflowResultsCursor<'a, 'tcx, MaybeStorageLive<'a, 'tcx>>,\n+    maybe_live: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n     // Caches to avoid allocation of `BitSet` on every query\n     bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n }\n \n-impl PossibleBorrower<'_, '_> {\n+impl PossibleBorrowerMap<'_, '_> {\n     /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n     fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek(at);\n+        self.maybe_live.seek_after(at);\n \n         self.bitset.0.clear();\n         let maybe_live = &mut self.maybe_live;"}]}