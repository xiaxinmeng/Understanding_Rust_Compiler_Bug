{"sha": "c39af6e79b135ed0462b5cb11eb530cbd07facad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOWFmNmU3OWIxMzVlZDA0NjJiNWNiMTFlYjUzMGNiZDA3ZmFjYWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T19:11:39Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T19:11:39Z"}, "message": "rustc_codegen_ssa: remove some unnecessary Box special-casing.", "tree": {"sha": "63d216a62662daaa557febd059219c190c0651a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63d216a62662daaa557febd059219c190c0651a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c39af6e79b135ed0462b5cb11eb530cbd07facad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c39af6e79b135ed0462b5cb11eb530cbd07facad", "html_url": "https://github.com/rust-lang/rust/commit/c39af6e79b135ed0462b5cb11eb530cbd07facad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c39af6e79b135ed0462b5cb11eb530cbd07facad/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "437ca55f23b7ed0051334a7e38ecabd83a173b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/437ca55f23b7ed0051334a7e38ecabd83a173b53", "html_url": "https://github.com/rust-lang/rust/commit/437ca55f23b7ed0051334a7e38ecabd83a173b53"}], "stats": {"total": 46, "additions": 19, "deletions": 27}, "files": [{"sha": "5f2d17f28c258d66da4d296b9f8916591c092ff6", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c39af6e79b135ed0462b5cb11eb530cbd07facad/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c39af6e79b135ed0462b5cb11eb530cbd07facad/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=c39af6e79b135ed0462b5cb11eb530cbd07facad", "patch": "@@ -168,12 +168,6 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n-        }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n@@ -196,6 +190,8 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            // FIXME(eddyb) move these out of this `match` arm, so they're always\n+            // applied, uniformly, no matter the source/destination types.\n             (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n              bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n         }\n@@ -212,31 +208,27 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n-    let mut coerce_ptr = || {\n-        let (base, info) = match bx.load_operand(src).val {\n-            OperandValue::Pair(base, info) => {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                // So we need to pointercast the base to ensure\n-                // the types match up.\n-                let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n-                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n-            }\n-            OperandValue::Immediate(base) => {\n-                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n-            }\n-            OperandValue::Ref(..) => bug!()\n-        };\n-        OperandValue::Pair(base, info).store(bx, dst);\n-    };\n     match (&src_ty.kind, &dst_ty.kind) {\n         (&ty::Ref(..), &ty::Ref(..)) |\n         (&ty::Ref(..), &ty::RawPtr(..)) |\n         (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n-            coerce_ptr()\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            coerce_ptr()\n+            let (base, info) = match bx.load_operand(src).val {\n+                OperandValue::Pair(base, info) => {\n+                    // fat-ptr to fat-ptr unsize preserves the vtable\n+                    // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                    // So we need to pointercast the base to ensure\n+                    // the types match up.\n+                    // FIXME(eddyb) use `scalar_pair_element_backend_type` here,\n+                    // like `unsize_thin_ptr` does.\n+                    let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n+                    (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n+                }\n+                OperandValue::Immediate(base) => {\n+                    unsize_thin_ptr(bx, base, src_ty, dst_ty)\n+                }\n+                OperandValue::Ref(..) => bug!()\n+            };\n+            OperandValue::Pair(base, info).store(bx, dst);\n         }\n \n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {"}]}