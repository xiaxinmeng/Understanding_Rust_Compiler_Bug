{"sha": "8a6396ffa55473bd1ba2555860954633d44798b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNjM5NmZmYTU1NDczYmQxYmEyNTU1ODYwOTU0NjMzZDQ0Nzk4Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-09T12:09:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-09T12:09:15Z"}, "message": "Auto merge of #1405 - RalfJung:stage-0, r=RalfJung\n\nmake Miri work in rustc bootstrap stage 0\n\nFixes https://github.com/rust-lang/rust/issues/52856", "tree": {"sha": "b4d1da859438497871846e109644cd840828e0c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4d1da859438497871846e109644cd840828e0c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a6396ffa55473bd1ba2555860954633d44798b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6396ffa55473bd1ba2555860954633d44798b9", "html_url": "https://github.com/rust-lang/rust/commit/8a6396ffa55473bd1ba2555860954633d44798b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a6396ffa55473bd1ba2555860954633d44798b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eaf05c4ec1172203362637e743bbbf31e6a0be6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eaf05c4ec1172203362637e743bbbf31e6a0be6", "html_url": "https://github.com/rust-lang/rust/commit/4eaf05c4ec1172203362637e743bbbf31e6a0be6"}, {"sha": "e65d87b110dd6890a3bd5b52198a535d8b91d355", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65d87b110dd6890a3bd5b52198a535d8b91d355", "html_url": "https://github.com/rust-lang/rust/commit/e65d87b110dd6890a3bd5b52198a535d8b91d355"}], "stats": {"total": 153, "additions": 97, "deletions": 56}, "files": [{"sha": "057ff5e7ce841d1a338bdbe0ccf73d1be01be7cd", "filename": "README.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a6396ffa55473bd1ba2555860954633d44798b9/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a6396ffa55473bd1ba2555860954633d44798b9/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8a6396ffa55473bd1ba2555860954633d44798b9", "patch": "@@ -222,6 +222,13 @@ Moreover, Miri recognizes some environment variables:\n * `MIRI_TEST_FLAGS` (recognized by the test suite) defines extra flags to be\n   passed to Miri.\n \n+The following environment variables are internal, but used to communicate between\n+different Miri binaries, and as such worth documenting:\n+\n+* `MIRI_BE_RUSTC` when set to any value tells the Miri driver to actually not\n+  interpret the code but compile it like rustc would. This is useful to be sure\n+  that the compiled `rlib`s are compatible with Miri.\n+\n ## Contributing and getting help\n \n If you want to contribute to Miri, great!  Please check out our"}, {"sha": "a1f502ab262fb7807c32e3fd36fef4a73ccb1ef4", "filename": "src/bin/cargo-miri.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8a6396ffa55473bd1ba2555860954633d44798b9/src%2Fbin%2Fcargo-miri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6396ffa55473bd1ba2555860954633d44798b9/src%2Fbin%2Fcargo-miri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-miri.rs?ref=8a6396ffa55473bd1ba2555860954633d44798b9", "patch": "@@ -86,11 +86,15 @@ fn get_arg_flag_value(name: &str) -> Option<String> {\n     }\n }\n \n-/// Returns a command for the right `miri` binary.\n-fn miri() -> Command {\n+/// Returns the path to the `miri` binary\n+fn find_miri() -> PathBuf {\n     let mut path = std::env::current_exe().expect(\"current executable path invalid\");\n     path.set_file_name(\"miri\");\n-    Command::new(path)\n+    path\n+}\n+\n+fn miri() -> Command {\n+    Command::new(find_miri())\n }\n \n fn cargo() -> Command {\n@@ -322,7 +326,8 @@ fn setup(subcommand: MiriCommand) {\n         show_error(format!(\"Given Rust source directory `{}` does not exist.\", rust_src.display()));\n     }\n \n-    // Next, we need our own libstd. We will do this work in whatever is a good cache dir for this platform.\n+    // Next, we need our own libstd. Prepare a xargo project for that purpose.\n+    // We will do this work in whatever is a good cache dir for this platform.\n     let dirs = directories::ProjectDirs::from(\"org\", \"rust-lang\", \"miri\").unwrap();\n     let dir = dirs.cache_dir();\n     if !dir.exists() {\n@@ -360,20 +365,31 @@ path = \"lib.rs\"\n         )\n         .unwrap();\n     File::create(dir.join(\"lib.rs\")).unwrap();\n-    // Prepare xargo invocation.\n+\n+    // Determine architectures.\n+    // We always need to set a target so rustc bootstrap can tell apart host from target crates.\n+    let host = rustc_version::version_meta().unwrap().host;\n     let target = get_arg_flag_value(\"--target\");\n-    let print_sysroot = subcommand == MiriCommand::Setup\n-        && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n+    let target = target.as_ref().unwrap_or(&host);\n+    // Now invoke xargo.\n     let mut command = xargo_check();\n     command.arg(\"build\").arg(\"-q\");\n+    command.arg(\"--target\").arg(target);\n     command.current_dir(&dir);\n-    command.env(\"RUSTFLAGS\", miri::miri_default_args().join(\" \"));\n     command.env(\"XARGO_HOME\", &dir);\n     command.env(\"XARGO_RUST_SRC\", &rust_src);\n-    // Handle target flag.\n-    if let Some(target) = &target {\n-        command.arg(\"--target\").arg(target);\n+    // Use Miri as rustc to build a libstd compatible with us (and use the right flags).\n+    // However, when we are running in bootstrap, we cannot just overwrite `RUSTC`,\n+    // because we still need bootstrap to distinguish between host and target crates.\n+    // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n+    // for target crates.\n+    if env::var_os(\"RUSTC_STAGE\").is_some() {\n+        command.env(\"RUSTC_REAL\", find_miri());\n+    } else {\n+        command.env(\"RUSTC\", find_miri());\n     }\n+    command.env(\"MIRI_BE_RUSTC\", \"1\");\n+    command.env(\"RUSTFLAGS\", miri::miri_default_args().join(\" \"));\n     // Finally run it!\n     if command.status().expect(\"failed to run xargo\").success().not() {\n         show_error(format!(\"Failed to run xargo\"));\n@@ -382,12 +398,11 @@ path = \"lib.rs\"\n     // That should be it! But we need to figure out where xargo built stuff.\n     // Unfortunately, it puts things into a different directory when the\n     // architecture matches the host.\n-    let is_host = match &target {\n-        None => true,\n-        Some(target) => target == &rustc_version::version_meta().unwrap().host,\n-    };\n-    let sysroot = if is_host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n+    let sysroot = if target == &host { dir.join(\"HOST\") } else { PathBuf::from(dir) };\n     std::env::set_var(\"MIRI_SYSROOT\", &sysroot); // pass the env var to the processes we spawn, which will turn it into \"--sysroot\" flags\n+    // Figure out what to print.\n+    let print_sysroot = subcommand == MiriCommand::Setup\n+        && has_arg_flag(\"--print-sysroot\"); // whether we just print the sysroot path\n     if print_sysroot {\n         // Print just the sysroot and nothing else; this way we do not need any escaping.\n         println!(\"{}\", sysroot.display());\n@@ -476,7 +491,7 @@ fn in_cargo_miri() {\n \n         // Set `RUSTC_WRAPPER` to ourselves.  Cargo will prepend that binary to its usual invocation,\n         // i.e., the first argument is `rustc` -- which is what we use in `main` to distinguish\n-        // the two codepaths.\n+        // the two codepaths. (That extra argument is why we prefer this over setting `RUSTC`.)\n         let path = std::env::current_exe().expect(\"current executable path invalid\");\n         cmd.env(\"RUSTC_WRAPPER\", path);\n         if verbose {"}, {"sha": "c9391cec66f0fe6dfadd31a50b94880bebefbdb6", "filename": "src/bin/miri.rs", "status": "modified", "additions": 58, "deletions": 39, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8a6396ffa55473bd1ba2555860954633d44798b9/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6396ffa55473bd1ba2555860954633d44798b9/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=8a6396ffa55473bd1ba2555860954633d44798b9", "patch": "@@ -16,7 +16,6 @@ use log::debug;\n use rustc_session::CtfeBacktrace;\n use rustc_driver::Compilation;\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_interface::{interface, Queries};\n use rustc_middle::ty::TyCtxt;\n \n struct MiriCompilerCalls {\n@@ -26,8 +25,8 @@ struct MiriCompilerCalls {\n impl rustc_driver::Callbacks for MiriCompilerCalls {\n     fn after_analysis<'tcx>(\n         &mut self,\n-        compiler: &interface::Compiler,\n-        queries: &'tcx Queries<'tcx>,\n+        compiler: &rustc_interface::interface::Compiler,\n+        queries: &'tcx rustc_interface::Queries<'tcx>,\n     ) -> Compilation {\n         compiler.session().abort_if_errors();\n \n@@ -106,12 +105,12 @@ fn init_late_loggers(tcx: TyCtxt<'_>) {\n fn compile_time_sysroot() -> Option<String> {\n     if option_env!(\"RUSTC_STAGE\").is_some() {\n         // This is being built as part of rustc, and gets shipped with rustup.\n-        // We can rely on the sysroot computation in librustc.\n+        // We can rely on the sysroot computation in librustc_session.\n         return None;\n     }\n     // For builds outside rustc, we need to ensure that we got a sysroot\n-    // that gets used as a default.  The sysroot computation in librustc would\n-    // end up somewhere in the build dir.\n+    // that gets used as a default.  The sysroot computation in librustc_session would\n+    // end up somewhere in the build dir (see `get_or_default_sysroot`).\n     // Taken from PR <https://github.com/Manishearth/rust-clippy/pull/911>.\n     let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n     let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n@@ -123,7 +122,47 @@ fn compile_time_sysroot() -> Option<String> {\n     })\n }\n \n+/// Execute a compiler with the given CLI arguments and callbacks.\n+fn run_compiler(mut args: Vec<String>, callbacks: &mut (dyn rustc_driver::Callbacks + Send)) {\n+    // Make sure we use the right default sysroot. The default sysroot is wrong,\n+    // because `get_or_default_sysroot` in `librustc_session` bases that on `current_exe`.\n+    //\n+    // Make sure we always call `compile_time_sysroot` as that also does some sanity-checks\n+    // of the environment we were built in.\n+    // FIXME: Ideally we'd turn a bad build env into a compile-time error via CTFE or so.\n+    if let Some(sysroot) = compile_time_sysroot() {\n+        let sysroot_flag = \"--sysroot\";\n+        if !args.iter().any(|e| e == sysroot_flag) {\n+            // We need to overwrite the default that librustc_session would compute.\n+            args.push(sysroot_flag.to_owned());\n+            args.push(sysroot);\n+        }\n+    }\n+\n+    // Invoke compiler, and handle return code.\n+    let result = rustc_driver::catch_fatal_errors(move || {\n+        rustc_driver::run_compiler(&args, callbacks, None, None)\n+    })\n+    .and_then(|result| result);\n+    let exit_code = match result {\n+        Ok(()) => rustc_driver::EXIT_SUCCESS,\n+        Err(_) => rustc_driver::EXIT_FAILURE,\n+    };\n+    std::process::exit(exit_code);\n+}\n+\n fn main() {\n+    rustc_driver::install_ice_hook();\n+\n+    // If the environment asks us to actually be rustc, then do that.\n+    if env::var_os(\"MIRI_BE_RUSTC\").is_some() {\n+        rustc_driver::init_rustc_env_logger();\n+        // We cannot use `rustc_driver::main` as we need to adjust the CLI arguments.\n+        let mut callbacks = rustc_driver::TimePassesCallbacks::default();\n+        return run_compiler(env::args().collect(), &mut callbacks);\n+    }\n+\n+    // Init loggers the Miri way.\n     init_early_loggers();\n \n     // Parse our arguments and split them across `rustc` and `miri`.\n@@ -136,16 +175,20 @@ fn main() {\n     let mut tracked_pointer_tag: Option<miri::PtrId> = None;\n     let mut tracked_alloc_id: Option<miri::AllocId> = None;\n     let mut rustc_args = vec![];\n-    let mut miri_args = vec![];\n+    let mut crate_args = vec![];\n     let mut after_dashdash = false;\n     let mut excluded_env_vars = vec![];\n-    for arg in std::env::args() {\n+    for arg in env::args() {\n         if rustc_args.is_empty() {\n-            // Very first arg: for `rustc`.\n+            // Very first arg: binary name.\n             rustc_args.push(arg);\n+            // After this, push Miri default args (before everything else so they can be overwritten).\n+            for arg in miri::miri_default_args().iter() {\n+                rustc_args.push(arg.to_string());\n+            }\n         } else if after_dashdash {\n-            // Everything that comes after are `miri` args.\n-            miri_args.push(arg);\n+            // Everything that comes after `--` is forwarded to the interpreted crate.\n+            crate_args.push(arg);\n         } else {\n             match arg.as_str() {\n                 \"-Zmiri-disable-validation\" => {\n@@ -221,30 +264,15 @@ fn main() {\n                     tracked_alloc_id = Some(miri::AllocId(id));\n                 }\n                 _ => {\n+                    // Forward to rustc.\n                     rustc_args.push(arg);\n                 }\n             }\n         }\n     }\n \n-    // Determine sysroot if needed.  Make sure we always call `compile_time_sysroot`\n-    // as that also does some sanity-checks of the environment we were built in.\n-    // FIXME: Ideally we'd turn a bad build env into a compile-time error, but\n-    // CTFE does not seem powerful enough for that yet.\n-    if let Some(sysroot) = compile_time_sysroot() {\n-        let sysroot_flag = \"--sysroot\";\n-        if !rustc_args.iter().any(|e| e == sysroot_flag) {\n-            // We need to overwrite the default that librustc would compute.\n-            rustc_args.push(sysroot_flag.to_owned());\n-            rustc_args.push(sysroot);\n-        }\n-    }\n-\n-    // Finally, add the default flags all the way in the beginning, but after the binary name.\n-    rustc_args.splice(1..1, miri::miri_default_args().iter().map(ToString::to_string));\n-\n     debug!(\"rustc arguments: {:?}\", rustc_args);\n-    debug!(\"miri arguments: {:?}\", miri_args);\n+    debug!(\"crate arguments: {:?}\", crate_args);\n     let miri_config = miri::MiriConfig {\n         validate,\n         stacked_borrows,\n@@ -253,18 +281,9 @@ fn main() {\n         ignore_leaks,\n         excluded_env_vars,\n         seed,\n-        args: miri_args,\n+        args: crate_args,\n         tracked_pointer_tag,\n         tracked_alloc_id,\n     };\n-    rustc_driver::install_ice_hook();\n-    let result = rustc_driver::catch_fatal_errors(move || {\n-        rustc_driver::run_compiler(&rustc_args, &mut MiriCompilerCalls { miri_config }, None, None)\n-    })\n-    .and_then(|result| result);\n-    let exit_code = match result {\n-        Ok(()) => rustc_driver::EXIT_SUCCESS,\n-        Err(_) => rustc_driver::EXIT_FAILURE,\n-    };\n-    std::process::exit(exit_code);\n+    return run_compiler(rustc_args, &mut MiriCompilerCalls { miri_config });\n }"}]}