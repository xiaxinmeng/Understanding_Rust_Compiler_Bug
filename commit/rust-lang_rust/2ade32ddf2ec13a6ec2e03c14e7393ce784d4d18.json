{"sha": "2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZGUzMmRkZjJlYzEzYTZlYzJlMDNjMTRlNzM5M2NlNzg0ZDRkMTg=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-04T15:16:43Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:00Z"}, "message": "move string_extend_chars and clone_on_ref_ptr to their own module", "tree": {"sha": "1d08e05dbc470c941525769d541da64f43b6c031", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d08e05dbc470c941525769d541da64f43b6c031"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "html_url": "https://github.com/rust-lang/rust/commit/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5d809a660240d5c826989839bd5eaab63fbb312", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5d809a660240d5c826989839bd5eaab63fbb312", "html_url": "https://github.com/rust-lang/rust/commit/b5d809a660240d5c826989839bd5eaab63fbb312"}], "stats": {"total": 150, "additions": 82, "deletions": 68}, "files": [{"sha": "3d5a68d69d7d2d9bbc510c70131bfbb215f4eba4", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "patch": "@@ -0,0 +1,36 @@\n+use crate::utils::{is_type_diagnostic_item, match_type, paths, snippet_with_macro_callsite, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::CLONE_ON_REF_PTR;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+\n+    if let ty::Adt(_, subst) = obj_ty.kind() {\n+        let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n+            \"Rc\"\n+        } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n+            \"Arc\"\n+        } else if match_type(cx, obj_ty, &paths::WEAK_RC) || match_type(cx, obj_ty, &paths::WEAK_ARC) {\n+            \"Weak\"\n+        } else {\n+            return;\n+        };\n+\n+        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+\n+        span_lint_and_sugg(\n+            cx,\n+            CLONE_ON_REF_PTR,\n+            expr.span,\n+            \"using `.clone()` on a ref-counted pointer\",\n+            \"try this\",\n+            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n+            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n+        );\n+    }\n+}"}, {"sha": "480f32a4340847ba9bbef242626d65eaf18dc2fa", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 4, "deletions": 68, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "patch": "@@ -1,5 +1,6 @@\n mod bind_instead_of_map;\n mod bytes_nth;\n+mod clone_on_ref_ptr;\n mod expect_used;\n mod filetype_is_file;\n mod filter_map_identity;\n@@ -20,6 +21,7 @@ mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_unwrap_or;\n mod skip_while_next;\n+mod string_extend_chars;\n mod suspicious_map;\n mod uninit_assumed_init;\n mod unnecessary_filter_map;\n@@ -1707,7 +1709,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_some\", \"rposition\"] => {\n                 lint_search_is_some(cx, expr, \"rposition\", arg_lists[1], arg_lists[0], method_spans[1])\n             },\n-            [\"extend\", ..] => lint_extend(cx, expr, arg_lists[0]),\n+            [\"extend\", ..] => string_extend_chars::check(cx, expr, arg_lists[0]),\n             [\"count\", \"into_iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"into_iter\"),\n             [\"count\", \"iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"iter\"),\n             [\"count\", \"iter_mut\"] => iter_count::check(cx, expr, &arg_lists[1], \"iter_mut\"),\n@@ -1767,7 +1769,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.ident.name == sym::clone {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n-                    lint_clone_on_ref_ptr(cx, expr, &args[0]);\n+                    clone_on_ref_ptr::check(cx, expr, &args[0]);\n                 }\n                 if args.len() == 1 && method_call.ident.name == sym!(to_string) {\n                     inefficient_to_string::check(cx, expr, &args[0], self_ty);\n@@ -2408,72 +2410,6 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n     }\n }\n \n-fn lint_clone_on_ref_ptr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n-\n-    if let ty::Adt(_, subst) = obj_ty.kind() {\n-        let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n-            \"Rc\"\n-        } else if is_type_diagnostic_item(cx, obj_ty, sym::Arc) {\n-            \"Arc\"\n-        } else if match_type(cx, obj_ty, &paths::WEAK_RC) || match_type(cx, obj_ty, &paths::WEAK_ARC) {\n-            \"Weak\"\n-        } else {\n-            return;\n-        };\n-\n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n-\n-        span_lint_and_sugg(\n-            cx,\n-            CLONE_ON_REF_PTR,\n-            expr.span,\n-            \"using `.clone()` on a ref-counted pointer\",\n-            \"try this\",\n-            format!(\"{}::<{}>::clone(&{})\", caller_type, subst.type_at(0), snippet),\n-            Applicability::Unspecified, // Sometimes unnecessary ::<_> after Rc/Arc/Weak\n-        );\n-    }\n-}\n-\n-fn lint_string_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let arg = &args[1];\n-    if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n-        let target = &arglists[0][0];\n-        let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n-        let ref_str = if *self_ty.kind() == ty::Str {\n-            \"\"\n-        } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n-            \"&\"\n-        } else {\n-            return;\n-        };\n-\n-        let mut applicability = Applicability::MachineApplicable;\n-        span_lint_and_sugg(\n-            cx,\n-            STRING_EXTEND_CHARS,\n-            expr.span,\n-            \"calling `.extend(_.chars())`\",\n-            \"try this\",\n-            format!(\n-                \"{}.push_str({}{})\",\n-                snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n-                ref_str,\n-                snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n-            ),\n-            applicability,\n-        );\n-    }\n-}\n-\n-fn lint_extend(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n-    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n-        lint_string_extend(cx, expr, args);\n-    }\n-}\n-\n fn lint_unnecessary_fold(cx: &LateContext<'_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n     fn check_fold_with_op(\n         cx: &LateContext<'_>,"}, {"sha": "0a08ea26175fe17d7a2589923a4b303ae4abc9e8", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=2ade32ddf2ec13a6ec2e03c14e7393ce784d4d18", "patch": "@@ -0,0 +1,42 @@\n+use crate::utils::{is_type_diagnostic_item, method_chain_args, snippet_with_applicability, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::STRING_EXTEND_CHARS;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n+    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n+        let arg = &args[1];\n+        if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n+            let target = &arglists[0][0];\n+            let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n+            let ref_str = if *self_ty.kind() == ty::Str {\n+                \"\"\n+            } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+                \"&\"\n+            } else {\n+                return;\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                STRING_EXTEND_CHARS,\n+                expr.span,\n+                \"calling `.extend(_.chars())`\",\n+                \"try this\",\n+                format!(\n+                    \"{}.push_str({}{})\",\n+                    snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n+                    ref_str,\n+                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}]}