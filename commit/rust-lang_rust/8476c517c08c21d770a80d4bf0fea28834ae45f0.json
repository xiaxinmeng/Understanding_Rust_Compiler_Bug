{"sha": "8476c517c08c21d770a80d4bf0fea28834ae45f0", "node_id": "C_kwDOAAsO6NoAKDg0NzZjNTE3YzA4YzIxZDc3MGE4MGQ0YmYwZmVhMjg4MzRhZTQ1ZjA", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-12-23T21:23:37Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2023-01-11T22:40:07Z"}, "message": "Don't recommend `if let` if `let else` works", "tree": {"sha": "dba7dc75bf459d24716351c6158e84730f6686ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dba7dc75bf459d24716351c6158e84730f6686ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8476c517c08c21d770a80d4bf0fea28834ae45f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmO/OscACgkQ+boUO5X/\nbYIkbQ//dE5oZ/bwsWkxUOFPfHD5ZMcZxsyP16td178dTYHqlvwucCcPRyJSmTF2\n5+Oz9WQ/ZLDQHETP4+nxQxjd8JJ3cdHKnMmDCtKV1LPAMAejVQSHZpoIcldqBFxl\nORnIULLi5ao/kmYEeckp2G3rdrud+oigjeIOsK9k4aCTpyDo+jxfdsB3BqMgcavv\nb1ptyhFW5VnIuFqlZBu1o8fcQBlFpOzxpcxakcMmPoszOFtp/lDiJmlP42vg/H74\nad+CxkFQ6DwexeFyQJb2WScCdfMH9ToLwQFcF0cDBpeYN3sJQWJ98O1dhjVE4vud\nPVAhAn8t6upaXharr3DuCjOS940sQ1WXW/E0hR5wJEXe7DLnkcTy6/F01lObkKHm\n/HV4dxhLOHeGtD7K66/P1pJ54+N+hVYHL7WQoEjRAsO2WX2UdJsfAsfQblPspD/D\nuB6yQVYTBQPde3NnbVtkArGFRou+UOJ1s1hUEq5dlwF6kzUChusBUk3tur7E1j9C\nr2O5UgD02X6uEWqamJ8dLg3pgB6QaOEFpJ6Q7+lmKrOrLDWJn8VjW8K+eDNv16ui\nVvXFp5G/JwXa9M2qZMNZ8gqqrInviyzlfgxIdtsB3nI+CNBls2xO55Dnz3qsPbdX\nhXwO0C/Yio9bCcV+LE/O+mRq6oi8EIFjGCjN3mSG8QK3DnoSmoA=\n=7Cuz\n-----END PGP SIGNATURE-----", "payload": "tree dba7dc75bf459d24716351c6158e84730f6686ff\nparent 31c20210b9683f983953e1a4e45db94146b3c7cb\nauthor mejrs <> 1671830617 +0100\ncommitter David Tolnay <dtolnay@gmail.com> 1673476807 -0800\n\nDon't recommend `if let` if `let else` works\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8476c517c08c21d770a80d4bf0fea28834ae45f0", "html_url": "https://github.com/rust-lang/rust/commit/8476c517c08c21d770a80d4bf0fea28834ae45f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8476c517c08c21d770a80d4bf0fea28834ae45f0/comments", "author": {}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31c20210b9683f983953e1a4e45db94146b3c7cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/31c20210b9683f983953e1a4e45db94146b3c7cb", "html_url": "https://github.com/rust-lang/rust/commit/31c20210b9683f983953e1a4e45db94146b3c7cb"}], "stats": {"total": 115, "additions": 26, "deletions": 89}, "files": [{"sha": "976614ecd9ebad3fe192b54c3f92967489fccd51", "filename": "compiler/rustc_error_messages/locales/en-US/mir_build.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmir_build.ftl?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -358,7 +358,7 @@ mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count\n         *[other] variants that aren't\n     } matched\n \n-mir_build_suggest_let_else = alternatively, you might want to use `let else` to handle the {$count ->\n+mir_build_suggest_let_else = you might want to use `let else` to handle the {$count ->\n         [one] variant that isn't\n         *[other] variants that aren't\n     } matched"}, {"sha": "1b2fbae2cd5be82a33b4ffd6ade12728d32939d5", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 10, "deletions": 32, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -747,9 +747,7 @@ pub(crate) struct PatternNotCovered<'s, 'tcx> {\n     pub _p: (),\n     pub pattern_ty: Ty<'tcx>,\n     #[subdiagnostic]\n-    pub if_let_suggestion: Option<SuggestIfLet>,\n-    #[subdiagnostic]\n-    pub let_else_suggestion: Option<SuggestLetElse>,\n+    pub let_suggestion: Option<SuggestLet>,\n     #[subdiagnostic]\n     pub res_defined_here: Option<ResDefinedHere>,\n }\n@@ -809,43 +807,23 @@ pub struct InterpretedAsConst {\n }\n \n #[derive(Subdiagnostic)]\n-pub enum SuggestIfLet {\n+pub enum SuggestLet {\n     #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n-    None {\n+    If {\n         #[suggestion_part(code = \"if \")]\n         start_span: Span,\n         #[suggestion_part(code = \" {{ todo!() }}\")]\n         semi_span: Span,\n         count: usize,\n     },\n-    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n-    One {\n-        #[suggestion_part(code = \"let {binding} = if \")]\n-        start_span: Span,\n-        #[suggestion_part(code = \" {{ {binding} }} else {{ todo!() }}\")]\n-        end_span: Span,\n-        binding: Ident,\n-        count: usize,\n-    },\n-    #[multipart_suggestion(mir_build_suggest_if_let, applicability = \"has-placeholders\")]\n-    More {\n-        #[suggestion_part(code = \"let ({bindings}) = if \")]\n-        start_span: Span,\n-        #[suggestion_part(code = \" {{ ({bindings}) }} else {{ todo!() }}\")]\n+    #[suggestion(\n+        mir_build_suggest_let_else,\n+        code = \" else {{ todo!() }}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    Else {\n+        #[primary_span]\n         end_span: Span,\n-        bindings: String,\n         count: usize,\n     },\n }\n-\n-#[derive(Subdiagnostic)]\n-#[suggestion(\n-    mir_build_suggest_let_else,\n-    code = \" else {{ todo!() }}\",\n-    applicability = \"has-placeholders\"\n-)]\n-pub struct SuggestLetElse {\n-    #[primary_span]\n-    pub end_span: Span,\n-    pub count: usize,\n-}"}, {"sha": "69481592895937a5777b00b844b9836f44e38a58", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -394,7 +394,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n \n-        let (inform, interpreted_as_const, res_defined_here, if_let_suggestion, let_else_suggestion) =\n+        let (inform, interpreted_as_const, res_defined_here,let_suggestion) =\n             if let hir::PatKind::Path(hir::QPath::Resolved(\n                 None,\n                 hir::Path {\n@@ -417,7 +417,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                             res,\n                         }\n                     },\n-                    None, None,\n+                    None,\n                 )\n             } else if let Some(span) = sp && self.tcx.sess.source_map().is_span_accessible(span) {\n                 let mut bindings = vec![];\n@@ -430,19 +430,11 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 let start_span = span.shrink_to_lo();\n                 let end_span = semi_span.shrink_to_lo();\n                 let count = witnesses.len();\n-                let if_let = match *bindings {\n-                    [] =>  SuggestIfLet::None{start_span, semi_span, count},\n-                    [binding] => SuggestIfLet::One{start_span, end_span, count, binding },\n-                    _ => SuggestIfLet::More{start_span, end_span, count, bindings: bindings\n-                        .iter()\n-                        .map(|ident| ident.to_string())\n-                        .collect::<Vec<_>>()\n-                        .join(\", \")},\n-                };\n-                let let_else = if bindings.is_empty() {None} else{Some( SuggestLetElse{end_span, count })};\n-                (sp.map(|_|Inform), None, None, Some(if_let), let_else)\n+\n+                let let_suggestion = if bindings.is_empty() {SuggestLet::If{start_span, semi_span, count}} else{ SuggestLet::Else{end_span, count }};\n+                (sp.map(|_|Inform), None, None, Some(let_suggestion))\n             } else{\n-                (sp.map(|_|Inform), None, None,  None, None)\n+                (sp.map(|_|Inform), None, None,  None)\n             };\n \n         let adt_defined_here = try {\n@@ -465,8 +457,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             interpreted_as_const,\n             _p: (),\n             pattern_ty,\n-            if_let_suggestion,\n-            let_else_suggestion,\n+            let_suggestion,\n             res_defined_here,\n             adt_defined_here,\n         });"}, {"sha": "a488e484b2bf8f49825d47d269396ce8bc797b93", "filename": "tests/ui/empty/empty-never-array.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Fempty%2Fempty-never-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty%2Fempty-never-array.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -14,11 +14,7 @@ LL | enum Helper<T, U> {\n LL |     T(T, [!; 0]),\n    |     - not covered\n    = note: the matched value is of type `Helper<T, U>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let u = if let Helper::U(u) = Helper::T(t, []) { u } else { todo!() };\n-   |     ++++++++++                                     ++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Helper::U(u) = Helper::T(t, []) else { todo!() };\n    |                                         ++++++++++++++++"}, {"sha": "4692b66413dff8f24a3bb4b86654ef41e789a0b0", "filename": "tests/ui/error-codes/E0005.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferror-codes%2FE0005.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -7,11 +7,7 @@ LL |     let Some(y) = x;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `Option<i32>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let y = if let Some(y) = x { y } else { todo!() };\n-   |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Some(y) = x else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "49e7ab6082c820b69d988e837fc929f349dd3117", "filename": "tests/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -7,11 +7,7 @@ LL |     let Ok(_x) = foo();\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `Result<u32, !>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let _x = if let Ok(_x) = foo() { _x } else { todo!() };\n-   |     +++++++++++                    +++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(_x) = foo() else { todo!() };\n    |                        ++++++++++++++++"}, {"sha": "5367de5e513c739a42a2f2ea98f30c658565be39", "filename": "tests/ui/pattern/usefulness/issue-31561.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fissue-31561.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -17,11 +17,7 @@ LL |     Bar,\n LL |     Baz\n    |     --- not covered\n    = note: the matched value is of type `Thing`\n-help: you might want to use `if let` to ignore the variants that aren't matched\n-   |\n-LL |     let y = if let Thing::Foo(y) = Thing::Foo(1) { y } else { todo!() };\n-   |     ++++++++++                                   ++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variants that aren't matched\n+help: you might want to use `let else` to handle the variants that aren't matched\n    |\n LL |     let Thing::Foo(y) = Thing::Foo(1) else { todo!() };\n    |                                       ++++++++++++++++"}, {"sha": "769d4070fb587fb56d31f2c2a74f775584bae7a0", "filename": "tests/ui/pattern/usefulness/non-exhaustive-defined-here.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-defined-here.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -183,11 +183,7 @@ LL | enum Opt {\n LL |     None,\n    |     ---- not covered\n    = note: the matched value is of type `Opt`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let _x = if let Opt::Some(ref _x) = e { _x } else { todo!() };\n-   |     +++++++++++                           +++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Opt::Some(ref _x) = e else { todo!() };\n    |                               ++++++++++++++++"}, {"sha": "1b4d80d90571c31ac7b30f341799b060f1db71b1", "filename": "tests/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -7,11 +7,7 @@ LL |     let Ok(x) = res;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `Result<u32, &R<'_>>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let x = if let Ok(x) = res { x } else { todo!() };\n-   |     ++++++++++                 ++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = res else { todo!() };\n    |                     ++++++++++++++++"}, {"sha": "8cafea555c172490dd1c0c9ddb3c7ed5e1549ad0", "filename": "tests/ui/uninhabited/uninhabited-irrefutable.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-irrefutable.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -14,11 +14,7 @@ LL | enum Foo {\n LL |     A(foo::SecretlyEmpty),\n    |     - not covered\n    = note: the matched value is of type `Foo`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let (_y, _z) = if let Foo::D(_y, _z) = x { (_y, _z) } else { todo!() };\n-   |     +++++++++++++++++                        +++++++++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Foo::D(_y, _z) = x else { todo!() };\n    |                            ++++++++++++++++"}, {"sha": "466d7f2eadb92c1fea2fa453567dd943b99188e4", "filename": "tests/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8476c517c08c21d770a80d4bf0fea28834ae45f0/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=8476c517c08c21d770a80d4bf0fea28834ae45f0", "patch": "@@ -104,11 +104,7 @@ LL |     let Ok(x) = x;\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n    = note: the matched value is of type `Result<u32, Void>`\n-help: you might want to use `if let` to ignore the variant that isn't matched\n-   |\n-LL |     let x = if let Ok(x) = x { x } else { todo!() };\n-   |     ++++++++++               ++++++++++++++++++++++\n-help: alternatively, you might want to use `let else` to handle the variant that isn't matched\n+help: you might want to use `let else` to handle the variant that isn't matched\n    |\n LL |     let Ok(x) = x else { todo!() };\n    |                   ++++++++++++++++"}]}