{"sha": "5a3971cdb8694717f56b8c1bc2cd597bb4ac1677", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMzk3MWNkYjg2OTQ3MTdmNTZiOGMxYmMyY2Q1OTdiYjRhYzE2Nzc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-23T10:10:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-25T13:42:56Z"}, "message": "comments and refactor variable names", "tree": {"sha": "37ad5de5f28a0c58b9c46a0ed4c3d0552f262669", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37ad5de5f28a0c58b9c46a0ed4c3d0552f262669"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a3971cdb8694717f56b8c1bc2cd597bb4ac1677", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a3971cdb8694717f56b8c1bc2cd597bb4ac1677", "html_url": "https://github.com/rust-lang/rust/commit/5a3971cdb8694717f56b8c1bc2cd597bb4ac1677", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a3971cdb8694717f56b8c1bc2cd597bb4ac1677/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f18203e85cfa1a140a53938487bbf82917c2e6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f18203e85cfa1a140a53938487bbf82917c2e6b", "html_url": "https://github.com/rust-lang/rust/commit/0f18203e85cfa1a140a53938487bbf82917c2e6b"}], "stats": {"total": 84, "additions": 46, "deletions": 38}, "files": [{"sha": "17dfe8b656c1a9817e5b56d334a58599be456e97", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5a3971cdb8694717f56b8c1bc2cd597bb4ac1677/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3971cdb8694717f56b8c1bc2cd597bb4ac1677/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=5a3971cdb8694717f56b8c1bc2cd597bb4ac1677", "patch": "@@ -580,7 +580,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n-        let (discr_scalar_layout, discr_kind, discr_index) = match rval.layout.variants {\n+        // We use \"discriminant\" to refer to the value associated with a particualr enum variant.\n+        // This is not to be confused with its \"variant index\", which is just determining its position in the\n+        // declared list of variants -- they can differ with explicitly assigned discriminants.\n+        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n+        // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n+        // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n+        // rather confusing.\n+        let (tag_scalar_layout, tag_kind, tag_index) = match rval.layout.variants {\n             Variants::Single { index } => {\n                 let discr = match rval.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     Some(discr) => {\n@@ -602,31 +609,31 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // There are *three* types/layouts that come into play here:\n-        // - The field storing the discriminant has a layout, which my be a pointer.\n-        //   This is `discr_val.layout`; we just use it for sanity checks.\n-        // - The discriminant has a layout for tag storing purposes, which is always an integer.\n-        //   This is `discr_layout` and is used to interpret the value we read from the\n-        //   discriminant field.\n-        // - The discriminant also has a type for typechecking, and that type's\n-        //   layout can be *different*. This is `discr_ty`, and is used for the `Scalar`\n-        //   we return. If necessary, a cast from `discr_layout` is performed.\n+        // - The discriminant has a type for typechecking. This is `discr_ty`, and is used for\n+        //   the `Scalar` we return.\n+        // - The discriminant gets encoded as a tag/niche, with layout `tag_layout`.\n+        //   This is always an integer, and used to interpret the value we read from the\n+        //   tag field. For the return value, a cast to `discr_ty` is performed.\n+        // - The field storing the tag has a layout, which is very similar to\n+        //   `tag_layout` but may be a pointer. This is `tag_val.layout`;\n+        //   we just use it for sanity checks.\n \n         // Get layout for tag.\n-        let discr_layout = self.layout_of(discr_scalar_layout.value.to_int_ty(*self.tcx))?;\n+        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n \n-        // Read discriminant value and sanity-check `discr_layout`.\n-        let discr_val = self.read_immediate(self.operand_field(rval, discr_index)?)?;\n-        assert_eq!(discr_layout.size, discr_val.layout.size);\n-        assert_eq!(discr_layout.abi.is_signed(), discr_val.layout.abi.is_signed());\n-        let discr_val = discr_val.to_scalar()?;\n-        trace!(\"discriminant value: {:?}\", discr_val);\n+        // Read tag and sanity-check `tag_layout`.\n+        let tag_val = self.read_immediate(self.operand_field(rval, tag_index)?)?;\n+        assert_eq!(tag_layout.size, tag_val.layout.size);\n+        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n+        let tag_val = tag_val.to_scalar()?;\n+        trace!(\"tag value: {:?}\", tag_val);\n \n         // Get type used by typechecking.\n         let discr_ty = match rval.layout.ty.kind {\n             ty::Adt(adt, _) => {\n                 let discr_int_ty = Integer::from_attr(self, adt.repr.discr_type());\n                 // The signedness of tag and discriminant is the same.\n-                discr_int_ty.to_ty(*self.tcx, discr_layout.abi.is_signed())\n+                discr_int_ty.to_ty(*self.tcx, tag_layout.abi.is_signed())\n             }\n             ty::Generator(_, substs, _) => {\n                 let substs = substs.as_generator();\n@@ -636,17 +643,17 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // Figure out which discriminant and variant this corresponds to.\n-        Ok(match *discr_kind {\n+        Ok(match *tag_kind {\n             DiscriminantKind::Tag => {\n-                let discr_bits = self\n-                    .force_bits(discr_val, discr_layout.size)\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(discr_val.erase_tag())))?;\n-                // Cast discriminant bits to the right type.\n-                let discr_ty_layout = self.layout_of(discr_ty)?;\n+                let tag_bits = self\n+                    .force_bits(tag_val, tag_layout.size)\n+                    .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                // Cast bits from tag layout to discriminant layout.\n+                let discr_layout = self.layout_of(discr_ty)?;\n                 let discr_val_cast =\n-                    self.cast_from_scalar(discr_bits, discr_layout, discr_ty);\n-                let discr_bits = discr_val_cast.assert_bits(discr_ty_layout.size);\n-                // Find variant index for this tag, and catch invalid discriminants.\n+                    self.cast_from_scalar(tag_bits, tag_layout, discr_ty);\n+                let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n+                // Convert discriminant to variant index, and catch invalid discriminants.\n                 let index = match rval.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n                         adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n@@ -659,36 +666,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(discr_val.erase_tag())))?;\n+                .ok_or_else(|| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n                 // Return the cast value, and the index.\n                 (discr_val_cast, index.0)\n             }\n             DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n-                // Compute the variant this discriminant corresponds to. With niche layout,\n-                // tag and variant index are the same.\n+                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n+                // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let variant = match discr_val.to_bits_or_ptr(discr_layout.size, self) {\n+                let variant = match tag_val.to_bits_or_ptr(tag_layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(discr_val.erase_tag()))\n+                            throw_ub!(InvalidDiscriminant(tag_val.erase_tag()))\n                         }\n                         dataful_variant\n                     }\n-                    Ok(bits_discr) => {\n+                    Ok(tag_bits) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n-                        // variant_index_relative = discr_val - niche_start_val\n-                        let discr_val = ImmTy::from_uint(bits_discr, discr_layout);\n-                        let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                        // variant_index_relative = tag_val - niche_start_val\n+                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, discr_val, niche_start_val)?;\n+                            self.binary_op(mir::BinOp::Sub, tag_val, niche_start_val)?;\n                         let variant_index_relative = variant_index_relative_val\n                             .to_scalar()?\n-                            .assert_bits(discr_val.layout.size);\n+                            .assert_bits(tag_val.layout.size);\n                         // Check if this is in the range that indicates an actual discriminant.\n                         if variant_index_relative <= u128::from(variants_end - variants_start) {\n                             let variant_index_relative = u32::try_from(variant_index_relative)\n@@ -712,7 +719,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 };\n                 // Compute the size of the scalar we need to return.\n-                // FIXME: Why do we not need to do a cast here like we do above?\n+                // No need to cast, because the variant index directly serves as discriminant and is\n+                // encoded in the tag.\n                 let size = self.layout_of(discr_ty)?.size;\n                 (Scalar::from_uint(variant.as_u32(), size), variant)\n             }"}]}