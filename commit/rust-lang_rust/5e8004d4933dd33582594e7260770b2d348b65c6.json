{"sha": "5e8004d4933dd33582594e7260770b2d348b65c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlODAwNGQ0OTMzZGQzMzU4MjU5NGU3MjYwNzcwYjJkMzQ4YjY1YzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-15T21:06:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-15T21:08:47Z"}, "message": "std: Follow conventions in bitv", "tree": {"sha": "156c8b4b5c6d67b3a68babc69b629252cd25a6cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/156c8b4b5c6d67b3a68babc69b629252cd25a6cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8004d4933dd33582594e7260770b2d348b65c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8004d4933dd33582594e7260770b2d348b65c6", "html_url": "https://github.com/rust-lang/rust/commit/5e8004d4933dd33582594e7260770b2d348b65c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8004d4933dd33582594e7260770b2d348b65c6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "844fbd83da4143bae253f3969d7b2cccb258bebc", "url": "https://api.github.com/repos/rust-lang/rust/commits/844fbd83da4143bae253f3969d7b2cccb258bebc", "html_url": "https://github.com/rust-lang/rust/commit/844fbd83da4143bae253f3969d7b2cccb258bebc"}], "stats": {"total": 107, "additions": 56, "deletions": 51}, "files": [{"sha": "4b79bf6c050d8966ac0aae5cb61642edf5b5bc28", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5e8004d4933dd33582594e7260770b2d348b65c6/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8004d4933dd33582594e7260770b2d348b65c6/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=5e8004d4933dd33582594e7260770b2d348b65c6", "patch": "@@ -1,5 +1,4 @@\n-export t;\n-export create;\n+export bitv;\n export union;\n export intersect;\n export assign;\n@@ -23,7 +22,7 @@ export eq_vec;\n //        for the case where nbits <= 32.\n \n #[doc = \"The bitvector type\"]\n-type t = @{storage: [mutable uint], nbits: uint};\n+type bitv = @{storage: [mutable uint], nbits: uint};\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n \n@@ -35,13 +34,13 @@ Constructs a bitvector\n * nbits - The number of bits in the bitvector\n * init - If true then the bits are initialized to 1, otherwise 0\n \"]\n-fn create(nbits: uint, init: bool) -> t {\n+fn bitv(nbits: uint, init: bool) -> bitv {\n     let elt = if init { !0u } else { 0u };\n     let storage = vec::to_mut(vec::from_elem(nbits / uint_bits + 1u, elt));\n     ret @{storage: storage, nbits: nbits};\n }\n \n-fn process(v0: t, v1: t, op: fn(uint, uint) -> uint) -> bool {\n+fn process(v0: bitv, v1: bitv, op: fn(uint, uint) -> uint) -> bool {\n     let len = vec::len(v1.storage);\n     assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n@@ -58,7 +57,9 @@ fn process(v0: t, v1: t, op: fn(uint, uint) -> uint) -> bool {\n \n fn lor(w0: uint, w1: uint) -> uint { ret w0 | w1; }\n \n-fn union(v0: t, v1: t) -> bool { let sub = lor; ret process(v0, v1, sub); }\n+fn union(v0: bitv, v1: bitv) -> bool {\n+    let sub = lor; ret process(v0, v1, sub);\n+}\n \n fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n \n@@ -68,7 +69,7 @@ Calculates the intersection of two bitvectors\n Sets `v0` to the intersection of `v0` and `v1`. Both bitvectors must be the\n same length. Returns 'true' if `v0` was changed.\n \"]\n-fn intersect(v0: t, v1: t) -> bool {\n+fn intersect(v0: bitv, v1: bitv) -> bool {\n     let sub = land;\n     ret process(v0, v1, sub);\n }\n@@ -80,18 +81,20 @@ Assigns the value of `v1` to `v0`\n \n Both bitvectors must be the same length. Returns `true` if `v0` was changed\n \"]\n-fn assign(v0: t, v1: t) -> bool { let sub = right; ret process(v0, v1, sub); }\n+fn assign(v0: bitv, v1: bitv) -> bool {\n+    let sub = right; ret process(v0, v1, sub);\n+}\n \n #[doc = \"Makes a copy of a bitvector\"]\n-fn clone(v: t) -> t {\n+fn clone(v: bitv) -> bitv {\n     let storage = vec::to_mut(vec::from_elem(v.nbits / uint_bits + 1u, 0u));\n     let len = vec::len(v.storage);\n     uint::range(0u, len) {|i| storage[i] = v.storage[i]; };\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n #[doc = \"Retreive the value at index `i`\"]\n-pure fn get(v: t, i: uint) -> bool {\n+pure fn get(v: bitv, i: uint) -> bool {\n     assert (i < v.nbits);\n     let bits = uint_bits;\n     let w = i / bits;\n@@ -108,7 +111,7 @@ Compares two bitvectors\n Both bitvectors must be the same length. Returns `true` if both bitvectors\n contain identical elements.\n \"]\n-fn equal(v0: t, v1: t) -> bool {\n+fn equal(v0: bitv, v1: bitv) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n \n@@ -122,17 +125,17 @@ fn equal(v0: t, v1: t) -> bool {\n }\n \n #[doc = \"Set all bits to 0\"]\n-fn clear(v: t) {\n+fn clear(v: bitv) {\n     uint::range(0u, vec::len(v.storage)) {|i| v.storage[i] = 0u; };\n }\n \n #[doc = \"Set all bits to 1\"]\n-fn set_all(v: t) {\n+fn set_all(v: bitv) {\n     uint::range(0u, v.nbits) {|i| set(v, i, true); };\n }\n \n #[doc = \"Invert all bits\"]\n-fn invert(v: t) {\n+fn invert(v: bitv) {\n     uint::range(0u, vec::len(v.storage)) {|i|\n         v.storage[i] = !v.storage[i];\n     };\n@@ -146,7 +149,7 @@ of `v1` at the same index. Both bitvectors must be the same length.\n \n Returns `true` if `v0` was changed.\n \"]\n-fn difference(v0: t, v1: t) -> bool {\n+fn difference(v0: bitv, v1: bitv) -> bool {\n     invert(v1);\n     let b = intersect(v0, v1);\n     invert(v1);\n@@ -158,7 +161,7 @@ Set the value of a bit at a given index\n \n `i` must be less than the length of the bitvector.\n \"]\n-fn set(v: t, i: uint, x: bool) {\n+fn set(v: bitv, i: uint, x: bool) {\n     assert (i < v.nbits);\n     let bits = uint_bits;\n     let w = i / bits;\n@@ -169,26 +172,28 @@ fn set(v: t, i: uint, x: bool) {\n \n \n #[doc = \"Returns true if all bits are 1\"]\n-fn is_true(v: t) -> bool {\n+fn is_true(v: bitv) -> bool {\n     for i: uint in to_vec(v) { if i != 1u { ret false; } }\n     ret true;\n }\n \n \n #[doc = \"Returns true if all bits are 0\"]\n-fn is_false(v: t) -> bool {\n+fn is_false(v: bitv) -> bool {\n     for i: uint in to_vec(v) { if i == 1u { ret false; } }\n     ret true;\n }\n \n-fn init_to_vec(v: t, i: uint) -> uint { ret if get(v, i) { 1u } else { 0u }; }\n+fn init_to_vec(v: bitv, i: uint) -> uint {\n+    ret if get(v, i) { 1u } else { 0u };\n+}\n \n #[doc = \"\n Converts the bitvector to a vector of uint with the same length.\n \n Each uint in the resulting vector has either value 0u or 1u.\n \"]\n-fn to_vec(v: t) -> [uint] {\n+fn to_vec(v: bitv) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n     ret vec::from_fn::<uint>(v.nbits, sub);\n }\n@@ -200,7 +205,7 @@ Converts the bitvector to a string.\n The resulting string has the same length as the bitvector, and each character\n is either '0' or '1'.\n \"]\n-fn to_str(v: t) -> str {\n+fn to_str(v: bitv) -> str {\n     let mut rs = \"\";\n     for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n@@ -212,7 +217,7 @@ Compare a bitvector to a vector of uint\n The uint vector is expected to only contain the values 0u and 1u. Both the\n bitvector and vector must have the same length\n \"]\n-fn eq_vec(v0: t, v1: [uint]) -> bool {\n+fn eq_vec(v0: bitv, v1: [uint]) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;\n     let mut i = 0u;\n@@ -231,17 +236,17 @@ mod tests {\n     fn test_0_elements() {\n         let act;\n         let exp;\n-        act = create(0u, false);\n+        act = bitv(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n         assert (eq_vec(act, exp));\n     }\n \n     #[test]\n     fn test_1_element() {\n         let act;\n-        act = create(1u, false);\n+        act = bitv(1u, false);\n         assert (eq_vec(act, [0u]));\n-        act = create(1u, true);\n+        act = bitv(1u, true);\n         assert (eq_vec(act, [1u]));\n     }\n \n@@ -250,15 +255,15 @@ mod tests {\n         let act;\n         // all 0\n \n-        act = create(10u, false);\n+        act = bitv(10u, false);\n         assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = create(10u, true);\n+        act = bitv(10u, true);\n         assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(10u, false);\n+        act = bitv(10u, false);\n         set(act, 0u, true);\n         set(act, 1u, true);\n         set(act, 2u, true);\n@@ -267,7 +272,7 @@ mod tests {\n         assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(10u, false);\n+        act = bitv(10u, false);\n         set(act, 5u, true);\n         set(act, 6u, true);\n         set(act, 7u, true);\n@@ -276,7 +281,7 @@ mod tests {\n         assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(10u, false);\n+        act = bitv(10u, false);\n         set(act, 0u, true);\n         set(act, 3u, true);\n         set(act, 6u, true);\n@@ -289,21 +294,21 @@ mod tests {\n         let act;\n         // all 0\n \n-        act = create(31u, false);\n+        act = bitv(31u, false);\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = create(31u, true);\n+        act = bitv(31u, true);\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(31u, false);\n+        act = bitv(31u, false);\n         set(act, 0u, true);\n         set(act, 1u, true);\n         set(act, 2u, true);\n@@ -318,7 +323,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(31u, false);\n+        act = bitv(31u, false);\n         set(act, 16u, true);\n         set(act, 17u, true);\n         set(act, 18u, true);\n@@ -333,7 +338,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(31u, false);\n+        act = bitv(31u, false);\n         set(act, 24u, true);\n         set(act, 25u, true);\n         set(act, 26u, true);\n@@ -347,7 +352,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(31u, false);\n+        act = bitv(31u, false);\n         set(act, 3u, true);\n         set(act, 17u, true);\n         set(act, 30u, true);\n@@ -362,21 +367,21 @@ mod tests {\n         let act;\n         // all 0\n \n-        act = create(32u, false);\n+        act = bitv(32u, false);\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = create(32u, true);\n+        act = bitv(32u, true);\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(32u, false);\n+        act = bitv(32u, false);\n         set(act, 0u, true);\n         set(act, 1u, true);\n         set(act, 2u, true);\n@@ -391,7 +396,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(32u, false);\n+        act = bitv(32u, false);\n         set(act, 16u, true);\n         set(act, 17u, true);\n         set(act, 18u, true);\n@@ -406,7 +411,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(32u, false);\n+        act = bitv(32u, false);\n         set(act, 24u, true);\n         set(act, 25u, true);\n         set(act, 26u, true);\n@@ -421,7 +426,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(32u, false);\n+        act = bitv(32u, false);\n         set(act, 3u, true);\n         set(act, 17u, true);\n         set(act, 30u, true);\n@@ -437,21 +442,21 @@ mod tests {\n         let act;\n         // all 0\n \n-        act = create(33u, false);\n+        act = bitv(33u, false);\n         assert (eq_vec(act,\n                        [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = create(33u, true);\n+        act = bitv(33u, true);\n         assert (eq_vec(act,\n                        [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = create(33u, false);\n+        act = bitv(33u, false);\n         set(act, 0u, true);\n         set(act, 1u, true);\n         set(act, 2u, true);\n@@ -466,7 +471,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(33u, false);\n+        act = bitv(33u, false);\n         set(act, 16u, true);\n         set(act, 17u, true);\n         set(act, 18u, true);\n@@ -481,7 +486,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = create(33u, false);\n+        act = bitv(33u, false);\n         set(act, 24u, true);\n         set(act, 25u, true);\n         set(act, 26u, true);\n@@ -496,7 +501,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n         // mixed\n \n-        act = create(33u, false);\n+        act = bitv(33u, false);\n         set(act, 3u, true);\n         set(act, 17u, true);\n         set(act, 30u, true);"}, {"sha": "e9170033fb7e9e34529dfe28421cbdc3802ece71", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e8004d4933dd33582594e7260770b2d348b65c6/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8004d4933dd33582594e7260770b2d348b65c6/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=5e8004d4933dd33582594e7260770b2d348b65c6", "patch": "@@ -29,12 +29,12 @@ export to_str;\n  have the same length; 11 should never appear in a given position)\n */\n \n-type t = {uncertain: bitv::t, val: bitv::t, nbits: uint};\n+type t = {uncertain: bitv::bitv, val: bitv::bitv, nbits: uint};\n enum trit { ttrue, tfalse, dont_care, }\n \n fn create_tritv(len: uint) -> t {\n-    ret {uncertain: bitv::create(len, true),\n-         val: bitv::create(len, false),\n+    ret {uncertain: bitv::bitv(len, true),\n+         val: bitv::bitv(len, false),\n          nbits: len};\n }\n "}]}