{"sha": "677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3N2I1MTdlNjZmZTlkZjBiMmNlNzJmNWVjNTdkNTJjYzBkYTUwNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T23:39:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T23:39:02Z"}, "message": "Auto merge of #87921 - kellerkindt:master, r=kennytm\n\nAdd Saturating type (based on Wrapping type)\n\nTracking #87920\n\n### Unresolved Questions\n<!--\nInclude any open questions that need to be answered before the feature can be\nstabilised.\n-->\n\n - [x] ~`impl Div for Saturating<T>` falls back on inner integer division - which seems alright?~\n    - [x] add `saturating_div`? (to respect division by `-1`)\n - [x] There is no `::saturating_shl` and `::saturating_shr`. (How to) implement `Shl`, `ShlAssign`, `Shr` and `ShrAssign`?\n   - [naively](3f7d2ce28f8cf4dec56bf65fa2e6da0cf329ec55)\n - [x] ~`saturating_neg` is only implemented on [signed integer types](https://doc.rust-lang.org/std/?search=saturating_n)~\n - [x] Is the implementation copied over from the `Wrapping`-type correct for `Saturating`?\n   - [x] `Saturating::rotate_left`\n   - [x] `Saturating::rotate_right`\n   - [x] `Not`\n   - [x] `BitXorOr` and `BitXorOrAssign`\n   - [x] `BitOr` and `BitOrAssign`\n   - [x] `BitAnd` and `BitAndAssign`\n   - [x] `Saturating::swap_bytes`\n   - [x] `Saturating::reverse_bits`", "tree": {"sha": "5ab3b7e2602c4b47de3587d95405807b9eb8ba1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ab3b7e2602c4b47de3587d95405807b9eb8ba1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "html_url": "https://github.com/rust-lang/rust/commit/677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5eacec9ec7e112a0de1011519a57c45586d58414", "url": "https://api.github.com/repos/rust-lang/rust/commits/5eacec9ec7e112a0de1011519a57c45586d58414", "html_url": "https://github.com/rust-lang/rust/commit/5eacec9ec7e112a0de1011519a57c45586d58414"}, {"sha": "ce636f25e55493f42e7339cb533cb523879b62a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce636f25e55493f42e7339cb533cb523879b62a5", "html_url": "https://github.com/rust-lang/rust/commit/ce636f25e55493f42e7339cb533cb523879b62a5"}], "stats": {"total": 1048, "additions": 1048, "deletions": 0}, "files": [{"sha": "2c866812937e975ba5b4406a46154da5d5c3ca40", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "patch": "@@ -918,6 +918,40 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Saturating integer division. Computes `self / rhs`, saturating at the\n+        /// numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(saturating_div)]\n+        ///\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_div(-1), \", stringify!($SelfT), \"::MIN + 1);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_div(-1), \", stringify!($SelfT), \"::MAX);\")]\n+        ///\n+        /// ```\n+        ///\n+        /// ```should_panic\n+        /// #![feature(saturating_div)]\n+        ///\n+        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".saturating_div(0);\")]\n+        ///\n+        /// ```\n+        #[unstable(feature = \"saturating_div\", issue = \"87920\")]\n+        #[rustc_const_unstable(feature = \"saturating_div\", issue = \"87920\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_div(self, rhs: Self) -> Self {\n+            match self.overflowing_div(rhs) {\n+                (result, false) => result,\n+                (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow\n+            }\n+        }\n+\n         /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///"}, {"sha": "09b7418bec0d9caf781d3946f598f7e8d401cb65", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "patch": "@@ -43,8 +43,12 @@ mod uint_macros; // import uint_impl!\n mod error;\n mod int_log10;\n mod nonzero;\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+mod saturating;\n mod wrapping;\n \n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+pub use saturating::Saturating;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use wrapping::Wrapping;\n "}, {"sha": "f6dd3603c491431cc9b31931d7fdf0a51f73fe0f", "filename": "library/core/src/num/saturating.rs", "status": "added", "additions": 976, "deletions": 0, "changes": 976, "blob_url": "https://github.com/rust-lang/rust/blob/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fsaturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fsaturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fsaturating.rs?ref=677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "patch": "@@ -0,0 +1,976 @@\n+//! Definitions of `Saturating<T>`.\n+\n+use crate::fmt;\n+use crate::ops::{Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign};\n+use crate::ops::{BitXor, BitXorAssign, Div, DivAssign};\n+use crate::ops::{Mul, MulAssign, Neg, Not, Rem, RemAssign};\n+use crate::ops::{Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign};\n+\n+/// Provides intentionally-saturating arithmetic on `T`.\n+///\n+/// Operations like `+` on `u32` values are intended to never overflow,\n+/// and in some debug configurations overflow is detected and results\n+/// in a panic. While most arithmetic falls into this category, some\n+/// code explicitly expects and relies upon saturating arithmetic.\n+///\n+/// Saturating arithmetic can be achieved either through methods like\n+/// `saturating_add`, or through the `Saturating<T>` type, which says that\n+/// all standard arithmetic operations on the underlying value are\n+/// intended to have saturating semantics.\n+///\n+/// The underlying value can be retrieved through the `.0` index of the\n+/// `Saturating` tuple.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(saturating_int_impl)]\n+/// use std::num::Saturating;\n+///\n+/// let max = Saturating(u32::MAX);\n+/// let one = Saturating(1u32);\n+///\n+/// assert_eq!(u32::MAX, (max + one).0);\n+/// ```\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n+#[repr(transparent)]\n+pub struct Saturating<T>(#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] pub T);\n+\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+impl<T: fmt::Debug> fmt::Debug for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+impl<T: fmt::Display> fmt::Display for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+impl<T: fmt::Binary> fmt::Binary for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+impl<T: fmt::Octal> fmt::Octal for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+impl<T: fmt::LowerHex> fmt::LowerHex for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+impl<T: fmt::UpperHex> fmt::UpperHex for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+#[allow(unused_macros)]\n+macro_rules! sh_impl_signed {\n+    ($t:ident, $f:ident) => {\n+        // FIXME what is the correct implementation here? see discussion https://github.com/rust-lang/rust/pull/87921#discussion_r695870065\n+        //\n+        // #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        // impl Shl<$f> for Saturating<$t> {\n+        //     type Output = Saturating<$t>;\n+        //\n+        //     #[inline]\n+        //     fn shl(self, other: $f) -> Saturating<$t> {\n+        //         if other < 0 {\n+        //             Saturating(self.0.shr((-other & self::shift_max::$t as $f) as u32))\n+        //         } else {\n+        //             Saturating(self.0.shl((other & self::shift_max::$t as $f) as u32))\n+        //         }\n+        //     }\n+        // }\n+        // forward_ref_binop! { impl Shl, shl for Saturating<$t>, $f,\n+        // #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+        //\n+        // #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        // impl ShlAssign<$f> for Saturating<$t> {\n+        //     #[inline]\n+        //     fn shl_assign(&mut self, other: $f) {\n+        //         *self = *self << other;\n+        //     }\n+        // }\n+        // forward_ref_op_assign! { impl ShlAssign, shl_assign for Saturating<$t>, $f }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Shr<$f> for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn shr(self, other: $f) -> Saturating<$t> {\n+                if other < 0 {\n+                    Saturating(self.0.shl((-other & self::shift_max::$t as $f) as u32))\n+                } else {\n+                    Saturating(self.0.shr((other & self::shift_max::$t as $f) as u32))\n+                }\n+            }\n+        }\n+        forward_ref_binop! { impl Shr, shr for Saturating<$t>, $f,\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl ShrAssign<$f> for Saturating<$t> {\n+            #[inline]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self = *self >> other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Saturating<$t>, $f }\n+    };\n+}\n+\n+macro_rules! sh_impl_unsigned {\n+    ($t:ident, $f:ident) => {\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Shl<$f> for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn shl(self, other: $f) -> Saturating<$t> {\n+                Saturating(self.0.wrapping_shl(other as u32))\n+            }\n+        }\n+        forward_ref_binop! { impl Shl, shl for Saturating<$t>, $f,\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl ShlAssign<$f> for Saturating<$t> {\n+            #[inline]\n+            fn shl_assign(&mut self, other: $f) {\n+                *self = *self << other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl ShlAssign, shl_assign for Saturating<$t>, $f }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Shr<$f> for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn shr(self, other: $f) -> Saturating<$t> {\n+                Saturating(self.0.wrapping_shr(other as u32))\n+            }\n+        }\n+        forward_ref_binop! { impl Shr, shr for Saturating<$t>, $f,\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl ShrAssign<$f> for Saturating<$t> {\n+            #[inline]\n+            fn shr_assign(&mut self, other: $f) {\n+                *self = *self >> other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl ShrAssign, shr_assign for Saturating<$t>, $f }\n+    };\n+}\n+\n+// FIXME (#23545): uncomment the remaining impls\n+macro_rules! sh_impl_all {\n+    ($($t:ident)*) => ($(\n+        //sh_impl_unsigned! { $t, u8 }\n+        //sh_impl_unsigned! { $t, u16 }\n+        //sh_impl_unsigned! { $t, u32 }\n+        //sh_impl_unsigned! { $t, u64 }\n+        //sh_impl_unsigned! { $t, u128 }\n+        sh_impl_unsigned! { $t, usize }\n+\n+        //sh_impl_signed! { $t, i8 }\n+        //sh_impl_signed! { $t, i16 }\n+        //sh_impl_signed! { $t, i32 }\n+        //sh_impl_signed! { $t, i64 }\n+        //sh_impl_signed! { $t, i128 }\n+        //sh_impl_signed! { $t, isize }\n+    )*)\n+}\n+\n+sh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+// FIXME(30524): impl Op<T> for Saturating<T>, impl OpAssign<T> for Saturating<T>\n+macro_rules! saturating_impl {\n+    ($($t:ty)*) => ($(\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Add for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn add(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_add(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Add, add for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl AddAssign for Saturating<$t> {\n+            #[inline]\n+            fn add_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self + other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Sub for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn sub(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_sub(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Sub, sub for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl SubAssign for Saturating<$t> {\n+            #[inline]\n+            fn sub_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self - other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Mul for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn mul(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_mul(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Mul, mul for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl MulAssign for Saturating<$t> {\n+            #[inline]\n+            fn mul_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self * other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Saturating<$t>, Saturating<$t> }\n+\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(saturating_int_impl, saturating_div)]\n+        /// use std::num::Saturating;\n+        ///\n+        #[doc = concat!(\"assert_eq!(Saturating(2\", stringify!($t), \"), Saturating(5\", stringify!($t), \") / Saturating(2));\")]\n+        #[doc = concat!(\"assert_eq!(Saturating(\", stringify!($t), \"::MAX), Saturating(\", stringify!($t), \"::MAX) / Saturating(1));\")]\n+        #[doc = concat!(\"assert_eq!(Saturating(\", stringify!($t), \"::MIN), Saturating(\", stringify!($t), \"::MIN) / Saturating(1));\")]\n+        /// ```\n+        ///\n+        /// ```should_panic\n+        /// #![feature(saturating_int_impl, saturating_div)]\n+        /// use std::num::Saturating;\n+        ///\n+        #[doc = concat!(\"let _ = Saturating(0\", stringify!($t), \") / Saturating(0);\")]\n+        /// ```\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Div for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn div(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_div(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Div, div for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl DivAssign for Saturating<$t> {\n+            #[inline]\n+            fn div_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self / other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Rem for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn rem(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.rem(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Rem, rem for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl RemAssign for Saturating<$t> {\n+            #[inline]\n+            fn rem_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self % other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl RemAssign, rem_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Not for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn not(self) -> Saturating<$t> {\n+                Saturating(!self.0)\n+            }\n+        }\n+        forward_ref_unop! { impl Not, not for Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl BitXor for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0 ^ other.0)\n+            }\n+        }\n+        forward_ref_binop! { impl BitXor, bitxor for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl BitXorAssign for Saturating<$t> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self ^ other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl BitOr for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0 | other.0)\n+            }\n+        }\n+        forward_ref_binop! { impl BitOr, bitor for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl BitOrAssign for Saturating<$t> {\n+            #[inline]\n+            fn bitor_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self | other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl BitAnd for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0 & other.0)\n+            }\n+        }\n+        forward_ref_binop! { impl BitAnd, bitand for Saturating<$t>, Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl BitAndAssign for Saturating<$t> {\n+            #[inline]\n+            fn bitand_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self & other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Saturating<$t>, Saturating<$t> }\n+\n+    )*)\n+}\n+\n+saturating_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! saturating_int_impl {\n+    ($($t:ty)*) => ($(\n+        impl Saturating<$t> {\n+            /// Returns the smallest value that can be represented by this integer type.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Saturating<\", stringify!($t), \">>::MIN, Saturating(\", stringify!($t), \"::MIN));\")]\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const MIN: Self = Self(<$t>::MIN);\n+\n+            /// Returns the largest value that can be represented by this integer type.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Saturating<\", stringify!($t), \">>::MAX, Saturating(\", stringify!($t), \"::MAX));\")]\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const MAX: Self = Self(<$t>::MAX);\n+\n+            /// Returns the size of this integer type in bits.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Saturating<\", stringify!($t), \">>::BITS, \", stringify!($t), \"::BITS);\")]\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const BITS: u32 = <$t>::BITS;\n+\n+            /// Returns the number of ones in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0b01001100\", stringify!($t), \");\")]\n+            ///\n+            /// assert_eq!(n.count_ones(), 3);\n+            /// ```\n+            #[inline]\n+            #[doc(alias = \"popcount\")]\n+            #[doc(alias = \"popcnt\")]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn count_ones(self) -> u32 {\n+                self.0.count_ones()\n+            }\n+\n+            /// Returns the number of zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(!0\", stringify!($t), \").count_zeros(), 0);\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn count_zeros(self) -> u32 {\n+                self.0.count_zeros()\n+            }\n+\n+            /// Returns the number of trailing zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0b0101000\", stringify!($t), \");\")]\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 3);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                self.0.trailing_zeros()\n+            }\n+\n+            /// Shifts the bits to the left by a specified amount, `n`,\n+            /// saturating the truncated bits to the end of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as the `<<` shifting\n+            /// operator!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n: Saturating<i64> = Saturating(0x0123456789ABCDEF);\n+            /// let m: Saturating<i64> = Saturating(-0x76543210FEDCBA99);\n+            ///\n+            /// assert_eq!(n.rotate_left(32), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn rotate_left(self, n: u32) -> Self {\n+                Saturating(self.0.rotate_left(n))\n+            }\n+\n+            /// Shifts the bits to the right by a specified amount, `n`,\n+            /// saturating the truncated bits to the beginning of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as the `>>` shifting\n+            /// operator!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n: Saturating<i64> = Saturating(0x0123456789ABCDEF);\n+            /// let m: Saturating<i64> = Saturating(-0xFEDCBA987654322);\n+            ///\n+            /// assert_eq!(n.rotate_right(4), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn rotate_right(self, n: u32) -> Self {\n+                Saturating(self.0.rotate_right(n))\n+            }\n+\n+            /// Reverses the byte order of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n: Saturating<i16> = Saturating(0b0000000_01010101);\n+            /// assert_eq!(n, Saturating(85));\n+            ///\n+            /// let m = n.swap_bytes();\n+            ///\n+            /// assert_eq!(m, Saturating(0b01010101_00000000));\n+            /// assert_eq!(m, Saturating(21760));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn swap_bytes(self) -> Self {\n+                Saturating(self.0.swap_bytes())\n+            }\n+\n+            /// Reverses the bit pattern of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Please note that this example is shared between integer types.\n+            /// Which explains why `i16` is used here.\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n = Saturating(0b0000000_01010101i16);\n+            /// assert_eq!(n, Saturating(85));\n+            ///\n+            /// let m = n.reverse_bits();\n+            ///\n+            /// assert_eq!(m.0 as u16, 0b10101010_00000000);\n+            /// assert_eq!(m, Saturating(-22016));\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            #[rustc_const_stable(feature = \"const_reverse_bits\", since = \"1.37.0\")]\n+            #[inline]\n+            #[must_use]\n+            pub const fn reverse_bits(self) -> Self {\n+                Saturating(self.0.reverse_bits())\n+            }\n+\n+            /// Converts an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_be(n), n)\")]\n+            /// } else {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\")]\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn from_be(x: Self) -> Self {\n+                Saturating(<$t>::from_be(x.0))\n+            }\n+\n+            /// Converts an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_le(n), n)\")]\n+            /// } else {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\")]\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn from_le(x: Self) -> Self {\n+                Saturating(<$t>::from_le(x.0))\n+            }\n+\n+            /// Converts `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn to_be(self) -> Self {\n+                Saturating(self.0.to_be())\n+            }\n+\n+            /// Converts `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn to_le(self) -> Self {\n+                Saturating(self.0.to_le())\n+            }\n+\n+            /// Raises self to the power of `exp`, using exponentiation by squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(3\", stringify!($t), \").pow(4), Saturating(81));\")]\n+            /// ```\n+            ///\n+            /// Results that are too large are saturated:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// assert_eq!(Saturating(3i8).pow(5), Saturating(127));\n+            /// assert_eq!(Saturating(3i8).pow(6), Saturating(127));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn pow(self, exp: u32) -> Self {\n+                Saturating(self.0.saturating_pow(exp))\n+            }\n+        }\n+    )*)\n+}\n+\n+saturating_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! saturating_int_impl_signed {\n+    ($($t:ty)*) => ($(\n+        impl Saturating<$t> {\n+            /// Returns the number of leading zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(\", stringify!($t), \"::MAX >> 2);\")]\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 3);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n+            }\n+\n+            /// Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self == MIN`\n+            /// instead of overflowing.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(100\", stringify!($t), \").abs(), Saturating(100));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(-100\", stringify!($t), \").abs(), Saturating(100));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(\", stringify!($t), \"::MIN).abs(), Saturating((\", stringify!($t), \"::MIN + 1).abs()));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(\", stringify!($t), \"::MIN).abs(), Saturating(\", stringify!($t), \"::MIN.saturating_abs()));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(\", stringify!($t), \"::MIN).abs(), Saturating(\", stringify!($t), \"::MAX));\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn abs(self) -> Saturating<$t> {\n+                Saturating(self.0.saturating_abs())\n+            }\n+\n+            /// Returns a number representing sign of `self`.\n+            ///\n+            ///  - `0` if the number is zero\n+            ///  - `1` if the number is positive\n+            ///  - `-1` if the number is negative\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(10\", stringify!($t), \").signum(), Saturating(1));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(0\", stringify!($t), \").signum(), Saturating(0));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(-10\", stringify!($t), \").signum(), Saturating(-1));\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn signum(self) -> Saturating<$t> {\n+                Saturating(self.0.signum())\n+            }\n+\n+            /// Returns `true` if `self` is positive and `false` if the number is zero or\n+            /// negative.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert!(Saturating(10\", stringify!($t), \").is_positive());\")]\n+            #[doc = concat!(\"assert!(!Saturating(-10\", stringify!($t), \").is_positive());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn is_positive(self) -> bool {\n+                self.0.is_positive()\n+            }\n+\n+            /// Returns `true` if `self` is negative and `false` if the number is zero or\n+            /// positive.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert!(Saturating(-10\", stringify!($t), \").is_negative());\")]\n+            #[doc = concat!(\"assert!(!Saturating(10\", stringify!($t), \").is_negative());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn is_negative(self) -> bool {\n+                self.0.is_negative()\n+            }\n+        }\n+\n+        #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+        impl Neg for Saturating<$t> {\n+            type Output = Self;\n+            #[inline]\n+            fn neg(self) -> Self {\n+                Saturating(self.0.saturating_neg())\n+            }\n+        }\n+        forward_ref_unop! { impl Neg, neg for Saturating<$t>,\n+                #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")] }\n+    )*)\n+}\n+\n+saturating_int_impl_signed! { isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! saturating_int_impl_unsigned {\n+    ($($t:ty)*) => ($(\n+        impl Saturating<$t> {\n+            /// Returns the number of leading zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(\", stringify!($t), \"::MAX >> 2);\")]\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 2);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n+            }\n+\n+            /// Returns `true` if and only if `self == 2^k` for some `k`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert!(Saturating(16\", stringify!($t), \").is_power_of_two());\")]\n+            #[doc = concat!(\"assert!(!Saturating(10\", stringify!($t), \").is_power_of_two());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn is_power_of_two(self) -> bool {\n+                self.0.is_power_of_two()\n+            }\n+\n+        }\n+    )*)\n+}\n+\n+saturating_int_impl_unsigned! { usize u8 u16 u32 u64 u128 }\n+\n+// Related to potential Shl and ShlAssign implementation\n+//\n+// mod shift_max {\n+//     #![allow(non_upper_case_globals)]\n+//\n+//     #[cfg(target_pointer_width = \"16\")]\n+//     mod platform {\n+//         pub const usize: u32 = super::u16;\n+//         pub const isize: u32 = super::i16;\n+//     }\n+//\n+//     #[cfg(target_pointer_width = \"32\")]\n+//     mod platform {\n+//         pub const usize: u32 = super::u32;\n+//         pub const isize: u32 = super::i32;\n+//     }\n+//\n+//     #[cfg(target_pointer_width = \"64\")]\n+//     mod platform {\n+//         pub const usize: u32 = super::u64;\n+//         pub const isize: u32 = super::i64;\n+//     }\n+//\n+//     pub const i8: u32 = (1 << 3) - 1;\n+//     pub const i16: u32 = (1 << 4) - 1;\n+//     pub const i32: u32 = (1 << 5) - 1;\n+//     pub const i64: u32 = (1 << 6) - 1;\n+//     pub const i128: u32 = (1 << 7) - 1;\n+//     pub use self::platform::isize;\n+//\n+//     pub const u8: u32 = i8;\n+//     pub const u16: u32 = i16;\n+//     pub const u32: u32 = i32;\n+//     pub const u64: u32 = i64;\n+//     pub const u128: u32 = i128;\n+//     pub use self::platform::usize;\n+// }"}, {"sha": "d6bd3115a0254dc330d6491a0e4d58770bf5bc04", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "patch": "@@ -1041,6 +1041,36 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Saturating integer division. Computes `self / rhs`, saturating at the\n+        /// numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(saturating_div)]\n+        ///\n+        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n+        ///\n+        /// ```\n+        ///\n+        /// ```should_panic\n+        /// #![feature(saturating_div)]\n+        ///\n+        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".saturating_div(0);\")]\n+        ///\n+        /// ```\n+        #[unstable(feature = \"saturating_div\", issue = \"87920\")]\n+        #[rustc_const_unstable(feature = \"saturating_div\", issue = \"87920\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_div(self, rhs: Self) -> Self {\n+            // on unsigned types, there is no overflow in integer division\n+            self.wrapping_div(rhs)\n+        }\n+\n         /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n         /// saturating at the numeric bounds instead of overflowing.\n         ///"}, {"sha": "028a066b5a130e3eebd0e403a0320d04fe27c9e9", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "patch": "@@ -310,6 +310,8 @@\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n+#![feature(saturating_div)]\n+#![feature(saturating_int_impl)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]"}, {"sha": "46064bd2837705eafbc31999ff3b115e38e30f74", "filename": "library/std/src/num.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fstd%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/677b517e66fe9df0b2ce72f5ec57d52cc0da506e/library%2Fstd%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnum.rs?ref=677b517e66fe9df0b2ce72f5ec57d52cc0da506e", "patch": "@@ -12,6 +12,8 @@ mod tests;\n #[cfg(test)]\n mod benches;\n \n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+pub use core::num::Saturating;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}