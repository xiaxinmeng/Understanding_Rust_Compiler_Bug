{"sha": "22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjljZTRkZjY4MmNkNGRkMTIwM2U1YWUzZDhjOTVmNTE0MGUyMDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-04T15:49:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-04T15:49:55Z"}, "message": "auto merge of #8243 : stepancheg/rust/ipv, r=brson\n\nmulticast functions now take IpAddr (without port), because they dont't\r\nneed port.\r\n\r\nUv* types renamed:\r\n* UvIpAddr -> UvSocketAddr\r\n* UvIpv4 -> UvIpv4SocketAddr\r\n* UvIpv6 -> UvIpv6SocketAddr\r\n\r\n\"Socket address\" is a common name for (ip-address, port) pair (e.g. in\r\nsockaddr_in struct).\r\n\r\nP. S. Are there any backward compatibility concerns? What is std::rt module, is it a part of public API?", "tree": {"sha": "049f876da7bc2936c73484b0a95e8e5e3f995ce6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/049f876da7bc2936c73484b0a95e8e5e3f995ce6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "html_url": "https://github.com/rust-lang/rust/commit/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7c4359a2c350521c312bd5dce3ce515878d922a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c4359a2c350521c312bd5dce3ce515878d922a", "html_url": "https://github.com/rust-lang/rust/commit/f7c4359a2c350521c312bd5dce3ce515878d922a"}, {"sha": "90465164446ca823cc9e9ecdd40747455f429525", "url": "https://api.github.com/repos/rust-lang/rust/commits/90465164446ca823cc9e9ecdd40747455f429525", "html_url": "https://github.com/rust-lang/rust/commit/90465164446ca823cc9e9ecdd40747455f429525"}], "stats": {"total": 290, "additions": 142, "deletions": 148}, "files": [{"sha": "815ec9b5c61ec56284ba436caa1a35af611af5b8", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -15,45 +15,61 @@ type Port = u16;\n \n #[deriving(Eq, TotalEq)]\n pub enum IpAddr {\n-    Ipv4(u8, u8, u8, u8, Port),\n-    Ipv6(u16, u16, u16, u16, u16, u16, u16, u16, Port)\n+    Ipv4Addr(u8, u8, u8, u8),\n+    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n }\n \n impl ToStr for IpAddr {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            Ipv4(a, b, c, d, p) =>\n-                fmt!(\"%u.%u.%u.%u:%u\",\n-                    a as uint, b as uint, c as uint, d as uint, p as uint),\n+            Ipv4Addr(a, b, c, d) =>\n+                fmt!(\"%u.%u.%u.%u\",\n+                    a as uint, b as uint, c as uint, d as uint),\n \n             // Ipv4 Compatible address\n-            Ipv6(0, 0, 0, 0, 0, 0, g, h, p) => {\n+            Ipv6Addr(0, 0, 0, 0, 0, 0, g, h) => {\n                 let a = fmt!(\"%04x\", g as uint);\n                 let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n                 let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n                 let c = fmt!(\"%04x\", h as uint);\n                 let d = FromStrRadix::from_str_radix(c.slice(2, 4), 16).unwrap();\n                 let c = FromStrRadix::from_str_radix(c.slice(0, 2), 16).unwrap();\n \n-                fmt!(\"[::%u.%u.%u.%u]:%u\", a, b, c, d, p as uint)\n+                fmt!(\"::%u.%u.%u.%u\", a, b, c, d)\n             }\n \n             // Ipv4-Mapped address\n-            Ipv6(0, 0, 0, 0, 0, 1, g, h, p) => {\n+            Ipv6Addr(0, 0, 0, 0, 0, 1, g, h) => {\n                 let a = fmt!(\"%04x\", g as uint);\n                 let b = FromStrRadix::from_str_radix(a.slice(2, 4), 16).unwrap();\n                 let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();\n                 let c = fmt!(\"%04x\", h as uint);\n                 let d = FromStrRadix::from_str_radix(c.slice(2, 4), 16).unwrap();\n                 let c = FromStrRadix::from_str_radix(c.slice(0, 2), 16).unwrap();\n \n-                fmt!(\"[::FFFF:%u.%u.%u.%u]:%u\", a, b, c, d, p as uint)\n+                fmt!(\"::FFFF:%u.%u.%u.%u\", a, b, c, d)\n             }\n \n-            Ipv6(a, b, c, d, e, f, g, h, p) =>\n-                fmt!(\"[%x:%x:%x:%x:%x:%x:%x:%x]:%u\",\n+            Ipv6Addr(a, b, c, d, e, f, g, h) =>\n+                fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                     a as uint, b as uint, c as uint, d as uint,\n-                    e as uint, f as uint, g as uint, h as uint, p as uint)\n+                    e as uint, f as uint, g as uint, h as uint)\n+        }\n+    }\n+}\n+\n+#[deriving(Eq, TotalEq)]\n+pub struct SocketAddr {\n+    ip: IpAddr,\n+    port: Port,\n+}\n+\n+\n+impl ToStr for SocketAddr {\n+    fn to_str(&self) -> ~str {\n+        match self.ip {\n+            Ipv4Addr(*) => fmt!(\"%s:%u\", self.ip.to_str(), self.port as uint),\n+            Ipv6Addr(*) => fmt!(\"[%s]:%u\", self.ip.to_str(), self.port as uint),\n         }\n     }\n }"}, {"sha": "27222542e087d6529523316d95a81fa341218a85", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -10,7 +10,7 @@\n \n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::io::net::ip::IpAddr;\n+use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer, Listener};\n use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory, IoFactoryObject,\n@@ -26,7 +26,7 @@ impl TcpStream {\n         TcpStream(s)\n     }\n \n-    pub fn connect(addr: IpAddr) -> Option<TcpStream> {\n+    pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n         let stream = unsafe {\n             rtdebug!(\"borrowing io to connect\");\n             let io = Local::unsafe_borrow::<IoFactoryObject>();\n@@ -44,7 +44,7 @@ impl TcpStream {\n         }\n     }\n \n-    pub fn peer_name(&mut self) -> Option<IpAddr> {\n+    pub fn peer_name(&mut self) -> Option<SocketAddr> {\n         match (**self).peer_name() {\n             Ok(pn) => Some(pn),\n             Err(ioerr) => {\n@@ -55,7 +55,7 @@ impl TcpStream {\n         }\n     }\n \n-    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n         match (**self).socket_name() {\n             Ok(sn) => Some(sn),\n             Err(ioerr) => {\n@@ -100,7 +100,7 @@ impl Writer for TcpStream {\n pub struct TcpListener(~RtioTcpListenerObject);\n \n impl TcpListener {\n-    pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n+    pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n         let listener = unsafe {\n             let io = Local::unsafe_borrow::<IoFactoryObject>();\n             (*io).tcp_bind(addr)\n@@ -114,7 +114,7 @@ impl TcpListener {\n         }\n     }\n \n-    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n         match (**self).socket_name() {\n             Ok(sn) => Some(sn),\n             Err(ioerr) => {\n@@ -145,7 +145,7 @@ mod test {\n     use super::*;\n     use cell::Cell;\n     use rt::test::*;\n-    use rt::io::net::ip::Ipv4;\n+    use rt::io::net::ip::{Ipv4Addr, SocketAddr};\n     use rt::io::*;\n     use prelude::*;\n \n@@ -157,7 +157,7 @@ mod test {\n                 assert!(e.kind == PermissionDenied);\n                 called = true;\n             }).inside {\n-                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n                 let listener = TcpListener::bind(addr);\n                 assert!(listener.is_none());\n             }\n@@ -173,7 +173,7 @@ mod test {\n                 assert!(e.kind == ConnectionRefused);\n                 called = true;\n             }).inside {\n-                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n                 let stream = TcpStream::connect(addr);\n                 assert!(stream.is_none());\n             }\n@@ -437,7 +437,7 @@ mod test {\n \n             connect(0, addr);\n \n-            fn connect(i: int, addr: IpAddr) {\n+            fn connect(i: int, addr: SocketAddr) {\n                 if i == MAX { return }\n \n                 do spawntask {\n@@ -476,7 +476,7 @@ mod test {\n \n             connect(0, addr);\n \n-            fn connect(i: int, addr: IpAddr) {\n+            fn connect(i: int, addr: SocketAddr) {\n                 if i == MAX { return }\n \n                 do spawntask {\n@@ -515,7 +515,7 @@ mod test {\n \n             connect(0, addr);\n \n-            fn connect(i: int, addr: IpAddr) {\n+            fn connect(i: int, addr: SocketAddr) {\n                 if i == MAX { return }\n \n                 do spawntask_later {\n@@ -553,7 +553,7 @@ mod test {\n \n             connect(0, addr);\n \n-            fn connect(i: int, addr: IpAddr) {\n+            fn connect(i: int, addr: SocketAddr) {\n                 if i == MAX { return }\n \n                 do spawntask_later {\n@@ -569,7 +569,7 @@ mod test {\n     }\n \n     #[cfg(test)]\n-    fn socket_name(addr: IpAddr) {\n+    fn socket_name(addr: SocketAddr) {\n         do run_in_newsched_task {\n             do spawntask {\n                 let listener = TcpListener::bind(addr);\n@@ -588,7 +588,7 @@ mod test {\n     }\n \n     #[cfg(test)]\n-    fn peer_name(addr: IpAddr) {\n+    fn peer_name(addr: SocketAddr) {\n         do run_in_newsched_task {\n             do spawntask {\n                 let mut listener = TcpListener::bind(addr);"}, {"sha": "644abcbe145ec710fe6025aa3041895111c9ad49", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -10,7 +10,7 @@\n \n use option::{Option, Some, None};\n use result::{Ok, Err};\n-use rt::io::net::ip::IpAddr;\n+use rt::io::net::ip::SocketAddr;\n use rt::io::{Reader, Writer};\n use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{RtioSocket, RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n@@ -19,7 +19,7 @@ use rt::local::Local;\n pub struct UdpSocket(~RtioUdpSocketObject);\n \n impl UdpSocket {\n-    pub fn bind(addr: IpAddr) -> Option<UdpSocket> {\n+    pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n         let socket = unsafe { (*Local::unsafe_borrow::<IoFactoryObject>()).udp_bind(addr) };\n         match socket {\n             Ok(s) => Some(UdpSocket(s)),\n@@ -30,7 +30,7 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n+    pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n         match (**self).recvfrom(buf) {\n             Ok((nread, src)) => Some((nread, src)),\n             Err(ioerr) => {\n@@ -43,18 +43,18 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn sendto(&mut self, buf: &[u8], dst: IpAddr) {\n+    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) {\n         match (**self).sendto(buf, dst) {\n             Ok(_) => (),\n             Err(ioerr) => io_error::cond.raise(ioerr),\n         }\n     }\n \n-    pub fn connect(self, other: IpAddr) -> UdpStream {\n+    pub fn connect(self, other: SocketAddr) -> UdpStream {\n         UdpStream { socket: self, connectedTo: other }\n     }\n \n-    pub fn socket_name(&mut self) -> Option<IpAddr> {\n+    pub fn socket_name(&mut self) -> Option<SocketAddr> {\n         match (***self).socket_name() {\n             Ok(sn) => Some(sn),\n             Err(ioerr) => {\n@@ -68,7 +68,7 @@ impl UdpSocket {\n \n pub struct UdpStream {\n     socket: UdpSocket,\n-    connectedTo: IpAddr\n+    connectedTo: SocketAddr\n }\n \n impl UdpStream {\n@@ -106,7 +106,7 @@ impl Writer for UdpStream {\n mod test {\n     use super::*;\n     use rt::test::*;\n-    use rt::io::net::ip::Ipv4;\n+    use rt::io::net::ip::{Ipv4Addr, SocketAddr};\n     use rt::io::*;\n     use option::{Some, None};\n \n@@ -118,7 +118,7 @@ mod test {\n                 assert!(e.kind == PermissionDenied);\n                 called = true;\n             }).inside {\n-                let addr = Ipv4(0, 0, 0, 0, 1);\n+                let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n                 let socket = UdpSocket::bind(addr);\n                 assert!(socket.is_none());\n             }\n@@ -265,7 +265,7 @@ mod test {\n     }\n \n     #[cfg(test)]\n-    fn socket_name(addr: IpAddr) {\n+    fn socket_name(addr: SocketAddr) {\n         do run_in_newsched_task {\n             do spawntask {\n                 let server = UdpSocket::bind(addr);"}, {"sha": "a7c794fb5f14241967b672f2741a1438f5046a31", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -12,7 +12,7 @@ use option::*;\n use result::*;\n \n use rt::io::IoError;\n-use super::io::net::ip::IpAddr;\n+use super::io::net::ip::{IpAddr, SocketAddr};\n use rt::uv::uvio;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n@@ -44,9 +44,9 @@ pub trait RemoteCallback {\n }\n \n pub trait IoFactory {\n-    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n-    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n-    fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError>;\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError>;\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError>;\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n }\n \n@@ -59,20 +59,20 @@ pub trait RtioTcpListener : RtioSocket {\n pub trait RtioTcpStream : RtioSocket {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n-    fn peer_name(&mut self) -> Result<IpAddr, IoError>;\n+    fn peer_name(&mut self) -> Result<SocketAddr, IoError>;\n     fn control_congestion(&mut self) -> Result<(), IoError>;\n     fn nodelay(&mut self) -> Result<(), IoError>;\n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError>;\n     fn letdie(&mut self) -> Result<(), IoError>;\n }\n \n pub trait RtioSocket {\n-    fn socket_name(&mut self) -> Result<IpAddr, IoError>;\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError>;\n }\n \n pub trait RtioUdpSocket : RtioSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n-    fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError>;\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError>;\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;\n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError>;"}, {"sha": "2427da01a0c1c700e966eeaf90843668e25853df", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -16,7 +16,7 @@ use clone::Clone;\n use container::Container;\n use iterator::{Iterator, range};\n use vec::{OwnedVector, MutableVector};\n-use super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use super::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use rt::sched::Scheduler;\n use unstable::run_in_bare_thread;\n use rt::thread::Thread;\n@@ -306,13 +306,13 @@ pub fn next_test_port() -> u16 {\n }\n \n /// Get a unique IPv4 localhost:port pair starting at 9600\n-pub fn next_test_ip4() -> IpAddr {\n-    Ipv4(127, 0, 0, 1, next_test_port())\n+pub fn next_test_ip4() -> SocketAddr {\n+    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n }\n \n /// Get a unique IPv6 localhost:port pair starting at 9600\n-pub fn next_test_ip6() -> IpAddr {\n-    Ipv6(0, 0, 0, 0, 0, 0, 0, 1, next_test_port())\n+pub fn next_test_ip6() -> SocketAddr {\n+    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n }\n \n /*"}, {"sha": "ae5e7dd27b5f3188760e3ddd0ba1cfc5e1132591", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -47,7 +47,7 @@ use libc::{c_void, c_int, size_t, malloc, free};\n use cast::transmute;\n use ptr::null;\n use unstable::finally::Finally;\n-use rt::io::net::ip::IpAddr;\n+use rt::io::net::ip::SocketAddr;\n \n use rt::io::IoError;\n \n@@ -128,7 +128,7 @@ pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n-pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, IpAddr, uint, Option<UvError>);\n+pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n \n "}, {"sha": "67d3bbef8a9c6880eb4094b62732f2ca21422a89", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -15,96 +15,89 @@ use rt::uv::uvll::*;\n use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback, UdpSendCallback};\n use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n              status_to_maybe_uv_error};\n-use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n use rt::uv::last_uv_error;\n use vec;\n use str;\n use from_str::{FromStr};\n use num;\n \n-pub enum UvIpAddr {\n-    UvIpv4(*sockaddr_in),\n-    UvIpv6(*sockaddr_in6),\n+pub enum UvSocketAddr {\n+    UvIpv4SocketAddr(*sockaddr_in),\n+    UvIpv6SocketAddr(*sockaddr_in6),\n }\n \n-fn sockaddr_to_UvIpAddr(addr: *uvll::sockaddr) -> UvIpAddr {\n+fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n     unsafe {\n         assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n         assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n         match addr {\n-            _ if is_ip4_addr(addr) => UvIpv4(addr as *uvll::sockaddr_in),\n-            _ if is_ip6_addr(addr) => UvIpv6(addr as *uvll::sockaddr_in6),\n+            _ if is_ip4_addr(addr) => UvIpv4SocketAddr(addr as *uvll::sockaddr_in),\n+            _ if is_ip6_addr(addr) => UvIpv6SocketAddr(addr as *uvll::sockaddr_in6),\n             _ => fail!(),\n         }\n     }\n }\n \n-fn ip_as_uv_ip<T>(addr: IpAddr, f: &fn(UvIpAddr) -> T) -> T {\n-    let malloc = match addr {\n-        Ipv4(*) => malloc_ip4_addr,\n-        Ipv6(*) => malloc_ip6_addr,\n+fn socket_addr_as_uv_socket_addr<T>(addr: SocketAddr, f: &fn(UvSocketAddr) -> T) -> T {\n+    let malloc = match addr.ip {\n+        Ipv4Addr(*) => malloc_ip4_addr,\n+        Ipv6Addr(*) => malloc_ip6_addr,\n     };\n-    let wrap = match addr {\n-        Ipv4(*) => UvIpv4,\n-        Ipv6(*) => UvIpv6,\n+    let wrap = match addr.ip {\n+        Ipv4Addr(*) => UvIpv4SocketAddr,\n+        Ipv6Addr(*) => UvIpv6SocketAddr,\n     };\n-    let ip_str = match addr {\n-        Ipv4(x1, x2, x3, x4, _) =>\n-            fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n-        Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n-            fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                  x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n-                  x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n-    };\n-    let port = match addr {\n-        Ipv4(_, _, _, _, p) | Ipv6(_, _, _, _, _, _, _, _, p) => p as int\n-    };\n-    let free = match addr {\n-        Ipv4(*) => free_ip4_addr,\n-        Ipv6(*) => free_ip6_addr,\n+    let free = match addr.ip {\n+        Ipv4Addr(*) => free_ip4_addr,\n+        Ipv6Addr(*) => free_ip6_addr,\n     };\n \n-    let addr = unsafe { malloc(ip_str, port) };\n+    let addr = unsafe { malloc(addr.ip.to_str(), addr.port as int) };\n     do (|| {\n         f(wrap(addr))\n     }).finally {\n         unsafe { free(addr) };\n     }\n }\n \n-fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n+fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T) -> T {\n     let ip_size = match addr {\n-        UvIpv4(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n-        UvIpv6(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n+        UvIpv4SocketAddr(*) => 4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/,\n+        UvIpv6SocketAddr(*) => 8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/,\n     };\n     let ip_name = {\n         let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n         unsafe {\n+            let buf_ptr = vec::raw::to_ptr(buf);\n             match addr {\n-                UvIpv4(addr) => uvll::ip4_name(addr, vec::raw::to_ptr(buf), ip_size as size_t),\n-                UvIpv6(addr) => uvll::ip6_name(addr, vec::raw::to_ptr(buf), ip_size as size_t),\n+                UvIpv4SocketAddr(addr) => uvll::ip4_name(addr, buf_ptr, ip_size as size_t),\n+                UvIpv6SocketAddr(addr) => uvll::ip6_name(addr, buf_ptr, ip_size as size_t),\n             }\n         };\n         buf\n     };\n     let ip_port = unsafe {\n         let port = match addr {\n-            UvIpv4(addr) => uvll::ip4_port(addr),\n-            UvIpv6(addr) => uvll::ip6_port(addr),\n+            UvIpv4SocketAddr(addr) => uvll::ip4_port(addr),\n+            UvIpv6SocketAddr(addr) => uvll::ip6_port(addr),\n         };\n         port as u16\n     };\n     let ip_str = str::from_bytes_slice(ip_name).trim_right_chars(&'\\x00');\n     let ip = match addr {\n-        UvIpv4(*) => {\n+        UvIpv4SocketAddr(*) => {\n             let ip: ~[u8] =\n                 ip_str.split_iter('.')\n                       .transform(|s: &str| -> u8 { FromStr::from_str(s).unwrap() })\n                       .collect();\n             assert_eq!(ip.len(), 4);\n-            Ipv4(ip[0], ip[1], ip[2], ip[3], ip_port)\n+            SocketAddr {\n+                ip: Ipv4Addr(ip[0], ip[1], ip[2], ip[3]),\n+                port: ip_port\n+            }\n         },\n-        UvIpv6(*) => {\n+        UvIpv6SocketAddr(*) => {\n             let ip: ~[u16] = {\n                 let expand_shorthand_and_convert = |s: &str| -> ~[~[u16]] {\n                     let convert_each_segment = |s: &str| -> ~[u16] {\n@@ -154,33 +147,36 @@ fn uv_ip_as_ip<T>(addr: UvIpAddr, f: &fn(IpAddr) -> T) -> T {\n                 }\n             };\n             assert_eq!(ip.len(), 8);\n-            Ipv6(ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6], ip[7], ip_port)\n+            SocketAddr {\n+                ip: Ipv6Addr(ip[0], ip[1], ip[2], ip[3], ip[4], ip[5], ip[6], ip[7]),\n+                port: ip_port\n+            }\n         },\n     };\n \n     // finally run the closure\n     f(ip)\n }\n \n-pub fn uv_ip_to_ip(addr: UvIpAddr) -> IpAddr {\n+pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n     use util;\n-    uv_ip_as_ip(addr, util::id)\n+    uv_socket_addr_as_socket_addr(addr, util::id)\n }\n \n #[cfg(test)]\n #[test]\n fn test_ip4_conversion() {\n     use rt;\n     let ip4 = rt::test::next_test_ip4();\n-    assert_eq!(ip4, ip_as_uv_ip(ip4, uv_ip_to_ip));\n+    assert_eq!(ip4, socket_addr_as_uv_socket_addr(ip4, uv_socket_addr_to_socket_addr));\n }\n \n #[cfg(test)]\n #[test]\n fn test_ip6_conversion() {\n     use rt;\n     let ip6 = rt::test::next_test_ip6();\n-    assert_eq!(ip6, ip_as_uv_ip(ip6, uv_ip_to_ip));\n+    assert_eq!(ip6, socket_addr_as_uv_socket_addr(ip6, uv_socket_addr_to_socket_addr));\n }\n \n // uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n@@ -293,12 +289,12 @@ impl TcpWatcher {\n         }\n     }\n \n-    pub fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n-        do ip_as_uv_ip(address) |addr| {\n+    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n+        do socket_addr_as_uv_socket_addr(address) |addr| {\n             let result = unsafe {\n                 match addr {\n-                    UvIpv4(addr) => uvll::tcp_bind(self.native_handle(), addr),\n-                    UvIpv6(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n+                    UvIpv4SocketAddr(addr) => uvll::tcp_bind(self.native_handle(), addr),\n+                    UvIpv6SocketAddr(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n                 }\n             };\n             match result {\n@@ -308,18 +304,18 @@ impl TcpWatcher {\n         }\n     }\n \n-    pub fn connect(&mut self, address: IpAddr, cb: ConnectionCallback) {\n+    pub fn connect(&mut self, address: SocketAddr, cb: ConnectionCallback) {\n         unsafe {\n             assert!(self.get_watcher_data().connect_cb.is_none());\n             self.get_watcher_data().connect_cb = Some(cb);\n \n             let connect_handle = ConnectRequest::new().native_handle();\n             rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-            do ip_as_uv_ip(address) |addr| {\n+            do socket_addr_as_uv_socket_addr(address) |addr| {\n                 let result = match addr {\n-                    UvIpv4(addr) => uvll::tcp_connect(connect_handle,\n+                    UvIpv4SocketAddr(addr) => uvll::tcp_connect(connect_handle,\n                                                       self.native_handle(), addr, connect_cb),\n-                    UvIpv6(addr) => uvll::tcp_connect6(connect_handle,\n+                    UvIpv6SocketAddr(addr) => uvll::tcp_connect6(connect_handle,\n                                                        self.native_handle(), addr, connect_cb),\n                 };\n                 assert_eq!(0, result);\n@@ -388,12 +384,12 @@ impl UdpWatcher {\n         }\n     }\n \n-    pub fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n-        do ip_as_uv_ip(address) |addr| {\n+    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n+        do socket_addr_as_uv_socket_addr(address) |addr| {\n             let result = unsafe {\n                 match addr {\n-                    UvIpv4(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n-                    UvIpv6(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n+                    UvIpv4SocketAddr(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n+                    UvIpv6SocketAddr(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n                 }\n             };\n             match result {\n@@ -432,7 +428,7 @@ impl UdpWatcher {\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n             let status = status_to_maybe_uv_error(udp_watcher, nread as c_int);\n-            let addr = uv_ip_to_ip(sockaddr_to_UvIpAddr(addr));\n+            let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n             (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n         }\n     }\n@@ -441,20 +437,20 @@ impl UdpWatcher {\n         unsafe { uvll::udp_recv_stop(self.native_handle()); }\n     }\n \n-    pub fn send(&mut self, buf: Buf, address: IpAddr, cb: UdpSendCallback) {\n+    pub fn send(&mut self, buf: Buf, address: SocketAddr, cb: UdpSendCallback) {\n         {\n             let data = self.get_watcher_data();\n             assert!(data.udp_send_cb.is_none());\n             data.udp_send_cb = Some(cb);\n         }\n \n         let req = UdpSendRequest::new();\n-        do ip_as_uv_ip(address) |addr| {\n+        do socket_addr_as_uv_socket_addr(address) |addr| {\n             let result = unsafe {\n                 match addr {\n-                    UvIpv4(addr) => uvll::udp_send(req.native_handle(),\n+                    UvIpv4SocketAddr(addr) => uvll::udp_send(req.native_handle(),\n                                                    self.native_handle(), [buf], addr, send_cb),\n-                    UvIpv6(addr) => uvll::udp_send6(req.native_handle(),\n+                    UvIpv6SocketAddr(addr) => uvll::udp_send6(req.native_handle(),\n                                                     self.native_handle(), [buf], addr, send_cb),\n                 }\n             };"}, {"sha": "85cf660a5f1aaded24bd731907a919dc6374ab0e", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 17, "deletions": 35, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f9ce4df682cd4dd1203e5ae3d8c95f5140e209/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=22f9ce4df682cd4dd1203e5ae3d8c95f5140e209", "patch": "@@ -18,10 +18,10 @@ use clone::Clone;\n use libc::{c_int, c_uint, c_void};\n use ptr;\n use rt::io::IoError;\n-use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::io::net::ip::{SocketAddr, IpAddr};\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4, UvIpv6};\n+use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use rt::rtio::*;\n use rt::sched::Scheduler;\n use rt::io::{standard_error, OtherIoError};\n@@ -44,7 +44,7 @@ enum SocketNameKind {\n }\n \n fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n-                                                 handle: U) -> Result<IpAddr, IoError> {\n+                                                 handle: U) -> Result<SocketAddr, IoError> {\n \n     let getsockname = match sk {\n         TcpPeer => uvll::rust_uv_tcp_getpeername,\n@@ -67,9 +67,9 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n \n     let addr = unsafe {\n         if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n-            net::uv_ip_to_ip(UvIpv6(r_addr as *uvll::sockaddr_in6))\n+            net::uv_socket_addr_to_socket_addr(UvIpv6SocketAddr(r_addr as *uvll::sockaddr_in6))\n         } else {\n-            net::uv_ip_to_ip(UvIpv4(r_addr as *uvll::sockaddr_in))\n+            net::uv_socket_addr_to_socket_addr(UvIpv4SocketAddr(r_addr as *uvll::sockaddr_in))\n         }\n     };\n \n@@ -244,7 +244,7 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError> {\n+    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStreamObject, IoError> {\n         // Create a cell in the task to hold the result. We will fill\n         // the cell before resuming the task.\n         let result_cell = Cell::new_empty();\n@@ -291,7 +291,7 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError> {\n+    fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => Ok(~UvTcpListener::new(watcher)),\n@@ -309,7 +309,7 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError> {\n+    fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError> {\n         let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => Ok(~UvUdpSocket(watcher)),\n@@ -365,7 +365,7 @@ impl Drop for UvTcpListener {\n }\n \n impl RtioSocket for UvTcpListener {\n-    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n         socket_name(Tcp, self.watcher)\n     }\n }\n@@ -445,7 +445,7 @@ impl Drop for UvTcpStream {\n }\n \n impl RtioSocket for UvTcpStream {\n-    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n         socket_name(Tcp, **self)\n     }\n }\n@@ -519,7 +519,7 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n-    fn peer_name(&mut self) -> Result<IpAddr, IoError> {\n+    fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n         socket_name(TcpPeer, **self)\n     }\n \n@@ -586,15 +586,15 @@ impl Drop for UvUdpSocket {\n }\n \n impl RtioSocket for UvUdpSocket {\n-    fn socket_name(&mut self) -> Result<IpAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n         socket_name(Udp, **self)\n     }\n }\n \n impl RtioUdpSocket for UvUdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(uint, IpAddr), IoError>> = &result_cell;\n+        let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n         let buf_ptr: *&mut [u8] = &buf;\n@@ -626,7 +626,7 @@ impl RtioUdpSocket for UvUdpSocket {\n         return result_cell.take();\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n@@ -653,17 +653,8 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let ip_str = match multi {\n-            Ipv4(x1, x2, x3, x4, _) =>\n-                fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n-            Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n-                fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                      x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n-                      x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n-        };\n-\n         let r = unsafe {\n-            do ip_str.as_c_str |m_addr| {\n+            do multi.to_str().as_c_str |m_addr| {\n                 uvll::udp_set_membership(self.native_handle(), m_addr,\n                                          ptr::null(), uvll::UV_JOIN_GROUP)\n             }\n@@ -676,17 +667,8 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let ip_str = match multi {\n-            Ipv4(x1, x2, x3, x4, _) =>\n-                fmt!(\"%u.%u.%u.%u\", x1 as uint, x2 as uint, x3 as uint, x4 as uint),\n-            Ipv6(x1, x2, x3, x4, x5, x6, x7, x8, _) =>\n-                fmt!(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                      x1 as uint, x2 as uint, x3 as uint, x4 as uint,\n-                      x5 as uint, x6 as uint, x7 as uint, x8 as uint),\n-        };\n-\n         let r = unsafe {\n-            do ip_str.as_c_str |m_addr| {\n+            do multi.to_str().as_c_str |m_addr| {\n                 uvll::udp_set_membership(self.native_handle(), m_addr,\n                                          ptr::null(), uvll::UV_LEAVE_GROUP)\n             }"}]}