{"sha": "e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NDgyOWQ1MWQ5YWE4ZTI2MjNkYWJkNGRjZDQ5MzVkMjIwMDhjYjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-02T14:39:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T09:35:00Z"}, "message": "Plumbing to omit allocas for temps when possible (currently unused)", "tree": {"sha": "58c37f3c0e9c88f6fa94be184fb098a78b12e348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58c37f3c0e9c88f6fa94be184fb098a78b12e348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "html_url": "https://github.com/rust-lang/rust/commit/e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02017b30ebebfaeb64a5a86a885773f38057beba", "url": "https://api.github.com/repos/rust-lang/rust/commits/02017b30ebebfaeb64a5a86a885773f38057beba", "html_url": "https://github.com/rust-lang/rust/commit/02017b30ebebfaeb64a5a86a885773f38057beba"}], "stats": {"total": 210, "additions": 166, "deletions": 44}, "files": [{"sha": "84ce458ed14f7f4b62acfffd87453a2e12a0e0bb", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "patch": "@@ -51,6 +51,7 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n+extern crate rustc_data_structures;\n extern crate rustc_front;\n extern crate rustc_llvm as llvm;\n extern crate rustc_mir;"}, {"sha": "1ce7b55a9c686400d077d7eb44ecd88091212427", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "patch": "@@ -20,7 +20,7 @@ use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::tvec;\n \n-use super::MirContext;\n+use super::{MirContext, TempRef};\n \n #[derive(Copy, Clone)]\n pub struct LvalueRef<'tcx> {\n@@ -58,7 +58,12 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let tcx = bcx.tcx();\n         match *lvalue {\n             mir::Lvalue::Var(index) => self.vars[index as usize],\n-            mir::Lvalue::Temp(index) => self.temps[index as usize],\n+            mir::Lvalue::Temp(index) => match self.temps[index as usize] {\n+                TempRef::Lvalue(lvalue) =>\n+                    lvalue,\n+                TempRef::Operand(..) =>\n+                    tcx.sess.bug(&format!(\"using operand temp {:?} as lvalue\", lvalue)),\n+            },\n             mir::Lvalue::Arg(index) => self.args[index as usize],\n             mir::Lvalue::Static(_def_id) => unimplemented!(),\n             mir::Lvalue::ReturnPointer => {"}, {"sha": "760018b4313c817fb27ada2df9df3e5eabd23054", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "patch": "@@ -10,9 +10,9 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n+use rustc_data_structures::fnv::FnvHashSet;\n use rustc_mir::repr as mir;\n use rustc_mir::tcx::LvalueTy;\n-use std::cell::Cell;\n use trans::base;\n use trans::build;\n use trans::common::{self, Block};\n@@ -21,6 +21,7 @@ use trans::expr;\n use trans::type_of;\n \n use self::lvalue::LvalueRef;\n+use self::operand::OperandRef;\n \n // FIXME DebugLoc is always None right now\n \n@@ -43,15 +44,31 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// An LLVM alloca for each MIR `VarDecl`\n     vars: Vec<LvalueRef<'tcx>>,\n \n-    /// An LLVM alloca for each MIR `TempDecl`\n-    temps: Vec<LvalueRef<'tcx>>,\n+    /// The location where each MIR `TempDecl` is stored. This is\n+    /// usually an `LvalueRef` representing an alloca, but not always:\n+    /// sometimes we can skip the alloca and just store the value\n+    /// directly using an `OperandRef`, which makes for tighter LLVM\n+    /// IR. The conditions for using an `OperandRef` are as follows:\n+    ///\n+    /// - the type of the temporary must be judged \"immediate\" by `type_is_immediate`\n+    /// - the operand must never be referenced indirectly\n+    ///     - we should not take its address using the `&` operator\n+    ///     - nor should it appear in an lvalue path like `tmp.a`\n+    /// - the operand must be defined by an rvalue that can generate immediate\n+    ///   values\n+    temps: Vec<TempRef<'tcx>>,\n \n     /// The arguments to the function; as args are lvalues, these are\n     /// always indirect, though we try to avoid creating an alloca\n     /// when we can (and just reuse the pointer the caller provided).\n     args: Vec<LvalueRef<'tcx>>,\n }\n \n+enum TempRef<'tcx> {\n+    Lvalue(LvalueRef<'tcx>),\n+    Operand(Option<OperandRef<'tcx>>),\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n@@ -60,6 +77,10 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n \n     let mir_blocks = bcx.mir().all_basic_blocks();\n \n+    // Analyze the temps to determine which must be lvalues\n+    // FIXME\n+    let lvalue_temps: FnvHashSet<usize> = (0..mir.temp_decls.len()).collect();\n+\n     // Allocate variable and temp allocas\n     let vars = mir.var_decls.iter()\n                             .map(|decl| (bcx.monomorphize(&decl.ty), decl.name))\n@@ -68,7 +89,16 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n     let temps = mir.temp_decls.iter()\n                               .map(|decl| bcx.monomorphize(&decl.ty))\n                               .enumerate()\n-                              .map(|(i, mty)| LvalueRef::alloca(bcx, mty, &format!(\"temp{:?}\", i)))\n+                              .map(|(i, mty)| if lvalue_temps.contains(&i) {\n+                                  TempRef::Lvalue(LvalueRef::alloca(bcx,\n+                                                                    mty,\n+                                                                    &format!(\"temp{:?}\", i)))\n+                              } else {\n+                                  // If this is an immediate temp, we do not create an\n+                                  // alloca in advance. Instead we wait until we see the\n+                                  // definition and update the operand there.\n+                                  TempRef::Operand(None)\n+                              })\n                               .collect();\n     let args = arg_value_refs(bcx, mir);\n "}, {"sha": "c82726fd0e577beece9bdb860c4f015a8121a774", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 99, "deletions": 35, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "patch": "@@ -53,21 +53,98 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 unimplemented!()\n             }\n \n+            mir::Rvalue::Aggregate(_, ref operands) => {\n+                for (i, operand) in operands.iter().enumerate() {\n+                    let lldest_i = build::GEPi(bcx, lldest, &[0, i]);\n+                    self.trans_operand_into(bcx, lldest_i, operand);\n+                }\n+                bcx\n+            }\n+\n+            mir::Rvalue::Slice { ref input, from_start, from_end } => {\n+                let ccx = bcx.ccx();\n+                let input = self.trans_lvalue(bcx, input);\n+                let (llbase, lllen) = tvec::get_base_and_len(bcx,\n+                                                             input.llval,\n+                                                             input.ty.to_ty(bcx.tcx()));\n+                let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n+                let adj = common::C_uint(ccx, from_start + from_end);\n+                let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n+                build::Store(bcx, llbase1, build::GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]));\n+                build::Store(bcx, lllen1, build::GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]));\n+                bcx\n+            }\n+\n+            mir::Rvalue::InlineAsm(inline_asm) => {\n+                asm::trans_inline_asm(bcx, inline_asm)\n+            }\n+\n+            _ => {\n+                assert!(self.rvalue_creates_operand(rvalue));\n+                let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n+                build::Store(bcx, temp.llval, lldest);\n+                bcx\n+            }\n+        }\n+    }\n+\n+    pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            mir::Rvalue::Use(..) | // (*)\n+            mir::Rvalue::Ref(..) |\n+            mir::Rvalue::Len(..) |\n+            mir::Rvalue::Cast(..) | // (*)\n+            mir::Rvalue::BinaryOp(..) |\n+            mir::Rvalue::UnaryOp(..) |\n+            mir::Rvalue::Box(..) =>\n+                true,\n+            mir::Rvalue::Repeat(..) |\n+            mir::Rvalue::Aggregate(..) |\n+            mir::Rvalue::Slice { .. } |\n+            mir::Rvalue::InlineAsm(..) =>\n+                false,\n+        }\n+\n+        // (*) this is only true if the type is suitable\n+    }\n+\n+    pub fn trans_rvalue_operand(&mut self,\n+                                bcx: Block<'bcx, 'tcx>,\n+                                rvalue: &mir::Rvalue<'tcx>)\n+                                -> (Block<'bcx, 'tcx>, OperandRef<'tcx>)\n+    {\n+        assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+\n+        match *rvalue {\n+            mir::Rvalue::Use(ref operand) => {\n+                let operand = self.trans_operand(bcx, operand);\n+                (bcx, operand)\n+            }\n+\n+            mir::Rvalue::Cast(..) => {\n+                unimplemented!()\n+            }\n+\n             mir::Rvalue::Ref(_, _, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n+\n                 // Note: lvalues are indirect, so storing the `llval` into the\n                 // destination effectively creates a reference.\n-                build::Store(bcx, tr_lvalue.llval, lldest);\n-                bcx\n+                (bcx, OperandRef {\n+                    llval: tr_lvalue.llval,\n+                    ty: tr_lvalue.ty.to_ty(bcx.tcx()),\n+                })\n             }\n \n             mir::Rvalue::Len(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n                 let (_, lllen) = tvec::get_base_and_len(bcx,\n                                                         tr_lvalue.llval,\n                                                         tr_lvalue.ty.to_ty(bcx.tcx()));\n-                build::Store(bcx, lllen, lldest);\n-                bcx\n+                (bcx, OperandRef {\n+                    llval: lllen,\n+                    ty: bcx.tcx().types.usize,\n+                })\n             }\n \n             mir::Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n@@ -170,8 +247,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     mir::BinOp::Gt => base::compare_scalar_types(bcx, lhs.llval, rhs.llval, lhs.ty,\n                                                                  hir::BiGt, binop_debug_loc),\n                 };\n-                build::Store(bcx, llval, lldest);\n-                bcx\n+                (bcx, OperandRef {\n+                    llval: llval,\n+                    ty: lhs.ty,\n+                })\n             }\n \n             mir::Rvalue::UnaryOp(op, ref operand) => {\n@@ -186,12 +265,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         build::Neg(bcx, operand.llval, debug_loc)\n                     }\n                 };\n-                build::Store(bcx, llval, lldest);\n-                bcx\n+                (bcx, OperandRef {\n+                    llval: llval,\n+                    ty: operand.ty,\n+                })\n             }\n \n             mir::Rvalue::Box(content_ty) => {\n-                let content_ty: Ty<'tcx> = content_ty;\n+                let content_ty: Ty<'tcx> = bcx.monomorphize(&content_ty);\n                 let llty = type_of::type_of(bcx.ccx(), content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx(), llty);\n                 let align = type_of::align_of(bcx.ccx(), content_ty);\n@@ -204,34 +285,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                                       llsize,\n                                                                       llalign,\n                                                                       DebugLoc::None);\n-                build::Store(bcx, llval, lldest);\n-                bcx\n-            }\n-\n-            mir::Rvalue::Aggregate(_, ref operands) => {\n-                for (i, operand) in operands.iter().enumerate() {\n-                    let lldest_i = build::GEPi(bcx, lldest, &[0, i]);\n-                    self.trans_operand_into(bcx, lldest_i, operand);\n-                }\n-                bcx\n+                (bcx, OperandRef {\n+                    llval: llval,\n+                    ty: box_ty,\n+                })\n             }\n \n-            mir::Rvalue::Slice { ref input, from_start, from_end } => {\n-                let ccx = bcx.ccx();\n-                let input = self.trans_lvalue(bcx, input);\n-                let (llbase, lllen) = tvec::get_base_and_len(bcx,\n-                                                             input.llval,\n-                                                             input.ty.to_ty(bcx.tcx()));\n-                let llbase1 = build::GEPi(bcx, llbase, &[from_start]);\n-                let adj = common::C_uint(ccx, from_start + from_end);\n-                let lllen1 = build::Sub(bcx, lllen, adj, DebugLoc::None);\n-                build::Store(bcx, llbase1, build::GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]));\n-                build::Store(bcx, lllen1, build::GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]));\n-                bcx\n-            }\n-\n-            mir::Rvalue::InlineAsm(inline_asm) => {\n-                asm::trans_inline_asm(bcx, inline_asm)\n+            mir::Rvalue::Repeat(..) |\n+            mir::Rvalue::Aggregate(..) |\n+            mir::Rvalue::Slice { .. } |\n+            mir::Rvalue::InlineAsm(..) => {\n+                bcx.tcx().sess.bug(&format!(\"cannot generate operand from rvalue {:?}\", rvalue));\n             }\n         }\n     }"}, {"sha": "95ff049836eb43ed9de900b734f39eb35fda8e87", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e84829d51d9aa8e2623dabd4dcd4935d22008cb5/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=e84829d51d9aa8e2623dabd4dcd4935d22008cb5", "patch": "@@ -15,6 +15,7 @@ use trans::debuginfo::DebugLoc;\n use trans::glue;\n \n use super::MirContext;\n+use super::TempRef;\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_statement(&mut self,\n@@ -25,9 +26,30 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                let tr_dest = self.trans_lvalue(bcx, lvalue);\n-                self.trans_rvalue(bcx, tr_dest.llval, rvalue);\n-                bcx\n+                match *lvalue {\n+                    mir::Lvalue::Temp(index) => {\n+                        let index = index as usize;\n+                        match self.temps[index as usize] {\n+                            TempRef::Lvalue(tr_dest) => {\n+                                self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                            }\n+                            TempRef::Operand(None) => {\n+                                let (bcx, operand) = self.trans_rvalue_operand(bcx, rvalue);\n+                                self.temps[index] = TempRef::Operand(Some(operand));\n+                                bcx\n+                            }\n+                            TempRef::Operand(Some(_)) => {\n+                                bcx.tcx().sess.span_bug(\n+                                    statement.span,\n+                                    &format!(\"operand {:?} already assigned\", rvalue));\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        let tr_dest = self.trans_lvalue(bcx, lvalue);\n+                        self.trans_rvalue(bcx, tr_dest.llval, rvalue)\n+                    }\n+                }\n             }\n \n             mir::StatementKind::Drop(mir::DropKind::Deep, ref lvalue) => {"}]}