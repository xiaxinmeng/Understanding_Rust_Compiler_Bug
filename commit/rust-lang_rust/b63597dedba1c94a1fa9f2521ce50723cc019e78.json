{"sha": "b63597dedba1c94a1fa9f2521ce50723cc019e78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MzU5N2RlZGJhMWM5NGExZmE5ZjI1MjFjZTUwNzIzY2MwMTllNzg=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-12-11T04:53:46Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-10T08:08:24Z"}, "message": "Remove StaticKind", "tree": {"sha": "fdd5fa3b206bb089c9450be629c7f621ec4c7b9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdd5fa3b206bb089c9450be629c7f621ec4c7b9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b63597dedba1c94a1fa9f2521ce50723cc019e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b63597dedba1c94a1fa9f2521ce50723cc019e78", "html_url": "https://github.com/rust-lang/rust/commit/b63597dedba1c94a1fa9f2521ce50723cc019e78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b63597dedba1c94a1fa9f2521ce50723cc019e78/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f2c7025b8192d68a082b153b9574d5df452ca8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f2c7025b8192d68a082b153b9574d5df452ca8a", "html_url": "https://github.com/rust-lang/rust/commit/6f2c7025b8192d68a082b153b9574d5df452ca8a"}], "stats": {"total": 168, "additions": 53, "deletions": 115}, "files": [{"sha": "42d24d9f332b404e4662a984156d8b200e0dc3f3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -1687,30 +1687,13 @@ pub enum PlaceBase<'tcx> {\n )]\n pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n-    pub kind: StaticKind,\n     /// The `DefId` of the item this static was declared in. For promoted values, usually, this is\n     /// the same as the `DefId` of the `mir::Body` containing the `Place` this promoted appears in.\n     /// However, after inlining, that might no longer be the case as inlined `Place`s are copied\n     /// into the calling frame.\n     pub def_id: DefId,\n }\n \n-#[derive(\n-    Clone,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    HashStable,\n-    RustcEncodable,\n-    RustcDecodable\n-)]\n-pub enum StaticKind {\n-    Static,\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n@@ -1942,7 +1925,7 @@ impl Debug for PlaceBase<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static, def_id }) => {\n+            PlaceBase::Static(box self::Static { ty, def_id }) => {\n                 write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n             }\n         }\n@@ -3046,31 +3029,13 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n \n impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Static {\n-            ty: self.ty.fold_with(folder),\n-            kind: self.kind.fold_with(folder),\n-            def_id: self.def_id,\n-        }\n+        Static { ty: self.ty.fold_with(folder), def_id: self.def_id }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let Static { ty, kind, def_id: _ } = self;\n-\n-        ty.visit_with(visitor) || kind.visit_with(visitor)\n-    }\n-}\n+        let Static { ty, def_id: _ } = self;\n \n-impl<'tcx> TypeFoldable<'tcx> for StaticKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n-        match self {\n-            StaticKind::Static => StaticKind::Static,\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        match self {\n-            StaticKind::Static => false,\n-        }\n+        ty.visit_with(visitor)\n     }\n }\n "}, {"sha": "3924a1aa47edab17a3df8ec5c6296c6ebaefcd49", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -712,7 +712,7 @@ macro_rules! make_mir_visitor {\n                     PlaceBase::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    PlaceBase::Static(box Static { kind: _, ty, def_id: _ }) => {\n+                    PlaceBase::Static(box Static { ty, def_id: _ }) => {\n                         self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n                 }"}, {"sha": "49c3edbb2b3df1f699e91e7301fec7302f43c771", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -438,12 +438,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n             mir::PlaceRef {\n-                base:\n-                    mir::PlaceBase::Static(box mir::Static {\n-                        ty,\n-                        kind: mir::StaticKind::Static,\n-                        def_id,\n-                    }),\n+                base: mir::PlaceBase::Static(box mir::Static { ty, def_id }),\n                 projection: [],\n             } => {\n                 // NB: The layout of a static may be unsized as is the case when working"}, {"sha": "8ef4273a2f6a563a2b9c9ce4cb545a7ee342f3fd", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -2,8 +2,8 @@\n \n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n-    PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Static, StaticKind,\n-    Terminator, TerminatorKind,\n+    PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Static, Terminator,\n+    TerminatorKind,\n };\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n@@ -172,10 +172,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }),\n-                projection: [],\n-            } => {\n+            PlaceRef { base: PlaceBase::Static(box Static { def_id, .. }), projection: [] } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n             PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }"}, {"sha": "6c9b811ebd0a85b3f49579bb786d76126be7cc7d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -5,7 +5,7 @@ use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n     read_only, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability, Operand, Place,\n-    PlaceBase, PlaceElem, PlaceRef, ReadOnlyBodyAndCache, Static, StaticKind,\n+    PlaceBase, PlaceElem, PlaceRef, ReadOnlyBodyAndCache, Static,\n };\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -2196,10 +2196,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }),\n                 }\n             }\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }),\n-                projection: [],\n-            } => {\n+            PlaceRef { base: PlaceBase::Static(box Static { def_id, .. }), projection: [] } => {\n                 if !self.infcx.tcx.is_mutable_static(*def_id) {\n                     Err(place)\n                 } else {"}, {"sha": "815ace55a3721e1e6aa5d79ea12360cbd35088ef", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -1,9 +1,7 @@\n use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{AccessDepth, Deep, Shallow};\n-use rustc::mir::{\n-    Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem, StaticKind,\n-};\n+use rustc::mir::{Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use rustc_hir as hir;\n use std::cmp::max;\n@@ -327,20 +325,16 @@ fn place_base_conflict<'tcx>(\n             }\n         }\n         (PlaceBase::Static(s1), PlaceBase::Static(s2)) => {\n-            match (&s1.kind, &s2.kind) {\n-                (StaticKind::Static, StaticKind::Static) => {\n-                    if s1.def_id != s2.def_id {\n-                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                        Overlap::Disjoint\n-                    } else if tcx.is_mutable_static(s1.def_id) {\n-                        // We ignore mutable statics - they can only be unsafe code.\n-                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                        Overlap::Disjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-                }\n+            if s1.def_id != s2.def_id {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                Overlap::Disjoint\n+            } else if tcx.is_mutable_static(s1.def_id) {\n+                // We ignore mutable statics - they can only be unsafe code.\n+                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                Overlap::EqualOrDisjoint\n             }\n         }\n         (PlaceBase::Local(_), PlaceBase::Static(_))"}, {"sha": "f771330e2d7111e5612244432ca1dd4e20d50602", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let mut place_ty = match &place.base {\n             PlaceBase::Local(index) => PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-            PlaceBase::Static(box Static { kind, ty, def_id }) => {\n+            PlaceBase::Static(box Static { ty, def_id }) => {\n                 let san_ty = self.sanitize_type(place, ty);\n                 let check_err =\n                     |verifier: &mut TypeVerifier<'a, 'b, 'tcx>, place: &Place<'tcx>, ty, san_ty| {\n@@ -487,14 +487,10 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                             );\n                         };\n                     };\n-                match kind {\n-                    StaticKind::Static => {\n-                        let ty = self.tcx().type_of(*def_id);\n-                        let ty = self.cx.normalize(ty, location);\n+                let ty = self.tcx().type_of(*def_id);\n+                let ty = self.cx.normalize(ty, location);\n \n-                        check_err(self, place, ty, san_ty);\n-                    }\n-                }\n+                check_err(self, place, ty, san_ty);\n                 PlaceTy::from_ty(san_ty)\n             }\n         };"}, {"sha": "3309e9b9b622ae8d33360cd831dcfeef82191dbe", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -212,7 +212,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame.locals[local].access()\n     }\n \n-    /// Called before a `StaticKind::Static` value is accessed.\n+    /// Called before a `Static` value is accessed.\n     fn before_access_static(\n         _memory_extra: &Self::MemoryExtra,\n         _allocation: &Allocation,"}, {"sha": "aa15f3d1f173eb7fbae274dfc8dd0f54f6503bb2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -625,33 +625,27 @@ where\n         &self,\n         place_static: &mir::Static<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        use rustc::mir::StaticKind;\n-\n-        Ok(match place_static.kind {\n-            StaticKind::Static => {\n-                let ty = place_static.ty;\n-                assert!(!ty.needs_subst());\n-                let layout = self.layout_of(ty)?;\n-                // Just create a lazy reference, so we can support recursive statics.\n-                // tcx takes care of assigning every static one and only one unique AllocId.\n-                // When the data here is ever actually used, memory will notice,\n-                // and it knows how to deal with alloc_id that are present in the\n-                // global table but not in its local memory: It calls back into tcx through\n-                // a query, triggering the CTFE machinery to actually turn this lazy reference\n-                // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this InterpCx uses another Machine (e.g., in miri).  This is what we\n-                // want!  This way, computing statics works consistently between codegen\n-                // and miri: They use the same query to eventually obtain a `ty::Const`\n-                // and use that for further computation.\n-                //\n-                // Notice that statics have *two* AllocIds: the lazy one, and the resolved\n-                // one.  Here we make sure that the interpreted program never sees the\n-                // resolved ID.  Also see the doc comment of `Memory::get_static_alloc`.\n-                let alloc_id = self.tcx.alloc_map.lock().create_static_alloc(place_static.def_id);\n-                let ptr = self.tag_static_base_pointer(Pointer::from(alloc_id));\n-                MPlaceTy::from_aligned_ptr(ptr, layout)\n-            }\n-        })\n+        let ty = place_static.ty;\n+        assert!(!ty.needs_subst());\n+        let layout = self.layout_of(ty)?;\n+        // Just create a lazy reference, so we can support recursive statics.\n+        // tcx takes care of assigning every static one and only one unique AllocId.\n+        // When the data here is ever actually used, memory will notice,\n+        // and it knows how to deal with alloc_id that are present in the\n+        // global table but not in its local memory: It calls back into tcx through\n+        // a query, triggering the CTFE machinery to actually turn this lazy reference\n+        // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n+        // this InterpCx uses another Machine (e.g., in miri).  This is what we\n+        // want!  This way, computing statics works consistently between codegen\n+        // and miri: They use the same query to eventually obtain a `ty::Const`\n+        // and use that for further computation.\n+        //\n+        // Notice that statics have *two* AllocIds: the lazy one, and the resolved\n+        // one.  Here we make sure that the interpreted program never sees the\n+        // resolved ID.  Also see the doc comment of `Memory::get_static_alloc`.\n+        let alloc_id = self.tcx.alloc_map.lock().create_static_alloc(place_static.def_id);\n+        let ptr = self.tag_static_base_pointer(Pointer::from(alloc_id));\n+        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n     /// Computes a place. You should only use this if you intend to write into this"}, {"sha": "2ecae7c6b0cd82473f3f8e3d5dd1ba3689cf2e1e", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -182,7 +182,7 @@ use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::mir::visit::Visitor as MirVisitor;\n-use rustc::mir::{self, Location, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, Location, PlaceBase, Static};\n use rustc::session::config::EntryFnType;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n@@ -647,7 +647,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         location: Location,\n     ) {\n         match place_base {\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n+            PlaceBase::Static(box Static { def_id, .. }) => {\n                 debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n \n                 let tcx = self.tcx;"}, {"sha": "be9c2b741a2692eb56dd9f0ef765d5d8b7029817", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -194,8 +194,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             PlaceBase::Local(..) => {\n                 // Locals are safe.\n             }\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n-                bug!(\"StaticKind::Static should not exist\");\n+            PlaceBase::Static(box Static { .. }) => {\n+                bug!(\"Static should not exist\");\n             }\n         }\n "}, {"sha": "76f1e2d186e619442f8a7ddf9f8e9d1396a43aa1", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63597dedba1c94a1fa9f2521ce50723cc019e78/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b63597dedba1c94a1fa9f2521ce50723cc019e78", "patch": "@@ -39,7 +39,7 @@ use crate::transform::{MirPass, MirSource};\n /// errors when promotion of `#[rustc_args_required_const]` arguments fails.\n ///\n /// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n-/// newly created `StaticKind::Promoted`.\n+/// newly created `Constant`.\n #[derive(Default)]\n pub struct PromoteTemps<'tcx> {\n     pub promoted_fragments: Cell<IndexVec<Promoted, BodyAndCache<'tcx>>>,"}]}