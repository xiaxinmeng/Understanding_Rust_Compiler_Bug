{"sha": "771cfa5581fd245b0d45e839e791b10e01ebb8a7", "node_id": "C_kwDOAAsO6NoAKDc3MWNmYTU1ODFmZDI0NWIwZDQ1ZTgzOWU3OTFiMTBlMDFlYmI4YTc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-07T19:43:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-07T19:43:19Z"}, "message": "Rollup merge of #104543 - JhonnyBillM:migrate-codegen-ssa-to-diagnostics-structs-pt3, r=davidtwco\n\nMigrate `codegen_ssa` to diagnostics structs - [Part 3]\n\nCompletes migrating `codegen_ssa` module except 2 outstanding errors that depend on other crates:\n1. [`rustc_middle::mir::interpret::InterpError`](https://github.com/rust-lang/rust/blob/b6097f2e1b2ca62e188ba53cf43bd66b06b36915/compiler/rustc_middle/src/mir/interpret/error.rs#L475): I saw `rustc_middle` is unassigned, I am open to take this work.\n\n2.  `codegen_llvm`'s use of `fn span_invalid_monomorphization_error`, which I started to replace in the [last commit](https://github.com/rust-lang/rust/commit/9a31b3cdda78a2c0891828254fe9886e0a1cfd16) of this PR, but would like to know the team's preference on how we should keep replacing the other macros:\n2.1. Update macros to expect a `Diagnostic`\n2.2. Remove macros and expand the code on each use.\nSee [some examples of the different options in this experimental commit](https://github.com/JhonnyBillM/rust/commit/64aee83e80857dcfa450f0c6e31d5f29c6d577e6)\n\n_Part 2 - https://github.com/rust-lang/rust/pull/103792_\n\nr? ``@davidtwco``\nCc ``@compiler-errors``", "tree": {"sha": "1e667149cde73f2bf463e6ec285cc634a701378a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e667149cde73f2bf463e6ec285cc634a701378a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/771cfa5581fd245b0d45e839e791b10e01ebb8a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjuctXCRBK7hj4Ov3rIwAAd5EIADMbystMT0eVfwyWMiqIRMVn\n5xoprSKKWSiUYKzmkxaNn8g3Gzqbg/7o1FAN6uimUl2dDagSOB4ne5gRc1lIlRuc\nKq9RA5wxtF4nuD3K3UUxcygrRYc/rysp87MUy3GJ8ZS6fXepv238LYLn97EKZyql\nxvwe2WPaLoBoO4OLnugSGGtINsxawGQ3zga4d0v/dA4Puv0112dlLarONrqT4xHz\nDEU/7uOV3BHDlf+WB0F9hUDCbhItCFHV8s9DaF+83HnrDYyCiZPQFc+wptYfVh6S\nC3HzhSIwr7t5ZR1rosOBKVi5z9t4jl0fB1Cf/k5FIoqzUDcS24aW5dQ/R3iPhmY=\n=FGe1\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e667149cde73f2bf463e6ec285cc634a701378a\nparent 08653c8c57dd7446088aa5c74112189a37140075\nparent 4d63d7d91c984342afd5bca0c5cf4cb1761973bf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673120599 +0100\ncommitter GitHub <noreply@github.com> 1673120599 +0100\n\nRollup merge of #104543 - JhonnyBillM:migrate-codegen-ssa-to-diagnostics-structs-pt3, r=davidtwco\n\nMigrate `codegen_ssa` to diagnostics structs - [Part 3]\n\nCompletes migrating `codegen_ssa` module except 2 outstanding errors that depend on other crates:\n1. [`rustc_middle::mir::interpret::InterpError`](https://github.com/rust-lang/rust/blob/b6097f2e1b2ca62e188ba53cf43bd66b06b36915/compiler/rustc_middle/src/mir/interpret/error.rs#L475): I saw `rustc_middle` is unassigned, I am open to take this work.\n\n2.  `codegen_llvm`'s use of `fn span_invalid_monomorphization_error`, which I started to replace in the [last commit](https://github.com/rust-lang/rust/commit/9a31b3cdda78a2c0891828254fe9886e0a1cfd16) of this PR, but would like to know the team's preference on how we should keep replacing the other macros:\n2.1. Update macros to expect a `Diagnostic`\n2.2. Remove macros and expand the code on each use.\nSee [some examples of the different options in this experimental commit](https://github.com/JhonnyBillM/rust/commit/64aee83e80857dcfa450f0c6e31d5f29c6d577e6)\n\n_Part 2 - https://github.com/rust-lang/rust/pull/103792_\n\nr? ``@davidtwco``\nCc ``@compiler-errors``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/771cfa5581fd245b0d45e839e791b10e01ebb8a7", "html_url": "https://github.com/rust-lang/rust/commit/771cfa5581fd245b0d45e839e791b10e01ebb8a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/771cfa5581fd245b0d45e839e791b10e01ebb8a7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08653c8c57dd7446088aa5c74112189a37140075", "url": "https://api.github.com/repos/rust-lang/rust/commits/08653c8c57dd7446088aa5c74112189a37140075", "html_url": "https://github.com/rust-lang/rust/commit/08653c8c57dd7446088aa5c74112189a37140075"}, {"sha": "4d63d7d91c984342afd5bca0c5cf4cb1761973bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d63d7d91c984342afd5bca0c5cf4cb1761973bf", "html_url": "https://github.com/rust-lang/rust/commit/4d63d7d91c984342afd5bca0c5cf4cb1761973bf"}], "stats": {"total": 1261, "additions": 920, "deletions": 341}, "files": [{"sha": "86e1e50c400612676db1930fcb978186940292da", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -3890,6 +3890,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"serde_json\",\n  \"smallvec\",\n  \"snap\",\n@@ -4024,6 +4025,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"serde\",\n  \"serde_json\",\n  \"termcolor\","}, {"sha": "680d810f78eb9b4121e98955f6cbad23629f52a3", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 283, "deletions": 266, "changes": 549, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -8,8 +8,8 @@ use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n-use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::errors::{ExpectedPointerMutability, InvalidMonomorphization};\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n@@ -284,15 +284,11 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n+                        tcx.sess.emit_err(InvalidMonomorphization::BasicIntegerType {\n                             span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                name, ty\n-                            ),\n-                        );\n+                            name,\n+                            ty,\n+                        });\n                         return;\n                     }\n                 }\n@@ -838,40 +834,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     llret_ty: &'ll Type,\n     span: Span,\n ) -> Result<&'ll Value, ()> {\n-    // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n-            {\n-                emit_error!($($fmt)*);\n-                return Err(());\n-            }\n-        }\n+        ($diag: expr) => {{\n+            bx.sess().emit_err($diag);\n+            return Err(());\n+        }};\n     }\n \n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond: expr, $diag: expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($diag);\n             }\n         };\n     }\n \n     macro_rules! require_simd {\n-        ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+        ($ty: expr, $diag: expr) => {\n+            require!($ty.is_simd(), $diag)\n         };\n     }\n \n@@ -881,7 +861,11 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     let arg_tys = sig.inputs();\n \n     if name == sym::simd_select_bitmask {\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n+\n         let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n \n         let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n@@ -902,12 +886,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n-            _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::InvalidBitmask {\n+                span,\n+                name,\n                 mask_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         };\n \n         let i1 = bx.type_i1();\n@@ -919,7 +904,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     }\n \n     // every intrinsic below takes a SIMD vector as its first argument\n-    require_simd!(arg_tys[0], \"input\");\n+    require_simd!(arg_tys[0], InvalidMonomorphization::SimdInput { span, name, ty: arg_tys[0] });\n     let in_ty = arg_tys[0];\n \n     let comparison = match name {\n@@ -934,23 +919,24 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n     let (in_len, in_elem) = arg_tys[0].simd_size_and_type(bx.tcx());\n     if let Some(cmp_op) = comparison {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n+\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnIntegerType { span, name, ret_ty, out_ty }\n         );\n \n         return Ok(compare_simd_types(\n@@ -975,34 +961,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                         span_bug!(span, \"could not evaluate shuffle index array length\")\n                     })\n                 }\n-                _ => return_error!(\n-                    \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                    args[2].layout.ty\n-                ),\n+                _ => return_error!(InvalidMonomorphization::SimdShuffle {\n+                    span,\n+                    name,\n+                    ty: args[2].layout.ty\n+                }),\n             }\n         } else {\n             stripped.parse().unwrap_or_else(|_| {\n                 span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n             })\n         };\n \n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphization::ReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let total_len = u128::from(in_len) * 2;\n@@ -1015,15 +994,20 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let val = bx.const_get_elt(vector, i as u64);\n                 match bx.const_to_opt_u128(val, true) {\n                     None => {\n-                        emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexNotConstant {\n+                            span,\n+                            name,\n+                            arg_idx,\n+                        });\n                         None\n                     }\n                     Some(idx) if idx >= total_len => {\n-                        emit_error!(\n-                            \"shuffle index #{} is out of bounds (limit {})\",\n+                        bx.sess().emit_err(InvalidMonomorphization::ShuffleIndexOutOfBounds {\n+                            span,\n+                            name,\n                             arg_idx,\n-                            total_len\n-                        );\n+                            total_len,\n+                        });\n                         None\n                     }\n                     Some(idx) => Some(bx.const_i32(idx as i32)),\n@@ -1044,10 +1028,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphization::InsertedType {\n+                span,\n+                name,\n+                in_elem,\n+                in_ty,\n+                out_ty: arg_tys[2]\n+            }\n         );\n         return Ok(bx.insert_element(\n             args[0].immediate(),\n@@ -1058,28 +1045,26 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()));\n     }\n \n     if name == sym::simd_select {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n-        require_simd!(arg_tys[1], \"argument\");\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdArgument { span, name, ty: arg_tys[1] }\n+        );\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphization::MismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphization::MaskType { span, name, ty: m_elem_ty }),\n         }\n         // truncate the mask to a vector of i1s\n         let i1 = bx.type_i1();\n@@ -1111,11 +1096,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 args[0].immediate(),\n                 i.bit_width().unwrap_or_else(|| bx.data_layout().pointer_size.bits()),\n             ),\n-            _ => return_error!(\n-                \"vector argument `{}`'s element type `{}`, expected integer element type\",\n+            _ => return_error!(InvalidMonomorphization::VectorArgument {\n+                span,\n+                name,\n                 in_ty,\n                 in_elem\n-            ),\n+            }),\n         };\n \n         // Shift the MSB to the right by \"in_elem_bitwidth - 1\" into the first bit position.\n@@ -1150,12 +1136,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                 let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n                 return Ok(bx.load(array_ty, ptr, Align::ONE));\n             }\n-            _ => return_error!(\n-                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n                 ret_ty,\n                 expected_int_bits,\n                 expected_bytes\n-            ),\n+            }),\n         }\n     }\n \n@@ -1168,42 +1155,27 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         span: Span,\n         args: &[OperandRef<'tcx, &'ll Value>],\n     ) -> Result<&'ll Value, ()> {\n-        #[allow(unused_macro_rules)]\n-        macro_rules! emit_error {\n-            ($msg: tt) => {\n-                emit_error!($msg, )\n-            };\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n-                {\n-                    emit_error!($($fmt)*);\n-                    return Err(());\n-                }\n-            }\n+            ($diag: expr) => {{\n+                bx.sess().emit_err($diag);\n+                return Err(());\n+            }};\n         }\n \n         let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n             let elem_ty = bx.cx.type_float_from_ty(*f);\n             match f.bit_width() {\n                 32 => (\"f32\", elem_ty),\n                 64 => (\"f64\", elem_ty),\n-                _ => {\n-                    return_error!(\n-                        \"unsupported element type `{}` of floating-point vector `{}`\",\n-                        f.name_str(),\n-                        in_ty\n-                    );\n-                }\n+                _ => return_error!(InvalidMonomorphization::FloatingPointVector {\n+                    span,\n+                    name,\n+                    f_ty: *f,\n+                    in_ty,\n+                }),\n             }\n         } else {\n-            return_error!(\"`{}` is not a floating-point type\", in_ty);\n+            return_error!(InvalidMonomorphization::FloatingPointType { span, name, in_ty });\n         };\n \n         let vec_ty = bx.type_vector(elem_ty, in_len);\n@@ -1225,7 +1197,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n             sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+            _ => return_error!(InvalidMonomorphization::UnrecognizedIntrinsic { span, name }),\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n@@ -1319,37 +1291,48 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n \n         // Of the same length:\n         let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            out_len\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n         );\n         require!(\n             in_len == out_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            out_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n         );\n \n         // The return type must match the first argument type\n-        require!(ret_ty == in_ty, \"expected return type `{}`, found `{}`\", in_ty, ret_ty);\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n \n         // This counts how many pointers\n         fn ptr_count(t: Ty<'_>) -> usize {\n@@ -1376,15 +1359,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*_ {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1400,10 +1383,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                                 to be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1452,32 +1437,40 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         // * M: any integer width is supported, will be truncated to i1\n \n         // All types must be simd vector types\n-        require_simd!(in_ty, \"first\");\n-        require_simd!(arg_tys[1], \"second\");\n-        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(in_ty, InvalidMonomorphization::SimdFirst { span, name, ty: in_ty });\n+        require_simd!(\n+            arg_tys[1],\n+            InvalidMonomorphization::SimdSecond { span, name, ty: arg_tys[1] }\n+        );\n+        require_simd!(\n+            arg_tys[2],\n+            InvalidMonomorphization::SimdThird { span, name, ty: arg_tys[2] }\n+        );\n \n         // Of the same length:\n         let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"second\",\n-            in_len,\n-            in_ty,\n-            arg_tys[1],\n-            element_len1\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n         );\n         require!(\n             in_len == element_len2,\n-            \"expected {} argument with length {} (same as input type `{}`), \\\n-            found `{}` with length {}\",\n-            \"third\",\n-            in_len,\n-            in_ty,\n-            arg_tys[2],\n-            element_len2\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n         );\n \n         // This counts how many pointers\n@@ -1508,15 +1501,15 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of second argument `{}` \\\n-                        to be a pointer to the element type `{}` of the first \\\n-                        argument `{}`, found `{}` != `*mut {}`\",\n-                    element_ty1,\n-                    arg_tys[1],\n-                    in_elem,\n-                    in_ty,\n-                    element_ty1,\n-                    in_elem\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n                 );\n                 unreachable!();\n             }\n@@ -1531,10 +1524,12 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             _ => {\n                 require!(\n                     false,\n-                    \"expected element type `{}` of third argument `{}` \\\n-                         be a signed integer type\",\n-                    element_ty2,\n-                    arg_tys[2]\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n                 );\n             }\n         }\n@@ -1581,10 +1576,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -1607,25 +1599,28 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n                                 32 => bx.const_real(bx.type_f32(), $identity),\n                                 64 => bx.const_real(bx.type_f64(), $identity),\n                                 v => return_error!(\n-                                    r#\"\n-unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n-                                    sym::$name,\n-                                    in_ty,\n-                                    in_elem,\n-                                    v,\n-                                    ret_ty\n+                                    InvalidMonomorphization::UnsupportedSymbolOfSize {\n+                                        span,\n+                                        name,\n+                                        symbol: sym::$name,\n+                                        in_ty,\n+                                        in_elem,\n+                                        size: v,\n+                                        ret_ty\n+                                    }\n                                 ),\n                             }\n                         };\n                         Ok(bx.$float_reduce(acc, args[0].immediate()))\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1653,22 +1648,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_i) => Ok(bx.$int_red(args[0].immediate(), true)),\n                     ty::Uint(_u) => Ok(bx.$int_red(args[0].immediate(), false)),\n                     ty::Float(_f) => Ok(bx.$float_red(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1686,22 +1679,20 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphization::ReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n+                        _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                            span,\n+                            name,\n+                            symbol: sym::$name,\n                             in_ty,\n                             in_elem,\n                             ret_ty\n-                        ),\n+                        }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -1714,13 +1705,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                         let r = bx.$red(input);\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n+                    _ => return_error!(InvalidMonomorphization::UnsupportedSymbol {\n+                        span,\n+                        name,\n+                        symbol: sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n-                    ),\n+                    }),\n                 };\n             }\n         };\n@@ -1733,16 +1725,18 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n     if name == sym::simd_cast_ptr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n@@ -1751,19 +1745,29 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast fat pointer `{}`\", in_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: in_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(p) => {\n                 let (metadata, check_sized) = p.ty.ptr_metadata_ty(bx.tcx, |ty| {\n                     bx.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), ty)\n                 });\n                 assert!(!check_sized); // we are in codegen, so we shouldn't see these types\n-                require!(metadata.is_unit(), \"cannot cast to fat pointer `{}`\", out_elem)\n+                require!(\n+                    metadata.is_unit(),\n+                    InvalidMonomorphization::CastFatPointer { span, name, ty: out_elem }\n+                );\n+            }\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n             }\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n         }\n \n         if in_elem == out_elem {\n@@ -1774,66 +1778,76 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     }\n \n     if name == sym::simd_expose_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", in_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: in_elem })\n+            }\n         }\n         match out_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", out_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: out_elem }),\n         }\n \n         return Ok(bx.ptrtoint(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_from_exposed_addr {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n \n         match in_elem.kind() {\n             ty::Uint(ty::UintTy::Usize) => {}\n-            _ => return_error!(\"expected `usize`, got `{}`\", in_elem),\n+            _ => return_error!(InvalidMonomorphization::ExpectedUsize { span, name, ty: in_elem }),\n         }\n         match out_elem.kind() {\n             ty::RawPtr(_) => {}\n-            _ => return_error!(\"expected pointer, got `{}`\", out_elem),\n+            _ => {\n+                return_error!(InvalidMonomorphization::ExpectedPointer { span, name, ty: out_elem })\n+            }\n         }\n \n         return Ok(bx.inttoptr(args[0].immediate(), llret_ty));\n     }\n \n     if name == sym::simd_cast || name == sym::simd_as {\n-        require_simd!(ret_ty, \"return\");\n+        require_simd!(ret_ty, InvalidMonomorphization::SimdReturn { span, name, ty: ret_ty });\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphization::ReturnLengthInputType {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                ret_ty,\n+                out_len\n+            }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -1912,11 +1926,14 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         }\n         require!(\n             false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+            InvalidMonomorphization::UnsupportedCast {\n+                span,\n+                name,\n+                in_ty,\n+                in_elem,\n+                ret_ty,\n+                out_elem\n+            }\n         );\n     }\n     macro_rules! arith_binary {\n@@ -1928,10 +1945,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -1959,10 +1976,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedOperation { span, name, in_ty, in_elem }\n+                );\n             })*\n         }\n     }\n@@ -2000,12 +2017,12 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphization::ExpectedVectorElementType {\n+                    span,\n+                    name,\n+                    expected_element: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vector_type: arg_tys[0]\n+                });\n             }\n         };\n         let llvm_intrinsic = &format!("}, {"sha": "d1ad687e6aee32a2b3e30c17557e58e366efce87", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -27,6 +27,7 @@ rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "8ca7103ed482cc5f7646537165823a4dbcf2041d", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -2616,7 +2616,7 @@ fn add_static_crate<'a>(\n             sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n         let mut archive = archive_builder_builder.new_archive_builder(sess);\n-        if let Err(e) = archive.add_archive(\n+        if let Err(error) = archive.add_archive(\n             cratepath,\n             Box::new(move |f| {\n                 if f == METADATA_FILENAME {\n@@ -2656,7 +2656,7 @@ fn add_static_crate<'a>(\n                 false\n             }),\n         ) {\n-            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+            sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n         }\n         if archive.build(&dst) {\n             link_upstream(&dst);"}, {"sha": "d318c15d34221231ef8843f97083094d054edb87", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -5,6 +5,7 @@ use crate::back::write::{\n     submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,\n };\n use crate::common::{IntPredicate, RealPredicate, TypeKind};\n+use crate::errors;\n use crate::meth;\n use crate::mir;\n use crate::mir::operand::OperandValue;\n@@ -451,10 +452,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let Some(llfn) = cx.declare_c_main(llfty) else {\n             // FIXME: We should be smart and show a better diagnostic here.\n             let span = cx.tcx().def_span(rust_main_def_id);\n-            cx.sess()\n-                .struct_span_err(span, \"entry symbol `main` declared multiple times\")\n-                .help(\"did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\")\n-                .emit();\n+            cx.sess().emit_err(errors::MultipleMainFunctions { span });\n             cx.sess().abort_if_errors();\n             bug!();\n         };\n@@ -595,8 +593,8 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 &metadata,\n                 &exported_symbols::metadata_symbol_name(tcx),\n             );\n-            if let Err(err) = std::fs::write(&file_name, data) {\n-                tcx.sess.fatal(&format!(\"error writing metadata object file: {}\", err));\n+            if let Err(error) = std::fs::write(&file_name, data) {\n+                tcx.sess.emit_fatal(errors::MetadataObjectFileWrite { error });\n             }\n             Some(CompiledModule {\n                 name: metadata_cgu_name,\n@@ -815,11 +813,7 @@ impl CrateInfo {\n         let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n-                tcx.sess.fatal(&format!(\n-                    \"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                    subsystem\n-                ));\n+                tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });\n             }\n             subsystem.to_string()\n         });"}, {"sha": "e1abb73a504a3bea8ce211910cc63bd15ffcbd75", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -1,10 +1,8 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_errors::struct_span_err;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n-use rustc_session::Session;\n use rustc_span::Span;\n \n use crate::base;\n@@ -193,10 +191,6 @@ pub fn shift_mask_val<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-pub fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n-    struct_span_err!(a, b, E0511, \"{}\", c).emit();\n-}\n-\n pub fn asm_const_to_str<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sp: Span,"}, {"sha": "1599ccbb2594c747e7ef31495e0c2171f5c06417", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -93,6 +93,7 @@ fn push_debuginfo_type_name<'tcx>(\n                     Err(e) => {\n                         // Computing the layout can still fail here, e.g. if the target architecture\n                         // cannot represent the type. See https://github.com/rust-lang/rust/issues/94961.\n+                        // FIXME: migrate once `rustc_middle::mir::interpret::InterpError` is translatable.\n                         tcx.sess.fatal(&format!(\"{}\", e));\n                     }\n                 }"}, {"sha": "d81252653dfe8094d9aafcf505075acb60a5f33c", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -6,7 +6,9 @@ use rustc_errors::{\n     IntoDiagnosticArg,\n };\n use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n use rustc_span::{Span, Symbol};\n+use rustc_type_ir::FloatTy;\n use std::borrow::Cow;\n use std::io::Error;\n use std::path::{Path, PathBuf};\n@@ -549,3 +551,432 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_multiple_main_functions)]\n+#[help]\n+pub struct MultipleMainFunctions {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_metadata_object_file_write)]\n+pub struct MetadataObjectFileWrite {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_windows_subsystem)]\n+pub struct InvalidWindowsSubsystem {\n+    pub subsystem: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_erroneous_constant)]\n+pub struct ErroneousConstant {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_polymorphic_constant_too_generic)]\n+pub struct PolymorphicConstantTooGeneric {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_shuffle_indices_evaluation)]\n+pub struct ShuffleIndicesEvaluation {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_missing_memory_ordering)]\n+pub struct MissingMemoryOrdering;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_atomic_ordering)]\n+pub struct UnknownAtomicOrdering;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_atomic_compare_exchange)]\n+pub struct AtomicCompareExchange;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unknown_atomic_operation)]\n+pub struct UnknownAtomicOperation;\n+\n+#[derive(Diagnostic)]\n+pub enum InvalidMonomorphization<'tcx> {\n+    #[diag(codegen_ssa_invalid_monomorphization_basic_integer_type, code = \"E0511\")]\n+    BasicIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_basic_float_type, code = \"E0511\")]\n+    BasicFloatType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_float_to_int_unchecked, code = \"E0511\")]\n+    FloatToIntUnchecked {\n+        #[primary_span]\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_floating_point_vector, code = \"E0511\")]\n+    FloatingPointVector {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        f_ty: FloatTy,\n+        in_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_floating_point_type, code = \"E0511\")]\n+    FloatingPointType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unrecognized_intrinsic, code = \"E0511\")]\n+    UnrecognizedIntrinsic {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_argument, code = \"E0511\")]\n+    SimdArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_input, code = \"E0511\")]\n+    SimdInput {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_first, code = \"E0511\")]\n+    SimdFirst {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_second, code = \"E0511\")]\n+    SimdSecond {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_third, code = \"E0511\")]\n+    SimdThird {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_return, code = \"E0511\")]\n+    SimdReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+    InvalidBitmask {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        mask_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+    ReturnLengthInputType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_second_argument_length, code = \"E0511\")]\n+    SecondArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_argument_length, code = \"E0511\")]\n+    ThirdArgumentLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        in_ty: Ty<'tcx>,\n+        arg_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+    ReturnIntegerType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+    SimdShuffle {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_length, code = \"E0511\")]\n+    ReturnLength {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_len: u64,\n+        ret_ty: Ty<'tcx>,\n+        out_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_element, code = \"E0511\")]\n+    ReturnElement {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_not_constant, code = \"E0511\")]\n+    ShuffleIndexNotConstant {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds, code = \"E0511\")]\n+    ShuffleIndexOutOfBounds {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        arg_idx: u64,\n+        total_len: u128,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_inserted_type, code = \"E0511\")]\n+    InsertedType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        out_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_return_type, code = \"E0511\")]\n+    ReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_return_type, code = \"E0511\")]\n+    ExpectedReturnType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+    MismatchedLengths {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        m_len: u64,\n+        v_len: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_mask_type, code = \"E0511\")]\n+    MaskType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_vector_argument, code = \"E0511\")]\n+    VectorArgument {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cannot_return, code = \"E0511\")]\n+    CannotReturn {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ret_ty: Ty<'tcx>,\n+        expected_int_bits: u64,\n+        expected_bytes: u64,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_element_type, code = \"E0511\")]\n+    ExpectedElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        second_arg: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        in_ty: Ty<'tcx>,\n+        mutability: ExpectedPointerMutability,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_third_arg_element_type, code = \"E0511\")]\n+    ThirdArgElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        third_arg: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size, code = \"E0511\")]\n+    UnsupportedSymbolOfSize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        size: u64,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_symbol, code = \"E0511\")]\n+    UnsupportedSymbol {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        symbol: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_cast_fat_pointer, code = \"E0511\")]\n+    CastFatPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_pointer, code = \"E0511\")]\n+    ExpectedPointer {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_usize, code = \"E0511\")]\n+    ExpectedUsize {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        ty: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+    UnsupportedCast {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+        ret_ty: Ty<'tcx>,\n+        out_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+    UnsupportedOperation {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        in_ty: Ty<'tcx>,\n+        in_elem: Ty<'tcx>,\n+    },\n+\n+    #[diag(codegen_ssa_invalid_monomorphization_expected_vector_element_type, code = \"E0511\")]\n+    ExpectedVectorElementType {\n+        #[primary_span]\n+        span: Span,\n+        name: Symbol,\n+        expected_element: Ty<'tcx>,\n+        vector_type: Ty<'tcx>,\n+    },\n+}\n+\n+pub enum ExpectedPointerMutability {\n+    Mut,\n+    Not,\n+}\n+\n+impl IntoDiagnosticArg for ExpectedPointerMutability {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        match self {\n+            ExpectedPointerMutability::Mut => DiagnosticArgValue::Str(Cow::Borrowed(\"*mut\")),\n+            ExpectedPointerMutability::Not => DiagnosticArgValue::Str(Cow::Borrowed(\"*_\")),\n+        }\n+    }\n+}"}, {"sha": "14fe84a146da0792144787ee67a46f049a46dfa9", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use crate::mir::operand::OperandRef;\n use crate::traits::*;\n use rustc_middle::mir;\n@@ -44,10 +45,14 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.cx.tcx().const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).map_err(|err| {\n             match err {\n                 ErrorHandled::Reported(_) => {\n-                    self.cx.tcx().sess.span_err(constant.span, \"erroneous constant encountered\");\n+                    self.cx.tcx().sess.emit_err(errors::ErroneousConstant { span: constant.span });\n                 }\n                 ErrorHandled::TooGeneric => {\n-                    span_bug!(constant.span, \"codegen encountered polymorphic constant: {:?}\", err);\n+                    self.cx\n+                        .tcx()\n+                        .sess\n+                        .diagnostic()\n+                        .emit_bug(errors::PolymorphicConstantTooGeneric { span: constant.span });\n                 }\n             }\n             err\n@@ -87,7 +92,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 (llval, c.ty())\n             })\n             .unwrap_or_else(|_| {\n-                bx.tcx().sess.span_err(span, \"could not evaluate shuffle_indices at compile time\");\n+                bx.tcx().sess.emit_err(errors::ShuffleIndicesEvaluation { span });\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(ty);\n                 let llty = bx.backend_type(bx.layout_of(ty));"}, {"sha": "766dc74cbbb6a39e66dd5dbacd6c82b80a821125", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -1,7 +1,9 @@\n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n use super::FunctionCx;\n-use crate::common::{span_invalid_monomorphization_error, IntPredicate};\n+use crate::common::IntPredicate;\n+use crate::errors;\n+use crate::errors::InvalidMonomorphization;\n use crate::glue;\n use crate::meth;\n use crate::traits::*;\n@@ -305,15 +307,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                name, ty\n-                            ),\n-                        );\n+                        bx.tcx().sess.emit_err(InvalidMonomorphization::BasicIntegerType { span, name, ty });\n                         return;\n                     }\n                 }\n@@ -329,45 +323,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         _ => bug!(),\n                     },\n                     None => {\n-                        span_invalid_monomorphization_error(\n-                            bx.tcx().sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\",\n-                                name, arg_tys[0]\n-                            ),\n-                        );\n+                        bx.tcx().sess.emit_err(InvalidMonomorphization::BasicFloatType { span, name, ty: arg_tys[0] });\n                         return;\n                     }\n                 }\n             }\n \n             sym::float_to_int_unchecked => {\n                 if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                  intrinsic: expected basic float type, \\\n-                                  found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::FloatToIntUnchecked { span, ty: arg_tys[0] });\n                     return;\n                 }\n                 let Some((_width, signed)) = int_type_width_signed(ret_ty, bx.tcx()) else {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                    intrinsic:  expected basic integer type, \\\n-                                    found `{}`\",\n-                            ret_ty\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::FloatToIntUnchecked { span, ty: ret_ty });\n                     return;\n                 };\n                 if signed {\n@@ -402,7 +370,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n \n                 let Some((instruction, ordering)) = atomic.split_once('_') else {\n-                    bx.sess().fatal(\"Atomic intrinsic missing memory ordering\");\n+                    bx.sess().emit_fatal(errors::MissingMemoryOrdering);\n                 };\n \n                 let parse_ordering = |bx: &Bx, s| match s {\n@@ -412,25 +380,17 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     \"release\" => Release,\n                     \"acqrel\" => AcquireRelease,\n                     \"seqcst\" => SequentiallyConsistent,\n-                    _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    _ => bx.sess().emit_fatal(errors::UnknownAtomicOrdering),\n                 };\n \n                 let invalid_monomorphization = |ty| {\n-                    span_invalid_monomorphization_error(\n-                        bx.tcx().sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\",\n-                            name, ty\n-                        ),\n-                    );\n+                    bx.tcx().sess.emit_err(InvalidMonomorphization::BasicIntegerType { span, name, ty });\n                 };\n \n                 match instruction {\n                     \"cxchg\" | \"cxchgweak\" => {\n                         let Some((success, failure)) = ordering.split_once('_') else {\n-                            bx.sess().fatal(\"Atomic compare-exchange intrinsic missing failure memory ordering\");\n+                            bx.sess().emit_fatal(errors::AtomicCompareExchange);\n                         };\n                         let ty = substs.type_at(0);\n                         if int_type_width_signed(ty, bx.tcx()).is_some() || ty.is_unsafe_ptr() {\n@@ -529,7 +489,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             \"min\" => AtomicRmwBinOp::AtomicMin,\n                             \"umax\" => AtomicRmwBinOp::AtomicUMax,\n                             \"umin\" => AtomicRmwBinOp::AtomicUMin,\n-                            _ => bx.sess().fatal(\"unknown atomic operation\"),\n+                            _ => bx.sess().emit_fatal(errors::UnknownAtomicOperation),\n                         };\n \n                         let ty = substs.type_at(0);"}, {"sha": "c8c7afb5f919632b8555682136978d0ea4dc4c99", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -192,3 +192,102 @@ codegen_ssa_unknown_archive_kind =\n     Don't know how to build archive of type: {$kind}\n \n codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n+codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n+    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n+\n+codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n+\n+codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n+\n+codegen_ssa_erroneous_constant = erroneous constant encountered\n+\n+codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n+\n+codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n+\n+codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n+\n+codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n+\n+codegen_ssa_unknown_atomic_operation = unknown atomic operation\n+\n+codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n+\n+codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n+\n+codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n+\n+codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n+\n+codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n+\n+codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n+\n+codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n+\n+codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type"}, {"sha": "cadd53fbd8356b3409ec98e7d9eaac9cfb54fcc4", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -17,6 +17,7 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n unicode-width = \"0.1.4\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.9\""}, {"sha": "cbfee582d871f2c5925b0e8449e60dad19749212", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -1,7 +1,7 @@\n use crate::diagnostic::IntoDiagnosticArg;\n use crate::{\n     Diagnostic, DiagnosticId, DiagnosticMessage, DiagnosticStyledString, ErrorGuaranteed,\n-    SubdiagnosticMessage,\n+    ExplicitBug, SubdiagnosticMessage,\n };\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n@@ -12,6 +12,7 @@ use std::borrow::Cow;\n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n+use std::panic;\n use std::thread::panicking;\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n@@ -308,6 +309,58 @@ impl EmissionGuarantee for Noted {\n     }\n }\n \n+/// Marker type which enables implementation of `create_bug` and `emit_bug` functions for\n+/// bug struct diagnostics.\n+#[derive(Copy, Clone)]\n+pub struct Bug;\n+\n+impl<'a> DiagnosticBuilder<'a, Bug> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n+    pub(crate) fn new_bug(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Bug, None, message);\n+        Self::new_diagnostic_bug(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_bug(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic bug\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for Bug {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+        // Then panic. No need to return the marker type.\n+        panic::panic_any(ExplicitBug);\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_bug(handler, msg)\n+    }\n+}\n+\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`]."}, {"sha": "794b6efcc2b246674b452ad0f4e3aa3e120b2b6a", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -9,6 +9,7 @@ use rustc_span::edition::Edition;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n+use rustc_type_ir as type_ir;\n use std::borrow::Cow;\n use std::fmt;\n use std::num::ParseIntError;\n@@ -170,6 +171,12 @@ impl IntoDiagnosticArg for ast::token::TokenKind {\n     }\n }\n \n+impl IntoDiagnosticArg for type_ir::FloatTy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(self.name_str()))\n+    }\n+}\n+\n impl IntoDiagnosticArg for Level {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Borrowed(match self {"}, {"sha": "b4d23e96f8f45ca06a991bbfac73fa5622a0be41", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/771cfa5581fd245b0d45e839e791b10e01ebb8a7/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=771cfa5581fd245b0d45e839e791b10e01ebb8a7", "patch": "@@ -1133,6 +1133,20 @@ impl Handler {\n         self.create_fatal(fatal).emit()\n     }\n \n+    pub fn create_bug<'a>(\n+        &'a self,\n+        bug: impl IntoDiagnostic<'a, diagnostic_builder::Bug>,\n+    ) -> DiagnosticBuilder<'a, diagnostic_builder::Bug> {\n+        bug.into_diagnostic(self)\n+    }\n+\n+    pub fn emit_bug<'a>(\n+        &'a self,\n+        bug: impl IntoDiagnostic<'a, diagnostic_builder::Bug>,\n+    ) -> diagnostic_builder::Bug {\n+        self.create_bug(bug).emit()\n+    }\n+\n     fn emit_diag_at_span(\n         &self,\n         mut diag: Diagnostic,"}]}