{"sha": "6d6e0b8f21385d008eb6161b56a98da2eac141a2", "node_id": "C_kwDOAAsO6NoAKDZkNmUwYjhmMjEzODVkMDA4ZWI2MTYxYjU2YTk4ZGEyZWFjMTQxYTI", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-21T13:52:11Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-21T13:52:11Z"}, "message": "Generate ast nodes for each ast trait", "tree": {"sha": "c0fa502338c4b42f533d991ca8e147d8b2a17470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0fa502338c4b42f533d991ca8e147d8b2a17470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d6e0b8f21385d008eb6161b56a98da2eac141a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6e0b8f21385d008eb6161b56a98da2eac141a2", "html_url": "https://github.com/rust-lang/rust/commit/6d6e0b8f21385d008eb6161b56a98da2eac141a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d6e0b8f21385d008eb6161b56a98da2eac141a2/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba84b91e7813762fa615544744d3c6139290f34c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba84b91e7813762fa615544744d3c6139290f34c", "html_url": "https://github.com/rust-lang/rust/commit/ba84b91e7813762fa615544744d3c6139290f34c"}], "stats": {"total": 531, "additions": 480, "deletions": 51}, "files": [{"sha": "f5a8da249389b5d2e4744c4718c391146546403f", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6d6e0b8f21385d008eb6161b56a98da2eac141a2", "patch": "@@ -481,7 +481,7 @@ impl<'db> SemanticsImpl<'db> {\n         )\n     }\n \n-    // This might not be the correct way to due this, but it works for now\n+    // This might not be the correct way to do this, but it works for now\n     fn descend_node_into_attributes<N: AstNode>(&self, node: N) -> SmallVec<[N; 1]> {\n         let mut res = smallvec![];\n         let tokens = (|| {"}, {"sha": "0470b9510f3287f0efe35a14f11be99da6f82ed4", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=6d6e0b8f21385d008eb6161b56a98da2eac141a2", "patch": "@@ -411,47 +411,47 @@ impl AttrsWithOwner {\n                 let file_id = id.parent.file_id(db);\n                 let root = db.parse_or_expand(file_id).unwrap();\n                 let owner = match &map[id.local_id] {\n-                    Either::Left(it) => ast::AttrsOwnerNode::new(it.to_node(&root)),\n-                    Either::Right(it) => ast::AttrsOwnerNode::new(it.to_node(&root)),\n+                    Either::Left(it) => ast::DynAttrsOwner::new(it.to_node(&root)),\n+                    Either::Right(it) => ast::DynAttrsOwner::new(it.to_node(&root)),\n                 };\n                 InFile::new(file_id, owner)\n             }\n             AttrDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             },\n-            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             AttrDefId::EnumVariantId(id) => {\n                 let map = db.variants_attrs_source_map(id.parent);\n                 let file_id = id.parent.lookup(db).id.file_id();\n                 let root = db.parse_or_expand(file_id).unwrap();\n-                InFile::new(file_id, ast::AttrsOwnerNode::new(map[id.local_id].to_node(&root)))\n+                InFile::new(file_id, ast::DynAttrsOwner::new(map[id.local_id].to_node(&root)))\n             }\n-            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n-            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n+            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             AttrDefId::MacroDefId(id) => id.ast_id().either(\n-                |it| it.with_value(ast::AttrsOwnerNode::new(it.to_node(db.upcast()))),\n-                |it| it.with_value(ast::AttrsOwnerNode::new(it.to_node(db.upcast()))),\n+                |it| it.with_value(ast::DynAttrsOwner::new(it.to_node(db.upcast()))),\n+                |it| it.with_value(ast::DynAttrsOwner::new(it.to_node(db.upcast()))),\n             ),\n-            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::DynAttrsOwner::new),\n             AttrDefId::GenericParamId(id) => match id {\n                 GenericParamId::TypeParamId(id) => {\n                     id.parent.child_source(db).map(|source| match &source[id.local_id] {\n-                        Either::Left(id) => ast::AttrsOwnerNode::new(id.clone()),\n-                        Either::Right(id) => ast::AttrsOwnerNode::new(id.clone()),\n+                        Either::Left(id) => ast::DynAttrsOwner::new(id.clone()),\n+                        Either::Right(id) => ast::DynAttrsOwner::new(id.clone()),\n                     })\n                 }\n                 GenericParamId::LifetimeParamId(id) => id\n                     .parent\n                     .child_source(db)\n-                    .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+                    .map(|source| ast::DynAttrsOwner::new(source[id.local_id].clone())),\n                 GenericParamId::ConstParamId(id) => id\n                     .parent\n                     .child_source(db)\n-                    .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+                    .map(|source| ast::DynAttrsOwner::new(source[id.local_id].clone())),\n             },\n         };\n "}, {"sha": "7c9200f56888ed22ea75c852e2a11362e791dcba", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=6d6e0b8f21385d008eb6161b56a98da2eac141a2", "patch": "@@ -21,8 +21,8 @@ pub use self::{\n     expr_ext::{ArrayExprKind, Effect, ElseBranch, LiteralKind},\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n-        AttrKind, AttrsOwnerNode, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind,\n-        SelfParamKind, SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n+        AttrKind, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind, SelfParamKind,\n+        SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n     },\n     operators::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp},\n     token_ext::{"}, {"sha": "5c80dc8346f245b17c57ad4bba31078474dc49aa", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=6d6e0b8f21385d008eb6161b56a98da2eac141a2", "patch": "@@ -1445,6 +1445,46 @@ pub enum GenericParam {\n     TypeParam(TypeParam),\n }\n impl ast::AttrsOwner for GenericParam {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynArgListOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::ArgListOwner for DynArgListOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynAttrsOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for DynAttrsOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynGenericParamsOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::GenericParamsOwner for DynGenericParamsOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynLoopBodyOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::LoopBodyOwner for DynLoopBodyOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynModuleItemOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::ModuleItemOwner for DynModuleItemOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynNameOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::NameOwner for DynNameOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynTypeBoundsOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::TypeBoundsOwner for DynTypeBoundsOwner {}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynVisibilityOwner {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::VisibilityOwner for DynVisibilityOwner {}\n impl AstNode for Name {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -3564,6 +3604,364 @@ impl AstNode for GenericParam {\n         }\n     }\n }\n+impl DynArgListOwner {\n+    #[inline]\n+    pub fn new<T: ast::ArgListOwner>(node: T) -> DynArgListOwner {\n+        DynArgListOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynArgListOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CALL_EXPR | METHOD_CALL_EXPR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            CALL_EXPR => DynArgListOwner { syntax },\n+            METHOD_CALL_EXPR => DynArgListOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynAttrsOwner {\n+    #[inline]\n+    pub fn new<T: ast::AttrsOwner>(node: T) -> DynAttrsOwner {\n+        DynAttrsOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynAttrsOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_CALL\n+            | SOURCE_FILE\n+            | CONST\n+            | ENUM\n+            | EXTERN_BLOCK\n+            | EXTERN_CRATE\n+            | FN\n+            | IMPL\n+            | MACRO_RULES\n+            | MACRO_DEF\n+            | MODULE\n+            | STATIC\n+            | STRUCT\n+            | TRAIT\n+            | TYPE_ALIAS\n+            | UNION\n+            | USE\n+            | ITEM_LIST\n+            | BLOCK_EXPR\n+            | SELF_PARAM\n+            | PARAM\n+            | RECORD_FIELD\n+            | TUPLE_FIELD\n+            | VARIANT\n+            | ASSOC_ITEM_LIST\n+            | EXTERN_ITEM_LIST\n+            | CONST_PARAM\n+            | LIFETIME_PARAM\n+            | TYPE_PARAM\n+            | EXPR_STMT\n+            | LET_STMT\n+            | ARRAY_EXPR\n+            | AWAIT_EXPR\n+            | BIN_EXPR\n+            | BOX_EXPR\n+            | BREAK_EXPR\n+            | CALL_EXPR\n+            | CAST_EXPR\n+            | CLOSURE_EXPR\n+            | CONTINUE_EXPR\n+            | EFFECT_EXPR\n+            | FIELD_EXPR\n+            | FOR_EXPR\n+            | IF_EXPR\n+            | INDEX_EXPR\n+            | LITERAL\n+            | LOOP_EXPR\n+            | MATCH_EXPR\n+            | METHOD_CALL_EXPR\n+            | PAREN_EXPR\n+            | PATH_EXPR\n+            | PREFIX_EXPR\n+            | RANGE_EXPR\n+            | REF_EXPR\n+            | RETURN_EXPR\n+            | TRY_EXPR\n+            | TUPLE_EXPR\n+            | WHILE_EXPR\n+            | YIELD_EXPR\n+            | RECORD_EXPR_FIELD_LIST\n+            | RECORD_EXPR_FIELD\n+            | MATCH_ARM_LIST\n+            | MATCH_ARM\n+            | IDENT_PAT\n+            | RECORD_PAT_FIELD => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            MACRO_CALL => DynAttrsOwner { syntax },\n+            SOURCE_FILE => DynAttrsOwner { syntax },\n+            CONST => DynAttrsOwner { syntax },\n+            ENUM => DynAttrsOwner { syntax },\n+            EXTERN_BLOCK => DynAttrsOwner { syntax },\n+            EXTERN_CRATE => DynAttrsOwner { syntax },\n+            FN => DynAttrsOwner { syntax },\n+            IMPL => DynAttrsOwner { syntax },\n+            MACRO_RULES => DynAttrsOwner { syntax },\n+            MACRO_DEF => DynAttrsOwner { syntax },\n+            MODULE => DynAttrsOwner { syntax },\n+            STATIC => DynAttrsOwner { syntax },\n+            STRUCT => DynAttrsOwner { syntax },\n+            TRAIT => DynAttrsOwner { syntax },\n+            TYPE_ALIAS => DynAttrsOwner { syntax },\n+            UNION => DynAttrsOwner { syntax },\n+            USE => DynAttrsOwner { syntax },\n+            ITEM_LIST => DynAttrsOwner { syntax },\n+            BLOCK_EXPR => DynAttrsOwner { syntax },\n+            SELF_PARAM => DynAttrsOwner { syntax },\n+            PARAM => DynAttrsOwner { syntax },\n+            RECORD_FIELD => DynAttrsOwner { syntax },\n+            TUPLE_FIELD => DynAttrsOwner { syntax },\n+            VARIANT => DynAttrsOwner { syntax },\n+            ASSOC_ITEM_LIST => DynAttrsOwner { syntax },\n+            EXTERN_ITEM_LIST => DynAttrsOwner { syntax },\n+            CONST_PARAM => DynAttrsOwner { syntax },\n+            LIFETIME_PARAM => DynAttrsOwner { syntax },\n+            TYPE_PARAM => DynAttrsOwner { syntax },\n+            EXPR_STMT => DynAttrsOwner { syntax },\n+            LET_STMT => DynAttrsOwner { syntax },\n+            ARRAY_EXPR => DynAttrsOwner { syntax },\n+            AWAIT_EXPR => DynAttrsOwner { syntax },\n+            BIN_EXPR => DynAttrsOwner { syntax },\n+            BOX_EXPR => DynAttrsOwner { syntax },\n+            BREAK_EXPR => DynAttrsOwner { syntax },\n+            CALL_EXPR => DynAttrsOwner { syntax },\n+            CAST_EXPR => DynAttrsOwner { syntax },\n+            CLOSURE_EXPR => DynAttrsOwner { syntax },\n+            CONTINUE_EXPR => DynAttrsOwner { syntax },\n+            EFFECT_EXPR => DynAttrsOwner { syntax },\n+            FIELD_EXPR => DynAttrsOwner { syntax },\n+            FOR_EXPR => DynAttrsOwner { syntax },\n+            IF_EXPR => DynAttrsOwner { syntax },\n+            INDEX_EXPR => DynAttrsOwner { syntax },\n+            LITERAL => DynAttrsOwner { syntax },\n+            LOOP_EXPR => DynAttrsOwner { syntax },\n+            MATCH_EXPR => DynAttrsOwner { syntax },\n+            METHOD_CALL_EXPR => DynAttrsOwner { syntax },\n+            PAREN_EXPR => DynAttrsOwner { syntax },\n+            PATH_EXPR => DynAttrsOwner { syntax },\n+            PREFIX_EXPR => DynAttrsOwner { syntax },\n+            RANGE_EXPR => DynAttrsOwner { syntax },\n+            REF_EXPR => DynAttrsOwner { syntax },\n+            RETURN_EXPR => DynAttrsOwner { syntax },\n+            TRY_EXPR => DynAttrsOwner { syntax },\n+            TUPLE_EXPR => DynAttrsOwner { syntax },\n+            WHILE_EXPR => DynAttrsOwner { syntax },\n+            YIELD_EXPR => DynAttrsOwner { syntax },\n+            RECORD_EXPR_FIELD_LIST => DynAttrsOwner { syntax },\n+            RECORD_EXPR_FIELD => DynAttrsOwner { syntax },\n+            MATCH_ARM_LIST => DynAttrsOwner { syntax },\n+            MATCH_ARM => DynAttrsOwner { syntax },\n+            IDENT_PAT => DynAttrsOwner { syntax },\n+            RECORD_PAT_FIELD => DynAttrsOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynGenericParamsOwner {\n+    #[inline]\n+    pub fn new<T: ast::GenericParamsOwner>(node: T) -> DynGenericParamsOwner {\n+        DynGenericParamsOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynGenericParamsOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ENUM | FN | IMPL | STRUCT | TRAIT | TYPE_ALIAS | UNION => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            ENUM => DynGenericParamsOwner { syntax },\n+            FN => DynGenericParamsOwner { syntax },\n+            IMPL => DynGenericParamsOwner { syntax },\n+            STRUCT => DynGenericParamsOwner { syntax },\n+            TRAIT => DynGenericParamsOwner { syntax },\n+            TYPE_ALIAS => DynGenericParamsOwner { syntax },\n+            UNION => DynGenericParamsOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynLoopBodyOwner {\n+    #[inline]\n+    pub fn new<T: ast::LoopBodyOwner>(node: T) -> DynLoopBodyOwner {\n+        DynLoopBodyOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynLoopBodyOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            FOR_EXPR | LOOP_EXPR | WHILE_EXPR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            FOR_EXPR => DynLoopBodyOwner { syntax },\n+            LOOP_EXPR => DynLoopBodyOwner { syntax },\n+            WHILE_EXPR => DynLoopBodyOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynModuleItemOwner {\n+    #[inline]\n+    pub fn new<T: ast::ModuleItemOwner>(node: T) -> DynModuleItemOwner {\n+        DynModuleItemOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynModuleItemOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            MACRO_ITEMS => DynModuleItemOwner { syntax },\n+            SOURCE_FILE => DynModuleItemOwner { syntax },\n+            ITEM_LIST => DynModuleItemOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynNameOwner {\n+    #[inline]\n+    pub fn new<T: ast::NameOwner>(node: T) -> DynNameOwner {\n+        DynNameOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynNameOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONST | ENUM | FN | MACRO_RULES | MACRO_DEF | MODULE | STATIC | STRUCT | TRAIT\n+            | TYPE_ALIAS | UNION | RENAME | SELF_PARAM | RECORD_FIELD | VARIANT | CONST_PARAM\n+            | TYPE_PARAM | IDENT_PAT => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            CONST => DynNameOwner { syntax },\n+            ENUM => DynNameOwner { syntax },\n+            FN => DynNameOwner { syntax },\n+            MACRO_RULES => DynNameOwner { syntax },\n+            MACRO_DEF => DynNameOwner { syntax },\n+            MODULE => DynNameOwner { syntax },\n+            STATIC => DynNameOwner { syntax },\n+            STRUCT => DynNameOwner { syntax },\n+            TRAIT => DynNameOwner { syntax },\n+            TYPE_ALIAS => DynNameOwner { syntax },\n+            UNION => DynNameOwner { syntax },\n+            RENAME => DynNameOwner { syntax },\n+            SELF_PARAM => DynNameOwner { syntax },\n+            RECORD_FIELD => DynNameOwner { syntax },\n+            VARIANT => DynNameOwner { syntax },\n+            CONST_PARAM => DynNameOwner { syntax },\n+            TYPE_PARAM => DynNameOwner { syntax },\n+            IDENT_PAT => DynNameOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynTypeBoundsOwner {\n+    #[inline]\n+    pub fn new<T: ast::TypeBoundsOwner>(node: T) -> DynTypeBoundsOwner {\n+        DynTypeBoundsOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynTypeBoundsOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            ASSOC_TYPE_ARG | TRAIT | TYPE_ALIAS | LIFETIME_PARAM | TYPE_PARAM | WHERE_PRED => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            ASSOC_TYPE_ARG => DynTypeBoundsOwner { syntax },\n+            TRAIT => DynTypeBoundsOwner { syntax },\n+            TYPE_ALIAS => DynTypeBoundsOwner { syntax },\n+            LIFETIME_PARAM => DynTypeBoundsOwner { syntax },\n+            TYPE_PARAM => DynTypeBoundsOwner { syntax },\n+            WHERE_PRED => DynTypeBoundsOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n+impl DynVisibilityOwner {\n+    #[inline]\n+    pub fn new<T: ast::VisibilityOwner>(node: T) -> DynVisibilityOwner {\n+        DynVisibilityOwner { syntax: node.syntax().clone() }\n+    }\n+}\n+impl AstNode for DynVisibilityOwner {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            CONST | ENUM | EXTERN_CRATE | FN | IMPL | MACRO_RULES | MACRO_DEF | MODULE | STATIC\n+            | STRUCT | TRAIT | TYPE_ALIAS | UNION | USE | RECORD_FIELD | TUPLE_FIELD | VARIANT => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            CONST => DynVisibilityOwner { syntax },\n+            ENUM => DynVisibilityOwner { syntax },\n+            EXTERN_CRATE => DynVisibilityOwner { syntax },\n+            FN => DynVisibilityOwner { syntax },\n+            IMPL => DynVisibilityOwner { syntax },\n+            MACRO_RULES => DynVisibilityOwner { syntax },\n+            MACRO_DEF => DynVisibilityOwner { syntax },\n+            MODULE => DynVisibilityOwner { syntax },\n+            STATIC => DynVisibilityOwner { syntax },\n+            STRUCT => DynVisibilityOwner { syntax },\n+            TRAIT => DynVisibilityOwner { syntax },\n+            TYPE_ALIAS => DynVisibilityOwner { syntax },\n+            UNION => DynVisibilityOwner { syntax },\n+            USE => DynVisibilityOwner { syntax },\n+            RECORD_FIELD => DynVisibilityOwner { syntax },\n+            TUPLE_FIELD => DynVisibilityOwner { syntax },\n+            VARIANT => DynVisibilityOwner { syntax },\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl std::fmt::Display for GenericArg {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "1dce67da639e235ba3ce5b0e08e2d71ae95ce23a", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=6d6e0b8f21385d008eb6161b56a98da2eac141a2", "patch": "@@ -167,36 +167,6 @@ impl NameOwner for Macro {\n \n impl AttrsOwner for Macro {}\n \n-/// Basically an owned `dyn AttrsOwner` without extra boxing.\n-pub struct AttrsOwnerNode {\n-    node: SyntaxNode,\n-}\n-\n-impl AttrsOwnerNode {\n-    pub fn new<N: AttrsOwner>(node: N) -> Self {\n-        AttrsOwnerNode { node: node.syntax().clone() }\n-    }\n-}\n-\n-impl AttrsOwner for AttrsOwnerNode {}\n-impl AstNode for AttrsOwnerNode {\n-    fn can_cast(_: SyntaxKind) -> bool\n-    where\n-        Self: Sized,\n-    {\n-        false\n-    }\n-    fn cast(_: SyntaxNode) -> Option<Self>\n-    where\n-        Self: Sized,\n-    {\n-        None\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.node\n-    }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,"}, {"sha": "71171c859b1cf468780f0696ba0fa1e690d92b3d", "filename": "crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6e0b8f21385d008eb6161b56a98da2eac141a2/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=6d6e0b8f21385d008eb6161b56a98da2eac141a2", "patch": "@@ -8,6 +8,7 @@ use std::{\n     fmt::Write,\n };\n \n+use itertools::Itertools;\n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n use ungrammar::{rust_grammar, Grammar, Rule};\n@@ -208,6 +209,64 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n         })\n         .unzip();\n \n+    let (dyn_node_defs, dyn_node_boilerplate_impls): (Vec<_>, Vec<_>) = grammar\n+        .nodes\n+        .iter()\n+        .flat_map(|node| node.traits.iter().map(move |t| (t, node)))\n+        .into_group_map()\n+        .into_iter()\n+        .sorted_by_key(|(k, _)| k.clone())\n+        .map(|(trait_name, nodes)| {\n+            let name = format_ident!(\"Dyn{}\", trait_name);\n+            let trait_name = format_ident!(\"{}\", trait_name);\n+            let kinds: Vec<_> = nodes\n+                .iter()\n+                .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.name.to_string())))\n+                .collect();\n+\n+            (\n+                quote! {\n+                    #[pretty_doc_comment_placeholder_workaround]\n+                    #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                    pub struct #name {\n+                        pub(crate) syntax: SyntaxNode,\n+                    }\n+                    impl ast::#trait_name for #name {}\n+                },\n+                quote! {\n+                    impl #name {\n+                        #[inline]\n+                        pub fn new<T: ast::#trait_name>(node: T) -> #name {\n+                            #name {\n+                                syntax: node.syntax().clone()\n+                            }\n+                        }\n+                    }\n+                    impl AstNode for #name {\n+                        fn can_cast(kind: SyntaxKind) -> bool {\n+                            match kind {\n+                                #(#kinds)|* => true,\n+                                _ => false,\n+                            }\n+                        }\n+                        fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                            let res = match syntax.kind() {\n+                                #(\n+                                #kinds => #name { syntax },\n+                                )*\n+                                _ => return None,\n+                            };\n+                            Some(res)\n+                        }\n+                        fn syntax(&self) -> &SyntaxNode {\n+                            &self.syntax\n+                        }\n+                    }\n+                },\n+            )\n+        })\n+        .unzip();\n+\n     let enum_names = grammar.enums.iter().map(|it| &it.name);\n     let node_names = grammar.nodes.iter().map(|it| &it.name);\n \n@@ -244,8 +303,10 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n \n         #(#node_defs)*\n         #(#enum_defs)*\n+        #(#dyn_node_defs)*\n         #(#node_boilerplate_impls)*\n         #(#enum_boilerplate_impls)*\n+        #(#dyn_node_boilerplate_impls)*\n         #(#display_impls)*\n     };\n "}]}