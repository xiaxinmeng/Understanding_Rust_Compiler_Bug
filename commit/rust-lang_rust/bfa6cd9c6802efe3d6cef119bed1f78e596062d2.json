{"sha": "bfa6cd9c6802efe3d6cef119bed1f78e596062d2", "node_id": "C_kwDOAAsO6NoAKGJmYTZjZDljNjgwMmVmZTNkNmNlZjExOWJlZDFmNzhlNTk2MDYyZDI", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-06-19T22:37:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-19T22:37:42Z"}, "message": "Rollup merge of #98225 - bjorn3:stable_target_json_hash, r=nagisa\n\nMake debug_triple depend on target json file content rather than file path\n\nThis ensures that changes to target json files will force a recompilation. And more importantly that moving the files doesn't force a recompilation.\n\nThis should fix https://github.com/Rust-for-Linux/linux/issues/792 (cc ``@ojeda)``", "tree": {"sha": "ebc37af8c86354e3fea63cdd955244c15cae172d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebc37af8c86354e3fea63cdd955244c15cae172d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfa6cd9c6802efe3d6cef119bed1f78e596062d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJir6U2CRBK7hj4Ov3rIwAA/yAIAFJu6yW7THzFSHR8ZYIrPRRp\noIYUYwTLPoSqJLWkSjNew7BvajoLioyFzxeDCcSHD+rAf5dhPwpc6EHvKL9YTF8S\nhYSBGZc8FnXfoBm5P51YZ+B31nAkVVfh+74NxxHywycbOWVE7WtgjNsMQe3gvTHd\nJ/1/yNpuELhgjt3xSBAryd+hgsEFQ1TaJ/US+3tA9209ltBBcFDvygynEjfYjV5D\n2ZVvfknLuEUAZdVJD9HWCwcRY5kwJ1T8ICA4lyg564pHNbRkFgFIHlmN2iMH6a/q\n+oOmq4W3yC/4xxCx8afD5ghLqZNsXtVs5hK+NEwZqmuT6/TRAtEvjlpcIU31tuc=\n=hUjA\n-----END PGP SIGNATURE-----\n", "payload": "tree ebc37af8c86354e3fea63cdd955244c15cae172d\nparent 77316a4aaa0029481397ff2e43f57e60d5226569\nparent b4b536d34d8d2371a4be95a2b294bbf0088807b7\nauthor Yuki Okushi <jtitor@2k36.org> 1655678262 +0900\ncommitter GitHub <noreply@github.com> 1655678262 +0900\n\nRollup merge of #98225 - bjorn3:stable_target_json_hash, r=nagisa\n\nMake debug_triple depend on target json file content rather than file path\n\nThis ensures that changes to target json files will force a recompilation. And more importantly that moving the files doesn't force a recompilation.\n\nThis should fix https://github.com/Rust-for-Linux/linux/issues/792 (cc ``@ojeda)``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa6cd9c6802efe3d6cef119bed1f78e596062d2", "html_url": "https://github.com/rust-lang/rust/commit/bfa6cd9c6802efe3d6cef119bed1f78e596062d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfa6cd9c6802efe3d6cef119bed1f78e596062d2/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77316a4aaa0029481397ff2e43f57e60d5226569", "url": "https://api.github.com/repos/rust-lang/rust/commits/77316a4aaa0029481397ff2e43f57e60d5226569", "html_url": "https://github.com/rust-lang/rust/commit/77316a4aaa0029481397ff2e43f57e60d5226569"}, {"sha": "b4b536d34d8d2371a4be95a2b294bbf0088807b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b536d34d8d2371a4be95a2b294bbf0088807b7", "html_url": "https://github.com/rust-lang/rust/commit/b4b536d34d8d2371a4be95a2b294bbf0088807b7"}], "stats": {"total": 128, "additions": 101, "deletions": 27}, "files": [{"sha": "fd0c3f36e7299fbd7072f709cf5325e8e5dd57c7", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 99, "deletions": 25, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bfa6cd9c6802efe3d6cef119bed1f78e596062d2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa6cd9c6802efe3d6cef119bed1f78e596062d2/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=bfa6cd9c6802efe3d6cef119bed1f78e596062d2", "patch": "@@ -39,11 +39,13 @@ use crate::json::{Json, ToJson};\n use crate::spec::abi::{lookup as lookup_abi, Abi};\n use crate::spec::crt_objects::{CrtObjects, CrtObjectsFallback};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::symbol::{sym, Symbol};\n use serde_json::Value;\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::convert::TryFrom;\n+use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n use std::ops::{Deref, DerefMut};\n use std::path::{Path, PathBuf};\n@@ -2183,7 +2185,7 @@ impl Target {\n             TargetTriple::TargetTriple(ref target_triple) => {\n                 load_builtin(target_triple).expect(\"built-in target\")\n             }\n-            TargetTriple::TargetPath(..) => {\n+            TargetTriple::TargetJson { .. } => {\n                 panic!(\"built-in targets doens't support target-paths\")\n             }\n         }\n@@ -2248,11 +2250,9 @@ impl Target {\n \n                 Err(format!(\"Could not find specification for target {:?}\", target_triple))\n             }\n-            TargetTriple::TargetPath(ref target_path) => {\n-                if target_path.is_file() {\n-                    return load_file(&target_path);\n-                }\n-                Err(format!(\"Target path {:?} is not a valid file\", target_path))\n+            TargetTriple::TargetJson { ref contents, .. } => {\n+                let obj = serde_json::from_str(contents).map_err(|e| e.to_string())?;\n+                Target::from_json(obj)\n             }\n         }\n     }\n@@ -2421,10 +2421,77 @@ impl ToJson for Target {\n }\n \n /// Either a target triple string or a path to a JSON file.\n-#[derive(PartialEq, Clone, Debug, Hash, Encodable, Decodable)]\n+#[derive(Clone, Debug)]\n pub enum TargetTriple {\n     TargetTriple(String),\n-    TargetPath(PathBuf),\n+    TargetJson {\n+        /// Warning: This field may only be used by rustdoc. Using it anywhere else will lead to\n+        /// inconsistencies as it is discarded during serialization.\n+        path_for_rustdoc: PathBuf,\n+        triple: String,\n+        contents: String,\n+    },\n+}\n+\n+// Use a manual implementation to ignore the path field\n+impl PartialEq for TargetTriple {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Self::TargetTriple(l0), Self::TargetTriple(r0)) => l0 == r0,\n+            (\n+                Self::TargetJson { path_for_rustdoc: _, triple: l_triple, contents: l_contents },\n+                Self::TargetJson { path_for_rustdoc: _, triple: r_triple, contents: r_contents },\n+            ) => l_triple == r_triple && l_contents == r_contents,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+// Use a manual implementation to ignore the path field\n+impl Hash for TargetTriple {\n+    fn hash<H: Hasher>(&self, state: &mut H) -> () {\n+        match self {\n+            TargetTriple::TargetTriple(triple) => {\n+                0u8.hash(state);\n+                triple.hash(state)\n+            }\n+            TargetTriple::TargetJson { path_for_rustdoc: _, triple, contents } => {\n+                1u8.hash(state);\n+                triple.hash(state);\n+                contents.hash(state)\n+            }\n+        }\n+    }\n+}\n+\n+// Use a manual implementation to prevent encoding the target json file path in the crate metadata\n+impl<S: Encoder> Encodable<S> for TargetTriple {\n+    fn encode(&self, s: &mut S) {\n+        match self {\n+            TargetTriple::TargetTriple(triple) => s.emit_enum_variant(0, |s| s.emit_str(triple)),\n+            TargetTriple::TargetJson { path_for_rustdoc: _, triple, contents } => s\n+                .emit_enum_variant(1, |s| {\n+                    s.emit_str(triple);\n+                    s.emit_str(contents)\n+                }),\n+        }\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for TargetTriple {\n+    fn decode(d: &mut D) -> Self {\n+        match d.read_usize() {\n+            0 => TargetTriple::TargetTriple(d.read_str().to_owned()),\n+            1 => TargetTriple::TargetJson {\n+                path_for_rustdoc: PathBuf::new(),\n+                triple: d.read_str().to_owned(),\n+                contents: d.read_str().to_owned(),\n+            },\n+            _ => {\n+                panic!(\"invalid enum variant tag while decoding `TargetTriple`, expected 0..2\");\n+            }\n+        }\n+    }\n }\n \n impl TargetTriple {\n@@ -2436,20 +2503,28 @@ impl TargetTriple {\n     /// Creates a target triple from the passed target path.\n     pub fn from_path(path: &Path) -> Result<Self, io::Error> {\n         let canonicalized_path = path.canonicalize()?;\n-        Ok(TargetTriple::TargetPath(canonicalized_path))\n+        let contents = std::fs::read_to_string(&canonicalized_path).map_err(|err| {\n+            io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                format!(\"target path {:?} is not a valid file: {}\", canonicalized_path, err),\n+            )\n+        })?;\n+        let triple = canonicalized_path\n+            .file_stem()\n+            .expect(\"target path must not be empty\")\n+            .to_str()\n+            .expect(\"target path must be valid unicode\")\n+            .to_owned();\n+        Ok(TargetTriple::TargetJson { path_for_rustdoc: canonicalized_path, triple, contents })\n     }\n \n     /// Returns a string triple for this target.\n     ///\n     /// If this target is a path, the file name (without extension) is returned.\n     pub fn triple(&self) -> &str {\n         match *self {\n-            TargetTriple::TargetTriple(ref triple) => triple,\n-            TargetTriple::TargetPath(ref path) => path\n-                .file_stem()\n-                .expect(\"target path must not be empty\")\n-                .to_str()\n-                .expect(\"target path must be valid unicode\"),\n+            TargetTriple::TargetTriple(ref triple)\n+            | TargetTriple::TargetJson { ref triple, .. } => triple,\n         }\n     }\n \n@@ -2459,16 +2534,15 @@ impl TargetTriple {\n     /// by `triple()`.\n     pub fn debug_triple(&self) -> String {\n         use std::collections::hash_map::DefaultHasher;\n-        use std::hash::{Hash, Hasher};\n-\n-        let triple = self.triple();\n-        if let TargetTriple::TargetPath(ref path) = *self {\n-            let mut hasher = DefaultHasher::new();\n-            path.hash(&mut hasher);\n-            let hash = hasher.finish();\n-            format!(\"{}-{}\", triple, hash)\n-        } else {\n-            triple.into()\n+\n+        match self {\n+            TargetTriple::TargetTriple(triple) => triple.to_owned(),\n+            TargetTriple::TargetJson { path_for_rustdoc: _, triple, contents: content } => {\n+                let mut hasher = DefaultHasher::new();\n+                content.hash(&mut hasher);\n+                let hash = hasher.finish();\n+                format!(\"{}-{}\", triple, hash)\n+            }\n         }\n     }\n }"}, {"sha": "ab72f4a3f502cf6991f2bac390341bbe99ec3446", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa6cd9c6802efe3d6cef119bed1f78e596062d2/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa6cd9c6802efe3d6cef119bed1f78e596062d2/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=bfa6cd9c6802efe3d6cef119bed1f78e596062d2", "patch": "@@ -365,8 +365,8 @@ fn run_test(\n     }\n     compiler.arg(\"--target\").arg(match target {\n         TargetTriple::TargetTriple(s) => s,\n-        TargetTriple::TargetPath(path) => {\n-            path.to_str().expect(\"target path must be valid unicode\").to_string()\n+        TargetTriple::TargetJson { path_for_rustdoc, .. } => {\n+            path_for_rustdoc.to_str().expect(\"target path must be valid unicode\").to_string()\n         }\n     });\n     if let ErrorOutputType::HumanReadable(kind) = rustdoc_options.error_format {"}]}