{"sha": "24909fabd27091a7b363dcbc549636e98ba4a898", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0OTA5ZmFiZDI3MDkxYTdiMzYzZGNiYzU0OTYzNmU5OGJhNGE4OTg=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T09:41:43Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:24Z"}, "message": "move map_flatten and search_is_some to their own modules", "tree": {"sha": "d68ff82d54a020b1101131b4858d8fa2a1e3f201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d68ff82d54a020b1101131b4858d8fa2a1e3f201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24909fabd27091a7b363dcbc549636e98ba4a898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24909fabd27091a7b363dcbc549636e98ba4a898", "html_url": "https://github.com/rust-lang/rust/commit/24909fabd27091a7b363dcbc549636e98ba4a898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24909fabd27091a7b363dcbc549636e98ba4a898/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ba779a532cd229a18e8a99342f351ba035aa30", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ba779a532cd229a18e8a99342f351ba035aa30", "html_url": "https://github.com/rust-lang/rust/commit/37ba779a532cd229a18e8a99342f351ba035aa30"}], "stats": {"total": 312, "additions": 168, "deletions": 144}, "files": [{"sha": "14a14e4f9ecd1a4d24aae583077810b31b2731c8", "filename": "clippy_lints/src/methods/map_flatten.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/24909fabd27091a7b363dcbc549636e98ba4a898/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24909fabd27091a7b363dcbc549636e98ba4a898/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=24909fabd27091a7b363dcbc549636e98ba4a898", "patch": "@@ -0,0 +1,61 @@\n+use crate::utils::{is_type_diagnostic_item, match_trait_method, paths, snippet, span_lint_and_sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::sym;\n+\n+use super::MAP_FLATTEN;\n+\n+/// lint use of `map().flatten()` for `Iterators` and 'Options'\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n+    // lint if caller of `.map().flatten()` is an Iterator\n+    if match_trait_method(cx, expr, &paths::ITERATOR) {\n+        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let is_map_to_option = match map_closure_ty.kind() {\n+            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+                let map_closure_sig = match map_closure_ty.kind() {\n+                    ty::Closure(_, substs) => substs.as_closure().sig(),\n+                    _ => map_closure_ty.fn_sig(cx.tcx),\n+                };\n+                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym::option_type)\n+            },\n+            _ => false,\n+        };\n+\n+        let method_to_use = if is_map_to_option {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            \"filter_map\"\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            \"flat_map\"\n+        };\n+        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Iterator`\",\n+            &format!(\"try using `{}` instead\", method_to_use),\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    // lint if caller of `.map().flatten()` is an Option\n+    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n+        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let hint = format!(\".and_then({})\", func_snippet);\n+        span_lint_and_sugg(\n+            cx,\n+            MAP_FLATTEN,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Option`\",\n+            \"try using `and_then` instead\",\n+            hint,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "2b8bb0b4216c73325544ca27ddadda2d159d9987", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 144, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/24909fabd27091a7b363dcbc549636e98ba4a898/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24909fabd27091a7b363dcbc549636e98ba4a898/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=24909fabd27091a7b363dcbc549636e98ba4a898", "patch": "@@ -25,9 +25,11 @@ mod iter_nth_zero;\n mod iterator_step_by_zero;\n mod manual_saturating_arithmetic;\n mod map_collect_result_unit;\n+mod map_flatten;\n mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_unwrap_or;\n+mod search_is_some;\n mod single_char_insert_string;\n mod single_char_pattern;\n mod single_char_push_string;\n@@ -1711,13 +1713,13 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"flat_map\", \"filter\"] => filter_flat_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", \"filter_map\"] => filter_map_flat_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"flat_map\", ..] => flat_map_identity::check(cx, expr, arg_lists[0], method_spans[0]),\n-            [\"flatten\", \"map\"] => lint_map_flatten(cx, expr, arg_lists[1]),\n-            [\"is_some\", \"find\"] => lint_search_is_some(cx, expr, \"find\", arg_lists[1], arg_lists[0], method_spans[1]),\n+            [\"flatten\", \"map\"] => map_flatten::check(cx, expr, arg_lists[1]),\n+            [\"is_some\", \"find\"] => search_is_some::check(cx, expr, \"find\", arg_lists[1], arg_lists[0], method_spans[1]),\n             [\"is_some\", \"position\"] => {\n-                lint_search_is_some(cx, expr, \"position\", arg_lists[1], arg_lists[0], method_spans[1])\n+                search_is_some::check(cx, expr, \"position\", arg_lists[1], arg_lists[0], method_spans[1])\n             },\n             [\"is_some\", \"rposition\"] => {\n-                lint_search_is_some(cx, expr, \"rposition\", arg_lists[1], arg_lists[0], method_spans[1])\n+                search_is_some::check(cx, expr, \"rposition\", arg_lists[1], arg_lists[0], method_spans[1])\n             },\n             [\"extend\", ..] => string_extend_chars::check(cx, expr, arg_lists[0]),\n             [\"count\", \"into_iter\"] => iter_count::check(cx, expr, &arg_lists[1], \"into_iter\"),\n@@ -2566,59 +2568,6 @@ fn derefs_to_slice<'tcx>(\n     }\n }\n \n-/// lint use of `map().flatten()` for `Iterators` and 'Options'\n-fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n-    // lint if caller of `.map().flatten()` is an Iterator\n-    if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n-        let is_map_to_option = match map_closure_ty.kind() {\n-            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n-                let map_closure_sig = match map_closure_ty.kind() {\n-                    ty::Closure(_, substs) => substs.as_closure().sig(),\n-                    _ => map_closure_ty.fn_sig(cx.tcx),\n-                };\n-                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n-                is_type_diagnostic_item(cx, map_closure_return_ty, sym::option_type)\n-            },\n-            _ => false,\n-        };\n-\n-        let method_to_use = if is_map_to_option {\n-            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n-            \"filter_map\"\n-        } else {\n-            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n-            \"flat_map\"\n-        };\n-        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_FLATTEN,\n-            expr.span.with_lo(map_args[0].span.hi()),\n-            \"called `map(..).flatten()` on an `Iterator`\",\n-            &format!(\"try using `{}` instead\", method_to_use),\n-            hint,\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-\n-    // lint if caller of `.map().flatten()` is an Option\n-    if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym::option_type) {\n-        let func_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let hint = format!(\".and_then({})\", func_snippet);\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_FLATTEN,\n-            expr.span.with_lo(map_args[0].span.hi()),\n-            \"called `map(..).flatten()` on an `Option`\",\n-            \"try using `and_then` instead\",\n-            hint,\n-            Applicability::MachineApplicable,\n-        );\n-    }\n-}\n-\n const MAP_UNWRAP_OR_MSRV: RustcVersion = RustcVersion::new(1, 41, 0);\n \n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n@@ -2756,93 +2705,6 @@ fn lint_map_or_none<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     );\n }\n \n-/// lint searching an Iterator followed by `is_some()`\n-/// or calling `find()` on a string followed by `is_some()`\n-fn lint_search_is_some<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    search_method: &str,\n-    search_args: &'tcx [hir::Expr<'_>],\n-    is_some_args: &'tcx [hir::Expr<'_>],\n-    method_span: Span,\n-) {\n-    // lint if caller of search is an Iterator\n-    if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n-        let msg = format!(\n-            \"called `is_some()` after searching an `Iterator` with `{}`\",\n-            search_method\n-        );\n-        let hint = \"this is more succinctly expressed by calling `any()`\";\n-        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n-        if search_snippet.lines().count() <= 1 {\n-            // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n-            // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n-            let any_search_snippet = if_chain! {\n-                if search_method == \"find\";\n-                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n-                let closure_body = cx.tcx.hir().body(body_id);\n-                if let Some(closure_arg) = closure_body.params.get(0);\n-                then {\n-                    if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n-                        Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n-                        let name = &*ident.name.as_str();\n-                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n-            };\n-            // add note if not multi-line\n-            span_lint_and_sugg(\n-                cx,\n-                SEARCH_IS_SOME,\n-                method_span.with_hi(expr.span.hi()),\n-                &msg,\n-                \"use `any()` instead\",\n-                format!(\n-                    \"any({})\",\n-                    any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n-                ),\n-                Applicability::MachineApplicable,\n-            );\n-        } else {\n-            span_lint_and_help(cx, SEARCH_IS_SOME, expr.span, &msg, None, hint);\n-        }\n-    }\n-    // lint if `find()` is called by `String` or `&str`\n-    else if search_method == \"find\" {\n-        let is_string_or_str_slice = |e| {\n-            let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n-            if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n-                true\n-            } else {\n-                *self_ty.kind() == ty::Str\n-            }\n-        };\n-        if_chain! {\n-            if is_string_or_str_slice(&search_args[0]);\n-            if is_string_or_str_slice(&search_args[1]);\n-            then {\n-                let msg = \"called `is_some()` after calling `find()` on a string\";\n-                let mut applicability = Applicability::MachineApplicable;\n-                let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n-                span_lint_and_sugg(\n-                    cx,\n-                    SEARCH_IS_SOME,\n-                    method_span.with_hi(expr.span.hi()),\n-                    msg,\n-                    \"use `contains()` instead\",\n-                    format!(\"contains({})\", find_arg),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n /// Used for `lint_binary_expr_with_method_call`.\n #[derive(Copy, Clone)]\n struct BinaryExprInfo<'a> {"}, {"sha": "e9e654432208d94813f5083cfb2fe931faa47829", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/24909fabd27091a7b363dcbc549636e98ba4a898/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24909fabd27091a7b363dcbc549636e98ba4a898/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=24909fabd27091a7b363dcbc549636e98ba4a898", "patch": "@@ -0,0 +1,101 @@\n+use crate::utils::{\n+    is_type_diagnostic_item, match_trait_method, paths, snippet, snippet_with_applicability, span_lint_and_help,\n+    span_lint_and_sugg, strip_pat_refs,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::PatKind;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+\n+use super::SEARCH_IS_SOME;\n+\n+/// lint searching an Iterator followed by `is_some()`\n+/// or calling `find()` on a string followed by `is_some()`\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    search_method: &str,\n+    search_args: &'tcx [hir::Expr<'_>],\n+    is_some_args: &'tcx [hir::Expr<'_>],\n+    method_span: Span,\n+) {\n+    // lint if caller of search is an Iterator\n+    if match_trait_method(cx, &is_some_args[0], &paths::ITERATOR) {\n+        let msg = format!(\n+            \"called `is_some()` after searching an `Iterator` with `{}`\",\n+            search_method\n+        );\n+        let hint = \"this is more succinctly expressed by calling `any()`\";\n+        let search_snippet = snippet(cx, search_args[1].span, \"..\");\n+        if search_snippet.lines().count() <= 1 {\n+            // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n+            // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n+            let any_search_snippet = if_chain! {\n+                if search_method == \"find\";\n+                if let hir::ExprKind::Closure(_, _, body_id, ..) = search_args[1].kind;\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                if let Some(closure_arg) = closure_body.params.get(0);\n+                then {\n+                    if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n+                        Some(search_snippet.replacen('&', \"\", 1))\n+                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(&closure_arg.pat).kind {\n+                        let name = &*ident.name.as_str();\n+                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n+                    } else {\n+                        None\n+                    }\n+                } else {\n+                    None\n+                }\n+            };\n+            // add note if not multi-line\n+            span_lint_and_sugg(\n+                cx,\n+                SEARCH_IS_SOME,\n+                method_span.with_hi(expr.span.hi()),\n+                &msg,\n+                \"use `any()` instead\",\n+                format!(\n+                    \"any({})\",\n+                    any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            span_lint_and_help(cx, SEARCH_IS_SOME, expr.span, &msg, None, hint);\n+        }\n+    }\n+    // lint if `find()` is called by `String` or `&str`\n+    else if search_method == \"find\" {\n+        let is_string_or_str_slice = |e| {\n+            let self_ty = cx.typeck_results().expr_ty(e).peel_refs();\n+            if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+                true\n+            } else {\n+                *self_ty.kind() == ty::Str\n+            }\n+        };\n+        if_chain! {\n+            if is_string_or_str_slice(&search_args[0]);\n+            if is_string_or_str_slice(&search_args[1]);\n+            then {\n+                let msg = \"called `is_some()` after calling `find()` on a string\";\n+                let mut applicability = Applicability::MachineApplicable;\n+                let find_arg = snippet_with_applicability(cx, search_args[1].span, \"..\", &mut applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    SEARCH_IS_SOME,\n+                    method_span.with_hi(expr.span.hi()),\n+                    msg,\n+                    \"use `contains()` instead\",\n+                    format!(\"contains({})\", find_arg),\n+                    applicability,\n+                );\n+            }\n+        }\n+    }\n+}"}]}