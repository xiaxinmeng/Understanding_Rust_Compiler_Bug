{"sha": "e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZGMzNTY3ZjhiYjJiNWI1MDIzMGFhMzFkNGFkNTdiNjMxYWM4ZGI=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-19T23:43:40Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Track if a thread was already joined.", "tree": {"sha": "f0038fd4c996da400123c7227591e2e9eed329d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0038fd4c996da400123c7227591e2e9eed329d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db", "html_url": "https://github.com/rust-lang/rust/commit/e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db/comments", "author": null, "committer": null, "parents": [{"sha": "5b55e0706c3fff3fd015e5396422a2a1eda19779", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b55e0706c3fff3fd015e5396422a2a1eda19779", "html_url": "https://github.com/rust-lang/rust/commit/5b55e0706c3fff3fd015e5396422a2a1eda19779"}], "stats": {"total": 57, "additions": 38, "deletions": 19}, "files": [{"sha": "657792bd2c6763fe1ff907355a64a9dac584795f", "filename": "src/thread.rs", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=e4dc3567f8bb2b5b50230aa31d4ad57b631ac8db", "patch": "@@ -92,18 +92,27 @@ pub enum ThreadState {\n     Terminated,\n }\n \n+/// The join status of a thread.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum ThreadJoinStatus {\n+    /// The thread can be joined.\n+    Joinable,\n+    /// A thread is detached if its join handle was destroyed and no other\n+    /// thread can join it.\n+    Detached,\n+    /// The thread was already joined by some thread and cannot be joined again.\n+    Joined,\n+}\n+\n /// A thread.\n pub struct Thread<'mir, 'tcx> {\n     state: ThreadState,\n     /// Name of the thread.\n     thread_name: Option<Vec<u8>>,\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>>,\n-    /// Is the thread detached?\n-    ///\n-    /// A thread is detached if its join handle was destroyed and no other\n-    /// thread can join it.\n-    detached: bool,\n+    /// The join status.\n+    join_status: ThreadJoinStatus,\n }\n \n impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n@@ -128,7 +137,12 @@ impl<'mir, 'tcx> std::fmt::Debug for Thread<'mir, 'tcx> {\n \n impl<'mir, 'tcx> Default for Thread<'mir, 'tcx> {\n     fn default() -> Self {\n-        Self { state: ThreadState::Enabled, thread_name: None, stack: Vec::new(), detached: false }\n+        Self {\n+            state: ThreadState::Enabled,\n+            thread_name: None,\n+            stack: Vec::new(),\n+            join_status: ThreadJoinStatus::Joinable,\n+        }\n     }\n }\n \n@@ -225,25 +239,31 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n \n     /// Mark the thread as detached, which means that no other thread will try\n     /// to join it and the thread is responsible for cleaning up.\n-    fn detach_thread(&mut self, id: ThreadId) {\n-        self.threads[id].detached = true;\n+    fn detach_thread(&mut self, id: ThreadId) -> InterpResult<'tcx> {\n+        if self.threads[id].join_status != ThreadJoinStatus::Joinable {\n+            throw_ub_format!(\"trying to detach thread that was already detached or joined\");\n+        }\n+        self.threads[id].join_status = ThreadJoinStatus::Detached;\n+        Ok(())\n     }\n \n     /// Mark that the active thread tries to join the thread with `joined_thread_id`.\n     fn join_thread(&mut self, joined_thread_id: ThreadId) -> InterpResult<'tcx> {\n-        if self.threads[joined_thread_id].detached {\n-            throw_ub_format!(\"trying to join a detached thread\");\n+        if self.threads[joined_thread_id].join_status != ThreadJoinStatus::Joinable {\n+            throw_ub_format!(\"trying to join a detached or already joined thread\");\n         }\n         if joined_thread_id == self.active_thread {\n             throw_ub_format!(\"trying to join itself\");\n         }\n-        if self\n-            .threads\n-            .iter()\n-            .any(|thread| thread.state == ThreadState::BlockedOnJoin(joined_thread_id))\n-        {\n-            throw_ub_format!(\"multiple threads try to join the same thread\");\n-        }\n+        assert!(\n+            self.threads\n+                .iter()\n+                .all(|thread| thread.state != ThreadState::BlockedOnJoin(joined_thread_id)),\n+            \"a joinable thread has threads waiting for its termination\"\n+        );\n+        // Mark the joined thread as being joined so that we detect if other\n+        // threads try to join it.\n+        self.threads[joined_thread_id].join_status = ThreadJoinStatus::Joined;\n         if self.threads[joined_thread_id].state != ThreadState::Terminated {\n             // The joined thread is still running, we need to wait for it.\n             self.active_thread_mut().state = ThreadState::BlockedOnJoin(joined_thread_id);\n@@ -451,8 +471,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[inline]\n     fn detach_thread(&mut self, thread_id: ThreadId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        this.machine.threads.detach_thread(thread_id);\n-        Ok(())\n+        this.machine.threads.detach_thread(thread_id)\n     }\n \n     #[inline]"}]}