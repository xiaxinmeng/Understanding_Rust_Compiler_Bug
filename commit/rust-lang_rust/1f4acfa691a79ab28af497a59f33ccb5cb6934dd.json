{"sha": "1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNGFjZmE2OTFhNzlhYjI4YWY0OTdhNTlmMzNjY2I1Y2I2OTM0ZGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-10T19:44:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-05T01:08:32Z"}, "message": "switch to using constvals for constants, instead of having constant\ntrees in MIR", "tree": {"sha": "d848c6edcff7d94950cec883cf6c9159bec78fb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d848c6edcff7d94950cec883cf6c9159bec78fb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "html_url": "https://github.com/rust-lang/rust/commit/1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dedde0bb5ab3fc8e5a7b78d36cbe18019a118bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/dedde0bb5ab3fc8e5a7b78d36cbe18019a118bbe", "html_url": "https://github.com/rust-lang/rust/commit/dedde0bb5ab3fc8e5a7b78d36cbe18019a118bbe"}], "stats": {"total": 343, "additions": 107, "deletions": 236}, "files": [{"sha": "78acff0ada389bc9a47b0df06ca934c1daaaf6be", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -242,7 +242,7 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n     }\n }\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum ConstVal {\n     Float(f64),\n     Int(i64),"}, {"sha": "6cc99a56933d68e22a022b8bb09bb1eecf50ed3c", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 9, "deletions": 88, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -10,8 +10,6 @@\n \n //! See docs in build/expr/mod.rs\n \n-use rustc_data_structures::fnv::FnvHashMap;\n-\n use build::{Builder};\n use hair::*;\n use repr::*;\n@@ -28,93 +26,16 @@ impl<H:Hair> Builder<H> {\n \n     fn expr_as_constant(&mut self, expr: Expr<H>) -> Constant<H> {\n         let this = self;\n-        let Expr { ty: _, temp_lifetime: _, span, kind } = expr;\n-        let kind = match kind {\n-            ExprKind::Scope { extent: _, value } => {\n-                return this.as_constant(value);\n-            }\n-            ExprKind::Literal { literal } => {\n-                ConstantKind::Literal(literal)\n-            }\n-            ExprKind::Vec { fields } => {\n-                let fields = this.as_constants(fields);\n-                ConstantKind::Aggregate(AggregateKind::Vec, fields)\n-            }\n-            ExprKind::Tuple { fields } => {\n-                let fields = this.as_constants(fields);\n-                ConstantKind::Aggregate(AggregateKind::Tuple, fields)\n-            }\n-            ExprKind::Adt { adt_def, variant_index, substs, fields, base: None } => {\n-                let field_names = this.hir.fields(adt_def, variant_index);\n-                let fields = this.named_field_constants(field_names, fields);\n-                ConstantKind::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs), fields)\n-            }\n-            ExprKind::Repeat { value, count } => {\n-                let value = Box::new(this.as_constant(value));\n-                let count = Box::new(this.as_constant(count));\n-                ConstantKind::Repeat(value, count)\n-            }\n-            ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = Box::new(this.as_constant(lhs));\n-                let rhs = Box::new(this.as_constant(rhs));\n-                ConstantKind::BinaryOp(op, lhs, rhs)\n-            }\n-            ExprKind::Unary { op, arg } => {\n-                let arg = Box::new(this.as_constant(arg));\n-                ConstantKind::UnaryOp(op, arg)\n-            }\n-            ExprKind::Field { lhs, name } => {\n-                let lhs = this.as_constant(lhs);\n-                ConstantKind::Projection(\n-                    Box::new(ConstantProjection {\n-                        base: lhs,\n-                        elem: ProjectionElem::Field(name),\n-                    }))\n-            }\n-            ExprKind::Deref { arg } => {\n-                let arg = this.as_constant(arg);\n-                ConstantKind::Projection(\n-                    Box::new(ConstantProjection {\n-                        base: arg,\n-                        elem: ProjectionElem::Deref,\n-                    }))\n-            }\n-            ExprKind::Call { fun, args } => {\n-                let fun = this.as_constant(fun);\n-                let args = this.as_constants(args);\n-                ConstantKind::Call(Box::new(fun), args)\n-            }\n-            _ => {\n+        let Expr { ty, temp_lifetime: _, span, kind } = expr;\n+        match kind {\n+            ExprKind::Scope { extent: _, value } =>\n+                this.as_constant(value),\n+            ExprKind::Literal { literal } =>\n+                Constant { span: span, ty: ty, literal: literal },\n+            _ =>\n                 this.hir.span_bug(\n                     span,\n-                    &format!(\"expression is not a valid constant {:?}\", kind));\n-            }\n-        };\n-        Constant { span: span, kind: kind }\n-    }\n-\n-    fn as_constants(&mut self,\n-                    exprs: Vec<ExprRef<H>>)\n-                    -> Vec<Constant<H>>\n-    {\n-        exprs.into_iter().map(|expr| self.as_constant(expr)).collect()\n-    }\n-\n-    fn named_field_constants(&mut self,\n-                             field_names: Vec<Field<H>>,\n-                             field_exprs: Vec<FieldExprRef<H>>)\n-                             -> Vec<Constant<H>>\n-    {\n-        let fields_map: FnvHashMap<_, _> =\n-            field_exprs.into_iter()\n-                       .map(|f| (f.name, self.as_constant(f.expr)))\n-                       .collect();\n-\n-        let fields: Vec<_> =\n-            field_names.into_iter()\n-                       .map(|n| fields_map[&n].clone())\n-                       .collect();\n-\n-        fields\n+                    &format!(\"expression is not a valid constant {:?}\", kind)),\n+        }\n     }\n }"}, {"sha": "61eeac30c0f1dae66374204cde3c877f5ad283fc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -99,14 +99,16 @@ impl<H:Hair> Builder<H> {\n                     true_block, expr_span, destination,\n                     Constant {\n                         span: expr_span,\n-                        kind: ConstantKind::Literal(Literal::Bool { value: true }),\n+                        ty: this.hir.bool_ty(),\n+                        literal: this.hir.true_literal(),\n                     });\n \n                 this.cfg.push_assign_constant(\n                     false_block, expr_span, destination,\n                     Constant {\n                         span: expr_span,\n-                        kind: ConstantKind::Literal(Literal::Bool { value: false }),\n+                        ty: this.hir.bool_ty(),\n+                        literal: this.hir.false_literal(),\n                     });\n \n                 this.cfg.terminate(true_block, Terminator::Goto { target: join_block });"}, {"sha": "519c6117717c7f60086834d0367cfcc5cfda781c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -221,10 +221,10 @@ enum TestKind<H:Hair> {\n     Switch { adt_def: H::AdtDef },\n \n     // test for equality\n-    Eq { value: Constant<H>, ty: H::Ty },\n+    Eq { value: Literal<H>, ty: H::Ty },\n \n     // test whether the value falls within an inclusive range\n-    Range { lo: Constant<H>, hi: Constant<H>, ty: H::Ty },\n+    Range { lo: Literal<H>, hi: Literal<H>, ty: H::Ty },\n \n     // test length of the slice is equal to len\n     Len { len: usize, op: BinOp },\n@@ -267,9 +267,12 @@ impl<H:Hair> Builder<H> {\n             // If so, apply any bindings, test the guard (if any), and\n             // branch to the arm.\n             let candidate = candidates.pop().unwrap();\n-            match self.bind_and_guard_matched_candidate(block, var_extent, candidate) {\n-                None => { return; }\n-                Some(b) => { block = b; }\n+            if let Some(b) = self.bind_and_guard_matched_candidate(block, var_extent, candidate) {\n+                block = b;\n+            } else {\n+                // if None is returned, then any remaining candidates\n+                // are unreachable (at least not through this path).\n+                return;\n             }\n         }\n "}, {"sha": "2d034baef167d6b1433d9c97781ea00f40fc659b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -33,20 +33,20 @@ impl<H:Hair> Builder<H> {\n                 }\n             }\n \n-            PatternKind::Constant { ref expr } => {\n-                let expr = self.as_constant(expr.clone());\n+            PatternKind::Constant { ref value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Eq { value: expr, ty: match_pair.pattern.ty.clone() },\n+                    kind: TestKind::Eq { value: value.clone(),\n+                                         ty: match_pair.pattern.ty.clone() },\n                 }\n             }\n \n             PatternKind::Range { ref lo, ref hi } => {\n-                let lo = self.as_constant(lo.clone());\n-                let hi = self.as_constant(hi.clone());\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Range { lo: lo, hi: hi, ty: match_pair.pattern.ty.clone() },\n+                    kind: TestKind::Range { lo: lo.clone(),\n+                                            hi: hi.clone(),\n+                                            ty: match_pair.pattern.ty.clone() },\n                 }\n             }\n \n@@ -90,15 +90,15 @@ impl<H:Hair> Builder<H> {\n \n             TestKind::Eq { value, ty } => {\n                 // call PartialEq::eq(discrim, constant)\n-                let constant = self.push_constant(block, test.span, ty.clone(), value);\n+                let constant = self.push_literal(block, test.span, ty.clone(), value);\n                 let item_ref = self.hir.partial_eq(ty);\n                 self.call_comparison_fn(block, test.span, item_ref, lvalue.clone(), constant)\n             }\n \n             TestKind::Range { lo, hi, ty } => {\n                 // Test `v` by computing `PartialOrd::le(lo, v) && PartialOrd::le(v, hi)`.\n-                let lo = self.push_constant(block, test.span, ty.clone(), lo);\n-                let hi = self.push_constant(block, test.span, ty.clone(), hi);\n+                let lo = self.push_literal(block, test.span, ty.clone(), lo);\n+                let hi = self.push_literal(block, test.span, ty.clone(), hi);\n                 let item_ref = self.hir.partial_le(ty);\n \n                 let lo_blocks ="}, {"sha": "9fa1d55e82f9c1eba2c6b5a5a7a66fd317c40727", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -33,13 +33,14 @@ impl<H:Hair> Builder<H> {\n         lvalue\n     }\n \n-    pub fn push_constant(&mut self,\n-                         block: BasicBlock,\n-                         span: H::Span,\n-                         ty: H::Ty,\n-                         constant: Constant<H>)\n-                         -> Lvalue<H> {\n-        let temp = self.temp(ty);\n+    pub fn push_literal(&mut self,\n+                        block: BasicBlock,\n+                        span: H::Span,\n+                        ty: H::Ty,\n+                        literal: Literal<H>)\n+                        -> Lvalue<H> {\n+        let temp = self.temp(ty.clone());\n+        let constant = Constant { span: span, ty: ty, literal: literal };\n         self.cfg.push_assign_constant(block, span, &temp, constant);\n         temp\n     }\n@@ -55,8 +56,8 @@ impl<H:Hair> Builder<H> {\n             block, span, &temp,\n             Constant {\n                 span: span,\n-                kind: ConstantKind::Literal(Literal::Uint { bits: IntegralBits::BSize,\n-                                                            value: value as u64 }),\n+                ty: self.hir.usize_ty(),\n+                literal: self.hir.usize_literal(value),\n             });\n         temp\n     }\n@@ -66,13 +67,7 @@ impl<H:Hair> Builder<H> {\n                          span: H::Span,\n                          item_ref: ItemRef<H>)\n                          -> Lvalue<H> {\n-        let constant = Constant {\n-            span: span,\n-            kind: ConstantKind::Literal(Literal::Item {\n-                def_id: item_ref.def_id,\n-                substs: item_ref.substs\n-            })\n-        };\n-        self.push_constant(block, span, item_ref.ty, constant)\n+        let literal = Literal::Item { def_id: item_ref.def_id, substs: item_ref.substs };\n+        self.push_literal(block, span, item_ref.ty, literal)\n     }\n }"}, {"sha": "f4eb03c5d07c2371dbbfd0660cc3e9dd75117bf3", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -38,6 +38,7 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     type Ty: Clone+Debug+Eq;                                     // e.g., ty::Ty<'tcx>\n     type Region: Copy+Debug;                                     // e.g., ty::Region\n     type CodeExtent: Copy+Debug+Hash+Eq;                         // e.g., region::CodeExtent\n+    type ConstVal: Clone+Debug+PartialEq;                        // e.g., ConstVal\n     type Pattern: Clone+Debug+Mirror<Self,Output=Pattern<Self>>; // e.g., &P<ast::Pat>\n     type Expr: Clone+Debug+Mirror<Self,Output=Expr<Self>>;       // e.g., &P<ast::Expr>\n     type Stmt: Clone+Debug+Mirror<Self,Output=Stmt<Self>>;       // e.g., &P<ast::Stmt>\n@@ -55,9 +56,18 @@ pub trait Hair: Sized+Debug+Clone+Eq+Hash { // (*)\n     /// Returns the type `usize`.\n     fn usize_ty(&mut self) -> Self::Ty;\n \n+    /// Returns the literal for `true`\n+    fn usize_literal(&mut self, value: usize) -> Literal<Self>;\n+\n     /// Returns the type `bool`.\n     fn bool_ty(&mut self) -> Self::Ty;\n \n+    /// Returns the literal for `true`\n+    fn true_literal(&mut self) -> Literal<Self>;\n+\n+    /// Returns the literal for `true`\n+    fn false_literal(&mut self) -> Literal<Self>;\n+\n     /// Returns a reference to `PartialEq::<T,T>::eq`\n     fn partial_eq(&mut self, ty: Self::Ty) -> ItemRef<Self>;\n \n@@ -261,9 +271,9 @@ pub enum PatternKind<H:Hair> {\n \n     Deref { subpattern: PatternRef<H> }, // box P, &P, &mut P, etc\n \n-    Constant { expr: ExprRef<H> },\n+    Constant { value: Literal<H> },\n \n-    Range { lo: ExprRef<H>, hi: ExprRef<H> },\n+    Range { lo: Literal<H>, hi: Literal<H> },\n \n     // matches against a slice, checking the length and extracting elements\n     Slice { prefix: Vec<PatternRef<H>>,"}, {"sha": "e5a03cbb5864c9990bc9a92233eedb9e2cef1bd4", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 3, "deletions": 35, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -646,44 +646,12 @@ impl<H:Hair> Debug for Rvalue<H> {\n #[derive(Clone, Debug, PartialEq)]\n pub struct Constant<H:Hair> {\n     pub span: H::Span,\n-    pub kind: ConstantKind<H>\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub enum ConstantKind<H:Hair> {\n-    Literal(Literal<H>),\n-    Aggregate(AggregateKind<H>, Vec<Constant<H>>),\n-    Call(Box<Constant<H>>, Vec<Constant<H>>),\n-    Cast(Box<Constant<H>>, H::Ty),\n-    Repeat(Box<Constant<H>>, Box<Constant<H>>),\n-    Ref(BorrowKind, Box<Constant<H>>),\n-    BinaryOp(BinOp, Box<Constant<H>>, Box<Constant<H>>),\n-    UnaryOp(UnOp, Box<Constant<H>>),\n-    Projection(Box<ConstantProjection<H>>)\n+    pub ty: H::Ty,\n+    pub literal: Literal<H>\n }\n \n-pub type ConstantProjection<H> =\n-    Projection<H,Constant<H>,Constant<H>>;\n-\n #[derive(Clone, Debug, PartialEq)]\n pub enum Literal<H:Hair> {\n     Item { def_id: H::DefId, substs: H::Substs },\n-    Projection { projection: H::Projection },\n-    Int { bits: IntegralBits, value: i64 },\n-    Uint { bits: IntegralBits, value: u64 },\n-    Float { bits: FloatBits, value: f64 },\n-    Char { c: char },\n-    Bool { value: bool },\n-    Bytes { value: H::Bytes },\n-    String { value: H::InternedString },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n-pub enum IntegralBits {\n-    B8, B16, B32, B64, BSize\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n-pub enum FloatBits {\n-    F32, F64\n+    Value { value: H::ConstVal },\n }"}, {"sha": "098a85514eb2af21eee7060b93f05d1887513248", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 4, "deletions": 66, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -16,14 +16,13 @@ use tcx::Cx;\n use tcx::block;\n use tcx::pattern::PatNode;\n use tcx::rustc::front::map;\n+use tcx::rustc::middle::const_eval;\n use tcx::rustc::middle::def;\n use tcx::rustc::middle::region::CodeExtent;\n use tcx::rustc::middle::pat_util;\n use tcx::rustc::middle::ty::{self, Ty};\n use tcx::rustc_front::hir;\n use tcx::rustc_front::util as hir_util;\n-use tcx::syntax::ast;\n-use tcx::syntax::codemap::Span;\n use tcx::syntax::parse::token;\n use tcx::syntax::ptr::P;\n use tcx::to_ref::ToRef;\n@@ -83,9 +82,9 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for &'tcx hir::Expr {\n                 }\n             }\n \n-            hir::ExprLit(ref lit) => {\n-                let literal = convert_literal(cx, self.span, expr_ty, lit);\n-                ExprKind::Literal { literal: literal }\n+            hir::ExprLit(..) => {\n+                let value = const_eval::eval_const_expr(cx.tcx, self);\n+                ExprKind::Literal { literal: Literal::Value { value: value } }\n             }\n \n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -452,67 +451,6 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_literal<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                               expr_span: Span,\n-                               expr_ty: Ty<'tcx>,\n-                               literal: &ast::Lit)\n-                               -> Literal<Cx<'a,'tcx>>\n-{\n-    use repr::IntegralBits::*;\n-    match (&literal.node, &expr_ty.sty) {\n-        (&ast::LitStr(ref text, _), _) =>\n-            Literal::String { value: text.clone() },\n-        (&ast::LitByteStr(ref bytes), _) =>\n-            Literal::Bytes { value: bytes.clone() },\n-        (&ast::LitByte(c), _) =>\n-            Literal::Uint { bits: B8, value: c as u64 },\n-        (&ast::LitChar(c), _) =>\n-            Literal::Char { c: c },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU8)) =>\n-            Literal::Uint { bits: B8, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU16)) =>\n-            Literal::Uint { bits: B16, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU32)) =>\n-            Literal::Uint { bits: B32, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyU64)) =>\n-            Literal::Uint { bits: B64, value: v },\n-        (&ast::LitInt(v, _), &ty::TyUint(ast::TyUs)) =>\n-            Literal::Uint { bits: BSize, value: v },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI8)) =>\n-            Literal::Int { bits: B8, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI16)) =>\n-            Literal::Int { bits: B16, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI32)) =>\n-            Literal::Int { bits: B32, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyI64)) =>\n-            Literal::Int { bits: B64, value: -(v as i64) },\n-        (&ast::LitInt(v, ast::SignedIntLit(_, ast::Sign::Minus)), &ty::TyInt(ast::TyIs)) =>\n-            Literal::Int { bits: BSize, value: -(v as i64) },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI8)) =>\n-            Literal::Int { bits: B8, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI16)) =>\n-            Literal::Int { bits: B16, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI32)) =>\n-            Literal::Int { bits: B32, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyI64)) =>\n-            Literal::Int { bits: B64, value: v as i64 },\n-        (&ast::LitInt(v, _), &ty::TyInt(ast::TyIs)) =>\n-            Literal::Int { bits: BSize, value: v as i64 },\n-        (&ast::LitFloat(ref v, _), &ty::TyFloat(ast::TyF32)) |\n-        (&ast::LitFloatUnsuffixed(ref v), &ty::TyFloat(ast::TyF32)) =>\n-            Literal::Float { bits: FloatBits::F32, value: v.parse::<f64>().unwrap() },\n-        (&ast::LitFloat(ref v, _), &ty::TyFloat(ast::TyF64)) |\n-        (&ast::LitFloatUnsuffixed(ref v), &ty::TyFloat(ast::TyF64)) =>\n-            Literal::Float { bits: FloatBits::F64, value: v.parse::<f64>().unwrap() },\n-        (&ast::LitBool(v), _) =>\n-            Literal::Bool { value: v },\n-        (ref l, ref t) =>\n-            cx.tcx.sess.span_bug(\n-                expr_span,\n-                &format!(\"Invalid literal/type combination: {:?},{:?}\", l, t))\n-    }\n-}\n-\n fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<Cx<'a,'tcx>> {\n     let map = if arm.pats.len() == 1 {\n         None"}, {"sha": "04f52a52464b7cb963b45fba5319cbcd8323304d", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -14,6 +14,7 @@ use std::fmt::{Debug, Formatter, Error};\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n \n+use self::rustc::middle::const_eval::ConstVal;\n use self::rustc::middle::def_id::DefId;\n use self::rustc::middle::infer::InferCtxt;\n use self::rustc::middle::region::CodeExtent;\n@@ -56,6 +57,7 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n     type Ty = Ty<'tcx>;\n     type Region = ty::Region;\n     type CodeExtent = CodeExtent;\n+    type ConstVal = ConstVal;\n     type Pattern = PatNode<'tcx>;\n     type Expr = &'tcx hir::Expr;\n     type Stmt = &'tcx hir::Stmt;\n@@ -70,10 +72,22 @@ impl<'a,'tcx:'a> Hair for Cx<'a, 'tcx> {\n         self.tcx.types.usize\n     }\n \n+    fn usize_literal(&mut self, value: usize) -> Literal<Self> {\n+        Literal::Value { value: ConstVal::Uint(value as u64) }\n+    }\n+\n     fn bool_ty(&mut self) -> Ty<'tcx> {\n         self.tcx.types.bool\n     }\n \n+    fn true_literal(&mut self) -> Literal<Self> {\n+        Literal::Value { value: ConstVal::Bool(true) }\n+    }\n+\n+    fn false_literal(&mut self) -> Literal<Self> {\n+        Literal::Value { value: ConstVal::Bool(false) }\n+    }\n+\n     fn partial_eq(&mut self, ty: Ty<'tcx>) -> ItemRef<Self> {\n         let eq_def_id = self.tcx.lang_items.eq_trait().unwrap();\n         self.cmp_method_ref(eq_def_id, \"eq\", ty)"}, {"sha": "fe0c2c6c76add2a309e5f6e932946db6311f8783", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4acfa691a79ab28af497a59f33ccb5cb6934dd/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=1f4acfa691a79ab28af497a59f33ccb5cb6934dd", "patch": "@@ -14,9 +14,10 @@ use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use std::rc::Rc;\n use tcx::Cx;\n-use tcx::rustc::middle::const_eval::lookup_const_by_id;\n+use tcx::rustc::middle::const_eval;\n use tcx::rustc::middle::def;\n use tcx::rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n+use tcx::rustc::middle::subst::Substs;\n use tcx::rustc::middle::ty::{self, Ty};\n use tcx::rustc_front::hir;\n use tcx::syntax::ast;\n@@ -145,26 +146,45 @@ impl<'a,'tcx:'a> Mirror<Cx<'a,'tcx>> for PatNode<'tcx> {\n             hir::PatWild(..) =>\n                 PatternKind::Wild,\n \n-            hir::PatLit(ref lt) =>\n-                PatternKind::Constant { expr: lt.to_ref() },\n+            hir::PatLit(ref value) => {\n+                let value = const_eval::eval_const_expr(cx.tcx, value);\n+                let value = Literal::Value { value: value };\n+                PatternKind::Constant { value: value }\n+            },\n \n-            hir::PatRange(ref begin, ref end) =>\n-                PatternKind::Range { lo: begin.to_ref(),\n-                                     hi: end.to_ref() },\n+            hir::PatRange(ref lo, ref hi) => {\n+                let lo = const_eval::eval_const_expr(cx.tcx, lo);\n+                let lo = Literal::Value { value: lo };\n+                let hi = const_eval::eval_const_expr(cx.tcx, hi);\n+                let hi = Literal::Value { value: hi };\n+                PatternKind::Range { lo: lo, hi: hi }\n+            },\n \n             hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n                 if pat_is_resolved_const(&cx.tcx.def_map, self.pat) =>\n             {\n                 let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n                 match def {\n                     def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n-                        match lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n-                            Some(const_expr) =>\n-                                PatternKind::Constant { expr: const_expr.to_ref() },\n-                            None =>\n+                        match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n+                            Some(const_expr) => {\n+                                let opt_value =\n+                                    const_eval::eval_const_expr_partial(\n+                                        cx.tcx, const_expr,\n+                                        const_eval::EvalHint::ExprTypeChecked);\n+                                let literal = if let Ok(value) = opt_value {\n+                                    Literal::Value { value: value }\n+                                } else {\n+                                    let substs = cx.tcx.mk_substs(Substs::empty());\n+                                    Literal::Item { def_id: def_id, substs: substs }\n+                                };\n+                                PatternKind::Constant { value: literal }\n+                            }\n+                            None => {\n                                 cx.tcx.sess.span_bug(\n                                     self.pat.span,\n-                                    &format!(\"cannot eval constant: {:?}\", def_id)),\n+                                    &format!(\"cannot eval constant: {:?}\", def_id))\n+                            }\n                         },\n                     _ =>\n                         cx.tcx.sess.span_bug("}]}