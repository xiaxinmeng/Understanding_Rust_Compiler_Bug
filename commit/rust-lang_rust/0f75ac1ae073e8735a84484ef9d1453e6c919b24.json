{"sha": "0f75ac1ae073e8735a84484ef9d1453e6c919b24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNzVhYzFhZTA3M2U4NzM1YTg0NDg0ZWY5ZDE0NTNlNmM5MTliMjQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-30T14:09:27Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-30T14:22:12Z"}, "message": "add `;` to last return in block", "tree": {"sha": "fa52db75cb2b16c86050852f7dc6c02d0803f53b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa52db75cb2b16c86050852f7dc6c02d0803f53b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f75ac1ae073e8735a84484ef9d1453e6c919b24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f75ac1ae073e8735a84484ef9d1453e6c919b24", "html_url": "https://github.com/rust-lang/rust/commit/0f75ac1ae073e8735a84484ef9d1453e6c919b24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f75ac1ae073e8735a84484ef9d1453e6c919b24/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c182aab5460fb5dc14b8c0e47fae45a09ccf0ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c182aab5460fb5dc14b8c0e47fae45a09ccf0ac8", "html_url": "https://github.com/rust-lang/rust/commit/c182aab5460fb5dc14b8c0e47fae45a09ccf0ac8"}], "stats": {"total": 61, "additions": 46, "deletions": 15}, "files": [{"sha": "2869e67e0b93dad26bbb1006e202d41e4693caa8", "filename": "crates/ra_analysis/src/completion/complete_keyword.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0f75ac1ae073e8735a84484ef9d1453e6c919b24/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f75ac1ae073e8735a84484ef9d1453e6c919b24/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=0f75ac1ae073e8735a84484ef9d1453e6c919b24", "patch": "@@ -35,7 +35,7 @@ pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         acc.add(keyword(\"continue\", \"continue\"));\n         acc.add(keyword(\"break\", \"break\"));\n     }\n-    acc.add_all(complete_return(fn_def, ctx.is_stmt));\n+    acc.add_all(complete_return(fn_def, ctx.can_be_stmt));\n }\n \n fn is_in_loop_body(leaf: SyntaxNodeRef) -> bool {\n@@ -57,8 +57,8 @@ fn is_in_loop_body(leaf: SyntaxNodeRef) -> bool {\n     false\n }\n \n-fn complete_return(fn_def: ast::FnDef, is_stmt: bool) -> Option<CompletionItem> {\n-    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n+fn complete_return(fn_def: ast::FnDef, can_be_stmt: bool) -> Option<CompletionItem> {\n+    let snip = match (can_be_stmt, fn_def.ret_type().is_some()) {\n         (true, true) => \"return $0;\",\n         (true, false) => \"return;\",\n         (false, true) => \"return $0\",\n@@ -75,7 +75,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_completion_kewords() {\n+    fn completes_various_keywords_in_function() {\n         check_keyword_completion(\n             r\"\n             fn quux() {\n@@ -87,13 +87,13 @@ mod tests {\n             match \"match $0 {}\"\n             while \"while $0 {}\"\n             loop \"loop {$0}\"\n-            return \"return\"\n+            return \"return;\"\n             \"#,\n         );\n     }\n \n     #[test]\n-    fn test_completion_else() {\n+    fn completes_else_after_if() {\n         check_keyword_completion(\n             r\"\n             fn quux() {\n@@ -109,7 +109,7 @@ mod tests {\n             loop \"loop {$0}\"\n             else \"else {$0}\"\n             else if \"else if $0 {}\"\n-            return \"return\"\n+            return \"return;\"\n             \"#,\n         );\n     }\n@@ -149,7 +149,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_completion_return_no_stmt() {\n+    fn dont_add_semi_after_return_if_not_a_statement() {\n         check_keyword_completion(\n             r\"\n             fn quux() -> i32 {\n@@ -169,7 +169,27 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_continue_break_completion() {\n+    fn last_return_in_block_has_semi() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                if condition {\n+                    <|>\n+                }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0;\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_break_and_continue_in_loops() {\n         check_keyword_completion(\n             r\"\n             fn quux() -> i32 {\n@@ -183,9 +203,10 @@ mod tests {\n             loop \"loop {$0}\"\n             continue \"continue\"\n             break \"break\"\n-            return \"return $0\"\n+            return \"return $0;\"\n             \"#,\n         );\n+        // No completion: lambda isolates control flow\n         check_keyword_completion(\n             r\"\n             fn quux() -> i32 {\n@@ -197,7 +218,7 @@ mod tests {\n             match \"match $0 {}\"\n             while \"while $0 {}\"\n             loop \"loop {$0}\"\n-            return \"return $0\"\n+            return \"return $0;\"\n             \"#,\n         );\n     }"}, {"sha": "4685c93281ebdc73f528bb45a6be03f24f36e83a", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f75ac1ae073e8735a84484ef9d1453e6c919b24/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f75ac1ae073e8735a84484ef9d1453e6c919b24/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=0f75ac1ae073e8735a84484ef9d1453e6c919b24", "patch": "@@ -31,7 +31,8 @@ pub(super) struct CompletionContext<'a> {\n     /// If not a trivial, path, the prefix (qualifier).\n     pub(super) path_prefix: Option<hir::Path>,\n     pub(super) after_if: bool,\n-    pub(super) is_stmt: bool,\n+    /// `true` if we are a statement or a last expr in the block.\n+    pub(super) can_be_stmt: bool,\n     /// Something is typed at the \"top\" level, in module or impl/trait.\n     pub(super) is_new_item: bool,\n     /// The receiver if this is a field or method access, i.e. writing something.<|>\n@@ -61,7 +62,7 @@ impl<'a> CompletionContext<'a> {\n             is_trivial_path: false,\n             path_prefix: None,\n             after_if: false,\n-            is_stmt: false,\n+            can_be_stmt: false,\n             is_new_item: false,\n             dot_receiver: None,\n             is_method_call: false,\n@@ -147,13 +148,22 @@ impl<'a> CompletionContext<'a> {\n             if path.qualifier().is_none() {\n                 self.is_trivial_path = true;\n \n-                self.is_stmt = match name_ref\n+                self.can_be_stmt = match name_ref\n                     .syntax()\n                     .ancestors()\n                     .filter_map(ast::ExprStmt::cast)\n                     .next()\n                 {\n-                    None => false,\n+                    None => {\n+                        name_ref\n+                            .syntax()\n+                            .ancestors()\n+                            .filter_map(ast::Block::cast)\n+                            .next()\n+                            .and_then(|block| block.expr())\n+                            .map(|e| e.syntax().range())\n+                            == Some(name_ref.syntax().range())\n+                    }\n                     Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n                 };\n "}]}