{"sha": "49d3fd3b38cd838b241858baaaa6162666badba1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZDNmZDNiMzhjZDgzOGIyNDE4NThiYWFhYTYxNjI2NjZiYWRiYTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-19T03:21:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-19T03:21:47Z"}, "message": "Auto merge of #37787 - michaelwoerister:macro-def-ich, r=nikomatsakis\n\nICH: Handle MacroDef HIR instances.\n\nAs of recently, `hir::MacroDef` instances are exported in crate metadata, which means we also store their ICH when doing incremental compilation. Even though exported macro definitions should not (yet) interact with incremental compilation, the ICH is also used for the general purpose crate hash, where macros should be included.\n\nThis PR implements ICH computation for `MacroDef`. In theory, the ICH of these MacroDefs is less stable than that of other HIR items, since I opted to just call the compiler-generated `Hash::hash()` for `Token::Interpolated` variants. `Token::Interpolated` contains AST data structures and it would have been a lot of effort to expand ICH computation to the AST too. Since quasi-quoting is rarely used *and* it would only make a difference if incremental compilation was extended to macros, the simpler implementation seemed like a good idea.\n\nThis fixes the problem reported in https://github.com/rust-lang/rust/issues/37756. The test still fails because of broken codegen-unit support though.\n\nr? @nikomatsakis", "tree": {"sha": "a09068946f0e895c38a65086ae7b9241eec30fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a09068946f0e895c38a65086ae7b9241eec30fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d3fd3b38cd838b241858baaaa6162666badba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d3fd3b38cd838b241858baaaa6162666badba1", "html_url": "https://github.com/rust-lang/rust/commit/49d3fd3b38cd838b241858baaaa6162666badba1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d3fd3b38cd838b241858baaaa6162666badba1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac635aa95ba851898e125b047ad7b8d6a8fecf8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac635aa95ba851898e125b047ad7b8d6a8fecf8e", "html_url": "https://github.com/rust-lang/rust/commit/ac635aa95ba851898e125b047ad7b8d6a8fecf8e"}, {"sha": "c722a1eb9992ac76f5c3dd0aee36b8734d613f11", "url": "https://api.github.com/repos/rust-lang/rust/commits/c722a1eb9992ac76f5c3dd0aee36b8734d613f11", "html_url": "https://github.com/rust-lang/rust/commit/c722a1eb9992ac76f5c3dd0aee36b8734d613f11"}], "stats": {"total": 183, "additions": 174, "deletions": 9}, "files": [{"sha": "f98e698a1c9d416b740457a4cfb8f0150977c0da", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49d3fd3b38cd838b241858baaaa6162666badba1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d3fd3b38cd838b241858baaaa6162666badba1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=49d3fd3b38cd838b241858baaaa6162666badba1", "patch": "@@ -46,6 +46,7 @@ use self::caching_codemap_view::CachingCodemapView;\n use self::hasher::IchHasher;\n use ich::Fingerprint;\n \n+\n mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n@@ -88,7 +89,12 @@ impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n     type Output = Fingerprint;\n \n     fn index(&self, index: &'a DepNode<DefId>) -> &Fingerprint {\n-        &self.hashes[index]\n+        match self.hashes.get(index) {\n+            Some(fingerprint) => fingerprint,\n+            None => {\n+                bug!(\"Could not find ICH for {:?}\", index);\n+            }\n+        }\n     }\n }\n \n@@ -108,8 +114,12 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n         visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX),\n                                  |v| visit::walk_crate(v, krate));\n-        // FIXME(#37713) if foreign items were item likes, could use ItemLikeVisitor\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+\n+        for macro_def in krate.exported_macros.iter() {\n+            visitor.calculate_node_id(macro_def.id,\n+                                      |v| v.visit_macro_def(macro_def));\n+        }\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);"}, {"sha": "a1ece48462b14fad8ae288dc67d3628580899c1f", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 139, "deletions": 7, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/49d3fd3b38cd838b241858baaaa6162666badba1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d3fd3b38cd838b241858baaaa6162666badba1/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=49d3fd3b38cd838b241858baaaa6162666badba1", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME (#14132): Even this SVH computation still has implementation\n-// artifacts: namely, the order of item declaration will affect the\n-// hash computation, but for many kinds of items the order of\n-// declaration should be irrelevant to the ABI.\n-\n use self::SawExprComponent::*;\n use self::SawAbiComponent::*;\n use self::SawItemComponent::*;\n@@ -24,6 +19,7 @@ use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n+use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def::{Def, PathResolution};\n@@ -769,9 +765,10 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         debug!(\"visit_macro_def: st={:?}\", self.st);\n         SawMacroDef.hash(self.st);\n         hash_attrs!(self, &macro_def.attrs);\n+        for tt in &macro_def.body {\n+            self.hash_token_tree(tt);\n+        }\n         visit::walk_macro_def(self, macro_def)\n-        // FIXME(mw): We should hash the body of the macro too but we don't\n-        //            have a stable way of doing so yet.\n     }\n }\n \n@@ -941,4 +938,139 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             self.overflow_checks_enabled = true;\n         }\n     }\n+\n+    fn hash_token_tree(&mut self, tt: &tokenstream::TokenTree) {\n+        self.hash_discriminant(tt);\n+        match *tt {\n+            tokenstream::TokenTree::Token(span, ref token) => {\n+                hash_span!(self, span);\n+                self.hash_token(token, span);\n+            }\n+            tokenstream::TokenTree::Delimited(span, ref delimited) => {\n+                hash_span!(self, span);\n+                let tokenstream::Delimited {\n+                    ref delim,\n+                    open_span,\n+                    ref tts,\n+                    close_span,\n+                } = **delimited;\n+\n+                delim.hash(self.st);\n+                hash_span!(self, open_span);\n+                tts.len().hash(self.st);\n+                for sub_tt in tts {\n+                    self.hash_token_tree(sub_tt);\n+                }\n+                hash_span!(self, close_span);\n+            }\n+            tokenstream::TokenTree::Sequence(span, ref sequence_repetition) => {\n+                hash_span!(self, span);\n+                let tokenstream::SequenceRepetition {\n+                    ref tts,\n+                    ref separator,\n+                    op,\n+                    num_captures,\n+                } = **sequence_repetition;\n+\n+                tts.len().hash(self.st);\n+                for sub_tt in tts {\n+                    self.hash_token_tree(sub_tt);\n+                }\n+                self.hash_discriminant(separator);\n+                if let Some(ref separator) = *separator {\n+                    self.hash_token(separator, span);\n+                }\n+                op.hash(self.st);\n+                num_captures.hash(self.st);\n+            }\n+        }\n+    }\n+\n+    fn hash_token(&mut self,\n+                  token: &token::Token,\n+                  error_reporting_span: Span) {\n+        self.hash_discriminant(token);\n+        match *token {\n+            token::Token::Eq |\n+            token::Token::Lt |\n+            token::Token::Le |\n+            token::Token::EqEq |\n+            token::Token::Ne |\n+            token::Token::Ge |\n+            token::Token::Gt |\n+            token::Token::AndAnd |\n+            token::Token::OrOr |\n+            token::Token::Not |\n+            token::Token::Tilde |\n+            token::Token::At |\n+            token::Token::Dot |\n+            token::Token::DotDot |\n+            token::Token::DotDotDot |\n+            token::Token::Comma |\n+            token::Token::Semi |\n+            token::Token::Colon |\n+            token::Token::ModSep |\n+            token::Token::RArrow |\n+            token::Token::LArrow |\n+            token::Token::FatArrow |\n+            token::Token::Pound |\n+            token::Token::Dollar |\n+            token::Token::Question |\n+            token::Token::Underscore |\n+            token::Token::Whitespace |\n+            token::Token::Comment |\n+            token::Token::Eof => {}\n+\n+            token::Token::BinOp(bin_op_token) |\n+            token::Token::BinOpEq(bin_op_token) => bin_op_token.hash(self.st),\n+\n+            token::Token::OpenDelim(delim_token) |\n+            token::Token::CloseDelim(delim_token) => delim_token.hash(self.st),\n+\n+            token::Token::Literal(ref lit, ref opt_name) => {\n+                self.hash_discriminant(lit);\n+                match *lit {\n+                    token::Lit::Byte(val) |\n+                    token::Lit::Char(val) |\n+                    token::Lit::Integer(val) |\n+                    token::Lit::Float(val) |\n+                    token::Lit::Str_(val) |\n+                    token::Lit::ByteStr(val) => val.as_str().hash(self.st),\n+                    token::Lit::StrRaw(val, n) |\n+                    token::Lit::ByteStrRaw(val, n) => {\n+                        val.as_str().hash(self.st);\n+                        n.hash(self.st);\n+                    }\n+                };\n+                opt_name.map(ast::Name::as_str).hash(self.st);\n+            }\n+\n+            token::Token::Ident(ident) |\n+            token::Token::Lifetime(ident) |\n+            token::Token::SubstNt(ident) => ident.name.as_str().hash(self.st),\n+            token::Token::MatchNt(ident1, ident2) => {\n+                ident1.name.as_str().hash(self.st);\n+                ident2.name.as_str().hash(self.st);\n+            }\n+\n+            token::Token::Interpolated(ref non_terminal) => {\n+                // FIXME(mw): This could be implemented properly. It's just a\n+                //            lot of work, since we would need to hash the AST\n+                //            in a stable way, in addition to the HIR.\n+                //            Since this is hardly used anywhere, just emit a\n+                //            warning for now.\n+                if self.tcx.sess.opts.debugging_opts.incremental.is_some() {\n+                    let msg = format!(\"Quasi-quoting might make incremental \\\n+                                       compilation very inefficient: {:?}\",\n+                                      non_terminal);\n+                    self.tcx.sess.span_warn(error_reporting_span, &msg[..]);\n+                }\n+\n+                non_terminal.hash(self.st);\n+            }\n+\n+            token::Token::DocComment(val) |\n+            token::Token::Shebang(val) => val.as_str().hash(self.st),\n+        }\n+    }\n }"}, {"sha": "eafef17230367d8a366cd7a41e4e2af3effd5eb6", "filename": "src/test/compile-fail/incr_comp_with_macro_export.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/49d3fd3b38cd838b241858baaaa6162666badba1/src%2Ftest%2Fcompile-fail%2Fincr_comp_with_macro_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d3fd3b38cd838b241858baaaa6162666badba1/src%2Ftest%2Fcompile-fail%2Fincr_comp_with_macro_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fincr_comp_with_macro_export.rs?ref=49d3fd3b38cd838b241858baaaa6162666badba1", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Zincremental=tmp/cfail-tests/incr_comp_with_macro_export\n+// must-compile-successfully\n+\n+\n+// This test case makes sure that we can compile with incremental compilation\n+// enabled when there are macros exported from this crate. (See #37756)\n+\n+#![crate_type=\"rlib\"]\n+\n+#[macro_export]\n+macro_rules! some_macro {\n+    ($e:expr) => ($e + 1)\n+}"}]}