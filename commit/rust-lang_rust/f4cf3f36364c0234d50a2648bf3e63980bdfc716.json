{"sha": "f4cf3f36364c0234d50a2648bf3e63980bdfc716", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0Y2YzZjM2MzY0YzAyMzRkNTBhMjY0OGJmM2U2Mzk4MGJkZmM3MTY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-18T03:35:37Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-18T03:35:37Z"}, "message": "Get benchmarks running again and factor out some parts in common with bin/miri.rs.", "tree": {"sha": "bc08566a40ac193074b17bc6900a8874635f16fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc08566a40ac193074b17bc6900a8874635f16fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4cf3f36364c0234d50a2648bf3e63980bdfc716", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cf3f36364c0234d50a2648bf3e63980bdfc716", "html_url": "https://github.com/rust-lang/rust/commit/f4cf3f36364c0234d50a2648bf3e63980bdfc716", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4cf3f36364c0234d50a2648bf3e63980bdfc716/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35c76c68627cdd761d53ea6c7cb17e09e705dbf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/35c76c68627cdd761d53ea6c7cb17e09e705dbf9", "html_url": "https://github.com/rust-lang/rust/commit/35c76c68627cdd761d53ea6c7cb17e09e705dbf9"}], "stats": {"total": 177, "additions": 99, "deletions": 78}, "files": [{"sha": "1b4b14c427f04526c7c8785a95b17f3395b93929", "filename": "benches/miri_helper.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf3f36364c0234d50a2648bf3e63980bdfc716/benches%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf3f36364c0234d50a2648bf3e63980bdfc716/benches%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fmiri_helper.rs?ref=f4cf3f36364c0234d50a2648bf3e63980bdfc716", "patch": "@@ -8,21 +8,36 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate test;\n \n-use self::miri::interpreter;\n+use self::miri::eval_main;\n use self::rustc::session::Session;\n use self::rustc_driver::{driver, CompilerCalls, Compilation};\n use std::cell::RefCell;\n use std::rc::Rc;\n-use std::env::var;\n use test::Bencher;\n \n pub struct MiriCompilerCalls<'a>(Rc<RefCell<&'a mut Bencher>>);\n \n+fn find_sysroot() -> String {\n+    // Taken from https://github.com/Manishearth/rust-clippy/pull/911.\n+    let home = option_env!(\"RUSTUP_HOME\").or(option_env!(\"MULTIRUST_HOME\"));\n+    let toolchain = option_env!(\"RUSTUP_TOOLCHAIN\").or(option_env!(\"MULTIRUST_TOOLCHAIN\"));\n+    match (home, toolchain) {\n+        (Some(home), Some(toolchain)) => format!(\"{}/toolchains/{}\", home, toolchain),\n+        _ => option_env!(\"RUST_SYSROOT\")\n+            .expect(\"need to specify RUST_SYSROOT env var or use rustup or multirust\")\n+            .to_owned(),\n+    }\n+}\n+\n pub fn run(filename: &str, bencher: &mut Bencher) {\n-    let path = var(\"RUST_SYSROOT\").expect(\"env variable `RUST_SYSROOT` not set\");\n-    rustc_driver::run_compiler(&[\n-        \"miri\".to_string(), format!(\"benches/{}.rs\", filename), \"--sysroot\".to_string(), path.to_string(),\n-    ], &mut MiriCompilerCalls(Rc::new(RefCell::new(bencher))));\n+    let args = &[\n+        \"miri\".to_string(),\n+        format!(\"benches/{}.rs\", filename),\n+        \"--sysroot\".to_string(),\n+        find_sysroot()\n+    ];\n+    let compiler_calls = &mut MiriCompilerCalls(Rc::new(RefCell::new(bencher)));\n+    rustc_driver::run_compiler(args, compiler_calls);\n }\n \n impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n@@ -38,9 +53,15 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n         control.after_analysis.stop = Compilation::Stop;\n         control.after_analysis.callback = Box::new(move |state| {\n             state.session.abort_if_errors();\n-            bencher.borrow_mut().iter(|| {\n-                interpreter::interpret_start_points(state.tcx.unwrap(), state.mir_map.unwrap());\n-            })\n+\n+            let tcx = state.tcx.unwrap();\n+            let mir_map = state.mir_map.unwrap();\n+            let (node_id, _) = state.session.entry_fn.borrow()\n+                .expect(\"no main or start function found\");\n+\n+            bencher.borrow_mut().iter(|| { eval_main(tcx, mir_map, node_id); });\n+\n+            state.session.abort_if_errors();\n         });\n \n         control"}, {"sha": "6a9ad5ce8387feb77cfc99c713a66a9855e3c209", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 67, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf3f36364c0234d50a2648bf3e63980bdfc716/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf3f36364c0234d50a2648bf3e63980bdfc716/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=f4cf3f36364c0234d50a2648bf3e63980bdfc716", "patch": "@@ -9,17 +9,9 @@ extern crate log_settings;\n extern crate syntax;\n #[macro_use] extern crate log;\n \n-use miri::{\n-    EvalContext,\n-    CachedMir,\n-    step,\n-    EvalError,\n-    Frame,\n-};\n+use miri::eval_main;\n use rustc::session::Session;\n use rustc_driver::{driver, CompilerCalls, Compilation};\n-use rustc::ty::{TyCtxt, subst};\n-use rustc::hir::def_id::DefId;\n \n struct MiriCompilerCalls;\n \n@@ -37,72 +29,17 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n \n             let tcx = state.tcx.unwrap();\n             let mir_map = state.mir_map.unwrap();\n+            let (node_id, _) = state.session.entry_fn.borrow()\n+                .expect(\"no main or start function found\");\n+            eval_main(tcx, mir_map, node_id);\n \n-            let (node_id, span) = state.session.entry_fn.borrow().expect(\"no main or start function found\");\n-            debug!(\"found `main` function at: {:?}\", span);\n-\n-            let mir = mir_map.map.get(&node_id).expect(\"no mir for main function\");\n-            let def_id = tcx.map.local_def_id(node_id);\n-            let mut ecx = EvalContext::new(tcx, mir_map);\n-            let substs = tcx.mk_substs(subst::Substs::empty());\n-            let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"main function should not be diverging\");\n-\n-            ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr));\n-\n-            if mir.arg_decls.len() == 2 {\n-                // start function\n-                let ptr_size = ecx.memory().pointer_size;\n-                let nargs = ecx.memory_mut().allocate(ptr_size);\n-                ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-                let args = ecx.memory_mut().allocate(ptr_size);\n-                ecx.memory_mut().write_usize(args, 0).unwrap();\n-                ecx.frame_mut().locals[0] = nargs;\n-                ecx.frame_mut().locals[1] = args;\n-            }\n-\n-            loop {\n-                match step(&mut ecx) {\n-                    Ok(true) => {}\n-                    Ok(false) => break,\n-                    // FIXME: diverging functions can end up here in some future miri\n-                    Err(e) => {\n-                        report(tcx, &ecx, e);\n-                        break;\n-                    }\n-                }\n-            }\n             state.session.abort_if_errors();\n         });\n \n         control\n     }\n }\n \n-fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n-    let frame = ecx.stack().last().expect(\"stackframe was empty\");\n-    let block = &frame.mir.basic_blocks()[frame.block];\n-    let span = if frame.stmt < block.statements.len() {\n-        block.statements[frame.stmt].source_info.span\n-    } else {\n-        block.terminator().source_info.span\n-    };\n-    let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n-    for &Frame { def_id, substs, span, .. } in ecx.stack().iter().rev() {\n-        // FIXME(solson): Find a way to do this without this Display impl hack.\n-        use rustc::util::ppaux;\n-        use std::fmt;\n-        struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n-        impl<'tcx> fmt::Display for Instance<'tcx> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n-                    |tcx| Some(tcx.lookup_item_type(self.0).generics))\n-            }\n-        }\n-        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n-    }\n-    err.emit();\n-}\n-\n fn init_logger() {\n     const MAX_INDENT: usize = 40;\n "}, {"sha": "6cad67cf6e0cc365513ea1340931cc64e32f2847", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf3f36364c0234d50a2648bf3e63980bdfc716/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf3f36364c0234d50a2648bf3e63980bdfc716/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=f4cf3f36364c0234d50a2648bf3e63980bdfc716", "patch": "@@ -1507,3 +1507,65 @@ impl StructExt for layout::Struct {\n         }\n     }\n }\n+\n+pub fn eval_main<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir_map: &'a MirMap<'tcx>,\n+    node_id: ast::NodeId,\n+) {\n+    let mir = mir_map.map.get(&node_id).expect(\"no mir for main function\");\n+    let def_id = tcx.map.local_def_id(node_id);\n+    let mut ecx = EvalContext::new(tcx, mir_map);\n+    let substs = tcx.mk_substs(subst::Substs::empty());\n+    let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"main function should not be diverging\");\n+\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr));\n+\n+    if mir.arg_decls.len() == 2 {\n+        // start function\n+        let ptr_size = ecx.memory().pointer_size;\n+        let nargs = ecx.memory_mut().allocate(ptr_size);\n+        ecx.memory_mut().write_usize(nargs, 0).unwrap();\n+        let args = ecx.memory_mut().allocate(ptr_size);\n+        ecx.memory_mut().write_usize(args, 0).unwrap();\n+        ecx.frame_mut().locals[0] = nargs;\n+        ecx.frame_mut().locals[1] = args;\n+    }\n+\n+    loop {\n+        match step(&mut ecx) {\n+            Ok(true) => {}\n+            Ok(false) => break,\n+            // FIXME: diverging functions can end up here in some future miri\n+            Err(e) => {\n+                report(tcx, &ecx, e);\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {\n+    let frame = ecx.stack().last().expect(\"stackframe was empty\");\n+    let block = &frame.mir.basic_blocks()[frame.block];\n+    let span = if frame.stmt < block.statements.len() {\n+        block.statements[frame.stmt].source_info.span\n+    } else {\n+        block.terminator().source_info.span\n+    };\n+    let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n+    for &Frame { def_id, substs, span, .. } in ecx.stack().iter().rev() {\n+        // FIXME(solson): Find a way to do this without this Display impl hack.\n+        use rustc::util::ppaux;\n+        use std::fmt;\n+        struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n+        impl<'tcx> fmt::Display for Instance<'tcx> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n+                    |tcx| Some(tcx.lookup_item_type(self.0).generics))\n+            }\n+        }\n+        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+    }\n+    err.emit();\n+}"}, {"sha": "ca43aea45c95155768b47755f2c9d74c268eaa65", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf3f36364c0234d50a2648bf3e63980bdfc716/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf3f36364c0234d50a2648bf3e63980bdfc716/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f4cf3f36364c0234d50a2648bf3e63980bdfc716", "patch": "@@ -32,10 +32,11 @@ pub use error::{\n };\n \n pub use interpreter::{\n+    CachedMir,\n     EvalContext,\n-    step,\n     Frame,\n-    CachedMir,\n+    eval_main,\n+    step,\n };\n \n pub use memory::Memory;"}]}