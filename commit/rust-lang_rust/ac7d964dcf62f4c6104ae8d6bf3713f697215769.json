{"sha": "ac7d964dcf62f4c6104ae8d6bf3713f697215769", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjN2Q5NjRkY2Y2MmY0YzYxMDRhZThkNmJmMzcxM2Y2OTcyMTU3Njk=", "commit": {"author": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-20T06:18:12Z"}, "committer": {"name": "Alexis", "email": "a.beingessner@gmail.com", "date": "2015-02-21T00:55:00Z"}, "message": "make int/uint modules just re-exports", "tree": {"sha": "678eadeb55d6f5c919bbe926e23a36e14f902a71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/678eadeb55d6f5c919bbe926e23a36e14f902a71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac7d964dcf62f4c6104ae8d6bf3713f697215769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac7d964dcf62f4c6104ae8d6bf3713f697215769", "html_url": "https://github.com/rust-lang/rust/commit/ac7d964dcf62f4c6104ae8d6bf3713f697215769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac7d964dcf62f4c6104ae8d6bf3713f697215769/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97aa34046ffec7be1e3e4f383f205344ed67da6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/97aa34046ffec7be1e3e4f383f205344ed67da6d", "html_url": "https://github.com/rust-lang/rust/commit/97aa34046ffec7be1e3e4f383f205344ed67da6d"}], "stats": {"total": 258, "additions": 107, "deletions": 151}, "files": [{"sha": "4b6e9cf76f9e570f3566d7d8cc6cb103d61a00a9", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac7d964dcf62f4c6104ae8d6bf3713f697215769/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac7d964dcf62f4c6104ae8d6bf3713f697215769/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ac7d964dcf62f4c6104ae8d6bf3713f697215769", "patch": "@@ -218,15 +218,15 @@ mod int_macros;\n #[macro_use]\n mod uint_macros;\n \n-#[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/isize.rs\"]  pub mod isize;\n+pub use isize as int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n #[path = \"num/i16.rs\"]  pub mod i16;\n #[path = \"num/i32.rs\"]  pub mod i32;\n #[path = \"num/i64.rs\"]  pub mod i64;\n \n-#[path = \"num/uint.rs\"] pub mod uint;\n #[path = \"num/usize.rs\"] pub mod usize;\n+pub use usize as uint;\n #[path = \"num/u8.rs\"]   pub mod u8;\n #[path = \"num/u16.rs\"]  pub mod u16;\n #[path = \"num/u32.rs\"]  pub mod u32;"}, {"sha": "669952eee3924a8bb81e94cd953a16ca965cdc77", "filename": "src/libstd/num/int.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97aa34046ffec7be1e3e4f383f205344ed67da6d/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97aa34046ffec7be1e3e4f383f205344ed67da6d/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=97aa34046ffec7be1e3e4f383f205344ed67da6d", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated: replaced by `isize`.\n-//!\n-//! The rollout of the new type will gradually take place over the\n-//! alpha cycle along with the development of clearer conventions\n-//! around integer types.\n-\n-#![unstable(feature = \"std_misc\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced by isize\")]\n-\n-pub use core::int::{BITS, BYTES, MIN, MAX};\n-\n-int_module! { int }"}, {"sha": "968adfafeab73df1f4e5496403be1708c70c91f0", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 105, "deletions": 105, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/ac7d964dcf62f4c6104ae8d6bf3713f697215769/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac7d964dcf62f4c6104ae8d6bf3713f697215769/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ac7d964dcf62f4c6104ae8d6bf3713f697215769", "patch": "@@ -11,7 +11,7 @@\n //! Numeric traits and functions for generic mathematics\n //!\n //! These are implemented for the primitive numeric types in `std::{u8, u16,\n-//! u32, u64, uint, i8, i16, i32, i64, int, f32, f64}`.\n+//! u32, u64, usize, i8, i16, i32, i64, isize, f32, f64}`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n@@ -146,12 +146,12 @@ pub trait Float\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n     /// Deprecated: use `std::f32::DIGITS` or `std::f64::DIGITS` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> uint;\n+    fn digits(unused_self: Option<Self>) -> usize;\n     /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n@@ -161,22 +161,22 @@ pub trait Float\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> int;\n+    fn min_exp(unused_self: Option<Self>) -> isize;\n     /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> int;\n+    fn max_exp(unused_self: Option<Self>) -> isize;\n     /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    fn min_10_exp(unused_self: Option<Self>) -> isize;\n     /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    fn max_10_exp(unused_self: Option<Self>) -> isize;\n \n     /// Returns the smallest finite value that this type can represent.\n     ///\n@@ -698,7 +698,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n-    fn ldexp(x: Self, exp: int) -> Self;\n+    fn ldexp(x: Self, exp: isize) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n     /// satisfying:\n     ///\n@@ -720,7 +720,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n-    fn frexp(self) -> (Self, int);\n+    fn frexp(self) -> (Self, isize);\n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n     ///\n@@ -1112,12 +1112,12 @@ mod tests {\n     use i16;\n     use i32;\n     use i64;\n-    use int;\n+    use isize;\n     use u8;\n     use u16;\n     use u32;\n     use u64;\n-    use uint;\n+    use usize;\n \n     macro_rules! test_cast_20 {\n         ($_20:expr) => ({\n@@ -1179,33 +1179,33 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_int_min() {\n-        assert_eq!(int::MIN.to_int(),  Some(int::MIN as int));\n-        assert_eq!(int::MIN.to_i8(),   None);\n-        assert_eq!(int::MIN.to_i16(),  None);\n-        // int::MIN.to_i32() is word-size specific\n-        assert_eq!(int::MIN.to_i64(),  Some(int::MIN as i64));\n-        assert_eq!(int::MIN.to_uint(), None);\n-        assert_eq!(int::MIN.to_u8(),   None);\n-        assert_eq!(int::MIN.to_u16(),  None);\n-        assert_eq!(int::MIN.to_u32(),  None);\n-        assert_eq!(int::MIN.to_u64(),  None);\n+        assert_eq!(isize::MIN.to_int(),  Some(isize::MIN as isize));\n+        assert_eq!(isize::MIN.to_i8(),   None);\n+        assert_eq!(isize::MIN.to_i16(),  None);\n+        // isize::MIN.to_i32() is word-size specific\n+        assert_eq!(isize::MIN.to_i64(),  Some(isize::MIN as i64));\n+        assert_eq!(isize::MIN.to_uint(), None);\n+        assert_eq!(isize::MIN.to_u8(),   None);\n+        assert_eq!(isize::MIN.to_u16(),  None);\n+        assert_eq!(isize::MIN.to_u32(),  None);\n+        assert_eq!(isize::MIN.to_u64(),  None);\n \n         #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(int::MIN.to_i32(), Some(int::MIN as i32));\n+            assert_eq!(isize::MIN.to_i32(), Some(isize::MIN as i32));\n         }\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(int::MIN.to_i32(), None);\n+            assert_eq!(isize::MIN.to_i32(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_i8_min() {\n-        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as int));\n+        assert_eq!(i8::MIN.to_int(),  Some(i8::MIN as isize));\n         assert_eq!(i8::MIN.to_i8(),   Some(i8::MIN as i8));\n         assert_eq!(i8::MIN.to_i16(),  Some(i8::MIN as i16));\n         assert_eq!(i8::MIN.to_i32(),  Some(i8::MIN as i32));\n@@ -1219,7 +1219,7 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i16_min() {\n-        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as int));\n+        assert_eq!(i16::MIN.to_int(),  Some(i16::MIN as isize));\n         assert_eq!(i16::MIN.to_i8(),   None);\n         assert_eq!(i16::MIN.to_i16(),  Some(i16::MIN as i16));\n         assert_eq!(i16::MIN.to_i32(),  Some(i16::MIN as i32));\n@@ -1233,7 +1233,7 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i32_min() {\n-        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as int));\n+        assert_eq!(i32::MIN.to_int(),  Some(i32::MIN as isize));\n         assert_eq!(i32::MIN.to_i8(),   None);\n         assert_eq!(i32::MIN.to_i16(),  None);\n         assert_eq!(i32::MIN.to_i32(),  Some(i32::MIN as i32));\n@@ -1265,47 +1265,47 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as int));\n+            assert_eq!(i64::MIN.to_int(), Some(i64::MIN as isize));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_int_max() {\n-        assert_eq!(int::MAX.to_int(),  Some(int::MAX as int));\n-        assert_eq!(int::MAX.to_i8(),   None);\n-        assert_eq!(int::MAX.to_i16(),  None);\n-        // int::MAX.to_i32() is word-size specific\n-        assert_eq!(int::MAX.to_i64(),  Some(int::MAX as i64));\n-        assert_eq!(int::MAX.to_u8(),   None);\n-        assert_eq!(int::MAX.to_u16(),  None);\n-        // int::MAX.to_u32() is word-size specific\n-        assert_eq!(int::MAX.to_u64(),  Some(int::MAX as u64));\n+        assert_eq!(isize::MAX.to_int(),  Some(isize::MAX as isize));\n+        assert_eq!(isize::MAX.to_i8(),   None);\n+        assert_eq!(isize::MAX.to_i16(),  None);\n+        // isize::MAX.to_i32() is word-size specific\n+        assert_eq!(isize::MAX.to_i64(),  Some(isize::MAX as i64));\n+        assert_eq!(isize::MAX.to_u8(),   None);\n+        assert_eq!(isize::MAX.to_u16(),  None);\n+        // isize::MAX.to_u32() is word-size specific\n+        assert_eq!(isize::MAX.to_u64(),  Some(isize::MAX as u64));\n \n         #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(int::MAX.to_i32(), Some(int::MAX as i32));\n-            assert_eq!(int::MAX.to_u32(), Some(int::MAX as u32));\n+            assert_eq!(isize::MAX.to_i32(), Some(isize::MAX as i32));\n+            assert_eq!(isize::MAX.to_u32(), Some(isize::MAX as u32));\n         }\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(int::MAX.to_i32(), None);\n-            assert_eq!(int::MAX.to_u32(), None);\n+            assert_eq!(isize::MAX.to_i32(), None);\n+            assert_eq!(isize::MAX.to_u32(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_i8_max() {\n-        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as int));\n+        assert_eq!(i8::MAX.to_int(),  Some(i8::MAX as isize));\n         assert_eq!(i8::MAX.to_i8(),   Some(i8::MAX as i8));\n         assert_eq!(i8::MAX.to_i16(),  Some(i8::MAX as i16));\n         assert_eq!(i8::MAX.to_i32(),  Some(i8::MAX as i32));\n         assert_eq!(i8::MAX.to_i64(),  Some(i8::MAX as i64));\n-        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as uint));\n+        assert_eq!(i8::MAX.to_uint(), Some(i8::MAX as usize));\n         assert_eq!(i8::MAX.to_u8(),   Some(i8::MAX as u8));\n         assert_eq!(i8::MAX.to_u16(),  Some(i8::MAX as u16));\n         assert_eq!(i8::MAX.to_u32(),  Some(i8::MAX as u32));\n@@ -1314,12 +1314,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i16_max() {\n-        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as int));\n+        assert_eq!(i16::MAX.to_int(),  Some(i16::MAX as isize));\n         assert_eq!(i16::MAX.to_i8(),   None);\n         assert_eq!(i16::MAX.to_i16(),  Some(i16::MAX as i16));\n         assert_eq!(i16::MAX.to_i32(),  Some(i16::MAX as i32));\n         assert_eq!(i16::MAX.to_i64(),  Some(i16::MAX as i64));\n-        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as uint));\n+        assert_eq!(i16::MAX.to_uint(), Some(i16::MAX as usize));\n         assert_eq!(i16::MAX.to_u8(),   None);\n         assert_eq!(i16::MAX.to_u16(),  Some(i16::MAX as u16));\n         assert_eq!(i16::MAX.to_u32(),  Some(i16::MAX as u32));\n@@ -1328,12 +1328,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_i32_max() {\n-        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as int));\n+        assert_eq!(i32::MAX.to_int(),  Some(i32::MAX as isize));\n         assert_eq!(i32::MAX.to_i8(),   None);\n         assert_eq!(i32::MAX.to_i16(),  None);\n         assert_eq!(i32::MAX.to_i32(),  Some(i32::MAX as i32));\n         assert_eq!(i32::MAX.to_i64(),  Some(i32::MAX as i64));\n-        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as uint));\n+        assert_eq!(i32::MAX.to_uint(), Some(i32::MAX as usize));\n         assert_eq!(i32::MAX.to_u8(),   None);\n         assert_eq!(i32::MAX.to_u16(),  None);\n         assert_eq!(i32::MAX.to_u32(),  Some(i32::MAX as u32));\n@@ -1361,35 +1361,35 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as int));\n-            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as uint));\n+            assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as isize));\n+            assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as usize));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_uint_min() {\n-        assert_eq!(uint::MIN.to_int(),  Some(uint::MIN as int));\n-        assert_eq!(uint::MIN.to_i8(),   Some(uint::MIN as i8));\n-        assert_eq!(uint::MIN.to_i16(),  Some(uint::MIN as i16));\n-        assert_eq!(uint::MIN.to_i32(),  Some(uint::MIN as i32));\n-        assert_eq!(uint::MIN.to_i64(),  Some(uint::MIN as i64));\n-        assert_eq!(uint::MIN.to_uint(), Some(uint::MIN as uint));\n-        assert_eq!(uint::MIN.to_u8(),   Some(uint::MIN as u8));\n-        assert_eq!(uint::MIN.to_u16(),  Some(uint::MIN as u16));\n-        assert_eq!(uint::MIN.to_u32(),  Some(uint::MIN as u32));\n-        assert_eq!(uint::MIN.to_u64(),  Some(uint::MIN as u64));\n+        assert_eq!(usize::MIN.to_int(),  Some(usize::MIN as isize));\n+        assert_eq!(usize::MIN.to_i8(),   Some(usize::MIN as i8));\n+        assert_eq!(usize::MIN.to_i16(),  Some(usize::MIN as i16));\n+        assert_eq!(usize::MIN.to_i32(),  Some(usize::MIN as i32));\n+        assert_eq!(usize::MIN.to_i64(),  Some(usize::MIN as i64));\n+        assert_eq!(usize::MIN.to_uint(), Some(usize::MIN as usize));\n+        assert_eq!(usize::MIN.to_u8(),   Some(usize::MIN as u8));\n+        assert_eq!(usize::MIN.to_u16(),  Some(usize::MIN as u16));\n+        assert_eq!(usize::MIN.to_u32(),  Some(usize::MIN as u32));\n+        assert_eq!(usize::MIN.to_u64(),  Some(usize::MIN as u64));\n     }\n \n     #[test]\n     fn test_cast_range_u8_min() {\n-        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as int));\n+        assert_eq!(u8::MIN.to_int(),  Some(u8::MIN as isize));\n         assert_eq!(u8::MIN.to_i8(),   Some(u8::MIN as i8));\n         assert_eq!(u8::MIN.to_i16(),  Some(u8::MIN as i16));\n         assert_eq!(u8::MIN.to_i32(),  Some(u8::MIN as i32));\n         assert_eq!(u8::MIN.to_i64(),  Some(u8::MIN as i64));\n-        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as uint));\n+        assert_eq!(u8::MIN.to_uint(), Some(u8::MIN as usize));\n         assert_eq!(u8::MIN.to_u8(),   Some(u8::MIN as u8));\n         assert_eq!(u8::MIN.to_u16(),  Some(u8::MIN as u16));\n         assert_eq!(u8::MIN.to_u32(),  Some(u8::MIN as u32));\n@@ -1398,12 +1398,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u16_min() {\n-        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as int));\n+        assert_eq!(u16::MIN.to_int(),  Some(u16::MIN as isize));\n         assert_eq!(u16::MIN.to_i8(),   Some(u16::MIN as i8));\n         assert_eq!(u16::MIN.to_i16(),  Some(u16::MIN as i16));\n         assert_eq!(u16::MIN.to_i32(),  Some(u16::MIN as i32));\n         assert_eq!(u16::MIN.to_i64(),  Some(u16::MIN as i64));\n-        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as uint));\n+        assert_eq!(u16::MIN.to_uint(), Some(u16::MIN as usize));\n         assert_eq!(u16::MIN.to_u8(),   Some(u16::MIN as u8));\n         assert_eq!(u16::MIN.to_u16(),  Some(u16::MIN as u16));\n         assert_eq!(u16::MIN.to_u32(),  Some(u16::MIN as u32));\n@@ -1412,12 +1412,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u32_min() {\n-        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as int));\n+        assert_eq!(u32::MIN.to_int(),  Some(u32::MIN as isize));\n         assert_eq!(u32::MIN.to_i8(),   Some(u32::MIN as i8));\n         assert_eq!(u32::MIN.to_i16(),  Some(u32::MIN as i16));\n         assert_eq!(u32::MIN.to_i32(),  Some(u32::MIN as i32));\n         assert_eq!(u32::MIN.to_i64(),  Some(u32::MIN as i64));\n-        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as uint));\n+        assert_eq!(u32::MIN.to_uint(), Some(u32::MIN as usize));\n         assert_eq!(u32::MIN.to_u8(),   Some(u32::MIN as u8));\n         assert_eq!(u32::MIN.to_u16(),  Some(u32::MIN as u16));\n         assert_eq!(u32::MIN.to_u32(),  Some(u32::MIN as u32));\n@@ -1426,12 +1426,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u64_min() {\n-        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as int));\n+        assert_eq!(u64::MIN.to_int(),  Some(u64::MIN as isize));\n         assert_eq!(u64::MIN.to_i8(),   Some(u64::MIN as i8));\n         assert_eq!(u64::MIN.to_i16(),  Some(u64::MIN as i16));\n         assert_eq!(u64::MIN.to_i32(),  Some(u64::MIN as i32));\n         assert_eq!(u64::MIN.to_i64(),  Some(u64::MIN as i64));\n-        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as uint));\n+        assert_eq!(u64::MIN.to_uint(), Some(u64::MIN as usize));\n         assert_eq!(u64::MIN.to_u8(),   Some(u64::MIN as u8));\n         assert_eq!(u64::MIN.to_u16(),  Some(u64::MIN as u16));\n         assert_eq!(u64::MIN.to_u32(),  Some(u64::MIN as u32));\n@@ -1440,39 +1440,39 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_uint_max() {\n-        assert_eq!(uint::MAX.to_int(),  None);\n-        assert_eq!(uint::MAX.to_i8(),   None);\n-        assert_eq!(uint::MAX.to_i16(),  None);\n-        assert_eq!(uint::MAX.to_i32(),  None);\n-        // uint::MAX.to_i64() is word-size specific\n-        assert_eq!(uint::MAX.to_u8(),   None);\n-        assert_eq!(uint::MAX.to_u16(),  None);\n-        // uint::MAX.to_u32() is word-size specific\n-        assert_eq!(uint::MAX.to_u64(),  Some(uint::MAX as u64));\n+        assert_eq!(usize::MAX.to_int(),  None);\n+        assert_eq!(usize::MAX.to_i8(),   None);\n+        assert_eq!(usize::MAX.to_i16(),  None);\n+        assert_eq!(usize::MAX.to_i32(),  None);\n+        // usize::MAX.to_i64() is word-size specific\n+        assert_eq!(usize::MAX.to_u8(),   None);\n+        assert_eq!(usize::MAX.to_u16(),  None);\n+        // usize::MAX.to_u32() is word-size specific\n+        assert_eq!(usize::MAX.to_u64(),  Some(usize::MAX as u64));\n \n         #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n-            assert_eq!(uint::MAX.to_u32(), Some(uint::MAX as u32));\n-            assert_eq!(uint::MAX.to_i64(), Some(uint::MAX as i64));\n+            assert_eq!(usize::MAX.to_u32(), Some(usize::MAX as u32));\n+            assert_eq!(usize::MAX.to_i64(), Some(usize::MAX as i64));\n         }\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(uint::MAX.to_u32(), None);\n-            assert_eq!(uint::MAX.to_i64(), None);\n+            assert_eq!(usize::MAX.to_u32(), None);\n+            assert_eq!(usize::MAX.to_i64(), None);\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_cast_range_u8_max() {\n-        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as int));\n+        assert_eq!(u8::MAX.to_int(),  Some(u8::MAX as isize));\n         assert_eq!(u8::MAX.to_i8(),   None);\n         assert_eq!(u8::MAX.to_i16(),  Some(u8::MAX as i16));\n         assert_eq!(u8::MAX.to_i32(),  Some(u8::MAX as i32));\n         assert_eq!(u8::MAX.to_i64(),  Some(u8::MAX as i64));\n-        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as uint));\n+        assert_eq!(u8::MAX.to_uint(), Some(u8::MAX as usize));\n         assert_eq!(u8::MAX.to_u8(),   Some(u8::MAX as u8));\n         assert_eq!(u8::MAX.to_u16(),  Some(u8::MAX as u16));\n         assert_eq!(u8::MAX.to_u32(),  Some(u8::MAX as u32));\n@@ -1481,12 +1481,12 @@ mod tests {\n \n     #[test]\n     fn test_cast_range_u16_max() {\n-        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as int));\n+        assert_eq!(u16::MAX.to_int(),  Some(u16::MAX as isize));\n         assert_eq!(u16::MAX.to_i8(),   None);\n         assert_eq!(u16::MAX.to_i16(),  None);\n         assert_eq!(u16::MAX.to_i32(),  Some(u16::MAX as i32));\n         assert_eq!(u16::MAX.to_i64(),  Some(u16::MAX as i64));\n-        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as uint));\n+        assert_eq!(u16::MAX.to_uint(), Some(u16::MAX as usize));\n         assert_eq!(u16::MAX.to_u8(),   None);\n         assert_eq!(u16::MAX.to_u16(),  Some(u16::MAX as u16));\n         assert_eq!(u16::MAX.to_u32(),  Some(u16::MAX as u32));\n@@ -1500,7 +1500,7 @@ mod tests {\n         assert_eq!(u32::MAX.to_i16(),  None);\n         assert_eq!(u32::MAX.to_i32(),  None);\n         assert_eq!(u32::MAX.to_i64(),  Some(u32::MAX as i64));\n-        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as uint));\n+        assert_eq!(u32::MAX.to_uint(), Some(u32::MAX as usize));\n         assert_eq!(u32::MAX.to_u8(),   None);\n         assert_eq!(u32::MAX.to_u16(),  None);\n         assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n@@ -1513,7 +1513,7 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as int));\n+            assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as isize));\n         }\n \n         check_word_size();\n@@ -1539,15 +1539,15 @@ mod tests {\n \n         #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n-            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as uint));\n+            assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as usize));\n         }\n \n         check_word_size();\n     }\n \n     #[test]\n     fn test_saturating_add_uint() {\n-        use uint::MAX;\n+        use usize::MAX;\n         assert_eq!(3_usize.saturating_add(5_usize), 8_usize);\n         assert_eq!(3_usize.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n@@ -1556,7 +1556,7 @@ mod tests {\n \n     #[test]\n     fn test_saturating_sub_uint() {\n-        use uint::MAX;\n+        use usize::MAX;\n         assert_eq!(5_usize.saturating_sub(3_usize), 2_usize);\n         assert_eq!(3_usize.saturating_sub(5_usize), 0_usize);\n         assert_eq!(0_usize.saturating_sub(1_usize), 0_usize);\n@@ -1565,7 +1565,7 @@ mod tests {\n \n     #[test]\n     fn test_saturating_add_int() {\n-        use int::{MIN,MAX};\n+        use isize::{MIN,MAX};\n         assert_eq!(3.saturating_add(5), 8);\n         assert_eq!(3.saturating_add(MAX-1), MAX);\n         assert_eq!(MAX.saturating_add(MAX), MAX);\n@@ -1577,7 +1577,7 @@ mod tests {\n \n     #[test]\n     fn test_saturating_sub_int() {\n-        use int::{MIN,MAX};\n+        use isize::{MIN,MAX};\n         assert_eq!(3.saturating_sub(5), -2);\n         assert_eq!(MIN.saturating_sub(1), MIN);\n         assert_eq!((-2).saturating_sub(MAX), MIN);\n@@ -1589,13 +1589,13 @@ mod tests {\n \n     #[test]\n     fn test_checked_add() {\n-        let five_less = uint::MAX - 5;\n-        assert_eq!(five_less.checked_add(0), Some(uint::MAX - 5));\n-        assert_eq!(five_less.checked_add(1), Some(uint::MAX - 4));\n-        assert_eq!(five_less.checked_add(2), Some(uint::MAX - 3));\n-        assert_eq!(five_less.checked_add(3), Some(uint::MAX - 2));\n-        assert_eq!(five_less.checked_add(4), Some(uint::MAX - 1));\n-        assert_eq!(five_less.checked_add(5), Some(uint::MAX));\n+        let five_less = usize::MAX - 5;\n+        assert_eq!(five_less.checked_add(0), Some(usize::MAX - 5));\n+        assert_eq!(five_less.checked_add(1), Some(usize::MAX - 4));\n+        assert_eq!(five_less.checked_add(2), Some(usize::MAX - 3));\n+        assert_eq!(five_less.checked_add(3), Some(usize::MAX - 2));\n+        assert_eq!(five_less.checked_add(4), Some(usize::MAX - 1));\n+        assert_eq!(five_less.checked_add(5), Some(usize::MAX));\n         assert_eq!(five_less.checked_add(6), None);\n         assert_eq!(five_less.checked_add(7), None);\n     }\n@@ -1614,7 +1614,7 @@ mod tests {\n \n     #[test]\n     fn test_checked_mul() {\n-        let third = uint::MAX / 3;\n+        let third = usize::MAX / 3;\n         assert_eq!(third.checked_mul(0), Some(0));\n         assert_eq!(third.checked_mul(1), Some(third));\n         assert_eq!(third.checked_mul(2), Some(third * 2));\n@@ -1641,7 +1641,7 @@ mod tests {\n     test_is_power_of_two!{ test_is_power_of_two_u16, u16 }\n     test_is_power_of_two!{ test_is_power_of_two_u32, u32 }\n     test_is_power_of_two!{ test_is_power_of_two_u64, u64 }\n-    test_is_power_of_two!{ test_is_power_of_two_uint, uint }\n+    test_is_power_of_two!{ test_is_power_of_two_uint, usize }\n \n     macro_rules! test_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n@@ -1661,7 +1661,7 @@ mod tests {\n     test_next_power_of_two! { test_next_power_of_two_u16, u16 }\n     test_next_power_of_two! { test_next_power_of_two_u32, u32 }\n     test_next_power_of_two! { test_next_power_of_two_u64, u64 }\n-    test_next_power_of_two! { test_next_power_of_two_uint, uint }\n+    test_next_power_of_two! { test_next_power_of_two_uint, usize }\n \n     macro_rules! test_checked_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n@@ -1684,19 +1684,19 @@ mod tests {\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u16, u16 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u32, u32 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n-    test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, uint }\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, usize }\n \n     #[derive(PartialEq, Debug)]\n-    struct Value { x: int }\n+    struct Value { x: isize }\n \n     impl ToPrimitive for Value {\n         fn to_i64(&self) -> Option<i64> { self.x.to_i64() }\n         fn to_u64(&self) -> Option<u64> { self.x.to_u64() }\n     }\n \n     impl FromPrimitive for Value {\n-        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as int }) }\n-        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as int }) }\n+        fn from_i64(n: i64) -> Option<Value> { Some(Value { x: n as isize }) }\n+        fn from_u64(n: u64) -> Option<Value> { Some(Value { x: n as isize }) }\n     }\n \n     #[test]\n@@ -1734,7 +1734,7 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn naive_pow<T: Int>(base: T, exp: uint) -> T {\n+        fn naive_pow<T: Int>(base: T, exp: usize) -> T {\n             let one: T = Int::one();\n             (0..exp).fold(one, |acc, _| acc * base)\n         }"}, {"sha": "c7b491381f337abca0b65054bfdaa8b620469cd9", "filename": "src/libstd/num/uint.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/97aa34046ffec7be1e3e4f383f205344ed67da6d/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97aa34046ffec7be1e3e4f383f205344ed67da6d/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=97aa34046ffec7be1e3e4f383f205344ed67da6d", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Deprecated: replaced by `usize`.\n-//!\n-//! The rollout of the new type will gradually take place over the\n-//! alpha cycle along with the development of clearer conventions\n-//! around integer types.\n-\n-#![unstable(feature = \"std_misc\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced by usize\")]\n-\n-pub use core::uint::{BITS, BYTES, MIN, MAX};\n-\n-uint_module! { uint }"}]}