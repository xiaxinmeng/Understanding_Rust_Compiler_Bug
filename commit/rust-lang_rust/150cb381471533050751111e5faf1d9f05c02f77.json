{"sha": "150cb381471533050751111e5faf1d9f05c02f77", "node_id": "C_kwDOAAsO6NoAKDE1MGNiMzgxNDcxNTMzMDUwNzUxMTExZTVmYWYxZDlmMDVjMDJmNzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T06:48:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T06:48:30Z"}, "message": "Auto merge of #108794 - nnethercote:avoid-unnecessary-hashing, r=cjgillot\n\nAvoid unnecessary hashing\n\nI noticed some stable hashing being done in a non-incremental build. It turns out that some of this is necessary to compute the crate hash, but some of it is not. Removing the unnecessary hashing is a perf win.\n\nr? `@cjgillot`", "tree": {"sha": "3180ee8fcea1444fdcfe2038f48bf3e06c661799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3180ee8fcea1444fdcfe2038f48bf3e06c661799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/150cb381471533050751111e5faf1d9f05c02f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/150cb381471533050751111e5faf1d9f05c02f77", "html_url": "https://github.com/rust-lang/rust/commit/150cb381471533050751111e5faf1d9f05c02f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/150cb381471533050751111e5faf1d9f05c02f77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "501ad021b9a4fb2cd6a39e0302d22f169f6166b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/501ad021b9a4fb2cd6a39e0302d22f169f6166b0", "html_url": "https://github.com/rust-lang/rust/commit/501ad021b9a4fb2cd6a39e0302d22f169f6166b0"}, {"sha": "9570023ce13d0b2fb3d5b79ce9db57e6d28c31d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9570023ce13d0b2fb3d5b79ce9db57e6d28c31d1", "html_url": "https://github.com/rust-lang/rust/commit/9570023ce13d0b2fb3d5b79ce9db57e6d28c31d1"}], "stats": {"total": 182, "additions": 100, "deletions": 82}, "files": [{"sha": "9e7027d5ae03723e234f6a12515527c454413a71", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -464,8 +464,10 @@ pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n         rustc_span::hygiene::clear_syntax_context_map();\n     }\n \n-    let hir_hash = compute_hir_hash(tcx, &owners);\n-    hir::Crate { owners, hir_hash }\n+    // Don't hash unless necessary, because it's expensive.\n+    let opt_hir_hash =\n+        if tcx.sess.needs_crate_hash() { Some(compute_hir_hash(tcx, &owners)) } else { None };\n+    hir::Crate { owners, opt_hir_hash }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -658,42 +660,33 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         bodies.sort_by_key(|(k, _)| *k);\n         let bodies = SortedMap::from_presorted_elements(bodies);\n-        let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n-        let (nodes, parenting) =\n-            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n-        let nodes = hir::OwnerNodes { hash_including_bodies, hash_without_bodies, nodes, bodies };\n-        let attrs = {\n-            let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n+\n+        // Don't hash unless necessary, because it's expensive.\n+        let (opt_hash_including_bodies, attrs_hash) = if self.tcx.sess.needs_crate_hash() {\n+            self.tcx.with_stable_hashing_context(|mut hcx| {\n+                let mut stable_hasher = StableHasher::new();\n+                hcx.with_hir_bodies(node.def_id(), &bodies, |hcx| {\n+                    node.hash_stable(hcx, &mut stable_hasher)\n+                });\n+                let h1 = stable_hasher.finish();\n+\n                 let mut stable_hasher = StableHasher::new();\n                 attrs.hash_stable(&mut hcx, &mut stable_hasher);\n-                stable_hasher.finish()\n-            });\n-            hir::AttributeMap { map: attrs, hash }\n+                let h2 = stable_hasher.finish();\n+\n+                (Some(h1), Some(h2))\n+            })\n+        } else {\n+            (None, None)\n         };\n+        let (nodes, parenting) =\n+            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n+        let nodes = hir::OwnerNodes { opt_hash_including_bodies, nodes, bodies };\n+        let attrs = hir::AttributeMap { map: attrs, opt_hash: attrs_hash };\n \n         self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n-    /// Hash the HIR node twice, one deep and one shallow hash. This allows to differentiate\n-    /// queries which depend on the full HIR tree and those which only depend on the item signature.\n-    fn hash_owner(\n-        &mut self,\n-        node: hir::OwnerNode<'hir>,\n-        bodies: &SortedMap<hir::ItemLocalId, &'hir hir::Body<'hir>>,\n-    ) -> (Fingerprint, Fingerprint) {\n-        self.tcx.with_stable_hashing_context(|mut hcx| {\n-            let mut stable_hasher = StableHasher::new();\n-            hcx.with_hir_bodies(node.def_id(), bodies, |hcx| {\n-                node.hash_stable(hcx, &mut stable_hasher)\n-            });\n-            let hash_including_bodies = stable_hasher.finish();\n-            let mut stable_hasher = StableHasher::new();\n-            hcx.without_hir_bodies(|hcx| node.hash_stable(hcx, &mut stable_hasher));\n-            let hash_without_bodies = stable_hasher.finish();\n-            (hash_including_bodies, hash_without_bodies)\n-        })\n-    }\n-\n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n     /// the `LoweringContext`'s `NodeId => HirId` map.\n     /// Take care not to call this method if the resulting `HirId` is then not"}, {"sha": "f00a5f24e45459f1a2156f3c8b7775eecb6fa166", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -815,12 +815,13 @@ pub struct ParentedNode<'tcx> {\n #[derive(Debug)]\n pub struct AttributeMap<'tcx> {\n     pub map: SortedMap<ItemLocalId, &'tcx [Attribute]>,\n-    pub hash: Fingerprint,\n+    // Only present when the crate hash is needed.\n+    pub opt_hash: Option<Fingerprint>,\n }\n \n impl<'tcx> AttributeMap<'tcx> {\n     pub const EMPTY: &'static AttributeMap<'static> =\n-        &AttributeMap { map: SortedMap::new(), hash: Fingerprint::ZERO };\n+        &AttributeMap { map: SortedMap::new(), opt_hash: Some(Fingerprint::ZERO) };\n \n     #[inline]\n     pub fn get(&self, id: ItemLocalId) -> &'tcx [Attribute] {\n@@ -832,10 +833,9 @@ impl<'tcx> AttributeMap<'tcx> {\n /// These nodes are mapped by `ItemLocalId` alongside the index of their parent node.\n /// The HIR tree, including bodies, is pre-hashed.\n pub struct OwnerNodes<'tcx> {\n-    /// Pre-computed hash of the full HIR.\n-    pub hash_including_bodies: Fingerprint,\n-    /// Pre-computed hash of the item signature, without recursing into the body.\n-    pub hash_without_bodies: Fingerprint,\n+    /// Pre-computed hash of the full HIR. Used in the crate hash. Only present\n+    /// when incr. comp. is enabled.\n+    pub opt_hash_including_bodies: Option<Fingerprint>,\n     /// Full HIR for the current owner.\n     // The zeroth node's parent should never be accessed: the owner's parent is computed by the\n     // hir_owner_parent query. It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n@@ -872,8 +872,7 @@ impl fmt::Debug for OwnerNodes<'_> {\n                     .collect::<Vec<_>>(),\n             )\n             .field(\"bodies\", &self.bodies)\n-            .field(\"hash_without_bodies\", &self.hash_without_bodies)\n-            .field(\"hash_including_bodies\", &self.hash_including_bodies)\n+            .field(\"opt_hash_including_bodies\", &self.opt_hash_including_bodies)\n             .finish()\n     }\n }\n@@ -940,7 +939,8 @@ impl<T> MaybeOwner<T> {\n #[derive(Debug)]\n pub struct Crate<'hir> {\n     pub owners: IndexVec<LocalDefId, MaybeOwner<&'hir OwnerInfo<'hir>>>,\n-    pub hir_hash: Fingerprint,\n+    // Only present when incr. comp. is enabled.\n+    pub opt_hir_hash: Option<Fingerprint>,\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "97fa710b35499f0f4879365245007321c33a0588", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -100,24 +100,23 @@ impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for OwnerNodes<'\n         // `local_id_to_def_id` is also ignored because is dependent on the body, then just hashing\n         // the body satisfies the condition of two nodes being different have different\n         // `hash_stable` results.\n-        let OwnerNodes { hash_including_bodies, hash_without_bodies: _, nodes: _, bodies: _ } =\n-            *self;\n-        hash_including_bodies.hash_stable(hcx, hasher);\n+        let OwnerNodes { opt_hash_including_bodies, nodes: _, bodies: _ } = *self;\n+        opt_hash_including_bodies.unwrap().hash_stable(hcx, hasher);\n     }\n }\n \n impl<'tcx, HirCtx: crate::HashStableContext> HashStable<HirCtx> for AttributeMap<'tcx> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        // We ignore the `map` since it refers to information included in `hash` which is hashed in\n-        // the collector and used for the crate hash.\n-        let AttributeMap { hash, map: _ } = *self;\n-        hash.hash_stable(hcx, hasher);\n+        // We ignore the `map` since it refers to information included in `opt_hash` which is\n+        // hashed in the collector and used for the crate hash.\n+        let AttributeMap { opt_hash, map: _ } = *self;\n+        opt_hash.unwrap().hash_stable(hcx, hasher);\n     }\n }\n \n impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Crate<'_> {\n     fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let Crate { owners: _, hir_hash } = self;\n-        hir_hash.hash_stable(hcx, hasher)\n+        let Crate { owners: _, opt_hir_hash } = self;\n+        opt_hir_hash.unwrap().hash_stable(hcx, hasher)\n     }\n }"}, {"sha": "4deae9f41c712d53bd83a8614b3fc22b1206d5b9", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -297,10 +297,12 @@ pub fn prepare_session_directory(\n /// renaming it to `s-{timestamp}-{svh}` and releasing the file lock.\n /// If there have been compilation errors, however, this function will just\n /// delete the presumably invalid session directory.\n-pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n+pub fn finalize_session_directory(sess: &Session, svh: Option<Svh>) {\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n+    // The svh is always produced when incr. comp. is enabled.\n+    let svh = svh.unwrap();\n \n     let _timer = sess.timer(\"incr_comp_finalize_session_directory\");\n "}, {"sha": "58ad044b399b6d76b965517c3c1f4bd7574e8125", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -284,7 +284,11 @@ impl<'tcx> Queries<'tcx> {\n         let codegen_backend = self.codegen_backend().clone();\n \n         let (crate_hash, prepare_outputs, dep_graph) = self.global_ctxt()?.enter(|tcx| {\n-            (tcx.crate_hash(LOCAL_CRATE), tcx.output_filenames(()).clone(), tcx.dep_graph.clone())\n+            (\n+                if tcx.sess.needs_crate_hash() { Some(tcx.crate_hash(LOCAL_CRATE)) } else { None },\n+                tcx.output_filenames(()).clone(),\n+                tcx.dep_graph.clone(),\n+            )\n         });\n         let ongoing_codegen = self.ongoing_codegen()?.steal();\n \n@@ -308,7 +312,8 @@ pub struct Linker {\n     // compilation outputs\n     dep_graph: DepGraph,\n     prepare_outputs: Arc<OutputFilenames>,\n-    crate_hash: Svh,\n+    // Only present when incr. comp. is enabled.\n+    crate_hash: Option<Svh>,\n     ongoing_codegen: Box<dyn Any>,\n }\n "}, {"sha": "08de828fbdba246e020a3231eb55a34a66709a7f", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -6,9 +6,9 @@ use crate::{encode_metadata, EncodedMetadata};\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{CrateType, OutputType};\n+use rustc_session::config::OutputType;\n use rustc_session::output::filename_for_metadata;\n-use rustc_session::Session;\n+use rustc_session::{MetadataKind, Session};\n use tempfile::Builder as TempFileBuilder;\n \n use std::fs;\n@@ -39,27 +39,6 @@ pub fn emit_wrapper_file(\n }\n \n pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n-    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n-    enum MetadataKind {\n-        None,\n-        Uncompressed,\n-        Compressed,\n-    }\n-\n-    let metadata_kind = tcx\n-        .sess\n-        .crate_types()\n-        .iter()\n-        .map(|ty| match *ty {\n-            CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,\n-\n-            CrateType::Rlib => MetadataKind::Uncompressed,\n-\n-            CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n-        })\n-        .max()\n-        .unwrap_or(MetadataKind::None);\n-\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let out_filename = filename_for_metadata(tcx.sess, crate_name, tcx.output_filenames(()));\n     // To avoid races with another rustc process scanning the output directory,\n@@ -76,6 +55,7 @@ pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n \n     // Always create a file at `metadata_filename`, even if we have nothing to write to it.\n     // This simplifies the creation of the output `out_filename` when requested.\n+    let metadata_kind = tcx.sess.metadata_kind();\n     match metadata_kind {\n         MetadataKind::None => {\n             std::fs::File::create(&metadata_filename).unwrap_or_else(|err| {"}, {"sha": "746cf4885893260e214fbfa744dad26e1cf19413", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -1134,7 +1134,7 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     debug_assert_eq!(crate_num, LOCAL_CRATE);\n     let krate = tcx.hir_crate(());\n-    let hir_body_hash = krate.hir_hash;\n+    let hir_body_hash = krate.opt_hir_hash.expect(\"HIR hash missing while computing crate hash\");\n \n     let upstream_crates = upstream_crates(tcx);\n "}, {"sha": "6c0566cd9e8a9f36aa09f1fcfe8248860ea0a050", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -8,7 +8,6 @@ pub mod place;\n \n use crate::ty::query::Providers;\n use crate::ty::{ImplSubject, TyCtxt};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -24,14 +23,15 @@ use rustc_span::{ExpnId, DUMMY_SP};\n #[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n     node: OwnerNode<'tcx>,\n-    hash_without_bodies: Fingerprint,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Owner { node: _, hash_without_bodies } = self;\n-        hash_without_bodies.hash_stable(hcx, hasher)\n+        // Perform a shallow hash instead using the deep hash saved in `OwnerNodes`. This lets us\n+        // differentiate queries that depend on the full HIR tree from those that only depend on\n+        // the item signature.\n+        hcx.without_hir_bodies(|hcx| self.node.hash_stable(hcx, hasher));\n     }\n }\n \n@@ -123,7 +123,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_owner = |tcx, id| {\n         let owner = tcx.hir_crate(()).owners.get(id.def_id)?.as_owner()?;\n         let node = owner.node();\n-        Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n+        Some(Owner { node })\n     };\n     providers.opt_local_def_id_to_hir_id = |tcx, id| {\n         let owner = tcx.hir_crate(()).owners[id].map(|_| ());"}, {"sha": "5ecb2d6a6313e4565b9660841ecbf751d9b029c8", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -577,5 +577,5 @@ fn get_body_span<'tcx>(\n fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, hir_body: &'tcx rustc_hir::Body<'tcx>) -> u64 {\n     // FIXME(cjgillot) Stop hashing HIR manually here.\n     let owner = hir_body.id().hir_id.owner;\n-    tcx.hir_owner_nodes(owner).unwrap().hash_including_bodies.to_smaller_hash()\n+    tcx.hir_owner_nodes(owner).unwrap().opt_hash_including_bodies.unwrap().to_smaller_hash()\n }"}, {"sha": "fdacf814dd6726c2a37e1714b6654c131cceac73", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150cb381471533050751111e5faf1d9f05c02f77/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=150cb381471533050751111e5faf1d9f05c02f77", "patch": "@@ -224,6 +224,13 @@ pub struct PerfStats {\n     pub normalize_projection_ty: AtomicUsize,\n }\n \n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n+pub enum MetadataKind {\n+    None,\n+    Uncompressed,\n+    Compressed,\n+}\n+\n impl Session {\n     pub fn miri_unleashed_feature(&self, span: Span, feature_gate: Option<Symbol>) {\n         self.miri_unleashed_features.lock().push((span, feature_gate));\n@@ -287,6 +294,38 @@ impl Session {\n         self.crate_types.get().unwrap().as_slice()\n     }\n \n+    pub fn needs_crate_hash(&self) -> bool {\n+        // Why is the crate hash needed for these configurations?\n+        // - debug_assertions: for the \"fingerprint the result\" check in\n+        //   `rustc_query_system::query::plumbing::execute_job`.\n+        // - incremental: for query lookups.\n+        // - needs_metadata: for putting into crate metadata.\n+        // - instrument_coverage: for putting into coverage data (see\n+        //   `hash_mir_source`).\n+        cfg!(debug_assertions)\n+            || self.opts.incremental.is_some()\n+            || self.needs_metadata()\n+            || self.instrument_coverage()\n+    }\n+\n+    pub fn metadata_kind(&self) -> MetadataKind {\n+        self.crate_types()\n+            .iter()\n+            .map(|ty| match *ty {\n+                CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => {\n+                    MetadataKind::None\n+                }\n+                CrateType::Rlib => MetadataKind::Uncompressed,\n+                CrateType::Dylib | CrateType::ProcMacro => MetadataKind::Compressed,\n+            })\n+            .max()\n+            .unwrap_or(MetadataKind::None)\n+    }\n+\n+    pub fn needs_metadata(&self) -> bool {\n+        self.metadata_kind() != MetadataKind::None\n+    }\n+\n     pub fn init_crate_types(&self, crate_types: Vec<CrateType>) {\n         self.crate_types.set(crate_types).expect(\"`crate_types` was initialized twice\")\n     }"}]}