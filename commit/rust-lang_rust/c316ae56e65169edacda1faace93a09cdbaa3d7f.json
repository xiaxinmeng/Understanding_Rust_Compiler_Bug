{"sha": "c316ae56e65169edacda1faace93a09cdbaa3d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMTZhZTU2ZTY1MTY5ZWRhY2RhMWZhYWNlOTNhMDljZGJhYTNkN2Y=", "commit": {"author": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2016-09-17T18:22:04Z"}, "committer": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2016-09-21T17:25:01Z"}, "message": "Tweak std::rc docs\n\nFixes #29372.", "tree": {"sha": "59e629fbab2d2b0ae9dc50a65ce07bc1c8138b84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59e629fbab2d2b0ae9dc50a65ce07bc1c8138b84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c316ae56e65169edacda1faace93a09cdbaa3d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c316ae56e65169edacda1faace93a09cdbaa3d7f", "html_url": "https://github.com/rust-lang/rust/commit/c316ae56e65169edacda1faace93a09cdbaa3d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c316ae56e65169edacda1faace93a09cdbaa3d7f/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cc6c6b1b76960441c39ef29e951f22de45da15b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc6c6b1b76960441c39ef29e951f22de45da15b", "html_url": "https://github.com/rust-lang/rust/commit/5cc6c6b1b76960441c39ef29e951f22de45da15b"}], "stats": {"total": 470, "additions": 310, "deletions": 160}, "files": [{"sha": "e0f635f195bcd770bbb147440b3f20090320746f", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 310, "deletions": 160, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/c316ae56e65169edacda1faace93a09cdbaa3d7f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c316ae56e65169edacda1faace93a09cdbaa3d7f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c316ae56e65169edacda1faace93a09cdbaa3d7f", "patch": "@@ -10,90 +10,138 @@\n \n #![allow(deprecated)]\n \n-//! Unsynchronized reference-counted boxes (the `Rc<T>` type) which are usable\n-//! only within a single thread.\n+//! Single-threaded reference-counting pointers.\n //!\n-//! The `Rc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as non-sendable because it avoids the overhead of atomic\n-//! reference counting.\n+//! The type [`Rc<T>`][rc] provides shared ownership of a value, allocated\n+//! in the heap. Invoking [`clone`][clone] on `Rc` produces a new pointer\n+//! to the same value in the heap. When the last `Rc` pointer to a given\n+//! value is destroyed, the pointed-to value is also destroyed.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n+//! Shared pointers in Rust disallow mutation by default, and `Rc` is no\n+//! exception. If you need to mutate through an `Rc`, use [`Cell`][cell] or\n+//! [`RefCell`][refcell].\n //!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Rc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n+//! `Rc` uses non-atomic reference counting. This means that overhead is very\n+//! low, but an `Rc` cannot be sent between threads, and consequently `Rc`\n+//! does not implement [`Send`][send]. As a result, the Rust compiler\n+//! will check *at compile time* that you are not sending `Rc`s between\n+//! threads. If you need multi-threaded, atomic reference counting, use\n+//! [`sync::Arc`][arc].\n+//!\n+//! The [`downgrade`][downgrade] method can be used to create a non-owning\n+//! [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n+//! to an `Rc`, but this will return [`None`][option] if the value has\n+//! already been dropped.\n+//!\n+//! A cycle between `Rc` pointers will never be deallocated. For this reason,\n+//! `Weak` is used to break cycles. For example, a tree could have strong\n+//! `Rc` pointers from parent nodes to children, and `Weak` pointers from\n+//! children back to their parents.\n+//!\n+//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n+//! so you can call `T`'s methods on a value of type `Rc<T>`. To avoid name\n+//! clashes with `T`'s methods, the methods of `Rc<T>` itself are [associated\n+//! functions][assoc], called using function-like syntax:\n+//!\n+//! ```\n+//! # use std::rc::Rc;\n+//! # let my_rc = Rc::new(());\n+//! Rc::downgrade(&my_rc);\n+//! ```\n+//!\n+//! `Weak<T>` does not auto-dereference to `T`, because the value may have\n+//! already been destroyed.\n+//!\n+//! [rc]: struct.Rc.html\n+//! [weak]: struct.Weak.html\n+//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+//! [cell]: ../../std/cell/struct.Cell.html\n+//! [refcell]: ../../std/cell/struct.RefCell.html\n+//! [send]: ../../std/marker/trait.Send.html\n+//! [arc]: ../../std/sync/struct.Arc.html\n+//! [deref]: ../../std/ops/trait.Deref.html\n+//! [downgrade]: struct.Rc.html#method.downgrade\n+//! [upgrade]: struct.Weak.html#method.upgrade\n+//! [option]: ../../std/option/enum.Option.html\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n //!\n //! # Examples\n //!\n //! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n //! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n //! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s,\n+//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s,\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n-//! ```rust\n+//! ```\n //! use std::rc::Rc;\n //!\n //! struct Owner {\n-//!     name: String\n+//!     name: String,\n //!     // ...other fields\n //! }\n //!\n //! struct Gadget {\n //!     id: i32,\n-//!     owner: Rc<Owner>\n+//!     owner: Rc<Owner>,\n //!     // ...other fields\n //! }\n //!\n //! fn main() {\n-//!     // Create a reference counted Owner.\n-//!     let gadget_owner : Rc<Owner> = Rc::new(\n-//!         Owner { name: String::from(\"Gadget Man\") }\n+//!     // Create a reference-counted `Owner`.\n+//!     let gadget_owner: Rc<Owner> = Rc::new(\n+//!         Owner {\n+//!             name: \"Gadget Man\".to_string(),\n+//!         }\n //!     );\n //!\n-//!     // Create Gadgets belonging to gadget_owner. To increment the reference\n-//!     // count we clone the `Rc<T>` object.\n-//!     let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n-//!     let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n+//!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n+//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // the reference count in the process.\n+//!     let gadget1 = Gadget {\n+//!         id: 1,\n+//!         owner: gadget_owner.clone(),\n+//!     };\n+//!     let gadget2 = Gadget {\n+//!         id: 2,\n+//!         owner: gadget_owner.clone(),\n+//!     };\n //!\n+//!     // Dispose of our local variable `gadget_owner`.\n //!     drop(gadget_owner);\n //!\n-//!     // Despite dropping gadget_owner, we're still able to print out the name\n-//!     // of the Owner of the Gadgets. This is because we've only dropped the\n-//!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other `Rc<T>` objects pointing at the same Owner, it will remain\n-//!     // allocated. Notice that the `Rc<T>` wrapper around Gadget.owner gets\n-//!     // automatically dereferenced for us.\n+//!     // Despite dropping `gadget_owner`, we're still able to print out the name\n+//!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n+//!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n+//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n+//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n //!\n-//!     // At the end of the method, gadget1 and gadget2 get destroyed, and with\n-//!     // them the last counted references to our Owner. Gadget Man now gets\n-//!     // destroyed as well.\n+//!     // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n+//!     // with them the last counted references to our `Owner`. Gadget Man now\n+//!     // gets destroyed as well.\n //! }\n //! ```\n //!\n //! If our requirements change, and we also need to be able to traverse from\n-//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc<T>` pointer from Owner\n-//! \u2192\u00a0Gadget introduces a cycle between the objects. This means that their\n-//! reference counts can never reach 0, and the objects will remain allocated: a\n-//! memory leak. In order to get around this, we can use `Weak<T>` pointers.\n-//! These pointers don't contribute to the total count.\n+//! `Owner` to\u00a0`Gadget`, we will run into problems. An `Rc` pointer from `Owner`\n+//! to `Gadget` introduces a cycle between the values. This means that their\n+//! reference counts can never reach 0, and the values will remain allocated\n+//! forever: a memory leak. In order to get around this, we can use `Weak`\n+//! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n-//! place: in order to end up with two objects that point at each other, one of\n-//! them needs to be mutable. This is problematic because `Rc<T>` enforces\n-//! memory safety by only giving out shared references to the object it wraps,\n+//! place. In order to end up with two values that point at each other, one of\n+//! them needs to be mutable. This is difficult because `Rc` enforces\n+//! memory safety by only giving out shared references to the value it wraps,\n //! and these don't allow direct mutation. We need to wrap the part of the\n-//! object we wish to mutate in a `RefCell`, which provides *interior\n+//! value we wish to mutate in a [`RefCell`][refcell], which provides *interior\n //! mutability*: a method to achieve mutability through a shared reference.\n-//! `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell`\n-//! documentation for more details on interior mutability.\n+//! `RefCell` enforces Rust's borrowing rules at runtime.\n //!\n-//! ```rust\n+//! ```\n //! use std::rc::Rc;\n //! use std::rc::Weak;\n //! use std::cell::RefCell;\n@@ -111,41 +159,58 @@\n //! }\n //!\n //! fn main() {\n-//!     // Create a reference counted Owner. Note the fact that we've put the\n-//!     // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n-//!     // through a shared reference.\n-//!     let gadget_owner : Rc<Owner> = Rc::new(\n+//!     // Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n+//!     // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n+//!     // a shared reference.\n+//!     let gadget_owner: Rc<Owner> = Rc::new(\n //!         Owner {\n //!             name: \"Gadget Man\".to_string(),\n-//!             gadgets: RefCell::new(Vec::new()),\n+//!             gadgets: RefCell::new(vec![]),\n //!         }\n //!     );\n //!\n-//!     // Create Gadgets belonging to gadget_owner as before.\n-//!     let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n-//!     let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n+//!     // Create `Gadget`s belonging to `gadget_owner`, as before.\n+//!     let gadget1 = Rc::new(\n+//!         Gadget {\n+//!             id: 1,\n+//!             owner: gadget_owner.clone(),\n+//!         }\n+//!     );\n+//!     let gadget2 = Rc::new(\n+//!         Gadget {\n+//!             id: 2,\n+//!             owner: gadget_owner.clone(),\n+//!         }\n+//!     );\n+//!\n+//!     // Add the `Gadget`s to their `Owner`.\n+//!     {\n+//!         let mut gadgets = gadget_owner.gadgets.borrow_mut();\n+//!         gadgets.push(Rc::downgrade(&gadget1));\n+//!         gadgets.push(Rc::downgrade(&gadget2));\n //!\n-//!     // Add the Gadgets to their Owner. To do this we mutably borrow from\n-//!     // the RefCell holding the Owner's Gadgets.\n-//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));\n-//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));\n+//!         // `RefCell` dynamic borrow ends here.\n+//!     }\n //!\n-//!     // Iterate over our Gadgets, printing their details out\n-//!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+//!     // Iterate over our `Gadget`s, printing their details out.\n+//!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n-//!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still allocated, we need to call upgrade()\n-//!         // on them to turn them into a strong reference. This returns an\n-//!         // Option, which contains a reference to our object if it still\n-//!         // exists.\n-//!         let gadget = gadget_opt.upgrade().unwrap();\n+//!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n+//!         // guarantee the value is still allocated, we need to call\n+//!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n+//!         //\n+//!         // In this case we know the value still exists, so we simply\n+//!         // `unwrap` the `Option`. In a more complicated program, you might\n+//!         // need graceful error handling for a `None` result.\n+//!\n+//!         let gadget = gadget_weak.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n //!\n-//!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n-//!     // destroyed. There are now no strong (`Rc<T>`) references to the gadgets.\n-//!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n-//!     // reference count on Gadget Man, they get destroyed as well.\n+//!     // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n+//!     // are destroyed. There are now no strong (`Rc`) pointers to the\n+//!     // gadgets, so they are destroyed. This zeroes the reference count on\n+//!     // Gadget Man, so he gets destroyed as well.\n //! }\n //! ```\n \n@@ -179,15 +244,14 @@ struct RcBox<T: ?Sized> {\n }\n \n \n-/// A reference-counted pointer type over an immutable value.\n+/// A single-threaded reference-counting pointer.\n ///\n-/// See the [module level documentation](./index.html) for more details.\n+/// See the [module-level documentation](./index.html) for more details.\n ///\n-/// Note: the inherent methods defined on `Rc<T>` are all associated functions,\n-/// which means that you have to call them as e.g. `Rc::get_mut(&value)` instead\n-/// of `value.get_mut()`.  This is so that there are no conflicts with methods\n-/// on the inner type `T`, which are what you want to call in the majority of\n-/// cases.\n+/// The inherent methods of `Rc` are all associated functions, which means\n+/// that you have to call them as e.g. `Rc::get_mut(&value)` instead of\n+/// `value.get_mut()`.  This avoids conflicts with methods of the inner\n+/// type `T`.\n #[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n@@ -229,9 +293,9 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Unwraps the contained value if the `Rc<T>` has exactly one strong reference.\n+    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an `Err` is returned with the same `Rc<T>`.\n+    /// Otherwise, an `Err` is returned with the same `Rc` that was passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n@@ -245,7 +309,7 @@ impl<T> Rc<T> {\n     ///\n     /// let x = Rc::new(4);\n     /// let _y = x.clone();\n-    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n@@ -268,7 +332,7 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Checks if `Rc::try_unwrap` would return `Ok`.\n+    /// Checks whether `Rc::try_unwrap` would return `Ok`.\n     ///\n     /// # Examples\n     ///\n@@ -284,7 +348,7 @@ impl<T> Rc<T> {\n     /// let x = Rc::new(4);\n     /// let _y = x.clone();\n     /// assert!(!Rc::would_unwrap(&x));\n-    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[unstable(feature = \"rc_would_unwrap\",\n                reason = \"just added for niche usecase\",\n@@ -295,7 +359,9 @@ impl<T> Rc<T> {\n }\n \n impl<T: ?Sized> Rc<T> {\n-    /// Creates a new `Weak<T>` reference from this value.\n+    /// Creates a new [`Weak`][weak] pointer to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -312,24 +378,54 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Get the number of weak references to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_counts)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let _weak_five = Rc::downgrade(&five);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.weak() - 1\n     }\n \n-    /// Get the number of strong references to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_counts)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let _also_five = five.clone();\n+    ///\n+    /// assert_eq!(2, Rc::strong_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n-    /// the same inner value.\n+    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// this inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -349,10 +445,19 @@ impl<T: ?Sized> Rc<T> {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the contained value if the `Rc<T>` has\n-    /// one strong reference and no weak references.\n+    /// Returns a mutable reference to the inner value, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    ///\n+    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// mutate a shared value.\n     ///\n-    /// Returns `None` if the `Rc<T>` is not unique.\n+    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n+    /// the inner value when it's shared.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [option]: ../../std/option/enum.Option.html\n+    /// [make_mut]: struct.Rc.html#method.make_mut\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///\n     /// # Examples\n     ///\n@@ -381,8 +486,8 @@ impl<T: ?Sized> Rc<T> {\n     #[unstable(feature = \"ptr_eq\",\n                reason = \"newly added\",\n                issue = \"36497\")]\n-    /// Return whether two `Rc` references point to the same value\n-    /// (not just values that compare equal).\n+    /// Returns true if the two `Rc`s point to the same value (not\n+    /// just values that compare as equal).\n     ///\n     /// # Examples\n     ///\n@@ -406,11 +511,17 @@ impl<T: ?Sized> Rc<T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Make a mutable reference into the given `Rc<T>` by cloning the inner\n-    /// data if the `Rc<T>` doesn't have one strong reference and no weak\n-    /// references.\n+    /// Makes a mutable reference into the given `Rc`.\n+    ///\n+    /// If there are other `Rc` or [`Weak`][weak] pointers to the same value,\n+    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n+    /// ensure unique ownership. This is also referred to as clone-on-write.\n     ///\n-    /// This is also referred to as a copy-on-write.\n+    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [get_mut]: struct.Rc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -419,16 +530,15 @@ impl<T: Clone> Rc<T> {\n     ///\n     /// let mut data = Rc::new(5);\n     ///\n-    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n-    /// let mut other_data = data.clone(); // Won't clone inner data\n-    /// *Rc::make_mut(&mut data) += 1;             // Clones inner data\n-    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n-    /// *Rc::make_mut(&mut other_data) *= 2;       // Won't clone anything\n+    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n+    /// let mut other_data = data.clone();    // Won't clone inner data\n+    /// *Rc::make_mut(&mut data) += 1;        // Clones inner data\n+    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n+    /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Note: data and other_data now point to different numbers\n+    /// // Now `data` and `other_data` point to different values.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n@@ -470,30 +580,30 @@ impl<T: ?Sized> Deref for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Rc<T> {\n-    /// Drops the `Rc<T>`.\n+    /// Drops the `Rc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n+    /// count reaches zero then the only other references (if any) are `Weak`,\n+    /// so we `drop` the inner value.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// {\n-    ///     let five = Rc::new(5);\n+    /// struct Foo;\n     ///\n-    ///     // stuff\n-    ///\n-    ///     drop(five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n     ///\n-    ///     // stuff\n+    /// let foo  = Rc::new(Foo);\n+    /// let foo2 = foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(foo);    // Doesn't print anything\n+    /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -519,10 +629,10 @@ impl<T: ?Sized> Drop for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n-    /// Makes a clone of the `Rc<T>`.\n+    /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n-    /// increase the strong reference counter.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// strong reference count.\n     ///\n     /// # Examples\n     ///\n@@ -550,6 +660,7 @@ impl<T: Default> Default for Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// let x: Rc<i32> = Default::default();\n+    /// assert_eq!(*x, 0);\n     /// ```\n     #[inline]\n     fn default() -> Rc<T> {\n@@ -559,9 +670,9 @@ impl<T: Default> Default for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n-    /// Equality for two `Rc<T>`s.\n+    /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc<T>`s are equal if their inner value are equal.\n+    /// Two `Rc`s are equal if their inner values are equal.\n     ///\n     /// # Examples\n     ///\n@@ -570,16 +681,16 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five == Rc::new(5);\n+    /// assert!(five == Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         **self == **other\n     }\n \n-    /// Inequality for two `Rc<T>`s.\n+    /// Inequality for two `Rc`s.\n     ///\n-    /// Two `Rc<T>`s are unequal if their inner value are unequal.\n+    /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n     /// # Examples\n     ///\n@@ -588,7 +699,7 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five != Rc::new(5);\n+    /// assert!(five != Rc::new(6));\n     /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool {\n@@ -601,25 +712,26 @@ impl<T: ?Sized + Eq> Eq for Rc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n-    /// Partial comparison for two `Rc<T>`s.\n+    /// Partial comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `partial_cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5));\n+    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Rc::new(6)));\n     /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n-    /// Less-than comparison for two `Rc<T>`s.\n+    /// Less-than comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `<` on their inner values.\n     ///\n@@ -630,14 +742,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five < Rc::new(5);\n+    /// assert!(five < Rc::new(6));\n     /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool {\n         **self < **other\n     }\n \n-    /// 'Less-than or equal to' comparison for two `Rc<T>`s.\n+    /// 'Less than or equal to' comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `<=` on their inner values.\n     ///\n@@ -648,14 +760,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five <= Rc::new(5);\n+    /// assert!(five <= Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool {\n         **self <= **other\n     }\n \n-    /// Greater-than comparison for two `Rc<T>`s.\n+    /// Greater-than comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `>` on their inner values.\n     ///\n@@ -666,14 +778,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five > Rc::new(5);\n+    /// assert!(five > Rc::new(4));\n     /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool {\n         **self > **other\n     }\n \n-    /// 'Greater-than or equal to' comparison for two `Rc<T>`s.\n+    /// 'Greater than or equal to' comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `>=` on their inner values.\n     ///\n@@ -684,7 +796,7 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five >= Rc::new(5);\n+    /// assert!(five >= Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool {\n@@ -694,18 +806,19 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Rc<T> {\n-    /// Comparison for two `Rc<T>`s.\n+    /// Comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5));\n+    /// assert_eq!(Ordering::Less, five.cmp(&Rc::new(6)));\n     /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering {\n@@ -748,12 +861,18 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n-/// A weak version of `Rc<T>`.\n+/// A weak version of [`Rc`][rc].\n+///\n+/// `Weak` pointers do not count towards determining if the inner value\n+/// should be dropped.\n+///\n+/// The typical way to obtain a `Weak` pointer is to call\n+/// [`Rc::downgrade`][downgrade].\n ///\n-/// Weak references do not count when determining if the inner value should be\n-/// dropped.\n+/// See the [module-level documentation](./index.html) for more details.\n ///\n-/// See the [module level documentation](./index.html) for more.\n+/// [rc]: struct.Rc.html\n+/// [downgrade]: struct.Rc.html#method.downgrade\n #[cfg_attr(stage0, unsafe_no_drop_flag)]\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n@@ -769,17 +888,22 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n     ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Weak;\n     ///\n     /// let empty: Weak<i64> = Weak::new();\n+    /// assert!(empty.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n@@ -796,12 +920,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n+    /// Upgrades the `Weak` pointer to an [`Rc`][rc], if possible.\n     ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    /// Returns [`None`][option] if the strong count has reached zero and the\n+    /// inner value was destroyed.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// [rc]: struct.Rc.html\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -813,6 +938,13 @@ impl<T: ?Sized> Weak<T> {\n     /// let weak_five = Rc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// assert!(strong_five.is_some());\n+    ///\n+    /// // Destroy all strong pointers.\n+    /// drop(strong_five);\n+    /// drop(five);\n+    ///\n+    /// assert!(weak_five.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n@@ -827,7 +959,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n+    /// Drops the `Weak` pointer.\n     ///\n     /// This will decrement the weak reference count.\n     ///\n@@ -836,21 +968,22 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = Rc::downgrade(&five);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(weak_five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = Rc::downgrade(&five);\n     ///\n-    ///     // stuff\n+    /// let foo = Rc::new(Foo);\n+    /// let weak_foo = Rc::downgrade(&foo);\n+    /// let other_weak_foo = weak_foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(weak_foo);   // Doesn't print anything\n+    /// drop(foo);        // Prints \"dropped!\"\n+    ///\n+    /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n@@ -868,9 +1001,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n+    /// Makes a clone of the `Weak` pointer.\n     ///\n-    /// This increases the weak reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// weak reference count.\n     ///\n     /// # Examples\n     ///\n@@ -897,7 +1031,23 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Creates a new `Weak<T>`.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n+    ///\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Default::default();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n     fn default() -> Weak<T> {\n         Weak::new()\n     }"}]}