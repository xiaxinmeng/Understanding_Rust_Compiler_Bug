{"sha": "b07d59f794d8fffb628f82c9c8156f5457de5e49", "node_id": "C_kwDOAAsO6NoAKGIwN2Q1OWY3OTRkOGZmZmI2MjhmODJjOWM4MTU2ZjU0NTdkZTVlNDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T01:18:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T01:18:01Z"}, "message": "Auto merge of #94431 - matthiaskrgr:rollup-1jsj0wu, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #94396 (1 - Make more use of `let_chains`)\n - #94397 (Document that pre-expansion lint passes are softly deprecated)\n - #94399 (Add test for #79465 to prevent regression)\n - #94409 (avoid rebuilding bootstrap when PATH changes)\n - #94415 (Use the first codegen backend in the config.toml as default)\n - #94417 (Fix duplicated impl links)\n - #94420 (3 - Make more use of `let_chains`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fbe0a92bea25945ae8f078f31cf6be4480bcc9db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbe0a92bea25945ae8f078f31cf6be4480bcc9db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b07d59f794d8fffb628f82c9c8156f5457de5e49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b07d59f794d8fffb628f82c9c8156f5457de5e49", "html_url": "https://github.com/rust-lang/rust/commit/b07d59f794d8fffb628f82c9c8156f5457de5e49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b07d59f794d8fffb628f82c9c8156f5457de5e49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fbff89354ba7a4ec2d1191a3f405cbe408370f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fbff89354ba7a4ec2d1191a3f405cbe408370f6", "html_url": "https://github.com/rust-lang/rust/commit/9fbff89354ba7a4ec2d1191a3f405cbe408370f6"}, {"sha": "5570b1de40be27979024ea25f8adc6d5e9ffe8cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5570b1de40be27979024ea25f8adc6d5e9ffe8cd", "html_url": "https://github.com/rust-lang/rust/commit/5570b1de40be27979024ea25f8adc6d5e9ffe8cd"}], "stats": {"total": 488, "additions": 250, "deletions": 238}, "files": [{"sha": "eb906d5fde7b4cdecfb7a807b902804e421237e6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -1921,17 +1921,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 err.span_label(assigned_span, format!(\"first assignment to {}\", place_description));\n             }\n         }\n-        if let Some(decl) = local_decl {\n-            if let Some(name) = local_name {\n-                if decl.can_be_made_mutable() {\n-                    err.span_suggestion(\n-                        decl.source_info.span,\n-                        \"consider making this binding mutable\",\n-                        format!(\"mut {}\", name),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n+        if let Some(decl) = local_decl\n+            && let Some(name) = local_name\n+            && decl.can_be_made_mutable()\n+        {\n+            err.span_suggestion(\n+                decl.source_info.span,\n+                \"consider making this binding mutable\",\n+                format!(\"mut {}\", name),\n+                Applicability::MachineApplicable,\n+            );\n         }\n         err.span_label(span, msg);\n         self.buffer_error(err);"}, {"sha": "2217c0e14b2aae0d4ad4930b241f6e5de30008f9", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -375,15 +375,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Some(Cause::DropVar(local, location)) => {\n                 let mut should_note_order = false;\n-                if self.local_names[local].is_some() {\n-                    if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Some(borrowed_local) = place.as_local() {\n-                            if self.local_names[borrowed_local].is_some() && local != borrowed_local\n-                            {\n-                                should_note_order = true;\n-                            }\n-                        }\n-                    }\n+                if self.local_names[local].is_some()\n+                    && let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place\n+                    && let Some(borrowed_local) = place.as_local()\n+                    && self.local_names[borrowed_local].is_some() && local != borrowed_local\n+                {\n+                    should_note_order = true;\n                 }\n \n                 BorrowExplanation::UsedLaterWhenDropped {"}, {"sha": "610798c7c05c85a427acf611ae57bcaf3a1018fb", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -1086,21 +1086,17 @@ fn get_mut_span_in_struct_field<'tcx>(\n     field: &mir::Field,\n ) -> Option<Span> {\n     // Expect our local to be a reference to a struct of some kind.\n-    if let ty::Ref(_, ty, _) = ty.kind() {\n-        if let ty::Adt(def, _) = ty.kind() {\n-            let field = def.all_fields().nth(field.index())?;\n-            // Use the HIR types to construct the diagnostic message.\n-            let node = tcx.hir().find_by_def_id(field.did.as_local()?)?;\n-            // Now we're dealing with the actual struct that we're going to suggest a change to,\n-            // we can expect a field that is an immutable reference to a type.\n-            if let hir::Node::Field(field) = node {\n-                if let hir::TyKind::Rptr(lifetime, hir::MutTy { mutbl: hir::Mutability::Not, ty }) =\n-                    field.ty.kind\n-                {\n-                    return Some(lifetime.span.between(ty.span));\n-                }\n-            }\n-        }\n+    if let ty::Ref(_, ty, _) = ty.kind()\n+        && let ty::Adt(def, _) = ty.kind()\n+        && let field = def.all_fields().nth(field.index())?\n+        // Use the HIR types to construct the diagnostic message.\n+        && let node = tcx.hir().find_by_def_id(field.did.as_local()?)?\n+        // Now we're dealing with the actual struct that we're going to suggest a change to,\n+        // we can expect a field that is an immutable reference to a type.\n+        && let hir::Node::Field(field) = node\n+        && let hir::TyKind::Rptr(lt, hir::MutTy { mutbl: hir::Mutability::Not, ty }) = field.ty.kind\n+    {\n+        return Some(lt.span.between(ty.span));\n     }\n \n     None"}, {"sha": "369aef6798ba662ce3cced8cacd8ad368e05180c", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -140,14 +140,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n     fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n-        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr).as_deref() {\n-            if let ty::BoundRegionKind::BrEnv = free_region.bound_region {\n-                if let DefiningTy::Closure(_, substs) =\n-                    self.regioncx.universal_regions().defining_ty\n-                {\n-                    return substs.as_closure().kind() == ty::ClosureKind::FnMut;\n-                }\n-            }\n+        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr).as_deref()\n+            && let ty::BoundRegionKind::BrEnv = free_region.bound_region\n+            && let DefiningTy::Closure(_, substs) = self.regioncx.universal_regions().defining_ty\n+        {\n+            return substs.as_closure().kind() == ty::ClosureKind::FnMut;\n         }\n \n         false"}, {"sha": "82d2d0dd4557f757ff8f92b86776f2bae2fa946a", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -1,15 +1,16 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n+#![allow(rustc::potential_query_instability)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -159,16 +160,14 @@ fn do_mir_borrowck<'a, 'tcx>(\n     for var_debug_info in &input_body.var_debug_info {\n         if let VarDebugInfoContents::Place(place) = var_debug_info.value {\n             if let Some(local) = place.as_local() {\n-                if let Some(prev_name) = local_names[local] {\n-                    if var_debug_info.name != prev_name {\n-                        span_bug!(\n-                            var_debug_info.source_info.span,\n-                            \"local {:?} has many names (`{}` vs `{}`)\",\n-                            local,\n-                            prev_name,\n-                            var_debug_info.name\n-                        );\n-                    }\n+                if let Some(prev_name) = local_names[local] && var_debug_info.name != prev_name {\n+                    span_bug!(\n+                        var_debug_info.source_info.span,\n+                        \"local {:?} has many names (`{}` vs `{}`)\",\n+                        local,\n+                        prev_name,\n+                        var_debug_info.name\n+                    );\n                 }\n                 local_names[local] = Some(var_debug_info.name);\n             }"}, {"sha": "5a935c3b8fbfddda7b0bc48445bc4d30ad36b9c5", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -60,10 +60,8 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n \n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n-    if let Some(l1) = borrow_place.as_local() {\n-        if let Some(l2) = access_place.as_local() {\n-            return l1 == l2;\n-        }\n+    if let Some(l1) = borrow_place.as_local() && let Some(l2) = access_place.as_local() {\n+        return l1 == l2;\n     }\n \n     place_components_conflict(tcx, body, borrow_place, borrow_kind, access_place, access, bias)"}, {"sha": "046f4f9451f58b535e27c470bd6b8f71d919e23a", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -236,13 +236,9 @@ pub fn get_codegen_backend(\n     static LOAD: SyncOnceCell<unsafe fn() -> Box<dyn CodegenBackend>> = SyncOnceCell::new();\n \n     let load = LOAD.get_or_init(|| {\n-        #[cfg(feature = \"llvm\")]\n-        const DEFAULT_CODEGEN_BACKEND: &str = \"llvm\";\n+        let default_codegen_backend = option_env!(\"CFG_DEFAULT_CODEGEN_BACKEND\").unwrap_or(\"llvm\");\n \n-        #[cfg(not(feature = \"llvm\"))]\n-        const DEFAULT_CODEGEN_BACKEND: &str = \"cranelift\";\n-\n-        match backend_name.unwrap_or(DEFAULT_CODEGEN_BACKEND) {\n+        match backend_name.unwrap_or(default_codegen_backend) {\n             filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n             #[cfg(feature = \"llvm\")]\n             \"llvm\" => rustc_codegen_llvm::LlvmCodegenBackend::new,"}, {"sha": "ad9a16fb39ae2d5fe3641ec255058e816c96a6e3", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -166,7 +166,12 @@ impl LintStore {\n         self.early_passes.push(Box::new(pass));\n     }\n \n-    /// Used by clippy.\n+    /// This lint pass is softly deprecated. It misses expanded code and has caused a few\n+    /// errors in the past. Currently, it is only used in Clippy. New implementations\n+    /// should avoid using this interface, as it might be removed in the future.\n+    ///\n+    /// * See [rust#69838](https://github.com/rust-lang/rust/pull/69838)\n+    /// * See [rust-clippy#5518](https://github.com/rust-lang/rust-clippy/pull/5518)\n     pub fn register_pre_expansion_pass(\n         &mut self,\n         pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,"}, {"sha": "14a6e686a6424f4585dcec7c3c75d71c5e78e999", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -1054,12 +1054,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut result = Vec::new();\n \n         for ast_bound in ast_bounds {\n-            if let Some(trait_ref) = ast_bound.trait_ref() {\n-                if let Some(trait_did) = trait_ref.trait_def_id() {\n-                    if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n-                        result.push(ast_bound.clone());\n-                    }\n-                }\n+            if let Some(trait_ref) = ast_bound.trait_ref()\n+                && let Some(trait_did) = trait_ref.trait_def_id()\n+                && self.tcx().trait_may_define_assoc_type(trait_did, assoc_name)\n+            {\n+                result.push(ast_bound.clone());\n             }\n         }\n "}, {"sha": "100d2d07a5c9f8029856572ce40e963364b2e249", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -282,13 +282,12 @@ pub(super) fn check_fn<'a, 'tcx>(\n                         sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                     }\n \n-                    if let Node::Item(item) = hir.get(fn_id) {\n-                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n-                            if !generics.params.is_empty() {\n+                    if let Node::Item(item) = hir.get(fn_id)\n+                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                        && !generics.params.is_empty()\n+                    {\n                                 sess.span_err(span, \"should have no type parameters\");\n                             }\n-                        }\n-                    }\n                 } else {\n                     let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n@@ -319,17 +318,15 @@ pub(super) fn check_fn<'a, 'tcx>(\n                         sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                     }\n \n-                    if let Node::Item(item) = hir.get(fn_id) {\n-                        if let ItemKind::Fn(_, ref generics, _) = item.kind {\n-                            if !generics.params.is_empty() {\n+                    if let Node::Item(item) = hir.get(fn_id)\n+                        && let ItemKind::Fn(_, ref generics, _) = item.kind\n+                        && !generics.params.is_empty()\n+                    {\n                                 sess.span_err(\n                                     span,\n-                                    \"`#[alloc_error_handler]` function should have no type \\\n-                                     parameters\",\n+                            \"`#[alloc_error_handler]` function should have no type parameters\",\n                                 );\n                             }\n-                        }\n-                    }\n                 } else {\n                     let span = sess.source_map().guess_head_span(span);\n                     sess.span_err(span, \"function should have one argument\");\n@@ -1146,18 +1143,17 @@ pub(super) fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n     if repr.packed() {\n         for attr in tcx.get_attrs(def.did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess, attr) {\n-                if let attr::ReprPacked(pack) = r {\n-                    if let Some(repr_pack) = repr.pack {\n-                        if pack as u64 != repr_pack.bytes() {\n+                if let attr::ReprPacked(pack) = r\n+                    && let Some(repr_pack) = repr.pack\n+                    && pack as u64 != repr_pack.bytes()\n+                {\n                             struct_span_err!(\n                                 tcx.sess,\n                                 sp,\n                                 E0634,\n                                 \"type has conflicting packed representation hints\"\n                             )\n                             .emit();\n-                        }\n-                    }\n                 }\n             }\n         }\n@@ -1399,12 +1395,11 @@ fn display_discriminant_value<'tcx>(\n ) -> String {\n     if let Some(expr) = &variant.disr_expr {\n         let body = &tcx.hir().body(expr.body).value;\n-        if let hir::ExprKind::Lit(lit) = &body.kind {\n-            if let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node {\n-                if evaluated != *lit_value {\n+        if let hir::ExprKind::Lit(lit) = &body.kind\n+            && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n+            && evaluated != *lit_value\n+        {\n                     return format!(\"`{}` (overflowed from `{}`)\", evaluated, lit_value);\n-                }\n-            }\n         }\n     }\n     format!(\"`{}`\", evaluated)"}, {"sha": "c6b14d3e104588d1c928ed34c1b9f94d633d93f3", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -1696,13 +1696,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     }\n \n     fn is_return_ty_unsized<'a>(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n-        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id) {\n-            if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-                let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty);\n-                if let ty::Dynamic(..) = ty.kind() {\n+        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id)\n+            && let hir::FnRetTy::Return(ty) = fn_decl.output\n+            && let ty = <dyn AstConv<'_>>::ast_ty_to_ty(fcx, ty)\n+            && let ty::Dynamic(..) = ty.kind()\n+        {\n                     return true;\n-                }\n-            }\n         }\n         false\n     }"}, {"sha": "faead1bf5cd6d504f61135885f97a395f9a0236f", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -587,9 +587,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match (&expr.kind, expected.kind(), checked_ty.kind()) {\n             (_, &ty::Ref(_, exp, _), &ty::Ref(_, check, _)) => match (exp.kind(), check.kind()) {\n                 (&ty::Str, &ty::Array(arr, _) | &ty::Slice(arr)) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.kind {\n-                        if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some() {\n+                    if let hir::ExprKind::Lit(_) = expr.kind\n+                        && let Ok(src) = sm.span_to_snippet(sp)\n+                        && replace_prefix(&src, \"b\\\"\", \"\\\"\").is_some()\n+                    {\n                                 let pos = sp.lo() + BytePos(1);\n                                 return Some((\n                                     sp.with_hi(pos),\n@@ -600,21 +601,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ));\n                             }\n                         }\n-                    }\n-                }\n                 (&ty::Array(arr, _) | &ty::Slice(arr), &ty::Str) if arr == self.tcx.types.u8 => {\n-                    if let hir::ExprKind::Lit(_) = expr.kind {\n-                        if let Ok(src) = sm.span_to_snippet(sp) {\n-                            if replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some() {\n+                    if let hir::ExprKind::Lit(_) = expr.kind\n+                        && let Ok(src) = sm.span_to_snippet(sp)\n+                        && replace_prefix(&src, \"\\\"\", \"b\\\"\").is_some()\n+                    {\n                                 return Some((\n                                     sp.shrink_to_lo(),\n                                     \"consider adding a leading `b`\",\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n                                 ));\n-                            }\n-                        }\n+\n                     }\n                 }\n                 _ => {}"}, {"sha": "14a1318517a197423edb2a2af0278cd883e94b03", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -810,10 +810,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Use the span of the trailing expression for our cause,\n         // not the span of the entire function\n         if !explicit_return {\n-            if let ExprKind::Block(body, _) = return_expr.kind {\n-                if let Some(last_expr) = body.expr {\n-                    span = last_expr.span;\n-                }\n+            if let ExprKind::Block(body, _) = return_expr.kind && let Some(last_expr) = body.expr {\n+                span = last_expr.span;\n             }\n         }\n         ret_coercion.borrow_mut().coerce("}, {"sha": "76339998a2fbba02b0244fc88cc304970dcbcf8a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -402,25 +402,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if arg_count == 0 || i + 1 == arg_count { &label } else { \"\" },\n                 );\n             }\n-            if let Some(def_id) = fn_def_id {\n-                if let Some(def_span) = tcx.def_ident_span(def_id) {\n-                    let mut spans: MultiSpan = def_span.into();\n-\n-                    let params = tcx\n-                        .hir()\n-                        .get_if_local(def_id)\n-                        .and_then(|node| node.body_id())\n-                        .into_iter()\n-                        .map(|id| tcx.hir().body(id).params)\n-                        .flatten();\n-\n-                    for param in params {\n-                        spans.push_span_label(param.span, String::new());\n-                    }\n-\n-                    let def_kind = tcx.def_kind(def_id);\n-                    err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+            if let Some(def_id) = fn_def_id && let Some(def_span) = tcx.def_ident_span(def_id) {\n+                let mut spans: MultiSpan = def_span.into();\n+\n+                let params = tcx\n+                    .hir()\n+                    .get_if_local(def_id)\n+                    .and_then(|node| node.body_id())\n+                    .into_iter()\n+                    .map(|id| tcx.hir().body(id).params)\n+                    .flatten();\n+\n+                for param in params {\n+                    spans.push_span_label(param.span, String::new());\n                 }\n+\n+                let def_kind = tcx.def_kind(def_id);\n+                err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n             }\n             if sugg_unit {\n                 let sugg_span = tcx.sess.source_map().end_point(call_expr.span);"}, {"sha": "32de5d23c1ea73149467efd269737ba4c91a50a9", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -430,12 +430,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             actual.prefix_string(self.tcx),\n                             ty_str_reported,\n                         );\n-                        if let Mode::MethodCall = mode {\n-                            if let SelfSource::MethodCall(call) = source {\n-                                self.suggest_await_before_method(\n-                                    &mut err, item_name, actual, call, span,\n-                                );\n-                            }\n+                        if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n+                            self.suggest_await_before_method(\n+                                &mut err, item_name, actual, cal, span,\n+                            );\n                         }\n                         if let Some(span) =\n                             tcx.resolutions(()).confused_type_with_std_module.get(&span)\n@@ -1525,43 +1523,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Arc), \"Arc::new\"),\n                     (self.tcx.mk_diagnostic_item(*rcvr_ty, sym::Rc), \"Rc::new\"),\n                 ] {\n-                    if let Some(new_rcvr_t) = *rcvr_ty {\n-                        if let Ok(pick) = self.lookup_probe(\n-                            span,\n-                            item_name,\n-                            new_rcvr_t,\n-                            rcvr,\n-                            crate::check::method::probe::ProbeScope::AllTraits,\n-                        ) {\n-                            debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n-                            let did = Some(pick.item.container.id());\n-                            // We don't want to suggest a container type when the missing\n-                            // method is `.clone()` or `.deref()` otherwise we'd suggest\n-                            // `Arc::new(foo).clone()`, which is far from what the user wants.\n-                            // Explicitly ignore the `Pin::as_ref()` method as `Pin` does not\n-                            // implement the `AsRef` trait.\n-                            let skip = skippable.contains(&did)\n-                                || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name));\n-                            // Make sure the method is defined for the *actual* receiver: we don't\n-                            // want to treat `Box<Self>` as a receiver if it only works because of\n-                            // an autoderef to `&self`\n-                            if pick.autoderefs == 0 && !skip {\n-                                err.span_label(\n-                                    pick.item.ident(self.tcx).span,\n-                                    &format!(\"the method is available for `{}` here\", new_rcvr_t),\n-                                );\n-                                err.multipart_suggestion(\n-                                    \"consider wrapping the receiver expression with the \\\n-                                        appropriate type\",\n-                                    vec![\n-                                        (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n-                                        (rcvr.span.shrink_to_hi(), \")\".to_string()),\n-                                    ],\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                // We don't care about the other suggestions.\n-                                alt_rcvr_sugg = true;\n-                            }\n+                    if let Some(new_rcvr_t) = *rcvr_ty && let Ok(pick) = self.lookup_probe(\n+                        span,\n+                        item_name,\n+                        new_rcvr_t,\n+                        rcvr,\n+                        crate::check::method::probe::ProbeScope::AllTraits,\n+                    ) {\n+                        debug!(\"try_alt_rcvr: pick candidate {:?}\", pick);\n+                        let did = Some(pick.item.container.id());\n+                        // We don't want to suggest a container type when the missing\n+                        // method is `.clone()` or `.deref()` otherwise we'd suggest\n+                        // `Arc::new(foo).clone()`, which is far from what the user wants.\n+                        // Explicitly ignore the `Pin::as_ref()` method as `Pin` does not\n+                        // implement the `AsRef` trait.\n+                        let skip = skippable.contains(&did)\n+                            || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name));\n+                        // Make sure the method is defined for the *actual* receiver: we don't\n+                        // want to treat `Box<Self>` as a receiver if it only works because of\n+                        // an autoderef to `&self`\n+                        if pick.autoderefs == 0 && !skip {\n+                            err.span_label(\n+                                pick.item.ident(self.tcx).span,\n+                                &format!(\"the method is available for `{}` here\", new_rcvr_t),\n+                            );\n+                            err.multipart_suggestion(\n+                                \"consider wrapping the receiver expression with the \\\n+                                    appropriate type\",\n+                                vec![\n+                                    (rcvr.span.shrink_to_lo(), format!(\"{}({}\", pre, post)),\n+                                    (rcvr.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            // We don't care about the other suggestions.\n+                            alt_rcvr_sugg = true;\n                         }\n                     }\n                 }"}, {"sha": "9963a922268a42f40b20f321968bcda685e02d97", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -685,9 +685,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat<'_>) -> bool {\n-        if let PatKind::Binding(..) = inner.kind {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.kind() {\n+        if let PatKind::Binding(..) = inner.kind\n+            && let Some(mt) = self.shallow_resolve(expected).builtin_deref(true)\n+            && let ty::Dynamic(..) = mt.ty.kind()\n+        {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                     let type_str = self.ty_to_string(expected);\n@@ -705,8 +706,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.emit();\n                     return false;\n                 }\n-            }\n-        }\n         true\n     }\n "}, {"sha": "88e3e67c99ee39dc8e24ef1932a10c2568a840de", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -190,25 +190,23 @@ crate fn placeholder_type_error<'tcx>(\n         let mut is_fn = false;\n         let mut is_const_or_static = false;\n \n-        if let Some(hir_ty) = hir_ty {\n-            if let hir::TyKind::BareFn(_) = hir_ty.kind {\n-                is_fn = true;\n-\n-                // Check if parent is const or static\n-                let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n-                let parent_node = tcx.hir().get(parent_id);\n-\n-                is_const_or_static = matches!(\n-                    parent_node,\n-                    Node::Item(&hir::Item {\n-                        kind: hir::ItemKind::Const(..) | hir::ItemKind::Static(..),\n-                        ..\n-                    }) | Node::TraitItem(&hir::TraitItem {\n-                        kind: hir::TraitItemKind::Const(..),\n-                        ..\n-                    }) | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n-                );\n-            }\n+        if let Some(hir_ty) = hir_ty && let hir::TyKind::BareFn(_) = hir_ty.kind {\n+            is_fn = true;\n+\n+            // Check if parent is const or static\n+            let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n+            let parent_node = tcx.hir().get(parent_id);\n+\n+            is_const_or_static = matches!(\n+                parent_node,\n+                Node::Item(&hir::Item {\n+                    kind: hir::ItemKind::Const(..) | hir::ItemKind::Static(..),\n+                    ..\n+                }) | Node::TraitItem(&hir::TraitItem {\n+                    kind: hir::TraitItemKind::Const(..),\n+                    ..\n+                }) | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n+            );\n         }\n \n         // if function is wrapped around a const or static,\n@@ -2417,16 +2415,14 @@ fn const_evaluatable_predicates_of<'tcx>(\n     let node = tcx.hir().get(hir_id);\n \n     let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n-    if let hir::Node::Item(item) = node {\n-        if let hir::ItemKind::Impl(ref impl_) = item.kind {\n-            if let Some(of_trait) = &impl_.of_trait {\n-                debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n-                collector.visit_trait_ref(of_trait);\n-            }\n-\n-            debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n-            collector.visit_ty(impl_.self_ty);\n+    if let hir::Node::Item(item) = node && let hir::ItemKind::Impl(ref impl_) = item.kind {\n+        if let Some(of_trait) = &impl_.of_trait {\n+            debug!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n+            collector.visit_trait_ref(of_trait);\n         }\n+\n+        debug!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n+        collector.visit_ty(impl_.self_ty);\n     }\n \n     if let Some(generics) = node.generics() {\n@@ -3280,15 +3276,14 @@ fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, id: DefId) -> &'tcx FxHashSet<Sy\n /// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n /// applied to the method prototype.\n fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(impl_item) = tcx.opt_associated_item(def_id) {\n-        if let ty::AssocItemContainer::ImplContainer(_) = impl_item.container {\n-            if let Some(trait_item) = impl_item.trait_item_def_id {\n-                return tcx\n-                    .codegen_fn_attrs(trait_item)\n-                    .flags\n-                    .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-            }\n-        }\n+    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n+        && let ty::AssocItemContainer::ImplContainer(_) = impl_item.container\n+        && let Some(trait_item) = impl_item.trait_item_def_id\n+    {\n+        return tcx\n+            .codegen_fn_attrs(trait_item)\n+            .flags\n+            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n     }\n \n     false"}, {"sha": "de030c5b60bccd2f053733f9fbd97a7ecaab3967", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -55,22 +55,23 @@ This API is completely unstable and subject to change.\n \n */\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n+#![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n+#![feature(hash_drain_filter)]\n #![feature(if_let_guard)]\n #![feature(is_sorted)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n-#![feature(nll)]\n-#![feature(try_blocks)]\n #![feature(never_type)]\n-#![feature(slice_partition_dedup)]\n-#![feature(control_flow_enum)]\n-#![feature(hash_drain_filter)]\n+#![feature(nll)]\n #![feature(once_cell)]\n+#![feature(slice_partition_dedup)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "61ca09f6b982c581d700fb8d1b24fb3bff362a3f", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -304,13 +304,12 @@ pub fn check_explicit_predicates<'tcx>(\n         // = X` binding from the object type (there must be such a\n         // binding) and thus infer an outlives requirement that `X:\n         // 'b`.\n-        if let Some(self_ty) = ignored_self_ty {\n-            if let GenericArgKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.walk().any(|arg| arg == self_ty.into()) {\n-                    debug!(\"skipping self ty = {:?}\", &ty);\n-                    continue;\n-                }\n-            }\n+        if let Some(self_ty) = ignored_self_ty\n+            && let GenericArgKind::Type(ty) = outlives_predicate.0.unpack()\n+            && ty.walk().any(|arg| arg == self_ty.into())\n+        {\n+            debug!(\"skipping self ty = {:?}\", &ty);\n+            continue;\n         }\n \n         let predicate = outlives_predicate.subst(tcx, substs);"}, {"sha": "466a3a29c4c78284043d12ddb7a220c6406e2892", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -551,7 +551,9 @@ changelog-seen = 2\n \n # This is an array of the codegen backends that will be compiled for the rustc\n # that's being compiled. The default is to only build the LLVM codegen backend,\n-# and currently the only standard options supported are `\"llvm\"` and `\"cranelift\"`.\n+# and currently the only standard options supported are `\"llvm\"`, `\"cranelift\"`\n+# and `\"gcc\"`. The first backend in this list will be used as default by rustc\n+# when no explicit backend is specified.\n #codegen-backends = [\"llvm\"]\n \n # Indicates whether LLD will be compiled and made available in the sysroot for"}, {"sha": "8a5bf933d56ec6aa68979a4c8b158204e0803a57", "filename": "src/bootstrap/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Fbootstrap%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Fbootstrap%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -4,13 +4,13 @@ use std::path::PathBuf;\n fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     println!(\"cargo:rerun-if-env-changed=RUSTC\");\n-    println!(\"cargo:rerun-if-env-changed=PATH\");\n     println!(\"cargo:rustc-env=BUILD_TRIPLE={}\", env::var(\"HOST\").unwrap());\n \n     // This may not be a canonicalized path.\n     let mut rustc = PathBuf::from(env::var_os(\"RUSTC\").unwrap());\n \n     if rustc.is_relative() {\n+        println!(\"cargo:rerun-if-env-changed=PATH\");\n         for dir in env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()) {\n             let absolute = dir.join(&rustc);\n             if absolute.exists() {"}, {"sha": "b4c6210b3881487916fcbab32617ad10573605ec", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -662,6 +662,10 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Cargo, target: TargetS\n         .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n         .env(\"CFG_VERSION\", builder.rust_version());\n \n+    if let Some(backend) = builder.config.rust_codegen_backends.get(0) {\n+        cargo.env(\"CFG_DEFAULT_CODEGEN_BACKEND\", backend);\n+    }\n+\n     let libdir_relative = builder.config.libdir_relative().unwrap_or_else(|| Path::new(\"lib\"));\n     let target_config = builder.config.target_config.get(&target);\n "}, {"sha": "3c1737c5e3f5f72df730496e3269340e73034b01", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -74,7 +74,7 @@ use crate::html::format::{\n     PrintWithSpace,\n };\n use crate::html::highlight;\n-use crate::html::markdown::{HeadingOffset, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use crate::html::markdown::{HeadingOffset, IdMap, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use crate::html::sources;\n use crate::scrape_examples::{CallData, CallLocation};\n use crate::try_none;\n@@ -1950,8 +1950,10 @@ fn small_url_encode(s: String) -> String {\n fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     let did = it.def_id.expect_def_id();\n     let cache = cx.cache();\n+\n     if let Some(v) = cache.impls.get(&did) {\n         let mut used_links = FxHashSet::default();\n+        let mut id_map = IdMap::new();\n \n         {\n             let used_links_bor = &mut used_links;\n@@ -1992,7 +1994,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                 sidebar_deref_methods(cx, out, impl_, v, &mut derefs);\n             }\n \n-            let format_impls = |impls: Vec<&Impl>| {\n+            let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n                 let mut links = FxHashSet::default();\n \n                 let mut ret = impls\n@@ -2001,13 +2003,14 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n                         if let Some(ref i) = it.inner_impl().trait_ {\n                             let i_display = format!(\"{:#}\", i.print(cx));\n                             let out = Escape(&i_display);\n-                            let encoded = small_url_encode(format!(\"{:#}\", i.print(cx)));\n+                            let encoded =\n+                                id_map.derive(small_url_encode(format!(\"impl-{:#}\", i.print(cx))));\n                             let prefix = match it.inner_impl().polarity {\n                                 ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n                                 ty::ImplPolarity::Negative => \"!\",\n                             };\n                             let generated =\n-                                format!(\"<a href=\\\"#impl-{}\\\">{}{}</a>\", encoded, prefix, out);\n+                                format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n                             if links.insert(generated.clone()) { Some(generated) } else { None }\n                         } else {\n                             None\n@@ -2023,9 +2026,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n                 concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n \n-            let concrete_format = format_impls(concrete);\n-            let synthetic_format = format_impls(synthetic);\n-            let blanket_format = format_impls(blanket_impl);\n+            let concrete_format = format_impls(concrete, &mut id_map);\n+            let synthetic_format = format_impls(synthetic, &mut id_map);\n+            let blanket_format = format_impls(blanket_impl, &mut id_map);\n \n             if !concrete_format.is_empty() {\n                 print_sidebar_block("}, {"sha": "f1a77982fb5237d3813a2a99a026824311179ac5", "filename": "src/test/rustdoc-ui/issue-79465.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Ftest%2Frustdoc-ui%2Fissue-79465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Ftest%2Frustdoc-ui%2Fissue-79465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-79465.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -0,0 +1,3 @@\n+pub fn f1<T>(x: T::A) {}\n+//~^ ERROR\n+//~^^ ERROR"}, {"sha": "489cc14420a4c06b2913c647f727669028266b8c", "filename": "src/test/rustdoc-ui/issue-79465.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Ftest%2Frustdoc-ui%2Fissue-79465.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Ftest%2Frustdoc-ui%2Fissue-79465.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-79465.stderr?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `A` not found for `T`\n+  --> $DIR/issue-79465.rs:1:20\n+   |\n+LL | pub fn f1<T>(x: T::A) {}\n+   |                    ^ associated type `A` not found\n+\n+error[E0220]: associated type `A` not found for `T`\n+  --> $DIR/issue-79465.rs:1:20\n+   |\n+LL | pub fn f1<T>(x: T::A) {}\n+   |                    ^ associated type `A` not found\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "796d553fac45e817518c29ed23f7b01df18356a8", "filename": "src/test/rustdoc/issue-78701.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Ftest%2Frustdoc%2Fissue-78701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b07d59f794d8fffb628f82c9c8156f5457de5e49/src%2Ftest%2Frustdoc%2Fissue-78701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-78701.rs?ref=b07d59f794d8fffb628f82c9c8156f5457de5e49", "patch": "@@ -0,0 +1,20 @@\n+#![crate_name = \"foo\"]\n+\n+// This test ensures that if a blanket impl has the same ID as another impl, it'll\n+// link to the blanket impl and not the other impl. Basically, we're checking if\n+// the ID is correctly derived.\n+\n+// @has 'foo/struct.AnotherStruct.html'\n+// @count - '//*[@class=\"sidebar\"]//a[@href=\"#impl-AnAmazingTrait\"]' 1\n+// @count - '//*[@class=\"sidebar\"]//a[@href=\"#impl-AnAmazingTrait-1\"]' 1\n+\n+pub trait Something {}\n+\n+pub trait AnAmazingTrait {}\n+\n+impl<T: Something> AnAmazingTrait for T {}\n+\n+pub struct AnotherStruct<T>(T);\n+\n+impl<T: Something> Something for AnotherStruct<T> {}\n+impl AnAmazingTrait for AnotherStruct<()> {}"}]}