{"sha": "ef753fc6ed54807ac2864706abd38eb01cbca5aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzUzZmM2ZWQ1NDgwN2FjMjg2NDcwNmFiZDM4ZWIwMWNiY2E1YWE=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-14T09:32:50Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-09T11:43:13Z"}, "message": "BTreeMap: better distinguish the root holder from the root node", "tree": {"sha": "c70fc864ce39df681b4d9de6cb64b1f2a2d723b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c70fc864ce39df681b4d9de6cb64b1f2a2d723b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef753fc6ed54807ac2864706abd38eb01cbca5aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef753fc6ed54807ac2864706abd38eb01cbca5aa", "html_url": "https://github.com/rust-lang/rust/commit/ef753fc6ed54807ac2864706abd38eb01cbca5aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef753fc6ed54807ac2864706abd38eb01cbca5aa/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e738539be23a62120059b5b4443f6c235f932b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e738539be23a62120059b5b4443f6c235f932b4", "html_url": "https://github.com/rust-lang/rust/commit/8e738539be23a62120059b5b4443f6c235f932b4"}], "stats": {"total": 93, "additions": 51, "deletions": 42}, "files": [{"sha": "e7d243bfcb0f75d00c6c246026b3b508f0b86737", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ef753fc6ed54807ac2864706abd38eb01cbca5aa/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef753fc6ed54807ac2864706abd38eb01cbca5aa/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=ef753fc6ed54807ac2864706abd38eb01cbca5aa", "patch": "@@ -2,14 +2,14 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering;\n-use core::fmt::Debug;\n+use core::fmt::{self, Debug};\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, RangeBounds};\n-use core::{fmt, ptr};\n+use core::ptr;\n \n use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n use super::search::{self, SearchResult::*};\n@@ -154,7 +154,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let root = out_tree.root.as_mut().unwrap(); // unwrap succeeds because we just wrapped\n-                        let mut out_node = match root.as_mut().force() {\n+                        let mut out_node = match root.node_as_mut().force() {\n                             Leaf(leaf) => leaf,\n                             Internal(_) => unreachable!(),\n                         };\n@@ -210,7 +210,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             // Ord` constraint, which this method lacks.\n             BTreeMap { root: None, length: 0 }\n         } else {\n-            clone_subtree(self.root.as_ref().unwrap().as_ref()) // unwrap succeeds because not empty\n+            clone_subtree(self.root.as_ref().unwrap().node_as_ref()) // unwrap succeeds because not empty\n         }\n     }\n }\n@@ -223,14 +223,16 @@ where\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv().0),\n             GoDown(_) => None,\n         }\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n-        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_kv()\n@@ -242,7 +244,7 @@ where\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         let root = Self::ensure_is_owned(&mut self.root);\n-        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.as_mut(), &key) {\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(root.node_as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry { key, handle, length: &mut self.length, _marker: PhantomData }\n@@ -565,7 +567,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref()?.as_ref(), key) {\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv().1),\n             GoDown(_) => None,\n         }\n@@ -592,7 +595,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_ref()?.as_ref(), k) {\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        match search::search_tree(root_node, k) {\n             Found(handle) => Some(handle.into_kv()),\n             GoDown(_) => None,\n         }\n@@ -617,8 +621,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_key_value(&self) -> Option<(&K, &V)> {\n-        let front = self.root.as_ref()?.as_ref().first_leaf_edge();\n-        front.right_kv().ok().map(Handle::into_kv)\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        root_node.first_leaf_edge().right_kv().ok().map(Handle::into_kv)\n     }\n \n     /// Returns the first entry in the map for in-place manipulation.\n@@ -643,8 +647,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n-        let front = self.root.as_mut()?.as_mut().first_leaf_edge();\n-        let kv = front.right_kv().ok()?;\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        let kv = root_node.first_leaf_edge().right_kv().ok()?;\n         Some(OccupiedEntry {\n             handle: kv.forget_node_type(),\n             length: &mut self.length,\n@@ -694,8 +698,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_key_value(&self) -> Option<(&K, &V)> {\n-        let back = self.root.as_ref()?.as_ref().last_leaf_edge();\n-        back.left_kv().ok().map(Handle::into_kv)\n+        let root_node = self.root.as_ref()?.node_as_ref();\n+        root_node.last_leaf_edge().left_kv().ok().map(Handle::into_kv)\n     }\n \n     /// Returns the last entry in the map for in-place manipulation.\n@@ -720,8 +724,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n     pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n-        let back = self.root.as_mut()?.as_mut().last_leaf_edge();\n-        let kv = back.left_kv().ok()?;\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        let kv = root_node.last_leaf_edge().left_kv().ok()?;\n         Some(OccupiedEntry {\n             handle: kv.forget_node_type(),\n             length: &mut self.length,\n@@ -805,7 +809,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(handle.into_kv_mut().1),\n             GoDown(_) => None,\n         }\n@@ -899,7 +904,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         K: Borrow<Q>,\n         Q: Ord,\n     {\n-        match search::search_tree(self.root.as_mut()?.as_mut(), key) {\n+        let root_node = self.root.as_mut()?.node_as_mut();\n+        match search::search_tree(root_node, key) {\n             Found(handle) => Some(\n                 OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData }\n                     .remove_entry(),\n@@ -995,7 +1001,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n-            let (f, b) = range_search(root.as_ref(), range);\n+            let (f, b) = range_search(root.node_as_ref(), range);\n \n             Range { front: Some(f), back: Some(b) }\n         } else {\n@@ -1041,7 +1047,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = range_search(root.as_mut(), range);\n+            let (f, b) = range_search(root.node_as_mut(), range);\n \n             RangeMut { front: Some(f), back: Some(b), _marker: PhantomData }\n         } else {\n@@ -1071,7 +1077,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let root = Self::ensure_is_owned(&mut self.root);\n-        match search::search_tree(root.as_mut(), &key) {\n+        match search::search_tree(root.node_as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry { handle, length: &mut self.length, _marker: PhantomData })\n             }\n@@ -1083,7 +1089,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n         let root = Self::ensure_is_owned(&mut self.root);\n-        let mut cur_node = root.as_mut().last_leaf_edge().into_node();\n+        let mut cur_node = root.node_as_mut().last_leaf_edge().into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n             // Try to push key-value pair into the current leaf node.\n@@ -1133,7 +1139,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     fn fix_right_edge(root: &mut node::Root<K, V>) {\n         // Handle underfull nodes, start from the top.\n-        let mut cur_node = root.as_mut();\n+        let mut cur_node = root.node_as_mut();\n         while let Internal(internal) = cur_node.force() {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n@@ -1201,8 +1207,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n \n         {\n-            let mut left_node = left_root.as_mut();\n-            let mut right_node = right_root.as_mut();\n+            let mut left_node = left_root.node_as_mut();\n+            let mut right_node = right_root.node_as_mut();\n \n             loop {\n                 let mut split_edge = match search::search_node(left_node, key) {\n@@ -1280,7 +1286,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         DrainFilter { pred, inner: self.drain_filter_inner() }\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n-        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        let root_node = self.root.as_mut().map(|r| r.node_as_mut());\n+        let front = root_node.map(|rn| rn.first_leaf_edge());\n         DrainFilterInner {\n             length: &mut self.length,\n             cur_leaf_edge: front,\n@@ -1315,7 +1322,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             res\n         }\n \n-        self.length = dfs(self.root.as_ref().unwrap().as_ref());\n+        self.length = dfs(self.root.as_ref().unwrap().node_as_ref());\n     }\n \n     /// Creates a consuming iterator visiting all the keys, in sorted order.\n@@ -2251,7 +2258,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n         if let Some(root) = &self.root {\n-            let (f, b) = full_range_search(root.as_ref());\n+            let (f, b) = full_range_search(root.node_as_ref());\n \n             Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n         } else {\n@@ -2283,7 +2290,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         if let Some(root) = &mut self.root {\n-            let (f, b) = full_range_search(root.as_mut());\n+            let (f, b) = full_range_search(root.node_as_mut());\n \n             IterMut {\n                 range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n@@ -2895,7 +2902,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n-        while self.height() > 0 && self.as_ref().len() == 0 {\n+        while self.height() > 0 && self.node_as_ref().len() == 0 {\n             self.pop_internal_level();\n         }\n     }\n@@ -2904,7 +2911,7 @@ impl<K, V> node::Root<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.as_mut();\n+            let mut cur_node = self.node_as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut last_kv = node.last_kv();\n@@ -2930,7 +2937,7 @@ impl<K, V> node::Root<K, V> {\n         self.fix_top();\n \n         {\n-            let mut cur_node = self.as_mut();\n+            let mut cur_node = self.node_as_mut();\n \n             while let Internal(node) = cur_node.force() {\n                 let mut first_kv = node.first_kv();"}, {"sha": "f70869148d59f2f801d49d23db9c60a5d64df8e1", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef753fc6ed54807ac2864706abd38eb01cbca5aa/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef753fc6ed54807ac2864706abd38eb01cbca5aa/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=ef753fc6ed54807ac2864706abd38eb01cbca5aa", "patch": "@@ -163,7 +163,8 @@ impl<K, V> Root<K, V> {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n     }\n \n-    pub fn as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n+    /// Borrows and returns an immutable reference to the node owned by the root.\n+    pub fn node_as_ref(&self) -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -172,7 +173,8 @@ impl<K, V> Root<K, V> {\n         }\n     }\n \n-    pub fn as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n+    /// Borrows and returns a mutable reference to the node owned by the root.\n+    pub fn node_as_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -226,12 +228,12 @@ impl<K, V> Root<K, V> {\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(\n-                self.as_mut().cast_unchecked::<marker::Internal>().first_edge().descend().node,\n+                self.node_as_mut().cast_unchecked::<marker::Internal>().first_edge().descend().node,\n             )\n         };\n         self.height -= 1;\n         unsafe {\n-            (*self.as_mut().as_leaf_mut()).parent = ptr::null();\n+            (*self.node_as_mut().as_leaf_mut()).parent = ptr::null();\n         }\n \n         unsafe {\n@@ -616,7 +618,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     let edge =\n                         ptr::read(internal.as_internal().edges.get_unchecked(idx + 1).as_ptr());\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n+                    (*new_root.node_as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n                 }\n             };\n@@ -648,7 +650,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n+                    (*new_root.node_as_mut().as_leaf_mut()).parent = ptr::null();\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -868,7 +870,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             } else {\n                 unsafe {\n                     Handle::new_edge(\n-                        right.as_mut().cast_unchecked::<marker::Leaf>(),\n+                        right.node_as_mut().cast_unchecked::<marker::Leaf>(),\n                         self.idx - (B + 1),\n                     )\n                     .insert_fit(key, val)\n@@ -943,7 +945,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             } else {\n                 unsafe {\n                     Handle::new_edge(\n-                        right.as_mut().cast_unchecked::<marker::Internal>(),\n+                        right.node_as_mut().cast_unchecked::<marker::Internal>(),\n                         self.idx - (B + 1),\n                     )\n                     .insert_fit(key, val, edge);\n@@ -1117,7 +1119,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n             for i in 0..(new_len + 1) {\n-                Handle::new_edge(new_root.as_mut().cast_unchecked(), i).correct_parent_link();\n+                Handle::new_edge(new_root.node_as_mut().cast_unchecked(), i).correct_parent_link();\n             }\n \n             (self.node, k, v, new_root)"}]}