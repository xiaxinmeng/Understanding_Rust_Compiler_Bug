{"sha": "ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNmQyODljNWIzMjJhMjE3MWY3ZjljYmQ2ZWVhOThkYTRlOTUwOTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-20T02:45:25Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:30:12Z"}, "message": "suspend lvalues, not locks. refactor memory locking.\n\nDue to this, we are back down to 88 tests", "tree": {"sha": "3f9ddaa821ad0cc0c230ef3022bf9a58f73c3572", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f9ddaa821ad0cc0c230ef3022bf9a58f73c3572"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAll3AZQACgkQpp+NIls6\n19lKWg//cEgTjWaie7EgdDFV4zTHKpzI5Tzapa/CjpuTIsJOSOSCnJY4QvGttTC/\nIo7ZJX/4ikMM/S+WipKiHOw9jrCJnZw+VrAxcJr0f7Kk/Z0ix+8IiYoSpy06HjGi\nfeTxfY4o3jP5eLOtZeLEWwZrBa1oODjv0keaBQvVlTAJHt10Sgw6rAYbti7qhY83\np/ZQcD/w1UwuddUH8pQrkW51aoSkm+u5KrBj8G/dadOI0VCwjaKXf4siSOCqwiRC\n7Kw88+2+W2R5LkV6hfN2dbTYZD2Nh8NY72FCZWL2pFwFJr2t1k3PWihyctr9n3D1\nip+SCpEhfvksnLYq7+AGibxptQC5Z/Rl+W2DWSbDfazXMQWgSxPMqra985MCkZyI\nt/Fn3E07yHWmx0Xi/v0pXBydR9dM9bwhKFauJXB8Du5VlCXYd7obPSd+SAuOY5qf\ns1qU8UZEvfQ6W2AbpyoQx7xar7Q3/H5f9pKD6bjvyIRsWhYF3rK+x42GMyRe7YTN\nvpB+yQ1Qx+gDq1nxn9XSeFZc6/jjMUzAvU78XYN+XANqkcYcogOhhRt5+uLDnoah\nY2WjQkkvCH5v8onawFgMgTKu9d6S444O+GreiXvpkpe4pQ7SrzKFLThZVUqE31/4\nwle01AFevU9tpnzGjzufmWSmR+ZiP173m/fKFSzvwXZ6m3gSSbI=\n=Eadr\n-----END PGP SIGNATURE-----", "payload": "tree 3f9ddaa821ad0cc0c230ef3022bf9a58f73c3572\nparent 0b15db0cc2f8529c518625e726241f6dbefb7efe\nauthor Ralf Jung <post@ralfj.de> 1500518725 -0700\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500971412 +0200\n\nsuspend lvalues, not locks. refactor memory locking.\n\nDue to this, we are back down to 88 tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "html_url": "https://github.com/rust-lang/rust/commit/ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b15db0cc2f8529c518625e726241f6dbefb7efe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b15db0cc2f8529c518625e726241f6dbefb7efe", "html_url": "https://github.com/rust-lang/rust/commit/0b15db0cc2f8529c518625e726241f6dbefb7efe"}], "stats": {"total": 402, "additions": 239, "deletions": 163}, "files": [{"sha": "76a9b3d0e051aa82095bfae0c626203b5204069d", "filename": "src/librustc_mir/interpret/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fbin%2Fmiri.rs?ref=ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "patch": "@@ -202,6 +202,7 @@ fn main() {\n \n     // for auxilary builds in unit tests\n     args.push(\"-Zalways-encode-mir\".to_owned());\n+    args.push(\"-Zmir-emit-validate\".to_owned());\n \n     rustc_driver::run_compiler(&args, &mut MiriCompilerCalls(RustcDefaultCalls), None, None);\n }"}, {"sha": "dc17df54aed3db321bafdb5db7c42290271f61bf", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "patch": "@@ -54,9 +54,16 @@ pub enum EvalError<'tcx> {\n     MemoryLockViolation {\n         ptr: MemoryPointer,\n         len: u64,\n+        frame: usize,\n         access: AccessKind,\n         lock: LockInfo,\n     },\n+    MemoryAcquireConflict {\n+        ptr: MemoryPointer,\n+        len: u64,\n+        kind: AccessKind,\n+        lock: LockInfo,\n+    },\n     InvalidMemoryLockRelease {\n         ptr: MemoryPointer,\n         len: u64,\n@@ -114,10 +121,12 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"invalid use of NULL pointer\",\n             MemoryLockViolation { .. } =>\n                 \"memory access conflicts with lock\",\n+            MemoryAcquireConflict { .. } =>\n+                \"new memory lock conflicts with existing lock\",\n             ValidationFailure(..) =>\n                 \"type validation failed\",\n             InvalidMemoryLockRelease { .. } =>\n-                \"memory lock released that was never acquired\",\n+                \"invalid attempt to release write lock\",\n             DeallocatedLockedMemory { .. } =>\n                 \"tried to deallocate memory in conflict with a lock\",\n             ReadPointerAsBytes =>\n@@ -219,12 +228,16 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        if access { \"memory access\" } else { \"pointer computed\" },\n                        ptr.offset, ptr.alloc_id, allocation_size)\n             },\n-            MemoryLockViolation { ptr, len, access, ref lock } => {\n-                write!(f, \"{:?} access at {:?}, size {}, is in conflict with lock {:?}\",\n-                       access, ptr, len, lock)\n+            MemoryLockViolation { ptr, len, frame, access, ref lock } => {\n+                write!(f, \"{:?} access by frame {} at {:?}, size {}, is in conflict with lock {:?}\",\n+                       access, frame, ptr, len, lock)\n+            }\n+            MemoryAcquireConflict { ptr, len, kind, ref lock } => {\n+                write!(f, \"new {:?} lock at {:?}, size {}, is in conflict with lock {:?}\",\n+                       kind, ptr, len, lock)\n             }\n             InvalidMemoryLockRelease { ptr, len } => {\n-                write!(f, \"tried to release memory write lock at {:?}, size {}, but the write lock is held by someone else\",\n+                write!(f, \"tried to release memory write lock at {:?}, size {}, but the write lock is held by someone else or its a read lock\",\n                        ptr, len)\n             }\n             DeallocatedLockedMemory { ptr, ref lock } => {"}, {"sha": "00ceec28074a083ec97d5bfee13d349a1406fcbf", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "patch": "@@ -4,6 +4,7 @@ use std::fmt::Write;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::ConstVal;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n@@ -21,6 +22,7 @@ use memory::{Memory, MemoryPointer, TlsKey, HasMemory};\n use memory::Kind as MemoryKind;\n use operator;\n use value::{PrimVal, PrimValKind, Value, Pointer};\n+use validation::ValidationQuery;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n@@ -29,6 +31,9 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The virtual memory system.\n     pub(crate) memory: Memory<'a, 'tcx>,\n \n+    /// Lvalues that were suspended by the validation subsystem, and will be recovered later\n+    pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n+\n     /// Precomputed statics, constants and promoteds.\n     pub(crate) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n@@ -112,6 +117,12 @@ pub enum StackPopCleanup {\n     None,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DynamicLifetime {\n+    pub frame: usize,\n+    pub region: Option<CodeExtent>, // \"None\" indicates \"until the function ends\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct ResourceLimits {\n     pub memory_size: u64,\n@@ -134,6 +145,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         EvalContext {\n             tcx,\n             memory: Memory::new(&tcx.data_layout, limits.memory_size),\n+            suspended: HashMap::new(),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,"}, {"sha": "3b82b93023a5a3bdb0d01ba2e223cc7be3690956", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 85, "deletions": 81, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "patch": "@@ -9,7 +9,7 @@ use rustc::middle::region::CodeExtent;\n \n use error::{EvalError, EvalResult};\n use value::{PrimVal, Pointer};\n-use eval_context::EvalContext;\n+use eval_context::{EvalContext, DynamicLifetime};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n@@ -24,7 +24,7 @@ mod range {\n     // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n     // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n     // This kind of search breaks, if `end < start`, so don't do that!\n-    #[derive(Eq, PartialEq, Ord, PartialOrd, Debug)]\n+    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n     pub struct MemoryRange {\n         start: u64,\n         end: u64,\n@@ -39,14 +39,6 @@ mod range {\n             }\n         }\n \n-        pub fn offset(&self) -> u64 {\n-            self.start\n-        }\n-\n-        pub fn len(&self) -> u64 {\n-            self.end - self.start\n-        }\n-\n         pub fn range(offset: u64, len: u64) -> ops::Range<MemoryRange> {\n             assert!(len > 0);\n             // We select all elements that are within\n@@ -83,33 +75,21 @@ pub enum AccessKind {\n     Write,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-struct DynamicLifetime {\n-    pub frame: usize,\n-    pub region: Option<CodeExtent>, // \"None\" indicates \"until the function ends\"\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum LockStatus {\n-    Held,\n-    RecoverAfter(CodeExtent), // the frame is given by the surrounding LockInfo's lifetime.\n-}\n-\n-/// Information about a lock that is or will be held.\n+/// Information about a lock that is currently held.\n #[derive(Clone, Debug)]\n-pub struct LockInfo {\n-    kind: AccessKind,\n-    lifetime: DynamicLifetime,\n-    status: LockStatus,\n+pub enum LockInfo {\n+    WriteLock(DynamicLifetime),\n+    ReadLock(Vec<DynamicLifetime>), // This should never be empty -- that would be a read lock held and nobody there to release it...\n }\n+use self::LockInfo::*;\n \n impl LockInfo {\n-    fn access_permitted(&self, frame: usize, access: AccessKind) -> bool {\n+    fn access_permitted(&self, frame: Option<usize>, access: AccessKind) -> bool {\n         use self::AccessKind::*;\n-        match (self.kind, access) {\n-            (Read, Read) => true, // Read access to read-locked region is okay, no matter who's holding the read lock.\n-            (Write, _) if self.lifetime.frame == frame => true, // All access is okay when we hold the write lock.\n-            _ => false, // Somebody else holding the write lock is not okay\n+        match (self, access) {\n+            (&ReadLock(_), Read) => true, // Read access to read-locked region is okay, no matter who's holding the read lock.\n+            (&WriteLock(ref lft), _) if Some(lft.frame) == frame => true, // All access is okay when we hold the write lock.\n+            _ => false, // Nothing else is okay.\n         }\n     }\n }\n@@ -146,28 +126,27 @@ pub struct Allocation {\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: Kind,\n     /// Memory regions that are locked by some function\n-    locks: BTreeMap<MemoryRange, Vec<LockInfo>>,\n+    locks: BTreeMap<MemoryRange, LockInfo>,\n }\n \n impl Allocation {\n-    fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=&'a LockInfo> + 'a {\n+    fn iter_locks<'a>(&'a self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a LockInfo)> + 'a {\n         self.locks.range(MemoryRange::range(offset, len))\n             .filter(move |&(range, _)| range.overlaps(offset, len))\n-            .flat_map(|(_, locks)| locks.iter())\n     }\n \n-    fn iter_lock_vecs_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a mut Vec<LockInfo>)> + 'a {\n+    fn iter_locks_mut<'a>(&'a mut self, offset: u64, len: u64) -> impl Iterator<Item=(&'a MemoryRange, &'a mut LockInfo)> + 'a {\n         self.locks.range_mut(MemoryRange::range(offset, len))\n             .filter(move |&(range, _)| range.overlaps(offset, len))\n     }\n \n-    fn check_locks<'tcx>(&self, frame: usize, offset: u64, len: u64, access: AccessKind) -> Result<(), LockInfo> {\n+    fn check_locks<'tcx>(&self, frame: Option<usize>, offset: u64, len: u64, access: AccessKind) -> Result<(), LockInfo> {\n         if len == 0 {\n             return Ok(())\n         }\n-        for lock in self.iter_locks(offset, len) {\n-            // Check if the lock is active, and is in conflict with the access.\n-            if lock.status == LockStatus::Held && !lock.access_permitted(frame, access) {\n+        for (_, lock) in self.iter_locks(offset, len) {\n+            // Check if the lock is in conflict with the access.\n+            if !lock.access_permitted(frame, access) {\n                 return Err(lock.clone());\n             }\n         }\n@@ -399,7 +378,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         // However, we should check *something*.  For now, we make sure that there is no conflicting write\n         // lock by another frame.  We *have* to permit deallocation if we hold a read lock.\n         // TODO: Figure out the exact rules here.\n-        alloc.check_locks(self.cur_frame, 0, alloc.bytes.len() as u64, AccessKind::Read)\n+        alloc.check_locks(Some(self.cur_frame), 0, alloc.bytes.len() as u64, AccessKind::Read)\n             .map_err(|lock| EvalError::DeallocatedLockedMemory { ptr, lock })?;\n \n         if alloc.kind != kind {\n@@ -553,88 +532,113 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Ok(())\n         }\n         let alloc = self.get(ptr.alloc_id)?;\n-        alloc.check_locks(self.cur_frame, ptr.offset, len, access)\n-            .map_err(|lock| EvalError::MemoryLockViolation { ptr, len, access, lock })\n+        let frame = self.cur_frame;\n+        alloc.check_locks(Some(frame), ptr.offset, len, access)\n+            .map_err(|lock| EvalError::MemoryLockViolation { ptr, len, frame, access, lock })\n     }\n \n     /// Acquire the lock for the given lifetime\n     pub(crate) fn acquire_lock(&mut self, ptr: MemoryPointer, len: u64, region: Option<CodeExtent>, kind: AccessKind) -> EvalResult<'tcx> {\n+        use std::collections::btree_map::Entry::*;\n+\n+        let frame = self.cur_frame;\n         assert!(len > 0);\n-        trace!(\"Acquiring {:?} lock at {:?}, size {} for region {:?}\", kind, ptr, len, region);\n+        trace!(\"Frame {} acquiring {:?} lock at {:?}, size {} for region {:?}\", frame, kind, ptr, len, region);\n         self.check_bounds(ptr.offset(len, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_locks(ptr, len, kind)?; // make sure we have the access we are acquiring\n-        let lifetime = DynamicLifetime { frame: self.cur_frame, region };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n-        alloc.locks.entry(MemoryRange::new(ptr.offset, len)).or_insert_with(|| Vec::new()).push(LockInfo { lifetime, kind, status: LockStatus::Held });\n+\n+        // Check if this conflicts with other locks\n+        alloc.check_locks(None, ptr.offset, len, kind)\n+            .map_err(|lock| EvalError::MemoryAcquireConflict { ptr, len, kind, lock })?;\n+\n+        let lifetime = DynamicLifetime { frame, region };\n+        match (alloc.locks.entry(MemoryRange::new(ptr.offset, len)), kind) {\n+            (Vacant(entry), AccessKind::Read) => { entry.insert(ReadLock(vec![lifetime])); },\n+            (Vacant(entry), AccessKind::Write) => { entry.insert(WriteLock(lifetime)); },\n+            (Occupied(mut entry), AccessKind::Read) =>\n+                match *entry.get_mut() {\n+                    ReadLock(ref mut lifetimes) => lifetimes.push(lifetime),\n+                    WriteLock(_) => bug!(\"We already checked that there is no conflicting write lock\"),\n+                },\n+            (Occupied(_), AccessKind::Write) => bug!(\"We already checked that there is no conflicting lock\"),\n+        };\n         Ok(())\n     }\n \n     /// Release a write lock prematurely. If there's just read locks, do nothing.\n-    pub(crate) fn release_write_lock_until(&mut self, ptr: MemoryPointer, len: u64, release_until: Option<CodeExtent>) -> EvalResult<'tcx> {\n+    pub(crate) fn release_write_lock(&mut self, ptr: MemoryPointer, len: u64) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n-        for (range, locks) in alloc.iter_lock_vecs_mut(ptr.offset, len) {\n-            // Check all locks in this region; make sure there are no conflicting write locks of other frames.\n-            // Also, if we will recover later, perform our release by changing the lock status.\n-            for lock in locks.iter_mut() {\n-                if lock.kind == AccessKind::Read || lock.status != LockStatus::Held { continue; }\n-                if lock.lifetime.frame != cur_frame {\n-                    return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n-                }\n-                if !range.contained_in(ptr.offset, len) {\n-                    return Err(EvalError::Unimplemented(format!(\"miri does not support release part of a write-locked region\")));\n-                }\n-                let ptr = MemoryPointer { alloc_id : ptr.alloc_id, offset: range.offset() };\n-                trace!(\"Releasing write lock at {:?}, size {} until {:?}\", ptr, range.len(), release_until);\n-                if let Some(region) = release_until {\n-                    lock.status = LockStatus::RecoverAfter(region);\n+        let mut remove_list : Vec<MemoryRange> = Vec::new();\n+        for (range, lock) in alloc.iter_locks_mut(ptr.offset, len) {\n+            match *lock {\n+                WriteLock(ref lft) => {\n+                    // Make sure we can release this lock\n+                    if lft.frame != cur_frame {\n+                        return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n+                    }\n+                    if !range.contained_in(ptr.offset, len) {\n+                        return Err(EvalError::Unimplemented(format!(\"miri does not support release part of a write-locked region\")));\n+                    }\n+                    // Release it later.  We cannot do this now.\n+                    remove_list.push(*range);\n                 }\n+                ReadLock(_) => {\n+                    return Err(EvalError::InvalidMemoryLockRelease { ptr, len });\n+                },\n             }\n+        }\n \n-            // If we will not recover, we did not do anything above except for some checks. Now, erase the locks from the list.\n-            if let None = release_until {\n-                // Delete everything that's a held write lock.  We already checked above that these are ours.\n-                // Unfortunately, this duplicates the condition from above.  Is there anything we can do about this?\n-                locks.retain(|lock| lock.kind == AccessKind::Read || lock.status != LockStatus::Held);\n-            }\n+        for range in remove_list {\n+            alloc.locks.remove(&range);\n         }\n \n+        // TODO: Test that we actually released a write lock for the entire covered region.\n+\n         Ok(())\n     }\n \n     pub(crate) fn locks_lifetime_ended(&mut self, ending_region: Option<CodeExtent>) {\n         trace!(\"Releasing locks that expire at {:?}\", ending_region);\n         let cur_frame = self.cur_frame;\n-        let has_ended =  |lock: &LockInfo| -> bool {\n-            if lock.lifetime.frame != cur_frame {\n+        let has_ended =  |lifetime: &DynamicLifetime| -> bool {\n+            if lifetime.frame != cur_frame {\n                 return false;\n             }\n             match ending_region {\n                 None => true, // When a function ends, we end *all* its locks. It's okay for a function to still have lifetime-related locks\n                               // when it returns, that can happen e.g. with NLL when a lifetime can, but does not have to, extend beyond the\n                               // end of a function.  Same for a function still having recoveries.\n-                Some(ending_region) => lock.lifetime.region == Some(ending_region),\n+                Some(ending_region) => lifetime.region == Some(ending_region),\n             }\n         };\n \n         for alloc in self.alloc_map.values_mut() {\n-            for (_range, locks) in alloc.locks.iter_mut() {\n+            // Collect things for removal as we cannot remove while iterating\n+            let mut remove_list : Vec<MemoryRange> = Vec::new();\n+            for (range, lock) in alloc.locks.iter_mut() {\n                 // Delete everything that ends now -- i.e., keep only all the other lifetimes.\n-                locks.retain(|lock| !has_ended(lock));\n-                // Activate locks that get recovered now\n-                if let Some(ending_region) = ending_region {\n-                    for lock in locks.iter_mut() {\n-                        if lock.lifetime.frame == cur_frame && lock.status == LockStatus::RecoverAfter(ending_region) {\n-                            // FIXME: Check if this triggers a conflict between active locks\n-                            lock.status = LockStatus::Held;\n+                match *lock {\n+                    WriteLock(ref lft) => {\n+                        if has_ended(lft) {\n+                            remove_list.push(*range);\n                         }\n                     }\n+                    ReadLock(ref mut lfts) => {\n+                        lfts.retain(|lft| !has_ended(lft));\n+                        if lfts.is_empty() {\n+                            remove_list.push(*range);\n+                        }\n+                    },\n                 }\n             }\n+            // Perform delayed removal\n+            for range in remove_list {\n+                alloc.locks.remove(&range);\n+            }\n         }\n-        // TODO: It may happen now that we leave empty vectors in the map.  Is it worth getting rid of them?\n     }\n }\n "}, {"sha": "4dac10ff24caad4adc89613fa98df485254eed0d", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "patch": "@@ -9,12 +9,11 @@ use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty;\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::{Subst, Substs};\n+use rustc::ty::subst::Substs;\n \n use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n-use validation::ValidationCtx;\n use value::{Value, PrimVal};\n use syntax::codemap::Span;\n use syntax::ast::Mutability;\n@@ -132,14 +131,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // Validity checks.\n             Validate(op, ref lvalues) => {\n                 for operand in lvalues {\n-                    // We need to monomorphize ty *without* erasing lifetimes\n-                    let ty = operand.ty.subst(self.tcx, self.substs());\n-                    let lvalue = self.eval_lvalue(&operand.lval)?;\n-                    self.validate(lvalue, ty, ValidationCtx::new(op))?;\n+                    self.validation_op(op, operand)?;\n                 }\n             }\n             EndRegion(ce) => {\n-                self.memory.locks_lifetime_ended(Some(ce));\n+                self.end_region(ce)?;\n             }\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the"}, {"sha": "9709e3de1d43dcc9b36713f094980aedefe22797", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 120, "deletions": 70, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d289c5b322a2171f7f9cbd6eea98da4e95099/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=ec6d289c5b322a2171f7f9cbd6eea98da4e95099", "patch": "@@ -1,83 +1,135 @@\n use rustc::hir::Mutability;\n-use rustc::mir::{self, ValidationOp};\n+use rustc::hir::Mutability::*;\n+use rustc::mir::{self, ValidationOp, ValidationOperand};\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc::infer::TransNormalize;\n use rustc::middle::region::CodeExtent;\n \n use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext};\n+use eval_context::{EvalContext, DynamicLifetime};\n use memory::AccessKind;\n use value::Value;\n use lvalue::{Lvalue, LvalueExtra};\n \n-// Validity checks\n+pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue<'tcx>>;\n+\n #[derive(Copy, Clone, Debug)]\n-pub struct ValidationCtx {\n-    op: ValidationOp,\n-    region: Option<CodeExtent>,\n-    mutbl: Mutability,\n+enum ValidationMode {\n+    Acquire,\n+    /// Recover because the given region ended\n+    Recover(CodeExtent),\n+    Release\n }\n \n-impl ValidationCtx {\n-    pub fn new(op: ValidationOp) -> Self {\n-        ValidationCtx {\n-            op, region: None, mutbl: Mutability::MutMutable,\n+impl ValidationMode {\n+    fn acquiring(self) -> bool {\n+        use self::ValidationMode::*;\n+        match self {\n+            Acquire | Recover(_) => true,\n+            Release => false,\n         }\n     }\n }\n \n+// Validity checks\n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    pub(crate) fn validation_op(&mut self, op: ValidationOp, operand: &ValidationOperand<'tcx, mir::Lvalue<'tcx>>) -> EvalResult<'tcx> {\n+        // We need to monomorphize ty *without* erasing lifetimes\n+        let ty = operand.ty.subst(self.tcx, self.substs());\n+        let lval = self.eval_lvalue(&operand.lval)?;\n+        let query = ValidationQuery { lval, ty, re: operand.re, mutbl: operand.mutbl };\n+\n+        let mode = match op {\n+            ValidationOp::Acquire => ValidationMode::Acquire,\n+            ValidationOp::Release => ValidationMode::Release,\n+            ValidationOp::Suspend(ce) => {\n+                if operand.mutbl == MutImmutable {\n+                    // Nothing to do when suspending immutable things\n+                    return Ok(());\n+                }\n+                let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+                trace!(\"Suspending {:?} until {:?}\", query, ce);\n+                self.suspended.entry(lft).or_insert_with(Vec::new).push(query.clone());\n+                ValidationMode::Release\n+            }\n+        };\n+        self.validate(query, mode)?;\n+        Ok(())\n+    }\n+\n+    pub(crate) fn end_region(&mut self, ce: CodeExtent) -> EvalResult<'tcx> {\n+        self.memory.locks_lifetime_ended(Some(ce));\n+        // Recover suspended lvals\n+        let lft = DynamicLifetime { frame: self.cur_frame(), region: Some(ce) };\n+        if let Some(queries) = self.suspended.remove(&lft) {\n+            for query in queries {\n+                self.validate(query, ValidationMode::Recover(ce))?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn validate_variant(\n         &mut self,\n-        lvalue: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n+        query: ValidationQuery<'tcx>,\n         variant: &ty::VariantDef,\n         subst: &ty::subst::Substs<'tcx>,\n-        vctx: ValidationCtx,\n+        mode: ValidationMode,\n     ) -> EvalResult<'tcx> {\n-        // TODO: Take visibility/privacy into account.\n+        // TODO: Maybe take visibility/privacy into account.\n         for (idx, field) in variant.fields.iter().enumerate() {\n             let field_ty = field.ty(self.tcx, subst);\n-            let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-            self.validate(field_lvalue, field_ty, vctx)?;\n+            let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+            self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n         }\n         Ok(())\n     }\n \n-    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, vctx: ValidationCtx) -> EvalResult<'tcx> {\n+    fn validate_ptr(&mut self, val: Value, pointee_ty: Ty<'tcx>, re: Option<CodeExtent>, mutbl: Mutability, mode: ValidationMode) -> EvalResult<'tcx> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&mut self.memory)?;\n         self.memory.check_align(ptr, align)?;\n \n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n-        self.validate(pointee_lvalue, pointee_ty, vctx)\n+        self.validate(ValidationQuery { lval: pointee_lvalue, ty: pointee_ty, re, mutbl }, mode)\n     }\n \n-    /// Validate the lvalue at the given type. If `release` is true, just do a release of all write locks\n-    pub(super) fn validate(&mut self, lvalue: Lvalue<'tcx>, mut ty: Ty<'tcx>, mut vctx: ValidationCtx) -> EvalResult<'tcx>\n+    /// Validate the lvalue at the given type. If `acquire` is false, just do a release of all write locks\n+    fn validate(&mut self, mut query: ValidationQuery<'tcx>, mode: ValidationMode) -> EvalResult<'tcx>\n     {\n         use rustc::ty::TypeVariants::*;\n         use rustc::ty::RegionKind::*;\n         use rustc::ty::AdtKind;\n-        use self::Mutability::*;\n+\n+        // No point releasing shared stuff.\n+        if !mode.acquiring() && query.mutbl == MutImmutable {\n+            return Ok(());\n+        }\n+        // When we recover, we may see data whose validity *just* ended.  Do not acquire it.\n+        if let ValidationMode::Recover(ce) = mode {\n+            if Some(ce) == query.re {\n+                return Ok(());\n+            }\n+        }\n \n         // This is essentially a copy of normalize_associated_type, but without erasure\n-        if ty.has_projection_types() {\n+        if query.ty.has_projection_types() {\n             let param_env = ty::ParamEnv::empty(Reveal::All);\n-            ty = self.tcx.infer_ctxt().enter(move |infcx| {\n-                ty.trans_normalize(&infcx, param_env)\n+            let old_ty = query.ty;\n+            query.ty = self.tcx.infer_ctxt().enter(move |infcx| {\n+                old_ty.trans_normalize(&infcx, param_env)\n             })\n         }\n-        let ty = ty; // no more mutation\n-        trace!(\"Validating {:?} at type {}, context {:?}\", lvalue, ty, vctx);\n+        trace!(\"{:?} on {:?}\", mode, query);\n \n         // Decide whether this type *owns* the memory it covers (like integers), or whether it\n         // just assembles pieces (that each own their memory) together to a larger whole.\n         // TODO: Currently, we don't acquire locks for padding and discriminants. We should.\n-        let is_owning = match ty.sty {\n+        let is_owning = match query.ty.sty {\n             TyInt(_) | TyUint(_) | TyRawPtr(_) |\n             TyBool | TyFloat(_) | TyChar | TyStr |\n             TyRef(..) | TyFnPtr(..) | TyFnDef(..) | TyNever => true,\n@@ -86,18 +138,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyParam(_) | TyInfer(_) | TyProjection(_) | TyAnon(..) | TyError => bug!(\"I got an incomplete/unnormalized type for validation\"),\n         };\n         if is_owning {\n-            match lvalue {\n+            match query.lval {\n                 Lvalue::Ptr { ptr, extra, aligned: _ } => {\n                     // Determine the size\n                     // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n-                    let len = match self.type_size(ty)? {\n+                    let len = match self.type_size(query.ty)? {\n                         Some(size) => {\n                             assert_eq!(extra, LvalueExtra::None, \"Got a fat ptr to a sized type\");\n                             size\n                         }\n                         None => {\n                             // The only unsized typ we concider \"owning\" is TyStr.\n-                            assert_eq!(ty.sty, TyStr, \"Found a surprising unsized owning type\");\n+                            assert_eq!(query.ty.sty, TyStr, \"Found a surprising unsized owning type\");\n                             // The extra must be the length, in bytes.\n                             match extra {\n                                 LvalueExtra::Length(len) => len,\n@@ -108,11 +160,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // Handle locking\n                     if len > 0 {\n                         let ptr = ptr.to_ptr()?;\n-                        let access = match vctx.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n-                        match vctx.op {\n-                            ValidationOp::Acquire => self.memory.acquire_lock(ptr, len, vctx.region, access)?,\n-                            ValidationOp::Release => self.memory.release_write_lock_until(ptr, len, None)?,\n-                            ValidationOp::Suspend(region) => self.memory.release_write_lock_until(ptr, len, Some(region))?,\n+                        let access = match query.mutbl { MutMutable => AccessKind::Write, MutImmutable => AccessKind::Read };\n+                        if mode.acquiring() {\n+                            self.memory.acquire_lock(ptr, len, query.re, access)?;\n+                        } else {\n+                            self.memory.release_write_lock(ptr, len)?;\n                         }\n                     }\n                 }\n@@ -122,7 +174,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        match ty.sty {\n+        match query.ty.sty {\n             TyInt(_) | TyUint(_) | TyRawPtr(_) => {\n                 // TODO: Make sure these are not undef.\n                 // We could do a bounds-check and other sanity checks on the lvalue, but it would be a bug in miri for this to ever fail.\n@@ -136,33 +188,29 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Err(EvalError::ValidationFailure(format!(\"The empty type is never valid.\")))\n             }\n             TyRef(region, ty::TypeAndMut { ty: pointee_ty, mutbl }) => {\n-                let val = self.read_lvalue(lvalue)?;\n+                let val = self.read_lvalue(query.lval)?;\n                 // Sharing restricts our context\n                 if mutbl == MutImmutable {\n-                    // Actually, in case of releasing-validation, this means we are done.\n-                    if vctx.op != ValidationOp::Acquire {\n-                        return Ok(());\n-                    }\n-                    vctx.mutbl = MutImmutable;\n+                    query.mutbl = MutImmutable;\n                 }\n                 // Inner lifetimes *outlive* outer ones, so only if we have no lifetime restriction yet,\n                 // we record the region of this borrow to the context.\n-                if vctx.region == None {\n+                if query.re == None {\n                     match *region {\n-                        ReScope(ce) => vctx.region = Some(ce),\n+                        ReScope(ce) => query.re = Some(ce),\n                         // It is possible for us to encode erased lifetimes here because the lifetimes in\n                         // this functions' Subst will be erased.\n                         _ => {},\n                     }\n                 }\n-                self.validate_ptr(val, pointee_ty, vctx)\n+                self.validate_ptr(val, pointee_ty, query.re, query.mutbl, mode)\n             }\n             TyAdt(adt, _) if adt.is_box() => {\n-                let val = self.read_lvalue(lvalue)?;\n-                self.validate_ptr(val, ty.boxed_ty(), vctx)\n+                let val = self.read_lvalue(query.lval)?;\n+                self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n             }\n             TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(lvalue)?.into_ptr(&mut self.memory)?.to_ptr()?;\n+                let ptr = self.read_lvalue(query.lval)?.into_ptr(&mut self.memory)?.to_ptr()?;\n                 self.memory.get_fn(ptr)?;\n                 // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 Ok(())\n@@ -175,28 +223,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Compound types\n             TySlice(elem_ty) => {\n-                let len = match lvalue {\n+                let len = match query.lval {\n                     Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n-                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", lvalue),\n+                    _ => bug!(\"acquire_valid of a TySlice given non-slice lvalue: {:?}\", query.lval),\n                 };\n                 for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(lvalue, ty, i)?;\n-                    self.validate(inner_lvalue, elem_ty, vctx)?;\n+                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i)?;\n+                    self.validate(ValidationQuery { lval: inner_lvalue, ty: elem_ty, ..query }, mode)?;\n                 }\n                 Ok(())\n             }\n             TyArray(elem_ty, len) => {\n                 for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(lvalue, ty, i as u64)?;\n-                    self.validate(inner_lvalue, elem_ty, vctx)?;\n+                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i as u64)?;\n+                    self.validate(ValidationQuery { lval: inner_lvalue, ty: elem_ty, ..query }, mode)?;\n                 }\n                 Ok(())\n             }\n             TyDynamic(_data, _region) => {\n                 // Check that this is a valid vtable\n-                let vtable = match lvalue {\n+                let vtable = match query.lval {\n                     Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n-                    _ => bug!(\"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\", lvalue),\n+                    _ => bug!(\"acquire_valid of a TyDynamic given non-trait-object lvalue: {:?}\", query.lval),\n                 };\n                 self.read_size_and_align_from_vtable(vtable)?;\n                 // TODO: Check that the vtable contains all the function pointers we expect it to have.\n@@ -207,16 +255,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(())\n             }\n             TyAdt(adt, subst) => {\n-                if Some(adt.did) == self.tcx.lang_items.unsafe_cell_type() {\n-                    // No locks for unsafe cells.  Also no other validation, the only field is private anyway.\n+                if Some(adt.did) == self.tcx.lang_items.unsafe_cell_type() /*&& query.mutbl == MutImmutable*/ {\n+                    // No locks for shared unsafe cells.  Also no other validation, the only field is private anyway.\n+                    // FIXME: For now we also don't acquire locks for mutable UnsafeCell, because this gets violated a lot\n+                    // by unsafe code.\n                     return Ok(());\n                 }\n \n                 match adt.adt_kind() {\n                     AdtKind::Enum => {\n                         // TODO: Can we get the discriminant without forcing an allocation?\n-                        let ptr = self.force_allocation(lvalue)?.to_ptr()?;\n-                        let discr = self.read_discriminant_value(ptr, ty)?;\n+                        let ptr = self.force_allocation(query.lval)?.to_ptr()?;\n+                        let discr = self.read_discriminant_value(ptr, query.ty)?;\n \n                         // Get variant index for discriminant\n                         let variant_idx = adt.discriminants(self.tcx)\n@@ -226,21 +276,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         if variant.fields.len() > 0 {\n                             // Downcast to this variant, if needed\n-                            let lvalue = if adt.variants.len() > 1 {\n-                                self.eval_lvalue_projection(lvalue, ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?\n+                            let lval = if adt.variants.len() > 1 {\n+                                self.eval_lvalue_projection(query.lval, query.ty, &mir::ProjectionElem::Downcast(adt, variant_idx))?\n                             } else {\n-                                lvalue\n+                                query.lval\n                             };\n \n                             // Recursively validate the fields\n-                            self.validate_variant(lvalue, ty, variant, subst, vctx)\n+                            self.validate_variant(ValidationQuery { lval, ..query} , variant, subst, mode)\n                         } else {\n                             // No fields, nothing left to check.  Downcasting may fail, e.g. in case of a CEnum.\n                             Ok(())\n                         }\n                     }\n                     AdtKind::Struct => {\n-                        self.validate_variant(lvalue, ty, adt.struct_variant(), subst, vctx)\n+                        self.validate_variant(query, adt.struct_variant(), subst, mode)\n                     }\n                     AdtKind::Union => {\n                         // No guarantees are provided for union types.\n@@ -251,15 +301,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n             TyTuple(ref types, _) => {\n                 for (idx, field_ty) in types.iter().enumerate() {\n-                    let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-                    self.validate(field_lvalue, field_ty, vctx)?;\n+                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+                    self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n                 }\n                 Ok(())\n             }\n             TyClosure(def_id, ref closure_substs) => {\n                 for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n-                    let field_lvalue = self.lvalue_field(lvalue, idx, ty, field_ty)?;\n-                    self.validate(field_lvalue, field_ty, vctx)?;\n+                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+                    self.validate(ValidationQuery { lval: field_lvalue, ty: field_ty, ..query }, mode)?;\n                 }\n                 // TODO: Check if the signature matches (should be the same check as what terminator/mod.rs already does on call?).\n                 // Is there other things we can/should check?  Like vtable pointers?"}]}