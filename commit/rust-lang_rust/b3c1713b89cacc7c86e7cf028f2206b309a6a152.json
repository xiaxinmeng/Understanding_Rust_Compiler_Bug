{"sha": "b3c1713b89cacc7c86e7cf028f2206b309a6a152", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYzE3MTNiODljYWNjN2M4NmU3Y2YwMjhmMjIwNmIzMDlhNmExNTI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-10T11:01:51Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-10T11:01:51Z"}, "message": "expose a minimal API and use it in the binary", "tree": {"sha": "4b719f3d9d1879f8cc54b872f3e44664636f6606", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b719f3d9d1879f8cc54b872f3e44664636f6606"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3c1713b89cacc7c86e7cf028f2206b309a6a152", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXWp4fAAoJEFbW7qD8Z6xGghMP/3oDzJB+0DZUULpL0X3eqcA3\nPgneQQCO1sp5fVC8cBMuZMyWLpE9z4VhLKDBSeO6JaJQHrMXThg3PtjXOwZim40N\n1+dLDRImAkWOdZQ9/vYkdOVs3xck0KQ0qkjP8udMoXhy/qVnMhDFao9cXUHocRK6\nXktAoJLXzPLHW3UYOlk202t/CdEvdw5pkYa0YKqc3PfkmHKFKYkbxQ0NWx/lI/nU\nit8pFlk7VIPgKUTg8CILZT3/ndVxOghWSZXTuD+fILRlFP2m1K/PKeRPFGad8G2i\nUS09ws3IH10tAKtd6VtrxTaXPgt9AhGC6uVEPWD4x7Ak841YfpuDc4ja8ef5hIvy\nYqpmveEpNQyatBJd4k4M6eSTuWC1CN79sWlAh0bKfBMhP8fR8ExJB+amLE8j+Dy4\nrX4rZX6muevqUsVT051mwXVCax4M57Z0e4j1edkIoILmDaB7ooCfBEmCwgtkovmt\nvb64D3P9usyjiPc8yn8iGgvubgzqFzFBoO9i5f5W9dlm4lH1wP7r5IysAMduB/ah\ncPLZFf2sA0ulGl2IBwYJmRNhQ3VSGKsjIjZsWhD9IKX7lmOIwfsA4woatFVp9gBY\nk8Mq7J6bhybjwfEnY1zsRT1QzAqHG5XMnDbLOVwv2Yb4obWyNyRGYZdkWliNVrdQ\ngHVIfeaFnZvLKmW1HHUU\n=0AvC\n-----END PGP SIGNATURE-----", "payload": "tree 4b719f3d9d1879f8cc54b872f3e44664636f6606\nparent 3b804942fdcc8858644218a570e034062021c7a4\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465556511 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465556511 +0200\n\nexpose a minimal API and use it in the binary"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c1713b89cacc7c86e7cf028f2206b309a6a152", "html_url": "https://github.com/rust-lang/rust/commit/b3c1713b89cacc7c86e7cf028f2206b309a6a152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3c1713b89cacc7c86e7cf028f2206b309a6a152/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b804942fdcc8858644218a570e034062021c7a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b804942fdcc8858644218a570e034062021c7a4", "html_url": "https://github.com/rust-lang/rust/commit/3b804942fdcc8858644218a570e034062021c7a4"}], "stats": {"total": 222, "additions": 127, "deletions": 95}, "files": [{"sha": "cec244a5c745aea5093a7b059acc34b9fda09992", "filename": "src/bin/miri.rs", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=b3c1713b89cacc7c86e7cf028f2206b309a6a152", "patch": "@@ -7,11 +7,21 @@ extern crate rustc;\n extern crate rustc_driver;\n extern crate env_logger;\n extern crate log_settings;\n-extern crate log;\n+extern crate syntax;\n+#[macro_use] extern crate log;\n \n-use miri::interpreter;\n+use miri::{\n+    GlobalEvalContext,\n+    CachedMir,\n+    step,\n+    EvalError,\n+    Frame,\n+};\n use rustc::session::Session;\n use rustc_driver::{driver, CompilerCalls};\n+use rustc::ty::{TyCtxt, subst};\n+use rustc::mir::mir_map::MirMap;\n+use rustc::hir::def_id::DefId;\n \n struct MiriCompilerCalls;\n \n@@ -25,13 +35,82 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n \n         control.after_analysis.callback = Box::new(|state| {\n             state.session.abort_if_errors();\n-            interpreter::interpret_start_points(state.tcx.unwrap(), state.mir_map.unwrap());\n+            interpret_start_points(state.tcx.unwrap(), state.mir_map.unwrap());\n         });\n \n         control\n     }\n }\n \n+\n+\n+fn interpret_start_points<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir_map: &MirMap<'tcx>,\n+) {\n+    let initial_indentation = ::log_settings::settings().indentation;\n+    for (&id, mir) in &mir_map.map {\n+        for attr in tcx.map.attrs(id) {\n+            use syntax::attr::AttrMetaMethods;\n+            if attr.check_name(\"miri_run\") {\n+                let item = tcx.map.expect_item(id);\n+\n+                ::log_settings::settings().indentation = initial_indentation;\n+\n+                debug!(\"Interpreting: {}\", item.name);\n+\n+                let mut gecx = GlobalEvalContext::new(tcx, mir_map);\n+                let substs = tcx.mk_substs(subst::Substs::empty());\n+                let return_ptr = gecx.alloc_ret_ptr(mir.return_ty, substs);\n+\n+                gecx.push_stack_frame(tcx.map.local_def_id(id), mir.span, CachedMir::Ref(mir), substs, return_ptr);\n+\n+                loop { match (step(&mut gecx), return_ptr) {\n+                    (Ok(true), _) => {},\n+                    (Ok(false), Some(ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n+                        gecx.memory().dump(ptr.alloc_id);\n+                        break;\n+                    },\n+                    (Ok(false), None) => {\n+                        warn!(\"diverging function returned\");\n+                        break;\n+                    },\n+                    // FIXME: diverging functions can end up here in some future miri\n+                    (Err(e), _) => {\n+                        report(tcx, &gecx, e);\n+                        break;\n+                    },\n+                } }\n+            }\n+        }\n+    }\n+}\n+\n+fn report(tcx: TyCtxt, gecx: &GlobalEvalContext, e: EvalError) {\n+    let frame = gecx.stack().last().expect(\"stackframe was empty\");\n+    let block = frame.mir.basic_block_data(frame.next_block);\n+    let span = if frame.stmt < block.statements.len() {\n+        block.statements[frame.stmt].span\n+    } else {\n+        block.terminator().span\n+    };\n+    let mut err = tcx.sess.struct_span_err(span, &e.to_string());\n+    for &Frame { def_id, substs, span, .. } in gecx.stack().iter().rev() {\n+        // FIXME(solson): Find a way to do this without this Display impl hack.\n+        use rustc::util::ppaux;\n+        use std::fmt;\n+        struct Instance<'tcx>(DefId, &'tcx subst::Substs<'tcx>);\n+        impl<'tcx> fmt::Display for Instance<'tcx> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n+                    |tcx| tcx.lookup_item_type(self.0).generics)\n+            }\n+        }\n+        err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n+    }\n+    err.emit();\n+}\n+\n #[miri_run]\n fn main() {\n     init_logger();"}, {"sha": "3b08a0ff62dec5a0e4df9db4677b92dd1f4b37cd", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 27, "deletions": 84, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=b3c1713b89cacc7c86e7cf028f2206b309a6a152", "patch": "@@ -24,6 +24,10 @@ use std::collections::HashMap;\n \n mod stepper;\n \n+pub fn step<'fncx, 'a: 'fncx, 'tcx: 'a>(gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>) -> EvalResult<bool> {\n+    stepper::Stepper::new(gecx).step()\n+}\n+\n pub struct GlobalEvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -45,38 +49,38 @@ pub struct GlobalEvalContext<'a, 'tcx: 'a> {\n }\n \n /// A stack frame.\n-struct Frame<'a, 'tcx: 'a> {\n+pub struct Frame<'a, 'tcx: 'a> {\n     /// The def_id of the current function\n-    def_id: DefId,\n+    pub def_id: DefId,\n \n     /// The span of the call site\n-    span: codemap::Span,\n+    pub span: codemap::Span,\n \n     /// type substitutions for the current function invocation\n-    substs: &'tcx Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n \n     /// The MIR for the function called on this frame.\n-    mir: CachedMir<'a, 'tcx>,\n+    pub mir: CachedMir<'a, 'tcx>,\n \n     /// The block that is currently executed (or will be executed after the above call stacks return)\n-    next_block: mir::BasicBlock,\n+    pub next_block: mir::BasicBlock,\n \n     /// A pointer for writing the return value of the current call if it's not a diverging call.\n-    return_ptr: Option<Pointer>,\n+    pub return_ptr: Option<Pointer>,\n \n     /// The list of locals for the current function, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The variables begin at `self.var_offset`\n     /// and the temporaries at `self.temp_offset`.\n-    locals: Vec<Pointer>,\n+    pub locals: Vec<Pointer>,\n \n     /// The offset of the first variable in `self.locals`.\n-    var_offset: usize,\n+    pub var_offset: usize,\n \n     /// The offset of the first temporary in `self.locals`.\n-    temp_offset: usize,\n+    pub temp_offset: usize,\n \n     /// The index of the currently evaluated statment\n-    stmt: usize,\n+    pub stmt: usize,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -94,7 +98,7 @@ enum LvalueExtra {\n }\n \n #[derive(Clone)]\n-enum CachedMir<'mir, 'tcx: 'mir> {\n+pub enum CachedMir<'mir, 'tcx: 'mir> {\n     Ref(&'mir mir::Mir<'tcx>),\n     Owned(Rc<mir::Mir<'tcx>>)\n }\n@@ -120,7 +124,7 @@ enum ConstantKind {\n }\n \n impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         GlobalEvalContext {\n             tcx: tcx,\n             mir_map: mir_map,\n@@ -135,7 +139,7 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n+    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n                 let size = self.type_size(ty, substs);\n@@ -145,6 +149,14 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub fn memory(&self) -> &Memory {\n+        &self.memory\n+    }\n+\n+    pub fn stack(&self) -> &[Frame] {\n+        &self.stack\n+    }\n+\n     // TODO(solson): Try making const_to_primval instead.\n     fn const_to_ptr(&mut self, const_val: &const_val::ConstVal) -> EvalResult<Pointer> {\n         use rustc::middle::const_val::ConstVal::*;\n@@ -308,34 +320,7 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n         })\n     }\n \n-    #[inline(never)]\n-    #[cold]\n-    fn report(&self, e: EvalError) {\n-        let stmt = self.frame().stmt;\n-        let block = self.basic_block();\n-        let span = if stmt < block.statements.len() {\n-            block.statements[stmt].span\n-        } else {\n-            block.terminator().span\n-        };\n-        let mut err = self.tcx.sess.struct_span_err(span, &e.to_string());\n-        for &Frame{ def_id, substs, span, .. } in self.stack.iter().rev() {\n-            // FIXME(solson): Find a way to do this without this Display impl hack.\n-            use rustc::util::ppaux;\n-            use std::fmt;\n-            struct Instance<'tcx>(DefId, &'tcx Substs<'tcx>);\n-            impl<'tcx> fmt::Display for Instance<'tcx> {\n-                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    ppaux::parameterized(f, self.1, self.0, ppaux::Ns::Value, &[],\n-                        |tcx| tcx.lookup_item_type(self.0).generics)\n-                }\n-            }\n-            err.span_note(span, &format!(\"inside call to {}\", Instance(def_id, substs)));\n-        }\n-        err.emit();\n-    }\n-\n-    fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n+    pub fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>)\n     {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n@@ -1387,48 +1372,6 @@ pub fn get_impl_method<'a, 'tcx>(\n     }\n }\n \n-pub fn interpret_start_points<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir_map: &MirMap<'tcx>,\n-) {\n-    let initial_indentation = ::log_settings::settings().indentation;\n-    for (&id, mir) in &mir_map.map {\n-        for attr in tcx.map.attrs(id) {\n-            use syntax::attr::AttrMetaMethods;\n-            if attr.check_name(\"miri_run\") {\n-                let item = tcx.map.expect_item(id);\n-\n-                ::log_settings::settings().indentation = initial_indentation;\n-\n-                debug!(\"Interpreting: {}\", item.name);\n-\n-                let mut gecx = GlobalEvalContext::new(tcx, mir_map);\n-                let substs = tcx.mk_substs(subst::Substs::empty());\n-                let return_ptr = gecx.alloc_ret_ptr(mir.return_ty, substs);\n-\n-                gecx.push_stack_frame(tcx.map.local_def_id(id), mir.span, CachedMir::Ref(mir), substs, return_ptr);\n-\n-                loop { match (stepper::step(&mut gecx), return_ptr) {\n-                    (Ok(true), _) => {},\n-                    (Ok(false), Some(ptr)) => if log_enabled!(::log::LogLevel::Debug) {\n-                        gecx.memory.dump(ptr.alloc_id);\n-                        break;\n-                    },\n-                    (Ok(false), None) => {\n-                        warn!(\"diverging function returned\");\n-                        break;\n-                    },\n-                    // FIXME: diverging functions can end up here in some future miri\n-                    (Err(e), _) => {\n-                        gecx.report(e);\n-                        break;\n-                    },\n-                } }\n-            }\n-        }\n-    }\n-}\n-\n // TODO(solson): Upstream these methods into rustc::ty::layout.\n \n trait IntegerExt {"}, {"sha": "942c913ccf9843c30bec50f9317e13731ad246b8", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=b3c1713b89cacc7c86e7cf028f2206b309a6a152", "patch": "@@ -12,16 +12,12 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use syntax::codemap::Span;\n use std::rc::Rc;\n \n-struct Stepper<'fncx, 'a: 'fncx, 'tcx: 'a>{\n+pub(super) struct Stepper<'fncx, 'a: 'fncx, 'tcx: 'a>{\n     gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>,\n }\n \n-pub fn step<'fncx, 'a: 'fncx, 'tcx: 'a>(gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>) -> EvalResult<bool> {\n-    Stepper::new(gecx).step()\n-}\n-\n impl<'fncx, 'a, 'tcx> Stepper<'fncx, 'a, 'tcx> {\n-    fn new(gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>) -> Self {\n+    pub(super) fn new(gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>) -> Self {\n         Stepper {\n             gecx: gecx,\n         }\n@@ -47,7 +43,7 @@ impl<'fncx, 'a, 'tcx> Stepper<'fncx, 'a, 'tcx> {\n     }\n \n     // returns true as long as there are more things to do\n-    fn step(&mut self) -> EvalResult<bool> {\n+    pub(super) fn step(&mut self) -> EvalResult<bool> {\n         if self.gecx.stack.is_empty() {\n             return Ok(false);\n         }"}, {"sha": "c5d74993dcc69982019f99faff971100286c296f", "filename": "src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c1713b89cacc7c86e7cf028f2206b309a6a152/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b3c1713b89cacc7c86e7cf028f2206b309a6a152", "patch": "@@ -20,6 +20,20 @@ extern crate log_settings;\n extern crate byteorder;\n \n mod error;\n-pub mod interpreter;\n+mod interpreter;\n mod memory;\n mod primval;\n+\n+pub use error::{\n+    EvalError,\n+    EvalResult,\n+};\n+\n+pub use interpreter::{\n+    GlobalEvalContext,\n+    step,\n+    Frame,\n+    CachedMir,\n+};\n+\n+pub use memory::Memory;"}]}