{"sha": "73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYTFkZDhlN2YxMGYxYzZjYmE2MThiNjBlM2ZlZDY5MGE3MmE4ZDc=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-10-08T18:14:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-08T18:14:55Z"}, "message": "Merge pull request #2117 from sinkuu/improve_take_by_value\n\nImprove needless_pass_by_value", "tree": {"sha": "6925a63d10590420149572243b17caaab364698a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6925a63d10590420149572243b17caaab364698a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "html_url": "https://github.com/rust-lang/rust/commit/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18483f89aad75500489b645abc02a8ae5c2e303b", "url": "https://api.github.com/repos/rust-lang/rust/commits/18483f89aad75500489b645abc02a8ae5c2e303b", "html_url": "https://github.com/rust-lang/rust/commit/18483f89aad75500489b645abc02a8ae5c2e303b"}, {"sha": "8ffec33fd3017b9e7e41f5c8a0b857fca7df9349", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ffec33fd3017b9e7e41f5c8a0b857fca7df9349", "html_url": "https://github.com/rust-lang/rust/commit/8ffec33fd3017b9e7e41f5c8a0b857fca7df9349"}], "stats": {"total": 440, "additions": 293, "deletions": 147}, "files": [{"sha": "3c1f6ef2c4bc64e89cbcd902bb1b0e92303c8e5a", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 108, "deletions": 53, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "patch": "@@ -1,16 +1,18 @@\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, RegionKind, TypeFoldable};\n use rustc::traits;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n use syntax::errors::DiagnosticBuilder;\n use utils::{get_trait_def_id, implements_trait, in_macro, is_copy, is_self, match_type, multispan_sugg, paths,\n-            snippet, span_lint_and_then};\n+            snippet, snippet_opt, span_lint_and_then};\n+use utils::ptr::get_spans;\n use std::collections::{HashMap, HashSet};\n+use std::borrow::Cow;\n \n /// **What it does:** Checks for functions taking arguments by value, but not\n /// consuming them in its\n@@ -73,18 +75,29 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n             _ => return,\n         }\n \n-        // Allows these to be passed by value.\n-        let fn_trait = need!(cx.tcx.lang_items().fn_trait());\n-        let asref_trait = need!(get_trait_def_id(cx, &paths::ASREF_TRAIT));\n+        // Allow `Borrow` or functions to be taken by value\n         let borrow_trait = need!(get_trait_def_id(cx, &paths::BORROW_TRAIT));\n+        let fn_traits = [\n+            need!(cx.tcx.lang_items().fn_trait()),\n+            need!(cx.tcx.lang_items().fn_once_trait()),\n+            need!(cx.tcx.lang_items().fn_mut_trait()),\n+        ];\n+\n+        let sized_trait = need!(cx.tcx.lang_items().sized_trait());\n \n         let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n \n-        let preds: Vec<ty::Predicate> = {\n-            traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n-                .filter(|p| !p.is_global())\n-                .collect()\n-        };\n+        let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds.to_vec())\n+            .filter(|p| !p.is_global())\n+            .filter_map(|pred| if let ty::Predicate::Trait(poly_trait_ref) = pred {\n+                if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_regions() {\n+                    return None;\n+                }\n+                Some(poly_trait_ref)\n+            } else {\n+                None\n+            })\n+            .collect::<Vec<_>>();\n \n         // Collect moved variables and spans which will need dereferencings from the\n         // function body.\n@@ -102,45 +115,56 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n-        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n-            // Determines whether `ty` implements `Borrow<U>` (U != ty) specifically.\n-            // This is needed due to the `Borrow<T> for T` blanket impl.\n-            let implements_borrow_trait = preds\n-                .iter()\n-                .filter_map(|pred| if let ty::Predicate::Trait(ref poly_trait_ref) = *pred {\n-                    Some(poly_trait_ref.skip_binder())\n-                } else {\n-                    None\n-                })\n-                .filter(|tpred| tpred.def_id() == borrow_trait && tpred.self_ty() == ty)\n-                .any(|tpred| {\n-                    tpred\n-                        .input_types()\n-                        .nth(1)\n-                        .expect(\"Borrow trait must have an parameter\") != ty\n-                });\n+        for (idx, ((input, &ty), arg)) in decl.inputs\n+            .iter()\n+            .zip(fn_sig.inputs())\n+            .zip(&body.arguments)\n+            .enumerate()\n+        {\n+            // * Exclude a type that is specifically bounded by `Borrow`.\n+            // * Exclude a type whose reference also fulfills its bound.\n+            //   (e.g. `std::convert::AsRef`, `serde::Serialize`)\n+            let (implements_borrow_trait, all_borrowable_trait) = {\n+                let preds = preds\n+                    .iter()\n+                    .filter(|t| t.skip_binder().self_ty() == ty)\n+                    .collect::<Vec<_>>();\n+\n+                (\n+                    preds.iter().any(|t| t.def_id() == borrow_trait),\n+                    !preds.is_empty() && preds.iter().all(|t| {\n+                        implements_trait(\n+                            cx,\n+                            cx.tcx.mk_imm_ref(&RegionKind::ReErased, ty),\n+                            t.def_id(),\n+                            &t.skip_binder().input_types().skip(1).collect::<Vec<_>>(),\n+                        )\n+                    }),\n+                )\n+            };\n \n             if_let_chain! {[\n                 !is_self(arg),\n                 !ty.is_mutable_pointer(),\n                 !is_copy(cx, ty),\n-                !implements_trait(cx, ty, fn_trait, &[]),\n-                !implements_trait(cx, ty, asref_trait, &[]),\n+                !fn_traits.iter().any(|&t| implements_trait(cx, ty, t, &[])),\n                 !implements_borrow_trait,\n+                !all_borrowable_trait,\n \n                 let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node,\n                 !moved_vars.contains(&canonical_id),\n             ], {\n-                // Note: `toplevel_ref_arg` warns if `BindByRef`\n                 if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n                     continue;\n                 }\n \n-                // Suggestion logic\n+                // Dereference suggestion\n                 let sugg = |db: &mut DiagnosticBuilder| {\n                     let deref_span = spans_need_deref.get(&canonical_id);\n                     if_let_chain! {[\n                         match_type(cx, ty, &paths::VEC),\n+                        let Some(clone_spans) =\n+                            get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n                         let Some(elem_ty) = path.segments.iter()\n                             .find(|seg| seg.name == \"Vec\")\n@@ -151,34 +175,68 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                         db.span_suggestion(input.span,\n                                         \"consider changing the type to\",\n                                         slice_ty);\n+\n+                        for (span, suggestion) in clone_spans {\n+                            db.span_suggestion(\n+                                span,\n+                                &snippet_opt(cx, span)\n+                                    .map_or(\n+                                        \"change the call to\".into(),\n+                                        |x| Cow::from(format!(\"change `{}` to\", x)),\n+                                    ),\n+                                suggestion.into()\n+                            );\n+                        }\n+\n+                        // cannot be destructured, no need for `*` suggestion\n                         assert!(deref_span.is_none());\n-                        return; // `Vec` and `String` cannot be destructured - no need for `*` suggestion\n+                        return;\n                     }}\n \n                     if match_type(cx, ty, &paths::STRING) {\n-                        db.span_suggestion(input.span,\n-                                           \"consider changing the type to\",\n-                                           \"&str\".to_string());\n-                        assert!(deref_span.is_none());\n-                        return;\n+                        if let Some(clone_spans) =\n+                            get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n+                            db.span_suggestion(input.span, \"consider changing the type to\", \"&str\".to_string());\n+\n+                            for (span, suggestion) in clone_spans {\n+                                db.span_suggestion(\n+                                    span,\n+                                    &snippet_opt(cx, span)\n+                                        .map_or(\n+                                            \"change the call to\".into(),\n+                                            |x| Cow::from(format!(\"change `{}` to\", x))\n+                                        ),\n+                                    suggestion.into(),\n+                                );\n+                            }\n+\n+                            assert!(deref_span.is_none());\n+                            return;\n+                        }\n                     }\n \n                     let mut spans = vec![(input.span, format!(\"&{}\", snippet(cx, input.span, \"_\")))];\n \n                     // Suggests adding `*` to dereference the added reference.\n                     if let Some(deref_span) = deref_span {\n-                        spans.extend(deref_span.iter().cloned()\n-                                     .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))));\n+                        spans.extend(\n+                            deref_span\n+                                .iter()\n+                                .cloned()\n+                                .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))),\n+                        );\n                         spans.sort_by_key(|&(span, _)| span);\n                     }\n                     multispan_sugg(db, \"consider taking a reference instead\".to_string(), spans);\n                 };\n \n-                span_lint_and_then(cx,\n-                          NEEDLESS_PASS_BY_VALUE,\n-                          input.span,\n-                          \"this argument is passed by value, but not consumed in the function body\",\n-                          sugg);\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_PASS_BY_VALUE,\n+                    input.span,\n+                    \"this argument is passed by value, but not consumed in the function body\",\n+                    sugg,\n+                );\n             }}\n         }\n     }\n@@ -188,8 +246,7 @@ struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     moved_vars: HashSet<NodeId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n-    /// suggested additional\n-    /// reference.\n+    /// suggested additional reference.\n     spans_need_deref: HashMap<NodeId, HashSet<Span>>,\n }\n \n@@ -213,9 +270,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n     fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n-        if_let_chain! {[\n-            let mc::Categorization::Local(vid) = cmt.cat,\n-        ], {\n+        if let mc::Categorization::Local(vid) = cmt.cat {\n             let mut id = matched_pat.id;\n             loop {\n                 let parent = self.cx.tcx.hir.get_parent_node(id);\n@@ -235,7 +290,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                                     .or_insert_with(HashSet::new)\n                                     .insert(c.span);\n                             }\n-                        }\n+                        },\n \n                         map::Node::NodeStmt(s) => {\n                             // `let <pat> = x;`\n@@ -251,13 +306,13 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                                         .map(|e| e.span)\n                                         .expect(\"`let` stmt without init aren't caught by match_pat\"));\n                             }}\n-                        }\n+                        },\n \n-                        _ => {}\n+                        _ => {},\n                     }\n                 }\n             }\n-        }}\n+        }\n     }\n }\n "}, {"sha": "8f42750e19b12935b8e50467f84a3b3eecb27417", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "patch": "@@ -2,16 +2,15 @@\n \n use std::borrow::Cow;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax_pos::MultiSpan;\n-use utils::{get_pat_name, match_qpath, match_type, match_var, paths,\n-            snippet, snippet_opt, span_lint, span_lint_and_then,\n+use utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then,\n             walk_ptrs_hir_ty};\n+use utils::ptr::get_spans;\n \n /// **What it does:** This lint checks for function arguments of type `&String`\n /// or `&Vec` unless the references are mutable. It will also suggest you\n@@ -164,7 +163,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 ], {\n                     ty_snippet = snippet_opt(cx, parameters.types[0].span);\n                 });\n-                if let Ok(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n+                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n                     span_lint_and_then(\n                         cx,\n                         PTR_ARG,\n@@ -187,7 +186,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                     );\n                 }\n             } else if match_type(cx, ty, &paths::STRING) {\n-                if let Ok(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n+                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                     span_lint_and_then(\n                         cx,\n                         PTR_ARG,\n@@ -234,66 +233,6 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n     }\n }\n \n-fn get_spans(cx: &LateContext, opt_body_id: Option<BodyId>, idx: usize, replacements: &'static [(&'static str, &'static str)]) -> Result<Vec<(Span, Cow<'static, str>)>, ()> {\n-    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n-        get_binding_name(&body.arguments[idx]).map_or_else(|| Ok(vec![]),\n-                                                |name| extract_clone_suggestions(cx, name, replacements, body))\n-    } else {\n-        Ok(vec![])\n-    }\n-}\n-\n-fn extract_clone_suggestions<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, name: Name, replace: &'static [(&'static str, &'static str)], body: &'tcx Body) -> Result<Vec<(Span, Cow<'static, str>)>, ()> {\n-    let mut visitor = PtrCloneVisitor {\n-        cx,\n-        name,\n-        replace,\n-        spans: vec![],\n-        abort: false,\n-    };\n-    visitor.visit_body(body);\n-    if visitor.abort { Err(()) } else { Ok(visitor.spans) }\n-}\n-\n-struct PtrCloneVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,\n-    name: Name,\n-    replace: &'static [(&'static str, &'static str)],\n-    spans: Vec<(Span, Cow<'static, str>)>,\n-    abort: bool,\n-}\n-\n-impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if self.abort { return; }\n-        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n-            if args.len() == 1 && match_var(&args[0], self.name) {\n-                if seg.name == \"capacity\" {\n-                    self.abort = true;\n-                    return;\n-                }\n-                for &(fn_name, suffix) in self.replace {\n-                    if seg.name == fn_name {\n-                        self.spans.push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n-                        return;\n-                    }\n-                }\n-            }\n-            return;\n-        }\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-}\n-\n-fn get_binding_name(arg: &Arg) -> Option<Name> {\n-    get_pat_name(&arg.pat)\n-}\n-\n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n     if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n         Some((lt, m.mutbl, ty.span))"}, {"sha": "240301708b7ad146b2d81996ad4ed9c4724c6583", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "patch": "@@ -32,6 +32,7 @@ pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n pub mod author;\n+pub mod ptr;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;"}, {"sha": "7782fb8bc76bf2ee36da3ea13391b3a4ddae365c", "filename": "clippy_lints/src/utils/ptr.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "patch": "@@ -0,0 +1,83 @@\n+use std::borrow::Cow;\n+use rustc::hir::*;\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc::lint::LateContext;\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n+use utils::{get_pat_name, match_var, snippet};\n+\n+pub fn get_spans(\n+    cx: &LateContext,\n+    opt_body_id: Option<BodyId>,\n+    idx: usize,\n+    replacements: &'static [(&'static str, &'static str)],\n+) -> Option<Vec<(Span, Cow<'static, str>)>> {\n+    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n+        get_binding_name(&body.arguments[idx])\n+            .map_or_else(|| Some(vec![]), |name| extract_clone_suggestions(cx, name, replacements, body))\n+    } else {\n+        Some(vec![])\n+    }\n+}\n+\n+fn extract_clone_suggestions<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    name: Name,\n+    replace: &'static [(&'static str, &'static str)],\n+    body: &'tcx Body,\n+) -> Option<Vec<(Span, Cow<'static, str>)>> {\n+    let mut visitor = PtrCloneVisitor {\n+        cx,\n+        name,\n+        replace,\n+        spans: vec![],\n+        abort: false,\n+    };\n+    visitor.visit_body(body);\n+    if visitor.abort {\n+        None\n+    } else {\n+        Some(visitor.spans)\n+    }\n+}\n+\n+struct PtrCloneVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    name: Name,\n+    replace: &'static [(&'static str, &'static str)],\n+    spans: Vec<(Span, Cow<'static, str>)>,\n+    abort: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if self.abort {\n+            return;\n+        }\n+        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n+            if args.len() == 1 && match_var(&args[0], self.name) {\n+                if seg.name == \"capacity\" {\n+                    self.abort = true;\n+                    return;\n+                }\n+                for &(fn_name, suffix) in self.replace {\n+                    if seg.name == fn_name {\n+                        self.spans\n+                            .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n+                        return;\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn get_binding_name(arg: &Arg) -> Option<Name> {\n+    get_pat_name(&arg.pat)\n+}"}, {"sha": "ac37b0bdda16860c071194326867513dde52beaa", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "patch": "@@ -4,6 +4,9 @@\n #![warn(needless_pass_by_value)]\n #![allow(dead_code, single_match, if_let_redundant_pattern_matching, many_single_char_names)]\n \n+use std::borrow::Borrow;\n+use std::convert::AsRef;\n+\n // `v` should be warned\n // `w`, `x` and `y` are allowed (moved or mutated)\n fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n@@ -25,10 +28,11 @@ fn bar(x: String, y: Wrapper) {\n     assert_eq!(y.0.len(), 42);\n }\n \n-// U implements `Borrow<U>`, but should be warned correctly\n-fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n+// V implements `Borrow<V>`, but should be warned correctly\n+fn test_borrow_trait<T: Borrow<str>, U: AsRef<str>, V>(t: T, u: U, v: V) {\n     println!(\"{}\", t.borrow());\n-    consume(&u);\n+    println!(\"{}\", u.as_ref());\n+    consume(&v);\n }\n \n // ok\n@@ -59,4 +63,20 @@ fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n     println!(\"{}\", t);\n }\n \n+trait Foo {}\n+\n+// `S: Serialize` can be passed by value\n+trait Serialize {}\n+impl<'a, T> Serialize for &'a T where T: Serialize {}\n+impl Serialize for i32 {}\n+\n+fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n+\n+fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+    s.capacity();\n+    let _ = t.clone();\n+    u.capacity();\n+    let _ = v.clone();\n+}\n+\n fn main() {}"}, {"sha": "f23b0714c599e4cb2c9dad11edae45116f96f158", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=73a1dd8e7f10f1c6cba618b60e3fed690a72a8d7", "patch": "@@ -1,58 +1,106 @@\n error: this argument is passed by value, but not consumed in the function body\n- --> $DIR/needless_pass_by_value.rs:9:23\n-  |\n-9 | fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n-  |                       ^^^^^^ help: consider changing the type to: `&[T]`\n-  |\n-  = note: `-D needless-pass-by-value` implied by `-D warnings`\n+  --> $DIR/needless_pass_by_value.rs:12:23\n+   |\n+12 | fn foo<T: Default>(v: Vec<T>, w: Vec<T>, mut x: Vec<T>, y: Vec<T>) -> Vec<T> {\n+   |                       ^^^^^^ help: consider changing the type to: `&[T]`\n+   |\n+   = note: `-D needless-pass-by-value` implied by `-D warnings`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:23:11\n+  --> $DIR/needless_pass_by_value.rs:26:11\n    |\n-23 | fn bar(x: String, y: Wrapper) {\n+26 | fn bar(x: String, y: Wrapper) {\n    |           ^^^^^^ help: consider changing the type to: `&str`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:23:22\n+  --> $DIR/needless_pass_by_value.rs:26:22\n    |\n-23 | fn bar(x: String, y: Wrapper) {\n+26 | fn bar(x: String, y: Wrapper) {\n    |                      ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:29:63\n+  --> $DIR/needless_pass_by_value.rs:32:71\n    |\n-29 | fn test_borrow_trait<T: std::borrow::Borrow<str>, U>(t: T, u: U) {\n-   |                                                               ^ help: consider taking a reference instead: `&U`\n+32 | fn test_borrow_trait<T: Borrow<str>, U: AsRef<str>, V>(t: T, u: U, v: V) {\n+   |                                                                       ^ help: consider taking a reference instead: `&V`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:40:18\n+  --> $DIR/needless_pass_by_value.rs:44:18\n    |\n-40 | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n+44 | fn test_match(x: Option<Option<String>>, y: Option<Option<String>>) {\n    |                  ^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: consider taking a reference instead\n    |\n-40 | fn test_match(x: &Option<Option<String>>, y: Option<Option<String>>) {\n-41 |     match *x {\n+44 | fn test_match(x: &Option<Option<String>>, y: Option<Option<String>>) {\n+45 |     match *x {\n    |\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:53:24\n+  --> $DIR/needless_pass_by_value.rs:57:24\n    |\n-53 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n+57 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                        ^^^^^^^ help: consider taking a reference instead: `&Wrapper`\n \n error: this argument is passed by value, but not consumed in the function body\n-  --> $DIR/needless_pass_by_value.rs:53:36\n+  --> $DIR/needless_pass_by_value.rs:57:36\n    |\n-53 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n+57 | fn test_destructure(x: Wrapper, y: Wrapper, z: Wrapper) {\n    |                                    ^^^^^^^\n    |\n help: consider taking a reference instead\n    |\n-53 | fn test_destructure(x: Wrapper, y: &Wrapper, z: Wrapper) {\n-54 |     let Wrapper(s) = z; // moved\n-55 |     let Wrapper(ref t) = *y; // not moved\n-56 |     let Wrapper(_) = *y; // still not moved\n+57 | fn test_destructure(x: Wrapper, y: &Wrapper, z: Wrapper) {\n+58 |     let Wrapper(s) = z; // moved\n+59 |     let Wrapper(ref t) = *y; // not moved\n+60 |     let Wrapper(_) = *y; // still not moved\n+   |\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:73:49\n+   |\n+73 | fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n+   |                                                 ^ help: consider taking a reference instead: `&T`\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:18\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                  ^^^^^^ help: consider taking a reference instead: `&String`\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:29\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                             ^^^^^^\n+   |\n+help: consider changing the type to\n+   |\n+75 | fn issue_2114(s: String, t: &str, u: Vec<i32>, v: Vec<i32>) {\n+   |                             ^^^^\n+help: change `t.clone()` to\n+   |\n+77 |     let _ = t.to_string();\n+   |             ^^^^^^^^^^^^^\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:40\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                                        ^^^^^^^^ help: consider taking a reference instead: `&Vec<i32>`\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:53\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                                                     ^^^^^^^^\n+   |\n+help: consider changing the type to\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: &[i32]) {\n+   |                                                     ^^^^^^\n+help: change `v.clone()` to\n    |\n+79 |     let _ = v.to_owned();\n+   |             ^^^^^^^^^^^^\n "}]}