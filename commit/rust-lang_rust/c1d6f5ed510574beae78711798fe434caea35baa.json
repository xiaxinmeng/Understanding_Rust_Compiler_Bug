{"sha": "c1d6f5ed510574beae78711798fe434caea35baa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZDZmNWVkNTEwNTc0YmVhZTc4NzExNzk4ZmU0MzRjYWVhMzViYWE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-31T01:32:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:02:00Z"}, "message": "libextra: De-`@mut` the arena", "tree": {"sha": "6237810dc9107f76263282f3e734975d72d24bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6237810dc9107f76263282f3e734975d72d24bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d6f5ed510574beae78711798fe434caea35baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d6f5ed510574beae78711798fe434caea35baa", "html_url": "https://github.com/rust-lang/rust/commit/c1d6f5ed510574beae78711798fe434caea35baa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d6f5ed510574beae78711798fe434caea35baa/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38456a92f81442093be2a7658742ecca96d0f84", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38456a92f81442093be2a7658742ecca96d0f84", "html_url": "https://github.com/rust-lang/rust/commit/c38456a92f81442093be2a7658742ecca96d0f84"}], "stats": {"total": 61, "additions": 34, "deletions": 27}, "files": [{"sha": "5ee0099561a21945369b7f78f36bbff44f315d88", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c1d6f5ed510574beae78711798fe434caea35baa/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d6f5ed510574beae78711798fe434caea35baa/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=c1d6f5ed510574beae78711798fe434caea35baa", "patch": "@@ -35,11 +35,13 @@\n #[allow(missing_doc)];\n \n \n-use list::{MutList, MutCons, MutNil};\n+use list::{List, Cons, Nil};\n+use list;\n \n use std::at_vec;\n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n+use std::cell::{Cell, RefCell};\n use std::num;\n use std::ptr;\n use std::mem;\n@@ -50,10 +52,11 @@ use std::unstable::intrinsics::{TyDesc, get_tydesc};\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n+#[deriving(Clone)]\n struct Chunk {\n-    data: @[u8],\n-    fill: uint,\n-    is_pod: bool,\n+    data: RefCell<@[u8]>,\n+    fill: Cell<uint>,\n+    is_pod: Cell<bool>,\n }\n \n #[no_freeze]\n@@ -63,7 +66,7 @@ pub struct Arena {\n     // access the head.\n     priv head: Chunk,\n     priv pod_head: Chunk,\n-    priv chunks: @mut MutList<Chunk>,\n+    priv chunks: RefCell<@List<Chunk>>,\n }\n \n impl Arena {\n@@ -75,7 +78,7 @@ impl Arena {\n         Arena {\n             head: chunk(initial_size, false),\n             pod_head: chunk(initial_size, true),\n-            chunks: @mut MutNil,\n+            chunks: RefCell::new(@Nil),\n         }\n     }\n }\n@@ -84,9 +87,9 @@ fn chunk(size: uint, is_pod: bool) -> Chunk {\n     let mut v: @[u8] = @[];\n     unsafe { at_vec::raw::reserve(&mut v, size); }\n     Chunk {\n-        data: unsafe { cast::transmute(v) },\n-        fill: 0u,\n-        is_pod: is_pod,\n+        data: RefCell::new(unsafe { cast::transmute(v) }),\n+        fill: Cell::new(0u),\n+        is_pod: Cell::new(is_pod),\n     }\n }\n \n@@ -95,8 +98,9 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-            self.chunks.each(|chunk| {\n-                if !chunk.is_pod {\n+\n+            list::each(self.chunks.get(), |chunk| {\n+                if !chunk.is_pod.get() {\n                     destroy_chunk(chunk);\n                 }\n                 true\n@@ -114,8 +118,11 @@ fn round_up_to(base: uint, align: uint) -> uint {\n // in it.\n unsafe fn destroy_chunk(chunk: &Chunk) {\n     let mut idx = 0;\n-    let buf = chunk.data.as_ptr();\n-    let fill = chunk.fill;\n+    let buf = {\n+        let data = chunk.data.borrow();\n+        data.get().as_ptr()\n+    };\n+    let fill = chunk.fill.get();\n \n     while idx < fill {\n         let tydesc_data: *uint = transmute(ptr::offset(buf, idx as int));\n@@ -155,9 +162,9 @@ impl Arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.pod_head.data);\n+        let chunk_size = at_vec::capacity(self.pod_head.data.get());\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n-        self.chunks = @mut MutCons(self.pod_head, self.chunks);\n+        self.chunks.set(@Cons(self.pod_head.clone(), self.chunks.get()));\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n \n@@ -168,17 +175,17 @@ impl Arena {\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n             let this = transmute_mut_region(self);\n-            let start = round_up_to(this.pod_head.fill, align);\n+            let start = round_up_to(this.pod_head.fill.get(), align);\n             let end = start + n_bytes;\n-            if end > at_vec::capacity(this.pod_head.data) {\n+            if end > at_vec::capacity(this.pod_head.data.get()) {\n                 return this.alloc_pod_grow(n_bytes, align);\n             }\n-            this.pod_head.fill = end;\n+            this.pod_head.fill.set(end);\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n-            //       start, n_bytes, align, head.fill);\n+            //       start, n_bytes, align, head.fill.get());\n \n-            ptr::offset(this.pod_head.data.as_ptr(), start as int)\n+            ptr::offset(this.pod_head.data.get().as_ptr(), start as int)\n         }\n     }\n \n@@ -197,9 +204,9 @@ impl Arena {\n     fn alloc_nonpod_grow(&mut self, n_bytes: uint, align: uint)\n                          -> (*u8, *u8) {\n         // Allocate a new chunk.\n-        let chunk_size = at_vec::capacity(self.head.data);\n+        let chunk_size = at_vec::capacity(self.head.data.get());\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n-        self.chunks = @mut MutCons(self.head, self.chunks);\n+        self.chunks.set(@Cons(self.head.clone(), self.chunks.get()));\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n \n@@ -218,23 +225,23 @@ impl Arena {\n             {\n                 let head = transmute_mut_region(&mut self.head);\n \n-                tydesc_start = head.fill;\n-                after_tydesc = head.fill + mem::size_of::<*TyDesc>();\n+                tydesc_start = head.fill.get();\n+                after_tydesc = head.fill.get() + mem::size_of::<*TyDesc>();\n                 start = round_up_to(after_tydesc, align);\n                 end = start + n_bytes;\n             }\n \n-            if end > at_vec::capacity(self.head.data) {\n+            if end > at_vec::capacity(self.head.data.get()) {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n \n             let head = transmute_mut_region(&mut self.head);\n-            head.fill = round_up_to(end, mem::pref_align_of::<*TyDesc>());\n+            head.fill.set(round_up_to(end, mem::pref_align_of::<*TyDesc>()));\n \n             //debug!(\"idx = {}, size = {}, align = {}, fill = {}\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = self.head.data.as_ptr();\n+            let buf = self.head.data.get().as_ptr();\n             return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }"}]}