{"sha": "cf30759a8409bee031ac252ee207452ab4804467", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMzA3NTlhODQwOWJlZTAzMWFjMjUyZWUyMDc0NTJhYjQ4MDQ0Njc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-06T18:30:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-06T18:30:15Z"}, "message": "Auto merge of #46268 - arielb1:union-borrow, r=nikomatsakis\n\nMIR borrowck: implement union-and-array-compatible semantics\n\nFixes #44831.\nFixes #44834.\nFixes #45537.\nFixes #45696 (by implementing DerefPure semantics, which is what we want going forward).\n\nr? @nikomatsakis", "tree": {"sha": "2365481701689ab3b4fe5065389c553ee0139271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2365481701689ab3b4fe5065389c553ee0139271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf30759a8409bee031ac252ee207452ab4804467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf30759a8409bee031ac252ee207452ab4804467", "html_url": "https://github.com/rust-lang/rust/commit/cf30759a8409bee031ac252ee207452ab4804467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf30759a8409bee031ac252ee207452ab4804467/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "833785b090c30d4a359d901fb41bfafbe1607ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/833785b090c30d4a359d901fb41bfafbe1607ce9", "html_url": "https://github.com/rust-lang/rust/commit/833785b090c30d4a359d901fb41bfafbe1607ce9"}, {"sha": "9d3558725b9110beaa6740e88847e3addc9c2d0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d3558725b9110beaa6740e88847e3addc9c2d0d", "html_url": "https://github.com/rust-lang/rust/commit/9d3558725b9110beaa6740e88847e3addc9c2d0d"}], "stats": {"total": 784, "additions": 608, "deletions": 176}, "files": [{"sha": "93cfc845b1f3497db950ce23741104f717fd3ffa", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -1084,9 +1084,11 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     pub fn map<U: ?Sized, F>(orig: RefMut<'b, T>, f: F) -> RefMut<'b, U>\n         where F: FnOnce(&mut T) -> &mut U\n     {\n+        // FIXME(nll-rfc#40): fix borrow-check\n+        let RefMut { value, borrow } = orig;\n         RefMut {\n-            value: f(orig.value),\n-            borrow: orig.borrow,\n+            value: f(value),\n+            borrow: borrow,\n         }\n     }\n }"}, {"sha": "06c29b47bf9217db2fe131db59099d0f807e6fc8", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -1776,12 +1776,18 @@ impl<I: Iterator> Iterator for Peekable<I> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            // the .take() below is just to avoid \"move into pattern guard\"\n-            Some(ref mut v) if n == 0 => v.take(),\n-            Some(None) => None,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n+        // FIXME(#6393): merge these when borrow-checking gets better.\n+        if n == 0 {\n+            match self.peeked.take() {\n+                Some(v) => v,\n+                None => self.iter.nth(n),\n+            }\n+        } else {\n+            match self.peeked.take() {\n+                Some(None) => None,\n+                Some(Some(_)) => self.iter.nth(n - 1),\n+                None => self.iter.nth(n),\n+            }\n         }\n     }\n "}, {"sha": "8d3491bd1d988a211251c94932408e640e3d08b2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 428, "deletions": 85, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -12,6 +12,7 @@\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::maps::Providers;\n@@ -36,6 +37,9 @@ use dataflow::move_paths::{IllegalMoveOriginKind, MoveError};\n use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveOutIndex, MovePathIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n+use std::fmt;\n+use std::iter;\n+\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n pub(crate) mod nll;\n@@ -128,6 +132,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         move_data: move_data,\n         param_env: param_env,\n     };\n+    let body_id = match tcx.def_key(def_id).disambiguated_data.data {\n+        DefPathData::StructCtor |\n+        DefPathData::EnumVariant(_) => None,\n+        _ => Some(tcx.hir.body_owned_by(id))\n+    };\n+\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowInProgress::new(do_dataflow(\n         tcx,\n@@ -189,6 +199,11 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         node_id: id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n+        locals_are_invalidated_at_exit: match tcx.hir.body_owner_kind(id) {\n+            hir::BodyOwnerKind::Const |\n+            hir::BodyOwnerKind::Static(_) => false,\n+            hir::BodyOwnerKind::Fn => true,\n+        },\n         storage_dead_or_drop_error_reported: FxHashSet(),\n     };\n \n@@ -198,7 +213,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, mir, opt_regioncx),\n+        Borrows::new(tcx, mir, opt_regioncx, def_id, body_id),\n         |bd, i| bd.location(i),\n     ));\n \n@@ -220,6 +235,13 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     node_id: ast::NodeId,\n     move_data: &'cx MoveData<'tcx>,\n     param_env: ParamEnv<'gcx>,\n+    /// This keeps track of whether local variables are free-ed when the function\n+    /// exits even without a `StorageDead`, which appears to be the case for\n+    /// constants.\n+    ///\n+    /// I'm not sure this is the right approach - @eddyb could you try and\n+    /// figure this out?\n+    locals_are_invalidated_at_exit: bool,\n     /// This field keeps track of when storage dead or drop errors are reported\n     /// in order to stop duplicate error reporting and identify the conditions required\n     /// for a \"temporary value dropped here while still borrowed\" error. See #45360.\n@@ -306,8 +328,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n-        let summary = flow_state.summary();\n-        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n+        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, flow_state);\n     }\n \n     fn visit_statement_entry(\n@@ -316,12 +337,11 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         stmt: &Statement<'tcx>,\n         flow_state: &Self::FlowState,\n     ) {\n-        let summary = flow_state.summary();\n         debug!(\n             \"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\",\n             location,\n             stmt,\n-            summary\n+            flow_state\n         );\n         let span = stmt.source_info.span;\n         match stmt.kind {\n@@ -423,12 +443,11 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         flow_state: &Self::FlowState,\n     ) {\n         let loc = location;\n-        let summary = flow_state.summary();\n         debug!(\n             \"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\",\n             location,\n             term,\n-            summary\n+            flow_state\n         );\n         let span = term.source_info.span;\n         match term.kind {\n@@ -540,14 +559,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n                         if self.place_is_invalidated_at_exit(&borrow.place) {\n                             debug!(\"borrow conflicts at exit {:?}\", borrow);\n-                            let borrow_span = self.mir.source_info(borrow.location).span;\n                             // FIXME: should be talking about the region lifetime instead\n                             // of just a span here.\n                             let end_span = domain.opt_region_end_span(&borrow.region);\n \n                             self.report_borrowed_value_does_not_live_long_enough(\n                                 ContextKind::StorageDead.new(loc),\n-                                (&borrow.place, borrow_span),\n+                            (&borrow.place, end_span.unwrap_or(span)),\n                                 end_span,\n                             )\n                         }\n@@ -641,8 +659,9 @@ enum WriteKind {\n /// - Take flow state into consideration in `is_assignable()` for local variables\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LocalMutationIsAllowed {\n+    Move,\n     Yes,\n-    No,\n+    No\n }\n \n #[derive(Copy, Clone)]\n@@ -710,7 +729,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context,\n             (sd, place_span.0),\n             flow_state,\n-            |this, _index, borrow, common_prefix| match (rw, borrow.kind) {\n+            |this, _index, borrow| match (rw, borrow.kind) {\n                 (Read(_), BorrowKind::Shared) => Control::Continue,\n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut) => {\n                     match kind {\n@@ -727,7 +746,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n-                                common_prefix,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n@@ -748,7 +766,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             error_reported = true;\n                             this.report_conflicting_borrow(\n                                 context,\n-                                common_prefix,\n                                 place_span,\n                                 bk,\n                                 &borrow,\n@@ -934,7 +951,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     context,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n-                    LocalMutationIsAllowed::Yes,\n+                    LocalMutationIsAllowed::Move,\n                     flow_state,\n                 );\n \n@@ -952,14 +969,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns whether a borrow of this place is invalidated when the function\n     /// exits\n-    fn place_is_invalidated_at_exit(&self, place: &Place<'tcx>) -> bool {\n+    fn place_is_invalidated_at_exit(&mut self, place: &Place<'tcx>) -> bool {\n         debug!(\"place_is_invalidated_at_exit({:?})\", place);\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n-        let (might_be_alive, will_be_dropped) = match root_place {\n+        //\n+        // FIXME: allow thread-locals to borrow other thread locals?\n+        let (might_be_alive, will_be_dropped, local) = match root_place {\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n@@ -968,12 +987,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .iter()\n                     .any(|attr| attr.check_name(\"thread_local\"));\n \n-                (true, is_thread_local)\n+                (true, is_thread_local, None)\n             }\n-            Place::Local(_) => {\n+            Place::Local(local) => {\n                 // Locals are always dropped at function exit, and if they\n                 // have a destructor it would've been called already.\n-                (false, true)\n+                (false, self.locals_are_invalidated_at_exit, Some(*local))\n             }\n             Place::Projection(..) => {\n                 bug!(\"root of {:?} is a projection ({:?})?\", place, root_place)\n@@ -996,8 +1015,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             PrefixSet::Shallow\n         };\n \n-        self.prefixes(place, prefix_set)\n-            .any(|prefix| prefix == root_place)\n+        let result =\n+            self.prefixes(place, prefix_set).any(|prefix| prefix == root_place);\n+\n+        if result {\n+            if let Some(local) = local {\n+                if let Some(_) = self.storage_dead_or_drop_error_reported.replace(local) {\n+                    debug!(\"place_is_invalidated_at_exit({:?}) - suppressed\", place);\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        result\n     }\n }\n \n@@ -1343,7 +1373,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n-                        LocalMutationIsAllowed::Yes => Ok(()),\n+                        LocalMutationIsAllowed::Yes |\n+                        LocalMutationIsAllowed::Move => Ok(()),\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n                     Mutability::Mut => Ok(()),\n@@ -1368,10 +1399,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        if self.is_upvar_field_projection(&proj.base).is_some() {\n-                                            self.is_mutable(&proj.base, is_local_mutation_allowed)\n-                                        } else {\n-                                            self.is_unique(&proj.base)\n+                                        match self.is_upvar_field_projection(&proj.base) {\n+                                            Some(field) if {\n+                                                self.mir.upvar_decls[field.index()].by_ref\n+                                            } => {\n+                                                self.is_mutable(&proj.base,\n+                                                                is_local_mutation_allowed)\n+                                            }\n+                                            _ => self.is_unique(&proj.base)\n                                         }\n                                     }\n                                 }\n@@ -1387,7 +1422,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             }\n                             // `Box<T>` owns its content, so mutable if its location is mutable\n                             _ if base_ty.is_box() => {\n-                                self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                                self.is_mutable(&proj.base, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n                             _ => bug!(\"Deref of unexpected type: {:?}\", base_ty),\n@@ -1404,14 +1439,17 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                         if let Some(field) = field_projection {\n                             let decl = &self.mir.upvar_decls[field.index()];\n-\n-                            return match decl.mutability {\n-                                Mutability::Mut => self.is_unique(&proj.base),\n-                                Mutability::Not => Err(place),\n+                            debug!(\"decl.mutability={:?} local_mutation_is_allowed={:?} place={:?}\",\n+                                   decl, is_local_mutation_allowed, place);\n+                            return match (decl.mutability, is_local_mutation_allowed) {\n+                                (Mutability::Not, LocalMutationIsAllowed::No) |\n+                                (Mutability::Not, LocalMutationIsAllowed::Yes) => Err(place),\n+                                (Mutability::Not, LocalMutationIsAllowed::Move) |\n+                                (Mutability::Mut, _) => self.is_unique(&proj.base),\n                             };\n                         }\n \n-                        self.is_mutable(&proj.base, LocalMutationIsAllowed::No)\n+                        self.is_mutable(&proj.base, is_local_mutation_allowed)\n                     }\n                 }\n             }\n@@ -1425,9 +1463,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // Local variables are unique\n                 Ok(())\n             }\n-            Place::Static(..) => {\n-                // Static variables are not\n-                Err(place)\n+            Place::Static(ref static_) => {\n+                if !self.tcx.is_static_mut(static_.def_id) {\n+                    Err(place)\n+                } else {\n+                    Ok(())\n+                }\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1478,15 +1519,358 @@ enum NoMovePathFound {\n     ReachedStatic,\n }\n \n+/// The degree of overlap between 2 places for borrow-checking.\n+enum Overlap {\n+    /// The places might partially overlap - in this case, we give\n+    /// up and say that they might conflict. This occurs when\n+    /// different fields of a union are borrowed. For example,\n+    /// if `u` is a union, we have no way of telling how disjoint\n+    /// `u.a.x` and `a.b.y` are.\n+    Arbitrary,\n+    /// The places have the same type, and are either completely disjoint\n+    /// or equal - i.e. they can't \"partially\" overlap as can occur with\n+    /// unions. This is the \"base case\" on which we recur for extensions\n+    /// of the place.\n+    EqualOrDisjoint,\n+    /// The places are disjoint, so we know all extensions of them\n+    /// will also be disjoint.\n+    Disjoint,\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n+    // Given that the bases of `elem1` and `elem2` are always either equal\n+    // or disjoint (and have the same type!), return the overlap situation\n+    // between `elem1` and `elem2`.\n+    fn place_element_conflict(&self,\n+                               elem1: &Place<'tcx>,\n+                               elem2: &Place<'tcx>)\n+                               -> Overlap\n+    {\n+        match (elem1, elem2) {\n+            (Place::Local(l1), Place::Local(l2)) => {\n+                if l1 == l2 {\n+                    // the same local - base case, equal\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n+                    Overlap::EqualOrDisjoint\n+                } else {\n+                    // different locals - base case, disjoint\n+                    debug!(\"place_element_conflict: DISJOINT-LOCAL\");\n+                    Overlap::Disjoint\n+                }\n+            }\n+            (Place::Static(..), Place::Static(..)) => {\n+                // Borrows of statics do not have to be tracked here.\n+                debug!(\"place_element_conflict: IGNORED-STATIC\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Local(_), Place::Static(_)) |\n+            (Place::Static(_), Place::Local(_)) => {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL\");\n+                Overlap::Disjoint\n+            }\n+            (Place::Projection(pi1), Place::Projection(pi2)) => {\n+                match (&pi1.elem, &pi2.elem) {\n+                    (ProjectionElem::Deref, ProjectionElem::Deref) => {\n+                        // derefs (e.g. `*x` vs. `*x`) - recur.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+                    (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n+                        if f1 == f2 {\n+                            // same field (e.g. `a.y` vs. `a.y`) - recur.\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            let ty = pi1.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                            match ty.sty {\n+                                ty::TyAdt(def, _) if def.is_union() => {\n+                                    // Different fields of a union, we are basically stuck.\n+                                    debug!(\"place_element_conflict: STUCK-UNION\");\n+                                    Overlap::Arbitrary\n+                                }\n+                                _ => {\n+                                    // Different fields of a struct (`a.x` vs. `a.y`). Disjoint!\n+                                    debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                                    Overlap::Disjoint\n+                                }\n+                            }\n+                        }\n+                    }\n+                    (ProjectionElem::Downcast(_, v1), ProjectionElem::Downcast(_, v2)) => {\n+                        // different variants are treated as having disjoint fields,\n+                        // even if they occupy the same \"space\", because it's\n+                        // impossible for 2 variants of the same enum to exist\n+                        // (and therefore, to be borrowed) at the same time.\n+                        //\n+                        // Note that this is different from unions - we *do* allow\n+                        // this code to compile:\n+                        //\n+                        // ```\n+                        // fn foo(x: &mut Result<i32, i32>) {\n+                        //     let mut v = None;\n+                        //     if let Ok(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     // here, you would *think* that the\n+                        //     // *entirety* of `x` would be borrowed,\n+                        //     // but in fact only the `Ok` variant is,\n+                        //     // so the `Err` variant is *entirely free*:\n+                        //     if let Err(ref mut a) = *x {\n+                        //         v = Some(a);\n+                        //     }\n+                        //     drop(v);\n+                        // }\n+                        // ```\n+                        if v1 == v2 {\n+                            debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n+                            Overlap::EqualOrDisjoint\n+                        } else {\n+                            debug!(\"place_element_conflict: DISJOINT-FIELD\");\n+                            Overlap::Disjoint\n+                        }\n+                    }\n+                    (ProjectionElem::Index(..), ProjectionElem::Index(..)) |\n+                    (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::Index(..), ProjectionElem::Subslice { .. }) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..)) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. }) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. }) |\n+                    (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                        // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n+                        // (if the indexes differ) or equal (if they are the same), so this\n+                        // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n+                        //\n+                        // Note that by construction, MIR at borrowck can't subdivide\n+                        // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n+                        // are only present in slice patterns, and we \"merge together\" nested\n+                        // slice patterns. That means we don't have to think about these. It's\n+                        // probably a good idea to assert this somewhere, but I'm too lazy.\n+                        //\n+                        // FIXME(#8636) we might want to return Disjoint if\n+                        // both projections are constant and disjoint.\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                        Overlap::EqualOrDisjoint\n+                    }\n+\n+                    (ProjectionElem::Deref, _) |\n+                    (ProjectionElem::Field(..), _) |\n+                    (ProjectionElem::Index(..), _) |\n+                    (ProjectionElem::ConstantIndex { .. }, _) |\n+                    (ProjectionElem::Subslice { .. }, _) |\n+                    (ProjectionElem::Downcast(..), _) => {\n+                        bug!(\"mismatched projections in place_element_conflict: {:?} and {:?}\",\n+\n+                             elem1, elem2)\n+                    }\n+                }\n+            }\n+            (Place::Projection(_), _) |\n+            (_, Place::Projection(_)) => {\n+                bug!(\"unexpected elements in place_element_conflict: {:?} and {:?}\",\n+                     elem1, elem2)\n+            }\n+        }\n+    }\n+    fn borrow_conflicts_with_place(&mut self,\n+                                    borrow: &BorrowData<'tcx>,\n+                                    place: &Place<'tcx>,\n+                                    access: ShallowOrDeep)\n+                                    -> bool\n+    {\n+        debug!(\"borrow_conflicts_with_place({:?},{:?},{:?})\", borrow, place, access);\n+\n+        // Return all the prefixes of `place` in reverse order, including\n+        // downcasts.\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>>\n+        {\n+            let mut result = vec![];\n+            let mut place = place;\n+            loop {\n+                result.push(place);\n+                match place {\n+                    Place::Projection(interior) => {\n+                        place = &interior.base;\n+                    }\n+                    Place::Local(_) | Place::Static(_) => {\n+                        result.reverse();\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let borrow_components = place_elements(&borrow.place);\n+        let access_components = place_elements(place);\n+        debug!(\"borrow_conflicts_with_place: components {:?} / {:?}\",\n+               borrow_components, access_components);\n+\n+        let borrow_components = borrow_components.into_iter()\n+             .map(Some).chain(iter::repeat(None));\n+        let access_components = access_components.into_iter()\n+             .map(Some).chain(iter::repeat(None));\n+        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+        // borrow forwards, iterating over \"similar\" projections in lockstep until\n+        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+        //\n+        // At each step, if we didn't run out of borrow or place, we know that our elements\n+        // have the same type, and that they only overlap if they are the identical.\n+        //\n+        // For example, if we are comparing these:\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  (*x1[i].y).w.b\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+        //\n+        // Because `zip` does potentially bad things to the iterator inside, this loop\n+        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+        //\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  x1[i].y\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //\n+        // -- here we run out of access - the borrow can access a part of it. If this\n+        // is a full deep access, then we *know* the borrow conflicts with it. However,\n+        // if the access is shallow, then we can proceed:\n+        //\n+        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+        //                                     are disjoint\n+        //\n+        // Our invariant is, that at each step of the iteration:\n+        //  - If we didn't run out of access to match, our borrow and access are comparable\n+        //    and either equal or disjoint.\n+        //  - If we did run out of accesss, the borrow can access a part of it.\n+        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+            debug!(\"borrow_conflicts_with_place: {:?} vs. {:?}\", borrow_c, access_c);\n+            match (borrow_c, access_c) {\n+                (None, _) => {\n+                    // If we didn't run out of access, the borrow can access all of our\n+                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                    // so we have a conflict.\n+                    //\n+                    // If we did, then we still know that the borrow can access a *part*\n+                    // of our place that our access cares about (a borrow of `a.b.c`\n+                    // with an access to `a.b`), so we still have a conflict.\n+                    //\n+                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                    // to #38899. Will probably need back-compat mode flag.\n+                    debug!(\"borrow_conflict_with_place: full borrow, CONFLICT\");\n+                    return true;\n+                }\n+                (Some(borrow_c), None) => {\n+                    // We know that the borrow can access a part of our place. This\n+                    // is a conflict if that is a part our access cares about.\n+\n+                    let (base, elem) = match borrow_c {\n+                        Place::Projection(box Projection { base, elem }) => (base, elem),\n+                        _ => bug!(\"place has no base?\")\n+                    };\n+                    let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                    match (elem, &base_ty.sty, access) {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant))) |\n+                        (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"borrow_conflicts_with_place: implicit field\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Shallow(None)) => {\n+                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                            // prefix thereof - the shallow access can't touch anything behind\n+                            // the pointer.\n+                            debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                            return false;\n+                        }\n+                        (ProjectionElem::Deref, ty::TyRef(_, ty::TypeAndMut {\n+                            ty: _, mutbl: hir::MutImmutable\n+                        }), _) => {\n+                            // the borrow goes through a dereference of a shared reference.\n+                            //\n+                            // I'm not sure why we are tracking these borrows - shared\n+                            // references can *always* be aliased, which means the\n+                            // permission check already account for this borrow.\n+                            debug!(\"borrow_conflicts_with_place: behind a shared ref\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Deep) |\n+                        (ProjectionElem::Field { .. }, _, _) |\n+                        (ProjectionElem::Index { ..}, _, _) |\n+                        (ProjectionElem::ConstantIndex { .. }, _, _) |\n+                        (ProjectionElem::Subslice { .. }, _, _) |\n+                        (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                    }\n+                }\n+                (Some(borrow_c), Some(access_c)) => {\n+                    match self.place_element_conflict(&borrow_c, access_c) {\n+                        Overlap::Arbitrary => {\n+                            // We have encountered different fields of potentially\n+                            // the same union - the borrow now partially overlaps.\n+                            //\n+                            // There is no *easy* way of comparing the fields\n+                            // further on, because they might have different types\n+                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                            // `.y` come from different structs).\n+                            //\n+                            // We could try to do some things here - e.g. count\n+                            // dereferences - but that's probably not a good\n+                            // idea, at least for now, so just give up and\n+                            // report a conflict. This is unsafe code anyway so\n+                            // the user could always use raw pointers.\n+                            debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                            return true;\n+                        }\n+                        Overlap::EqualOrDisjoint => {\n+                            // This is the recursive case - proceed to the next element.\n+                        }\n+                        Overlap::Disjoint => {\n+                            // We have proven the borrow disjoint - further\n+                            // projections will remain disjoint.\n+                            debug!(\"borrow_conflicts_with_place: disjoint\");\n+                            return false;\n+                        }\n+                    }\n+\n+                }\n+            }\n+        }\n+        unreachable!(\"iter::repeat returned None\")\n+    }\n+\n     fn each_borrow_involving_path<F>(\n         &mut self,\n         _context: Context,\n         access_place: (ShallowOrDeep, &Place<'tcx>),\n         flow_state: &InProgress<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>, &Place<'tcx>) -> Control,\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n@@ -1501,47 +1885,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n \n-            // Is `place` (or a prefix of it) already borrowed? If\n-            // so, that's relevant.\n-            //\n-            // FIXME: Differs from AST-borrowck; includes drive-by fix\n-            // to #38899. Will probably need back-compat mode flag.\n-            for accessed_prefix in self.prefixes(place, PrefixSet::All) {\n-                if *accessed_prefix == borrowed.place {\n-                    // FIXME: pass in enum describing case we are in?\n-                    let ctrl = op(self, i, borrowed, accessed_prefix);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            // Is `place` a prefix (modulo access type) of the\n-            // `borrowed.place`? If so, that's relevant.\n-\n-            let prefix_kind = match access {\n-                Shallow(Some(ArtificialField::Discriminant)) |\n-                Shallow(Some(ArtificialField::ArrayLength)) => {\n-                    // The discriminant and array length are like\n-                    // additional fields on the type; they do not\n-                    // overlap any existing data there. Furthermore,\n-                    // they cannot actually be a prefix of any\n-                    // borrowed place (at least in MIR as it is\n-                    // currently.)\n-                    continue 'next_borrow;\n-                }\n-                Shallow(None) => PrefixSet::Shallow,\n-                Deep => PrefixSet::Supporting,\n-            };\n-\n-            for borrowed_prefix in self.prefixes(&borrowed.place, prefix_kind) {\n-                if borrowed_prefix == place {\n-                    // FIXME: pass in enum describing case we are in?\n-                    let ctrl = op(self, i, borrowed, borrowed_prefix);\n-                    if ctrl == Control::Break {\n-                        return;\n-                    }\n-                }\n+            if self.borrow_conflicts_with_place(borrowed, place, access) {\n+                let ctrl = op(self, i, borrowed);\n+                if ctrl == Control::Break { return; }\n             }\n         }\n     }\n@@ -1595,6 +1941,7 @@ mod prefixes {\n     }\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+    #[allow(dead_code)]\n     pub(super) enum PrefixSet {\n         /// Doesn't stop until it returns the base case (a Local or\n         /// Static prefix).\n@@ -1907,17 +2254,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn report_conflicting_borrow(\n         &mut self,\n         context: Context,\n-        common_prefix: &Place<'tcx>,\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData,\n         end_issued_loan_span: Option<Span>,\n     ) {\n-        use self::prefixes::IsPrefixOf;\n-\n-        assert!(common_prefix.is_prefix_of(place));\n-        assert!(common_prefix.is_prefix_of(&issued_borrow.place));\n-\n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n         let new_closure_span = self.find_closure_span(span, context.loc);\n@@ -2373,8 +2714,10 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n         xform_move_outs(&mut self.move_outs);\n         xform_ever_inits(&mut self.ever_inits);\n     }\n+}\n \n-    fn summary(&self) -> String {\n+impl<'b, 'gcx, 'tcx> fmt::Display for InProgress<'b, 'gcx, 'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let mut s = String::new();\n \n         s.push_str(\"borrows in effect: [\");\n@@ -2451,7 +2794,7 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n         });\n         s.push_str(\"]\");\n \n-        return s;\n+        fmt::Display::fmt(&s, fmt)\n     }\n }\n "}, {"sha": "932aad0bb1d84dcf68f12673d221547452081fac", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -51,6 +51,17 @@ impl<'tcx> CFG<'tcx> {\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n         if tcx.sess.emit_end_regions() {\n+            if let region::ScopeData::CallSite(_) = region_scope.data() {\n+                // The CallSite scope (aka the root scope) is sort of weird, in that it is\n+                // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being\n+                // that, it is not really a part of the region hierarchy, but for some\n+                // reason it *is* considered a part of it.\n+                //\n+                // It should die a hopefully painful death with NLL, so let's leave this hack\n+                // for now so that nobody can complain about soundness.\n+                return\n+            }\n+\n             self.push(block, Statement {\n                 source_info,\n                 kind: StatementKind::EndRegion(region_scope),"}, {"sha": "c27cb43eff77b8f92f8effd87052ffa8b5213559", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::middle::region;\n use rustc::mir::{self, Location, Mir};\n use rustc::mir::visit::Visitor;\n use rustc::ty::{self, Region, TyCtxt};\n@@ -27,16 +30,20 @@ use borrow_check::nll::ToRegionVid;\n use syntax_pos::Span;\n \n use std::fmt;\n+use std::rc::Rc;\n \n // `Borrows` maps each dataflow bit to an `Rvalue::Ref`, which can be\n // uniquely identified in the MIR by the `Location` of the assigment\n // statement in which it appears on the right hand side.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n+    scope_tree: Rc<region::ScopeTree>,\n+    root_scope: Option<region::Scope>,\n     borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n     nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n }\n@@ -69,22 +76,32 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>)\n+               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n+               def_id: DefId,\n+               body_id: Option<hir::BodyId>)\n                -> Self {\n+        let scope_tree = tcx.region_scope_tree(def_id);\n+        let root_scope = body_id.map(|body_id| {\n+            region::Scope::CallSite(tcx.hir.body(body_id).value.hir_id.local_id)\n+        });\n         let mut visitor = GatherBorrows {\n             tcx,\n             mir,\n             idx_vec: IndexVec::new(),\n             location_map: FxHashMap(),\n             region_map: FxHashMap(),\n+            local_map: FxHashMap(),\n             region_span_map: FxHashMap()\n         };\n         visitor.visit_mir(mir);\n         return Borrows { tcx: tcx,\n                          mir: mir,\n                          borrows: visitor.idx_vec,\n+                         scope_tree,\n+                         root_scope,\n                          location_map: visitor.location_map,\n                          region_map: visitor.region_map,\n+                         local_map: visitor.local_map,\n                          region_span_map: visitor.region_span_map,\n                          nonlexical_regioncx };\n \n@@ -94,13 +111,22 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n             location_map: FxHashMap<Location, BorrowIndex>,\n             region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n+            local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             fn visit_rvalue(&mut self,\n                             rvalue: &mir::Rvalue<'tcx>,\n                             location: mir::Location) {\n+                fn root_local(mut p: &mir::Place<'_>) -> Option<mir::Local> {\n+                    loop { match p {\n+                        mir::Place::Projection(pi) => p = &pi.base,\n+                        mir::Place::Static(_) => return None,\n+                        mir::Place::Local(l) => return Some(*l)\n+                    }}\n+                }\n+\n                 if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n                     if is_unsafe_place(self.tcx, self.mir, place) { return; }\n \n@@ -109,8 +135,14 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n+\n                     let borrows = self.region_map.entry(region).or_insert(FxHashSet());\n                     borrows.insert(idx);\n+\n+                    if let Some(local) = root_local(place) {\n+                        let borrows = self.local_map.entry(local).or_insert(FxHashSet());\n+                        borrows.insert(idx);\n+                    }\n                 }\n             }\n \n@@ -199,7 +231,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::EndRegion(region_scope) => {\n                 if let Some(borrow_indexes) = self.region_map.get(&ReScope(region_scope)) {\n                     assert!(self.nonlexical_regioncx.is_none());\n-                    for idx in borrow_indexes { sets.kill(&idx); }\n+                    sets.kill_all(borrow_indexes);\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n                 }\n@@ -224,10 +256,19 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            mir::StatementKind::StorageDead(local) => {\n+                // Make sure there are no remaining borrows for locals that\n+                // are gone out of scope.\n+                //\n+                // FIXME: expand this to variables that are assigned over.\n+                if let Some(borrow_indexes) = self.local_map.get(&local) {\n+                    sets.kill_all(borrow_indexes);\n+                }\n+            }\n+\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n-            mir::StatementKind::StorageDead(..) |\n             mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => {}\n \n@@ -253,8 +294,17 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 // like unwind paths, we do not always emit `EndRegion` statements, so we\n                 // add some kills here as a \"backup\" and to avoid spurious error messages.\n                 for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n-                    if let ReScope(..) = borrow_data.region {\n-                        sets.kill(&borrow_index);\n+                    if let ReScope(scope) = borrow_data.region {\n+                        // Check that the scope is not actually a scope from a function that is\n+                        // a parent of our closure. Note that the CallSite scope itself is\n+                        // *outside* of the closure, for some weird reason.\n+                        if let Some(root_scope) = self.root_scope {\n+                            if *scope != root_scope &&\n+                                self.scope_tree.is_subscope_of(*scope, root_scope)\n+                            {\n+                                sets.kill(&borrow_index);\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "db8ca0628c4ed2f44c347c1240049cb497cd1ebe", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -14,7 +14,6 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -504,7 +503,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n         let stmt = &mir[location.block].statements[location.statement_index];\n         let loc_map = &move_data.loc_map;\n         let path_map = &move_data.path_map;\n-        let bits_per_block = self.bits_per_block();\n \n         match stmt.kind {\n             // this analysis only tries to find moves explicitly\n@@ -515,21 +513,15 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n             _ => {\n                 debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n                        stmt, location, &loc_map[location]);\n-                for move_index in &loc_map[location] {\n-                    // Every path deinitialized by a *particular move*\n-                    // has corresponding bit, \"gen'ed\" (i.e. set)\n-                    // here, in dataflow vector\n-                    zero_to_one(sets.gen_set.words_mut(), *move_index);\n-                }\n+                // Every path deinitialized by a *particular move*\n+                // has corresponding bit, \"gen'ed\" (i.e. set)\n+                // here, in dataflow vector\n+                sets.gen_all_and_assert_dead(&loc_map[location]);\n             }\n         }\n \n         for_location_inits(tcx, mir, move_data, location,\n-            |mpi| for moi in &path_map[mpi] {\n-                assert!(moi.index() < bits_per_block);\n-                sets.kill_set.add(&moi);\n-            }\n-        );\n+                           |mpi| sets.kill_all(&path_map[mpi]));\n     }\n \n     fn terminator_effect(&self,\n@@ -543,18 +535,10 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n \n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, location, &loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for move_index in &loc_map[location] {\n-            assert!(move_index.index() < bits_per_block);\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n+        sets.gen_all_and_assert_dead(&loc_map[location]);\n \n         for_location_inits(tcx, mir, move_data, location,\n-            |mpi| for moi in &path_map[mpi] {\n-                assert!(moi.index() < bits_per_block);\n-                sets.kill_set.add(&moi);\n-            }\n-        );\n+                           |mpi| sets.kill_all(&path_map[mpi]));\n     }\n \n     fn propagate_call_return(&self,\n@@ -585,11 +569,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n \n     fn start_block_effect(&self, sets: &mut BlockSets<InitIndex>) {\n-        let bits_per_block = self.bits_per_block();\n-        for init_index in (0..self.mir.arg_count).map(InitIndex::new) {\n-            assert!(init_index.index() < bits_per_block);\n-            sets.gen_set.add(&init_index);\n-        }\n+        sets.gen_all((0..self.mir.arg_count).map(InitIndex::new));\n     }\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<InitIndex>,\n@@ -599,26 +579,39 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         let init_path_map = &move_data.init_path_map;\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n-        let bits_per_block = self.bits_per_block();\n \n         debug!(\"statement {:?} at loc {:?} initializes move_indexes {:?}\",\n                stmt, location, &init_loc_map[location]);\n-        for init_index in &init_loc_map[location] {\n-            assert!(init_index.index() < bits_per_block);\n-            sets.gen_set.add(init_index);\n-        }\n+        sets.gen_all(&init_loc_map[location]);\n \n         match stmt.kind {\n-            mir::StatementKind::StorageDead(local) => {\n-                // End inits for StorageDead, so that an immutable variable can\n-                // be reinitialized on the next iteration of the loop.\n+            mir::StatementKind::StorageDead(local) |\n+            mir::StatementKind::StorageLive(local) => {\n+                // End inits for StorageDead and StorageLive, so that an immutable\n+                // variable can be reinitialized on the next iteration of the loop.\n+                //\n+                // FIXME(#46525): We *need* to do this for StorageLive as well as\n+                // StorageDead, because lifetimes of match bindings with guards are\n+                // weird - i.e. this code\n+                //\n+                // ```\n+                //     fn main() {\n+                //         match 0 {\n+                //             a | a\n+                //             if { println!(\"a={}\", a); false } => {}\n+                //             _ => {}\n+                //         }\n+                //     }\n+                // ```\n+                //\n+                // runs the guard twice, using the same binding for `a`, and only\n+                // storagedeads after everything ends, so if we don't regard the\n+                // storagelive as killing storage, we would have a multiple assignment\n+                // to immutable data error.\n                 if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Place::Local(local)) {\n                     debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n-                        stmt, location, &init_path_map[mpi]);\n-                    for ii in &init_path_map[mpi] {\n-                        assert!(ii.index() < bits_per_block);\n-                        sets.kill_set.add(&ii);\n-                    }\n+                           stmt, location, &init_path_map[mpi]);\n+                    sets.kill_all(&init_path_map[mpi]);\n                 }\n             }\n             _ => {}\n@@ -634,13 +627,11 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n         let init_loc_map = &move_data.init_loc_map;\n         debug!(\"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n                term, location, &init_loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for init_index in &init_loc_map[location] {\n-            if move_data.inits[*init_index].kind != InitKind::NonPanicPathOnly {\n-                assert!(init_index.index() < bits_per_block);\n-                sets.gen_set.add(init_index);\n-            }\n-        }\n+        sets.gen_all(\n+            init_loc_map[location].iter().filter(|init_index| {\n+                move_data.inits[**init_index].kind != InitKind::NonPanicPathOnly\n+            })\n+        );\n     }\n \n     fn propagate_call_return(&self,\n@@ -663,11 +654,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.index());\n-    assert!(retval);\n-}\n-\n impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {"}, {"sha": "12722979706fc6921eed8c696b738f71e5ffc30c", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -18,6 +18,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n+use std::borrow::Borrow;\n use std::fmt::{self, Debug};\n use std::io;\n use std::mem;\n@@ -492,10 +493,39 @@ impl<'a, E:Idx> BlockSets<'a, E> {\n         self.gen_set.add(e);\n         self.kill_set.remove(e);\n     }\n+    fn gen_all<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+              I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            self.gen(j.borrow());\n+        }\n+    }\n+\n+    fn gen_all_and_assert_dead<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+        I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            let j = j.borrow();\n+            let retval = self.gen_set.add(j);\n+            self.kill_set.remove(j);\n+            assert!(retval);\n+        }\n+    }\n+\n     fn kill(&mut self, e: &E) {\n         self.gen_set.remove(e);\n         self.kill_set.add(e);\n     }\n+    fn kill_all<I>(&mut self, i: I)\n+        where I: IntoIterator,\n+              I::Item: Borrow<E>\n+    {\n+        for j in i {\n+            self.kill(j.borrow());\n+        }\n+    }\n }\n \n impl<E:Idx> AllSets<E> {"}, {"sha": "fa80a2efdf83dab89815ce3e28f4a7704e5afc2a", "filename": "src/test/compile-fail/borrowck/borrowck-local-borrow-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-outlives-fn.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -13,7 +13,7 @@\n \n fn cplusplus_mode(x: isize) -> &'static isize {\n     &x //[ast]~ ERROR `x` does not live long enough\n-       //[mir]~^ ERROR borrowed value does not live long enough\n }\n+//[mir]~^ ERROR borrowed value does not live long enough\n \n fn main() {}"}, {"sha": "78f0d321e0d3df7d88db773626de99327b03bba8", "filename": "src/test/compile-fail/borrowck/borrowck-local-borrow-with-panic-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-with-panic-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-with-panic-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-local-borrow-with-panic-outlives-fn.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -14,9 +14,9 @@\n fn cplusplus_mode_exceptionally_unsafe(x: &mut Option<&'static mut isize>) {\n     let mut z = (0, 0);\n     *x = Some(&mut z.1); //[ast]~ ERROR [E0597]\n-                         //[mir]~^ ERROR [E0597]\n     panic!(\"catch me for a dangling pointer!\")\n }\n+//[mir]~^ ERROR [E0597]\n \n fn main() {\n     cplusplus_mode_exceptionally_unsafe(&mut None);"}, {"sha": "2bd6f75df1b1ff138befe6bf9a9a9cbff91617f7", "filename": "src/test/compile-fail/borrowck/borrowck-move-moved-value-into-closure.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-moved-value-into-closure.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(box_syntax)]\n \n fn call_f<F:FnOnce() -> isize>(f: F) -> isize {\n@@ -18,5 +21,6 @@ fn main() {\n     let t: Box<_> = box 3;\n \n     call_f(move|| { *t + 1 });\n-    call_f(move|| { *t + 1 }); //~ ERROR capture of moved value\n+    call_f(move|| { *t + 1 }); //[ast]~ ERROR capture of moved value\n+    //[mir]~^ ERROR use of moved value\n }"}, {"sha": "63bb04a0e4c3afd38716b3e7de834bbe298a963f", "filename": "src/test/compile-fail/borrowck/borrowck-mut-borrow-linear-errors.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-mut-borrow-linear-errors.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -23,15 +23,9 @@ fn main() {\n             1 => { addr = &mut x; } //[ast]~ ERROR [E0499]\n             //[mir]~^ ERROR [E0499]\n             2 => { addr = &mut x; } //[ast]~ ERROR [E0499]\n-            //[mir]~^ ERROR [E0506]\n-            //[mir]~| ERROR [E0499]\n-            //[mir]~| ERROR [E0499]\n+            //[mir]~^ ERROR [E0499]\n             _ => { addr = &mut x; } //[ast]~ ERROR [E0499]\n-            //[mir]~^ ERROR [E0506]\n-            //[mir]~| ERROR [E0499]\n-            //[mir]~| ERROR [E0499]\n+            //[mir]~^ ERROR [E0499]\n         }\n     }\n }\n-\n-"}, {"sha": "df0a05dfaee0e6a15ed1a864cf8c45c32335471b", "filename": "src/test/compile-fail/borrowck/borrowck-thread-local-static-borrow-outlives-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-thread-local-static-borrow-outlives-fn.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-test will be fixed later\n // revisions: ast mir\n //[mir]compile-flags: -Z borrowck=mir\n "}, {"sha": "0241b3870c7e64554f8a692b5c4bc8722dc60fc5", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -52,12 +52,12 @@ fn main() {\n         {\n             let ra = &u.a;\n             let rmb = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n-                                // FIXME Error for MIR (needs support for union)\n+                                //[mir]~^ ERROR cannot borrow `u.b` as mutable because it is also borrowed as immutable\n         }\n         {\n             let ra = &u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     // FIXME Error for MIR (needs support for union)\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n         }\n         // Mut borrow, same field\n         {\n@@ -84,22 +84,23 @@ fn main() {\n         {\n             let rma = &mut u.a;\n             let rb = &u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n-                           // FIXME Error for MIR (needs support for union)\n+                           //[mir]~^ ERROR cannot borrow `u.b` as immutable because it is also borrowed as mutable\n         }\n         {\n             let ra = &mut u.a;\n             let b = u.b; //[ast]~ ERROR cannot use `u.b` because it was mutably borrowed\n-                         // FIXME Error for MIR (needs support for union)\n+                         //[mir]~^ ERROR cannot use `u.b` because it was mutably borrowed\n+\n         }\n         {\n             let rma = &mut u.a;\n             let rmb2 = &mut u.b; //[ast]~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n-                                 // FIXME Error for MIR (needs support for union)\n+                                 //[mir]~^ ERROR cannot borrow `u.b` as mutable more than once at a time\n         }\n         {\n             let rma = &mut u.a;\n             u.b = 1; //[ast]~ ERROR cannot assign to `u.b` because it is borrowed\n-                     // FIXME Error for MIR (needs support for union)\n+                     //[mir]~^ ERROR cannot assign to `u.b` because it is borrowed\n         }\n     }\n }"}, {"sha": "94877b27d5888becd5ec91158c5f764e9da42aa8", "filename": "src/test/compile-fail/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -22,7 +23,7 @@ fn main() {\n     println!(\"t[0]: {}\", t[0]);\n     a[2] = 0; //[ast]~ ERROR cannot assign to `a[..]` because it is borrowed\n               //[cmp]~^ ERROR cannot assign to `a[..]` because it is borrowed (Ast)\n-              // FIXME Error for MIR (error missed)\n+              //[cmp]~| ERROR cannot assign to `a[..]` because it is borrowed (Mir)\n     println!(\"t[0]: {}\", t[0]);\n     t[0];\n }"}, {"sha": "5f5a58ed759426b8e2b1c633e509d02ea31edfaf", "filename": "src/test/compile-fail/issue-25579.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25579.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -20,13 +20,9 @@ fn causes_ice(mut l: &mut Sexpression) {\n     loop { match l {\n         &mut Sexpression::Num(ref mut n) => {},\n         &mut Sexpression::Cons(ref mut expr) => { //[ast]~ ERROR [E0499]\n-                                                  //[mir]~^ ERROR [E0506]\n-                                                  //[mir]~| ERROR [E0499]\n+                                                  //[mir]~^ ERROR [E0499]\n             l = &mut **expr; //[ast]~ ERROR [E0506]\n                              //[mir]~^ ERROR [E0506]\n-                             //[mir]~| ERROR [E0506]\n-                             //[mir]~| ERROR [E0499]\n-                             //[mir]~| ERROR [E0499]\n         }\n     }}\n }"}, {"sha": "a4dc00bd2b1e77acc4869230fb0839ddf28f45ae", "filename": "src/test/compile-fail/region-borrow-params-issue-29793-big.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-big.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -16,6 +16,10 @@\n // behavior (because the improperly accepted closure was actually\n // able to be invoked).\n \n+// ignore-tidy-linelength\n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n struct WrapA<F>(Option<F>);\n \n impl<F> WrapA<F> {\n@@ -75,9 +79,11 @@ impl<F, T> WrapA<F>\n fn main() {\n     let mut w = WrapA::new().set(|x: usize, y: usize| {\n         WrapB::new().set(|t: bool| if t { x } else { y }) // (separate errors for `x` vs `y`)\n-            //~^ ERROR `x` does not live long enough\n-            //~| ERROR `y` does not live long enough\n+            //[ast]~^ ERROR `x` does not live long enough\n+            //[ast]~| ERROR `y` does not live long enough\n     });\n+    //[mir]~^ ERROR borrowed value does not live long enough\n+    //[mir]~| ERROR borrowed value does not live long enough\n \n     w.handle(); // This works\n     // w.handle_ref(); // This doesn't"}, {"sha": "9592da77a1b583cb329e6171994892395a71e942", "filename": "src/test/run-pass/match-pipe-binding.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf30759a8409bee031ac252ee207452ab4804467/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-pipe-binding.rs?ref=cf30759a8409bee031ac252ee207452ab4804467", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z borrowck=compare\n \n fn test1() {\n     // from issue 6338"}]}