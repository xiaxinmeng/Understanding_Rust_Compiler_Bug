{"sha": "ad82a031f2e2c3612b0257f6727b8a379cb732d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkODJhMDMxZjJlMmMzNjEyYjAyNTdmNjcyN2I4YTM3OWNiNzMyZDA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-01T03:06:50Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-01T07:45:51Z"}, "message": "rustdoc: Use unique types for writing markdown output\n\nNo shared types allowed.", "tree": {"sha": "574836d62ed4ce5d7a464985dbc0171c26a8a31f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/574836d62ed4ce5d7a464985dbc0171c26a8a31f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad82a031f2e2c3612b0257f6727b8a379cb732d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad82a031f2e2c3612b0257f6727b8a379cb732d0", "html_url": "https://github.com/rust-lang/rust/commit/ad82a031f2e2c3612b0257f6727b8a379cb732d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad82a031f2e2c3612b0257f6727b8a379cb732d0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81a0745361744b30b7888372a39d924042cd0234", "url": "https://api.github.com/repos/rust-lang/rust/commits/81a0745361744b30b7888372a39d924042cd0234", "html_url": "https://github.com/rust-lang/rust/commit/81a0745361744b30b7888372a39d924042cd0234"}], "stats": {"total": 107, "additions": 73, "deletions": 34}, "files": [{"sha": "44ea3bc7229a4642912b244149e74bd9bc428953", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad82a031f2e2c3612b0257f6727b8a379cb732d0/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad82a031f2e2c3612b0257f6727b8a379cb732d0/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=ad82a031f2e2c3612b0257f6727b8a379cb732d0", "patch": "@@ -1,7 +1,7 @@\n import std::getopts;\n \n-export output_format::{};\n-export output_style::{};\n+export output_format;\n+export output_style;\n export config;\n export default_config;\n export parse_config;"}, {"sha": "3f4424f8284dd053fce0804e85964d1ce785d94e", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 71, "deletions": 32, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ad82a031f2e2c3612b0257f6727b8a379cb732d0/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad82a031f2e2c3612b0257f6727b8a379cb732d0/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=ad82a031f2e2c3612b0257f6727b8a379cb732d0", "patch": "@@ -1,23 +1,48 @@\n #[doc = \"Generate markdown from a document tree\"];\n \n-import std::io;\n-import std::io::writer_util;\n-\n export mk_pass;\n \n fn mk_pass(config: config::config) -> pass {\n-    mk_pass_(config, {|f| f(std::io::stdout()) })\n+    mk_pass_(config, stdout_writer)\n+}\n+\n+enum writeinstr {\n+    write(str),\n+    done\n+}\n+\n+type writer = fn~(writeinstr);\n+\n+impl writer for writer {\n+    fn write_str(str: str) {\n+        self(write(str));\n+    }\n+\n+    fn write_line(str: str) {\n+        self.write_str(str + \"\\n\");\n+    }\n+\n+    fn write_done() {\n+        self(done)\n+    }\n+}\n+\n+fn stdout_writer(instr: writeinstr) {\n+    alt instr {\n+      write(str) { std::io::println(str); }\n+      done { }\n+    }\n }\n \n // FIXME: This is a really convoluted interface to work around trying\n // to get a writer into a unique closure and then being able to test\n // what was written afterward\n fn mk_pass_(\n     config: config::config,\n-    give_writer: fn~(fn(io::writer))\n+    writer: writer\n ) -> pass {\n     let f = fn~(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n-        run(srv, doc, config, give_writer)\n+        run(srv, doc, config, writer)\n     };\n \n     {\n@@ -30,7 +55,7 @@ fn run(\n     srv: astsrv::srv,\n     doc: doc::cratedoc,\n     _config: config::config,\n-    give_writer: fn~(fn(io::writer))\n+    writer: writer\n ) -> doc::cratedoc {\n \n     fn mods_last(item1: doc::itemtag, item2: doc::itemtag) -> bool {\n@@ -45,17 +70,16 @@ fn run(\n         lteq\n     }\n \n-    give_writer {|writer|\n-        // Sort the items so mods come last. All mods will be\n-        // output at the same header level so sorting mods last\n-        // makes the headers come out nested correctly.\n-        let sorted_doc = sort_pass::mk_pass(\n-            \"mods last\", mods_last\n-        ).f(srv, doc);\n+    // Sort the items so mods come last. All mods will be\n+    // output at the same header level so sorting mods last\n+    // makes the headers come out nested correctly.\n+    let sorted_doc = sort_pass::mk_pass(\n+        \"mods last\", mods_last\n+    ).f(srv, doc);\n \n-        write_markdown(sorted_doc, writer);\n-    }\n-    doc\n+    write_markdown(sorted_doc, writer);\n+\n+    ret doc;\n }\n \n #[test]\n@@ -85,18 +109,19 @@ fn should_write_modules_last() {\n }\n \n type ctxt = {\n-    w: io::writer\n+    w: writer\n };\n \n fn write_markdown(\n     doc: doc::cratedoc,\n-    writer: io::writer\n+    writer: writer\n ) {\n     let ctxt = {\n         w: writer\n     };\n \n     write_crate(ctxt, doc);\n+    ctxt.w.write_done();\n }\n \n enum hlvl {\n@@ -853,31 +878,45 @@ mod test {\n         doc\n     }\n \n+    fn writer_future() -> (writer, future::future<str>) {\n+        let port = comm::port();\n+        let chan = comm::chan(port);\n+        let writer = fn~(instr: writeinstr) {\n+            comm::send(chan, copy instr);\n+        };\n+        let future = future::from_fn {||\n+            let res = \"\";\n+            while true {\n+                alt comm::recv(port) {\n+                  write(s) { res += s }\n+                  done { break }\n+                }\n+            }\n+            res\n+        };\n+        (writer, future)\n+    }\n+\n     fn write_markdown_str(\n         doc: doc::cratedoc\n     ) -> str {\n-        let buffer = io::mk_mem_buffer();\n-        let writer = io::mem_buffer_writer(buffer);\n+        let (writer, future) = writer_future();\n         write_markdown(doc, writer);\n-        ret io::mem_buffer_str(buffer);\n+        ret future::get(future);\n     }\n \n     fn write_markdown_str_srv(\n         srv: astsrv::srv,\n         doc: doc::cratedoc\n     ) -> str {\n-        let port = comm::port();\n-        let chan = comm::chan(port);\n-\n-        let pass = mk_pass_(config::default_config(\"\")) {|f|\n-            let buffer = io::mk_mem_buffer();\n-            let writer = io::mem_buffer_writer(buffer);\n-            f(writer);\n-            let result = io::mem_buffer_str(buffer);\n-            comm::send(chan, result);\n+        let config = {\n+            output_style: config::doc_per_crate\n+            with config::default_config(\"\")\n         };\n+        let (writer, future) = writer_future();\n+        let pass = mk_pass_(config, writer);\n         pass.f(srv, doc);\n-        ret comm::recv(port);\n+        ret future::get(future);\n     }\n \n     #[test]"}]}