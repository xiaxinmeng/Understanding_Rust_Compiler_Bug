{"sha": "da5c835c8bc7c283a97dd9c7f183755473ecf810", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNWM4MzVjOGJjN2MyODNhOTdkZDljN2YxODM3NTU0NzNlY2Y4MTA=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-24T18:15:11Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-29T13:10:17Z"}, "message": "Remove io::Result from syntax::print\n\nSince we're now writing directly to the vector, there's no need to\nthread results through the whole printing infrastructure", "tree": {"sha": "7565b095d08f4e6f3b7db20b921715ed28bf3a59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7565b095d08f4e6f3b7db20b921715ed28bf3a59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da5c835c8bc7c283a97dd9c7f183755473ecf810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da5c835c8bc7c283a97dd9c7f183755473ecf810", "html_url": "https://github.com/rust-lang/rust/commit/da5c835c8bc7c283a97dd9c7f183755473ecf810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da5c835c8bc7c283a97dd9c7f183755473ecf810/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aff8af213d76d746a4a86bf1b1c44af9d3d5691", "html_url": "https://github.com/rust-lang/rust/commit/1aff8af213d76d746a4a86bf1b1c44af9d3d5691"}], "stats": {"total": 4117, "additions": 1993, "deletions": 2124}, "files": [{"sha": "5be768ff1219876a86769428f362106ae71f2441", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -25,7 +25,6 @@ use crate::hir::print::Nested;\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n-use std::io;\n use std::result::Result::Err;\n use crate::ty::query::Providers;\n \n@@ -1187,7 +1186,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n /// Identical to the `PpAnn` implementation for `hir::Crate`,\n /// except it avoids creating a dependency on the whole crate.\n impl<'hir> print::PpAnn for Map<'hir> {\n-    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) -> io::Result<()> {\n+    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n         match nested {\n             Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n@@ -1199,7 +1198,7 @@ impl<'hir> print::PpAnn for Map<'hir> {\n }\n \n impl<'a> print::State<'a> {\n-    pub fn print_node(&mut self, node: Node<'_>) -> io::Result<()> {\n+    pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n@@ -1219,9 +1218,9 @@ impl<'a> print::State<'a> {\n                 use syntax::print::pprust::PrintState;\n \n                 // containing cbox, will be closed by print-block at }\n-                self.cbox(print::indent_unit)?;\n+                self.cbox(print::indent_unit);\n                 // head-ibox, will be closed by print-block after {\n-                self.ibox(0)?;\n+                self.ibox(0);\n                 self.print_block(&a)\n             }\n             Node::Lifetime(a)     => self.print_lifetime(&a),"}, {"sha": "36fa6c2bc8e901bc4042a0edccea7bf1e75d9576", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 848, "deletions": 884, "changes": 1732, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810"}, {"sha": "0055770e6f3e0afde9dea6ee7ee80d3db16e5df1", "filename": "src/librustc_borrowck/dataflow.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdataflow.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -6,7 +6,6 @@\n use rustc::cfg;\n use rustc::cfg::CFGIndex;\n use rustc::ty::TyCtxt;\n-use std::io;\n use std::mem;\n use std::usize;\n use syntax::print::pprust::PrintState;\n@@ -98,23 +97,23 @@ impl<'tcx, O: DataFlowOperator> DataFlowContext<'tcx, O> {\n }\n \n impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n-    fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust::State<'_>, nested: pprust::Nested) {\n         pprust::PpAnn::nested(self.tcx.hir(), state, nested)\n     }\n     fn pre(&self,\n            ps: &mut pprust::State<'_>,\n-           node: pprust::AnnNode<'_>) -> io::Result<()> {\n+           node: pprust::AnnNode<'_>) {\n         let id = match node {\n-            pprust::AnnNode::Name(_) => return Ok(()),\n+            pprust::AnnNode::Name(_) => return,\n             pprust::AnnNode::Expr(expr) => expr.hir_id.local_id,\n             pprust::AnnNode::Block(blk) => blk.hir_id.local_id,\n             pprust::AnnNode::Item(_) |\n-            pprust::AnnNode::SubItem(_) => return Ok(()),\n+            pprust::AnnNode::SubItem(_) => return,\n             pprust::AnnNode::Pat(pat) => pat.hir_id.local_id\n         };\n \n         if !self.has_bitset_for_local_id(id) {\n-            return Ok(());\n+            return;\n         }\n \n         assert!(self.bits_per_id > 0);\n@@ -147,10 +146,9 @@ impl<'tcx, O: DataFlowOperator> pprust::PpAnn for DataFlowContext<'tcx, O> {\n \n             ps.synth_comment(\n                 format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n-                        gens_str, action_kills_str, scope_kills_str))?;\n-            ps.s.space()?;\n+                        gens_str, action_kills_str, scope_kills_str));\n+            ps.s.space();\n         }\n-        Ok(())\n     }\n }\n \n@@ -531,8 +529,8 @@ impl<'tcx, O: DataFlowOperator + Clone + 'static> DataFlowContext<'tcx, O> {\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", pprust::to_string(self, |s| {\n-            s.cbox(pprust::indent_unit)?;\n-            s.ibox(0)?;\n+            s.cbox(pprust::indent_unit);\n+            s.ibox(0);\n             s.print_expr(&body.value)\n         }));\n     }"}, {"sha": "fcf790ca0f8f15672855a19bc9471a49d9f52cd0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -297,12 +297,9 @@ impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n \n impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n-    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n-              -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(tcx) = self.tcx {\n             pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n-        } else {\n-            Ok(())\n         }\n     }\n }\n@@ -323,37 +320,37 @@ impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> pprust::PpAnn for IdentifiedAnnotation<'hir> {\n-    fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n             pprust::AnnNode::Expr(_) => s.popen(),\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n-    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n             pprust::AnnNode::Ident(_) |\n-            pprust::AnnNode::Name(_) => Ok(()),\n+            pprust::AnnNode::Name(_) => {},\n \n             pprust::AnnNode::Item(item) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(item.id.to_string())\n             }\n             pprust::AnnNode::SubItem(id) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(id.to_string())\n             }\n             pprust::AnnNode::Block(blk) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"block {}\", blk.id))\n             }\n             pprust::AnnNode::Expr(expr) => {\n-                s.s.space()?;\n-                s.synth_comment(expr.id.to_string())?;\n+                s.s.space();\n+                s.synth_comment(expr.id.to_string());\n                 s.pclose()\n             }\n             pprust::AnnNode::Pat(pat) => {\n-                s.s.space()?;\n-                s.synth_comment(format!(\"pat {}\", pat.id))\n+                s.s.space();\n+                s.synth_comment(format!(\"pat {}\", pat.id));\n             }\n         }\n     }\n@@ -374,45 +371,42 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n }\n \n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n-    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n-              -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(ref tcx) = self.tcx {\n             pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n-        } else {\n-            Ok(())\n         }\n     }\n-    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n             pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n-    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n-            pprust_hir::AnnNode::Name(_) => Ok(()),\n+            pprust_hir::AnnNode::Name(_) => {},\n             pprust_hir::AnnNode::Item(item) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"hir_id: {} hir local_id: {}\",\n                                         item.hir_id, item.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::SubItem(id) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(id.to_string())\n             }\n             pprust_hir::AnnNode::Block(blk) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"block hir_id: {} hir local_id: {}\",\n                                         blk.hir_id, blk.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::Expr(expr) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"expr hir_id: {} hir local_id: {}\",\n-                                        expr.hir_id, expr.hir_id.local_id.as_u32()))?;\n+                                        expr.hir_id, expr.hir_id.local_id.as_u32()));\n                 s.pclose()\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(format!(\"pat hir_id: {} hir local_id: {}\",\n                                         pat.hir_id, pat.hir_id.local_id.as_u32()))\n             }\n@@ -435,19 +429,19 @@ impl<'a> PrinterSupport for HygieneAnnotation<'a> {\n }\n \n impl<'a> pprust::PpAnn for HygieneAnnotation<'a> {\n-    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust::State<'_>, node: pprust::AnnNode<'_>) {\n         match node {\n             pprust::AnnNode::Ident(&ast::Ident { name, span }) => {\n-                s.s.space()?;\n+                s.s.space();\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n                 s.synth_comment(format!(\"{}{:?}\", name.as_u32(), span.ctxt()))\n             }\n             pprust::AnnNode::Name(&name) => {\n-                s.s.space()?;\n+                s.s.space();\n                 s.synth_comment(name.as_u32().to_string())\n             }\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n }\n@@ -476,32 +470,30 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n-    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested)\n-              -> io::Result<()> {\n+    fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         let old_tables = self.tables.get();\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested)?;\n+        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested);\n         self.tables.set(old_tables);\n-        Ok(())\n     }\n-    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n             pprust_hir::AnnNode::Expr(_) => s.popen(),\n-            _ => Ok(()),\n+            _ => {}\n         }\n     }\n-    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) -> io::Result<()> {\n+    fn post(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n         match node {\n             pprust_hir::AnnNode::Expr(expr) => {\n-                s.s.space()?;\n-                s.s.word(\"as\")?;\n-                s.s.space()?;\n-                s.s.word(self.tables.get().expr_ty(expr).to_string())?;\n-                s.pclose()\n+                s.s.space();\n+                s.s.word(\"as\");\n+                s.s.space();\n+                s.s.word(self.tables.get().expr_ty(expr).to_string());\n+                s.pclose();\n             }\n-            _ => Ok(()),\n+            _ => {},\n         }\n     }\n }\n@@ -744,7 +736,7 @@ pub fn print_after_parsing(sess: &Session,\n                                 out,\n                                 annotation.pp_ann(),\n                                 false)\n-        }).unwrap()\n+        })\n     } else {\n         unreachable!();\n     };\n@@ -831,14 +823,14 @@ pub fn print_after_hir_lowering<'tcx>(\n                     for node_id in uii.all_matching_node_ids(hir_map) {\n                         let hir_id = tcx.hir().node_to_hir_id(node_id);\n                         let node = hir_map.get(hir_id);\n-                        pp_state.print_node(node)?;\n-                        pp_state.s.space()?;\n+                        pp_state.print_node(node);\n+                        pp_state.s.space();\n                         let path = annotation.node_path(hir_id)\n                             .expect(\"-Z unpretty missing node paths\");\n-                        pp_state.synth_comment(path)?;\n-                        pp_state.s.hardbreak()?;\n+                        pp_state.synth_comment(path);\n+                        pp_state.s.hardbreak();\n                     }\n-                    pp_state.s.eof()\n+                    pp_state.s.eof();\n                 })\n             }\n \n@@ -851,13 +843,11 @@ pub fn print_after_hir_lowering<'tcx>(\n                         let node = tcx.hir().get(hir_id);\n                         out.push_str(&format!(\"{:#?}\", node));\n                     }\n-                    Ok(())\n                 })\n             }\n \n             _ => unreachable!(),\n         }\n-        .unwrap();\n \n     write_output(out.into_bytes(), ofile);\n }"}, {"sha": "11a1de13fc217874cef8fb8d67eed2fefc9bd50b", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -1261,7 +1261,6 @@ pub fn noop_visit_vis<T: MutVisitor>(Spanned { node, span }: &mut Visibility, vi\n \n #[cfg(test)]\n mod tests {\n-    use std::io;\n     use crate::ast::{self, Ident};\n     use crate::util::parser_testing::{string_to_crate, matches_codepattern};\n     use crate::print::pprust;\n@@ -1271,7 +1270,7 @@ mod tests {\n \n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State<'_>,\n-                        krate: &ast::Crate) -> io::Result<()> {\n+                        krate: &ast::Crate) {\n         s.print_mod(&krate.module, &krate.attrs)\n     }\n "}, {"sha": "edcdb18a037d863f5b08fff410fce9c6e4c6bebc", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -613,12 +613,12 @@ impl<'a> Parser<'a> {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     use crate::print::pprust::PrintState;\n \n-                    s.s.word(\"&\")?;\n-                    s.print_opt_lifetime(lifetime)?;\n-                    s.print_mutability(mut_ty.mutbl)?;\n-                    s.popen()?;\n-                    s.print_type(&mut_ty.ty)?;\n-                    s.print_type_bounds(\" +\", &bounds)?;\n+                    s.s.word(\"&\");\n+                    s.print_opt_lifetime(lifetime);\n+                    s.print_mutability(mut_ty.mutbl);\n+                    s.popen();\n+                    s.print_type(&mut_ty.ty);\n+                    s.print_type_bounds(\" +\", &bounds);\n                     s.pclose()\n                 });\n                 err.span_suggestion("}, {"sha": "3143f2b997124a3b6a7f2c706ab73fd7b5ec96e2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -2572,12 +2572,12 @@ impl<'a> Parser<'a> {\n                           };\n                           let sugg = pprust::to_string(|s| {\n                               use crate::print::pprust::PrintState;\n-                              s.popen()?;\n-                              s.print_expr(&e)?;\n-                              s.s.word( \".\")?;\n-                              s.print_usize(float.trunc() as usize)?;\n-                              s.pclose()?;\n-                              s.s.word(\".\")?;\n+                              s.popen();\n+                              s.print_expr(&e);\n+                              s.s.word( \".\");\n+                              s.print_usize(float.trunc() as usize);\n+                              s.pclose();\n+                              s.s.word(\".\");\n                               s.s.word(fstr.splitn(2, \".\").last().unwrap().to_string())\n                           });\n                           err.span_suggestion(\n@@ -4634,9 +4634,9 @@ impl<'a> Parser<'a> {\n                     }\n                     let sugg = pprust::to_string(|s| {\n                         use crate::print::pprust::{PrintState, INDENT_UNIT};\n-                        s.ibox(INDENT_UNIT)?;\n-                        s.bopen()?;\n-                        s.print_stmt(&stmt)?;\n+                        s.ibox(INDENT_UNIT);\n+                        s.bopen();\n+                        s.print_stmt(&stmt);\n                         s.bclose_maybe_open(stmt.span, INDENT_UNIT, false)\n                     });\n                     e.span_suggestion("}, {"sha": "f64e95aee5bca91ee5ac4382bdf997db165a519e", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 34, "deletions": 51, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810", "patch": "@@ -136,7 +136,6 @@\n \n use std::collections::VecDeque;\n use std::fmt;\n-use std::io;\n use std::borrow::Cow;\n use log::debug;\n \n@@ -311,16 +310,15 @@ impl<'a> Printer<'a> {\n         self.buf[self.right].token = t;\n     }\n \n-    fn pretty_print_eof(&mut self) -> io::Result<()> {\n+    fn pretty_print_eof(&mut self) {\n         if !self.scan_stack.is_empty() {\n             self.check_stack(0);\n-            self.advance_left()?;\n+            self.advance_left();\n         }\n         self.indent(0);\n-        Ok(())\n     }\n \n-    fn pretty_print_begin(&mut self, b: BeginToken) -> io::Result<()> {\n+    fn pretty_print_begin(&mut self, b: BeginToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n@@ -334,24 +332,22 @@ impl<'a> Printer<'a> {\n         self.buf[self.right] = BufEntry { token: Token::Begin(b), size: -self.right_total };\n         let right = self.right;\n         self.scan_push(right);\n-        Ok(())\n     }\n \n-    fn pretty_print_end(&mut self) -> io::Result<()> {\n+    fn pretty_print_end(&mut self) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n-            self.print_end()\n+            self.print_end();\n         } else {\n             debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n             self.advance_right();\n             self.buf[self.right] = BufEntry { token: Token::End, size: -1 };\n             let right = self.right;\n             self.scan_push(right);\n-            Ok(())\n         }\n     }\n \n-    fn pretty_print_break(&mut self, b: BreakToken) -> io::Result<()> {\n+    fn pretty_print_break(&mut self, b: BreakToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n@@ -367,25 +363,24 @@ impl<'a> Printer<'a> {\n         self.scan_push(right);\n         self.buf[self.right] = BufEntry { token: Token::Break(b), size: -self.right_total };\n         self.right_total += b.blank_space;\n-        Ok(())\n     }\n \n-    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+    fn pretty_print_string(&mut self, s: Cow<'static, str>, len: isize) {\n         if self.scan_stack.is_empty() {\n             debug!(\"pp String('{}')/print Vec<{},{}>\",\n                    s, self.left, self.right);\n-            self.print_string(s, len)\n+            self.print_string(s, len);\n         } else {\n             debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                    s, self.left, self.right);\n             self.advance_right();\n             self.buf[self.right] = BufEntry { token: Token::String(s, len), size: len };\n             self.right_total += len;\n-            self.check_stream()\n+            self.check_stream();\n         }\n     }\n \n-    crate fn check_stream(&mut self) -> io::Result<()> {\n+    crate fn check_stream(&mut self) {\n         debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -396,12 +391,11 @@ impl<'a> Printer<'a> {\n                 let scanned = self.scan_pop_bottom();\n                 self.buf[scanned].size = SIZE_INFINITY;\n             }\n-            self.advance_left()?;\n+            self.advance_left();\n             if self.left != self.right {\n-                self.check_stream()?;\n+                self.check_stream();\n             }\n         }\n-        Ok(())\n     }\n \n     crate fn scan_push(&mut self, x: usize) {\n@@ -431,7 +425,7 @@ impl<'a> Printer<'a> {\n         assert_ne!(self.right, self.left);\n     }\n \n-    crate fn advance_left(&mut self) -> io::Result<()> {\n+    crate fn advance_left(&mut self) {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.buf[self.left].size);\n \n@@ -449,7 +443,7 @@ impl<'a> Printer<'a> {\n                 _ => 0\n             };\n \n-            self.print(left, left_size)?;\n+            self.print(left, left_size);\n \n             self.left_total += len;\n \n@@ -462,8 +456,6 @@ impl<'a> Printer<'a> {\n \n             left_size = self.buf[self.left].size;\n         }\n-\n-        Ok(())\n     }\n \n     crate fn check_stack(&mut self, k: isize) {\n@@ -494,12 +486,11 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn print_newline(&mut self, amount: isize) -> io::Result<()> {\n+    crate fn print_newline(&mut self, amount: isize) {\n         debug!(\"NEWLINE {}\", amount);\n         self.out.push('\\n');\n         self.pending_indentation = 0;\n         self.indent(amount);\n-        Ok(())\n     }\n \n     crate fn indent(&mut self, amount: isize) {\n@@ -517,7 +508,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n-    crate fn print_begin(&mut self, b: BeginToken, l: isize) -> io::Result<()> {\n+    crate fn print_begin(&mut self, b: BeginToken, l: isize) {\n         if l > self.space {\n             let col = self.margin - self.space + b.offset;\n             debug!(\"print Begin -> push broken block at col {}\", col);\n@@ -532,52 +523,46 @@ impl<'a> Printer<'a> {\n                 pbreak: PrintStackBreak::Fits\n             });\n         }\n-        Ok(())\n     }\n \n-    crate fn print_end(&mut self) -> io::Result<()> {\n+    crate fn print_end(&mut self) {\n         debug!(\"print End -> pop End\");\n         let print_stack = &mut self.print_stack;\n         assert!(!print_stack.is_empty());\n         print_stack.pop().unwrap();\n-        Ok(())\n     }\n \n-    crate fn print_break(&mut self, b: BreakToken, l: isize) -> io::Result<()> {\n+    crate fn print_break(&mut self, b: BreakToken, l: isize) {\n         let top = self.get_top();\n         match top.pbreak {\n             PrintStackBreak::Fits => {\n                 debug!(\"print Break({}) in fitting block\", b.blank_space);\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n-                Ok(())\n             }\n             PrintStackBreak::Broken(Breaks::Consistent) => {\n                 debug!(\"print Break({}+{}) in consistent block\",\n                        top.offset, b.offset);\n-                let ret = self.print_newline(top.offset + b.offset);\n+                self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n-                ret\n             }\n             PrintStackBreak::Broken(Breaks::Inconsistent) => {\n                 if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n-                    let ret = self.print_newline(top.offset + b.offset);\n+                    self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n-                    ret\n                 } else {\n                     debug!(\"print Break({}) w/o newline in inconsistent\",\n                            b.blank_space);\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n-                    Ok(())\n                 }\n             }\n         }\n     }\n \n-    crate fn print_string(&mut self, s: Cow<'static, str>, len: isize) -> io::Result<()> {\n+    crate fn print_string(&mut self, s: Cow<'static, str>, len: isize) {\n         debug!(\"print String({})\", s);\n         // assert!(len <= space);\n         self.space -= len;\n@@ -592,11 +577,9 @@ impl<'a> Printer<'a> {\n         self.out.extend(std::iter::repeat(' ').take(self.pending_indentation as usize));\n         self.pending_indentation = 0;\n         self.out.push_str(&s);\n-\n-        Ok(())\n     }\n \n-    crate fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n+    crate fn print(&mut self, token: Token, l: isize) {\n         debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.buf,\n@@ -609,7 +592,7 @@ impl<'a> Printer<'a> {\n             Token::Break(b) => self.print_break(b, l),\n             Token::String(s, len) => {\n                 assert_eq!(len, l);\n-                self.print_string(s, len)\n+                self.print_string(s, len);\n             }\n             Token::Eof => panic!(), // Eof should never get here.\n         }\n@@ -618,57 +601,57 @@ impl<'a> Printer<'a> {\n     // Convenience functions to talk to the printer.\n \n     /// \"raw box\"\n-    crate fn rbox(&mut self, indent: usize, b: Breaks) -> io::Result<()> {\n+    crate fn rbox(&mut self, indent: usize, b: Breaks) {\n         self.pretty_print_begin(BeginToken {\n             offset: indent as isize,\n             breaks: b\n         })\n     }\n \n     /// Inconsistent breaking box\n-    crate fn ibox(&mut self, indent: usize) -> io::Result<()> {\n+    crate fn ibox(&mut self, indent: usize) {\n         self.rbox(indent, Breaks::Inconsistent)\n     }\n \n     /// Consistent breaking box\n-    pub fn cbox(&mut self, indent: usize) -> io::Result<()> {\n+    pub fn cbox(&mut self, indent: usize) {\n         self.rbox(indent, Breaks::Consistent)\n     }\n \n-    pub fn break_offset(&mut self, n: usize, off: isize) -> io::Result<()> {\n+    pub fn break_offset(&mut self, n: usize, off: isize) {\n         self.pretty_print_break(BreakToken {\n             offset: off,\n             blank_space: n as isize\n         })\n     }\n \n-    crate fn end(&mut self) -> io::Result<()> {\n+    crate fn end(&mut self) {\n         self.pretty_print_end()\n     }\n \n-    pub fn eof(&mut self) -> io::Result<()> {\n+    pub fn eof(&mut self) {\n         self.pretty_print_eof()\n     }\n \n-    pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) -> io::Result<()> {\n+    pub fn word<S: Into<Cow<'static, str>>>(&mut self, wrd: S) {\n         let s = wrd.into();\n         let len = s.len() as isize;\n         self.pretty_print_string(s, len)\n     }\n \n-    fn spaces(&mut self, n: usize) -> io::Result<()> {\n+    fn spaces(&mut self, n: usize) {\n         self.break_offset(n, 0)\n     }\n \n-    crate fn zerobreak(&mut self) -> io::Result<()> {\n+    crate fn zerobreak(&mut self) {\n         self.spaces(0)\n     }\n \n-    pub fn space(&mut self) -> io::Result<()> {\n+    pub fn space(&mut self) {\n         self.spaces(1)\n     }\n \n-    pub fn hardbreak(&mut self) -> io::Result<()> {\n+    pub fn hardbreak(&mut self) {\n         self.spaces(SIZE_INFINITY as usize)\n     }\n "}, {"sha": "88f96fc8483c1b8d57f198329b476350305fac72", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1038, "deletions": 1102, "changes": 2140, "blob_url": "https://github.com/rust-lang/rust/blob/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5c835c8bc7c283a97dd9c7f183755473ecf810/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=da5c835c8bc7c283a97dd9c7f183755473ecf810"}]}