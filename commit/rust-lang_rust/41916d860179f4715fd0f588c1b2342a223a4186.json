{"sha": "41916d860179f4715fd0f588c1b2342a223a4186", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOTE2ZDg2MDE3OWY0NzE1ZmQwZjU4OGMxYjIzNDJhMjIzYTQxODY=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-26T20:11:15Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-26T23:21:01Z"}, "message": "Drop cached sources to reduce memory usage", "tree": {"sha": "a13b99b2c3ada4057e2fcab46e6fc2f81be1ab6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a13b99b2c3ada4057e2fcab46e6fc2f81be1ab6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41916d860179f4715fd0f588c1b2342a223a4186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41916d860179f4715fd0f588c1b2342a223a4186", "html_url": "https://github.com/rust-lang/rust/commit/41916d860179f4715fd0f588c1b2342a223a4186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41916d860179f4715fd0f588c1b2342a223a4186/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8779e7baa495b8dc46008c8f7d2badcb0ea3b1ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/8779e7baa495b8dc46008c8f7d2badcb0ea3b1ab", "html_url": "https://github.com/rust-lang/rust/commit/8779e7baa495b8dc46008c8f7d2badcb0ea3b1ab"}], "stats": {"total": 66, "additions": 43, "deletions": 23}, "files": [{"sha": "aed710e2b8edc440c25949ad628ad6651e924eb3", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/41916d860179f4715fd0f588c1b2342a223a4186/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41916d860179f4715fd0f588c1b2342a223a4186/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=41916d860179f4715fd0f588c1b2342a223a4186", "patch": "@@ -66,6 +66,25 @@ struct FileEntry {\n \n type Cache = HashMap<PathBuf, FileEntry>;\n \n+impl FileEntry {\n+    fn parse_ids(&mut self,\n+                file: &Path,\n+                contents: &str,\n+                errors: &mut bool)\n+{\n+        if self.ids.is_empty() {\n+            with_attrs_in_source(contents, \" id\", |fragment, i| {\n+                let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                if !self.ids.insert(frag) {\n+                    *errors = true;\n+                    println!(\"{}:{}: id is not unique: `{}`\",\n+                             file.display(), i, fragment);\n+                }\n+            });\n+        }\n+    }\n+}\n+\n fn walk(cache: &mut Cache,\n         root: &Path,\n         dir: &Path,\n@@ -79,7 +98,13 @@ fn walk(cache: &mut Cache,\n         if kind.is_dir() {\n             walk(cache, root, &path, url, errors);\n         } else {\n-            check(cache, root, &path, url, errors);\n+            let pretty_path = check(cache, root, &path, url, errors);\n+            if let Some(pretty_path) = pretty_path {\n+                let entry = cache.get_mut(&pretty_path).unwrap();\n+                // we don't need the source anymore,\n+                // so drop to to reduce memory-usage\n+                entry.source = String::new();\n+            }\n         }\n         url.path_mut().unwrap().pop();\n     }\n@@ -89,42 +114,42 @@ fn check(cache: &mut Cache,\n          root: &Path,\n          file: &Path,\n          base: &Url,\n-         errors: &mut bool)\n+         errors: &mut bool) -> Option<PathBuf>\n {\n     // ignore js files as they are not prone to errors as the rest of the\n     // documentation is and they otherwise bring up false positives.\n     if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n-        return\n+        return None;\n     }\n \n     // Unfortunately we're not 100% full of valid links today to we need a few\n     // whitelists to get this past `make check` today.\n     // FIXME(#32129)\n     if file.ends_with(\"std/string/struct.String.html\") ||\n        file.ends_with(\"collections/string/struct.String.html\") {\n-        return\n+        return None;\n     }\n     // FIXME(#32130)\n     if file.ends_with(\"btree_set/struct.BTreeSet.html\") ||\n        file.ends_with(\"collections/struct.BTreeSet.html\") ||\n        file.ends_with(\"collections/btree_map/struct.BTreeMap.html\") ||\n        file.ends_with(\"collections/hash_map/struct.HashMap.html\") {\n-        return\n+        return None;\n     }\n \n     if file.ends_with(\"std/sys/ext/index.html\") {\n-        return\n+        return None;\n     }\n \n     if let Some(file) = file.to_str() {\n         // FIXME(#31948)\n         if file.contains(\"ParseFloatError\") {\n-            return\n+            return None;\n         }\n         // weird reexports, but this module is on its way out, so chalk it up to\n         // \"rustdoc weirdness\" and move on from there\n         if file.contains(\"scoped_tls\") {\n-            return\n+            return None;\n         }\n     }\n \n@@ -134,8 +159,12 @@ fn check(cache: &mut Cache,\n     let res = load_file(cache, root, PathBuf::from(file), false, false);\n     let (pretty_file, contents) = match res {\n         Ok(res) => res,\n-        Err(_) => return,\n+        Err(_) => return None,\n     };\n+    {\n+        cache.get_mut(&pretty_file).unwrap()\n+                                   .parse_ids(&pretty_file, &contents, errors);\n+    }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n     with_attrs_in_source(&contents, \" href\", |url, i| {\n@@ -172,19 +201,10 @@ fn check(cache: &mut Cache,\n                     return;\n                 }\n \n-                let ids = &mut cache.get_mut(&pretty_path).unwrap().ids;\n-                if ids.is_empty() {\n-                    // Search for anything that's the regex 'id[ ]*=[ ]*\".*?\"'\n-                    with_attrs_in_source(&contents, \" id\", |fragment, i| {\n-                        let frag = fragment.trim_left_matches(\"#\").to_owned();\n-                        if !ids.insert(frag) {\n-                            *errors = true;\n-                            println!(\"{}:{}: id is not unique: `{}`\",\n-                                     pretty_file.display(), i, fragment);\n-                        }\n-                    });\n-                }\n-                if !ids.contains(fragment) {\n+                let entry = &mut cache.get_mut(&pretty_path).unwrap();\n+                entry.parse_ids(&pretty_path, &contents, errors);\n+\n+                if !entry.ids.contains(fragment) {\n                     *errors = true;\n                     print!(\"{}:{}: broken link fragment  \",\n                            pretty_file.display(), i + 1);\n@@ -199,14 +219,14 @@ fn check(cache: &mut Cache,\n             println!(\"{}\", pretty_path.display());\n         }\n     });\n+    Some(pretty_file)\n }\n \n fn load_file(cache: &mut Cache,\n              root: &Path,\n              file: PathBuf,\n              follow_redirects: bool,\n              is_redirect: bool) -> Result<(PathBuf, String), LoadError> {\n-\n     let mut contents = String::new();\n     let pretty_file = PathBuf::from(file.strip_prefix(root).unwrap_or(&file));\n "}]}