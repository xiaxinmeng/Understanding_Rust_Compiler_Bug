{"sha": "de04c05dea10fc03cb626338ce1d55f4c90f58b0", "node_id": "C_kwDOAAsO6NoAKGRlMDRjMDVkZWExMGZjMDNjYjYyNjMzOGNlMWQ1NWY0YzkwZjU4YjA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-12-01T05:30:05Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-03-31T15:04:53Z"}, "message": "Specialize suggestion for Option<T>", "tree": {"sha": "0a5347cfe1642013b5a97ad421b275c18471daf7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a5347cfe1642013b5a97ad421b275c18471daf7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de04c05dea10fc03cb626338ce1d55f4c90f58b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de04c05dea10fc03cb626338ce1d55f4c90f58b0", "html_url": "https://github.com/rust-lang/rust/commit/de04c05dea10fc03cb626338ce1d55f4c90f58b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de04c05dea10fc03cb626338ce1d55f4c90f58b0/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df20355fa9fa5e9fb89be4e4bfee8a643bb7a23e", "url": "https://api.github.com/repos/rust-lang/rust/commits/df20355fa9fa5e9fb89be4e4bfee8a643bb7a23e", "html_url": "https://github.com/rust-lang/rust/commit/df20355fa9fa5e9fb89be4e4bfee8a643bb7a23e"}], "stats": {"total": 294, "additions": 231, "deletions": 63}, "files": [{"sha": "53acffc5098ed89133b39fd0716dc4e642563af9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -2285,10 +2285,10 @@ impl<'v> Visitor<'v> for FindTypeParam {\n     }\n }\n \n-pub fn recursive_type_with_infinite_size_error(\n-    tcx: TyCtxt<'_>,\n+pub fn recursive_type_with_infinite_size_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,\n-    spans: Vec<Span>,\n+    spans: Vec<(Span, Option<hir::HirId>)>,\n ) {\n     assert!(type_def_id.is_local());\n     let span = tcx.hir().span_if_local(type_def_id).unwrap();\n@@ -2297,24 +2297,33 @@ pub fn recursive_type_with_infinite_size_error(\n     let mut err =\n         struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\", path);\n     err.span_label(span, \"recursive type has infinite size\");\n-    for &span in &spans {\n+    for &(span, _) in &spans {\n         err.span_label(span, \"recursive without indirection\");\n     }\n     let msg = format!(\n         \"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `{}` representable\",\n         path,\n     );\n     if spans.len() <= 4 {\n+        // FIXME: This suggestion might be erroneous if Option or Box are shadowed\n         err.multipart_suggestion(\n             &msg,\n             spans\n-                .iter()\n-                .flat_map(|&span| {\n-                    [\n-                        (span.shrink_to_lo(), \"Box<\".to_string()),\n-                        (span.shrink_to_hi(), \">\".to_string()),\n-                    ]\n-                    .into_iter()\n+                .into_iter()\n+                .flat_map(|(span, field_id)| {\n+                    if let Some(generic_span) = get_option_generic_from_field_id(tcx, field_id) {\n+                        // If we match an `Option` and can grab the span of the Option's generic, then\n+                        // suggest boxing the generic arg for a non-null niche optimization.\n+                        vec![\n+                            (generic_span.shrink_to_lo(), \"Box<\".to_string()),\n+                            (generic_span.shrink_to_hi(), \">\".to_string()),\n+                        ]\n+                    } else {\n+                        vec![\n+                            (span.shrink_to_lo(), \"Box<\".to_string()),\n+                            (span.shrink_to_hi(), \">\".to_string()),\n+                        ]\n+                    }\n                 })\n                 .collect(),\n             Applicability::HasPlaceholders,\n@@ -2325,6 +2334,38 @@ pub fn recursive_type_with_infinite_size_error(\n     err.emit();\n }\n \n+/// Extract the span for the generic type `T` of `Option<T>` in a field definition\n+fn get_option_generic_from_field_id(tcx: TyCtxt<'_>, field_id: Option<hir::HirId>) -> Option<Span> {\n+    let node = tcx.hir().find(field_id?);\n+\n+    // Expect a field from our field_id\n+    let Some(hir::Node::Field(field_def)) = node\n+        else { bug!(\"Expected HirId corresponding to FieldDef, found: {:?}\", node) };\n+\n+    // Match a type that is a simple QPath with no Self\n+    let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = &field_def.ty.kind\n+        else { return None };\n+\n+    // Check if the path we're checking resolves to Option\n+    let hir::def::Res::Def(_, did) = path.res\n+        else { return None };\n+\n+    // Bail if this path doesn't describe `::core::option::Option`\n+    if !tcx.is_diagnostic_item(sym::Option, did) {\n+        return None;\n+    }\n+\n+    // Match a single generic arg in the 0th path segment\n+    let generic_arg = path.segments.get(0)?.args?.args.get(0);\n+\n+    // Take the span out of the type, if it's a type\n+    if let Some(hir::GenericArg::Type(generic_ty)) = generic_arg {\n+        Some(generic_ty.span)\n+    } else {\n+        None\n+    }\n+}\n+\n /// Summarizes information\n #[derive(Clone)]\n pub enum ArgKind {"}, {"sha": "7efc82efd15c30c60034df6da010b48acccdfdd2", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -17,12 +17,20 @@ use std::cmp;\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n-    SelfRecursive(Vec<Span>),\n+    /// Return a list of types that are included in themselves:\n+    /// the spans where they are self-included, and (if found)\n+    /// the HirId of the FieldDef that defines the self-inclusion.\n+    SelfRecursive(Vec<(Span, Option<hir::HirId>)>),\n }\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> Representability {\n+pub fn ty_is_representable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n+) -> Representability {\n     debug!(\"is_type_representable: {:?}\", ty);\n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack of\n@@ -38,11 +46,12 @@ pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> R\n     let mut force_result = false;\n     let r = is_type_structurally_recursive(\n         tcx,\n-        sp,\n         &mut seen,\n         &mut shadow_seen,\n         &mut representable_cache,\n         ty,\n+        sp,\n+        field_id,\n         &mut force_result,\n     );\n     debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n@@ -61,11 +70,12 @@ fn fold_repr<It: Iterator<Item = Representability>>(iter: It) -> Representabilit\n \n fn are_inner_types_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n     shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n     force_result: &mut bool,\n ) -> Representability {\n     debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n@@ -75,11 +85,12 @@ fn are_inner_types_recursive<'tcx>(\n             fold_repr(fields.iter().map(|ty| {\n                 is_type_structurally_recursive(\n                     tcx,\n-                    sp,\n                     seen,\n                     shadow_seen,\n                     representable_cache,\n                     ty,\n+                    sp,\n+                    field_id,\n                     force_result,\n                 )\n             }))\n@@ -88,20 +99,26 @@ fn are_inner_types_recursive<'tcx>(\n         // FIXME(#11924) Behavior undecided for zero-length vectors.\n         ty::Array(ty, _) => is_type_structurally_recursive(\n             tcx,\n-            sp,\n             seen,\n             shadow_seen,\n             representable_cache,\n             *ty,\n+            sp,\n+            field_id,\n             force_result,\n         ),\n         ty::Adt(def, substs) => {\n             // Find non representable fields with their spans\n             fold_repr(def.all_fields().map(|field| {\n                 let ty = field.ty(tcx, substs);\n-                let span = match field.did.as_local().and_then(|id| tcx.hir().find_by_def_id(id)) {\n-                    Some(hir::Node::Field(field)) => field.ty.span,\n-                    _ => sp,\n+                let (sp, field_id) = match field\n+                    .did\n+                    .as_local()\n+                    .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n+                    .and_then(|id| tcx.hir().find(id))\n+                {\n+                    Some(hir::Node::Field(field)) => (field.ty.span, Some(field.hir_id)),\n+                    _ => (sp, field_id),\n                 };\n \n                 let mut result = None;\n@@ -130,7 +147,7 @@ fn are_inner_types_recursive<'tcx>(\n                 // result without adjusting).\n                 if shadow_seen.len() > seen.len() && shadow_seen.first() == Some(def) {\n                     *force_result = true;\n-                    result = Some(Representability::SelfRecursive(vec![span]));\n+                    result = Some(Representability::SelfRecursive(vec![(sp, field_id)]));\n                 }\n \n                 if result == None {\n@@ -161,16 +178,17 @@ fn are_inner_types_recursive<'tcx>(\n                         result = Some(\n                             match is_type_structurally_recursive(\n                                 tcx,\n-                                span,\n                                 &mut nested_seen,\n                                 shadow_seen,\n                                 representable_cache,\n                                 raw_adt_ty,\n+                                sp,\n+                                field_id,\n                                 force_result,\n                             ) {\n                                 Representability::SelfRecursive(_) => {\n                                     if *force_result {\n-                                        Representability::SelfRecursive(vec![span])\n+                                        Representability::SelfRecursive(vec![(sp, field_id)])\n                                     } else {\n                                         Representability::ContainsRecursive\n                                     }\n@@ -208,15 +226,16 @@ fn are_inner_types_recursive<'tcx>(\n                         result = Some(\n                             match is_type_structurally_recursive(\n                                 tcx,\n-                                span,\n                                 seen,\n                                 shadow_seen,\n                                 representable_cache,\n                                 ty,\n+                                sp,\n+                                field_id,\n                                 force_result,\n                             ) {\n                                 Representability::SelfRecursive(_) => {\n-                                    Representability::SelfRecursive(vec![span])\n+                                    Representability::SelfRecursive(vec![(sp, field_id)])\n                                 }\n                                 x => x,\n                             },\n@@ -247,29 +266,31 @@ fn same_adt<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n // contain any types on stack `seen`?\n fn is_type_structurally_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n     shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n     force_result: &mut bool,\n ) -> Representability {\n-    debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n+    debug!(\"is_type_structurally_recursive: {:?} {:?} {:?}\", ty, sp, field_id);\n     if let Some(representability) = representable_cache.get(&ty) {\n         debug!(\n-            \"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n-            ty, sp, representability\n+            \"is_type_structurally_recursive: {:?} {:?} {:?} - (cached) {:?}\",\n+            ty, sp, field_id, representability\n         );\n         return representability.clone();\n     }\n \n     let representability = is_type_structurally_recursive_inner(\n         tcx,\n-        sp,\n         seen,\n         shadow_seen,\n         representable_cache,\n         ty,\n+        sp,\n+        field_id,\n         force_result,\n     );\n \n@@ -279,11 +300,12 @@ fn is_type_structurally_recursive<'tcx>(\n \n fn is_type_structurally_recursive_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n     shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n     force_result: &mut bool,\n ) -> Representability {\n     match ty.kind() {\n@@ -305,7 +327,7 @@ fn is_type_structurally_recursive_inner<'tcx>(\n                 if let Some(&seen_adt) = iter.next() {\n                     if same_adt(seen_adt, *def) {\n                         debug!(\"SelfRecursive: {:?} contains {:?}\", seen_adt, ty);\n-                        return Representability::SelfRecursive(vec![sp]);\n+                        return Representability::SelfRecursive(vec![(sp, field_id)]);\n                     }\n                 }\n \n@@ -335,11 +357,12 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             shadow_seen.push(*def);\n             let out = are_inner_types_recursive(\n                 tcx,\n-                sp,\n                 seen,\n                 shadow_seen,\n                 representable_cache,\n                 ty,\n+                sp,\n+                field_id,\n                 force_result,\n             );\n             shadow_seen.pop();\n@@ -350,11 +373,12 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             // No need to push in other cases.\n             are_inner_types_recursive(\n                 tcx,\n-                sp,\n                 seen,\n                 shadow_seen,\n                 representable_cache,\n                 ty,\n+                sp,\n+                field_id,\n                 force_result,\n             )\n         }"}, {"sha": "7cb478d78880acbea2f8d1dab399287d91aacb42", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -1045,7 +1045,7 @@ pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalD\n     // recursive type. It is only necessary to throw an error on those that\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n-    match representability::ty_is_representable(tcx, rty, sp) {\n+    match representability::ty_is_representable(tcx, rty, sp, None) {\n         Representability::SelfRecursive(spans) => {\n             recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n             return false;"}, {"sha": "db32eb952ba79796caa6b7fdac16eb13d004536b", "filename": "src/test/ui/issues/issue-17431-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -8,8 +8,8 @@ LL | struct Foo { foo: Option<Option<Foo>> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo { foo: Box<Option<Option<Foo>>> }\n-   |                   ++++                   +\n+LL | struct Foo { foo: Option<Box<Option<Foo>>> }\n+   |                          ++++           +\n \n error: aborting due to previous error\n "}, {"sha": "d23fd1474ac12fe497ea1dd217fadefd9a092811", "filename": "src/test/ui/issues/issue-17431-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -8,8 +8,8 @@ LL | struct Baz { q: Option<Foo> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n    |\n-LL | struct Baz { q: Box<Option<Foo>> }\n-   |                 ++++           +\n+LL | struct Baz { q: Option<Box<Foo>> }\n+   |                        ++++   +\n \n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-2.rs:4:1\n@@ -21,8 +21,8 @@ LL | struct Foo { q: Option<Baz> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo { q: Box<Option<Baz>> }\n-   |                 ++++           +\n+LL | struct Foo { q: Option<Box<Baz>> }\n+   |                        ++++   +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ddf669b8fd1cb6733773b069185e7a1b0ec73dcc", "filename": "src/test/ui/issues/issue-17431-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -8,8 +8,8 @@ LL | struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T>\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo<T> { foo: Box<Option<Option<Foo<T>>>>, marker: marker::PhantomData<T> }\n-   |                      ++++                      +\n+LL | struct Foo<T> { foo: Option<Box<Option<Foo<T>>>>, marker: marker::PhantomData<T> }\n+   |                             ++++              +\n \n error: aborting due to previous error\n "}, {"sha": "6f8a7e3867b099eb6987f52bc1137f8881f475b3", "filename": "src/test/ui/issues/issue-17431-7.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -8,8 +8,8 @@ LL | enum Foo { Voo(Option<Option<Foo>>) }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | enum Foo { Voo(Box<Option<Option<Foo>>>) }\n-   |                ++++                   +\n+LL | enum Foo { Voo(Option<Box<Option<Foo>>>) }\n+   |                       ++++           +\n \n error: aborting due to previous error\n "}, {"sha": "e853d0f8c8932d98ff5bd743ca95385264edffd4", "filename": "src/test/ui/issues/issue-3779.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -9,8 +9,8 @@ LL |     element: Option<S>\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `S` representable\n    |\n-LL |     element: Box<Option<S>>\n-   |              ++++         +\n+LL |     element: Option<Box<S>>\n+   |                     ++++ +\n \n error: aborting due to previous error\n "}, {"sha": "536510814c57ca7f8ea2705653cff351d92ace7c", "filename": "src/test/ui/sized-cycle-note.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized-cycle-note.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -8,8 +8,8 @@ LL | struct Baz { q: Option<Foo> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n    |\n-LL | struct Baz { q: Box<Option<Foo>> }\n-   |                 ++++           +\n+LL | struct Baz { q: Option<Box<Foo>> }\n+   |                        ++++   +\n \n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/sized-cycle-note.rs:11:1\n@@ -21,8 +21,8 @@ LL | struct Foo { q: Option<Baz> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo { q: Box<Option<Baz>> }\n-   |                 ++++           +\n+LL | struct Foo { q: Option<Box<Baz>> }\n+   |                        ++++   +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "882ed577cf36626d00bf63a6fb55d23c2f3c2f6b", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -9,8 +9,8 @@ LL |     tail: Option<ListNode>,\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n    |\n-LL |     tail: Box<Option<ListNode>>,\n-   |           ++++                +\n+LL |     tail: Option<Box<ListNode>>,\n+   |                  ++++        +\n \n error: aborting due to previous error\n "}, {"sha": "acfc60b51f330892710429c476ccfbc1ba26f27e", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -12,8 +12,8 @@ LL | | }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n    |\n-LL |     tail: Box<Option<ListNode>>,\n-   |           ++++                +\n+LL |     tail: Option<Box<ListNode>>,\n+   |                  ++++        +\n \n error: aborting due to previous error\n "}, {"sha": "80a494f3f65eb20d83ecf57aa34b381a456f5ed3", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -37,8 +37,8 @@ LL |     y: Option<Option<D<T>>>,\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `C` representable\n    |\n-LL |     y: Box<Option<Option<D<T>>>>,\n-   |        ++++                    +\n+LL |     y: Option<Box<Option<D<T>>>>,\n+   |               ++++            +\n \n error[E0072]: recursive type `D` has infinite size\n   --> $DIR/mutual-struct-recursion.rs:18:1\n@@ -51,8 +51,8 @@ LL |     z: Option<Option<C<T>>>,\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `D` representable\n    |\n-LL |     z: Box<Option<Option<C<T>>>>,\n-   |        ++++                    +\n+LL |     z: Option<Box<Option<C<T>>>>,\n+   |               ++++            +\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e8084f0d0826af0b18b2d0ebaf513c31a59c3175", "filename": "src/test/ui/type/type-recursive.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.rs?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -1,6 +1,30 @@\n struct T1 { //~ ERROR E0072\n     foo: isize,\n-    foolish: T1\n+    foolish: T1,\n+}\n+\n+struct T2 { //~ ERROR E0072\n+    inner: Option<T2>,\n+}\n+\n+type OptionT3 = Option<T3>;\n+\n+struct T3 { //~ ERROR E0072\n+    inner: OptionT3,\n+}\n+\n+struct T4(Option<T4>); //~ ERROR E0072\n+\n+enum T5 { //~ ERROR E0072\n+    Variant(Option<T5>),\n+}\n+\n+enum T6 { //~ ERROR E0072\n+    Variant{ field: Option<T6> },\n+}\n+\n+struct T7 { //~ ERROR E0072\n+    foo: std::cell::Cell<Option<T7>>,\n }\n \n fn main() { }"}, {"sha": "04392f7390dfc3fd52cbc764c46909f62116111b", "filename": "src/test/ui/type/type-recursive.stderr", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de04c05dea10fc03cb626338ce1d55f4c90f58b0/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr?ref=de04c05dea10fc03cb626338ce1d55f4c90f58b0", "patch": "@@ -4,14 +4,93 @@ error[E0072]: recursive type `T1` has infinite size\n LL | struct T1 {\n    | ^^^^^^^^^ recursive type has infinite size\n LL |     foo: isize,\n-LL |     foolish: T1\n+LL |     foolish: T1,\n    |              -- recursive without indirection\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T1` representable\n    |\n-LL |     foolish: Box<T1>\n+LL |     foolish: Box<T1>,\n    |              ++++  +\n \n-error: aborting due to previous error\n+error[E0072]: recursive type `T2` has infinite size\n+  --> $DIR/type-recursive.rs:6:1\n+   |\n+LL | struct T2 {\n+   | ^^^^^^^^^ recursive type has infinite size\n+LL |     inner: Option<T2>,\n+   |            ---------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T2` representable\n+   |\n+LL |     inner: Option<Box<T2>>,\n+   |                   ++++  +\n+\n+error[E0072]: recursive type `T3` has infinite size\n+  --> $DIR/type-recursive.rs:12:1\n+   |\n+LL | struct T3 {\n+   | ^^^^^^^^^ recursive type has infinite size\n+LL |     inner: OptionT3,\n+   |            -------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T3` representable\n+   |\n+LL |     inner: Box<OptionT3>,\n+   |            ++++        +\n+\n+error[E0072]: recursive type `T4` has infinite size\n+  --> $DIR/type-recursive.rs:16:1\n+   |\n+LL | struct T4(Option<T4>);\n+   | ^^^^^^^^^^----------^^\n+   | |         |\n+   | |         recursive without indirection\n+   | recursive type has infinite size\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T4` representable\n+   |\n+LL | struct T4(Option<Box<T4>>);\n+   |                  ++++  +\n+\n+error[E0072]: recursive type `T5` has infinite size\n+  --> $DIR/type-recursive.rs:18:1\n+   |\n+LL | enum T5 {\n+   | ^^^^^^^ recursive type has infinite size\n+LL |     Variant(Option<T5>),\n+   |             ---------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T5` representable\n+   |\n+LL |     Variant(Option<Box<T5>>),\n+   |                    ++++  +\n+\n+error[E0072]: recursive type `T6` has infinite size\n+  --> $DIR/type-recursive.rs:22:1\n+   |\n+LL | enum T6 {\n+   | ^^^^^^^ recursive type has infinite size\n+LL |     Variant{ field: Option<T6> },\n+   |                     ---------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T6` representable\n+   |\n+LL |     Variant{ field: Option<Box<T6>> },\n+   |                            ++++  +\n+\n+error[E0072]: recursive type `T7` has infinite size\n+  --> $DIR/type-recursive.rs:26:1\n+   |\n+LL | struct T7 {\n+   | ^^^^^^^^^ recursive type has infinite size\n+LL |     foo: std::cell::Cell<Option<T7>>,\n+   |          --------------------------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T7` representable\n+   |\n+LL |     foo: Box<std::cell::Cell<Option<T7>>>,\n+   |          ++++                           +\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0072`."}]}