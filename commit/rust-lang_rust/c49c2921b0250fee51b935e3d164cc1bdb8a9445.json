{"sha": "c49c2921b0250fee51b935e3d164cc1bdb8a9445", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OWMyOTIxYjAyNTBmZWU1MWI5MzVlM2QxNjRjYzFiZGI4YTk0NDU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-17T00:47:35Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: add read and unlink to low-level FileDescriptor + end-to-end CRUD test", "tree": {"sha": "0e00def1ca96a9ee9a56a445b9dbbae4386091c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e00def1ca96a9ee9a56a445b9dbbae4386091c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c49c2921b0250fee51b935e3d164cc1bdb8a9445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c49c2921b0250fee51b935e3d164cc1bdb8a9445", "html_url": "https://github.com/rust-lang/rust/commit/c49c2921b0250fee51b935e3d164cc1bdb8a9445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c49c2921b0250fee51b935e3d164cc1bdb8a9445/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dabbac1d6c06c00f24148ffc58b42455496fdd3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dabbac1d6c06c00f24148ffc58b42455496fdd3c", "html_url": "https://github.com/rust-lang/rust/commit/dabbac1d6c06c00f24148ffc58b42455496fdd3c"}], "stats": {"total": 209, "additions": 151, "deletions": 58}, "files": [{"sha": "ef8c131688b44dd448411548468486cb6eb198ba", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 106, "deletions": 53, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=c49c2921b0250fee51b935e3d164cc1bdb8a9445", "patch": "@@ -13,12 +13,14 @@ use ptr::null;\n use libc::c_void;\n use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n              status_to_maybe_uv_error_with_loop,\n-             vec_to_uv_buf};//, vec_from_uv_buf};\n+             vec_to_uv_buf, vec_from_uv_buf};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use path::Path;\n use cast::transmute;\n use libc::{c_int};\n+use option::{None, Some, Option};\n+use vec;\n \n pub struct FsRequest(*uvll::uv_fs_t);\n impl Request for FsRequest;\n@@ -110,7 +112,15 @@ impl FsRequest {\n     fn cleanup_and_delete(self) {\n         unsafe {\n             let data = uvll::get_data_for_req(self.native_handle());\n-            let _data = transmute::<*c_void, ~RequestData>(data);\n+            let mut _data = transmute::<*c_void, ~RequestData>(data);\n+            // if set we're going to convert the buf param back into\n+            // a rust vec, as that's the mechanism by which the raw\n+            // uv_buf_t's .base field gets freed. We immediately discard\n+            // the result\n+            if _data.buf.is_some() {\n+                let buf = _data.buf.take_unwrap();\n+                vec_from_uv_buf(buf);\n+            }\n             uvll::set_data_for_req(self.native_handle(), null::<()>());\n             uvll::fs_req_cleanup(self.native_handle());\n             free_req(self.native_handle() as *c_void)\n@@ -146,6 +156,15 @@ impl FileDescriptor {\n         })\n     }\n \n+    pub fn unlink(loop_: Loop, path: Path, cb: FsCallback) -> int {\n+        let req = FsRequest::new(Some(cb));\n+        path.to_str().to_c_str().with_ref(|p| unsafe {\n+            uvll::fs_unlink(loop_.native_handle(),\n+                          req.native_handle(), p, complete_cb) as int\n+        })\n+    }\n+\n+    // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n     pub fn write(&self, loop_: Loop, buf: ~[u8], offset: i64, cb: FsCallback)\n           -> int {\n         let mut req = FsRequest::new(Some(cb));\n@@ -161,6 +180,31 @@ impl FileDescriptor {\n         }\n     }\n \n+    // really contemplated having this just take a read_len param and have\n+    // the buf live in the scope of this request.. but decided that exposing\n+    // an unsafe mechanism that takes a buf_ptr and len would be much more\n+    // flexible, but the caller is now in the position of managing that\n+    // buf (with all of the sadface that this entails)\n+    pub fn read(&self, loop_: Loop, buf_ptr: Option<*c_void>, len: uint, offset: i64, cb: FsCallback)\n+          -> int {\n+        let mut req = FsRequest::new(Some(cb));\n+        req.get_req_data().raw_fd = Some(self.native_handle());\n+        unsafe {\n+            let buf_ptr = match buf_ptr {\n+                Some(ptr) => ptr,\n+                None => {\n+                    let buf = vec::from_elem(len, 0u8);\n+                    let buf = vec_to_uv_buf(buf);\n+                    req.get_req_data().buf = Some(buf);\n+                    buf.base as *c_void\n+                }\n+            };\n+            uvll::fs_read(loop_.native_handle(), req.native_handle(),\n+                           self.native_handle(), buf_ptr,\n+                           len, offset, complete_cb) as int\n+        }\n+    }\n+\n     pub fn close(self, loop_: Loop, cb: FsCallback) -> int {\n         let req = FsRequest::new(Some(cb));\n         unsafe {\n@@ -205,90 +249,99 @@ impl NativeHandle<c_int> for FileDescriptor {\n mod test {\n     use super::*;\n     //use rt::test::*;\n+    use libc::{STDOUT_FILENO};\n+    use str;\n     use unstable::run_in_bare_thread;\n     use path::Path;\n-    use rt::uv::{Loop};//, slice_to_uv_buf};\n-\n-    // this is equiv to touch, i guess?\n-    fn file_test_touch_impl() {\n-        debug!(\"hello?\")\n-        do run_in_bare_thread {\n-            debug!(\"In bare thread\")\n-            let mut loop_ = Loop::new();\n-            let flags = map_flag(O_RDWR) |\n-                map_flag(O_CREAT);\n-            // 0644\n-            let mode = map_mode(S_IWUSR) |\n-                map_mode(S_IRUSR) |\n-                map_mode(S_IRGRP) |\n-                map_mode(S_IROTH);\n-            do FileDescriptor::open(loop_, Path(\"./foo.txt\"), flags, mode)\n-            |req, uverr| {\n-                let loop_ = req.get_loop();\n-                assert!(uverr.is_none());\n-                let fd = FileDescriptor::from_open_req(req);\n-                do fd.close(loop_) |_, uverr| {\n-                    assert!(uverr.is_none());\n-                };\n-            };\n-            loop_.run();\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_touch() {\n-        file_test_touch_impl();\n-    }\n+    use rt::uv::{Loop, vec_from_uv_buf};//, slice_to_uv_buf};\n+    use option::{None};\n \n-    fn file_test_tee_impl() {\n+    fn file_test_full_simple_impl() {\n         debug!(\"hello?\")\n         do run_in_bare_thread {\n             debug!(\"In bare thread\")\n             let mut loop_ = Loop::new();\n-            let flags = map_flag(O_RDWR) |\n+            let create_flags = map_flag(O_RDWR) |\n                 map_flag(O_CREAT);\n+            let read_flags = map_flag(O_RDONLY);\n             // 0644\n             let mode = map_mode(S_IWUSR) |\n                 map_mode(S_IRUSR) |\n                 map_mode(S_IRGRP) |\n                 map_mode(S_IROTH);\n-            do FileDescriptor::open(loop_, Path(\"./file_tee_test.txt\"), flags, mode)\n+            let path_str = \"./file_full_simple.txt\";\n+            let write_val = \"hello\";\n+            do FileDescriptor::open(loop_, Path(path_str), create_flags, mode)\n             |req, uverr| {\n                 let loop_ = req.get_loop();\n                 assert!(uverr.is_none());\n                 let fd = FileDescriptor::from_open_req(req);\n-                let msg: ~[u8] = \"hello world\".as_bytes().to_owned();\n+                let msg: ~[u8] = write_val.as_bytes().to_owned();\n                 let raw_fd = fd.native_handle();\n                 do fd.write(loop_, msg, -1) |_, uverr| {\n                     let fd = FileDescriptor(raw_fd);\n-                    do fd.close(loop_) |_, _| {\n+                    do fd.close(loop_) |req, _| {\n+                        let loop_ = req.get_loop();\n                         assert!(uverr.is_none());\n+                        do FileDescriptor::open(loop_, Path(path_str), read_flags,0)\n+                            |req, uverr| {\n+                            assert!(uverr.is_none());\n+                            let loop_ = req.get_loop();\n+                            let len = 1028;\n+                            let fd = FileDescriptor::from_open_req(req);\n+                            let raw_fd = fd.native_handle();\n+                            do fd.read(loop_, None, len, 0) |req, uverr| {\n+                                assert!(uverr.is_none());\n+                                let loop_ = req.get_loop();\n+                                // we know nread >=0 because uverr is none..\n+                                let nread = req.get_result() as uint;\n+                                // nread == 0 would be EOF\n+                                if nread > 0 {\n+                                    let buf = vec_from_uv_buf(\n+                                        req.get_req_data().buf.take_unwrap())\n+                                        .take_unwrap();\n+                                    let read_str = str::from_bytes(\n+                                        buf.slice(0,\n+                                                  nread));\n+                                    assert!(read_str == ~\"hello\");\n+                                    do FileDescriptor(raw_fd).close(loop_) |_,uverr| {\n+                                        assert!(uverr.is_none());\n+                                        do FileDescriptor::unlink(loop_, Path(path_str))\n+                                        |_,uverr| {\n+                                            assert!(uverr.is_none());\n+                                        };\n+                                    };\n+                                }\n+                            };\n+                        };\n                     };\n                 };\n             };\n             loop_.run();\n+            loop_.close();\n         }\n     }\n \n     #[test]\n-    fn file_test_tee() {\n-        file_test_tee_impl();\n+    fn file_test_full_simple() {\n+        file_test_full_simple_impl();\n     }\n \n-    fn naive_print(input: ~str) {\n-        do run_in_bare_thread {\n-            let mut loop_ = Loop::new();\n-            let stdout = FileDescriptor(1);\n-            let msg = input.as_bytes().to_owned();\n-            do stdout.write(loop_, msg, -1) |_, uverr| {\n-                assert!(uverr.is_none());\n-            };\n-            loop_.run();\n-        }\n+    fn naive_print(loop_: Loop, input: ~str) {\n+        let stdout = FileDescriptor(STDOUT_FILENO);\n+        let msg = input.as_bytes().to_owned();\n+        do stdout.write(loop_, msg, -1) |_, uverr| {\n+            assert!(uverr.is_none());\n+        };\n     }\n \n     #[test]\n-    fn file_test_println() {\n-        naive_print(~\"oh yeah.\\n\");\n+    fn file_test_write_to_stdout() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            naive_print(loop_, ~\"zanzibar!\\n\");\n+            loop_.run();\n+            loop_.close();\n+        };\n     }\n }"}, {"sha": "1b257b708c47a2d7473871b08b05176393691566", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=c49c2921b0250fee51b935e3d164cc1bdb8a9445", "patch": "@@ -621,10 +621,19 @@ pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags:\n                 cb: *u8) -> c_int {\n     rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n }\n+\n+pub unsafe fn fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                cb: *u8) -> c_int {\n+    rust_uv_fs_unlink(loop_ptr, req, path, cb)\n+}\n pub unsafe fn fs_write(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n                        len: uint, offset: i64, cb: *u8) -> c_int {\n     rust_uv_fs_write(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n }\n+pub unsafe fn fs_read(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                       len: uint, offset: i64, cb: *u8) -> c_int {\n+    rust_uv_fs_read(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n+}\n pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n                 cb: *u8) -> c_int {\n     rust_uv_fs_close(loop_ptr, req, fd, cb)\n@@ -817,8 +826,12 @@ extern {\n     fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n     fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n                        flags: c_int, mode: c_int, cb: *u8) -> c_int;\n+    fn rust_uv_fs_unlink(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n+                       cb: *u8) -> c_int;\n     fn rust_uv_fs_write(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n                        buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n+    fn rust_uv_fs_read(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n+                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n     fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n                         cb: *u8) -> c_int;\n     fn rust_uv_fs_req_cleanup(req: *uv_fs_t);"}, {"sha": "e08b4ac21ebf92562cd73cce94d04a7f3b6f2009", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=c49c2921b0250fee51b935e3d164cc1bdb8a9445", "patch": "@@ -13,11 +13,6 @@\n #include <malloc.h>\n #endif\n \n-#ifndef __WIN32__\n-// for signal\n-#include <signal.h>\n-#endif\n-\n #include <fcntl.h>\n #include \"uv.h\"\n \n@@ -521,6 +516,20 @@ rust_uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n   return uv_fs_open(loop, req, path, flags, mode, cb);\n }\n extern \"C\" int\n+rust_uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n+  return uv_fs_unlink(loop, req, path, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n+                 size_t len, int64_t offset, uv_fs_cb cb) {\n+  return uv_fs_write(loop, req, fd, buf, len, offset, cb);\n+}\n+extern \"C\" int\n+rust_uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n+                 size_t len, int64_t offset, uv_fs_cb cb) {\n+  return uv_fs_read(loop, req, fd, buf, len, offset, cb);\n+}\n+extern \"C\" int\n rust_uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {\n   return uv_fs_close(loop, req, fd, cb);\n }\n@@ -549,6 +558,22 @@ rust_uv_get_O_TRUNC() {\n   return O_TRUNC;\n }\n extern \"C\" int\n+rust_uv_get_S_IWUSR() {\n+  return S_IWUSR;\n+}\n+extern \"C\" int\n+rust_uv_get_S_IRUSR() {\n+  return S_IRUSR;\n+}\n+extern \"C\" int\n+rust_uv_get_S_IRGRP() {\n+  return S_IRGRP;\n+}\n+extern \"C\" int\n+rust_uv_get_S_IROTH() {\n+  return S_IROTH;\n+}\n+extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n }"}, {"sha": "824a3931771e50356c273cf2314343e535fbd87a", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/c49c2921b0250fee51b935e3d164cc1bdb8a9445/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=c49c2921b0250fee51b935e3d164cc1bdb8a9445", "patch": "@@ -109,7 +109,9 @@ rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_idle_stop\n rust_uv_fs_open\n+rust_uv_fs_unlink\n rust_uv_fs_write\n+rust_uv_fs_read\n rust_uv_fs_close\n rust_uv_get_O_RDONLY\n rust_uv_get_O_WRONLY"}]}