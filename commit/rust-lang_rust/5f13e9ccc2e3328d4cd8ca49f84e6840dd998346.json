{"sha": "5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMTNlOWNjYzJlMzMyOGQ0Y2Q4Y2E0OWY4NGU2ODQwZGQ5OTgzNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-02T20:36:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-02T20:36:51Z"}, "message": "auto merge of #5678 : Thiez/rust/no-Mut, r=thestinger\n\nThis pull request completely removes Mut<T> and the associated file (libcore/mutable.rs). Some minor changes were made to workcache (libstd/workcache.rs) as it was using Mut.\r\n\r\nr?", "tree": {"sha": "6e507951163f39e06f80387a0edde2b71c88f40f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e507951163f39e06f80387a0edde2b71c88f40f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "html_url": "https://github.com/rust-lang/rust/commit/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00dbbd01c2aee72982b3e0f9511ae1d4428c3ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/00dbbd01c2aee72982b3e0f9511ae1d4428c3ba9", "html_url": "https://github.com/rust-lang/rust/commit/00dbbd01c2aee72982b3e0f9511ae1d4428c3ba9"}, {"sha": "f43e6af38d742b9b6d4c697e48ea239d7ef154c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f43e6af38d742b9b6d4c697e48ea239d7ef154c2", "html_url": "https://github.com/rust-lang/rust/commit/f43e6af38d742b9b6d4c697e48ea239d7ef154c2"}], "stats": {"total": 291, "additions": 60, "deletions": 231}, "files": [{"sha": "f7c64e3f37445f0138ac0070213bf4556ff6b2d2", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "patch": "@@ -212,7 +212,6 @@ pub mod rand;\n pub mod run;\n pub mod sys;\n pub mod cast;\n-pub mod mutable;\n pub mod flate;\n pub mod repr;\n pub mod cleanup;"}, {"sha": "e9639820e836b6c9a9d7c0617e31cca93c86a862", "filename": "src/libcore/mutable.rs", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/00dbbd01c2aee72982b3e0f9511ae1d4428c3ba9/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00dbbd01c2aee72982b3e0f9511ae1d4428c3ba9/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=00dbbd01c2aee72982b3e0f9511ae1d4428c3ba9", "patch": "@@ -1,158 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Module for wrapping freezable data structures in managed boxes.\n-Normally freezable data structures require an unaliased reference,\n-such as `T` or `~T`, so that the compiler can track when they are\n-being mutated.  The `managed<T>` type converts these static checks into\n-dynamic checks: your program will fail if you attempt to perform\n-mutation when the data structure should be immutable.\n-\n-*/\n-\n-use util::with;\n-use cast::transmute_immut;\n-\n-enum Mode { ReadOnly, Mutable, Immutable }\n-\n-struct Data<T> {\n-    priv mut value: T,\n-    priv mut mode: Mode\n-}\n-\n-pub type Mut<T> = Data<T>;\n-\n-pub fn Mut<T>(t: T) -> Mut<T> {\n-    Data {value: t, mode: ReadOnly}\n-}\n-\n-pub fn unwrap<T>(m: Mut<T>) -> T {\n-    // Borrowck should prevent us from calling unwrap while the value\n-    // is in use, as that would be a move from a borrowed value.\n-    assert!((m.mode as uint) == (ReadOnly as uint));\n-    let Data {value: value, mode: _} = m;\n-    value\n-}\n-\n-pub impl<T> Data<T> {\n-    fn borrow_mut<R>(&self, op: &fn(t: &mut T) -> R) -> R {\n-        match self.mode {\n-            Immutable => fail!(~\"currently immutable\"),\n-            ReadOnly | Mutable => {}\n-        }\n-\n-        do with(&mut self.mode, Mutable) {\n-            op(&mut self.value)\n-        }\n-    }\n-\n-    fn borrow_const<R>(&self, op: &fn(t: &const T) -> R) -> R {\n-        op(&const self.value)\n-    }\n-\n-    fn borrow_imm<R>(&self, op: &fn(t: &T) -> R) -> R {\n-        match self.mode {\n-          Mutable => fail!(~\"currently mutable\"),\n-          ReadOnly | Immutable => {}\n-        }\n-\n-        do with(&mut self.mode, Immutable) {\n-            op(unsafe{transmute_immut(&mut self.value)})\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn unwrap(self) -> T { unwrap(self) }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-#[should_fail]\n-pub fn test_mut_in_imm() {\n-    let m = @Mut(1);\n-    do m.borrow_imm |_p| {\n-        do m.borrow_mut |_q| {\n-            // should not be permitted\n-        }\n-    }\n-}\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-#[should_fail]\n-pub fn test_imm_in_mut() {\n-    let m = @Mut(1);\n-    do m.borrow_mut |_p| {\n-        do m.borrow_imm |_q| {\n-            // should not be permitted\n-        }\n-    }\n-}\n-\n-#[test]\n-pub fn test_const_in_mut() {\n-    let m = @Mut(1);\n-    do m.borrow_mut |p| {\n-        do m.borrow_const |q| {\n-            assert!(*p == *q);\n-            *p += 1;\n-            assert!(*p == *q);\n-        }\n-    }\n-}\n-\n-#[test]\n-pub fn test_mut_in_const() {\n-    let m = @Mut(1);\n-    do m.borrow_const |p| {\n-        do m.borrow_mut |q| {\n-            assert!(*p == *q);\n-            *q += 1;\n-            assert!(*p == *q);\n-        }\n-    }\n-}\n-\n-#[test]\n-pub fn test_imm_in_const() {\n-    let m = @Mut(1);\n-    do m.borrow_const |p| {\n-        do m.borrow_imm |q| {\n-            assert!(*p == *q);\n-        }\n-    }\n-}\n-\n-#[test]\n-pub fn test_const_in_imm() {\n-    let m = @Mut(1);\n-    do m.borrow_imm |p| {\n-        do m.borrow_const |q| {\n-            assert!(*p == *q);\n-        }\n-    }\n-}\n-\n-\n-#[test]\n-#[ignore(cfg(windows))]\n-#[should_fail]\n-pub fn test_mut_in_imm_in_const() {\n-    let m = @Mut(1);\n-    do m.borrow_const |_p| {\n-        do m.borrow_imm |_q| {\n-            do m.borrow_mut |_r| {\n-            }\n-        }\n-    }\n-}\n-"}, {"sha": "6ed1364d7fcb208e7efee3671e6edd2c6b0dab39", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 60, "deletions": 72, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f13e9ccc2e3328d4cd8ca49f84e6840dd998346/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=5f13e9ccc2e3328d4cd8ca49f84e6840dd998346", "patch": "@@ -27,7 +27,6 @@ use core::run;\n use core::hashmap::linear::LinearMap;\n use core::task;\n use core::to_bytes;\n-use core::mutable::Mut;\n \n /**\n *\n@@ -168,7 +167,7 @@ impl<D:Decoder> Decodable<D> for WorkMap {\n struct Database {\n     db_filename: Path,\n     db_cache: LinearMap<~str, ~str>,\n-    mut db_dirty: bool\n+    db_dirty: bool\n }\n \n pub impl Database {\n@@ -210,8 +209,8 @@ pub impl Logger {\n }\n \n struct Context {\n-    db: @Mut<Database>,\n-    logger: @Mut<Logger>,\n+    db: @mut Database,\n+    logger: @mut Logger,\n     cfg: @json::Object,\n     freshness: LinearMap<~str,@fn(&str,&str)->bool>\n }\n@@ -228,7 +227,7 @@ struct Exec {\n }\n \n struct Work<T> {\n-    prep: @Mut<Prep>,\n+    prep: @mut Prep,\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n@@ -261,8 +260,8 @@ fn digest_file(path: &Path) -> ~str {\n \n pub impl Context {\n \n-    fn new(db: @Mut<Database>,\n-                  lg: @Mut<Logger>,\n+    fn new(db: @mut Database,\n+                  lg: @mut Logger,\n                   cfg: @json::Object) -> Context {\n         Context {\n             db: db,\n@@ -277,19 +276,19 @@ pub impl Context {\n               Decodable<json::Decoder>>( // FIXME(#5121)\n                   @self,\n                   fn_name:&str,\n-                  blk: &fn(@Mut<Prep>)->Work<T>) -> Work<T> {\n-        let p = @Mut(Prep {\n+                  blk: &fn(@mut Prep)->Work<T>) -> Work<T> {\n+        let p = @mut Prep {\n             ctxt: self,\n             fn_name: fn_name.to_owned(),\n             declared_inputs: WorkMap::new()\n-        });\n+        };\n         blk(p)\n     }\n }\n \n \n trait TPrep {\n-    fn declare_input(&self, kind:&str, name:&str, val:&str);\n+    fn declare_input(&mut self, kind:&str, name:&str, val:&str);\n     fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n     fn exec<T:Owned +\n@@ -298,30 +297,25 @@ trait TPrep {\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n-impl TPrep for @Mut<Prep> {\n-    fn declare_input(&self, kind:&str, name:&str, val:&str) {\n-        do self.borrow_mut |p| {\n-            p.declared_inputs.insert(WorkKey::new(kind, name),\n-                                     val.to_owned());\n-        }\n+impl TPrep for Prep {\n+    fn declare_input(&mut self, kind:&str, name:&str, val:&str) {\n+        self.declared_inputs.insert(WorkKey::new(kind, name),\n+                                 val.to_owned());\n     }\n \n     fn is_fresh(&self, cat: &str, kind: &str,\n                 name: &str, val: &str) -> bool {\n-        do self.borrow_imm |p| {\n-            let k = kind.to_owned();\n-            let f = (*p.ctxt.freshness.get(&k))(name, val);\n-            do p.ctxt.logger.borrow_imm |lg| {\n-                if f {\n-                    lg.info(fmt!(\"%s %s:%s is fresh\",\n-                                 cat, kind, name));\n-                } else {\n-                    lg.info(fmt!(\"%s %s:%s is not fresh\",\n-                                 cat, kind, name))\n-                }\n+        let k = kind.to_owned();\n+        let f = (*self.ctxt.freshness.get(&k))(name, val);\n+        let lg = self.ctxt.logger;\n+            if f {\n+                lg.info(fmt!(\"%s %s:%s is fresh\",\n+                             cat, kind, name));\n+            } else {\n+                lg.info(fmt!(\"%s %s:%s is not fresh\",\n+                             cat, kind, name))\n             }\n-            f\n-        }\n+        f\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n@@ -339,38 +333,34 @@ impl TPrep for @Mut<Prep> {\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n         let mut bo = Some(blk);\n \n-        do self.borrow_imm |p| {\n-            let cached = do p.ctxt.db.borrow_mut |db| {\n-                db.prepare(p.fn_name, &p.declared_inputs)\n-            };\n+        let cached = self.ctxt.db.prepare(self.fn_name, &self.declared_inputs);\n \n-            match cached {\n-                Some((ref disc_in, ref disc_out, ref res))\n-                if self.all_fresh(\"declared input\",\n-                                  &p.declared_inputs) &&\n-                self.all_fresh(\"discovered input\", disc_in) &&\n-                self.all_fresh(\"discovered output\", disc_out) => {\n-                    Work::new(*self, Left(json_decode(*res)))\n-                }\n+        match cached {\n+            Some((ref disc_in, ref disc_out, ref res))\n+            if self.all_fresh(\"declared input\",\n+                              &self.declared_inputs) &&\n+            self.all_fresh(\"discovered input\", disc_in) &&\n+            self.all_fresh(\"discovered output\", disc_out) => {\n+                Work::new(@mut *self, Left(json_decode(*res)))\n+            }\n \n-                _ => {\n-                    let (chan, port) = oneshot::init();\n-                    let mut blk = None;\n-                    blk <-> bo;\n-                    let blk = blk.unwrap();\n-                    let chan = Cell(chan);\n-                    do task::spawn || {\n-                        let exe = Exec {\n-                            discovered_inputs: WorkMap::new(),\n-                            discovered_outputs: WorkMap::new(),\n-                        };\n-                        let chan = chan.take();\n-                        let v = blk(&exe);\n-                        send_one(chan, (exe, v));\n-                    }\n-\n-                    Work::new(*self, Right(port))\n+            _ => {\n+                let (chan, port) = oneshot::init();\n+                let mut blk = None;\n+                blk <-> bo;\n+                let blk = blk.unwrap();\n+                let chan = Cell(chan);\n+\n+                do task::spawn || {\n+                    let exe = Exec {\n+                        discovered_inputs: WorkMap::new(),\n+                        discovered_outputs: WorkMap::new(),\n+                    };\n+                    let chan = chan.take();\n+                    let v = blk(&exe);\n+                    send_one(chan, (exe, v));\n                 }\n+                Work::new(@mut *self, Right(port))\n             }\n         }\n     }\n@@ -379,7 +369,7 @@ impl TPrep for @Mut<Prep> {\n pub impl<T:Owned +\n          Encodable<json::Encoder> +\n          Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n-    fn new(p: @Mut<Prep>, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+    fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n         Work { prep: p, res: Some(e) }\n     }\n }\n@@ -404,15 +394,13 @@ fn unwrap<T:Owned +\n \n             let s = json_encode(&v);\n \n-            do ww.prep.borrow_imm |p| {\n-                do p.ctxt.db.borrow_mut |db| {\n-                    db.cache(p.fn_name,\n-                             &p.declared_inputs,\n-                             &exe.discovered_inputs,\n-                             &exe.discovered_outputs,\n-                             s);\n-                }\n-            }\n+            let p = &*ww.prep;\n+            let db = p.ctxt.db;\n+            db.cache(p.fn_name,\n+                 &p.declared_inputs,\n+                 &exe.discovered_inputs,\n+                 &exe.discovered_outputs,\n+                 s);\n             v\n         }\n     }\n@@ -422,10 +410,10 @@ fn unwrap<T:Owned +\n fn test() {\n     use core::io::WriterUtil;\n \n-    let db = @Mut(Database { db_filename: Path(\"db.json\"),\n+    let db = @mut Database { db_filename: Path(\"db.json\"),\n                              db_cache: LinearMap::new(),\n-                             db_dirty: false });\n-    let lg = @Mut(Logger { a: () });\n+                             db_dirty: false };\n+    let lg = @mut Logger { a: () };\n     let cfg = @LinearMap::new();\n     let cx = @Context::new(db, lg, cfg);\n     let w:Work<~str> = do cx.prep(\"test1\") |prep| {"}]}