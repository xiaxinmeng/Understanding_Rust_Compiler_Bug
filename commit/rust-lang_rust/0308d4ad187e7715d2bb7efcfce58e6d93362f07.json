{"sha": "0308d4ad187e7715d2bb7efcfce58e6d93362f07", "node_id": "C_kwDOAAsO6NoAKDAzMDhkNGFkMTg3ZTc3MTVkMmJiN2VmY2ZjZTU4ZTZkOTMzNjJmMDc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-10T21:41:11Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-28T01:02:15Z"}, "message": "Compute bound vars correctly", "tree": {"sha": "c1b87d4c299a6c99a2655d89f686cb13e69e1492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1b87d4c299a6c99a2655d89f686cb13e69e1492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0308d4ad187e7715d2bb7efcfce58e6d93362f07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0308d4ad187e7715d2bb7efcfce58e6d93362f07", "html_url": "https://github.com/rust-lang/rust/commit/0308d4ad187e7715d2bb7efcfce58e6d93362f07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0308d4ad187e7715d2bb7efcfce58e6d93362f07/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "773e8a5ad1fa012bc1574c6733a700e094a48e3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/773e8a5ad1fa012bc1574c6733a700e094a48e3d", "html_url": "https://github.com/rust-lang/rust/commit/773e8a5ad1fa012bc1574c6733a700e094a48e3d"}], "stats": {"total": 125, "additions": 108, "deletions": 17}, "files": [{"sha": "8334393001002b11d94d9f543221158c00b33e43", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0308d4ad187e7715d2bb7efcfce58e6d93362f07/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0308d4ad187e7715d2bb7efcfce58e6d93362f07/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0308d4ad187e7715d2bb7efcfce58e6d93362f07", "patch": "@@ -1088,7 +1088,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // TODO: rtn comment goes here\n         let associated_return_type_bound =\n-            binding.gen_args.parenthesized && self.tcx().features().associated_return_type_bounds;\n+            binding.gen_args.parenthesized && tcx.features().associated_return_type_bounds;\n \n         let candidate = if return_type_notation {\n             if self.trait_defines_associated_item_named(\n@@ -1156,7 +1156,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             dup_bindings\n                 .entry(assoc_item.def_id)\n                 .and_modify(|prev_span| {\n-                    self.tcx().sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n+                    tcx.sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n                         span: binding.span,\n                         prev_span: *prev_span,\n                         item_name: binding.item_name,\n@@ -1166,14 +1166,53 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .or_insert(binding.span);\n         }\n \n-        let projection_ty = if associated_return_type_bound {\n-            let generics = self.tcx().generics_of(assoc_item.def_id);\n-            if !generics.params.is_empty() {\n-                todo!();\n-            }\n-            let output = self.tcx().fn_sig(assoc_item.def_id).skip_binder().output();\n-            let fn_bound_vars = output.bound_vars();\n+        let projection_ty = if return_type_notation {\n+            // If we have an method return type bound, then we need to substitute\n+            // the method's early bound params with suitable late-bound params.\n+            let mut num_bound_vars = candidate.bound_vars().len();\n+            let substs =\n+                candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n+                    let subst = match param.kind {\n+                        GenericParamDefKind::Lifetime => tcx\n+                            .mk_re_late_bound(\n+                                ty::INNERMOST,\n+                                ty::BoundRegion {\n+                                    var: ty::BoundVar::from_usize(num_bound_vars),\n+                                    kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                                },\n+                            )\n+                            .into(),\n+                        GenericParamDefKind::Type { .. } => tcx\n+                            .mk_bound(\n+                                ty::INNERMOST,\n+                                ty::BoundTy {\n+                                    var: ty::BoundVar::from_usize(num_bound_vars),\n+                                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n+                                },\n+                            )\n+                            .into(),\n+                        GenericParamDefKind::Const { .. } => {\n+                            let ty = tcx\n+                                .type_of(param.def_id)\n+                                .no_bound_vars()\n+                                .expect(\"ct params cannot have early bound vars\");\n+                            tcx.mk_const(\n+                                ty::ConstKind::Bound(\n+                                    ty::INNERMOST,\n+                                    ty::BoundVar::from_usize(num_bound_vars),\n+                                ),\n+                                ty,\n+                            )\n+                            .into()\n+                        }\n+                    };\n+                    num_bound_vars += 1;\n+                    subst\n+                });\n \n+            // Next, we need to check that the return-type notation is being used on\n+            // an RPITIT (return-position impl trait in trait) or AFIT (async fn in trait).\n+            let output = tcx.fn_sig(assoc_item.def_id).skip_binder().output();\n             let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n                 && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n             {\n@@ -1182,13 +1221,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 todo!(\"found return type of {output:?}\");\n             };\n \n-            let trait_bound_vars = candidate.bound_vars();\n-            let shifted_output = tcx.shift_bound_var_indices(trait_bound_vars.len(), output);\n-            let subst_output =\n-                ty::EarlyBinder(shifted_output).subst(tcx, candidate.skip_binder().substs);\n-            let bound_vars =\n-                tcx.mk_bound_variable_kinds_from_iter(trait_bound_vars.iter().chain(fn_bound_vars));\n+            // Finally, move the fn return type's bound vars over to account for the early bound\n+            // params (and trait ref's late bound params). This logic is very similar to\n+            // `Predicate::subst_supertrait`, and it's no coincidence why.\n+            let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n+            let subst_output = ty::EarlyBinder(shifted_output).subst(tcx, substs);\n \n+            let bound_vars = tcx.late_bound_vars(binding.hir_id);\n             ty::Binder::bind_with_vars(subst_output, bound_vars)\n         } else {\n             // Include substitutions for generic parameters of associated types\n@@ -1211,7 +1250,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 debug!(?substs_trait_ref_and_assoc_item);\n \n-                self.tcx().mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n+                tcx.mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n             })\n         };\n "}, {"sha": "1a4a1636071b6acf974db70c2c6cd0b9b862b49e", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0308d4ad187e7715d2bb7efcfce58e6d93362f07/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0308d4ad187e7715d2bb7efcfce58e6d93362f07/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=0308d4ad187e7715d2bb7efcfce58e6d93362f07", "patch": "@@ -1640,7 +1640,59 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 },\n                 s: self.scope,\n             };\n-            if let Some(type_def_id) = type_def_id {\n+            // If the binding is parenthesized, then this must be `feature(return_type_notation)`.\n+            // In that case, introduce a binder over all of the function's early and late bound vars.\n+            //\n+            // For example, given\n+            // ```\n+            // trait Foo {\n+            //     async fn x<'r, T>();\n+            // }\n+            // ```\n+            // and a bound that looks like:\n+            //    `for<'a> T::Trait<'a, x(): for<'b> Other<'b>>`\n+            // this is going to expand to something like:\n+            //    `for<'a> for<'r, T> <T as Trait<'a>>::x::<'r, T>::{opaque#0}: for<'b> Other<'b>`.\n+            if binding.gen_args.parenthesized {\n+                let bound_vars = if let Some(type_def_id) = type_def_id\n+                    && self.tcx.def_kind(type_def_id) == DefKind::Trait\n+                    // FIXME(return_type_notation): We could bound supertrait methods.\n+                    && let Some(assoc_fn) = self\n+                        .tcx\n+                        .associated_items(type_def_id)\n+                        .find_by_name_and_kind(self.tcx, binding.ident, ty::AssocKind::Fn, type_def_id)\n+                {\n+                    self.tcx\n+                        .generics_of(assoc_fn.def_id)\n+                        .params\n+                        .iter()\n+                        .map(|param| match param.kind {\n+                            ty::GenericParamDefKind::Lifetime => ty::BoundVariableKind::Region(\n+                                ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                            ),\n+                            ty::GenericParamDefKind::Type { .. } => ty::BoundVariableKind::Ty(\n+                                ty::BoundTyKind::Param(param.def_id, param.name),\n+                            ),\n+                            ty::GenericParamDefKind::Const { .. } => ty::BoundVariableKind::Const,\n+                        })\n+                        .chain(self.tcx.fn_sig(assoc_fn.def_id).subst_identity().bound_vars())\n+                        .collect()\n+                } else {\n+                    self.tcx.sess.delay_span_bug(\n+                        binding.ident.span,\n+                        \"bad return type notation here\",\n+                    );\n+                    vec![]\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::Supertrait { bound_vars, s: this.scope };\n+                    this.with(scope, |this| {\n+                        let (bound_vars, _) = this.poly_trait_ref_binder_info();\n+                        this.record_late_bound_vars(binding.hir_id, bound_vars);\n+                        this.visit_assoc_type_binding(binding)\n+                    });\n+                });\n+            } else if let Some(type_def_id) = type_def_id {\n                 let bound_vars =\n                     BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n                 self.with(scope, |this| {"}]}