{"sha": "137564d82508dfa509289466055246430986ccf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNzU2NGQ4MjUwOGRmYTUwOTI4OTQ2NjA1NTI0NjQzMDk4NmNjZjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-29T15:14:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-29T15:14:01Z"}, "message": "Rollup merge of #63956 - alexcrichton:fix-lto-all-cached, r=michaelwoerister\n\nrustc: Handle modules in \"fat\" LTO more robustly\n\nWhen performing a \"fat\" LTO the compiler has a whole mess of codegen\nunits that it links together. To do this it needs to select one module\nas a \"base\" module and then link everything else into this module.\nPreviously LTO passes assume that there's at least one module in-memory\nto link into, but nowadays that's not always true! With incremental\ncompilation modules may actually largely be cached and it may be\npossible that there's no in-memory modules to work with.\n\nThis commit updates the logic of the LTO backend to handle modules a bit\nmore uniformly during a fat LTO. This commit immediately splits them\ninto two lists, one serialized and one in-memory. The in-memory list is\nthen searched for the largest module and failing that we simply\ndeserialize the first serialized module and link into that. This\nrefactoring avoids juggling three lists, two of which are serialized\nmodules and one of which is half serialized and half in-memory.\n\nCloses #63349", "tree": {"sha": "cc81b67ab27ce52da9340b903c8dceb602800872", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc81b67ab27ce52da9340b903c8dceb602800872"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/137564d82508dfa509289466055246430986ccf7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdZ+u5CRBK7hj4Ov3rIwAAdHIIAItYJUUWAOn6dqeILvvRA8N/\noQRqGQr6hI2T7GEzK3nPLyj91iQiG/nlbbRFw07bVKluSL+t9XtZEhl5HjeZ9Rbz\nDQvKEsgvyAQ5xK7FH9JfNLldnE+fBzhz0J7BBnwaajm1LRshSF/oJOMv+nmzY+QS\nTgfrpQnxZSU0jU8LJ8wtpxQO/6CXP0IxLbA2/wR3QabIhk7p+hbVbIEqa4LGgcK5\nRMMLGz1wogLQmGe46HT7kxqsF/gWjKw0lQ2xkkft6lvNJxSob1LjiGM38agWkc1J\nV2NEqftkBUGVByidwMI8OHMMFgvf8oAqGuc3V/AufoADhZoXXS24ScX80Wlx9r4=\n=lqQ6\n-----END PGP SIGNATURE-----\n", "payload": "tree cc81b67ab27ce52da9340b903c8dceb602800872\nparent 78e728e2c20a61dad6d73d9fcb1927668c75c416\nparent 1a4330d2a23f8b9912cb4ca54d259333b0133b76\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567091641 +0200\ncommitter GitHub <noreply@github.com> 1567091641 +0200\n\nRollup merge of #63956 - alexcrichton:fix-lto-all-cached, r=michaelwoerister\n\nrustc: Handle modules in \"fat\" LTO more robustly\n\nWhen performing a \"fat\" LTO the compiler has a whole mess of codegen\nunits that it links together. To do this it needs to select one module\nas a \"base\" module and then link everything else into this module.\nPreviously LTO passes assume that there's at least one module in-memory\nto link into, but nowadays that's not always true! With incremental\ncompilation modules may actually largely be cached and it may be\npossible that there's no in-memory modules to work with.\n\nThis commit updates the logic of the LTO backend to handle modules a bit\nmore uniformly during a fat LTO. This commit immediately splits them\ninto two lists, one serialized and one in-memory. The in-memory list is\nthen searched for the largest module and failing that we simply\ndeserialize the first serialized module and link into that. This\nrefactoring avoids juggling three lists, two of which are serialized\nmodules and one of which is half serialized and half in-memory.\n\nCloses #63349\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/137564d82508dfa509289466055246430986ccf7", "html_url": "https://github.com/rust-lang/rust/commit/137564d82508dfa509289466055246430986ccf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/137564d82508dfa509289466055246430986ccf7/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e728e2c20a61dad6d73d9fcb1927668c75c416", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e728e2c20a61dad6d73d9fcb1927668c75c416", "html_url": "https://github.com/rust-lang/rust/commit/78e728e2c20a61dad6d73d9fcb1927668c75c416"}, {"sha": "1a4330d2a23f8b9912cb4ca54d259333b0133b76", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4330d2a23f8b9912cb4ca54d259333b0133b76", "html_url": "https://github.com/rust-lang/rust/commit/1a4330d2a23f8b9912cb4ca54d259333b0133b76"}], "stats": {"total": 108, "additions": 59, "deletions": 49}, "files": [{"sha": "a43fbb68dbaed76d7d5d3d858c8c591fee5f50f7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/137564d82508dfa509289466055246430986ccf7/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/137564d82508dfa509289466055246430986ccf7/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=137564d82508dfa509289466055246430986ccf7", "patch": "@@ -183,14 +183,40 @@ pub(crate) fn prepare_thin(\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n+    // Sort out all our lists of incoming modules into two lists.\n+    //\n+    // * `serialized_modules` (also and argument to this function) contains all\n+    //   modules that are serialized in-memory.\n+    // * `in_memory` contains modules which are already parsed and in-memory,\n+    //   such as from multi-CGU builds.\n+    //\n+    // All of `cached_modules` (cached from previous incremental builds) can\n+    // immediately go onto the `serialized_modules` modules list and then we can\n+    // split the `modules` array into these two lists.\n+    let mut in_memory = Vec::new();\n+    serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+        info!(\"pushing cached module {:?}\", wp.cgu_name);\n+        (buffer, CString::new(wp.cgu_name).unwrap())\n+    }));\n+    for module in modules {\n+        match module {\n+            FatLTOInput::InMemory(m) => in_memory.push(m),\n+            FatLTOInput::Serialized { name, buffer } => {\n+                info!(\"pushing serialized module {:?}\", name);\n+                let buffer = SerializedModule::Local(buffer);\n+                serialized_modules.push((buffer, CString::new(name).unwrap()));\n+            }\n+        }\n+    }\n+\n     // Find the \"costliest\" module and merge everything into that codegen unit.\n     // All the other modules will be serialized and reparsed into the new\n     // context, so this hopefully avoids serializing and parsing the largest\n@@ -200,14 +226,8 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let costliest_module = modules.iter()\n+    let costliest_module = in_memory.iter()\n         .enumerate()\n-        .filter_map(|(i, module)| {\n-            match module {\n-                FatLTOInput::InMemory(m) => Some((i, m)),\n-                FatLTOInput::Serialized { .. } => None,\n-            }\n-        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n@@ -223,26 +243,14 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // re-executing the LTO passes. If that's the case deserialize the first\n     // module and create a linker with it.\n     let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n-        Some((_cost, i)) => {\n-            match modules.remove(i) {\n-                FatLTOInput::InMemory(m) => m,\n-                FatLTOInput::Serialized { .. } => unreachable!(),\n-            }\n-        }\n+        Some((_cost, i)) => in_memory.remove(i),\n         None => {\n-            let pos = modules.iter().position(|m| {\n-                match m {\n-                    FatLTOInput::InMemory(_) => false,\n-                    FatLTOInput::Serialized { .. } => true,\n-                }\n-            }).expect(\"must have at least one serialized module\");\n-            let (name, buffer) = match modules.remove(pos) {\n-                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n-                FatLTOInput::InMemory(_) => unreachable!(),\n-            };\n+            assert!(serialized_modules.len() > 0, \"must have at least one serialized module\");\n+            let (buffer, name) = serialized_modules.remove(0);\n+            info!(\"no in-memory regular modules to choose from, parsing {:?}\", name);\n             ModuleCodegen {\n-                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n-                name,\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, buffer.data(), diag_handler)?,\n+                name: name.into_string().unwrap(),\n                 kind: ModuleKind::Regular,\n             }\n         }\n@@ -265,25 +273,13 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        let mut new_modules = modules.into_iter().map(|module| {\n-            match module {\n-                FatLTOInput::InMemory(module) => {\n-                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-                    let llmod_id = CString::new(&module.name[..]).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-                FatLTOInput::Serialized { name, buffer } => {\n-                    let llmod_id = CString::new(name).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-            }\n-        }).collect::<Vec<_>>();\n+        for module in in_memory {\n+            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+            let llmod_id = CString::new(&module.name[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n         // Sort the modules to ensure we produce deterministic results.\n-        new_modules.sort_by(|module1, module2| module1.1.partial_cmp(&module2.1).unwrap());\n-        serialized_modules.extend(new_modules);\n-        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n-            (buffer, CString::new(wp.cgu_name).unwrap())\n-        }));\n+        serialized_modules.sort_by(|module1, module2| module1.1.cmp(&module2.1));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n         // above, this is all mostly handled in C++. Like above, though, we don't\n@@ -850,7 +846,7 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n \n-fn parse_module<'a>(\n+pub fn parse_module<'a>(\n     cx: &'a llvm::Context,\n     name: &CStr,\n     data: &[u8],"}, {"sha": "2fd78885bd01e8106b8ffb22d2cd468075dcad8d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/137564d82508dfa509289466055246430986ccf7/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/137564d82508dfa509289466055246430986ccf7/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=137564d82508dfa509289466055246430986ccf7", "patch": "@@ -54,6 +54,7 @@ use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n+use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n@@ -386,13 +387,13 @@ impl ModuleLlvm {\n \n     fn parse(\n         cgcx: &CodegenContext<LlvmCodegenBackend>,\n-        name: &str,\n-        buffer: &back::lto::ModuleBuffer,\n+        name: &CStr,\n+        buffer: &[u8],\n         handler: &Handler,\n     ) -> Result<Self, FatalError> {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n             let tm = match (cgcx.tm_factory.0)() {\n                 Ok(m) => m,\n                 Err(e) => {"}, {"sha": "345d10bc4b9ea59d3c4216b4055b564d9b8a1265", "filename": "src/test/run-make-fulldeps/lto-empty/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/137564d82508dfa509289466055246430986ccf7/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/137564d82508dfa509289466055246430986ccf7/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile?ref=137564d82508dfa509289466055246430986ccf7", "patch": "@@ -0,0 +1,12 @@\n+-include ../tools.mk\n+\n+all: cdylib-fat cdylib-thin\n+\n+cdylib-fat:\n+\t$(RUSTC) lib.rs -C lto=fat -C opt-level=3 -C incremental=$(TMPDIR)/inc-fat\n+\t$(RUSTC) lib.rs -C lto=fat -C opt-level=3 -C incremental=$(TMPDIR)/inc-fat\n+\n+cdylib-thin:\n+\t$(RUSTC) lib.rs -C lto=thin -C opt-level=3 -C incremental=$(TMPDIR)/inc-thin\n+\t$(RUSTC) lib.rs -C lto=thin -C opt-level=3 -C incremental=$(TMPDIR)/inc-thin\n+"}, {"sha": "e3663c79078f4f0823ebbb7baf5fc65a1512c15a", "filename": "src/test/run-make-fulldeps/lto-empty/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/137564d82508dfa509289466055246430986ccf7/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/137564d82508dfa509289466055246430986ccf7/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs?ref=137564d82508dfa509289466055246430986ccf7", "patch": "@@ -0,0 +1 @@\n+#![crate_type = \"cdylib\"]"}, {"sha": "b7a930b61cc96aed4b73d9adc82ce62250d63d61", "filename": "src/test/ui/lto-duplicate-symbols.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/137564d82508dfa509289466055246430986ccf7/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/137564d82508dfa509289466055246430986ccf7/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr?ref=137564d82508dfa509289466055246430986ccf7", "patch": "@@ -1,6 +1,6 @@\n warning: Linking globals named 'foo': symbol multiply defined!\n \n-error: failed to load bc of \"lto_duplicate_symbols1.3a1fbbbh-cgu.0\": \n+error: failed to load bc of \"lto_duplicate_symbols2.3a1fbbbh-cgu.0\": \n \n error: aborting due to previous error\n "}]}