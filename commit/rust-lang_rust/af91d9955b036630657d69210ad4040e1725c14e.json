{"sha": "af91d9955b036630657d69210ad4040e1725c14e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmOTFkOTk1NWIwMzY2MzA2NTdkNjkyMTBhZDQwNDBlMTcyNWMxNGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-07T20:27:03Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-15T06:46:24Z"}, "message": "Use `into` for casting when possible", "tree": {"sha": "0ff74ddf58bb1a25d48c4650913231217921e174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ff74ddf58bb1a25d48c4650913231217921e174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af91d9955b036630657d69210ad4040e1725c14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af91d9955b036630657d69210ad4040e1725c14e", "html_url": "https://github.com/rust-lang/rust/commit/af91d9955b036630657d69210ad4040e1725c14e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af91d9955b036630657d69210ad4040e1725c14e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "url": "https://api.github.com/repos/rust-lang/rust/commits/aec16237e4cd8c2d4d650cacac72b9a33cac1f99", "html_url": "https://github.com/rust-lang/rust/commit/aec16237e4cd8c2d4d650cacac72b9a33cac1f99"}], "stats": {"total": 377, "additions": 205, "deletions": 172}, "files": [{"sha": "8d43b9b4aa7396878c5d9161eef07fb61ba5f46d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -1173,37 +1173,6 @@ impl fmt::Debug for Expr {\n     }\n }\n \n-impl Expr {\n-\n-    /// If casting this expression to a given numeric type would be appropriate in case of a type\n-    /// mismatch.\n-    ///\n-    /// We want to minimize the amount of casting operations that are suggested, as it can be a\n-    /// lossy operation with potentially bad side effects, so we only suggest when encountering an\n-    /// expression that indicates that the original type couldn't be directly changed.\n-    pub fn could_cast_in_type_mismatch(&self) -> bool {\n-        match self.node {\n-            ExprCall(..) |\n-            ExprMethodCall(..) |\n-            ExprBinary(..) |\n-            ExprField(..) |\n-            ExprTupField(..) |\n-            ExprIndex(..) |\n-            ExprPath(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn needs_parens_around_cast(&self) -> bool {\n-        match self.node {\n-            ExprBinary(..) |\n-            ExprCast(..) |\n-            ExprType(..) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Expr_ {\n     /// A `box x` expression."}, {"sha": "42cca2bbb5ebbae7073d32c733042e7576b5a908", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 154, "deletions": 92, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -325,152 +325,214 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let will_sign_extend = \"will sign-extend the source value\";\n         let will_zero_extend = \"will zero-extend the source value\";\n \n-        let needs_paren = expr.needs_parens_around_cast();\n+        // If casting this expression to a given numeric type would be appropriate in case of a type\n+        // mismatch.\n+        //\n+        // We want to minimize the amount of casting operations that are suggested, as it can be a\n+        // lossy operation with potentially bad side effects, so we only suggest when encountering\n+        // an expression that indicates that the original type couldn't be directly changed.\n+        let can_cast = match expr.node {\n+            hir::ExprPath(..) |\n+            hir::ExprCall(..) |\n+            hir::ExprMethodCall(..) |\n+            hir::ExprBinary(..) => true,\n+            _ => false,\n+        };\n+\n+        let needs_paren = match expr.node {\n+            hir::ExprBinary(..) => true,\n+            _ => false,\n+        };\n \n-        if let (Ok(src), true) = (self.tcx.sess.codemap().span_to_snippet(expr.span),\n-                                  expr.could_cast_in_type_mismatch()) {\n+        if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n             let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);\n-            let suggestion = format!(\"{}{} as {}{}\",\n-                                     if needs_paren { \"(\" } else { \"\" },\n-                                     src,\n-                                     if needs_paren { \")\" } else { \"\" },\n-                                     expected_ty);\n+            let cast_suggestion = format!(\"{}{}{} as {}\",\n+                                          if needs_paren { \"(\" } else { \"\" },\n+                                          src,\n+                                          if needs_paren { \")\" } else { \"\" },\n+                                          expected_ty);\n+            let into_suggestion = format!(\"{}{}{}.into()\",\n+                                          if needs_paren { \"(\" } else { \"\" },\n+                                          src,\n+                                          if needs_paren { \")\" } else { \"\" });\n \n             match (&expected_ty.sty, &checked_ty.sty) {\n                 (&ty::TyInt(ref exp), &ty::TyInt(ref found)) => {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_truncate),\n-                                                suggestion);\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n                         }\n                         (None, _) | (_, None) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, depending_on_isize),\n-                                                suggestion);\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n                         }\n                         _ => {\n                             err.span_suggestion(expr.span,\n                                                 &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                suggestion);\n+                                                into_suggestion);\n                         }\n                     }\n                     true\n                 }\n                 (&ty::TyUint(ref exp), &ty::TyUint(ref found)) => {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_truncate),\n-                                                suggestion);\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n                         }\n                         (None, _) | (_, None) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, depending_on_usize),\n-                                                suggestion);\n+                            if can_cast {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n                         }\n                         _ => {\n                             err.span_suggestion(expr.span,\n                                                 &format!(\"{}, which {}\", msg, will_zero_extend),\n-                                                suggestion);\n+                                                into_suggestion);\n                         }\n                     }\n                     true\n                 }\n                 (&ty::TyInt(ref exp), &ty::TyUint(ref found)) => {\n-                    match (found.bit_width(), exp.bit_width()) {\n-                        (Some(found), Some(exp)) if found > exp - 1 => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_truncate),\n-                                                suggestion);\n-                        }\n-                        (None, None) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_truncate),\n-                                                suggestion);\n-                        }\n-                        (None, _) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, depending_on_isize),\n-                                                suggestion);\n-                        }\n-                        (_, None) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, depending_on_usize),\n-                                                suggestion);\n-                        }\n-                        _ => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n-                                                suggestion);\n+                    if can_cast {\n+                        match (found.bit_width(), exp.bit_width()) {\n+                            (Some(found), Some(exp)) if found > exp - 1 => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, _) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                            (_, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                            _ => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                                    cast_suggestion);\n+                            }\n                         }\n                     }\n                     true\n                 }\n                 (&ty::TyUint(ref exp), &ty::TyInt(ref found)) => {\n-                    match (found.bit_width(), exp.bit_width()) {\n-                        (Some(found), Some(exp)) if found - 1 > exp => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_truncate),\n-                                                suggestion);\n-                        }\n-                        (None, None) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                suggestion);\n-                        }\n-                        (None, _) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, depending_on_usize),\n-                                                suggestion);\n-                        }\n-                        (_, None) => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, depending_on_isize),\n-                                                suggestion);\n-                        }\n-                        _ => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                suggestion);\n+                    if can_cast {\n+                        match (found.bit_width(), exp.bit_width()) {\n+                            (Some(found), Some(exp)) if found - 1 > exp => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                    cast_suggestion);\n+                            }\n+                            (None, _) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                                    cast_suggestion);\n+                            }\n+                            (_, None) => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                                    cast_suggestion);\n+                            }\n+                            _ => {\n+                                err.span_suggestion(expr.span,\n+                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                                    cast_suggestion);\n+                            }\n                         }\n                     }\n                     true\n                 }\n                 (&ty::TyFloat(ref exp), &ty::TyFloat(ref found)) => {\n-                    if found.bit_width() > exp.bit_width() {\n+                    if found.bit_width() < exp.bit_width() {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{} in a lossless way\",\n+                                                     msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n                         err.span_suggestion(expr.span,\n                                             &format!(\"{}, producing the closest possible value\",\n                                                      msg),\n-                                            suggestion);\n-                        err.warn(\"casting here will cause Undefined Behavior if the value is \\\n+                                            cast_suggestion);\n+                        err.warn(\"casting here will cause undefined behavior if the value is \\\n                                   finite but larger or smaller than the largest or smallest \\\n                                   finite value representable by `f32` (this is a bug and will be \\\n                                   fixed)\");\n-                    } else {\n+                    }\n+                    true\n+                }\n+                (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n+                    if can_cast {\n                         err.span_suggestion(expr.span,\n-                                            &format!(\"{} in a lossless way\",\n+                                            &format!(\"{}, rounding the float towards zero\",\n                                                      msg),\n-                                            suggestion);\n+                                            cast_suggestion);\n+                        err.warn(\"casting here will cause undefined behavior if the rounded value \\\n+                                  cannot be represented by the target integer type, including \\\n+                                  `Inf` and `NaN` (this is a bug and will be fixed)\");\n                     }\n                     true\n                 }\n-                (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n-                    err.span_suggestion(expr.span,\n-                                        &format!(\"{}, rounding the float towards zero\",\n-                                                 msg),\n-                                        suggestion);\n-                    err.warn(\"casting here will cause Undefined Behavior if the rounded value \\\n-                              cannot be represented by the target integer type, including `Inf` \\\n-                              and `NaN` (this is a bug and will be fixed)\");\n+                (&ty::TyFloat(ref exp), &ty::TyUint(ref found)) => {\n+                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            cast_suggestion);\n+                    }\n                     true\n                 }\n-                (&ty::TyFloat(_), &ty::TyUint(_)) | (&ty::TyFloat(_), &ty::TyInt(_)) => {\n-                    err.span_suggestion(expr.span,\n-                                        &format!(\"{}, producing the floating point representation \\\n-                                                  of the integer, rounded if necessary\",\n-                                                  msg),\n-                                        suggestion);\n+                (&ty::TyFloat(ref exp), &ty::TyInt(ref found)) => {\n+                    if exp.bit_width() > found.bit_width().unwrap_or(256) {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            into_suggestion);\n+                    } else if can_cast {\n+                        err.span_suggestion(expr.span,\n+                                            &format!(\"{}, producing the floating point \\\n+                                                      representation of the integer, rounded if \\\n+                                                      necessary\",\n+                                                      msg),\n+                                            cast_suggestion);\n+                    }\n                     true\n                 }\n                 _ => false,"}, {"sha": "0641e09b552e5c140035f686179b9c6f9a2d105f", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n    |     -------------- in this macro invocation\n help: you can cast an `usize` to `u64`, which will truncate or zero-extend depending on the bit width of `usize`\n    |\n-26 |                   ($arr.len() * size_of($arr[0]) as )u64); //~ ERROR mismatched types\n+26 |                   ($arr.len() * size_of($arr[0])) as u64); //~ ERROR mismatched types\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0605]: non-primitive cast: `{integer}` as `()`"}, {"sha": "4c905a090a68c330c3d574fd39462eb08634fbac", "filename": "src/test/ui/suggestions/numeric-cast-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.rs?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -13,5 +13,7 @@ fn foo() -> i32 {\n }\n fn main() {\n     let x: u32 = foo();\n+    //~^ ERROR mismatched types\n     let z: i32 = x + x;\n+    //~^ ERROR mismatched types\n }"}, {"sha": "44703867b754755574ca0a25420a0ef4bbfd4031", "filename": "src/test/ui/suggestions/numeric-cast-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast-2.stderr?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -9,13 +9,13 @@ help: you can cast an `i32` to `u32`, which will sign-extend the source value\n    |                  ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/numeric-cast-2.rs:16:18\n+  --> $DIR/numeric-cast-2.rs:17:18\n    |\n-16 |     let z: i32 = x + x;\n+17 |     let z: i32 = x + x;\n    |                  ^^^^^ expected i32, found u32\n help: you can cast an `u32` to `i32`, which will truncate the source value\n    |\n-16 |     let z: i32 = (x + x as )i32;\n+17 |     let z: i32 = (x + x) as i32;\n    |                  ^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors"}, {"sha": "cd5e183ede9420dc4587c61057d7d40005fdc0cb", "filename": "src/test/ui/suggestions/numeric-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.rs?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -331,6 +331,6 @@ fn main() {\n     //~^ ERROR mismatched types\n     foo::<f32>(x_f64);\n     //~^ ERROR mismatched types\n-    //~| WARN casting here will cause Undefined Behavior\n+    //~| WARN casting here will cause undefined behavior\n     foo::<f32>(x_f32);\n }"}, {"sha": "f074a3bc280a101c2e97c4f6b0b142a688f9ad16", "filename": "src/test/ui/suggestions/numeric-cast.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af91d9955b036630657d69210ad4040e1725c14e/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnumeric-cast.stderr?ref=af91d9955b036630657d69210ad4040e1725c14e", "patch": "@@ -94,7 +94,7 @@ error[E0308]: mismatched types\n 47 |     foo::<usize>(x_f64);\n    |                  ^^^^^ expected usize, found f64\n    |\n-   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+   = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `usize`, rounding the float towards zero\n    |\n 47 |     foo::<usize>(x_f64 as usize);\n@@ -106,7 +106,7 @@ error[E0308]: mismatched types\n 50 |     foo::<usize>(x_f32);\n    |                  ^^^^^ expected usize, found f32\n    |\n-   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+   = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `usize`, rounding the float towards zero\n    |\n 50 |     foo::<usize>(x_f32 as usize);\n@@ -208,7 +208,7 @@ error[E0308]: mismatched types\n 73 |     foo::<isize>(x_f64);\n    |                  ^^^^^ expected isize, found f64\n    |\n-   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+   = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `isize`, rounding the float towards zero\n    |\n 73 |     foo::<isize>(x_f64 as isize);\n@@ -220,7 +220,7 @@ error[E0308]: mismatched types\n 76 |     foo::<isize>(x_f32);\n    |                  ^^^^^ expected isize, found f32\n    |\n-   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+   = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `isize`, rounding the float towards zero\n    |\n 76 |     foo::<isize>(x_f32 as isize);\n@@ -243,7 +243,7 @@ error[E0308]: mismatched types\n    |                ^^^^^ expected u64, found u32\n help: you can cast an `u32` to `u64`, which will zero-extend the source value\n    |\n-83 |     foo::<u64>(x_u32 as u64);\n+83 |     foo::<u64>(x_u32.into());\n    |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -253,7 +253,7 @@ error[E0308]: mismatched types\n    |                ^^^^^ expected u64, found u16\n help: you can cast an `u16` to `u64`, which will zero-extend the source value\n    |\n-85 |     foo::<u64>(x_u16 as u64);\n+85 |     foo::<u64>(x_u16.into());\n    |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -263,7 +263,7 @@ error[E0308]: mismatched types\n    |                ^^^^ expected u64, found u8\n help: you can cast an `u8` to `u64`, which will zero-extend the source value\n    |\n-87 |     foo::<u64>(x_u8 as u64);\n+87 |     foo::<u64>(x_u8.into());\n    |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -322,7 +322,7 @@ error[E0308]: mismatched types\n 99 |     foo::<u64>(x_f64);\n    |                ^^^^^ expected u64, found f64\n    |\n-   = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+   = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `u64`, rounding the float towards zero\n    |\n 99 |     foo::<u64>(x_f64 as u64);\n@@ -334,7 +334,7 @@ error[E0308]: mismatched types\n 102 |     foo::<u64>(x_f32);\n     |                ^^^^^ expected u64, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `u64`, rounding the float towards zero\n     |\n 102 |     foo::<u64>(x_f32 as u64);\n@@ -407,7 +407,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected i64, found i32\n help: you can cast an `i32` to `i64`, which will sign-extend the source value\n     |\n-119 |     foo::<i64>(x_i32 as i64);\n+119 |     foo::<i64>(x_i32.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -417,7 +417,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected i64, found i16\n help: you can cast an `i16` to `i64`, which will sign-extend the source value\n     |\n-121 |     foo::<i64>(x_i16 as i64);\n+121 |     foo::<i64>(x_i16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -427,7 +427,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected i64, found i8\n help: you can cast an `i8` to `i64`, which will sign-extend the source value\n     |\n-123 |     foo::<i64>(x_i8 as i64);\n+123 |     foo::<i64>(x_i8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -436,7 +436,7 @@ error[E0308]: mismatched types\n 125 |     foo::<i64>(x_f64);\n     |                ^^^^^ expected i64, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `i64`, rounding the float towards zero\n     |\n 125 |     foo::<i64>(x_f64 as i64);\n@@ -448,7 +448,7 @@ error[E0308]: mismatched types\n 128 |     foo::<i64>(x_f32);\n     |                ^^^^^ expected i64, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `i64`, rounding the float towards zero\n     |\n 128 |     foo::<i64>(x_f32 as i64);\n@@ -481,7 +481,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected u32, found u16\n help: you can cast an `u16` to `u32`, which will zero-extend the source value\n     |\n-137 |     foo::<u32>(x_u16 as u32);\n+137 |     foo::<u32>(x_u16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -491,7 +491,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected u32, found u8\n help: you can cast an `u8` to `u32`, which will zero-extend the source value\n     |\n-139 |     foo::<u32>(x_u8 as u32);\n+139 |     foo::<u32>(x_u8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -550,7 +550,7 @@ error[E0308]: mismatched types\n 151 |     foo::<u32>(x_f64);\n     |                ^^^^^ expected u32, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `u32`, rounding the float towards zero\n     |\n 151 |     foo::<u32>(x_f64 as u32);\n@@ -562,7 +562,7 @@ error[E0308]: mismatched types\n 154 |     foo::<u32>(x_f32);\n     |                ^^^^^ expected u32, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `u32`, rounding the float towards zero\n     |\n 154 |     foo::<u32>(x_f32 as u32);\n@@ -645,7 +645,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected i32, found i16\n help: you can cast an `i16` to `i32`, which will sign-extend the source value\n     |\n-173 |     foo::<i32>(x_i16 as i32);\n+173 |     foo::<i32>(x_i16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -655,7 +655,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected i32, found i8\n help: you can cast an `i8` to `i32`, which will sign-extend the source value\n     |\n-175 |     foo::<i32>(x_i8 as i32);\n+175 |     foo::<i32>(x_i8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -664,7 +664,7 @@ error[E0308]: mismatched types\n 177 |     foo::<i32>(x_f64);\n     |                ^^^^^ expected i32, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `i32`, rounding the float towards zero\n     |\n 177 |     foo::<i32>(x_f64 as i32);\n@@ -676,7 +676,7 @@ error[E0308]: mismatched types\n 180 |     foo::<i32>(x_f32);\n     |                ^^^^^ expected i32, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `i32`, rounding the float towards zero\n     |\n 180 |     foo::<i32>(x_f32 as i32);\n@@ -719,7 +719,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected u16, found u8\n help: you can cast an `u8` to `u16`, which will zero-extend the source value\n     |\n-191 |     foo::<u16>(x_u8 as u16);\n+191 |     foo::<u16>(x_u8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -778,7 +778,7 @@ error[E0308]: mismatched types\n 203 |     foo::<u16>(x_f64);\n     |                ^^^^^ expected u16, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `u16`, rounding the float towards zero\n     |\n 203 |     foo::<u16>(x_f64 as u16);\n@@ -790,7 +790,7 @@ error[E0308]: mismatched types\n 206 |     foo::<u16>(x_f32);\n     |                ^^^^^ expected u16, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `u16`, rounding the float towards zero\n     |\n 206 |     foo::<u16>(x_f32 as u16);\n@@ -883,7 +883,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected i16, found i8\n help: you can cast an `i8` to `i16`, which will sign-extend the source value\n     |\n-227 |     foo::<i16>(x_i8 as i16);\n+227 |     foo::<i16>(x_i8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -892,7 +892,7 @@ error[E0308]: mismatched types\n 229 |     foo::<i16>(x_f64);\n     |                ^^^^^ expected i16, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `i16`, rounding the float towards zero\n     |\n 229 |     foo::<i16>(x_f64 as i16);\n@@ -904,7 +904,7 @@ error[E0308]: mismatched types\n 232 |     foo::<i16>(x_f32);\n     |                ^^^^^ expected i16, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `i16`, rounding the float towards zero\n     |\n 232 |     foo::<i16>(x_f32 as i16);\n@@ -1006,7 +1006,7 @@ error[E0308]: mismatched types\n 255 |     foo::<u8>(x_f64);\n     |               ^^^^^ expected u8, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `u8`, rounding the float towards zero\n     |\n 255 |     foo::<u8>(x_f64 as u8);\n@@ -1018,7 +1018,7 @@ error[E0308]: mismatched types\n 258 |     foo::<u8>(x_f32);\n     |               ^^^^^ expected u8, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `u8`, rounding the float towards zero\n     |\n 258 |     foo::<u8>(x_f32 as u8);\n@@ -1120,7 +1120,7 @@ error[E0308]: mismatched types\n 281 |     foo::<i8>(x_f64);\n     |               ^^^^^ expected i8, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f64` to `i8`, rounding the float towards zero\n     |\n 281 |     foo::<i8>(x_f64 as i8);\n@@ -1132,7 +1132,7 @@ error[E0308]: mismatched types\n 284 |     foo::<i8>(x_f32);\n     |               ^^^^^ expected i8, found f32\n     |\n-    = warning: Currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type. This includes `Inf` and `NaN`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the rounded value cannot be represented by the target integer type, including `Inf` and `NaN` (this is a bug and will be fixed)\n help: you can cast an `f32` to `i8`, rounding the float towards zero\n     |\n 284 |     foo::<i8>(x_f32 as i8);\n@@ -1165,7 +1165,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f64, found u32\n help: you can cast an `u32` to `f64`, producing the floating point representation of the integer, rounded if necessary\n     |\n-292 |     foo::<f64>(x_u32 as f64);\n+292 |     foo::<f64>(x_u32.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1175,7 +1175,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f64, found u16\n help: you can cast an `u16` to `f64`, producing the floating point representation of the integer, rounded if necessary\n     |\n-294 |     foo::<f64>(x_u16 as f64);\n+294 |     foo::<f64>(x_u16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1185,7 +1185,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected f64, found u8\n help: you can cast an `u8` to `f64`, producing the floating point representation of the integer, rounded if necessary\n     |\n-296 |     foo::<f64>(x_u8 as f64);\n+296 |     foo::<f64>(x_u8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1215,7 +1215,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f64, found i32\n help: you can cast an `i32` to `f64`, producing the floating point representation of the integer, rounded if necessary\n     |\n-302 |     foo::<f64>(x_i32 as f64);\n+302 |     foo::<f64>(x_i32.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1225,7 +1225,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f64, found i16\n help: you can cast an `i16` to `f64`, producing the floating point representation of the integer, rounded if necessary\n     |\n-304 |     foo::<f64>(x_i16 as f64);\n+304 |     foo::<f64>(x_i16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1235,7 +1235,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected f64, found i8\n help: you can cast an `i8` to `f64`, producing the floating point representation of the integer, rounded if necessary\n     |\n-306 |     foo::<f64>(x_i8 as f64);\n+306 |     foo::<f64>(x_i8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1245,7 +1245,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f64, found f32\n help: you can cast an `f32` to `f64` in a lossless way\n     |\n-309 |     foo::<f64>(x_f32 as f64);\n+309 |     foo::<f64>(x_f32.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1285,7 +1285,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f32, found u16\n help: you can cast an `u16` to `f32`, producing the floating point representation of the integer, rounded if necessary\n     |\n-318 |     foo::<f32>(x_u16 as f32);\n+318 |     foo::<f32>(x_u16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1295,7 +1295,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected f32, found u8\n help: you can cast an `u8` to `f32`, producing the floating point representation of the integer, rounded if necessary\n     |\n-320 |     foo::<f32>(x_u8 as f32);\n+320 |     foo::<f32>(x_u8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1335,7 +1335,7 @@ error[E0308]: mismatched types\n     |                ^^^^^ expected f32, found i16\n help: you can cast an `i16` to `f32`, producing the floating point representation of the integer, rounded if necessary\n     |\n-328 |     foo::<f32>(x_i16 as f32);\n+328 |     foo::<f32>(x_i16.into());\n     |                ^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1345,7 +1345,7 @@ error[E0308]: mismatched types\n     |                ^^^^ expected f32, found i8\n help: you can cast an `i8` to `f32`, producing the floating point representation of the integer, rounded if necessary\n     |\n-330 |     foo::<f32>(x_i8 as f32);\n+330 |     foo::<f32>(x_i8.into());\n     |                ^^^^^^^^^^^\n \n error[E0308]: mismatched types\n@@ -1354,7 +1354,7 @@ error[E0308]: mismatched types\n 332 |     foo::<f32>(x_f64);\n     |                ^^^^^ expected f32, found f64\n     |\n-    = warning: Currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by `f32`. This is a bug and will be fixed.\n+    = warning: casting here will cause undefined behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by `f32` (this is a bug and will be fixed)\n help: you can cast an `f64` to `f32`, producing the closest possible value\n     |\n 332 |     foo::<f32>(x_f64 as f32);"}]}