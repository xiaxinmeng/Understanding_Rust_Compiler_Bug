{"sha": "36505c7b40b461744061c9da49a1c76996d46c4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NTA1YzdiNDBiNDYxNzQ0MDYxYzlkYTQ5YTFjNzY5OTZkNDZjNGM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-06T00:11:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-06T00:17:16Z"}, "message": "fix bitops being accidentally allowed on pointers from the same allocation", "tree": {"sha": "5d30834a5d0727ffb18b78398588967231ebc8ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d30834a5d0727ffb18b78398588967231ebc8ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36505c7b40b461744061c9da49a1c76996d46c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36505c7b40b461744061c9da49a1c76996d46c4c", "html_url": "https://github.com/rust-lang/rust/commit/36505c7b40b461744061c9da49a1c76996d46c4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36505c7b40b461744061c9da49a1c76996d46c4c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6e6a6fd29616f4c4a60eb11923bc4e2b0097acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e6a6fd29616f4c4a60eb11923bc4e2b0097acd", "html_url": "https://github.com/rust-lang/rust/commit/a6e6a6fd29616f4c4a60eb11923bc4e2b0097acd"}], "stats": {"total": 133, "additions": 94, "deletions": 39}, "files": [{"sha": "b58098e4196774f0b2b997043cc1b70e4e211b2e", "filename": "src/operator.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/36505c7b40b461744061c9da49a1c76996d46c4c/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36505c7b40b461744061c9da49a1c76996d46c4c/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=36505c7b40b461744061c9da49a1c76996d46c4c", "patch": "@@ -155,57 +155,48 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n         let (left, right) = (normalize(left), normalize(right));\n \n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+\n         // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n         if bin_op == Offset {\n-            let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n-            let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n-            return Ok((PrimVal::Ptr(ptr), false));\n+            if left_kind == Ptr && right_kind == PrimValKind::from_uint_size(self.memory.pointer_size()) {\n+                let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+                let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n+                return Ok((PrimVal::Ptr(ptr), false));\n+            } else {\n+                bug!(\"Offset used with wrong type\");\n+            }\n         }\n \n         let (l, r) = match (left, right) {\n             (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n \n+            // One argument is a pointer value -- this is handled separately\n             (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n-                if left_ptr.alloc_id == right_ptr.alloc_id {\n-                    // If the pointers are into the same allocation, fall through to the more general\n-                    // match later, which will do comparisons on the pointer offsets.\n-                    (left_ptr.offset as u128, right_ptr.offset as u128)\n-                } else {\n-                    return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n-                }\n+                return self.ptr_ops(bin_op, left_ptr, left_kind, right_ptr, right_kind);\n+            }\n+            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) => {\n+                return self.ptr_ops(bin_op, ptr, left_kind, Pointer::from_int(bytes as u64), right_kind);\n             }\n-\n-            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n             (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n-                return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n+                return self.ptr_ops(bin_op, Pointer::from_int(bytes as u64), left_kind, ptr, right_kind);\n             }\n \n             (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n         };\n \n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n-\n         // These ops can have an RHS with a different numeric type.\n-        if bin_op == Shl || bin_op == Shr {\n+        if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n             return match bin_op {\n                 Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n                 Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n                 _ => bug!(\"it has already been checked that this is a shift op\"),\n             };\n         }\n-        if bin_op == Offset {\n-            // We permit offset-by-0 in any case.  Drop glue actually does this, and it's probably (TM) fine for LLVM.\n-            if left_kind == PrimValKind::Ptr && right_kind.is_int() && r == 0 {\n-                return Ok((PrimVal::Bytes(l), false));\n-            } else {\n-                let msg = format!(\"unimplemented Offset: {:?}, {:?}\", left, right);\n-                return Err(EvalError::Unimplemented(msg));\n-            }\n-        }\n \n         if left_kind != right_kind {\n-            let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+            let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n             return Err(EvalError::Unimplemented(msg));\n         }\n \n@@ -258,25 +249,58 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n \n             _ => {\n-                let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+                let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n                 return Err(EvalError::Unimplemented(msg));\n             }\n         };\n \n         Ok((val, false))\n     }\n-}\n \n-fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) -> EvalResult<'tcx, PrimVal> {\n-    use rustc::mir::BinOp::*;\n-    match bin_op {\n-        Eq => Ok(PrimVal::from_bool(false)),\n-        Ne => Ok(PrimVal::from_bool(true)),\n-        Lt | Le | Gt | Ge => Err(EvalError::InvalidPointerMath),\n-        _ if left.to_int().is_ok() ^ right.to_int().is_ok() => {\n-            Err(EvalError::ReadPointerAsBytes)\n-        },\n-        _ => bug!(),\n+    fn ptr_ops(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: Pointer,\n+        left_kind: PrimValKind,\n+        right: Pointer,\n+        right_kind: PrimValKind,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        use rustc::mir::BinOp::*;\n+        use value::PrimValKind::*;\n+\n+        if left_kind != right_kind {\n+            let msg = format!(\"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n+            return Err(EvalError::Unimplemented(msg));\n+        }\n+\n+        let val = match (bin_op, left_kind) {\n+            (Eq, k) if k.is_ptr() => PrimVal::from_bool(left == right),\n+            (Ne, k) if k.is_ptr() => PrimVal::from_bool(left != right),\n+            (Lt, k) | (Le, k) | (Gt, k) | (Ge, k) if k.is_ptr() => {\n+                if left.alloc_id == right.alloc_id {\n+                    PrimVal::from_bool(match bin_op {\n+                        Lt => left.offset < right.offset,\n+                        Le => left.offset <= right.offset,\n+                        Gt => left.offset > right.offset,\n+                        Ge => left.offset >= right.offset,\n+                        _ => bug!(\"We already established it has to be a comparison operator.\"),\n+                    })\n+                } else {\n+                    return Err(EvalError::InvalidPointerMath);\n+                }\n+            }\n+            (Sub, k) if k == PrimValKind::from_uint_size(self.memory.pointer_size())  => {\n+                if left.alloc_id == right.alloc_id {\n+                    return int_arithmetic!(k, overflowing_sub, left.offset, right.offset);\n+                } else {\n+                    return Err(EvalError::InvalidPointerMath);\n+                }\n+            }\n+            _ => {\n+                return Err(EvalError::ReadPointerAsBytes);\n+            }\n+        };\n+        Ok((val, false))\n     }\n }\n "}, {"sha": "fe4c6608ed3806caee75d99a68e09c3a882b9a62", "filename": "src/value.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36505c7b40b461744061c9da49a1c76996d46c4c/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36505c7b40b461744061c9da49a1c76996d46c4c/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=36505c7b40b461744061c9da49a1c76996d46c4c", "patch": "@@ -243,4 +243,12 @@ impl PrimValKind {\n             _ => bug!(\"can't make int with size {}\", size),\n         }\n     }\n+\n+    pub fn is_ptr(self) -> bool {\n+        use self::PrimValKind::*;\n+        match self {\n+            Ptr | FnPtr => true,\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "3a889be741efdf159f05fc87134203ef7e5b92e1", "filename": "tests/compile-fail/overflowing-lsh-neg.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36505c7b40b461744061c9da49a1c76996d46c4c/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36505c7b40b461744061c9da49a1c76996d46c4c/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foverflowing-lsh-neg.rs?ref=36505c7b40b461744061c9da49a1c76996d46c4c", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(exceeding_bitshifts)]\n+#![allow(const_err)]\n+\n+fn main() {\n+    let _n = 2i64 << -1; //~ Overflow(Shl)\n+}"}, {"sha": "78fd8e912b5e73524f20475050a86478b0c864c1", "filename": "tests/compile-fail/ptr_bitops.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/36505c7b40b461744061c9da49a1c76996d46c4c/tests%2Fcompile-fail%2Fptr_bitops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36505c7b40b461744061c9da49a1c76996d46c4c/tests%2Fcompile-fail%2Fptr_bitops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops.rs?ref=36505c7b40b461744061c9da49a1c76996d46c4c", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let one = bytes.as_ptr().wrapping_offset(1);\n+    let three = bytes.as_ptr().wrapping_offset(3);\n+    let res = (one as usize) | (three as usize); //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    println!(\"{}\", res);\n+}"}]}