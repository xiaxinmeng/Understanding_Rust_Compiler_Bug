{"sha": "8e9296994837c82c39b2c4cee7623d9181e4bc80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTI5Njk5NDgzN2M4MmMzOWIyYzRjZWU3NjIzZDkxODFlNGJjODA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-27T12:35:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-27T12:36:05Z"}, "message": "implement Windows SRWLock shims", "tree": {"sha": "8e7e87b9d9d17713786107201f9c08bce4ad0fac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e7e87b9d9d17713786107201f9c08bce4ad0fac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9296994837c82c39b2c4cee7623d9181e4bc80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9296994837c82c39b2c4cee7623d9181e4bc80", "html_url": "https://github.com/rust-lang/rust/commit/8e9296994837c82c39b2c4cee7623d9181e4bc80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9296994837c82c39b2c4cee7623d9181e4bc80/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dca00ab85ec970432ebaf1cf59b0e795db2d65cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca00ab85ec970432ebaf1cf59b0e795db2d65cd", "html_url": "https://github.com/rust-lang/rust/commit/dca00ab85ec970432ebaf1cf59b0e795db2d65cd"}], "stats": {"total": 199, "additions": 193, "deletions": 6}, "files": [{"sha": "0cd9ef0565058d6bd34cbbc45d9507511ce01aaf", "filename": "src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=8e9296994837c82c39b2c4cee7623d9181e4bc80", "patch": "@@ -230,7 +230,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n-        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),"}, {"sha": "737fd4314f632cc33e360b392d90112ec9a6a5d0", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=8e9296994837c82c39b2c4cee7623d9181e4bc80", "patch": "@@ -2,11 +2,16 @@ use rustc_middle::mir;\n \n use crate::*;\n use helpers::check_arg_count;\n+use shims::windows::sync::EvalContextExt as _;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n     AcquireSRWLockExclusive,\n+    ReleaseSRWLockExclusive,\n+    TryAcquireSRWLockExclusive,\n     AcquireSRWLockShared,\n+    ReleaseSRWLockShared,\n+    TryAcquireSRWLockShared,\n }\n \n impl Dlsym {\n@@ -15,7 +20,11 @@ impl Dlsym {\n     pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n         Ok(match name {\n             \"AcquireSRWLockExclusive\" => Some(Dlsym::AcquireSRWLockExclusive),\n+            \"ReleaseSRWLockExclusive\" => Some(Dlsym::ReleaseSRWLockExclusive),\n+            \"TryAcquireSRWLockExclusive\" => Some(Dlsym::TryAcquireSRWLockExclusive),\n             \"AcquireSRWLockShared\" => Some(Dlsym::AcquireSRWLockShared),\n+            \"ReleaseSRWLockShared\" => Some(Dlsym::ReleaseSRWLockShared),\n+            \"TryAcquireSRWLockShared\" => Some(Dlsym::TryAcquireSRWLockShared),\n             \"SetThreadStackGuarantee\" => None,\n             \"GetSystemTimePreciseAsFileTime\" => None,\n             _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n@@ -38,13 +47,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match dlsym {\n             Dlsym::AcquireSRWLockExclusive => {\n                 let &[ptr] = check_arg_count(args)?;\n-                let lock = this.deref_operand(ptr)?; // points to ptr-sized data\n-                throw_unsup_format!(\"AcquireSRWLockExclusive is not actually implemented\");\n+                this.AcquireSRWLockExclusive(ptr)?;\n+            }\n+            Dlsym::ReleaseSRWLockExclusive => {\n+                let &[ptr] = check_arg_count(args)?;\n+                this.ReleaseSRWLockExclusive(ptr)?;\n+            }\n+            Dlsym::TryAcquireSRWLockExclusive => {\n+                let &[ptr] = check_arg_count(args)?;\n+                let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n+                this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n             Dlsym::AcquireSRWLockShared => {\n                 let &[ptr] = check_arg_count(args)?;\n-                let lock = this.deref_operand(ptr)?; // points to ptr-sized data\n-                throw_unsup_format!(\"AcquireSRWLockExclusive is not actually implemented\");\n+                this.AcquireSRWLockShared(ptr)?;\n+            }\n+            Dlsym::ReleaseSRWLockShared => {\n+                let &[ptr] = check_arg_count(args)?;\n+                this.ReleaseSRWLockShared(ptr)?;\n+            }\n+            Dlsym::TryAcquireSRWLockShared => {\n+                let &[ptr] = check_arg_count(args)?;\n+                let ret = this.TryAcquireSRWLockShared(ptr)?;\n+                this.write_scalar(Scalar::from_u8(ret), dest)?;\n             }\n         }\n "}, {"sha": "ddb70b752e794f54634d02dc4ea3df28289a45ee", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=8e9296994837c82c39b2c4cee7623d9181e4bc80", "patch": "@@ -21,6 +21,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // HANDLE = isize\n         // DWORD = ULONG = u32\n         // BOOL = i32\n+        // BOOLEAN = u8\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n@@ -301,7 +302,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n-                // There is only one thread, so this always succeeds and returns TRUE\n+                // There is only one thread, so this always succeeds and returns TRUE.\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n "}, {"sha": "ef40eb089110400483f142e3337f1066db2c97d0", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9296994837c82c39b2c4cee7623d9181e4bc80/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=8e9296994837c82c39b2c4cee7623d9181e4bc80", "patch": "@@ -0,0 +1,161 @@\n+use rustc_target::abi::Size;\n+\n+use crate::*;\n+\n+// Locks are pointer-sized pieces of data, initialized to 0.\n+// We use them to count readers, with usize::MAX representing the write-locked state.\n+\n+fn deref_lock<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    lock_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n+    // `lock` is a pointer to `void*`; cast it to a pointer to `usize`.\n+    let lock = ecx.deref_operand(lock_op)?;\n+    let usize = ecx.machine.layouts.usize;\n+    assert_eq!(lock.layout.size, usize.size);\n+    Ok(lock.offset(Size::ZERO, MemPlaceMeta::None, usize, ecx)?)\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    #[allow(non_snake_case)]\n+    fn AcquireSRWLockExclusive(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n+        let lock = deref_lock(this, lock_op)?;\n+        let lock_val = this.read_scalar(lock.into())?.to_machine_usize(this)?;\n+        if lock_val == 0 {\n+            // Currently not locked. Lock it.\n+            let new_val = Scalar::from_machine_usize(this.machine_usize_max(), this);\n+            this.write_scalar(new_val, lock.into())?;\n+        } else {\n+            // Lock is already held. This is a deadlock.\n+            throw_machine_stop!(TerminationInfo::Deadlock);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn TryAcquireSRWLockExclusive(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, u8> {\n+        let this = self.eval_context_mut();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n+        let lock = deref_lock(this, lock_op)?;\n+        let lock_val = this.read_scalar(lock.into())?.to_machine_usize(this)?;\n+        if lock_val == 0 {\n+            // Currently not locked. Lock it.\n+            let new_val = this.machine_usize_max();\n+            this.write_scalar(Scalar::from_machine_usize(new_val, this), lock.into())?;\n+            Ok(1)\n+        } else {\n+            // Lock is already held.\n+            Ok(0)\n+        }\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn ReleaseSRWLockExclusive(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n+        let lock = deref_lock(this, lock_op)?;\n+        let lock_val = this.read_scalar(lock.into())?.to_machine_usize(this)?;\n+        if lock_val == this.machine_usize_max() {\n+            // Currently locked. Unlock it.\n+            let new_val = 0;\n+            this.write_scalar(Scalar::from_machine_usize(new_val, this), lock.into())?;\n+        } else {\n+            // Lock is not locked.\n+            throw_ub_format!(\"calling ReleaseSRWLockExclusive on an SRWLock that is not exclusively locked\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn AcquireSRWLockShared(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n+        let lock = deref_lock(this, lock_op)?;\n+        let lock_val = this.read_scalar(lock.into())?.to_machine_usize(this)?;\n+        if lock_val == this.machine_usize_max() {\n+            // Currently write locked. This is a deadlock.\n+            throw_machine_stop!(TerminationInfo::Deadlock);\n+        } else {\n+            // Bump up read counter (cannot overflow as we just checkd against usize::MAX);\n+            let new_val = lock_val+1;\n+            // Make sure this does not reach the \"write locked\" flag.\n+            if new_val == this.machine_usize_max() {\n+                throw_unsup_format!(\"SRWLock read-acquired too many times\");\n+            }\n+            this.write_scalar(Scalar::from_machine_usize(new_val, this), lock.into())?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn TryAcquireSRWLockShared(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, u8> {\n+        let this = self.eval_context_mut();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n+        let lock = deref_lock(this, lock_op)?;\n+        let lock_val = this.read_scalar(lock.into())?.to_machine_usize(this)?;\n+        if lock_val == this.machine_usize_max() {\n+            // Currently write locked.\n+            Ok(0)\n+        } else {\n+            // Bump up read counter (cannot overflow as we just checkd against usize::MAX);\n+            let new_val = lock_val+1;\n+            // Make sure this does not reach the \"write locked\" flag.\n+            if new_val == this.machine_usize_max() {\n+                throw_unsup_format!(\"SRWLock read-acquired too many times\");\n+            }\n+            this.write_scalar(Scalar::from_machine_usize(new_val, this), lock.into())?;\n+            Ok(1)\n+        }\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn ReleaseSRWLockShared(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+\n+        let lock = deref_lock(this, lock_op)?;\n+        let lock_val = this.read_scalar(lock.into())?.to_machine_usize(this)?;\n+        if lock_val == this.machine_usize_max() {\n+            // Currently write locked. This is a UB.\n+            throw_ub_format!(\"calling ReleaseSRWLockShared on write-locked SRWLock\");\n+        } else if lock_val == 0 {\n+            // Currently not locked at all.\n+            throw_ub_format!(\"calling ReleaseSRWLockShared on unlocked SRWLock\");\n+        } else {\n+            // Decrement read counter (cannot overflow as we just checkd against 0);\n+            let new_val = lock_val-1;\n+            this.write_scalar(Scalar::from_machine_usize(new_val, this), lock.into())?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}]}