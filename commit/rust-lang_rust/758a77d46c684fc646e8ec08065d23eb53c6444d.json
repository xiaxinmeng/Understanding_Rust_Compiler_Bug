{"sha": "758a77d46c684fc646e8ec08065d23eb53c6444d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1OGE3N2Q0NmM2ODRmYzY0NmU4ZWMwODA2NWQyM2ViNTNjNjQ0NGQ=", "commit": {"author": {"name": "steveklabnik", "email": "steve@steveklabnik.com", "date": "2018-04-06T19:06:53Z"}, "committer": {"name": "steveklabnik", "email": "steve@steveklabnik.com", "date": "2018-04-09T18:04:58Z"}, "message": "more lints", "tree": {"sha": "4b27837848fa4a6b1e69f8bbc872cf198ae1d205", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b27837848fa4a6b1e69f8bbc872cf198ae1d205"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758a77d46c684fc646e8ec08065d23eb53c6444d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758a77d46c684fc646e8ec08065d23eb53c6444d", "html_url": "https://github.com/rust-lang/rust/commit/758a77d46c684fc646e8ec08065d23eb53c6444d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758a77d46c684fc646e8ec08065d23eb53c6444d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df81ca37645835d41ae67d9f8e682244f40d53e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/df81ca37645835d41ae67d9f8e682244f40d53e7", "html_url": "https://github.com/rust-lang/rust/commit/df81ca37645835d41ae67d9f8e682244f40d53e7"}], "stats": {"total": 1081, "additions": 1035, "deletions": 46}, "files": [{"sha": "a432c00e0609a040fadddcbad2249935a0978167", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/758a77d46c684fc646e8ec08065d23eb53c6444d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/758a77d46c684fc646e8ec08065d23eb53c6444d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=758a77d46c684fc646e8ec08065d23eb53c6444d", "patch": "@@ -436,7 +436,7 @@ This lint detects enums with widely varying variant sizes. Some example code tha\n ```rust\n enum En {\n     V0(u8),\n-    VBig([u8; 1024]),   //~ ERROR variant is more than three times larger\n+    VBig([u8; 1024]),\n }\n ```\n "}, {"sha": "a8f3400687c2a148fec25ed136688cb9e44df761", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 1034, "deletions": 45, "changes": 1079, "blob_url": "https://github.com/rust-lang/rust/blob/758a77d46c684fc646e8ec08065d23eb53c6444d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/758a77d46c684fc646e8ec08065d23eb53c6444d/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=758a77d46c684fc646e8ec08065d23eb53c6444d", "patch": "@@ -2,48 +2,1037 @@\n \n These lints are all set to the 'warn' level by default.\n \n-                                    const-err  warn     constant evaluation detected erroneous expression\n-                                    dead-code  warn     detect unused, unexported items\n-                                   deprecated  warn     detects use of deprecated items\n-       illegal-floating-point-literal-pattern  warn     floating-point literals cannot be used in patterns\n-                              improper-ctypes  warn     proper use of libc types in foreign modules\n-                 incoherent-fundamental-impls  warn     potentially-conflicting impls were erroneously allowed\n-                late-bound-lifetime-arguments  warn     detects generic lifetime arguments in path segments with late bound lifetime parameters\n-                         non-camel-case-types  warn     types, variants, traits and type parameters should have camel case names\n-                 non-shorthand-field-patterns  warn     using `Struct { x: x }` instead of `Struct { x }` in a pattern\n-                               non-snake-case  warn     variables, methods, functions, lifetime parameters and modules should have snake case names\n-                       non-upper-case-globals  warn     static constants should have uppercase identifiers\n-                      no-mangle-generic-items  warn     generic items must be mangled\n-                         overflowing-literals  warn     literal out of range for its type\n-                              path-statements  warn     path statements with no effect\n-                 patterns-in-fns-without-body  warn     patterns in functions without body were erroneously allowed\n-                            plugin-as-library  warn     compiler plugin used as ordinary library in non-plugin crate\n-                            private-in-public  warn     detect private items in public interfaces not caught by the old implementation\n-                        private-no-mangle-fns  warn     functions marked #[no_mangle] should be exported\n-                    private-no-mangle-statics  warn     statics marked #[no_mangle] should be exported\n-                    renamed-and-removed-lints  warn     lints that have been renamed or removed\n-                          safe-packed-borrows  warn     safe borrows of fields of packed structs were was erroneously allowed\n-                              stable-features  warn     stable features found in #[feature] directive\n-                            type-alias-bounds  warn     bounds in type aliases are not enforced\n-                     tyvar-behind-raw-pointer  warn     raw pointer to an inference variable\n-                      unconditional-recursion  warn     functions that cannot return without calling themselves\n-                      unions-with-drop-fields  warn     use of unions that contain fields with possibly non-trivial drop code\n-                                unknown-lints  warn     unrecognized lint attribute\n-                             unreachable-code  warn     detects unreachable code paths\n-                         unreachable-patterns  warn     detects unreachable patterns\n-                      unstable-name-collision  warn     detects name collision with an existing but unstable method\n-                            unused-allocation  warn     detects unnecessary allocations that can be eliminated\n-                           unused-assignments  warn     detect assignments that will never be read\n-                            unused-attributes  warn     detects attributes that were not used by the compiler\n-                           unused-comparisons  warn     comparisons made useless by limits of the types involved\n-                           unused-doc-comment  warn     detects doc comments that aren't used by rustdoc\n-                              unused-features  warn     unused or unknown features found in crate-level #[feature] directives\n-                               unused-imports  warn     imports that are never used\n-                                unused-macros  warn     detects macros that were not used\n-                              unused-must-use  warn     unused result of a type flagged as #[must_use]\n-                                   unused-mut  warn     detect mut variables which don't need to be mutable\n-                                unused-parens  warn     `if`, `match`, `while` and `return` do not need parentheses\n-                                unused-unsafe  warn     unnecessary use of an `unsafe` block\n-                             unused-variables  warn     detect variables which are not used in any way\n-                                     warnings  warn     mass-change the level for lints which produce warnings\n-                                   while-true  warn     suggest using `loop { }` instead of `while true { }`\n\\ No newline at end of file\n+## const-err\n+\n+This lint detects an erroneous expression while doing constant evaluation. Some\n+example code that triggers this lint:\n+\n+```rust\n+let b = 200u8 + 200u8;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: attempt to add with overflow\n+ --> src/main.rs:2:9\n+  |\n+2 | let b = 200u8 + 200u8;\n+  |         ^^^^^^^^^^^^^\n+  |\n+```\n+\n+## dead-code\n+\n+This lint detects detect unused, unexported items. Some\n+example code that triggers this lint:\n+\n+```rust\n+fn foo() {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: function is never used: `foo`\n+ --> src/lib.rs:2:1\n+  |\n+2 | fn foo() {}\n+  | ^^^^^^^^\n+  |\n+```\n+\n+## deprecated\n+\n+This lint detects detects use of deprecated items. Some\n+example code that triggers this lint:\n+\n+```rust\n+#[deprecated]\n+fn foo() {}\n+\n+fn bar() {\n+    foo();\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: use of deprecated item 'foo'\n+ --> src/lib.rs:7:5\n+  |\n+7 |     foo();\n+  |     ^^^\n+  |\n+```\n+\n+## illegal-floating-point-literal-pattern\n+\n+This lint detects floating-point literals used in patterns. Some example code\n+that triggers this lint:\n+\n+```rust\n+let x = 42.0;\n+\n+match x {\n+    5.0 => {},\n+    _ => {},\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: floating-point literals cannot be used in patterns\n+ --> src/main.rs:4:9\n+  |\n+4 |         5.0 => {},\n+  |         ^^^\n+  |\n+  = note: #[warn(illegal_floating_point_literal_pattern)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n+```\n+\n+## improper-ctypes\n+\n+This lint detects proper use of libc types in foreign modules. Some\n+example code that triggers this lint:\n+\n+```rust\n+extern \"C\" {\n+    static STATIC: String;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a #[repr(C)] attribute to the type\n+ --> src/main.rs:2:20\n+  |\n+2 |     static STATIC: String;\n+  |                    ^^^^^^\n+  |\n+```\n+\n+## incoherent-fundamental-impls\n+\n+This lint detects potentially-conflicting impls that were erroneously allowed. Some\n+example code that triggers this lint:\n+\n+```rust\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n+  --> src/main.rs:13:1\n+   |\n+9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+   | --------------------------------------------- first implementation here\n+...\n+13 | impl<X> Trait1<Box<X>> for A {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n+   |\n+   = note: #[warn(incoherent_fundamental_impls)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n+   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+```\n+\n+## late-bound-lifetime-arguments\n+\n+This lint detects detects generic lifetime arguments in path segments with\n+late bound lifetime parameters. Some example code that triggers this lint:\n+\n+```rust\n+struct S;\n+\n+impl S {\n+    fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+}\n+\n+fn main() {\n+    S.late::<'static>(&0, &0);\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n+ --> src/main.rs:8:14\n+  |\n+4 |     fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+  |             -- the late bound lifetime parameter is introduced here\n+...\n+8 |     S.late::<'static>(&0, &0);\n+  |              ^^^^^^^\n+  |\n+  = note: #[warn(late_bound_lifetime_arguments)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n+```\n+\n+## non-camel-case-types\n+\n+This lint detects types, variants, traits and type parameters that don't have\n+camel case names. Some example code that triggers this lint:\n+\n+```rust\n+struct s;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: type `s` should have a camel case name such as `S`\n+ --> src/main.rs:1:1\n+  |\n+1 | struct s;\n+  | ^^^^^^^^^\n+  |\n+```\n+\n+## non-shorthand-field-patterns\n+\n+This lint detects using `Struct { x: x }` instead of `Struct { x }` in a pattern. Some\n+example code that triggers this lint:\n+\n+```rust\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+\n+fn main() {\n+    let p = Point {\n+        x: 5,\n+        y: 5,\n+    };\n+\n+    match p {\n+        Point { x: x, y: y } => (),\n+    }\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: the `x:` in this pattern is redundant\n+  --> src/main.rs:14:17\n+   |\n+14 |         Point { x: x, y: y } => (),\n+   |                 --^^\n+   |                 |\n+   |                 help: remove this\n+   |\n+\n+warning: the `y:` in this pattern is redundant\n+  --> src/main.rs:14:23\n+   |\n+14 |         Point { x: x, y: y } => (),\n+   |                       --^^\n+   |                       |\n+   |                       help: remove this\n+\n+```\n+\n+## non-snake-case\n+\n+This lint detects variables, methods, functions, lifetime parameters and\n+modules that don't have snake case names. Some example code that triggers\n+this lint:\n+\n+```rust\n+let X = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: variable `X` should have a snake case name such as `x`\n+ --> src/main.rs:2:9\n+  |\n+2 |     let X = 5;\n+  |         ^\n+  |\n+```\n+\n+## non-upper-case-globals\n+\n+This lint detects static constants that don't have uppercase identifiers.\n+Some example code that triggers this lint:\n+\n+```rust\n+static x: i32 = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: static variable `x` should have an upper case name such as `X`\n+ --> src/main.rs:1:1\n+  |\n+1 | static x: i32 = 5;\n+  | ^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## no-mangle-generic-items\n+\n+This lint detects generic items must be mangled. Some\n+example code that triggers this lint:\n+\n+```rust\n+#[no_mangle]\n+fn foo<T>(t: T) {\n+\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: functions generic over types must be mangled\n+ --> src/main.rs:2:1\n+  |\n+1 |   #[no_mangle]\n+  |   ------------ help: remove this attribute\n+2 | / fn foo<T>(t: T) {\n+3 | |     \n+4 | | }\n+  | |_^\n+  |\n+```\n+\n+## overflowing-literals\n+\n+This lint detects literal out of range for its type. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x: u8 = 1000;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: literal out of range for u8\n+ --> src/main.rs:2:17\n+  |\n+2 |     let x: u8 = 1000;\n+  |                 ^^^^\n+  |\n+```\n+\n+## path-statements\n+\n+This lint detects path statements with no effect. Some example code that\n+triggers this lint:\n+\n+```rust\n+let x = 42;\n+\n+x;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: path statement with no effect\n+ --> src/main.rs:3:5\n+  |\n+3 |     x;\n+  |     ^^\n+  |\n+```\n+\n+## patterns-in-fns-without-body\n+\n+This lint detects patterns in functions without body were that were\n+previously erroneously allowed. Some example code that triggers this lint:\n+\n+```rust\n+trait Trait {\n+    fn foo(mut arg: u8);\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: patterns aren't allowed in methods without bodies\n+ --> src/main.rs:2:12\n+  |\n+2 |     fn foo(mut arg: u8);\n+  |            ^^^^^^^\n+  |\n+  = note: #[warn(patterns_in_fns_without_body)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n+```\n+\n+To fix this, remove the pattern; it can be used in the implementation without\n+being used in the definition. That is:\n+\n+```rust\n+trait Trait {\n+    fn foo(arg: u8);\n+}\n+\n+impl Trait for i32 {\n+    fn foo(mut arg: u8) {\n+\n+    }\n+}\n+```\n+\n+## plugin-as-library\n+\n+This lint detects when compiler plugins are used as ordinary library in\n+non-plugin crate. Some example code that triggers this lint:\n+\n+```rust\n+#![feature(plugin)]\n+#![plugin(macro_crate_test)]\n+\n+extern crate macro_crate_test;\n+```\n+\n+## private-in-public\n+\n+This lint detects detect private items in public interfaces not caught by the old implementation. Some\n+example code that triggers this lint:\n+\n+```rust\n+pub trait Trait {\n+    type A;\n+}\n+\n+pub struct S;\n+\n+mod foo {\n+    struct Z;\n+\n+    impl ::Trait for ::S {\n+        type A = Z;\n+    }\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+error[E0446]: private type `foo::Z` in public interface\n+  --> src/main.rs:11:9\n+   |\n+11 |         type A = Z;\n+   |         ^^^^^^^^^^^ can't leak private type\n+```\n+\n+## private-no-mangle-fns\n+\n+This lint detects functions marked `#[no_mangle]` that are also private.\n+Given that private functions aren't exposed publicly, and `#[no_mangle]`\n+controls the public symbol, this combination is erroneous. Some example code\n+that triggers this lint:\n+\n+```rust\n+#[no_mangle]\n+fn foo() {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: function is marked #[no_mangle], but not exported\n+ --> src/main.rs:2:1\n+  |\n+2 | fn foo() {}\n+  | -^^^^^^^^^^\n+  | |\n+  | help: try making it public: `pub`\n+  |\n+```\n+\n+To fix this, either make it public or remove the `#[no_mangle]`.\n+\n+## private-no-mangle-statics\n+\n+This lint detects any statics marked `#[no_mangle]` that are private.\n+Given that private statics aren't exposed publicly, and `#[no_mangle]`\n+controls the public symbol, this combination is erroneous. Some example code\n+that triggers this lint:\n+\n+```rust\n+#[no_mangle]\n+static X: i32 = 4;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: static is marked #[no_mangle], but not exported\n+ --> src/main.rs:2:1\n+  |\n+2 | static X: i32 = 4;\n+  | -^^^^^^^^^^^^^^^^^\n+  | |\n+  | help: try making it public: `pub`\n+  |\n+```\n+\n+To fix this, either make it public or remove the `#[no_mangle]`.\n+\n+## renamed-and-removed-lints\n+\n+This lint detects lints that have been renamed or removed. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![deny(raw_pointer_derive)]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: lint raw_pointer_derive has been removed: using derive with raw pointers is ok\n+ --> src/main.rs:1:9\n+  |\n+1 | #![deny(raw_pointer_derive)]\n+  |         ^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+To fix this, either remove the lint or use the new name.\n+\n+## safe-packed-borrows\n+\n+This lint detects borrowing a field in the interior of a packed structure\n+with alignment other than 1. Some example code that triggers this lint:\n+\n+```rust\n+#[repr(packed)]\n+pub struct Unaligned<T>(pub T);\n+\n+pub struct Foo {\n+    start: u8,\n+    data: Unaligned<u32>,\n+}\n+\n+fn main() {\n+    let x = Foo { start: 0, data: Unaligned(1) };\n+    let y = &x.data.0;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: borrow of packed field requires unsafe function or block (error E0133)\n+  --> src/main.rs:11:13\n+   |\n+11 |     let y = &x.data.0; \n+   |             ^^^^^^^^^\n+   |\n+   = note: #[warn(safe_packed_borrows)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+```\n+\n+## stable-features\n+\n+This lint detects a `#[feature]` attribute that's since been made stable. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![feature(test_accepted_feature)]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: this feature has been stable since 1.0.0. Attribute no longer needed\n+ --> src/main.rs:1:12\n+  |\n+1 | #![feature(test_accepted_feature)]\n+  |            ^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+To fix, simply remove the `#![feature]` attribute, as it's no longer needed.\n+\n+## type-alias-bounds\n+\n+This lint detects bounds in type aliases. These are not currently enforced.\n+Some example code that triggers this lint:\n+\n+```rust\n+type SendVec<T: Send> = Vec<T>;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: type alias is never used: `SendVec`\n+ --> src/main.rs:1:1\n+  |\n+1 | type SendVec<T: Send> = Vec<T>;\n+  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## tyvar-behind-raw-pointer\n+\n+This lint detects raw pointer to an inference variable. Some\n+example code that triggers this lint:\n+\n+```rust\n+let data = std::ptr::null();\n+let _ = &data as *const *const ();\n+\n+if data.is_null() {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: type annotations needed\n+ --> src/main.rs:4:13\n+  |\n+4 |     if data.is_null() {}\n+  |             ^^^^^^^\n+  |\n+  = note: #[warn(tyvar_behind_raw_pointer)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+  = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n+```\n+\n+## unconditional-recursion\n+\n+This lint detects functions that cannot return without calling themselves.\n+Some example code that triggers this lint:\n+\n+```rust\n+fn foo() {\n+    foo();\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: function cannot return without recurring\n+ --> src/main.rs:1:1\n+  |\n+1 | fn foo() {\n+  | ^^^^^^^^ cannot return without recurring\n+2 |     foo();\n+  |     ----- recursive call site\n+  |\n+```\n+\n+## unions-with-drop-fields\n+\n+This lint detects use of unions that contain fields with possibly non-trivial drop code. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![feature(untagged_unions)]\n+\n+union U {\n+    s: String,\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n+ --> src/main.rs:4:5\n+  |\n+4 |     s: String,\n+  |     ^^^^^^^^^\n+  |\n+```\n+\n+## unknown-lints\n+\n+This lint detects unrecognized lint attribute. Some\n+example code that triggers this lint:\n+\n+```rust\n+#[allow(not_a_real_lint)]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unknown lint: `not_a_real_lint`\n+ --> src/main.rs:1:10\n+  |\n+1 | #![allow(not_a_real_lint)]\n+  |          ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unreachable-code\n+\n+This lint detects detects unreachable code paths. Some example code that\n+triggers this lint:\n+\n+```rust\n+panic!(\"we never go past here!\");\n+\n+let x = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unreachable statement\n+ --> src/main.rs:4:5\n+  |\n+4 |     let x = 5;\n+  |     ^^^^^^^^^^\n+  |\n+```\n+\n+## unreachable-patterns\n+\n+This lint detects detects unreachable patterns. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x = 5;\n+match x {\n+    y => (),\n+    5 => (),\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unreachable pattern\n+ --> src/main.rs:5:5\n+  |\n+5 |     5 => (),\n+  |     ^\n+  |\n+```\n+\n+The `y` pattern will always match, so the five is impossible to reach.\n+Remember, match arms match in order, you probably wanted to put the `5` case\n+above the `y` case.\n+\n+## unstable-name-collision\n+\n+This lint detects that you've used a name that the standard library plans to\n+add in the future, which means that your code may fail to compile without\n+additional type annotations in the future. Either rename, or add those\n+annotations now.\n+\n+## unused-allocation\n+\n+This lint detects detects unnecessary allocations that can be eliminated.\n+\n+## unused-assignments\n+\n+This lint detects detect assignments that will never be read. Some\n+example code that triggers this lint:\n+\n+```rust\n+let mut x = 5;\n+x = 6;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: value assigned to `x` is never read\n+ --> src/main.rs:4:5\n+  |\n+4 |     x = 6;\n+  |     ^\n+  |\n+```\n+\n+## unused-attributes\n+\n+This lint detects detects attributes that were not used by the compiler. Some\n+example code that triggers this lint:\n+\n+```rust\n+#![feature(custom_attribute)]\n+\n+#![mutable_doc]\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused attribute\n+ --> src/main.rs:4:1\n+  |\n+4 | #![mutable_doc]\n+  | ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-comparisons\n+\n+This lint detects comparisons made useless by limits of the types involved. Some\n+example code that triggers this lint:\n+\n+```rust\n+fn foo(x: u8) {\n+    x >= 0;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: comparison is useless due to type limits\n+ --> src/main.rs:6:5\n+  |\n+6 |     x >= 0;\n+  |     ^^^^^^\n+  |\n+```\n+\n+## unused-doc-comment\n+\n+This lint detects detects doc comments that aren't used by rustdoc. Some\n+example code that triggers this lint:\n+\n+```rust\n+/// docs for x\n+let x = 12;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: doc comment not used by rustdoc\n+ --> src/main.rs:2:5\n+  |\n+2 |     /// docs for x\n+  |     ^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-features\n+\n+This lint detects unused or unknown features found in crate-level #[feature] directives.\n+To fix this, simply remove the feature flag.\n+\n+## unused-imports\n+\n+This lint detects imports that are never used. Some\n+example code that triggers this lint:\n+\n+```rust\n+use std::collections::HashMap;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused import: `std::collections::HashMap`\n+ --> src/main.rs:1:5\n+  |\n+1 | use std::collections::HashMap;\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-macros\n+\n+This lint detects detects macros that were not used. Some example code that\n+triggers this lint:\n+\n+```rust\n+macro_rules! unused {\n+    () => {};\n+}\n+\n+fn main() {\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused macro definition\n+ --> src/main.rs:1:1\n+  |\n+1 | / macro_rules! unused {\n+2 | |     () => {};\n+3 | | }\n+  | |_^\n+  |\n+```\n+\n+## unused-must-use\n+\n+This lint detects unused result of a type flagged as #[must_use]. Some\n+example code that triggers this lint:\n+\n+```rust\n+fn returns_result() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    returns_result();\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused `std::result::Result` which must be used\n+ --> src/main.rs:6:5\n+  |\n+6 |     returns_result();\n+  |     ^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-mut\n+\n+This lint detects detect mut variables which don't need to be mutable. Some\n+example code that triggers this lint:\n+\n+```rust\n+let mut x = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: variable does not need to be mutable\n+ --> src/main.rs:2:9\n+  |\n+2 |     let mut x = 5;\n+  |         ----^\n+  |         |\n+  |         help: remove this `mut`\n+  |\n+```\n+\n+## unused-parens\n+\n+This lint detects `if`, `match`, `while` and `return` with parentheses; they\n+do not need them. Some example code that triggers this lint:\n+\n+```rust\n+if(true) {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unnecessary parentheses around `if` condition\n+ --> src/main.rs:2:7\n+  |\n+2 |     if(true) {}\n+  |       ^^^^^^ help: remove these parentheses\n+  |\n+```\n+\n+## unused-unsafe\n+\n+This lint detects unnecessary use of an `unsafe` block. Some\n+example code that triggers this lint:\n+\n+```rust\n+unsafe {}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unnecessary `unsafe` block\n+ --> src/main.rs:2:5\n+  |\n+2 |     unsafe {}\n+  |     ^^^^^^ unnecessary `unsafe` block\n+  |\n+```\n+\n+## unused-variables\n+\n+This lint detects detect variables which are not used in any way. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+warning: unused variable: `x`\n+ --> src/main.rs:2:9\n+  |\n+2 |     let x = 5;\n+  |         ^ help: consider using `_x` instead\n+  |\n+```\n+\n+## warnings\n+\n+This lint is a bit special; by changing its level, you change every other warning\n+that would produce a warning to whatever value you'd like:\n+\n+```rust\n+#![deny(warnings)]\n+```\n+\n+As such, you won't ever trigger this lint in your code directly.\n+\n+## while-true\n+\n+This lint detects `while true { }`. Some example code that triggers this\n+lint:\n+\n+```rust\n+while true {\n+\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+warning: denote infinite loops with `loop { ... }`\n+ --> src/main.rs:2:5\n+  |\n+2 |     while true {\n+  |     ^^^^^^^^^^ help: use `loop`\n+  |\n+```\n\\ No newline at end of file"}]}