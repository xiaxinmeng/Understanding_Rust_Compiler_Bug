{"sha": "2716a1fa3f8a7410248724a6ce5d4c28837db682", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MTZhMWZhM2Y4YTc0MTAyNDg3MjRhNmNlNWQ0YzI4ODM3ZGI2ODI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-02T18:00:38Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-02T18:00:38Z"}, "message": "More principled approach for gotodef for field shorhand\n\nCallers can now decide for themselves if they should prefer field or\nlocal definition. By default, it's the local.", "tree": {"sha": "ad1faf323e4cb1478e1e34e2ed9fe858c5be80e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad1faf323e4cb1478e1e34e2ed9fe858c5be80e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2716a1fa3f8a7410248724a6ce5d4c28837db682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2716a1fa3f8a7410248724a6ce5d4c28837db682", "html_url": "https://github.com/rust-lang/rust/commit/2716a1fa3f8a7410248724a6ce5d4c28837db682", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2716a1fa3f8a7410248724a6ce5d4c28837db682/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96eca8a1abd79840b9040250db9d1e65ec663b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/96eca8a1abd79840b9040250db9d1e65ec663b0e", "html_url": "https://github.com/rust-lang/rust/commit/96eca8a1abd79840b9040250db9d1e65ec663b0e"}], "stats": {"total": 115, "additions": 79, "deletions": 36}, "files": [{"sha": "afc7f7ee77a0d136dd43d9992f63f191089e9333", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -107,8 +107,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.analyze(field.syntax()).resolve_field(field)\n     }\n \n-    pub fn resolve_record_field(&self, field: &ast::RecordField) -> Option<StructField> {\n-        self.analyze(field.syntax()).resolve_record_field(field)\n+    pub fn resolve_record_field(\n+        &self,\n+        field: &ast::RecordField,\n+    ) -> Option<(StructField, Option<Local>)> {\n+        self.analyze(field.syntax()).resolve_record_field(self.db, field)\n     }\n \n     pub fn resolve_record_literal(&self, record_lit: &ast::RecordLit) -> Option<VariantDef> {"}, {"sha": "015389fb06ac1b6f8f8d2c7354798562e73e07e1", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -5,7 +5,7 @@\n //!\n //! So, this modules should not be used during hir construction, it exists\n //! purely for \"IDE needs\".\n-use std::sync::Arc;\n+use std::{iter::once, sync::Arc};\n \n use either::Either;\n use hir_def::{\n@@ -25,8 +25,8 @@ use ra_syntax::{\n };\n \n use crate::{\n-    db::HirDatabase, Adt, Const, EnumVariant, Function, Local, MacroDef, ModuleDef, Path, Static,\n-    Struct, Trait, Type, TypeAlias, TypeParam,\n+    db::HirDatabase, Adt, Const, EnumVariant, Function, Local, MacroDef, ModPath, ModuleDef, Path,\n+    PathKind, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n@@ -162,16 +162,27 @@ impl SourceAnalyzer {\n \n     pub(crate) fn resolve_record_field(\n         &self,\n+        db: &impl HirDatabase,\n         field: &ast::RecordField,\n-    ) -> Option<crate::StructField> {\n-        let expr_id = match field.expr() {\n-            Some(it) => self.expr_id(&it)?,\n+    ) -> Option<(crate::StructField, Option<Local>)> {\n+        let (expr_id, local) = match field.expr() {\n+            Some(it) => (self.expr_id(&it)?, None),\n             None => {\n                 let src = InFile { file_id: self.file_id, value: field };\n-                self.body_source_map.as_ref()?.field_init_shorthand_expr(src)?\n+                let expr_id = self.body_source_map.as_ref()?.field_init_shorthand_expr(src)?;\n+                let local_name = field.name_ref()?.as_name();\n+                let path = ModPath::from_segments(PathKind::Plain, once(local_name));\n+                let local = match self.resolver.resolve_path_in_value_ns_fully(db, &path) {\n+                    Some(ValueNs::LocalBinding(pat_id)) => {\n+                        Some(Local { pat_id, parent: self.resolver.body_owner()? })\n+                    }\n+                    _ => None,\n+                };\n+                (expr_id, local)\n             }\n         };\n-        self.infer.as_ref()?.record_field_resolution(expr_id).map(|it| it.into())\n+        let struct_field = self.infer.as_ref()?.record_field_resolution(expr_id)?;\n+        Some((struct_field.into(), local))\n     }\n \n     pub(crate) fn resolve_record_literal("}, {"sha": "76ee232a3a1774e9c9f2d51a31e6ab810ac20c25", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -76,6 +76,8 @@ pub(crate) fn reference_definition(\n \n     let name_kind = classify_name_ref(sema, name_ref);\n     if let Some(def) = name_kind {\n+        let def = def.definition();\n+\n         return match def.try_to_nav(sema.db) {\n             Some(nav) => ReferenceResult::Exact(nav),\n             None => ReferenceResult::Approximate(Vec::new()),\n@@ -795,8 +797,8 @@ mod tests {\n                 Foo { x<|> };\n             }\n             \",\n-            \"x RECORD_FIELD_DEF FileId(1) [13; 19) [13; 14)\",\n-            \"x: i32|x\",\n+            \"x BIND_PAT FileId(1) [42; 43)\",\n+            \"x\",\n         )\n     }\n }"}, {"sha": "b319566267759a8c70e1a0b724c900fba00e4cfa", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -153,7 +153,7 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     if let Some((node, name_kind)) = match_ast! {\n         match (token.parent()) {\n             ast::NameRef(name_ref) => {\n-                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d))\n+                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n             },\n             ast::Name(name) => {\n                 classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))"}, {"sha": "2eb047c9684715d9b327764cb481f9590f76104a", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -27,7 +27,10 @@ use test_utils::tested_by;\n \n use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeInfo};\n \n-pub(crate) use self::{classify::classify_name_ref, rename::rename};\n+pub(crate) use self::{\n+    classify::{classify_name_ref, NameRefClass},\n+    rename::rename,\n+};\n pub(crate) use ra_ide_db::defs::{classify_name, NameDefinition};\n \n pub use self::search_scope::SearchScope;\n@@ -160,7 +163,7 @@ fn find_name(\n         return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n     }\n     let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(sema, &name_ref)?;\n+    let def = classify_name_ref(sema, &name_ref)?.definition();\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n }\n@@ -212,6 +215,7 @@ fn process_definition(\n             // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n \n             if let Some(d) = classify_name_ref(&sema, &name_ref) {\n+                let d = d.definition();\n                 if d == def {\n                     let kind =\n                         if is_record_lit_name_ref(&name_ref) || is_call_expr_name_ref(&name_ref) {"}, {"sha": "e837ca8a3cecd36c9bdff7cc86ca91fe54ab79b9", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -1,6 +1,6 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{PathResolution, Semantics};\n+use hir::{Local, PathResolution, Semantics};\n use ra_ide_db::defs::NameDefinition;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n@@ -9,40 +9,59 @@ use test_utils::tested_by;\n \n pub use ra_ide_db::defs::{from_module_def, from_struct_field};\n \n+pub enum NameRefClass {\n+    NameDefinition(NameDefinition),\n+    FieldShorthand { local: Local, field: NameDefinition },\n+}\n+\n+impl NameRefClass {\n+    pub fn definition(self) -> NameDefinition {\n+        match self {\n+            NameRefClass::NameDefinition(def) => def,\n+            NameRefClass::FieldShorthand { local, field: _ } => NameDefinition::Local(local),\n+        }\n+    }\n+}\n+\n pub(crate) fn classify_name_ref(\n     sema: &Semantics<RootDatabase>,\n     name_ref: &ast::NameRef,\n-) -> Option<NameDefinition> {\n+) -> Option<NameRefClass> {\n     let _p = profile(\"classify_name_ref\");\n \n     let parent = name_ref.syntax().parent()?;\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = sema.resolve_method_call(&method_call) {\n-            return Some(from_module_def(func.into()));\n+            return Some(NameRefClass::NameDefinition(NameDefinition::ModuleDef(func.into())));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_fields);\n         if let Some(field) = sema.resolve_field(&field_expr) {\n-            return Some(from_struct_field(field));\n+            return Some(NameRefClass::NameDefinition(NameDefinition::StructField(field)));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n         tested_by!(goto_def_for_record_fields);\n         tested_by!(goto_def_for_field_init_shorthand);\n-        if let Some(field_def) = sema.resolve_record_field(&record_field) {\n-            return Some(from_struct_field(field_def));\n+        if let Some((field, local)) = sema.resolve_record_field(&record_field) {\n+            let field = NameDefinition::StructField(field);\n+            let res = match local {\n+                None => NameRefClass::NameDefinition(field),\n+                Some(local) => NameRefClass::FieldShorthand { field, local },\n+            };\n+            return Some(res);\n         }\n     }\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n         if let Some(macro_def) = sema.resolve_macro_call(&macro_call) {\n-            return Some(NameDefinition::Macro(macro_def));\n+            return Some(NameRefClass::NameDefinition(NameDefinition::Macro(macro_def)));\n         }\n     }\n \n@@ -63,5 +82,5 @@ pub(crate) fn classify_name_ref(\n         PathResolution::Macro(def) => NameDefinition::Macro(def),\n         PathResolution::SelfType(impl_def) => NameDefinition::SelfType(impl_def),\n     };\n-    Some(res)\n+    Some(NameRefClass::NameDefinition(res))\n }"}, {"sha": "b89501aff6fd3d93b9eee4cd719f655041949a7b", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2716a1fa3f8a7410248724a6ce5d4c28837db682/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=2716a1fa3f8a7410248724a6ce5d4c28837db682", "patch": "@@ -19,7 +19,11 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashMap;\n \n-use crate::{call_info::call_info_for_token, references::classify_name_ref, Analysis, FileId};\n+use crate::{\n+    call_info::call_info_for_token,\n+    references::{classify_name_ref, NameRefClass},\n+    Analysis, FileId,\n+};\n \n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n@@ -186,24 +190,24 @@ fn highlight_element(\n         }\n \n         // Highlight references like the definitions they resolve to\n-\n-        // Special-case field init shorthand\n-        NAME_REF if element.parent().and_then(ast::RecordField::cast).is_some() => {\n-            HighlightTag::Field.into()\n-        }\n         NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => return None,\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n             let name_kind = classify_name_ref(sema, &name_ref)?;\n \n-            if let NameDefinition::Local(local) = &name_kind {\n-                if let Some(name) = local.name(db) {\n-                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n-                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+            match name_kind {\n+                NameRefClass::NameDefinition(def) => {\n+                    if let NameDefinition::Local(local) = &def {\n+                        if let Some(name) = local.name(db) {\n+                            let shadow_count =\n+                                bindings_shadow_count.entry(name.clone()).or_default();\n+                            binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                        }\n+                    };\n+                    highlight_name(db, def)\n                 }\n-            };\n-\n-            highlight_name(db, name_kind)\n+                NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n+            }\n         }\n \n         // Simple token-based highlighting"}]}