{"sha": "a15f484b918a4533ad633ea903ccce82910af342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNWY0ODRiOTE4YTQ1MzNhZDYzM2VhOTAzY2NjZTgyOTEwYWYzNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-22T17:56:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-22T17:56:43Z"}, "message": "Auto merge of #81362 - ssomers:btree_drainy_refactor_8, r=Mark-Simulacrum\n\nBTreeMap: gather and decompose reusable tree fixing functions\n\nThis is kind of pushing it as a standalone refactor, probably only useful for #81075 (or similar).\nr? `@Mark-Simulacrum`", "tree": {"sha": "ae521289a5e67a947cf84e785bb1d73453ddc38e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae521289a5e67a947cf84e785bb1d73453ddc38e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a15f484b918a4533ad633ea903ccce82910af342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a15f484b918a4533ad633ea903ccce82910af342", "html_url": "https://github.com/rust-lang/rust/commit/a15f484b918a4533ad633ea903ccce82910af342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a15f484b918a4533ad633ea903ccce82910af342/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15598a83db88ec7a32ea18a44dd6309f32edc07e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15598a83db88ec7a32ea18a44dd6309f32edc07e", "html_url": "https://github.com/rust-lang/rust/commit/15598a83db88ec7a32ea18a44dd6309f32edc07e"}, {"sha": "cbbdb4439ab9a668d119615d9b8c8876e4bbc10f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbdb4439ab9a668d119615d9b8c8876e4bbc10f", "html_url": "https://github.com/rust-lang/rust/commit/cbbdb4439ab9a668d119615d9b8c8876e4bbc10f"}], "stats": {"total": 322, "additions": 176, "deletions": 146}, "files": [{"sha": "a30a21db5347f443da4eeb94dfead3d77475b0fa", "filename": "library/alloc/src/collections/btree/append.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fappend.rs?ref=a15f484b918a4533ad633ea903ccce82910af342", "patch": "@@ -1,6 +1,5 @@\n-use super::map::MIN_LEN;\n use super::merge_iter::MergeIterInner;\n-use super::node::{self, ForceResult::*, Root};\n+use super::node::{self, Root};\n use core::iter::FusedIterator;\n \n impl<K, V> Root<K, V> {\n@@ -83,26 +82,6 @@ impl<K, V> Root<K, V> {\n         }\n         self.fix_right_border_of_plentiful();\n     }\n-\n-    /// Stock up any underfull nodes on the right border of the tree.\n-    /// The other nodes, those that are not the root nor a rightmost edge,\n-    /// must have MIN_LEN elements to spare.\n-    fn fix_right_border_of_plentiful(&mut self) {\n-        let mut cur_node = self.borrow_mut();\n-        while let Internal(internal) = cur_node.force() {\n-            // Check if right-most child is underfull.\n-            let mut last_kv = internal.last_kv().consider_for_balancing();\n-            debug_assert!(last_kv.left_child_len() >= MIN_LEN * 2);\n-            let right_child_len = last_kv.right_child_len();\n-            if right_child_len < MIN_LEN {\n-                // We need to steal.\n-                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n-            }\n-\n-            // Go further down.\n-            cur_node = last_kv.into_right_child();\n-        }\n-    }\n }\n \n // An iterator for merging two sorted sequences into one"}, {"sha": "af87a9b956a176d9bc59f5d4eb7494ce82380ce5", "filename": "library/alloc/src/collections/btree/fix.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Ffix.rs?ref=a15f484b918a4533ad633ea903ccce82910af342", "patch": "@@ -0,0 +1,171 @@\n+use super::map::MIN_LEN;\n+use super::node::{marker, ForceResult::*, Handle, LeftOrRight::*, NodeRef, Root};\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Stocks up a possibly underfull node by merging with or stealing from a\n+    /// sibling. If succesful but at the cost of shrinking the parent node,\n+    /// returns that shrunk parent node. Returns an `Err` if the node is\n+    /// an empty root.\n+    fn fix_node_through_parent(\n+        self,\n+    ) -> Result<Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>>, Self> {\n+        let len = self.len();\n+        if len >= MIN_LEN {\n+            Ok(None)\n+        } else {\n+            match self.choose_parent_kv() {\n+                Ok(Left(mut left_parent_kv)) => {\n+                    if left_parent_kv.can_merge() {\n+                        let parent = left_parent_kv.merge_tracking_parent();\n+                        Ok(Some(parent))\n+                    } else {\n+                        left_parent_kv.bulk_steal_left(MIN_LEN - len);\n+                        Ok(None)\n+                    }\n+                }\n+                Ok(Right(mut right_parent_kv)) => {\n+                    if right_parent_kv.can_merge() {\n+                        let parent = right_parent_kv.merge_tracking_parent();\n+                        Ok(Some(parent))\n+                    } else {\n+                        right_parent_kv.bulk_steal_right(MIN_LEN - len);\n+                        Ok(None)\n+                    }\n+                }\n+                Err(root) => {\n+                    if len > 0 {\n+                        Ok(None)\n+                    } else {\n+                        Err(root)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Stocks up a possibly underfull node, and if that causes its parent node\n+    /// to shrink, stocks up the parent, recursively.\n+    /// Returns `true` if it fixed the tree, `false` if it couldn't because the\n+    /// root node became empty.\n+    ///\n+    /// This method does not expect ancestors to already be underfull upon entry\n+    /// and panics if it encounters an empty ancestor.\n+    pub fn fix_node_and_affected_ancestors(mut self) -> bool {\n+        loop {\n+            match self.fix_node_through_parent() {\n+                Ok(Some(parent)) => self = parent.forget_type(),\n+                Ok(None) => return true,\n+                Err(_) => return false,\n+            }\n+        }\n+    }\n+}\n+\n+impl<K, V> Root<K, V> {\n+    /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n+    pub fn fix_top(&mut self) {\n+        while self.height() > 0 && self.len() == 0 {\n+            self.pop_internal_level();\n+        }\n+    }\n+\n+    /// Stocks up or merge away any underfull nodes on the right border of the\n+    /// tree. The other nodes, those that are not the root nor a rightmost edge,\n+    /// must already have at least MIN_LEN elements.\n+    pub fn fix_right_border(&mut self) {\n+        self.fix_top();\n+        if self.len() > 0 {\n+            self.borrow_mut().last_kv().fix_right_border_of_right_edge();\n+            self.fix_top();\n+        }\n+    }\n+\n+    /// The symmetric clone of `fix_right_border`.\n+    pub fn fix_left_border(&mut self) {\n+        self.fix_top();\n+        if self.len() > 0 {\n+            self.borrow_mut().first_kv().fix_left_border_of_left_edge();\n+            self.fix_top();\n+        }\n+    }\n+\n+    /// Stock up any underfull nodes on the right border of the tree.\n+    /// The other nodes, those that are not the root nor a rightmost edge,\n+    /// must be prepared to have up to MIN_LEN elements stolen.\n+    pub fn fix_right_border_of_plentiful(&mut self) {\n+        let mut cur_node = self.borrow_mut();\n+        while let Internal(internal) = cur_node.force() {\n+            // Check if right-most child is underfull.\n+            let mut last_kv = internal.last_kv().consider_for_balancing();\n+            debug_assert!(last_kv.left_child_len() >= MIN_LEN * 2);\n+            let right_child_len = last_kv.right_child_len();\n+            if right_child_len < MIN_LEN {\n+                // We need to steal.\n+                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n+            }\n+\n+            // Go further down.\n+            cur_node = last_kv.into_right_child();\n+        }\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    fn fix_left_border_of_left_edge(mut self) {\n+        while let Internal(internal_kv) = self.force() {\n+            self = internal_kv.fix_left_child().first_kv();\n+            debug_assert!(self.reborrow().into_node().len() > MIN_LEN);\n+        }\n+    }\n+\n+    fn fix_right_border_of_right_edge(mut self) {\n+        while let Internal(internal_kv) = self.force() {\n+            self = internal_kv.fix_right_child().last_kv();\n+            debug_assert!(self.reborrow().into_node().len() > MIN_LEN);\n+        }\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::KV> {\n+    /// Stocks up the left child, assuming the right child isn't underfull, and\n+    /// provisions an extra element to allow merging its children in turn\n+    /// without becoming underfull.\n+    /// Returns the left child.\n+    fn fix_left_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+        let mut internal_kv = self.consider_for_balancing();\n+        let left_len = internal_kv.left_child_len();\n+        debug_assert!(internal_kv.right_child_len() >= MIN_LEN);\n+        if internal_kv.can_merge() {\n+            internal_kv.merge_tracking_child()\n+        } else {\n+            // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n+            let count = (MIN_LEN + 1).saturating_sub(left_len);\n+            if count > 0 {\n+                internal_kv.bulk_steal_right(count);\n+            }\n+            internal_kv.into_left_child()\n+        }\n+    }\n+\n+    /// Stocks up the right child, assuming the left child isn't underfull, and\n+    /// provisions an extra element to allow merging its children in turn\n+    /// without becoming underfull.\n+    /// Returns wherever the right child ended up.\n+    fn fix_right_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n+        let mut internal_kv = self.consider_for_balancing();\n+        let right_len = internal_kv.right_child_len();\n+        debug_assert!(internal_kv.left_child_len() >= MIN_LEN);\n+        if internal_kv.can_merge() {\n+            internal_kv.merge_tracking_child()\n+        } else {\n+            // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n+            let count = (MIN_LEN + 1).saturating_sub(right_len);\n+            if count > 0 {\n+                internal_kv.bulk_steal_left(count);\n+            }\n+            internal_kv.into_right_child()\n+        }\n+    }\n+}"}, {"sha": "f74172c7d976fb50f4921cb9f772f51466822ae4", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=a15f484b918a4533ad633ea903ccce82910af342", "patch": "@@ -1,5 +1,6 @@\n mod append;\n mod borrow;\n+mod fix;\n pub mod map;\n mod mem;\n mod merge_iter;"}, {"sha": "6bc1252b9cb9d60604da628a2a5bf280f67e8579", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "modified", "additions": 3, "deletions": 60, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=a15f484b918a4533ad633ea903ccce82910af342", "patch": "@@ -60,7 +60,9 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n             // rearrange the parent through the grandparent, thus change the\n             // link to the parent inside the leaf.\n             if let Ok(parent) = unsafe { pos.reborrow_mut() }.into_node().ascend() {\n-                parent.into_node().handle_shrunk_node_recursively(handle_emptied_internal_root);\n+                if !parent.into_node().forget_type().fix_node_and_affected_ancestors() {\n+                    handle_emptied_internal_root();\n+                }\n             }\n         }\n         (old_kv, pos)\n@@ -87,62 +89,3 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         (old_kv, pos)\n     }\n }\n-\n-impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n-    /// Stocks up a possibly underfull internal node and its ancestors,\n-    /// until it reaches an ancestor that has elements to spare or is the root.\n-    fn handle_shrunk_node_recursively<F: FnOnce()>(mut self, handle_emptied_internal_root: F) {\n-        loop {\n-            self = match self.len() {\n-                0 => {\n-                    // An empty node must be the root, because length is only\n-                    // reduced by one, and non-root underfull nodes are stocked up,\n-                    // so non-root nodes never have fewer than MIN_LEN - 1 elements.\n-                    debug_assert!(self.ascend().is_err());\n-                    handle_emptied_internal_root();\n-                    return;\n-                }\n-                1..MIN_LEN => {\n-                    if let Some(parent) = self.handle_underfull_node_locally() {\n-                        parent\n-                    } else {\n-                        return;\n-                    }\n-                }\n-                _ => return,\n-            }\n-        }\n-    }\n-\n-    /// Stocks up an underfull internal node, possibly at the cost of shrinking\n-    /// its parent instead, which is then returned.\n-    fn handle_underfull_node_locally(\n-        self,\n-    ) -> Option<NodeRef<marker::Mut<'a>, K, V, marker::Internal>> {\n-        match self.forget_type().choose_parent_kv() {\n-            Ok(Left(mut left_parent_kv)) => {\n-                debug_assert_eq!(left_parent_kv.right_child_len(), MIN_LEN - 1);\n-                if left_parent_kv.can_merge() {\n-                    let parent = left_parent_kv.merge_tracking_parent();\n-                    Some(parent)\n-                } else {\n-                    debug_assert!(left_parent_kv.left_child_len() > MIN_LEN);\n-                    left_parent_kv.bulk_steal_left(1);\n-                    None\n-                }\n-            }\n-            Ok(Right(mut right_parent_kv)) => {\n-                debug_assert_eq!(right_parent_kv.left_child_len(), MIN_LEN - 1);\n-                if right_parent_kv.can_merge() {\n-                    let parent = right_parent_kv.merge_tracking_parent();\n-                    Some(parent)\n-                } else {\n-                    debug_assert!(right_parent_kv.right_child_len() > MIN_LEN);\n-                    right_parent_kv.bulk_steal_right(1);\n-                    None\n-                }\n-            }\n-            Err(_) => None,\n-        }\n-    }\n-}"}, {"sha": "bec495a72a4a8e92352f4ab3f3faaa1aae94dd08", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a15f484b918a4533ad633ea903ccce82910af342/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=a15f484b918a4533ad633ea903ccce82910af342", "patch": "@@ -1,4 +1,3 @@\n-use super::map::MIN_LEN;\n use super::node::{ForceResult::*, Root};\n use super::search::SearchResult::*;\n use core::borrow::Borrow;\n@@ -70,67 +69,4 @@ impl<K, V> Root<K, V> {\n         }\n         root\n     }\n-\n-    /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n-    fn fix_top(&mut self) {\n-        while self.height() > 0 && self.len() == 0 {\n-            self.pop_internal_level();\n-        }\n-    }\n-\n-    /// Stock up or merge away any underfull nodes on the right border of the\n-    /// tree. The other nodes, those that are not the root nor a rightmost edge,\n-    /// must already have at least MIN_LEN elements.\n-    fn fix_right_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.borrow_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut last_kv = node.last_kv().consider_for_balancing();\n-\n-                if last_kv.can_merge() {\n-                    cur_node = last_kv.merge_tracking_child();\n-                } else {\n-                    let right_len = last_kv.right_child_len();\n-                    // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n-                    if right_len < MIN_LEN + 1 {\n-                        last_kv.bulk_steal_left(MIN_LEN + 1 - right_len);\n-                    }\n-                    cur_node = last_kv.into_right_child();\n-                }\n-                debug_assert!(cur_node.len() > MIN_LEN);\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n-\n-    /// The symmetric clone of `fix_right_border`.\n-    fn fix_left_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.borrow_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut first_kv = node.first_kv().consider_for_balancing();\n-\n-                if first_kv.can_merge() {\n-                    cur_node = first_kv.merge_tracking_child();\n-                } else {\n-                    let left_len = first_kv.left_child_len();\n-                    // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n-                    if left_len < MIN_LEN + 1 {\n-                        first_kv.bulk_steal_right(MIN_LEN + 1 - left_len);\n-                    }\n-                    cur_node = first_kv.into_left_child();\n-                }\n-                debug_assert!(cur_node.len() > MIN_LEN);\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n }"}]}