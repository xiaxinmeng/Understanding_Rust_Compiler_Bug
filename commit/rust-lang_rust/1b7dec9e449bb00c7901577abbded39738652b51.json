{"sha": "1b7dec9e449bb00c7901577abbded39738652b51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiN2RlYzllNDQ5YmIwMGM3OTAxNTc3YWJiZGVkMzk3Mzg2NTJiNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-19T13:24:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-19T13:24:05Z"}, "message": "Auto merge of #71326 - Dylan-DPC:rollup-hdlkdj5, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #71107 (Address concerns of weak-into-raw)\n - #71188 (Fixed missing trait method suggests incorrect code (self parameter not named \"self\"). )\n - #71300 (Clarify when to use the tracking issue template)\n - #71315 (Add example in the alternative in std::mem::transmute docs)\n - #71319 (Clean up E0522 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f908f092b07ee3843882e6a3687ed6636cfbccd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f908f092b07ee3843882e6a3687ed6636cfbccd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b7dec9e449bb00c7901577abbded39738652b51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b7dec9e449bb00c7901577abbded39738652b51", "html_url": "https://github.com/rust-lang/rust/commit/1b7dec9e449bb00c7901577abbded39738652b51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b7dec9e449bb00c7901577abbded39738652b51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36b1a9296cde2b773771710e9bbd608fd2eca35f", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b1a9296cde2b773771710e9bbd608fd2eca35f", "html_url": "https://github.com/rust-lang/rust/commit/36b1a9296cde2b773771710e9bbd608fd2eca35f"}, {"sha": "1d2532bdf623772c0596166c31df98374d7c6af6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2532bdf623772c0596166c31df98374d7c6af6", "html_url": "https://github.com/rust-lang/rust/commit/1d2532bdf623772c0596166c31df98374d7c6af6"}], "stats": {"total": 207, "additions": 138, "deletions": 69}, "files": [{"sha": "51bf0c3ee673652e64d8770d189b2454f38277d3", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -1,6 +1,6 @@\n ---\n name: Tracking Issue\n-about: A tracking issue for a feature in Rust.\n+about: A tracking issue for an accepted feature or RFC in Rust.\n title: Tracking Issue for XXX\n labels: C-tracking-issue\n ---"}, {"sha": "e106b4354e4e942e731192ec822834a12bb299f7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -569,9 +569,33 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n+        let ptr = Self::as_ptr(&this);\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Provides a raw pointer to the data.\n+    ///\n+    /// The counts are not affected in any way and the `Rc` is not consumed. The pointer is valid\n+    /// for as long there are strong counts in the `Rc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(\"hello\".to_owned());\n+    /// let y = Rc::clone(&x);\n+    /// let x_ptr = Rc::as_ptr(&x);\n+    /// assert_eq!(x_ptr, Rc::as_ptr(&y));\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n-        mem::forget(this);\n \n         // SAFETY: This cannot go through Deref::deref.\n         // Instead, we manually offset the pointer rather than manifesting a reference.\n@@ -1644,8 +1668,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1658,31 +1682,22 @@ impl<T> Weak<T> {\n     /// let strong = Rc::new(\"hello\".to_owned());\n     /// let weak = Rc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const RcBox<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1691,7 +1706,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1712,10 +1727,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1730,9 +1745,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw`], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`]  and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1765,7 +1779,6 @@ impl<T> Weak<T> {\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`Rc`]: struct.Rc.html\n     /// [`Weak`]: struct.Weak.html\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]"}, {"sha": "54df2b60857803541ab7dbb15e13904bcf1a1b76", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -566,9 +566,33 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n+        let ptr = Self::as_ptr(&this);\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Provides a raw pointer to the data.\n+    ///\n+    /// The counts are not affected in way and the `Arc` is not consumed. The pointer is valid for\n+    /// as long as there are strong counts in the `Arc`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(\"hello\".to_owned());\n+    /// let y = Arc::clone(&x);\n+    /// let x_ptr = Arc::as_ptr(&x);\n+    /// assert_eq!(x_ptr, Arc::as_ptr(&y));\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n+    /// ```\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n-        mem::forget(this);\n \n         // SAFETY: This cannot go through Deref::deref.\n         // Instead, we manually offset the pointer rather than manifesting a reference.\n@@ -1340,8 +1364,8 @@ impl<T> Weak<T> {\n \n     /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n     ///\n-    /// The pointer is valid only if there are some strong references. The pointer may be dangling\n-    /// or even [`null`] otherwise.\n+    /// The pointer is valid only if there are some strong references. The pointer may be dangling,\n+    /// unaligned or even [`null`] otherwise.\n     ///\n     /// # Examples\n     ///\n@@ -1354,31 +1378,22 @@ impl<T> Weak<T> {\n     /// let strong = Arc::new(\"hello\".to_owned());\n     /// let weak = Arc::downgrade(&strong);\n     /// // Both point to the same object\n-    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// assert!(ptr::eq(&*strong, weak.as_ptr()));\n     /// // The strong here keeps it alive, so we can still access the object.\n-    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     ///\n     /// drop(strong);\n-    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // But not any more. We can do weak.as_ptr(), but accessing the pointer would lead to\n     /// // undefined behaviour.\n-    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_ptr() });\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n-    pub fn as_raw(&self) -> *const T {\n-        match self.inner() {\n-            None => ptr::null(),\n-            Some(inner) => {\n-                let offset = data_offset_sized::<T>();\n-                let ptr = inner as *const ArcInner<T>;\n-                // Note: while the pointer we create may already point to dropped value, the\n-                // allocation still lives (it must hold the weak point as long as we are alive).\n-                // Therefore, the offset is OK to do, it won't get out of the allocation.\n-                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n-                ptr as *const T\n-            }\n-        }\n+    pub fn as_ptr(&self) -> *const T {\n+        let offset = data_offset_sized::<T>();\n+        let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n+        ptr as *const T\n     }\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n@@ -1387,7 +1402,7 @@ impl<T> Weak<T> {\n     /// can be turned back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n-    /// [`as_raw`] apply.\n+    /// [`as_ptr`] apply.\n     ///\n     /// # Examples\n     ///\n@@ -1408,10 +1423,10 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n     #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n     pub fn into_raw(self) -> *const T {\n-        let result = self.as_raw();\n+        let result = self.as_ptr();\n         mem::forget(self);\n         result\n     }\n@@ -1427,9 +1442,8 @@ impl<T> Weak<T> {\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`] (or [`as_raw'], provided there was\n-    /// a corresponding [`forget`] on the `Weak<T>`) and must still own its potential weak reference\n-    /// count.\n+    /// The pointer must have originated from the [`into_raw`] and must still own its potential\n+    /// weak reference count.\n     ///\n     /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n     /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n@@ -1458,7 +1472,6 @@ impl<T> Weak<T> {\n     /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n     /// ```\n     ///\n-    /// [`as_raw`]: struct.Weak.html#method.as_raw\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`into_raw`]: struct.Weak.html#method.into_raw\n     /// [`upgrade`]: struct.Weak.html#method.upgrade"}, {"sha": "75c7313089112ca55eed25d8eb3e2f68a85d1c9e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -1100,6 +1100,24 @@ extern \"rust-intrinsic\" {\n     /// Below are common applications of `transmute` which can be replaced with safer\n     /// constructs.\n     ///\n+    /// Turning raw bytes(`&[u8]`) to `u32`, `f64`, etc.:\n+    ///\n+    /// ```\n+    /// let raw_bytes = [0x78, 0x56, 0x34, 0x12];\n+    ///\n+    /// let num = unsafe {\n+    ///     std::mem::transmute::<[u8; 4], u32>(raw_bytes);\n+    /// };\n+    ///\n+    /// // use `u32::from_ne_bytes` instead\n+    /// let num = u32::from_ne_bytes(raw_bytes);\n+    /// // or use `u32::from_le_bytes` or `u32::from_ge_bytes` to specify the endianness\n+    /// let num = u32::from_le_bytes(raw_bytes);\n+    /// assert_eq!(num, 0x12345678);\n+    /// let num = u32::from_be_bytes(raw_bytes);\n+    /// assert_eq!(num, 0x78563412);\n+    /// ```\n+    ///\n     /// Turning a pointer into a `usize`:\n     ///\n     /// ```"}, {"sha": "83272314a87086d7c35bb9823a76d908f9e7487f", "filename": "src/librustc_error_codes/error_codes/E0522.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -1,7 +1,5 @@\n-The lang attribute is intended for marking special items that are built-in to\n-Rust itself. This includes special traits (like `Copy` and `Sized`) that affect\n-how the compiler behaves, as well as special functions that may be automatically\n-invoked (such as the handler for out-of-bounds accesses when indexing a slice).\n+The lang attribute was used in an invalid context.\n+\n Erroneous code example:\n \n ```compile_fail,E0522\n@@ -12,3 +10,8 @@ fn cookie() -> ! { // error: definition of an unknown language item: `cookie`\n     loop {}\n }\n ```\n+\n+The lang attribute is intended for marking special items that are built-in to\n+Rust itself. This includes special traits (like `Copy` and `Sized`) that affect\n+how the compiler behaves, as well as special functions that may be automatically\n+invoked (such as the handler for out-of-bounds accesses when indexing a slice)."}, {"sha": "9bb81c322ab1b9ed9a127a389fdd2df169b9e773", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -2251,26 +2251,39 @@ fn fn_sig_suggestion(\n     sig: &ty::FnSig<'_>,\n     ident: Ident,\n     predicates: ty::GenericPredicates<'_>,\n+    assoc: &ty::AssocItem,\n ) -> String {\n     let args = sig\n         .inputs()\n         .iter()\n-        .map(|ty| {\n+        .enumerate()\n+        .map(|(i, ty)| {\n             Some(match ty.kind {\n-                ty::Param(param) if param.name == kw::SelfUpper => \"self\".to_string(),\n-                ty::Ref(reg, ref_ty, mutability) => {\n+                ty::Param(_) if assoc.fn_has_self_parameter && i == 0 => \"self\".to_string(),\n+                ty::Ref(reg, ref_ty, mutability) if i == 0 => {\n                     let reg = match &format!(\"{}\", reg)[..] {\n                         \"'_\" | \"\" => String::new(),\n                         reg => format!(\"{} \", reg),\n                     };\n-                    match ref_ty.kind {\n-                        ty::Param(param) if param.name == kw::SelfUpper => {\n-                            format!(\"&{}{}self\", reg, mutability.prefix_str())\n+                    if assoc.fn_has_self_parameter {\n+                        match ref_ty.kind {\n+                            ty::Param(param) if param.name == kw::SelfUpper => {\n+                                format!(\"&{}{}self\", reg, mutability.prefix_str())\n+                            }\n+\n+                            _ => format!(\"self: {}\", ty),\n                         }\n-                        _ => format!(\"_: {:?}\", ty),\n+                    } else {\n+                        format!(\"_: {:?}\", ty)\n+                    }\n+                }\n+                _ => {\n+                    if assoc.fn_has_self_parameter && i == 0 {\n+                        format!(\"self: {:?}\", ty)\n+                    } else {\n+                        format!(\"_: {:?}\", ty)\n                     }\n                 }\n-                _ => format!(\"_: {:?}\", ty),\n             })\n         })\n         .chain(std::iter::once(if sig.c_variadic { Some(\"...\".to_string()) } else { None }))\n@@ -2309,6 +2322,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n                 tcx.fn_sig(assoc.def_id).skip_binder(),\n                 assoc.ident,\n                 tcx.predicates_of(assoc.def_id),\n+                assoc,\n             )\n         }\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.ident),"}, {"sha": "fcf52c9e88743093482a5c5365b1cb158638557e", "filename": "src/test/ui/missing/missing-items/auxiliary/m1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fauxiliary%2Fm1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fauxiliary%2Fm1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fauxiliary%2Fm1.rs?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -2,4 +2,8 @@ pub trait X {\n     const CONSTANT: u32;\n     type Type;\n     fn method(&self, s: String) -> Self::Type;\n+    fn method2(self: Box<Self>, s: String) -> Self::Type;\n+    fn method3(other: &Self, s: String) -> Self::Type;\n+    fn method4(&self, other: &Self) -> Self::Type;\n+    fn method5(self: &Box<Self>) -> Self::Type;\n }"}, {"sha": "64e9530e61348276b9a7bc51ccb76b9d0697bdd4", "filename": "src/test/ui/missing/missing-items/m2.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b7dec9e449bb00c7901577abbded39738652b51/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b7dec9e449bb00c7901577abbded39738652b51/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fm2.stderr?ref=1b7dec9e449bb00c7901577abbded39738652b51", "patch": "@@ -1,12 +1,16 @@\n-error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `method`\n+error[E0046]: not all trait items implemented, missing: `CONSTANT`, `Type`, `method`, `method2`, `method3`, `method4`, `method5`\n   --> $DIR/m2.rs:9:1\n    |\n LL | impl m1::X for X {\n-   | ^^^^^^^^^^^^^^^^ missing `CONSTANT`, `Type`, `method` in implementation\n+   | ^^^^^^^^^^^^^^^^ missing `CONSTANT`, `Type`, `method`, `method2`, `method3`, `method4`, `method5` in implementation\n    |\n    = help: implement the missing item: `const CONSTANT: u32 = 42;`\n    = help: implement the missing item: `type Type = Type;`\n    = help: implement the missing item: `fn method(&self, _: std::string::String) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method2(self: std::boxed::Box<Self>, _: std::string::String) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method3(_: &Self, _: std::string::String) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method4(&self, _: &Self) -> <Self as m1::X>::Type { todo!() }`\n+   = help: implement the missing item: `fn method5(self: &std::boxed::Box<Self>) -> <Self as m1::X>::Type { todo!() }`\n \n error: aborting due to previous error\n "}]}