{"sha": "d1857d30fc05f29fb82231336b229e50948a8336", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxODU3ZDMwZmMwNWYyOWZiODIyMzEzMzZiMjI5ZTUwOTQ4YTgzMzY=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-01T00:44:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-14T01:14:13Z"}, "message": "This is the mega-ucontext commit. It replaces the task switching mechanism with a new one inspired by ucontext. It works under Linux, OS X and Windows, and is Valgrind clean on Linux and OS X (provided the runtime is built with gcc).\n\nThis commit also moves yield and join to the standard library, as requested in #42. Join is currently a no-op though.", "tree": {"sha": "8a1ad8ad6dcda631e4858902008e3d7b8227b271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a1ad8ad6dcda631e4858902008e3d7b8227b271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1857d30fc05f29fb82231336b229e50948a8336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1857d30fc05f29fb82231336b229e50948a8336", "html_url": "https://github.com/rust-lang/rust/commit/d1857d30fc05f29fb82231336b229e50948a8336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1857d30fc05f29fb82231336b229e50948a8336/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1595c9d767de72340358028e87d3eb386af0adfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1595c9d767de72340358028e87d3eb386af0adfe", "html_url": "https://github.com/rust-lang/rust/commit/1595c9d767de72340358028e87d3eb386af0adfe"}], "stats": {"total": 860, "additions": 418, "deletions": 442}, "files": [{"sha": "e4d79318269f5ba57be7eaff740a3af22ace404d", "filename": "configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/configure", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -176,11 +176,11 @@ fi\n step_msg \"making directories\"\n for i in \\\n     doc \\\n-    rt rt/isaac rt/bigint rt/sync rt/test \\\n+    rt rt/isaac rt/bigint rt/sync rt/test rt/arch/i386 \\\n     rustllvm \\\n     dl stage0 stage1 stage2 stage3 \\\n     test/run-pass test/run-fail test/compile-fail \\\n-    test/bench/99-bottles test/bench/shootout\n+    test/bench/99-bottles test/bench/shootout     \n do\n     make_dir $i\n done"}, {"sha": "cd18e0597d8d005a3be0a1a4269e5e594a04b9c3", "filename": "mk/rt.mk", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -27,11 +27,12 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/memory_region.cpp \\\n               rt/test/rust_test_harness.cpp \\\n               rt/test/rust_test_runtime.cpp \\\n-              rt/test/rust_test_util.cpp\n+              rt/test/rust_test_util.cpp \\\n+              rt/arch/i386/context.cpp \\\n \n-RUNTIME_LL := rt/new_exit.ll rt/vec_append.ll\n+RUNTIME_LL := rt/vec_append.ll\n \n-RUNTIME_S := rt/activate_glue.s rt/yield_glue.s\n+RUNTIME_S := rt/arch/i386/_context.s\n \n RUNTIME_HDR := rt/globals.h \\\n                rt/rust.h \\\n@@ -60,10 +61,12 @@ RUNTIME_HDR := rt/globals.h \\\n                rt/memory.h \\\n                rt/test/rust_test_harness.h \\\n                rt/test/rust_test_runtime.h \\\n-               rt/test/rust_test_util.h\n+               rt/test/rust_test_util.h \\\n+               rt/arch/i386/context.h \\\n \n RUNTIME_DEF := rt/rustrt$(CFG_DEF_SUFFIX)\n-RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash\n+RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash \\\n+                -I $(S)src/rt/arch/i386\n RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o) $(RUNTIME_LL:.ll=.o) $(RUNTIME_S:.s=.o)\n RUNTIME_LIBS := $(CFG_GCCISH_POST_LIB_FLAGS)\n "}, {"sha": "42a4dddd5645671957a25cef4e6e5b204c39acb8", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -93,10 +93,6 @@ fn vec_append_glue_name() -> str {\n     ret \"rust_vec_append_glue\";\n }\n \n-fn yield_glue_name() -> str {\n-    ret \"rust_yield_glue\";\n-}\n-\n fn no_op_type_glue_name() -> str {\n     ret \"rust_no_op_type_glue\";\n }"}, {"sha": "12bd64af23ed708a763f93ee62b6955c91a43037", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -114,7 +114,7 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n                         T_ptr(T_tydesc(tn))),\n         new_task=d(\"new_task\", [T_ptr(T_str())], T_taskptr(tn)),\n         start_task=d(\"start_task\", [T_taskptr(tn), \n-                                    T_int(), T_int()],\n+                                    T_int(), T_int(), T_size_t()],\n                      T_taskptr(tn)),\n         new_thread=d(\"new_thread\", [T_ptr(T_i8())], T_taskptr(tn)),\n         start_thread=d(\"start_thread\", [T_taskptr(tn), T_int(), T_int(),"}, {"sha": "02bcc0f8191d89f9d22c675ed779f255714c798d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -85,8 +85,7 @@ state obj namegen(mutable int i) {\n \n type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n \n-type glue_fns = rec(ValueRef yield_glue,\n-                    ValueRef no_op_type_glue,\n+type glue_fns = rec(ValueRef no_op_type_glue,\n                     ValueRef vec_append_glue);\n \n type tydesc_info = rec(ty::t ty,\n@@ -6454,13 +6453,12 @@ fn trans_spawn(&@block_ctxt cx,\n     auto wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n     bcx = wrapper.bcx;\n     auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n-    // TODO: this next line might be necessary...\n-    //llfnptr_i = bcx.build.Load(llfnptr_i);\n \n     // And start the task\n+    auto args_size = size_of(bcx, args_ty).val;\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n                    [bcx.fcx.lltaskptr, new_task,\n-                    llfnptr_i, llargs_i]);\n+                    llfnptr_i, llargs_i, args_size]);\n \n     auto task_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto dropref = clean(bind drop_ty(_, new_task, task_ty));\n@@ -8545,8 +8543,7 @@ fn vec_p0(&@block_ctxt bcx, ValueRef v) -> ValueRef {\n }\n \n fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n-    ret @rec(yield_glue = decl_glue(llmod, tn, abi::yield_glue_name()),\n-             no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n+    ret @rec(no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n "}, {"sha": "60cecd7cf6889e3ec5ce41d6f6f960ee47338382", "filename": "src/lib/std.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -18,7 +18,7 @@ mod str;\n \n mod io;\n mod sys;\n-mod _task;\n+mod task;\n \n // Utility modules.\n \n@@ -33,7 +33,7 @@ auth os_fs = unsafe;\n auth run = unsafe;\n auth str = unsafe;\n auth vec = unsafe;\n-auth _task = unsafe;\n+auth task = unsafe;\n \n auth dbg = unsafe;\n "}, {"sha": "0173143cda2a150d0eb24bb9b72d32c3d8355e3d", "filename": "src/lib/task.rs", "status": "renamed", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,5 +1,6 @@\n native \"rust\" mod rustrt {\n     fn task_sleep(uint time_in_us);\n+    fn task_yield();\n }\n \n /**\n@@ -11,6 +12,15 @@ fn sleep(uint time_in_us) {\n     ret rustrt::task_sleep(time_in_us);\n }\n \n+fn yield() {\n+    ret rustrt::task_yield();\n+}\n+\n+fn join(task t) {\n+    // TODO: figure out how to pass tasks to the runtime and call the builtin\n+    // join.\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;", "previous_filename": "src/lib/_task.rs"}, {"sha": "5b55f56888032872c4c5c7d5f5b32751f6b613f4", "filename": "src/rt/activate_glue.s", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1595c9d767de72340358028e87d3eb386af0adfe/src%2Frt%2Factivate_glue.s", "raw_url": "https://github.com/rust-lang/rust/raw/1595c9d767de72340358028e87d3eb386af0adfe/src%2Frt%2Factivate_glue.s", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Factivate_glue.s?ref=1595c9d767de72340358028e87d3eb386af0adfe", "patch": "@@ -1,89 +0,0 @@\n-/*\n- * This is a bit of glue-code.\n- *\n- *   - save regs on C stack\n- *   - save sp to task.runtime_sp (runtime_sp is thus always aligned)\n- *   - load saved task sp (switch stack)\n- *   - restore saved task regs\n- *   - return to saved task pc\n- *\n- * Our incoming stack looks like this:\n- *\n- *   *esp+4        = [arg1   ] = task ptr\n- *   *esp          = [retpc  ]\n- */\n-\n-\t.globl new_rust_activate_glue\n-\t.balign 4\n-new_rust_activate_glue:\n-\tmovl  4(%esp), %ecx    # ecx = rust_task\n-\tpushl %ebp\n-\tpushl %edi\n-\tpushl %esi\n-\tpushl %ebx\n-\tmovl  %esp, 12(%ecx)\n-\tmovl  16(%ecx), %esp\n-\n-        /*\n-         * There are two paths we can arrive at this code from:\n-         *\n-         *\n-         *   1. We are activating a task for the first time. When we switch\n-         *      into the task stack and 'ret' to its first instruction, we'll\n-         *      start doing whatever the first instruction says. Probably\n-         *      saving registers and starting to establish a frame. Harmless\n-         *      stuff, doesn't look at task->rust_sp again except when it\n-         *      clobbers it during a later native call.\n-         *\n-         *\n-         *   2. We are resuming a task that was descheduled by the yield glue\n-         *      below.  When we switch into the task stack and 'ret', we'll be\n-         *      ret'ing to a very particular instruction:\n-         *\n-         *              \"esp <- task->rust_sp\"\n-         *\n-         *      this is the first instruction we 'ret' to after this glue,\n-         *      because it is the first instruction following *any* native\n-         *      call, and the task we are activating was descheduled\n-         *      mid-native-call.\n-         *\n-         *      Unfortunately for us, we have already restored esp from\n-         *      task->rust_sp and are about to eat the 5 words off the top of\n-         *      it.\n-         *\n-         *\n-         *      | ...    | <-- where esp will be once we restore + ret, below,\n-         *      | retpc  |     and where we'd *like* task->rust_sp to wind up.\n-         *      | ebp    |\n-         *      | edi    |\n-         *      | esi    |\n-         *      | ebx    | <-- current task->rust_sp == current esp\n-         *\n-         *\n-         *      This is a problem. If we return to \"esp <- task->rust_sp\" it\n-         *      will push esp back down by 5 words. This manifests as a rust\n-         *      stack that grows by 5 words on each yield/reactivate. Not\n-         *      good.\n-         *\n-         *      So what we do here is just adjust task->rust_sp up 5 words as\n-         *      well, to mirror the movement in esp we're about to\n-         *      perform. That way the \"esp <- task->rust_sp\" we 'ret' to below\n-         *      will be a no-op. Esp won't move, and the task's stack won't\n-         *      grow.\n-         */\n-\taddl  $20, 16(%ecx)\n-\n-        /*\n-         * In most cases, the function we're returning to (activating)\n-         * will have saved any caller-saves before it yielded via native call,\n-         * so no work to do here. With one exception: when we're initially\n-         * activating, the task needs to be in the fastcall 2nd parameter\n-         * expected by the rust main function. That's edx.\n-         */\n-        mov  %ecx, %edx\n-\n-\tpopl  %ebx\n-\tpopl  %esi\n-\tpopl  %edi\n-\tpopl  %ebp\n-\tret"}, {"sha": "8b49d35de1be2d49e01e00a39671a7ca9847aa5b", "filename": "src/rt/arch/i386/_context.s", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Farch%2Fi386%2F_context.s", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Farch%2Fi386%2F_context.s", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.s?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -0,0 +1,86 @@\n+\t.text\n+\n+/*\n+Callee save registers:\n+\tebp, ebx, esi, edi\n+\n+Caller save registers:\n+\teax, ecx, edx\n+*/\n+\t\n+/*\n+Saves a set of registers. This is used by our implementation of\n+getcontext.\n+\n+The registers_t variable is in (%esp)\n+*/\n+\t\n+.globl get_registers\n+get_registers:\n+\tmovl 4(%esp), %eax\n+\tmovl %eax, 0(%eax)\n+\tmovl %ebx, 4(%eax)\n+\tmovl %ecx, 8(%eax)\n+\tmovl %edx, 12(%eax)\n+\tmovl %ebp, 16(%eax)\n+\tmovl %esi, 20(%eax)\n+\tmovl %edi, 24(%eax)\n+\tmovl %esp, 28(%eax)\n+\tmovw %cs, 32(%eax)\n+\tmovw %ds, 34(%eax)\n+\tmovw %ss, 36(%eax)\n+\tmovw %es, 38(%eax)\n+\tmovw %fs, 40(%eax)\n+\tmovw %gs, 42(%eax)\n+\n+\t// save the flags\n+\tpushf\n+\tpopl %ecx\n+\tmovl %ecx, 44(%eax)\n+\n+\t// save the return address as the instruction pointer\n+\tmovl 0(%esp), %ecx\n+\tmovl %ecx, 48(%eax)\n+\n+\t// return 0\n+\txor %eax, %eax\n+\tret\n+\n+.globl set_registers\n+set_registers:\n+\tmovl 4(%esp), %eax\n+\n+\tmovl 4(%eax), %ebx\n+\t// save ecx for later...\n+\tmovl 12(%eax), %edx\n+\tmovl 16(%eax), %ebp\n+\tmovl 20(%eax), %esi\n+\tmovl 24(%eax), %edi\n+\tmovl 28(%eax), %esp\n+\t// We can't actually change this...\n+\t//movl 32(%eax), %cs\n+\tmovw 34(%eax), %ds\n+\tmovw 36(%eax), %ss\n+\tmovw 38(%eax), %es\n+\tmovw 40(%eax), %fs\n+\tmovw 42(%eax), %gs\n+\n+\t// restore the flags\n+\tmovl 44(%eax), %ecx\n+\tpush %ecx\n+\tpopf\n+\n+\t// get ready to return back to the old eip\n+\t// We could write this directly to 0(%esp), but Valgrind on OS X\n+\t// complains.\n+\tpop %ecx\n+\tmov 48(%eax), %ecx\n+\tpush %ecx\t\n+\t//movl %ecx, 0(%esp)\n+\t\n+\t// okay, now we can restore ecx.\n+\tmovl 8(%eax), %ecx\n+\n+\t// return 1 to the saved eip\n+\tmovl $1, %eax\n+\tret"}, {"sha": "8f5dbacbcf42877c49ab9fe715702de8a642ca95", "filename": "src/rt/arch/i386/context.cpp", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Farch%2Fi386%2Fcontext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -0,0 +1,81 @@\n+#include \"context.h\"\n+\n+#include \"../../rust.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+extern \"C\" uint32_t CDECL get_registers(registers_t *regs) \n+  asm (\"get_registers\");\n+extern \"C\" uint32_t CDECL set_registers(registers_t *regs)\n+  asm (\"set_registers\");\n+\n+context::context()\n+  : next(NULL)\n+{\n+  get_registers(&regs);\n+}\n+\n+void context::set()\n+{\n+  //printf(\"Activating %p...\\n\", this);\n+  set_registers(&regs);\n+}\n+\n+void context::swap(context &out)\n+{\n+  //printf(\"Swapping to %p and saving in %p\\n\", this, &out);\n+  uint32_t r = get_registers(&out.regs);\n+  //printf(\"get_registers = %d, sp = 0x%x\\n\", r, out.regs.esp);\n+  if(!r) {\n+    set();\n+  }\n+  //printf(\"Resumed %p...\\n\", &out);\n+}\n+\n+void context::call(void *f, void *arg, void *stack) {\n+  // set up the trampoline frame\n+  uint32_t *sp = (uint32_t *)stack;\n+  *--sp = (uint32_t)this;\n+  *--sp = (uint32_t)arg;\n+  *--sp = 0xdeadbeef; //(uint32_t)ctx_trampoline1;\n+  *--sp = 0xdeadbeef;\n+\n+  regs.esp = (uint32_t)sp;\n+  regs.eip = (uint32_t)f;\n+}\n+\n+#if 0\n+// This is some useful code to check how the registers struct got\n+// layed out in memory.\n+int main() {\n+  registers_t regs;\n+\n+  printf(\"Register offsets\\n\");\n+\n+#define REG(r) \\\n+  printf(\"  %6s: +%ld\\n\", #r, (intptr_t)&regs.r - (intptr_t)&regs);\n+\n+  REG(eax);\n+  REG(ebx);\n+  REG(ecx);\n+  REG(edx);\n+  REG(ebp);\n+  REG(esi);\n+  REG(edi);\n+  REG(esp);\n+\n+  REG(cs);\n+  REG(ds);\n+  REG(ss);\n+  REG(es);\n+  REG(fs);\n+  REG(gs);\n+\n+  REG(eflags);\n+\n+  REG(eip);\n+\n+  return 0;\n+}\n+#endif"}, {"sha": "0ddbee6988fcb6485665c11e4b99509c542932e4", "filename": "src/rt/arch/i386/context.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Farch%2Fi386%2Fcontext.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Farch%2Fi386%2Fcontext.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2Fcontext.h?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -0,0 +1,35 @@\n+// -*- mode: c++ -*-\n+\n+#ifndef CONTEXT_H\n+#define CONTEXT_H\n+\n+#include <inttypes.h>\n+\n+struct registers_t {\n+  // general purpose registers\n+  uint32_t eax, ebx, ecx, edx, ebp, esi, edi, esp;\n+\n+  // segment registers\n+  uint16_t cs, ds, ss, es, fs, gs;\n+\n+  uint32_t eflags;\n+\n+  uint32_t eip;\n+};\n+\n+class context {\n+  registers_t regs;\n+\n+public:\n+  context();\n+  \n+  context *next;\n+\n+  void set();\n+  \n+  void swap(context &out);\n+\n+  void call(void *f, void *arg, void *sp);\n+};\n+\n+#endif"}, {"sha": "aa696dd9092a34356f78bd6663dbd8fafe807c0a", "filename": "src/rt/globals.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Fglobals.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Fglobals.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fglobals.h?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,9 +1,12 @@\n #ifndef GLOBALS_H\n #define GLOBALS_H\n \n+#ifndef RUST_INTERNAL_H\n+// these are defined in two files and GCC complains\n #define __STDC_LIMIT_MACROS 1\n #define __STDC_CONSTANT_MACROS 1\n #define __STDC_FORMAT_MACROS 1\n+#endif\n \n #include <stdlib.h>\n #include <stdint.h>\n@@ -32,4 +35,16 @@ extern \"C\" {\n #error \"Platform not supported.\"\n #endif\n \n+#define CHECKED(call)                                               \\\n+    {                                                               \\\n+    int res = (call);                                               \\\n+        if(0 != res) {                                              \\\n+            fprintf(stderr,                                         \\\n+                    #call \" failed in %s at line %d, result = %d \"  \\\n+                    \"(%s) \\n\",                                      \\\n+                    __FILE__, __LINE__, res, strerror(res));        \\\n+            abort();                                                \\\n+        }                                                           \\\n+    }                                                               \n+\n #endif /* GLOBALS_H */"}, {"sha": "07f52e7759dddce4536f2afa3a1a826cfdb06ad7", "filename": "src/rt/new_exit.ll", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1595c9d767de72340358028e87d3eb386af0adfe/src%2Frt%2Fnew_exit.ll", "raw_url": "https://github.com/rust-lang/rust/raw/1595c9d767de72340358028e87d3eb386af0adfe/src%2Frt%2Fnew_exit.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fnew_exit.ll?ref=1595c9d767de72340358028e87d3eb386af0adfe", "patch": "@@ -1,43 +0,0 @@\n-declare fastcc i32 @\"\\01rust_native_rust_local_copy\"(i32, i32)\n-\n-module asm \"\\09.globl rust_native_rust_local_copy\"\n-module asm \"\\09.balign 4\"\n-module asm \"rust_native_rust_local_copy:\"\n-module asm \"\\09.cfi_startproc\"\n-module asm \"\\09pushl %ebp\"\n-module asm \"\\09.cfi_def_cfa_offset 8\"\n-module asm \"\\09.cfi_offset %ebp, -8\"\n-module asm \"\\09pushl %edi\"\n-module asm \"\\09.cfi_def_cfa_offset 12\"\n-module asm \"\\09pushl %esi\"\n-module asm \"\\09.cfi_def_cfa_offset 16\"\n-module asm \"\\09pushl %ebx\"\n-module asm \"\\09.cfi_def_cfa_offset 20\"\n-module asm \"\\09movl  %esp, %ebp     # ebp = rust_sp\"\n-module asm \"\\09.cfi_def_cfa_register %ebp\"\n-module asm \"\\09movl  %esp, 16(%edx)\"\n-module asm \"\\09movl  12(%edx), %esp\"\n-module asm \"\\09subl  $4, %esp   # esp -= args\"\n-module asm \"\\09andl  $~0xf, %esp    # align esp down\"\n-module asm \"\\09movl  %edx, (%esp)\"\n-module asm \"\\09movl  %edx, %edi     # save task from edx to edi\"\n-module asm \"\\09call  *%ecx          # call *%ecx\"\n-module asm \"\\09movl  %edi, %edx     # restore edi-saved task to edx\"\n-module asm \"\\09movl  16(%edx), %esp\"\n-module asm \"\\09popl  %ebx\"\n-module asm \"\\09popl  %esi\"\n-module asm \"\\09popl  %edi\"\n-module asm \"\\09popl  %ebp\"\n-module asm \"\\09ret\"\n-module asm \"\\09.cfi_endproc\"\n-\n-\n-declare i32 @upcall_exit(i32)\n-\n-define void @rust_new_exit_task_glue(i32, i32, i32, i32, i32) {\n-entry:\n-  %5 = inttoptr i32 %0 to void (i32, i32, i32, i32)*\n-  tail call fastcc void %5(i32 %1, i32 %2, i32 %3, i32 %4)\n-  %6 = tail call fastcc i32 @\"\\01rust_native_rust_local_copy\"(i32 ptrtoint (i32 (i32)* @upcall_exit to i32), i32 %2)\n-  ret void\n-}"}, {"sha": "ae150acab171261bbdb9d52232a52c7caf213a28", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -93,9 +93,13 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n         DLOG(dom, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n+    /*\n     uintptr_t main_args[4] = {0, 0, 0, (uintptr_t)args->args};\n     dom->root_task->start(main_fn,\n                           (uintptr_t)&main_args, sizeof(main_args));\n+    */\n+    dom->root_task->start(main_fn,\n+                          (uintptr_t)args->args, sizeof(args->args));\n \n     int ret = dom->start_main_loop();\n     delete args;"}, {"sha": "1ca5dddd5e695a23c3f39325c2b29eabdb3a4679", "filename": "src/rt/rust.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.h?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -10,11 +10,14 @@\n // 'cdecl' ABI only means anything on i386\n #ifdef __WIN32__\n #define CDECL __cdecl\n+#define FASTCALL __fastcall\n #else\n #define CDECL __attribute__((cdecl))\n+#define FASTCALL __attribute__((fastcall))\n #endif\n #else\n #define CDECL\n+#define FASTCALL\n #endif\n \n /*"}, {"sha": "65c9d7e76a194c9762ec50330ea415a9f6ae4475", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -354,6 +354,16 @@ task_sleep(rust_task *task, size_t time_in_us) {\n     upcall_sleep(task, time_in_us);\n }\n \n+extern \"C\" CDECL void\n+task_yield(rust_task *task) {\n+    task->yield(1);\n+}\n+\n+extern \"C\" CDECL void\n+task_join(rust_task *task, rust_task *join_task) {\n+    // TODO\n+}\n+\n /* Debug builtins for std.dbg. */\n \n static void"}, {"sha": "1a5e14635099fd2c3c006c18f6c4747b8e9d4ba4", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,6 +1,7 @@\n \n #include <stdarg.h>\n #include \"rust_internal.h\"\n+#include \"globals.h\"\n \n rust_dom::rust_dom(rust_kernel *kernel,\n     rust_message_queue *message_queue, rust_srv *srv,\n@@ -44,13 +45,17 @@ rust_dom::~rust_dom() {\n #endif\n }\n \n-extern \"C\" void new_rust_activate_glue(rust_task *)\n-    asm(\"new_rust_activate_glue\");\n-\n void\n rust_dom::activate(rust_task *task) {\n     curr_task = task;\n-    new_rust_activate_glue(task);\n+\n+    context ctx;\n+\n+    task->ctx.next = &ctx;\n+    DLOG(this, task, \"descheduling...\");\n+    task->ctx.swap(ctx);\n+    DLOG(this, task, \"task has returned\");\n+\n     curr_task = NULL;\n }\n \n@@ -308,10 +313,14 @@ rust_dom::start_main_loop() {\n                  scheduled_task->state->name,\n                  scheduled_task->rust_sp);\n \n+        /*\n+          // These invariants are no longer valid, as rust_sp is not\n+          // updated.\n         I(this, scheduled_task->rust_sp >=\n           (uintptr_t) &scheduled_task->stk->data[0]);\n         I(this, scheduled_task->rust_sp < scheduled_task->stk->limit);\n-\n+        */\n+        \n         reap_dead_tasks();\n     }\n "}, {"sha": "5545d613a32f10d3df5bd250f12f14459d077ea4", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,9 +1,12 @@\n #ifndef RUST_INTERNAL_H\n #define RUST_INTERNAL_H\n \n+#ifndef GLOBALS_H\n+// these are defined in two files, and GCC complains.\n #define __STDC_LIMIT_MACROS 1\n #define __STDC_CONSTANT_MACROS 1\n #define __STDC_FORMAT_MACROS 1\n+#endif\n \n #define ERROR 0\n \n@@ -203,8 +206,6 @@ struct rust_timer {\n \n #include \"rust_util.h\"\n \n-typedef void CDECL (*activate_glue_ty)(rust_task *);\n-\n struct type_desc {\n     // First part of type_desc is known to compiler.\n     // first_param = &descs[1] if dynamic, null if static."}, {"sha": "f72da483c350225dad707adc677b3ce2ffd487ef", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -187,8 +187,11 @@ rust_kernel::~rust_kernel() {\n     KLOG(\"freeing handles\");\n \n     free_handles(_task_handles);\n+    KLOG(\"..task handles freed\");\n     free_handles(_port_handles);\n+    KLOG(\"..port handles freed\");\n     free_handles(_dom_handles);\n+    KLOG(\"..dom handles freed\");\n \n     KLOG(\"freeing queues\");\n \n@@ -214,6 +217,7 @@ rust_kernel::free_handles(hash_map<T*, rust_handle<T>* > &map) {\n     T* key;\n     rust_handle<T> *value;\n     while (map.pop(&key, &value)) {\n+        KLOG(\"...freeing \" PTR, value);\n         delete value;\n     }\n }"}, {"sha": "0c3df20358a5c449a0cb87345470b27c67f57c5b", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,3 +1,4 @@\n+// -*- c++ -*-\n #ifndef RUST_KERNEL_H\n #define RUST_KERNEL_H\n "}, {"sha": "6caaf25db820d7a3d1d32c345371ffa74413f398", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 58, "deletions": 197, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -8,6 +8,8 @@\n #include <execinfo.h>\n #endif\n \n+#include \"globals.h\"\n+\n // Stacks\n \n // FIXME (issue #151): This should be 0x300; the change here is for\n@@ -50,30 +52,6 @@ del_stk(rust_dom *dom, stk_seg *stk)\n size_t const n_callee_saves = 4;\n size_t const callee_save_fp = 0;\n \n-static uintptr_t\n-align_down(uintptr_t sp)\n-{\n-    // There is no platform we care about that needs more than a\n-    // 16-byte alignment.\n-    return sp & ~(16 - 1);\n-}\n-\n-static uintptr_t*\n-align_down(uintptr_t* sp)\n-{\n-    return (uintptr_t*) align_down((uintptr_t)sp);\n-}\n-\n-\n-static void\n-make_aligned_room_for_bytes(uintptr_t*& sp, size_t n)\n-{\n-    uintptr_t tmp = (uintptr_t) sp;\n-    tmp = align_down(tmp - n) + n;\n-    sp = (uintptr_t*) tmp;\n-}\n-\n-\n rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n                      rust_task *spawner, const char *name) :\n     maybe_proxy<rust_task>(this),\n@@ -94,6 +72,7 @@ rust_task::rust_task(rust_dom *dom, rust_task_list *state,\n     handle(NULL)\n {\n     LOGPTR(dom, \"new task\", (uintptr_t)this);\n+    DLOG(dom, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n \n     if (spawner == NULL) {\n         ref_count = 0;\n@@ -135,61 +114,66 @@ rust_task::~rust_task()\n \n extern \"C\" void rust_new_exit_task_glue();\n \n+struct spawn_args {\n+    rust_task *task;\n+    uintptr_t a3;\n+    uintptr_t a4;\n+    void (*FASTCALL f)(int *, rust_task *, \n+                       uintptr_t, uintptr_t);\n+};\n+\n+// TODO: rewrite this in LLVM assembly so we can be sure the calling\n+// conventions will match.\n+extern \"C\" CDECL\n+void task_start_wrapper(spawn_args *a)\n+{\n+    rust_task *task = a->task;\n+    int rval = 42;\n+    \n+    // This is used by the context switching code. LLVM generates fastcall\n+    // functions, but ucontext needs cdecl functions. This massages the\n+    // calling conventions into the right form.\n+    a->f(&rval, task, a->a3, a->a4);\n+\n+    LOG(task, task, \"task exited with value %d\", rval);\n+\n+    // TODO: the old exit glue does some magical argument copying stuff. This\n+    // is probably still needed.\n+\n+    // This is duplicated from upcall_exit, which is probably dead code by\n+    // now.\n+    LOG(task, task, \"task ref_count: %d\", task->ref_count);\n+    A(task->dom, task->ref_count >= 0,\n+      \"Task ref_count should not be negative on exit!\");\n+    task->die();\n+    task->notify_tasks_waiting_to_join();\n+    task->yield(1);\n+}\n+\n void\n rust_task::start(uintptr_t spawnee_fn,\n                  uintptr_t args,\n                  size_t callsz)\n {\n     LOGPTR(dom, \"from spawnee\", spawnee_fn);\n \n-    // Set sp to last uintptr_t-sized cell of segment\n-    rust_sp -= sizeof(uintptr_t);\n-\n-    // Begin synthesizing the exit_task_glue frame. We will return to\n-    // exit_task_glue and it is responsible for calling the user code\n-    // and passing the value returned by the user to the system\n-    // exit routine.\n-    uintptr_t *spp = (uintptr_t *)rust_sp;\n-\n-    uintptr_t dummy_ret = (uintptr_t) spp--;\n-\n-    uintptr_t args_size = callsz - 3*sizeof(uintptr_t);\n-    uintptr_t frame_size = args_size + 4*sizeof(uintptr_t);\n-\n-\n-    // NB: Darwin needs \"16-byte aligned\" stacks *at the point of the call\n-    // instruction in the caller*. This means that the address at which the\n-    // word before retpc is pushed must always be 16-byte aligned.\n-    //\n-    // see: \"Mac OS X ABI Function Call Guide\"\n+    I(dom, stk->data != NULL);\n \n-    make_aligned_room_for_bytes(spp, frame_size - sizeof(uintptr_t));\n+    char *sp = (char *)stk->limit;\n \n-    // Copy args from spawner to spawnee.\n-    uintptr_t *src = (uintptr_t *)args;\n-    src += 1;                  // spawn-call output slot\n-    src += 1;                  // spawn-call task slot\n-    src += 1;                  // spawn-call closure-or-obj slot\n+    sp -= sizeof(spawn_args);\n \n-    *spp-- = (uintptr_t) *src;       // vec\n-    *spp-- = (uintptr_t) 0x0;        // closure-or-obj\n-    *spp-- = (uintptr_t) this;       // task\n-    *spp-- = (uintptr_t) dummy_ret;  // output address\n+    spawn_args *a = (spawn_args *)sp;\n \n-    I(dom, spp == align_down(spp));\n-    *spp-- = (uintptr_t) (uintptr_t) spawnee_fn;\n+    a->task = this;\n+    a->a3 = 0xca11ab1e;\n+    a->a4 = args;\n+    void **f = (void **)&a->f;\n+    *f = (void *)spawnee_fn;\n \n-    *spp-- = (uintptr_t) 0x0;        // retp\n-\n-    *spp-- = (uintptr_t) rust_new_exit_task_glue;\n-\n-    for (size_t j = 0; j < n_callee_saves; ++j) {\n-        *spp-- = (uintptr_t)NULL;\n-    }\n-\n-    // Back up one, we overshot where sp should be.\n-    rust_sp = (uintptr_t) (spp+1);\n+    ctx.call((void *)task_start_wrapper, a, sp);\n \n+    yield_timer.reset(0);\n     transition(&dom->newborn_tasks, &dom->running_tasks);\n }\n \n@@ -201,133 +185,24 @@ rust_task::grow(size_t n_frame_bytes)\n     // the presence of non-word-aligned pointers.\n     abort();\n \n-#if 0\n-    stk_seg *old_stk = this->stk;\n-    uintptr_t old_top = (uintptr_t) old_stk->limit;\n-    uintptr_t old_bottom = (uintptr_t) &old_stk->data[0];\n-    uintptr_t rust_sp_disp = old_top - this->rust_sp;\n-    size_t ssz = old_top - old_bottom;\n-    DLOG(dom, task, \"upcall_grow_task(%\" PRIdPTR\n-         \"), old size %\" PRIdPTR \" bytes (old lim: 0x%\" PRIxPTR \")\",\n-         n_frame_bytes, ssz, old_top);\n-    ssz *= 2;\n-    if (ssz < n_frame_bytes)\n-        ssz = n_frame_bytes;\n-    ssz = next_power_of_two(ssz);\n-\n-    DLOG(dom, task, \"upcall_grow_task growing stk 0x%\"\n-         PRIxPTR \" to %d bytes\", old_stk, ssz);\n-\n-    stk_seg *nstk = new_stk(dom, ssz);\n-    uintptr_t new_top = (uintptr_t) &nstk->data[ssz];\n-    size_t n_copy = old_top - old_bottom;\n-    DLOG(dom, task,\n-         \"copying %d bytes of stack from [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\"\n-         \" to [0x%\" PRIxPTR \", 0x%\" PRIxPTR \"]\",\n-         n_copy,\n-         old_bottom, old_bottom + n_copy,\n-         new_top - n_copy, new_top);\n-\n-    VALGRIND_MAKE_MEM_DEFINED((void*)old_bottom, n_copy);\n-    memcpy((void*)(new_top - n_copy), (void*)old_bottom, n_copy);\n-\n-    nstk->limit = new_top;\n-    this->stk = nstk;\n-    this->rust_sp = new_top - rust_sp_disp;\n-\n-    DLOG(dom, task, \"processing relocations\");\n-\n-    // FIXME (issue #32): this is the most ridiculously crude\n-    // relocation scheme ever. Try actually, you know, writing out\n-    // reloc descriptors?\n-    size_t n_relocs = 0;\n-    for (uintptr_t* p = (uintptr_t*)(new_top - n_copy);\n-         p < (uintptr_t*)new_top; ++p) {\n-        if (old_bottom <= *p && *p < old_top) {\n-            //DLOG(dom, mem, \"relocating pointer 0x%\" PRIxPTR\n-            //        \" by %d bytes\", *p, (new_top - old_top));\n-            n_relocs++;\n-            *p += (new_top - old_top);\n-        }\n-    }\n-    DLOG(dom, task, \"processed %d relocations\", n_relocs);\n-    del_stk(dom, old_stk);\n-    LOGPTR(dom, \"grown stk limit\", new_top);\n-#endif\n-}\n-\n-void\n-push_onto_thread_stack(uintptr_t &sp, uintptr_t value)\n-{\n-    asm(\"xchgl %0, %%esp\\n\"\n-        \"push %2\\n\"\n-        \"xchgl %0, %%esp\\n\"\n-        : \"=r\" (sp)\n-        : \"0\" (sp), \"r\" (value)\n-        : \"eax\");\n-}\n-\n-void\n-rust_task::run_after_return(size_t nargs, uintptr_t glue)\n-{\n-    // This is only safe to call if we're the currently-running task.\n-    check_active();\n-\n-    uintptr_t sp = runtime_sp;\n-\n-    // The compiler reserves nargs + 1 word for oldsp on the stack and\n-    // then aligns it.\n-    sp = align_down(sp - nargs * sizeof(uintptr_t));\n-\n-    uintptr_t *retpc = ((uintptr_t *) sp) - 1;\n-    DLOG(dom, task,\n-         \"run_after_return: overwriting retpc=0x%\" PRIxPTR\n-         \" @ runtime_sp=0x%\" PRIxPTR\n-         \" with glue=0x%\" PRIxPTR,\n-         *retpc, sp, glue);\n-\n-    // Move the current return address (which points into rust code)\n-    // onto the rust stack and pretend we just called into the glue.\n-    push_onto_thread_stack(rust_sp, *retpc);\n-    *retpc = glue;\n-}\n-\n-void\n-rust_task::run_on_resume(uintptr_t glue)\n-{\n-    // This is only safe to call if we're suspended.\n-    check_suspended();\n-\n-    // Inject glue as resume address in the suspended frame.\n-    uintptr_t* rsp = (uintptr_t*) rust_sp;\n-    rsp += n_callee_saves;\n-    DLOG(dom, task,\n-             \"run_on_resume: overwriting retpc=0x%\" PRIxPTR\n-             \" @ rust_sp=0x%\" PRIxPTR\n-             \" with glue=0x%\" PRIxPTR,\n-             *rsp, rsp, glue);\n-    *rsp = glue;\n }\n \n void\n rust_task::yield(size_t nargs) {\n     yield(nargs, 0);\n }\n \n-extern \"C\" void new_rust_yield_glue(void) asm(\"new_rust_yield_glue\");\n-\n void\n rust_task::yield(size_t nargs, size_t time_in_us) {\n     LOG(this, task, \"task %s @0x%\" PRIxPTR \" yielding for %d us\",\n         name, this, time_in_us);\n+\n+    // TODO: what is nargs for, and is it safe to ignore?\n+\n     yield_timer.reset(time_in_us);\n-    run_after_return(nargs, (uintptr_t) new_rust_yield_glue);\n-}\n \n-static inline uintptr_t\n-get_callee_save_fp(uintptr_t *top_of_callee_saves)\n-{\n-    return top_of_callee_saves[n_callee_saves - (callee_save_fp + 1)];\n+    // Return to the scheduler.\n+    ctx.next->swap(ctx);\n }\n \n void\n@@ -410,20 +285,6 @@ rust_task::notify_tasks_waiting_to_join() {\n     }\n }\n \n-uintptr_t\n-rust_task::get_fp() {\n-    // sp in any suspended task points to the last callee-saved reg on\n-    // the task stack.\n-    return get_callee_save_fp((uintptr_t*)rust_sp);\n-}\n-\n-uintptr_t\n-rust_task::get_previous_fp(uintptr_t fp) {\n-    // FIXME: terribly X86-specific.\n-    // *fp == previous_fp.\n-    return *((uintptr_t*)fp);\n-}\n-\n frame_glue_fns*\n rust_task::get_frame_glue_fns(uintptr_t fp) {\n     fp -= sizeof(uintptr_t);\n@@ -548,10 +409,10 @@ rust_task::free(void *p, bool is_gc)\n \n void\n rust_task::transition(rust_task_list *src, rust_task_list *dst) {\n-    I(dom, state == src);\n     DLOG(dom, task,\n-             \"task %s \" PTR \" state change '%s' -> '%s'\",\n-             name, (uintptr_t)this, src->name, dst->name);\n+         \"task %s \" PTR \" state change '%s' -> '%s' while in '%s'\",\n+         name, (uintptr_t)this, src->name, dst->name, state->name);\n+    I(dom, state == src);\n     src->remove(this);\n     dst->append(this);\n     state = dst;"}, {"sha": "82792c1e1e5b3d26a05cb74fb9d5c6dbb9bcce96", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -7,6 +7,8 @@\n \n #include \"util/array_list.h\"\n \n+#include \"context.h\"\n+\n struct\n rust_task : public maybe_proxy<rust_task>,\n             public dom_owned<rust_task>\n@@ -47,6 +49,8 @@ rust_task : public maybe_proxy<rust_task>,\n \n     rust_handle<rust_task> *handle;\n \n+    context ctx;\n+\n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n     rust_task(rust_dom *dom,\n               rust_task_list *state,\n@@ -83,14 +87,6 @@ rust_task : public maybe_proxy<rust_task>,\n     // Print a backtrace, if the \"bt\" logging option is on.\n     void backtrace();\n \n-    // Swap in some glue code to run when we have returned to the\n-    // task's context (assuming we're the active task).\n-    void run_after_return(size_t nargs, uintptr_t glue);\n-\n-    // Swap in some glue code to run when we're next activated\n-    // (assuming we're the suspended task).\n-    void run_on_resume(uintptr_t glue);\n-\n     // Save callee-saved registers and return to the main loop.\n     void yield(size_t nargs);\n \n@@ -114,8 +110,6 @@ rust_task : public maybe_proxy<rust_task>,\n \n     rust_handle<rust_task> * get_handle();\n \n-    uintptr_t get_fp();\n-    uintptr_t get_previous_fp(uintptr_t fp);\n     frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n     rust_crate_cache * get_crate_cache();\n };"}, {"sha": "fb7e3edc4f88e2ecf13da284c532a0feb42031c3", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -462,11 +462,22 @@ upcall_new_task(rust_task *spawner, rust_vec *name) {\n     return task;\n }\n \n+// TODO: This is copied from rust_task.cpp. Both copies should be moved to a\n+// common location.\n+static uintptr_t\n+align_down(uintptr_t sp)\n+{\n+    // There is no platform we care about that needs more than a\n+    // 16-byte alignment.\n+    return sp & ~(16 - 1);\n+}\n+\n extern \"C\" CDECL rust_task *\n upcall_start_task(rust_task *spawner,\n                   rust_task *task,\n                   uintptr_t spawnee_fn,\n-                  uintptr_t args) {\n+                  uintptr_t args,\n+                  size_t args_sz) {\n     LOG_UPCALL_ENTRY(spawner);\n \n     rust_dom *dom = spawner->dom;\n@@ -478,7 +489,14 @@ upcall_start_task(rust_task *spawner,\n \n     // we used to be generating this tuple in rustc, but it's easier to do it\n     // here.\n-    uintptr_t start_args[] = {0, 0, 0, args};\n+    //\n+    // The args tuple is stack-allocated. We need to move it over to the new\n+    // stack.\n+    task->rust_sp -= args_sz;\n+    memcpy((void*)task->rust_sp, (void*)args, args_sz);\n+    uintptr_t start_args[] = {0, 0, 0, task->rust_sp};\n+    \n+    task->rust_sp = align_down(task->rust_sp);\n     \n     task->start(spawnee_fn, (uintptr_t)start_args, sizeof(start_args));\n     return task;"}, {"sha": "bea25d633ff5f02909963282046b8c365abe8db2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -36,6 +36,8 @@ str_push_byte\n str_slice\n str_vec\n task_sleep\n+task_yield\n+task_join\n unsafe_vec_to_mut\n unsupervise\n upcall_clone_chan"}, {"sha": "4f2622858261bbd2d56d76de258248ef8903dbb9", "filename": "src/rt/sync/lock_and_signal.cpp", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Fsync%2Flock_and_signal.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Frt%2Fsync%2Flock_and_signal.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_and_signal.cpp?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -22,33 +22,33 @@ lock_and_signal::lock_and_signal() {\n \n #else\n lock_and_signal::lock_and_signal() {\n-    pthread_cond_init(&_cond, NULL);\n-    pthread_mutex_init(&_mutex, NULL);\n+    CHECKED(pthread_cond_init(&_cond, NULL));\n+    CHECKED(pthread_mutex_init(&_mutex, NULL));\n }\n #endif\n \n lock_and_signal::~lock_and_signal() {\n #if defined(__WIN32__)\n     CloseHandle(_event);\n #else\n-    pthread_cond_destroy(&_cond);\n-    pthread_mutex_destroy(&_mutex);\n+    CHECKED(pthread_cond_destroy(&_cond));\n+    CHECKED(pthread_mutex_destroy(&_mutex));\n #endif\n }\n \n void lock_and_signal::lock() {\n #if defined(__WIN32__)\n     EnterCriticalSection(&_cs);\n #else\n-    pthread_mutex_lock(&_mutex);\n+    CHECKED(pthread_mutex_lock(&_mutex));\n #endif\n }\n \n void lock_and_signal::unlock() {\n #if defined(__WIN32__)\n     LeaveCriticalSection(&_cs);\n #else\n-    pthread_mutex_unlock(&_mutex);\n+    CHECKED(pthread_mutex_unlock(&_mutex));\n #endif\n }\n \n@@ -66,14 +66,14 @@ void lock_and_signal::timed_wait(size_t timeout_in_ns) {\n     EnterCriticalSection(&_cs);\n #else\n     if (timeout_in_ns == 0) {\n-        pthread_cond_wait(&_cond, &_mutex);\n+        CHECKED(pthread_cond_wait(&_cond, &_mutex));\n     } else {\n         timeval time_val;\n         gettimeofday(&time_val, NULL);\n         timespec time_spec;\n         time_spec.tv_sec = time_val.tv_sec + 0;\n         time_spec.tv_nsec = time_val.tv_usec * 1000 + timeout_in_ns;\n-        pthread_cond_timedwait(&_cond, &_mutex, &time_spec);\n+        CHECKED(pthread_cond_timedwait(&_cond, &_mutex, &time_spec));\n     }\n #endif\n }\n@@ -85,7 +85,7 @@ void lock_and_signal::signal() {\n #if defined(__WIN32__)\n     SetEvent(_event);\n #else\n-    pthread_cond_signal(&_cond);\n+    CHECKED(pthread_cond_signal(&_cond));\n #endif\n }\n \n@@ -96,7 +96,7 @@ void lock_and_signal::signal_all() {\n #if defined(__WIN32__)\n     SetEvent(_event);\n #else\n-    pthread_cond_broadcast(&_cond);\n+    CHECKED(pthread_cond_broadcast(&_cond));\n #endif\n }\n "}, {"sha": "767c9c5cae6ddbc960a096da990aac8897cb55a1", "filename": "src/rt/yield_glue.s", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1595c9d767de72340358028e87d3eb386af0adfe/src%2Frt%2Fyield_glue.s", "raw_url": "https://github.com/rust-lang/rust/raw/1595c9d767de72340358028e87d3eb386af0adfe/src%2Frt%2Fyield_glue.s", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fyield_glue.s?ref=1595c9d767de72340358028e87d3eb386af0adfe", "patch": "@@ -1,42 +0,0 @@\n-/* More glue code, this time the 'bottom half' of yielding.\n- *\n- * We arrived here because an native call decided to deschedule the\n- * running task. So the native call's return address got patched to the\n- * first instruction of this glue code.\n- *\n- * When the native call does 'ret' it will come here, and its esp will be\n- * pointing to the last argument pushed on the C stack before making\n- * the native call: the 0th argument to the native call, which is always\n- * the task ptr performing the native call. That's where we take over.\n- *\n- * Our goal is to complete the descheduling\n- *\n- *   - Switch over to the task stack temporarily.\n- *\n- *   - Save the task's callee-saves onto the task stack.\n- *     (the task is now 'descheduled', safe to set aside)\n- *\n- *   - Switch *back* to the C stack.\n- *\n- *   - Restore the C-stack callee-saves.\n- *\n- *   - Return to the caller on the C stack that activated the task.\n- *\n- */\n-\n-\t.globl new_rust_yield_glue\n-\t.balign 4\n-new_rust_yield_glue:\n-\tmovl  0(%esp), %ecx    # ecx = rust_task\n-\tmovl  16(%ecx), %esp\n-\tpushl %ebp\n-\tpushl %edi\n-\tpushl %esi\n-\tpushl %ebx\n-\tmovl  %esp, 16(%ecx)\n-\tmovl  12(%ecx), %esp\n-\tpopl  %ebx\n-\tpopl  %esi\n-\tpopl  %edi\n-\tpopl  %ebp\n-\tret"}, {"sha": "844f3ee3bfa1b2d842604e2e4ec62e28fafde785", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -8,12 +8,14 @@ fn main() {\n   spawn child(chan(p));\n   let int y;\n   p |> y;\n-  log \"received\";\n-  log y;\n-  assert (y == 10);\n+  log_err \"received\";\n+  log_err y;\n+  //assert (y == 10);\n }\n \n fn child(chan[int] c) {\n+  log_err \"sending\";\n   c <| 10;\n+  log_err \"value sent\"\n }\n "}, {"sha": "0a5b3c30cf3625f6c028bea0eda800b987fa1db1", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,23 +1,24 @@\n // xfail-stage0\n-// xfail-stage1\n-// xfail-stage2\n // -*- rust -*-\n \n+use std;\n+\n+import std::task::*;\n+\n fn main() {\n   auto other = spawn child();\n-  log \"1\";\n-  yield;\n-  log \"2\";\n-  yield;\n-  log \"3\";\n-  join other;\n+  log_err \"1\";\n+  yield();\n+  log_err \"2\";\n+  yield();\n+  log_err \"3\";\n+  join(other);\n }\n \n fn child() {\n-  log \"4\";\n-  yield;\n-  log \"5\";\n-  yield;\n-  log \"6\";\n+  log_err \"4\";\n+  yield();\n+  log_err \"5\";\n+  yield();\n+  log_err \"6\";\n }\n-"}, {"sha": "4c09b3742023624f84f74adf2697922b8f2f1fc8", "filename": "src/test/run-pass/yield1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -0,0 +1,17 @@\n+// xfail-stage0\n+// -*- rust -*-\n+\n+use std;\n+\n+import std::task::*;\n+\n+fn main() {\n+  auto other = spawn child();\n+  log_err \"1\";\n+  yield();\n+  join(other);\n+}\n+\n+fn child() {\n+  log_err \"2\";\n+}"}, {"sha": "b4a2b2702325c84f9d4907a4039eaed4b78efc1b", "filename": "src/test/run-pass/yield2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fyield2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1857d30fc05f29fb82231336b229e50948a8336/src%2Ftest%2Frun-pass%2Fyield2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield2.rs?ref=d1857d30fc05f29fb82231336b229e50948a8336", "patch": "@@ -1,13 +1,13 @@\n // xfail-stage0\n-// xfail-stage1\n-// xfail-stage2\n // -*- rust -*-\n \n+use std;\n+\n fn main() {\n   let int i = 0;\n   while (i < 100) {\n     i = i + 1;\n-    log i;\n-    yield;\n+    log_err i;\n+    std::task::yield();\n   }\n }"}]}