{"sha": "dc75695e973d608903e1860db45b950b1a4cd470", "node_id": "C_kwDOAAsO6NoAKGRjNzU2OTVlOTczZDYwODkwM2UxODYwZGI0NWI5NTBiMWE0Y2Q0NzA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T21:08:05Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:26Z"}, "message": "Split out `match_wild_err_arm`", "tree": {"sha": "fe0dca48a57f9275efdaf6ca9e2debb3f9dc70b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe0dca48a57f9275efdaf6ca9e2debb3f9dc70b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc75695e973d608903e1860db45b950b1a4cd470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc75695e973d608903e1860db45b950b1a4cd470", "html_url": "https://github.com/rust-lang/rust/commit/dc75695e973d608903e1860db45b950b1a4cd470", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc75695e973d608903e1860db45b950b1a4cd470/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a70439ef080f9b0a2bf08d124035ac120c6e0ee", "html_url": "https://github.com/rust-lang/rust/commit/2a70439ef080f9b0a2bf08d124035ac120c6e0ee"}], "stats": {"total": 104, "additions": 55, "deletions": 49}, "files": [{"sha": "bc16f17b6196e420184860ce3dd731f9eeeebdbe", "filename": "clippy_lints/src/matches/match_wild_err_arm.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dc75695e973d608903e1860db45b950b1a4cd470/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75695e973d608903e1860db45b950b1a4cd470/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs?ref=dc75695e973d608903e1860db45b950b1a4cd470", "patch": "@@ -0,0 +1,51 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::macros::{is_panic, root_macro_call};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{is_wild, peel_blocks_with_stmt};\n+use rustc_hir::{Arm, Expr, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::{kw, sym};\n+\n+use super::MATCH_WILD_ERR_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n+    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n+        for arm in arms {\n+            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n+                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n+                if path_str == \"Err\" {\n+                    let mut matching_wild = inner.iter().any(is_wild);\n+                    let mut ident_bind_name = kw::Underscore;\n+                    if !matching_wild {\n+                        // Looking for unused bindings (i.e.: `_e`)\n+                        for pat in inner.iter() {\n+                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n+                                    ident_bind_name = ident.name;\n+                                    matching_wild = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if_chain! {\n+                        if matching_wild;\n+                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n+                        if is_panic(cx, macro_call.def_id);\n+                        then {\n+                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n+                            span_lint_and_note(cx,\n+                                MATCH_WILD_ERR_ARM,\n+                                arm.pat.span,\n+                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n+                                None,\n+                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "e2a103c58d1ef48d91a00a97cb65a3fb5a55d33d", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/dc75695e973d608903e1860db45b950b1a4cd470/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc75695e973d608903e1860db45b950b1a4cd470/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=dc75695e973d608903e1860db45b950b1a4cd470", "patch": "@@ -1,12 +1,7 @@\n-use clippy_utils::diagnostics::{\n-    multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-};\n-use clippy_utils::macros::{is_panic, root_macro_call};\n-use clippy_utils::peel_blocks_with_stmt;\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, is_lang_ctor, is_refutable, is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks,\n     peel_hir_pat_refs, recurse_or_patterns, strip_pat_refs,\n@@ -24,11 +19,12 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, VariantDef};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{sym, symbol::kw};\n+use rustc_span::sym;\n \n mod match_bool;\n mod match_like_matches;\n mod match_same_arms;\n+mod match_wild_err_arm;\n mod overlapping_arms;\n mod redundant_pattern_match;\n mod single_match;\n@@ -632,7 +628,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             single_match::check(cx, ex, arms, expr);\n             match_bool::check(cx, ex, arms, expr);\n             overlapping_arms::check(cx, ex, arms);\n-            check_wild_err_arm(cx, ex, arms);\n+            match_wild_err_arm::check(cx, ex, arms);\n             check_wild_enum_match(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n             check_wild_in_or_pats(cx, arms);\n@@ -709,47 +705,6 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n-    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n-        for arm in arms {\n-            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n-                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n-                if path_str == \"Err\" {\n-                    let mut matching_wild = inner.iter().any(is_wild);\n-                    let mut ident_bind_name = kw::Underscore;\n-                    if !matching_wild {\n-                        // Looking for unused bindings (i.e.: `_e`)\n-                        for pat in inner.iter() {\n-                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n-                                    ident_bind_name = ident.name;\n-                                    matching_wild = true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if_chain! {\n-                        if matching_wild;\n-                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n-                        if is_panic(cx, macro_call.def_id);\n-                        then {\n-                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n-                            span_lint_and_note(cx,\n-                                MATCH_WILD_ERR_ARM,\n-                                arm.pat.span,\n-                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n-                                None,\n-                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n enum CommonPrefixSearcher<'a> {\n     None,\n     Path(&'a [PathSegment<'a>]),"}]}