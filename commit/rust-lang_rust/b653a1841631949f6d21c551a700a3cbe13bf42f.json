{"sha": "b653a1841631949f6d21c551a700a3cbe13bf42f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NTNhMTg0MTYzMTk0OWY2ZDIxYzU1MWE3MDBhM2NiZTEzYmY0MmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-15T13:47:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-22T04:04:14Z"}, "message": "add mut decls to rustc and make them mandatory", "tree": {"sha": "a9c1b3b9525e98ec812453b51b5e5561a45dc110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9c1b3b9525e98ec812453b51b5e5561a45dc110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b653a1841631949f6d21c551a700a3cbe13bf42f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b653a1841631949f6d21c551a700a3cbe13bf42f", "html_url": "https://github.com/rust-lang/rust/commit/b653a1841631949f6d21c551a700a3cbe13bf42f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b653a1841631949f6d21c551a700a3cbe13bf42f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7be4abdae6165668059515e0113021be6dddeb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7be4abdae6165668059515e0113021be6dddeb9", "html_url": "https://github.com/rust-lang/rust/commit/d7be4abdae6165668059515e0113021be6dddeb9"}], "stats": {"total": 1880, "additions": 956, "deletions": 924}, "files": [{"sha": "fbdf42bc0849bacb24ed079356f6174d1b89beeb", "filename": "mk/target.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -53,7 +53,8 @@ $$(TBIN$(1)_T_$(2)_H_$(3))/rustc$$(X):\t\t\t\t\\\n \t\t$$(RUSTC_INPUTS)                                \\\n \t\t$$(TLIBRUSTC_DEFAULT$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3))  -o $$@ $$<\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(ENFORCE_MUT_VARS_$(1)) \\\n+\t\t -o $$@ $$<\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC):\t\t\\\n \t\t$$(COMPILER_CRATE) $$(COMPILER_INPUTS)\t\t\\\n@@ -62,7 +63,8 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC):\t\t\\\n \t\t$$(TCORELIB_DEFAULT$(1)_T_$(2)_H_$(3))      \\\n \t\t$$(TSTDLIB_DEFAULT$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) $$(ENFORCE_MUT_VARS_$(1)) \\\n+\t\t-o $$@ $$< && touch $$@\n \n endef\n "}, {"sha": "7b0e14b1da6d7f5efaeaaefd17d41c45702f9b7f", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -116,7 +116,7 @@ mod write {\n         let opts = sess.opts;\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n-        let pm = mk_pass_manager();\n+        let mut pm = mk_pass_manager();\n         let td = mk_target_data(\n             sess.targ_cfg.target_strs.data_layout);\n         llvm::LLVMAddTargetData(td.lltd, pm.llpm);\n@@ -165,7 +165,7 @@ mod write {\n             llvm::LLVMPassManagerBuilderDispose(FPMB);\n \n             llvm::LLVMRunPassManager(fpm.llpm, llmod);\n-            let threshold = 225u;\n+            let mut threshold = 225u;\n             if opts.optimize == 3u { threshold = 275u; }\n \n             let MPMB = llvm::LLVMPassManagerBuilderCreate();\n@@ -195,15 +195,15 @@ mod write {\n             let LLVMOptDefault    = 2 as c_int; // -O2, -Os\n             let LLVMOptAggressive = 3 as c_int; // -O3\n \n-            let CodeGenOptLevel;\n+            let mut CodeGenOptLevel;\n             alt check opts.optimize {\n               0u { CodeGenOptLevel = LLVMOptNone; }\n               1u { CodeGenOptLevel = LLVMOptLess; }\n               2u { CodeGenOptLevel = LLVMOptDefault; }\n               3u { CodeGenOptLevel = LLVMOptAggressive; }\n             }\n \n-            let FileType;\n+            let mut FileType;\n             if opts.output_type == output_type_object ||\n                    opts.output_type == output_type_exe {\n                 FileType = LLVMObjectFile;\n@@ -362,9 +362,9 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n \n     fn provided_link_metas(sess: session, c: ast::crate) ->\n        provided_metas {\n-        let name: option<str> = none;\n-        let vers: option<str> = none;\n-        let cmh_items: [@ast::meta_item] = [];\n+        let mut name: option<str> = none;\n+        let mut vers: option<str> = none;\n+        let mut cmh_items: [@ast::meta_item] = [];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);\n         for meta: @ast::meta_item in linkage_metas {\n@@ -433,7 +433,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n               none {\n                 let name =\n                     {\n-                        let os = str::split_char(path::basename(output), '.');\n+                        let mut os =\n+                            str::split_char(path::basename(output), '.');\n                         if (vec::len(os) < 2u) {\n                             sess.fatal(#fmt(\"output file name %s doesn't\\\n                               appear to have an extension\", output));\n@@ -494,7 +495,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: link_meta) ->\n }\n \n fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n-    let hash = \"\";\n+    let mut hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n       none {\n@@ -509,7 +510,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n // gas doesn't!\n fn sanitize(s: str) -> str {\n-    let result = \"\";\n+    let mut result = \"\";\n     str::chars_iter(s) {|c|\n         alt c {\n           '@' { result += \"_sbox_\"; }\n@@ -536,7 +537,7 @@ fn sanitize(s: str) -> str {\n fn mangle(ss: path) -> str {\n     // Follow C++ namespace-mangling style\n \n-    let n = \"_ZN\"; // Begin name-sequence.\n+    let mut n = \"_ZN\"; // Begin name-sequence.\n \n     for s in ss {\n         alt s { path_name(s) | path_mod(s) {\n@@ -597,7 +598,7 @@ fn link_binary(sess: session,\n             } else { ret filename; }\n         };\n         fn rmext(filename: str) -> str {\n-            let parts = str::split_char(filename, '.');\n+            let mut parts = str::split_char(filename, '.');\n             vec::pop(parts);\n             ret str::connect(parts, \".\");\n         }\n@@ -636,11 +637,11 @@ fn link_binary(sess: session,\n         if sess.targ_cfg.os == session::os_win32 { \"gcc\" } else { \"cc\" };\n     // The invocations of cc share some flags across platforms\n \n-    let cc_args =\n+    let mut cc_args =\n         [stage] + sess.targ_cfg.target_strs.cc_args +\n         [\"-o\", output, obj_filename];\n \n-    let lib_cmd;\n+    let mut lib_cmd;\n     let os = sess.targ_cfg.os;\n     if os == session::os_macos {\n         lib_cmd = \"-dynamiclib\";"}, {"sha": "eb52a2884cb5899dfaeebc8ae1d9ba6cb70a6a63", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -130,14 +130,13 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     assert len2 > 0u;\n \n     let max_common_path = uint::min(len1, len2) - 1u;\n-    let start_idx = 0u;\n+    let mut start_idx = 0u;\n     while start_idx < max_common_path\n         && split1[start_idx] == split2[start_idx] {\n         start_idx += 1u;\n     }\n \n-    let path = [];\n-\n+    let mut path = [];\n     uint::range(start_idx, len1 - 1u) {|_i| path += [\"..\"]; };\n \n     path += vec::slice(split2, start_idx, len2 - 1u);\n@@ -179,7 +178,7 @@ fn get_install_prefix_rpath(cwd: path::path, target_triple: str) -> str {\n \n fn minimize_rpaths(rpaths: [str]) -> [str] {\n     let set = map::str_hash::<()>();\n-    let minimized = [];\n+    let mut minimized = [];\n     for rpath in rpaths {\n         if !set.contains_key(rpath) {\n             minimized += [rpath];"}, {"sha": "3d8b051638b2c9000d9a5d732d30964f4837805b", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -34,7 +34,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n     fn decl(llmod: ModuleRef, prefix: str, name: str,\n             tys: [TypeRef], rv: TypeRef) ->\n        ValueRef {\n-        let arg_tys: [TypeRef] = [];\n+        let mut arg_tys: [TypeRef] = [];\n         for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret base::decl_cdecl_fn(llmod, prefix + name, fn_ty);"}, {"sha": "cb4d59e70a1fcec4513d253423c5ed2e8fc8dbfb", "filename": "src/rustc/driver/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdiagnostic.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -195,8 +195,8 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n \n     // arbitrarily only print up to six lines of the error\n     let max_lines = 6u;\n-    let elided = false;\n-    let display_lines = lines.lines;\n+    let mut elided = false;\n+    let mut display_lines = lines.lines;\n     if vec::len(display_lines) > max_lines {\n         display_lines = vec::slice(display_lines, 0u, max_lines);\n         elided = true;\n@@ -210,8 +210,8 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     if elided {\n         let last_line = display_lines[vec::len(display_lines) - 1u];\n         let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n-        let indent = str::len(s);\n-        let out = \"\";\n+        let mut indent = str::len(s);\n+        let mut out = \"\";\n         while indent > 0u { out += \" \"; indent -= 1u; }\n         out += \"...\\n\";\n         io::stderr().write_str(out);\n@@ -221,22 +221,22 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     // If there's one line at fault we can easily point to the problem\n     if vec::len(lines.lines) == 1u {\n         let lo = codemap::lookup_char_pos(cm, sp.lo);\n-        let digits = 0u;\n-        let num = (lines.lines[0] + 1u) / 10u;\n+        let mut digits = 0u;\n+        let mut num = (lines.lines[0] + 1u) / 10u;\n \n         // how many digits must be indent past?\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = str::len(fm.name) + digits + lo.col + 3u;\n-        let s = \"\";\n+        let mut left = str::len(fm.name) + digits + lo.col + 3u;\n+        let mut s = \"\";\n         while left > 0u { str::push_char(s, ' '); left -= 1u; }\n \n         s += \"^\";\n         let hi = codemap::lookup_char_pos(cm, sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n-            let width = hi.col - lo.col - 1u;\n+            let mut width = hi.col - lo.col - 1u;\n             while width > 0u { str::push_char(s, '~'); width -= 1u; }\n         }\n         io::stderr().write_str(s + \"\\n\");"}, {"sha": "6b5a86989765149dfa3a09f7c294aeb3aba78f12", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -66,7 +66,7 @@ fn build_configuration(sess: session, argv0: str, input: str) ->\n fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n-    let words = [];\n+    let mut words = [];\n     for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n     ret words;\n }\n@@ -106,8 +106,8 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n                 outputs: option<output_filenames>)\n     -> {crate: @ast::crate, tcx: option<ty::ctxt>} {\n     let time_passes = sess.opts.time_passes;\n-    let crate = time(time_passes, \"parsing\",\n-                     bind parse_input(sess, cfg, input));\n+    let mut crate = time(time_passes, \"parsing\",\n+                         bind parse_input(sess, cfg, input));\n     if upto == cu_parse { ret {crate: crate, tcx: none}; }\n \n     sess.building_library = session::building_library(\n@@ -261,7 +261,7 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: str,\n     };\n     let {crate, tcx} = compile_upto(sess, cfg, input, upto, none);\n \n-    let ann: pprust::pp_ann = pprust::no_ann();\n+    let mut ann: pprust::pp_ann = pprust::no_ann();\n     alt ppm {\n       ppm_typed {\n         ann = {pre: ann_paren_for_expr,\n@@ -362,7 +362,7 @@ fn build_session_options(match: getopts::match,\n \n     let parse_only = opt_present(match, \"parse-only\");\n     let no_trans = opt_present(match, \"no-trans\");\n-    let lint_opts = [];\n+    let mut lint_opts = [];\n     if opt_present(match, \"no-lint-ctypes\") {\n         lint_opts += [(lint::ctypes, false)];\n     }\n@@ -388,7 +388,7 @@ fn build_session_options(match: getopts::match,\n     let time_llvm_passes = opt_present(match, \"time-llvm-passes\");\n     let sysroot_opt = getopts::opt_maybe_str(match, \"sysroot\");\n     let target_opt = getopts::opt_maybe_str(match, \"target\");\n-    let no_asm_comments = getopts::opt_present(match, \"no-asm-comments\");\n+    let mut no_asm_comments = getopts::opt_present(match, \"no-asm-comments\");\n     alt output_type {\n       // unless we're emitting huamn-readable assembly, omit comments.\n       link::output_type_llvm_assembly | link::output_type_assembly {}\n@@ -531,8 +531,8 @@ fn build_output_filenames(ifile: str,\n                           ofile: option<str>,\n                           sess: session)\n         -> output_filenames {\n-    let obj_path = \"\";\n-    let out_path: str = \"\";\n+    let mut obj_path = \"\";\n+    let mut out_path: str = \"\";\n     let sopts = sess.opts;\n     let stop_after_codegen =\n         sopts.output_type != link::output_type_exe ||"}, {"sha": "2058b0f45b992708b52d7b97bc4904835489d117", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -11,7 +11,7 @@ import rustc::syntax::codemap;\n import rustc::driver::diagnostic;\n \n fn version(argv0: str) {\n-    let vers = \"unknown version\";\n+    let mut vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n     if str::len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n@@ -73,7 +73,8 @@ fn run_compiler(args: [str], demitter: diagnostic::emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n-    let args = args, binary = vec::shift(args);\n+    let mut args = args;\n+    let binary = vec::shift(args);\n \n     if vec::len(args) == 0u { usage(binary); ret; }\n "}, {"sha": "599da3811d17fec42cfdac8cfe2914d51c582b21", "filename": "src/rustc/front/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fattr.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -37,7 +37,7 @@ export native_abi;\n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n-    let metas: [@ast::meta_item] = [];\n+    let mut metas: [@ast::meta_item] = [];\n     for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n         alt attr.node.value.node {\n           ast::meta_list(_, items) { metas += items; }\n@@ -141,7 +141,7 @@ fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n fn attr_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n-    let mitems = [];\n+    let mut mitems = [];\n     for a: ast::attribute in attrs { mitems += [attr_meta(a)]; }\n     ret mitems;\n }\n@@ -198,12 +198,12 @@ fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: [mutable @ast::meta_item] = [mutable];\n+    let mut v: [mutable @ast::meta_item] = [mutable];\n     for mi: @ast::meta_item in items { v += [mutable mi]; }\n \n     std::sort::quick_sort(lteq, v);\n \n-    let v2: [@ast::meta_item] = [];\n+    let mut v2: [@ast::meta_item] = [];\n     for mi: @ast::meta_item in v { v2 += [mi]; }\n     ret v2;\n }"}, {"sha": "4af7e77bd8723bbe43caa6824b0cc0a8bb032769", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -267,7 +267,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     #debug(\"building test vector from %u tests\", vec::len(cx.testfns));\n-    let descs = [];\n+    let mut descs = [];\n     for test: test in cx.testfns {\n         let test_ = test; // Satisfy alias analysis\n         descs += [mk_test_desc_rec(cx, test_)];"}, {"sha": "d72bed20880f07234b8cfef8a6e70e3cf78f2172", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -965,8 +965,8 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n     let kind: int = llvm::LLVMGetTypeKind(ty) as int;\n \n     fn tys_str(names: type_names, outer: [TypeRef], tys: [TypeRef]) -> str {\n-        let s: str = \"\";\n-        let first: bool = true;\n+        let mut s: str = \"\";\n+        let mut first: bool = true;\n         for t: TypeRef in tys {\n             if first { first = false; } else { s += \", \"; }\n             s += type_to_str_inner(names, outer, t);\n@@ -989,7 +989,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n         ret \"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n       9 {\n-        let s = \"fn(\";\n+        let mut s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n         let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n         let args: [TypeRef] = vec::from_elem::<TypeRef>(n_args, 0 as TypeRef);\n@@ -1002,7 +1002,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n         ret s;\n       }\n       10 {\n-        let s: str = \"{\";\n+        let mut s: str = \"{\";\n         let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n         let elts: [TypeRef] = vec::from_elem::<TypeRef>(n_elts, 0 as TypeRef);\n         unsafe {\n@@ -1018,7 +1018,7 @@ fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n             uint::str(llvm::LLVMGetArrayLength(ty) as uint) + \"]\";\n       }\n       12 {\n-        let i: uint = 0u;\n+        let mut i: uint = 0u;\n         for tout: TypeRef in outer0 {\n             i += 1u;\n             if tout as int == ty as int {"}, {"sha": "0e53e656d9891b0019e9250772298b56f81c7917", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -109,7 +109,7 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n fn hash_node_id(&&node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n \n fn hash_path(&&s: str) -> uint {\n-    let h = 5381u;\n+    let mut h = 5381u;\n     for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;\n }"}, {"sha": "925995912405acdfd970b1af954273a213c7d3f5", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -68,7 +68,7 @@ fn visit_item(e: env, i: @ast::item) {\n               }\n               none { i.ident }\n             };\n-        let already_added = false;\n+        let mut already_added = false;\n         if vec::len(attr::find_attrs_by_name(i.attrs, \"nolink\")) == 0u {\n             already_added = !cstore::add_used_library(cstore, native_name);\n         }"}, {"sha": "679eaf841130393680f572ee0a673219c4ea8ecb", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -40,7 +40,7 @@ fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n \n fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n                path: [ast::ident]) -> [ast::def] {\n-    let result = [];\n+    let mut result = [];\n     #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n     for (c, data, def) in resolve_path(cstore, cnum, path) {\n         result += [decoder::lookup_def(c, data, def)];\n@@ -64,7 +64,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     let cm = cstore::get_crate_data(cstore, cnum);\n     #debug(\"resolve_path %s in crates[%d]:%s\",\n            str::connect(path, \"::\"), cnum, cm.name);\n-    let result = [];\n+    let mut result = [];\n     for def in decoder::resolve_path(path, cm.data) {\n         if def.crate == ast::local_crate {\n             result += [(cnum, cm.data, def)];"}, {"sha": "89e5343f6e4d81d595a7d056bf413f28f9d26049", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -141,7 +141,7 @@ fn find_use_stmt_cnum(cstore: cstore,\n // sorted by crate name.\n fn get_dep_hashes(cstore: cstore) -> [str] {\n     type crate_hash = {name: str, hash: str};\n-    let result = [];\n+    let mut result = [];\n \n     p(cstore).use_crate_map.values {|cnum|\n         let cdata = cstore::get_crate_data(cstore, cnum);"}, {"sha": "93d635734d9a25a3cf43b9820c3112b113f7bc6a", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -60,7 +60,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn@([u8]) -> bool, hash: uint) ->\n     let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n     // Awkward logic because we can't ret from foreach yet\n \n-    let result: [ebml::doc] = [];\n+    let mut result: [ebml::doc] = [];\n     let belt = tag_index_buckets_bucket_elt;\n     ebml::tagged_docs(bucket, belt) {|elt|\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n@@ -107,7 +107,7 @@ fn item_symbol(item: ebml::doc) -> str {\n }\n \n fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n-    let found = none;\n+    let mut found = none;\n     ebml::tagged_docs(d, tag_items_data_parent_item) {|did|\n         found = some(parse_def_id(ebml::doc_data(did)));\n     }\n@@ -142,7 +142,7 @@ fn item_type(item_id: ast::def_id, item: ebml::doc,\n \n fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> option<ty::t> {\n-    let result = none;\n+    let mut result = none;\n     ebml::tagged_docs(item, tag_impl_iface) {|ity|\n         let t = parse_ty_data(ity.data, cdata.cnum, ity.start, tcx, {|did|\n             translate_def_id(cdata, did)\n@@ -154,7 +154,7 @@ fn item_impl_iface(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n \n fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     -> @[ty::param_bounds] {\n-    let bounds = [];\n+    let mut bounds = [];\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) {|p|\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, {|did|\n             translate_def_id(cdata, did)\n@@ -165,14 +165,14 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n }\n \n fn item_ty_param_count(item: ebml::doc) -> uint {\n-    let n = 0u;\n+    let mut n = 0u;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n                       {|_p| n += 1u; });\n     n\n }\n \n fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> [ast::def_id] {\n-    let ids: [ast::def_id] = [];\n+    let mut ids: [ast::def_id] = [];\n     let v = tag_items_data_item_variant;\n     ebml::tagged_docs(item, v) {|p|\n         let ext = parse_def_id(ebml::doc_data(p));\n@@ -191,7 +191,7 @@ fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n     let md = ebml::doc(data);\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = bind eq_item(_, s);\n-    let result: [ast::def_id] = [];\n+    let mut result: [ast::def_id] = [];\n     #debug(\"resolve_path: looking up %s\", s);\n     for doc: ebml::doc in lookup_hash(paths, eqer, hash_path(s)) {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n@@ -206,7 +206,7 @@ fn item_path(item_doc: ebml::doc) -> ast_map::path {\n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n     let len = ebml::doc_as_u32(len_doc) as uint;\n \n-    let result = [];\n+    let mut result = [];\n     vec::reserve(result, len);\n \n     ebml::docs(path_doc) {|tag, elt_doc|\n@@ -250,7 +250,7 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n       'm' { ast::def_mod(did) }\n       'n' { ast::def_native_mod(did) }\n       'v' {\n-        let tid = option::get(item_parent_item(item));\n+        let mut tid = option::get(item_parent_item(item));\n         tid = {crate: cnum, node: tid.node};\n         ast::def_variant(tid, did)\n       }\n@@ -279,7 +279,7 @@ fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n \n fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n     let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n-    let found = none;\n+    let mut found = none;\n     ebml::tagged_docs(find_item(id, items), tag_item_method) {|mid|\n         let m_did = parse_def_id(ebml::doc_data(mid));\n         if item_name(find_item(m_did.node, items)) == name {\n@@ -290,7 +290,7 @@ fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n }\n \n fn item_is_intrinsic(cdata: cmd, id: ast::node_id) -> bool {\n-    let intrinsic = false;\n+    let mut intrinsic = false;\n     ebml::tagged_docs(lookup_item(id, cdata.data), tag_item_is_intrinsic,\n                       {|_i| intrinsic = true;});\n     intrinsic\n@@ -332,15 +332,15 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     let data = cdata.data;\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     let item = find_item(id, items);\n-    let infos: [ty::variant_info] = [];\n+    let mut infos: [ty::variant_info] = [];\n     let variant_ids = enum_variant_ids(item, cdata);\n-    let disr_val = 0;\n+    let mut disr_val = 0;\n     for did: ast::def_id in variant_ids {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type({crate: cdata.cnum, node: id}, item,\n                                 tcx, cdata);\n         let name = item_name(item);\n-        let arg_tys: [ty::t] = [];\n+        let mut arg_tys: [ty::t] = [];\n         alt ty::get(ctor_ty).struct {\n           ty::ty_fn(f) {\n             for a: ty::arg in f.inputs { arg_tys += [a.ty]; }\n@@ -360,7 +360,7 @@ fn get_enum_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n \n fn item_impl_methods(cdata: cmd, item: ebml::doc, base_tps: uint)\n     -> [@middle::resolve::method_info] {\n-    let rslt = [];\n+    let mut rslt = [];\n     ebml::tagged_docs(item, tag_item_method) {|doc|\n         let m_did = parse_def_id(ebml::doc_data(doc));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n@@ -375,7 +375,8 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n                      name: option<ast::ident>)\n     -> @[@middle::resolve::_impl] {\n     let data = cdata.data;\n-    let mod_item = lookup_item(m_id, data), result = [];\n+    let mod_item = lookup_item(m_id, data);\n+    let mut result = [];\n     ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n         let did = translate_def_id(cdata, parse_def_id(ebml::doc_data(doc)));\n         let item = lookup_item(did.node, data), nm = item_name(item);\n@@ -391,7 +392,8 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     -> @[ty::method] {\n     let data = cdata.data;\n-    let item = lookup_item(id, data), result = [];\n+    let item = lookup_item(id, data);\n+    let mut result = [];\n     ebml::tagged_docs(item, tag_item_method) {|mth|\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(mth);\n@@ -413,7 +415,8 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n fn get_class_members(cdata: cmd, id: ast::node_id,\n                      family: char) -> [ty::field_ty] {\n     let data = cdata.data;\n-    let item = lookup_item(id, data), result = [];\n+    let item = lookup_item(id, data);\n+    let mut result = [];\n     ebml::tagged_docs(item, tag_items_data_item) {|an_item|\n        if item_family(an_item) == family {\n           let name = item_name(an_item);\n@@ -487,7 +490,7 @@ fn item_family_to_str(fam: char) -> str {\n }\n \n fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n-    let items: [@ast::meta_item] = [];\n+    let mut items: [@ast::meta_item] = [];\n     ebml::tagged_docs(md, tag_meta_item_word) {|meta_item_doc|\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = str::from_bytes(ebml::doc_data(nd));\n@@ -512,7 +515,7 @@ fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n }\n \n fn get_attributes(md: ebml::doc) -> [ast::attribute] {\n-    let attrs: [ast::attribute] = [];\n+    let mut attrs: [ast::attribute] = [];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n         ebml::tagged_docs(attrs_d, tag_attribute) {|attr_doc|\n@@ -554,10 +557,10 @@ fn get_crate_attributes(data: @[u8]) -> [ast::attribute] {\n type crate_dep = {cnum: ast::crate_num, ident: str};\n \n fn get_crate_deps(data: @[u8]) -> [crate_dep] {\n-    let deps: [crate_dep] = [];\n+    let mut deps: [crate_dep] = [];\n     let cratedoc = ebml::doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n-    let crate_num = 1;\n+    let mut crate_num = 1;\n     ebml::tagged_docs(depsdoc, tag_crate_dep) {|depdoc|\n         let depname = str::from_bytes(ebml::doc_data(depdoc));\n         deps += [{cnum: crate_num, ident: depname}];\n@@ -615,7 +618,7 @@ fn get_crate_module_paths(bytes: @[u8]) -> [(ast::def_id, str)] {\n \n     // find all module (path, def_ids), which are not\n     // fowarded path due to renamed import or reexport\n-    let res = [];\n+    let mut res = [];\n     let mods = map::str_hash();\n     iter_crate_items(bytes) {|path, did|\n         let m = mod_of_path(path);"}, {"sha": "f20e89ec29889e54b464e8c8c242ad27668b27f5", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -180,8 +180,8 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n \n fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n     -> [entry<str>] {\n-    let index: [entry<str>] = [];\n-    let path: [str] = [];\n+    let mut index: [entry<str>] = [];\n+    let mut path: [str] = [];\n     ebml_w.start_tag(tag_paths);\n     encode_module_item_paths(ebml_w, ecx, crate.node.module, path, index);\n     encode_reexport_paths(ebml_w, ecx, index);\n@@ -283,8 +283,8 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                             id: node_id, variants: [variant],\n                             path: ast_map::path, index: @mutable [entry<int>],\n                             ty_params: [ty_param]) {\n-    let disr_val = 0;\n-    let i = 0;\n+    let mut disr_val = 0;\n+    let mut i = 0;\n     let vi = ty::enum_variants(ecx.ccx.tcx, {crate: local_crate, node: id});\n     for variant: variant in variants {\n         *index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n@@ -604,7 +604,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_name(ebml_w, item.ident);\n-        let i = 0u;\n+        let mut i = 0u;\n         for mty in *ty::iface_methods(tcx, local_def(item.id)) {\n             ebml_w.start_tag(tag_item_method);\n             encode_name(ebml_w, mty.ident);\n@@ -695,14 +695,14 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n fn create_index<T: copy>(index: [entry<T>], hash_fn: fn@(T) -> uint) ->\n    [@[entry<T>]] {\n-    let buckets: [@mutable [entry<T>]] = [];\n+    let mut buckets: [@mutable [entry<T>]] = [];\n     uint::range(0u, 256u) {|_i| buckets += [@mutable []]; };\n     for elt: entry<T> in index {\n         let h = hash_fn(elt.val);\n         *buckets[h % 256u] += [elt];\n     }\n \n-    let buckets_frozen = [];\n+    let mut buckets_frozen = [];\n     for bucket: @mutable [entry<T>] in buckets {\n         buckets_frozen += [@*bucket];\n     }\n@@ -713,7 +713,7 @@ fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n                    write_fn: fn(io::writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n-    let bucket_locs: [uint] = [];\n+    let mut bucket_locs: [uint] = [];\n     ebml_w.start_tag(tag_index_buckets);\n     for bucket: @[entry<T>] in buckets {\n         bucket_locs += [ebml_w.writer.tell()];\n@@ -815,8 +815,8 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n         ret attr::mk_attr(link_item);\n     }\n \n-    let attrs: [attribute] = [];\n-    let found_link_attr = false;\n+    let mut attrs: [attribute] = [];\n+    let mut found_link_attr = false;\n     for attr: attribute in crate.node.attrs {\n         attrs +=\n             if attr::get_attr_name(attr) != \"link\" {\n@@ -844,7 +844,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         type numname = {crate: crate_num, ident: str};\n \n         // Pull the cnums and names out of cstore\n-        let pairs: [mutable numname] = [mutable];\n+        let mut pairs: [mutable numname] = [mutable];\n         cstore::iter_crate_data(cstore) {|key, val|\n             pairs += [mutable {crate: key, ident: val.name}];\n         };\n@@ -854,7 +854,7 @@ fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n         std::sort::quick_sort(lteq, pairs);\n \n         // Sanity-check the crate numbers\n-        let expected_cnum = 1;\n+        let mut expected_cnum = 1;\n         for n: numname in pairs {\n             assert (n.crate == expected_cnum);\n             expected_cnum += 1;"}, {"sha": "3a925fdcb5ef8a0326157e3ebea8c94ab3c90f52", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -42,7 +42,7 @@ fn parse_ident(st: @pstate, last: char) -> ast::ident {\n \n fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n    ast::ident {\n-    let rslt = \"\";\n+    let mut rslt = \"\";\n     while !is_last(peek(st)) {\n         rslt += str::from_byte(next_byte(st));\n     }\n@@ -64,7 +64,7 @@ fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n }\n \n fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr] {\n-    let rslt: [@ty::constr] = [];\n+    let mut rslt: [@ty::constr] = [];\n     alt peek(st) {\n       ':' {\n         do  {\n@@ -79,7 +79,7 @@ fn parse_constrs(st: @pstate, conv: conv_did) -> [@ty::constr] {\n \n // FIXME less copy-and-paste\n fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr] {\n-    let rslt: [@ty::type_constr] = [];\n+    let mut rslt: [@ty::type_constr] = [];\n     alt peek(st) {\n       ':' {\n         do  {\n@@ -93,7 +93,7 @@ fn parse_ty_constrs(st: @pstate, conv: conv_did) -> [@ty::type_constr] {\n }\n \n fn parse_path(st: @pstate) -> @ast::path {\n-    let idents: [ast::ident] = [];\n+    let mut idents: [ast::ident] = [];\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n     idents += [parse_ident_(st, is_last)];\n     loop {\n@@ -145,12 +145,12 @@ fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n                          pser: fn(@pstate) -> ast::constr_arg_general_<T>)\n     -> @ty::constr_general<T> {\n     let sp = ast_util::dummy_sp(); // FIXME: use a real span\n-    let args: [@sp_constr_arg<T>] = [];\n+    let mut args: [@sp_constr_arg<T>] = [];\n     let pth = parse_path(st);\n-    let ignore: char = next(st);\n+    let mut ignore: char = next(st);\n     assert (ignore == '(');\n     let def = parse_def(st, conv);\n-    let an_arg: constr_arg_general_<T>;\n+    let mut an_arg: constr_arg_general_<T>;\n     do  {\n         an_arg = pser(st);\n         // FIXME use a real span\n@@ -203,15 +203,15 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       't' {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n-        let params: [ty::t] = [];\n+        let mut params: [ty::t] = [];\n         while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_enum(st.tcx, def, params);\n       }\n       'x' {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n-        let params: [ty::t] = [];\n+        let mut params: [ty::t] = [];\n         while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_iface(st.tcx, def, params);\n@@ -222,7 +222,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       's' {\n         assert next(st) == '[';\n-        let params = [];\n+        let mut params = [];\n         while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos += 1u;\n         ret ty::mk_self(st.tcx, params);\n@@ -233,9 +233,9 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'I' { ret ty::mk_vec(st.tcx, parse_mt(st, conv)); }\n       'R' {\n         assert (next(st) == '[');\n-        let fields: [ty::field] = [];\n+        let mut fields: [ty::field] = [];\n         while peek(st) != ']' {\n-            let name = \"\";\n+            let mut name = \"\";\n             while peek(st) != '=' {\n                 name += str::from_byte(next_byte(st));\n             }\n@@ -247,7 +247,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'T' {\n         assert (next(st) == '[');\n-        let params = [];\n+        let mut params = [];\n         while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_tup(st.tcx, params);\n@@ -260,7 +260,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) == '[');\n         let def = parse_def(st, conv);\n         let inner = parse_ty(st, conv);\n-        let params: [ty::t] = [];\n+        let mut params: [ty::t] = [];\n         while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n         st.pos = st.pos + 1u;\n         ret ty::mk_res(st.tcx, def, inner, params);\n@@ -309,7 +309,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           #debug(\"saw a [\");\n           let did = parse_def(st, conv);\n           #debug(\"parsed a def_id %?\", did);\n-          let params: [ty::t] = [];\n+          let mut params: [ty::t] = [];\n           while peek(st) != ']' { params += [parse_ty(st, conv)]; }\n           assert (next(st) == ']');\n           ret ty::mk_class(st.tcx, did, params);\n@@ -319,7 +319,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n }\n \n fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n-    let m;\n+    let mut m;\n     alt peek(st) {\n       'm' { next(st); m = ast::m_mutbl; }\n       '?' { next(st); m = ast::m_const; }\n@@ -329,14 +329,14 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n-    let def = [];\n+    let mut def = [];\n     while peek(st) != '|' { def += [next_byte(st)]; }\n     st.pos = st.pos + 1u;\n     ret conv(parse_def_id(def));\n }\n \n fn parse_int(st: @pstate) -> int {\n-    let n = 0;\n+    let mut n = 0;\n     loop {\n         let cur = peek(st);\n         if cur < '0' || cur > '9' { ret n; }\n@@ -347,7 +347,7 @@ fn parse_int(st: @pstate) -> int {\n }\n \n fn parse_hex(st: @pstate) -> uint {\n-    let n = 0u;\n+    let mut n = 0u;\n     loop {\n         let cur = peek(st);\n         if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { ret n; }\n@@ -361,7 +361,7 @@ fn parse_hex(st: @pstate) -> uint {\n \n fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     assert (next(st) == '[');\n-    let inputs: [ty::arg] = [];\n+    let mut inputs: [ty::arg] = [];\n     while peek(st) != ']' {\n         let mode = alt check peek(st) {\n           '&' { ast::by_mutbl_ref }\n@@ -383,7 +383,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n \n // Rust metadata parsing\n fn parse_def_id(buf: [u8]) -> ast::def_id {\n-    let colon_idx = 0u;\n+    let mut colon_idx = 0u;\n     let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n@@ -393,8 +393,8 @@ fn parse_def_id(buf: [u8]) -> ast::def_id {\n     let crate_part = vec::slice::<u8>(buf, 0u, colon_idx);\n     let def_part = vec::slice::<u8>(buf, colon_idx + 1u, len);\n \n-    let crate_part_vec = [];\n-    let def_part_vec = [];\n+    let mut crate_part_vec = [];\n+    let mut def_part_vec = [];\n     for b: u8 in crate_part { crate_part_vec += [b]; }\n     for b: u8 in def_part { def_part_vec += [b]; }\n \n@@ -421,7 +421,7 @@ fn parse_bounds_data(data: @[u8], start: uint,\n }\n \n fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound] {\n-    let bounds = [];\n+    let mut bounds = [];\n     loop {\n         bounds += [alt check next(st) {\n           'S' { ty::bound_send }"}, {"sha": "c526777f37e90788990b2efe07607454f64ddc99", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -65,8 +65,8 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n             let end = w.tell();\n             let len = end - pos;\n             fn estimate_sz(u: uint) -> uint {\n-                let n = u;\n-                let len = 0u;\n+                let mut n = u;\n+                let mut len = 0u;\n                 while n != 0u { len += 1u; n = n >> 4u; }\n                 ret len;\n             }\n@@ -256,7 +256,7 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n-    let colon = true;\n+    let mut colon = true;\n     for c: @ty::constr in ft.constraints {\n         if colon {\n             w.write_char(':');\n@@ -276,7 +276,7 @@ fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n-    let semi = false;\n+    let mut semi = false;\n     for a: @constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n@@ -293,7 +293,7 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n-    let semi = false;\n+    let mut semi = false;\n     for a: @ty::ty_constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {"}, {"sha": "fd6e7eb3ff27d69db923fc4af4547079e7a00668", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -96,7 +96,7 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n }\n \n fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n-    let handled = true;\n+    let mut handled = true;\n     alt ex.node {\n       ast::expr_call(f, args, _) {\n         check_call(*cx, sc, f, args);\n@@ -213,9 +213,9 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     -> [binding] {\n     let fty = ty::expr_ty(cx.tcx, f);\n     let arg_ts = ty::ty_fn_args(fty);\n-    let mut_roots: [{arg: uint, node: node_id}] = [];\n-    let bindings = [];\n-    let i = 0u;\n+    let mut mut_roots: [{arg: uint, node: node_id}] = [];\n+    let mut bindings = [];\n+    let mut i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         let arg = args[i];\n         let root = expr_root(cx, arg, false);\n@@ -251,9 +251,9 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n           _ { true }\n         };\n     if f_may_close {\n-        let i = 0u;\n+        let mut i = 0u;\n         for b in bindings {\n-            let unsfe = vec::len(b.unsafe_tys) > 0u;\n+            let mut unsfe = vec::len(b.unsafe_tys) > 0u;\n             alt b.root_var {\n               some(rid) {\n                 for o in sc.bs {\n@@ -271,10 +271,10 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n             i += 1u;\n         }\n     }\n-    let j = 0u;\n+    let mut j = 0u;\n     for b in bindings {\n         for unsafe_ty in b.unsafe_tys {\n-            let i = 0u;\n+            let mut i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias =\n                     (ast::by_mutbl_ref == ty::arg_mode(cx.tcx, arg_t));\n@@ -294,7 +294,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n     // Ensure we're not passing a root by mutable alias.\n \n     for {node: node, arg: arg} in mut_roots {\n-        let i = 0u;\n+        let mut i = 0u;\n         for b in bindings {\n             if i != arg {\n                 alt b.root_var {\n@@ -319,17 +319,17 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n              v: vt<scope>) {\n     v.visit_expr(input, sc, v);\n     let orig_invalid = *sc.invalid;\n-    let all_invalid = orig_invalid;\n+    let mut all_invalid = orig_invalid;\n     let root = expr_root(cx, input, true);\n     for a: ast::arm in arms {\n-        let new_bs = sc.bs;\n+        let mut new_bs = sc.bs;\n         let root_var = path_def_id(cx, root.ex);\n         let pat_id_map = pat_util::pat_id_map(cx.tcx.def_map, a.pats[0]);\n         type info = {\n             id: node_id,\n             mutable unsafe_tys: [unsafe_ty],\n             span: span};\n-        let binding_info: [info] = [];\n+        let mut binding_info: [info] = [];\n         for pat in a.pats {\n             for proot in pattern_roots(cx.tcx, root.mutbl, pat) {\n                 let canon_id = pat_id_map.get(proot.name);\n@@ -361,7 +361,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n-    let cur_mutbl = root.mutbl;\n+    let mut cur_mutbl = root.mutbl;\n     alt ty::get(seq_t).struct {\n       ty::ty_vec(mt) {\n         if mt.mutbl != ast::m_imm {\n@@ -371,7 +371,7 @@ fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n       _ {}\n     }\n     let root_var = path_def_id(cx, root.ex);\n-    let new_bs = sc.bs;\n+    let mut new_bs = sc.bs;\n     for proot in pattern_roots(cx.tcx, cur_mutbl, local.node.pat) {\n         new_bs += [mk_binding(cx, proot.id, proot.span, root_var,\n                               unsafe_set(proot.mutbl))];\n@@ -445,7 +445,7 @@ fn check_loop(cx: ctx, sc: scope, checker: fn()) {\n }\n \n fn test_scope(cx: ctx, sc: scope, b: binding, p: @ast::path) {\n-    let prob = find_invalid(b.node_id, *sc.invalid);\n+    let mut prob = find_invalid(b.node_id, *sc.invalid);\n     alt b.root_var {\n       some(dn) {\n         for other in sc.bs {\n@@ -560,12 +560,12 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_str | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n           ty::ty_enum(_, ts) | ty::ty_tup(ts) {\n-            let sum = 0u;\n+            let mut sum = 0u;\n             for t in ts { sum += score_ty(tcx, t); }\n             sum\n           }\n           ty::ty_rec(fs) {\n-            let sum = 0u;\n+            let mut sum = 0u;\n             for f in fs { sum += score_ty(tcx, f.mt.ty); }\n             sum\n           }\n@@ -628,7 +628,7 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n           }\n         }\n     }\n-    let set = [];\n+    let mut set = [];\n     walk(tcx, mutbl, pat, set);\n     ret set;\n }\n@@ -638,7 +638,7 @@ fn pattern_roots(tcx: ty::ctxt, mutbl: option<unsafe_ty>, pat: @ast::pat)\n fn expr_root(cx: ctx, ex: @ast::expr, autoderef: bool)\n     -> {ex: @ast::expr, mutbl: option<unsafe_ty>} {\n     let base_root = mutbl::expr_root(cx.tcx, ex, autoderef);\n-    let unsafe_ty = none;\n+    let mut unsafe_ty = none;\n     for d in *base_root.ds {\n         if d.mutbl { unsafe_ty = some(contains(d.outer_t)); break; }\n     }\n@@ -651,7 +651,7 @@ fn unsafe_set(from: option<unsafe_ty>) -> [unsafe_ty] {\n \n fn find_invalid(id: node_id, lst: list<@invalid>)\n     -> option<@invalid> {\n-    let cur = lst;\n+    let mut cur = lst;\n     loop {\n         alt cur {\n           list::nil { ret none; }\n@@ -664,17 +664,17 @@ fn find_invalid(id: node_id, lst: list<@invalid>)\n }\n \n fn join_invalid(a: list<@invalid>, b: list<@invalid>) -> list<@invalid> {\n-    let result = a;\n+    let mut result = a;\n     list::iter(b) {|elt|\n-        let found = false;\n+        let mut found = false;\n         list::iter(a) {|e| if e == elt { found = true; } }\n         if !found { result = list::cons(elt, @result); }\n     }\n     result\n }\n \n fn filter_invalid(src: list<@invalid>, bs: [binding]) -> list<@invalid> {\n-    let out = list::nil, cur = src;\n+    let mut out = list::nil, cur = src;\n     while cur != list::nil {\n         alt cur {\n           list::cons(head, tail) {"}, {"sha": "6646e1612c86a84f49e7358767626419fc847a77", "filename": "src/rustc/middle/block_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fblock_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fblock_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fblock_use.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -26,7 +26,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_call(f, args, _) {\n         cx.allow_block = true;\n         v.visit_expr(f, cx, v);\n-        let i = 0u;\n+        let mut i = 0u;\n         for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n             cx.allow_block = (ty::arg_mode(cx.tcx, arg_t) == by_ref);\n             v.visit_expr(args[i], cx, v);"}, {"sha": "fb1006bc91bd783704ba61a3b5a5fe02d47fe647", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -128,7 +128,7 @@ fn compute_capture_vars(tcx: ty::ctxt,\n         }\n     }\n \n-    let result = [];\n+    let mut result = [];\n     cap_map.values { |cap_var| result += [cap_var]; }\n     ret result;\n }"}, {"sha": "31ef3703c0b581618bac7dcc844c086a36d22589", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -35,12 +35,12 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n }\n \n fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n-    let i = 0;\n+    let mut i = 0;\n     /* Check for unreachable patterns */\n     for arm: arm in arms {\n         for arm_pat: @pat in arm.pats {\n-            let reachable = true;\n-            let j = 0;\n+            let mut reachable = true;\n+            let mut j = 0;\n             while j < i {\n                 if option::is_none(arms[j].guard) {\n                     for prev_pat: @pat in arms[j].pats {\n@@ -121,7 +121,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n         }\n       }\n       ty::ty_bool {\n-        let saw_true = false, saw_false = false;\n+        let mut saw_true = false, saw_false = false;\n         for p in pats {\n             alt raw_pat(p).node {\n               pat_lit(@{node: expr_lit(@{node: lit_bool(b), _}), _}) {\n@@ -192,7 +192,7 @@ fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n \n fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n     fn patterns_supersede(tcx: ty::ctxt, as: [@pat], bs: [@pat]) -> bool {\n-        let i = 0;\n+        let mut i = 0;\n         for a: @pat in as {\n             if !pattern_supersedes(tcx, a, bs[i]) { ret false; }\n             i += 1;\n@@ -203,7 +203,7 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n                                 fbs: [field_pat]) -> bool {\n         let wild = @{id: 0, node: pat_wild, span: dummy_sp()};\n         for fa: field_pat in fas {\n-            let pb = wild;\n+            let mut pb = wild;\n             for fb: field_pat in fbs {\n                 if fa.ident == fb.ident { pb = fb.pat; }\n             }"}, {"sha": "ad0f053884a6ee7b4cd528f52b1dfdb6b159663f", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -49,11 +49,11 @@ fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n                 visit::visit_expr(expr, depth + 1, v);\n               }\n               ast::expr_path(path) {\n-                  let i = 0;\n+                  let mut i = 0;\n                   alt def_map.find(expr.id) {\n                     none { fail (\"Not found: \" + path_to_str(path)) }\n                     some(df) {\n-                      let def = df;\n+                      let mut def = df;\n                       while i < depth {\n                         alt copy def {\n                           ast::def_upvar(_, inner, _) { def = *inner; }"}, {"sha": "66638089651cbd5cf55a04131620250e9a2e8b55", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -173,7 +173,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         for a in args { alt a { some(ex) { maybe_copy(cx, ex); } _ {} } }\n       }\n       expr_call(f, args, _) {\n-        let i = 0u;\n+        let mut i = 0u;\n         for arg_t in ty::ty_fn_args(ty::expr_ty(cx.tcx, f)) {\n             alt ty::arg_mode(cx.tcx, arg_t) {\n               by_copy { maybe_copy(cx, args[i]); }"}, {"sha": "36a8047cdfb3eb447b4a38b43872d61a1c92c7da", "filename": "src/rustc/middle/last_use.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -108,7 +108,8 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_alt(input, arms, _) {\n         v.visit_expr(input, cx, v);\n-        let before = cx.current, sets = [];\n+        let before = cx.current;\n+        let mut sets = [];\n         for arm in arms {\n             cx.current = before;\n             v.visit_arm(arm, cx, v);\n@@ -118,7 +119,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_if(cond, then, els) {\n         v.visit_expr(cond, cx, v);\n-        let cur = cx.current;\n+        let mut cur = cx.current;\n         visit::visit_block(then, cx, v);\n         cx.current <-> cur;\n         visit::visit_expr_opt(els, cx, v);\n@@ -164,7 +165,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n       }\n       expr_call(f, args, _) {\n         v.visit_expr(f, cx, v);\n-        let fns = [];\n+        let mut fns = [];\n         let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n         vec::iter2(args, arg_ts) {|arg, arg_t|\n             alt arg.node {\n@@ -204,7 +205,7 @@ fn visit_stmt(s: @stmt, cx: ctx, v: visit::vt<ctx>) {\n       stmt_decl(@{node: decl_local(ls), _}, _) {\n         shadow_in_current(cx, {|id|\n             for local in ls {\n-                let found = false;\n+                let mut found = false;\n                 pat_util::pat_bindings(cx.tcx.def_map, local.node.pat,\n                                        {|pid, _a, _b|\n                     if pid == id { found = true; }\n@@ -247,7 +248,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n           }\n           _ {}\n         }\n-        let old_cur = [], old_blocks = nil;\n+        let mut old_cur = [], old_blocks = nil;\n         cx.blocks <-> old_blocks;\n         cx.current <-> old_cur;\n         visit::visit_fn(fk, decl, body, sp, id, cx, v);\n@@ -272,7 +273,7 @@ fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n }\n \n fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n-    let cur = cx.blocks;\n+    let mut cur = cx.blocks;\n     while cur != nil {\n         alt cur {\n           cons(b, tail) {\n@@ -293,12 +294,13 @@ fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n }\n \n fn join_branches(branches: [set]) -> set {\n-    let found: set = [], i = 0u, l = vec::len(branches);\n+    let mut found: set = [], i = 0u;\n+    let l = vec::len(branches);\n     for set in branches {\n         i += 1u;\n         for {def, uses} in set {\n             if !vec::any(found, {|v| v.def == def}) {\n-                let j = i, nne = uses;\n+                let mut j = i, nne = uses;\n                 while j < l {\n                     for {def: d2, uses} in branches[j] {\n                         if d2 == def {\n@@ -331,7 +333,7 @@ fn leave_fn(cx: ctx) {\n }\n \n fn shadow_in_current(cx: ctx, p: fn(node_id) -> bool) {\n-    let out = [];\n+    let mut out = [];\n     cx.current <-> out;\n     for e in out { if !p(e.def) { cx.current += [e]; } }\n }"}, {"sha": "d0bb83e25e677d49c1d4beb98914c75526bdc0e5", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -66,7 +66,7 @@ fn merge_opts(attrs: [ast::attribute], cmd_opts: [(option, bool)]) ->\n         ret false;\n     }\n \n-    let result = cmd_opts;\n+    let mut result = cmd_opts;\n \n     let lint_metas =\n         attr::attr_metas(attr::find_attrs_by_name(attrs, \"lint\"));"}, {"sha": "b6fa6d1fffbf8d19158523c11c761638dff00446", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -15,7 +15,7 @@ type deref = @{mutbl: bool, kind: deref_t, outer_t: ty::t};\n fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n    {ex: @expr, ds: @[deref]} {\n     fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n-        let ds = [], t = t;\n+        let mut ds = [], t = t;\n         loop {\n             alt ty::get(t).struct {\n               ty::ty_box(mt) | ty::ty_uniq(mt) | ty::ty_rptr(_, mt) {\n@@ -42,12 +42,12 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n         }\n         ret {t: t, ds: ds};\n     }\n-    let ds: [deref] = [], ex = ex;\n+    let mut ds: [deref] = [], ex = ex;\n     loop {\n         alt copy ex.node {\n           expr_field(base, ident, _) {\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n-            let is_mutbl = false;\n+            let mut is_mutbl = false;\n             alt ty::get(auto_unbox.t).struct {\n               ty::ty_rec(fields) {\n                 for fld: ty::field in fields {\n@@ -83,7 +83,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n           expr_unary(op, base) {\n             if op == deref {\n                 let base_t = ty::expr_ty(tcx, base);\n-                let is_mutbl = false, ptr = false;\n+                let mut is_mutbl = false, ptr = false;\n                 alt ty::get(base_t).struct {\n                   ty::ty_box(mt) { is_mutbl = mt.mutbl == m_mutbl; }\n                   ty::ty_uniq(mt) { is_mutbl = mt.mutbl == m_mutbl; }\n@@ -236,7 +236,7 @@ fn check_move_rhs(cx: @ctx, src: @expr) {\n \n fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n-    let i = 0u;\n+    let mut i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         alt ty::resolved_mode(cx.tcx, arg_t.mode) {\n           by_mutbl_ref { check_lval(cx, args[i], msg_mutbl_ref); }\n@@ -249,7 +249,7 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n \n fn check_bind(cx: @ctx, f: @expr, args: [option<@expr>]) {\n     let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n-    let i = 0u;\n+    let mut i = 0u;\n     for arg in args {\n         alt arg {\n           some(expr) {"}, {"sha": "037b00d95f5abf5b26a17cb4efa8b326558f0352", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -63,7 +63,7 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n }\n \n fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> [node_id] {\n-    let found = [];\n+    let mut found = [];\n     pat_bindings(dm, pat) {|b_id, _sp, _pt| found += [b_id]; };\n     ret found;\n }"}, {"sha": "a6806b642e82106fcd1a44c29f224a6c45067e9f", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -88,7 +88,7 @@ fn region_to_scope(region_map: @region_map, region: ty::region)\n // `superscope` and false otherwise.\n fn scope_contains(region_map: @region_map, superscope: ast::node_id,\n                   subscope: ast::node_id) -> bool {\n-    let subscope = subscope;\n+    let mut subscope = subscope;\n     while superscope != subscope {\n         alt region_map.parents.find(subscope) {\n             none { ret false; }\n@@ -140,7 +140,7 @@ fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n                     // If at item scope, introduce or reuse a binding. If at\n                     // block scope, require that the binding be introduced.\n                     let bindings = cx.bindings;\n-                    let region;\n+                    let mut region;\n                     alt list::find(*bindings, {|b| ident == b.name}) {\n                         some(binding) { region = ty::re_named(binding.id); }\n                         none {\n@@ -301,7 +301,7 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let parent;\n+    let mut parent;\n     let mut self_binding = cx.self_binding;\n     alt item.node {\n         ast::item_fn(_, _, _) | ast::item_enum(_, _) {"}, {"sha": "5afebaa699f688dd40fc75852e64bd78a5ff944e", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -251,7 +251,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n     }\n \n     fn path_from_scope(sc: scopes, n: str) -> str {\n-        let path = n + \"::\";\n+        let mut path = n + \"::\";\n         list::iter(sc) {|s|\n             alt s {\n               scope_item(i) { path = i.ident + \"::\" + path; }\n@@ -439,7 +439,8 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         }\n     }\n     fn walk_tps(e: @env, tps: [ast::ty_param], sc: scopes, v: vt<scopes>) {\n-        let outer_current_tp = e.current_tp, current = 0u;\n+        let outer_current_tp = e.current_tp;\n+        let mut current = 0u;\n         for tp in tps {\n             e.current_tp = some(current);\n             for bound in *tp.bounds {\n@@ -653,8 +654,8 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n    option<def> {\n     let path_len = vec::len(path);\n-    let dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n-    let i = 1u;\n+    let mut dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n+    let mut i = 1u;\n     loop {\n        alt dcur {\n           some(dcur_def) {\n@@ -711,7 +712,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     // resolution of this import.\n     fn find_imports_after(e: env, id: node_id, sc: scopes) -> [node_id] {\n         fn lst(my_id: node_id, vis: [@view_item]) -> [node_id] {\n-            let imports = [], found = false;\n+            let mut imports = [], found = false;\n             for vi in vis {\n                 iter_effective_import_paths(*vi) {|vp|\n                     alt vp.node {\n@@ -753,7 +754,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     // This function has cleanup code at the end. Do not return without going\n     // through that.\n     e.imports.insert(defid.node, resolving(sp));\n-    let ignored = find_imports_after(e, defid.node, sc);\n+    let mut ignored = find_imports_after(e, defid.node, sc);\n     e.ignored_imports <-> ignored;\n     let n_idents = vec::len(ids);\n     let end_id = ids[n_idents - 1u];\n@@ -766,10 +767,10 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n             unresolved_err(e, in_scope(sc), sp, ids[0], ns_name(ns_module));\n           }\n           some(dcur_) {\n-            let dcur = dcur_, i = 1u;\n+            let mut dcur = dcur_, i = 1u;\n             loop {\n                 if i == n_idents - 1u {\n-                    let impls = [];\n+                    let mut impls = [];\n                     find_impls_in_mod(e, dcur, impls, some(end_id));\n                     register(e, defid.node, in_mod(dcur), sp, name, {|ns|\n                         lookup_in_mod(e, dcur, sp, end_id, ns, outside)\n@@ -817,7 +818,7 @@ enum ctxt { in_mod(def), in_scope(scopes), }\n \n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option<scope> {\n-        let sc = sc;\n+        let mut sc = sc;\n         loop {\n             alt sc {\n               cons(cur, rest) {\n@@ -834,7 +835,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             }\n         };\n     }\n-    let path = name;\n+    let mut path = name;\n     alt cx {\n       in_scope(sc) {\n         alt find_fn_or_mod_scope(sc) {\n@@ -884,8 +885,8 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n     alt dcur_ {\n       none { ret none; }\n       some(dcur__) {\n-         let i = 1u;\n-         let dcur = dcur__;\n+         let mut i = 1u;\n+         let mut dcur = dcur__;\n          while i < n_idents {\n             let curns = if n_idents == i + 1u { ns } else { ns_module };\n             alt lookup_in_mod_strict(e, dcur, sp, pth.idents[i],\n@@ -1059,18 +1060,18 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n         }\n         ret none;\n     }\n-    let left_fn = false;\n-    let closing = [];\n+    let mut left_fn = false;\n+    let mut closing = [];\n     // Used to determine whether self is in scope\n-    let left_fn_level2 = false;\n-    let sc = sc;\n+    let mut left_fn_level2 = false;\n+    let mut sc = sc;\n     loop {\n         alt copy sc {\n           nil { ret none; }\n           cons(hd, tl) {\n               alt in_scope(e, sp, name, hd, ns) {\n                some(df_) {\n-                 let df = df_;\n+                 let mut df = df_;\n                  let local = def_is_local(df), self_scope = def_is_self(df);\n                  if check_capture &&\n                      (left_fn && local || left_fn_level2 && self_scope\n@@ -1082,7 +1083,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n                      };\n                      e.sess.span_fatal(sp, msg);\n                 } else if local || self_scope {\n-                    let i = vec::len(closing);\n+                    let mut i = vec::len(closing);\n                     while i > 0u {\n                         i -= 1u;\n                         #debug[\"name=%s df=%?\", name, df];\n@@ -1112,7 +1113,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n \n fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n     -> option<def> {\n-    let n = 0u;\n+    let mut n = 0u;\n     for tp: ast::ty_param in ty_params {\n         if str::eq(tp.ident, name) && alt e.current_tp {\n             some(cur) { n < cur } none { true }\n@@ -1123,7 +1124,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n }\n \n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<node_id> {\n-    let found = none;\n+    let mut found = none;\n \n     pat_util::pat_bindings(e.def_map, pat) {|p_id, _sp, n|\n         if str::eq(path_to_ident(n), name)\n@@ -1176,7 +1177,7 @@ fn lookup_in_class(parent_id: def_id,\n fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                    loc_pos: uint, ns: namespace) -> option<def> {\n \n-    let i = vec::len(b.stmts);\n+    let mut i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n         let st = b.stmts[i];\n@@ -1185,7 +1186,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n             alt d.node {\n               ast::decl_local(locs) {\n                 if i <= pos {\n-                    let j = vec::len(locs);\n+                    let mut j = vec::len(locs);\n                     while j > 0u {\n                         j -= 1u;\n                         let loc = locs[j];\n@@ -1240,7 +1241,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n     }\n     for vi in b.view_items {\n \n-        let is_import = false;\n+        let mut is_import = false;\n         alt vi.node {\n           ast::view_item_import(_) { is_import = true; }\n           _ {}\n@@ -1344,7 +1345,7 @@ fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n         // examining a module in an external crate\n         let cached = e.ext_cache.find({did: defid, ident: name, ns: ns});\n         if !is_none(cached) { ret cached; }\n-        let path = [name];\n+        let mut path = [name];\n         if defid.node != ast::crate_node_id {\n             path = cstore::get_path(e.cstore, defid) + path;\n         }\n@@ -1430,7 +1431,7 @@ fn is_exported(e: env, i: ident, m: @indexed_mod) -> bool {\n // `f` returns `none` for every element, `list_search` returns `none`.\n fn list_search<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n         -> option<U> {\n-    let ls = ls;\n+    let mut ls = ls;\n     loop {\n         alt ls {\n           cons(hd, tl) {\n@@ -1624,7 +1625,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n           }\n           ast::item_enum(variants, _) {\n             add_to_index(index, it.ident, mie_item(it));\n-            let variant_idx: uint = 0u;\n+            let mut variant_idx: uint = 0u;\n             for v: ast::variant in variants {\n                 add_to_index(index, v.node.name,\n                              mie_enum_variant(variant_idx, variants,\n@@ -1716,10 +1717,10 @@ fn check_for_collisions(e: @env, c: ast::crate) {\n }\n \n fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n-    let saw_mod = false;\n-    let saw_type = false;\n-    let saw_value = false;\n-    let entries = entries;\n+    let mut saw_mod = false;\n+    let mut saw_type = false;\n+    let mut saw_value = false;\n+    let mut entries = entries;\n     fn dup(e: env, sp: span, word: str, name: ident) {\n         e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n@@ -1761,7 +1762,7 @@ fn mie_span(mie: mod_index_entry) -> span {\n \n fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     fn typaram_names(tps: [ast::ty_param]) -> [ident] {\n-        let x: [ast::ident] = [];\n+        let mut x: [ast::ident] = [];\n         for tp: ast::ty_param in tps { x += [tp.ident]; }\n         ret x;\n     }\n@@ -1791,7 +1792,7 @@ fn check_arm(e: @env, a: ast::arm, &&x: (), v: vt<()>) {\n     let ch0 = checker(*e, \"binding\");\n     check_pat(e, ch0, a.pats[0]);\n     let seen0 = ch0.seen;\n-    let i = vec::len(a.pats);\n+    let mut i = vec::len(a.pats);\n     while i > 1u {\n         i -= 1u;\n         let ch = checker(*e, \"binding\");\n@@ -1992,7 +1993,7 @@ fn check_exports(e: @env) {\n \n     fn check_export(e: @env, ident: str, _mod: @indexed_mod,\n                     export_id: node_id, vi: @view_item) {\n-        let found_something = false;\n+        let mut found_something = false;\n         if _mod.index.contains_key(ident) {\n             found_something = true;\n             let xs = _mod.index.get(ident);\n@@ -2051,7 +2052,7 @@ fn check_exports(e: @env) {\n         let parent_id = check_enum_ok(e, span, id, _mod);\n         add_export(e, export_id, local_def(parent_id), false);\n         for variant_id in ids {\n-            let found = false;\n+            let mut found = false;\n             alt _mod.index.find(variant_id.node.name) {\n               some(ms) {\n                 list::iter(ms) {|m|\n@@ -2158,7 +2159,7 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n     iter_effective_import_paths(*vi) { |vp|\n         alt vp.node {\n           ast::view_path_simple(name, pt, id) {\n-            let found = [];\n+            let mut found = [];\n             if vec::len(*pt) == 1u {\n                 option::may(sc) {|sc|\n                     list::iter(sc) {|level|\n@@ -2223,14 +2224,14 @@ fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n \n fn find_impls_in_mod_by_id(e: env, defid: def_id, &impls: [@_impl],\n                            name: option<ident>) {\n-    let cached;\n+    let mut cached;\n     alt e.impl_cache.find(defid) {\n       some(some(v)) { cached = v; }\n       some(none) { ret; }\n       none {\n         e.impl_cache.insert(defid, none);\n         cached = if defid.crate == ast::local_crate {\n-            let tmp = [];\n+            let mut tmp = [];\n             let mi = e.mod_map.get(defid.node);\n             let md = option::get(mi.m);\n             for vi in md.view_items {\n@@ -2268,7 +2269,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n \n fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n                                v: vt<iscopes>) {\n-    let impls = [];\n+    let mut impls = [];\n     for vi in b.node.view_items {\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n@@ -2286,7 +2287,7 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n \n fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n                              sc: iscopes, v: vt<iscopes>) {\n-    let impls = [];\n+    let mut impls = [];\n     for vi in m.view_items {\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }"}, {"sha": "818fda7c60f595452e20dee9542ccad3e0f0acb7", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -40,7 +40,8 @@ enum opt_result {\n     range_result(result, result),\n }\n fn trans_opt(bcx: block, o: opt) -> opt_result {\n-    let ccx = bcx.ccx(), bcx = bcx;\n+    let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n     alt o {\n       lit(l) {\n         alt l.node {\n@@ -101,7 +102,7 @@ fn has_nested_bindings(m: match, col: uint) -> bool {\n }\n \n fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n-    let result = [];\n+    let mut result = [];\n     for br in m {\n       alt br.pats[col].node {\n           ast::pat_ident(name, some(inner)) {\n@@ -122,7 +123,7 @@ type enter_pat = fn(@ast::pat) -> option<[@ast::pat]>;\n \n fn enter_match(dm: def_map, m: match, col: uint, val: ValueRef,\n                e: enter_pat) -> match {\n-    let result = [];\n+    let mut result = [];\n     for br: match_branch in m {\n         alt e(br.pats[col]) {\n           some(sub) {\n@@ -185,9 +186,9 @@ fn enter_rec(dm: def_map, m: match, col: uint, fields: [ast::ident],\n     enter_match(dm, m, col, val) {|p|\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n-            let pats = [];\n+            let mut pats = [];\n             for fname: ast::ident in fields {\n-                let pat = dummy;\n+                let mut pat = dummy;\n                 for fpat: ast::field_pat in fpats {\n                     if str::eq(fpat.ident, fname) { pat = fpat.pat; break; }\n                 }\n@@ -237,7 +238,7 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n         set += [val];\n     }\n \n-    let found = [];\n+    let mut found = [];\n     for br in m {\n         let cur = br.pats[col];\n         if pat_is_variant(ccx.tcx.def_map, cur) {\n@@ -258,21 +259,22 @@ fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n                         vdefs: {enm: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: block} {\n-    let ccx = bcx.fcx.ccx, bcx = bcx;\n+    let ccx = bcx.fcx.ccx;\n+    let mut bcx = bcx;\n     let enum_ty_substs = alt check ty::get(node_id_type(bcx, pat_id)).struct {\n       ty::ty_enum(id, tps) { assert id == vdefs.enm; tps }\n     };\n-    let blobptr = val;\n+    let mut blobptr = val;\n     let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n-    let args = [];\n+    let mut args = [];\n     let size = ty::enum_variant_with_id(ccx.tcx, vdefs.enm,\n                                         vdefs.var).args.len();\n     if size > 0u && (*variants).len() != 1u {\n         let enumptr =\n             PointerCast(bcx, val, T_opaque_enum_ptr(ccx));\n         blobptr = GEPi(bcx, enumptr, [0, 1]);\n     }\n-    let i = 0u;\n+    let mut i = 0u;\n     let vdefs_tg = vdefs.enm;\n     let vdefs_var = vdefs.var;\n     while i < size {\n@@ -286,7 +288,7 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n }\n \n fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n-    let fields = [];\n+    let mut fields = [];\n     for br: match_branch in m {\n         alt br.pats[col].node {\n           ast::pat_rec(fs, _) {\n@@ -336,12 +338,12 @@ fn pick_col(m: match) -> uint {\n     }\n     let scores = vec::to_mut(vec::from_elem(m[0].pats.len(), 0u));\n     for br: match_branch in m {\n-        let i = 0u;\n+        let mut i = 0u;\n         for p: @ast::pat in br.pats { scores[i] += score(p); i += 1u; }\n     }\n-    let max_score = 0u;\n-    let best_col = 0u;\n-    let i = 0u;\n+    let mut max_score = 0u;\n+    let mut best_col = 0u;\n+    let mut i = 0u;\n     for score: uint in scores {\n         // Irrefutable columns always go first, they'd only be duplicated in\n         // the branches.\n@@ -356,7 +358,8 @@ fn pick_col(m: match) -> uint {\n \n fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n                     chk: option<mk_fail>, &exits: [exit_node]) {\n-    let bcx = bcx, tcx = bcx.tcx(), dm = tcx.def_map;\n+    let mut bcx = bcx;\n+    let tcx = bcx.tcx(), dm = tcx.def_map;\n     if m.len() == 0u { Br(bcx, option::get(chk)()); ret; }\n     if m[0].pats.len() == 0u {\n         let data = m[0].data;\n@@ -394,7 +397,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     let vals_left = vec::slice(vals, 0u, col) +\n         vec::slice(vals, col + 1u, vals.len());\n     let ccx = bcx.fcx.ccx;\n-    let pat_id = 0;\n+    let mut pat_id = 0;\n     for br: match_branch in m {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n@@ -405,7 +408,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     // Separate path for extracting and binding record fields\n     if rec_fields.len() > 0u {\n         let fields = ty::get_fields(node_id_type(bcx, pat_id));\n-        let rec_vals = [];\n+        let mut rec_vals = [];\n         for field_name: ast::ident in rec_fields {\n             let ix = option::get(ty::field_idx(field_name, fields));\n             rec_vals += [GEPi(bcx, val, [0, ix as int])];\n@@ -421,7 +424,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n           ty::ty_tup(elts) { elts.len() }\n           _ { ccx.sess.bug(\"non-tuple type in tuple pattern\"); }\n         };\n-        let tup_vals = [], i = 0u;\n+        let mut tup_vals = [], i = 0u;\n         while i < n_tup_elts {\n             tup_vals += [GEPi(bcx, val, [0, i as int])];\n             i += 1u;\n@@ -450,8 +453,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     // Decide what kind of branch we need\n     let opts = get_options(ccx, m, col);\n     enum branch_kind { no_branch, single, switch, compare, }\n-    let kind = no_branch;\n-    let test_val = val;\n+    let mut kind = no_branch;\n+    let mut test_val = val;\n     if opts.len() > 0u {\n         alt opts[0] {\n           var(_, vdef) {\n@@ -493,11 +496,12 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n \n     let defaults = enter_default(dm, m, col, val);\n     let exhaustive = option::is_none(chk) && defaults.len() == 0u;\n-    let len = opts.len(), i = 0u;\n+    let len = opts.len();\n+    let mut i = 0u;\n     // Compile subtrees for each option\n     for opt in opts {\n         i += 1u;\n-        let opt_cx = else_cx;\n+        let mut opt_cx = else_cx;\n         if !exhaustive || i < len {\n             opt_cx = sub_block(bcx, \"match_case\");\n             alt kind {\n@@ -533,8 +537,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n               _ { }\n             }\n         } else if kind == compare { Br(bcx, else_cx.llbb); }\n-        let size = 0u;\n-        let unpacked = [];\n+        let mut size = 0u;\n+        let mut unpacked = [];\n         alt opt {\n           var(_, vdef) {\n             let args = extract_variant_args(opt_cx, pat_id, vdef, val);\n@@ -561,10 +565,10 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n fn make_phi_bindings(bcx: block, map: [exit_node],\n                      ids: pat_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n-    let success = true, bcx = bcx;\n+    let mut success = true, bcx = bcx;\n     ids.items {|name, node_id|\n-        let llbbs = [];\n-        let vals = [];\n+        let mut llbbs = [];\n+        let mut vals = [];\n         for ex: exit_node in map {\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n@@ -613,7 +617,7 @@ fn trans_alt(bcx: block, expr: @ast::expr, arms: [ast::arm],\n fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n                    mode: ast::alt_mode, dest: dest) -> block {\n     let bcx = scope_cx, tcx = bcx.tcx();\n-    let bodies = [], match = [];\n+    let mut bodies = [], match = [];\n \n     let {bcx, val, _} = trans_temp_expr(bcx, expr);\n     if bcx.unreachable { ret bcx; }\n@@ -647,19 +651,19 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n       }\n       ast::alt_exhaustive { none }\n     };\n-    let exit_map = [];\n+    let mut exit_map = [];\n     let t = node_id_type(bcx, expr.id);\n     let {bcx, val: spilled} = spill_if_immediate(bcx, val, t);\n     compile_submatch(bcx, match, [spilled], mk_fail, exit_map);\n \n-    let arm_cxs = [], arm_dests = [], i = 0u;\n+    let mut arm_cxs = [], arm_dests = [], i = 0u;\n     for a in arms {\n         let body_cx = bodies[i];\n         let id_map = pat_util::pat_id_map(tcx.def_map, a.pats[0]);\n         if make_phi_bindings(body_cx, exit_map, id_map) {\n             let arm_dest = dup_for_join(dest);\n             arm_dests += [arm_dest];\n-            let arm_cx = trans_block(body_cx, a.body, arm_dest);\n+            let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n             arm_cx = trans_block_cleanups(arm_cx, body_cx);\n             arm_cxs += [arm_cx];\n         }\n@@ -671,7 +675,8 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> block {\n-    let ccx = bcx.fcx.ccx, bcx = bcx;\n+    let ccx = bcx.fcx.ccx;\n+    let mut bcx = bcx;\n \n     // Necessary since bind_irrefutable_pat is called outside trans_alt\n     alt pat.node {\n@@ -694,7 +699,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n       ast::pat_enum(_, sub) {\n         let vdefs = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat.id));\n         let args = extract_variant_args(bcx, pat.id, vdefs, val);\n-        let i = 0;\n+        let mut i = 0;\n         for argval: ValueRef in args.vals {\n             bcx = bind_irrefutable_pat(bcx, sub[i], argval, make_copy);\n             i += 1;\n@@ -710,7 +715,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_tup(elems) {\n-        let i = 0u;\n+        let mut i = 0u;\n         for elem in elems {\n             let fldptr = GEPi(bcx, val, [0, i as int]);\n             bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);"}, {"sha": "b63e42bf7a454eb3382e27520eb556ec5add9f52", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 154, "deletions": 140, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -83,7 +83,7 @@ fn dup_for_join(dest: dest) -> dest {\n fn join_returns(parent_cx: block, in_cxs: [block],\n                 in_ds: [dest], out_dest: dest) -> block {\n     let out = sub_block(parent_cx, \"join\");\n-    let reachable = false, i = 0u, phi = none;\n+    let mut reachable = false, i = 0u, phi = none;\n     for cx in in_cxs {\n         if !cx.unreachable {\n             Br(cx, out.llbb);\n@@ -192,7 +192,7 @@ fn trans_native_call(cx: block, externs: hashmap<str, ValueRef>,\n     let n = args.len() as int;\n     let llnative: ValueRef =\n         get_simple_extern_fn(cx, externs, llmod, name, n);\n-    let call_args: [ValueRef] = [];\n+    let mut call_args: [ValueRef] = [];\n     for a: ValueRef in args {\n         call_args += [ZExtOrBitCast(cx, a, cx.ccx().int_type)];\n     }\n@@ -288,7 +288,8 @@ fn opaque_box_body(bcx: block,\n // header.\n fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n                           &static_ti: option<@tydesc_info>) -> result {\n-    let bcx = bcx, ccx = bcx.ccx();\n+    let mut bcx = bcx;\n+    let ccx = bcx.ccx();\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n@@ -308,7 +309,7 @@ fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n // initializes the reference count to 1, and pulls out the body and rc\n fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n    {bcx: block, box: ValueRef, body: ValueRef} {\n-    let ti = none;\n+    let mut ti = none;\n     let {bcx, val:box} = trans_malloc_boxed_raw(bcx, t, ti);\n     let body = GEPi(bcx, box, [0, abi::box_field_body]);\n     ret {bcx: bcx, box: box, body: body};\n@@ -317,7 +318,7 @@ fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n // Type descriptor and type glue stuff\n \n fn get_tydesc_simple(bcx: block, t: ty::t) -> result {\n-    let ti = none;\n+    let mut ti = none;\n     get_tydesc(bcx, t, ti)\n }\n \n@@ -396,12 +397,10 @@ fn note_unique_llvm_symbol(ccx: @crate_ctxt, sym: str) {\n // Generates the declaration for (but doesn't emit) a type descriptor.\n fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(ccx.tcx, t));\n-    let llsize;\n-    let llalign;\n     let llty = type_of(ccx, t);\n-    llsize = llsize_of(ccx, llty);\n-    llalign = llalign_of(ccx, llty);\n-    let name;\n+    let llsize = llsize_of(ccx, llty);\n+    let llalign = llalign_of(ccx, llty);\n+    let mut name;\n     //XXX this triggers duplicate LLVM symbols\n     if false /*ccx.sess.opts.debuginfo*/ {\n         name = mangle_internal_name_by_type_only(ccx, t, \"tydesc\");\n@@ -427,7 +426,7 @@ type glue_helper = fn@(block, ValueRef, ty::t);\n fn declare_generic_glue(ccx: @crate_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: str) -> ValueRef {\n     let name = name;\n-    let fn_nm;\n+    let mut fn_nm;\n     //XXX this triggers duplicate LLVM symbols\n     if false /*ccx.sess.opts.debuginfo*/ {\n         fn_nm = mangle_internal_name_by_type_only(ccx, t, \"glue_\" + name);\n@@ -527,7 +526,7 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n }\n \n fn make_take_glue(cx: block, v: ValueRef, t: ty::t) {\n-    let bcx = cx;\n+    let mut bcx = cx;\n     // NB: v is a *pointer* to type t here, not a direct value.\n     bcx = alt ty::get(t).struct {\n       ty::ty_box(_) | ty::ty_opaque_box {\n@@ -567,7 +566,7 @@ fn incr_refcnt_of_boxed(cx: block, box_ptr: ValueRef) -> block {\n     maybe_validate_box(cx, box_ptr);\n     let rc_ptr = GEPi(cx, box_ptr, [0, abi::box_field_refcnt]);\n     let rc = Load(cx, rc_ptr);\n-    rc = Add(cx, rc, C_int(ccx, 1));\n+    let rc = Add(cx, rc, C_int(ccx, 1));\n     Store(cx, rc, rc_ptr);\n     ret cx;\n }\n@@ -819,10 +818,10 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         if variant.args.len() == 0u { ret cx; }\n         let fn_ty = variant.ctor_ty;\n         let ccx = cx.ccx();\n-        let cx = cx;\n+        let mut cx = cx;\n         alt ty::get(fn_ty).struct {\n           ty::ty_fn({inputs: args, _}) {\n-            let j = 0u;\n+            let mut j = 0u;\n             let v_id = variant.id;\n             for a: ty::arg in args {\n                 let rslt = GEP_enum(cx, a_tup, tid, v_id, tps, j);\n@@ -841,18 +840,18 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     /*\n     Typestate constraint that shows the unimpl case doesn't happen?\n     */\n-    let cx = cx;\n+    let mut cx = cx;\n     alt ty::get(t).struct {\n       ty::ty_rec(fields) {\n-        let i: int = 0;\n+        let mut i: int = 0;\n         for fld: ty::field in fields {\n             let llfld_a = GEPi(cx, av, [0, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n             i += 1;\n         }\n       }\n       ty::ty_tup(args) {\n-        let i = 0;\n+        let mut i = 0;\n         for arg in args {\n             let llfld_a = GEPi(cx, av, [0, i]);\n             cx = f(cx, llfld_a, arg);\n@@ -894,15 +893,15 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                                    \"enum-iter-variant-\" +\n                                        int::to_str(variant.disr_val, 10u));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n-            variant_cx =\n+            let variant_cx =\n                 iter_variant(variant_cx, llunion_a_ptr, variant, tps, tid, f);\n             Br(variant_cx, next_cx.llbb);\n         }\n         ret next_cx;\n       }\n       ty::ty_class(did, tps) {\n           // a class is like a record type\n-        let i: int = 0;\n+        let mut i: int = 0;\n         for fld: ty::field in ty::class_items_as_fields(cx.tcx(), did) {\n             let llfld_a = GEPi(cx, av, [0, i]);\n             cx = f(cx, llfld_a, fld.mt.ty);\n@@ -981,7 +980,7 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n     lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n     if cx.unreachable { ret; }\n \n-    let static_glue_fn = none;\n+    let mut static_glue_fn = none;\n     alt static_ti {\n       none {/* no-op */ }\n       some(sti) {\n@@ -996,26 +995,26 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n     }\n \n     let llrawptr = PointerCast(cx, v, T_ptr(T_i8()));\n-    let lltydescs =\n-        GEPi(cx, tydesc, [0, abi::tydesc_field_first_param]);\n-    lltydescs = Load(cx, lltydescs);\n-\n-    let llfn;\n-    alt static_glue_fn {\n-      none {\n-        let llfnptr = GEPi(cx, tydesc, [0, field]);\n-        llfn = Load(cx, llfnptr);\n-      }\n-      some(sgf) { llfn = sgf; }\n-    }\n+    let lltydescs = GEPi(cx, tydesc, [0, abi::tydesc_field_first_param]);\n+    let lltydescs = Load(cx, lltydescs);\n+\n+    let llfn = {\n+        alt static_glue_fn {\n+          none {\n+            let llfnptr = GEPi(cx, tydesc, [0, field]);\n+            Load(cx, llfnptr)\n+          }\n+          some(sgf) { sgf }\n+        }\n+    };\n \n     Call(cx, llfn, [C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n                     lltydescs, llrawptr]);\n }\n \n fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n    block {\n-    let ti: option<@tydesc_info> = none::<@tydesc_info>;\n+    let mut ti: option<@tydesc_info> = none;\n     let {bcx: bcx, val: td} = get_tydesc(cx, t, ti);\n     call_tydesc_glue_full(bcx, v, td, field, ti);\n     ret bcx;\n@@ -1030,19 +1029,18 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n     let r = spill_if_immediate(bcx, lhs, t);\n     let lllhs = r.val;\n-    bcx = r.bcx;\n-    r = spill_if_immediate(bcx, rhs, t);\n+    let bcx = r.bcx;\n+    let r = spill_if_immediate(bcx, rhs, t);\n     let llrhs = r.val;\n-    bcx = r.bcx;\n+    let bcx = r.bcx;\n \n     let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n-    r = get_tydesc_simple(bcx, t);\n+    let r = get_tydesc_simple(bcx, t);\n     let lltydesc = r.val;\n-    bcx = r.bcx;\n-    let lltydescs =\n-        GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]);\n-    lltydescs = Load(bcx, lltydescs);\n+    let bcx = r.bcx;\n+    let lltydescs = GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]);\n+    let lltydescs = Load(bcx, lltydescs);\n \n     let llfn = bcx.ccx().upcalls.cmp_type;\n \n@@ -1161,7 +1159,8 @@ fn copy_val(cx: block, action: copy_action, dst: ValueRef,\n \n fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> block {\n-    let ccx = bcx.ccx(), bcx = bcx;\n+    let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n     if ty::type_is_scalar(t) {\n         Store(bcx, src, dst);\n         ret bcx;\n@@ -1190,8 +1189,9 @@ fn copy_val_no_check(bcx: block, action: copy_action, dst: ValueRef,\n // doesn't need to be dropped.\n fn move_val(cx: block, action: copy_action, dst: ValueRef,\n             src: lval_result, t: ty::t) -> block {\n-    let src_val = src.val;\n-    let tcx = cx.tcx(), cx = cx;\n+    let mut src_val = src.val;\n+    let tcx = cx.tcx();\n+    let mut cx = cx;\n     if ty::type_is_scalar(t) {\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         Store(cx, src_val, dst);\n@@ -1285,7 +1285,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n         ret store_in_dest(bcx, neg, dest);\n       }\n       ast::box(_) {\n-        let {bcx, box, body} = trans_malloc_boxed(bcx, e_ty);\n+        let mut {bcx, box, body} = trans_malloc_boxed(bcx, e_ty);\n         add_clean_free(bcx, box, false);\n         // Cast the body type to the type of the value. This is needed to\n         // make enums work, since enums have a different LLVM type depending\n@@ -1309,7 +1309,7 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n }\n \n fn trans_addr_of(cx: block, e: @ast::expr, dest: dest) -> block {\n-    let {bcx, val, kind} = trans_temp_lval(cx, e);\n+    let mut {bcx, val, kind} = trans_temp_lval(cx, e);\n     let ety = expr_ty(cx, e);\n     let is_immediate = ty::type_is_immediate(ety);\n     if (kind == temporary && is_immediate) || kind == owned_imm {\n@@ -1327,13 +1327,14 @@ fn trans_compare(cx: block, op: ast::binop, lhs: ValueRef,\n     }\n \n     // Determine the operation we need.\n-    let llop;\n-    alt op {\n-      ast::eq | ast::ne { llop = C_u8(abi::cmp_glue_op_eq); }\n-      ast::lt | ast::ge { llop = C_u8(abi::cmp_glue_op_lt); }\n-      ast::le | ast::gt { llop = C_u8(abi::cmp_glue_op_le); }\n-      _ { cx.tcx().sess.bug(\"trans_compare got non-comparison-op\"); }\n-    }\n+    let llop = {\n+        alt op {\n+          ast::eq | ast::ne { C_u8(abi::cmp_glue_op_eq) }\n+          ast::lt | ast::ge { C_u8(abi::cmp_glue_op_lt) }\n+          ast::le | ast::gt { C_u8(abi::cmp_glue_op_le) }\n+          _ { cx.tcx().sess.bug(\"trans_compare got non-comparison-op\"); }\n+        }\n+    };\n \n     let rs = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n \n@@ -1392,16 +1393,19 @@ fn trans_eager_binop(cx: block, op: ast::binop, lhs: ValueRef,\n                      lhs_t: ty::t, rhs: ValueRef, rhs_t: ty::t, dest: dest)\n     -> block {\n     if dest == ignore { ret cx; }\n-    let intype = lhs_t;\n-    if ty::type_is_bot(intype) { intype = rhs_t; }\n+    let intype = {\n+        if ty::type_is_bot(lhs_t) { rhs_t }\n+        else { lhs_t }\n+    };\n     let is_float = ty::type_is_fp(intype);\n \n     let rhs = cast_shift_expr_rhs(cx, op, lhs, rhs);\n \n     if op == ast::add && ty::type_is_sequence(intype) {\n         ret tvec::trans_add(cx, intype, lhs, rhs, dest);\n     }\n-    let cx = cx, val = alt op {\n+    let mut cx = cx;\n+    let val = alt op {\n       ast::add {\n         if is_float { FAdd(cx, lhs, rhs) }\n         else { Add(cx, lhs, rhs) }\n@@ -1487,8 +1491,8 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n }\n \n fn autoderef(cx: block, v: ValueRef, t: ty::t) -> result_t {\n-    let v1: ValueRef = v;\n-    let t1: ty::t = t;\n+    let mut v1: ValueRef = v;\n+    let mut t1: ty::t = t;\n     let ccx = cx.ccx();\n     loop {\n         alt ty::get(t1).struct {\n@@ -1602,7 +1606,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n     option::may(els) {|e| else_cx.block_span = some(e.span); }\n     CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n     let then_bcx = trans_block(then_cx, thn, then_dest);\n-    then_bcx = trans_block_cleanups(then_bcx, then_cx);\n+    let then_bcx = trans_block_cleanups(then_bcx, then_cx);\n     // Calling trans_block directly instead of trans_expr\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n@@ -1623,7 +1627,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n       }\n       _ { else_cx }\n     };\n-    else_bcx = trans_block_cleanups(else_bcx, else_cx);\n+    let else_bcx = trans_block_cleanups(else_bcx, else_cx);\n     ret join_returns(cx, [then_bcx, else_bcx], [then_dest, else_dest], dest);\n }\n \n@@ -1640,7 +1644,7 @@ fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n                                T_ptr(type_of(bcx.ccx(), t)));\n         let bcx = alt::bind_irrefutable_pat(scope_cx, local.node.pat,\n                                                   curr, false);\n-        bcx = trans_block(bcx, body, ignore);\n+        let bcx = trans_block(bcx, body, ignore);\n         cleanup_and_Br(bcx, scope_cx, next_cx.llbb);\n         ret next_cx;\n     }\n@@ -1649,7 +1653,7 @@ fn trans_for(cx: block, local: @ast::local, seq: @ast::expr,\n     let seq_ty = expr_ty(cx, seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n     let seq = PointerCast(bcx, seq, T_ptr(ccx.opaque_vec_type));\n-    let fill = tvec::get_fill(bcx, seq);\n+    let mut fill = tvec::get_fill(bcx, seq);\n     if ty::type_is_str(seq_ty) {\n         fill = Sub(bcx, fill, C_int(ccx, 1));\n     }\n@@ -1777,9 +1781,9 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n     let precise_param_ids = alt vtables {\n       some(vts) {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;\n-        let i = 0u;\n+        let mut i = 0u;\n         vec::map2(*bounds, substs, {|bounds, subst|\n-            let v = [];\n+            let mut v = [];\n             for bound in *bounds {\n                 alt bound {\n                   ty::bound_iface(_) {\n@@ -1848,7 +1852,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n     }\n \n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n-    let item_ty = tpt.ty;\n+    let mut item_ty = tpt.ty;\n \n     let map_node = ccx.tcx.items.get(fn_id.node);\n     // Get the path so that we can create a symbol\n@@ -1949,7 +1953,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n           }\n           csearch::found_parent(parent_id, ast::ii_item(item)) {\n             ccx.external.insert(parent_id, some(item.id));\n-            let my_id = 0;\n+            let mut my_id = 0;\n             alt check item.node {\n               ast::item_enum(_, _) {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n@@ -1995,9 +1999,11 @@ fn lval_intrinsic_fn(bcx: block, val: ValueRef, tys: [ty::t],\n              vec::tailn(args, first_real_arg), out_ty)\n     }\n \n-    let bcx = bcx, ccx = bcx.ccx();\n+    let mut bcx = bcx;\n+    let ccx = bcx.ccx();\n     let tds = vec::map(tys, {|t|\n-        let ti = none, td_res = get_tydesc(bcx, t, ti);\n+        let mut ti = none;\n+        let td_res = get_tydesc(bcx, t, ti);\n         bcx = td_res.bcx;\n         lazily_emit_all_tydesc_glue(ccx, ti);\n         td_res.val\n@@ -2029,8 +2035,8 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n     } else { fn_id };\n \n     if fn_id.crate == ast::local_crate && tys.len() > 0u {\n-        let {val, must_cast, intrinsic} = monomorphic_fn(ccx, fn_id, tys,\n-                                                         vtables);\n+        let mut {val, must_cast, intrinsic} =\n+            monomorphic_fn(ccx, fn_id, tys, vtables);\n         if intrinsic { ret lval_intrinsic_fn(bcx, val, tys, id); }\n         if must_cast {\n             val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n@@ -2039,7 +2045,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         ret {bcx: bcx, val: val, kind: owned, env: null_env, tds: none};\n     }\n \n-    let val = if fn_id.crate == ast::local_crate {\n+    let mut val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n         get_item_val(ccx, fn_id.node)\n     } else {\n@@ -2218,14 +2224,15 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let ccx = cx.ccx();\n \n     // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n-    let ix_val;\n     let ix_size = llsize_of_real(cx.ccx(), val_ty(ix.val));\n     let int_size = llsize_of_real(cx.ccx(), ccx.int_type);\n-    if ix_size < int_size {\n-        ix_val = ZExt(bcx, ix.val, ccx.int_type);\n+    let ix_val = if ix_size < int_size {\n+        ZExt(bcx, ix.val, ccx.int_type)\n     } else if ix_size > int_size {\n-        ix_val = Trunc(bcx, ix.val, ccx.int_type);\n-    } else { ix_val = ix.val; }\n+        Trunc(bcx, ix.val, ccx.int_type)\n+    } else {\n+        ix.val\n+    };\n \n     let unit_ty = node_id_type(cx, ex.id);\n     let llunitty = type_of(ccx, unit_ty);\n@@ -2236,7 +2243,7 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n     let lim = tvec::get_fill(bcx, v);\n     let body = tvec::get_dataptr(bcx, v, type_of(ccx, unit_ty));\n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, lim);\n-    bcx = with_cond(bcx, bounds_check) {|bcx|\n+    let bcx = with_cond(bcx, bounds_check) {|bcx|\n         // fail: bad bounds check.\n         trans_fail(bcx, some(ex.span), \"bounds check\")\n     };\n@@ -2440,8 +2447,8 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     let e_ty = expr_ty(cx, e);\n     let is_bot = ty::type_is_bot(e_ty);\n     let lv = trans_temp_lval(cx, e);\n-    let bcx = lv.bcx;\n-    let val = lv.val;\n+    let mut bcx = lv.bcx;\n+    let mut val = lv.val;\n     let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n     if is_bot {\n         // For values of type _|_, we generate an\n@@ -2450,7 +2457,8 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n         // to have type lldestty (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty);\n     } else if arg_mode == ast::by_ref || arg_mode == ast::by_val {\n-        let copied = false, imm = ty::type_is_immediate(e_ty);\n+        let mut copied = false;\n+        let imm = ty::type_is_immediate(e_ty);\n         if arg_mode == ast::by_ref && lv.kind != owned && imm {\n             val = do_spill_noroot(bcx, val);\n             copied = true;\n@@ -2515,12 +2523,12 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n               dest: dest, generic_intrinsic: bool)\n     -> {bcx: block, args: [ValueRef], retslot: ValueRef} {\n \n-    let temp_cleanups = [];\n+    let mut temp_cleanups = [];\n     let arg_tys = ty::ty_fn_args(fn_ty);\n-    let llargs: [ValueRef] = [];\n+    let mut llargs: [ValueRef] = [];\n \n     let ccx = cx.ccx();\n-    let bcx = cx;\n+    let mut bcx = cx;\n \n     let retty = ty::ty_fn_ret(fn_ty);\n     // Arg 0: Output pointer.\n@@ -2555,7 +2563,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: call_args, fn_ty: ty::t,\n     alt args {\n       arg_exprs(es) {\n         let llarg_tys = type_of_explicit_args(ccx, arg_tys);\n-        let i = 0u;\n+        let mut i = 0u;\n         for e: @ast::expr in es {\n             let r = trans_arg_expr(bcx, arg_tys[i], llarg_tys[i],\n                                    e, temp_cleanups);\n@@ -2594,9 +2602,10 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n     -> block {\n     with_scope(in_cx, \"call\") {|cx|\n         let f_res = get_callee(cx);\n-        let bcx = f_res.bcx, ccx = cx.ccx();\n+        let mut bcx = f_res.bcx;\n+        let ccx = cx.ccx();\n \n-        let faddr = f_res.val;\n+        let mut faddr = f_res.val;\n         let llenv = alt f_res.env {\n           null_env {\n             llvm::LLVMGetUndef(T_opaque_box_ptr(ccx))\n@@ -2622,7 +2631,7 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t, ret_ty: ty::t,\n                        option::is_some(f_res.tds))\n         };\n         bcx = args_res.bcx;\n-        let llargs = args_res.args;\n+        let mut llargs = args_res.args;\n         option::may(f_res.tds) {|vals|\n             llargs = vec::slice(llargs, 0u, first_real_arg) + vals +\n                 vec::tailn(llargs, first_real_arg);\n@@ -2680,7 +2689,7 @@ fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n \n fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n-        let bcx = bcx;\n+        let mut bcx = bcx;\n         loop {\n             alt bcx.kind {\n               block_scope(info) {\n@@ -2694,7 +2703,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n         }\n     }\n \n-    let cached = none, pad_bcx = bcx; // Guaranteed to be set below\n+    let mut cached = none, pad_bcx = bcx; // Guaranteed to be set below\n     in_lpad_scope_cx(bcx) {|info|\n         // If there is a valid landing pad still around, use it\n         alt info.landing_pad {\n@@ -2740,7 +2749,7 @@ fn get_landing_pad(bcx: block) -> BasicBlockRef {\n }\n \n fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     let addr = alt dest {\n       ignore {\n         for ex in elts { bcx = trans_expr(bcx, ex, ignore); }\n@@ -2749,7 +2758,7 @@ fn trans_tup(bcx: block, elts: [@ast::expr], dest: dest) -> block {\n       save_in(pos) { pos }\n       _ { bcx.tcx().sess.bug(\"trans_tup: weird dest\"); }\n     };\n-    let temp_cleanups = [], i = 0;\n+    let mut temp_cleanups = [], i = 0;\n     for e in elts {\n         let dst = GEPi(bcx, addr, [0, i]);\n         let e_ty = expr_ty(bcx, e);\n@@ -2766,7 +2775,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n              dest: dest) -> block {\n     let t = node_id_type(bcx, id);\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     let addr = alt dest {\n       ignore {\n         for fld in fields {\n@@ -2782,7 +2791,7 @@ fn trans_rec(bcx: block, fields: [ast::field],\n       ty::ty_rec(f) { f }\n       _ { bcx.tcx().sess.bug(\"trans_rec: id doesn't\\\n            have a record type\") } };\n-    let temp_cleanups = [];\n+    let mut temp_cleanups = [];\n     for fld in fields {\n         let ix = option::get(vec::position(ty_fields, {|ft|\n             str::eq(fld.node.ident, ft.ident)\n@@ -2794,7 +2803,8 @@ fn trans_rec(bcx: block, fields: [ast::field],\n     }\n     alt base {\n       some(bexp) {\n-        let {bcx: cx, val: base_val} = trans_temp_expr(bcx, bexp), i = 0;\n+        let {bcx: cx, val: base_val} = trans_temp_expr(bcx, bexp);\n+        let mut i = 0;\n         bcx = cx;\n         // Copy over inherited fields\n         for tf in ty_fields {\n@@ -2831,7 +2841,7 @@ fn trans_expr_save_in(bcx: block, e: @ast::expr, dest: ValueRef)\n // trans_expr_save_in. For intermediates where you don't care about lval-ness,\n // use trans_temp_expr.\n fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     if expr_is_lval(bcx, e) {\n         ret trans_lval(bcx, e);\n     } else {\n@@ -2846,7 +2856,7 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n             ret {bcx: bcx, val: *cell, kind: temporary};\n         } else {\n             let {bcx, val: scratch} = alloc_ty(bcx, ty);\n-            bcx = trans_expr_save_in(bcx, e, scratch);\n+            let bcx = trans_expr_save_in(bcx, e, scratch);\n             add_clean_temp(bcx, scratch, ty);\n             ret {bcx: bcx, val: scratch, kind: temporary};\n         }\n@@ -2856,7 +2866,7 @@ fn trans_temp_lval(bcx: block, e: @ast::expr) -> lval_result {\n // Use only for intermediate values. See trans_expr and trans_expr_save_in for\n // expressions that must 'end up somewhere' (or get ignored).\n fn trans_temp_expr(bcx: block, e: @ast::expr) -> result {\n-    let {bcx, val, kind} = trans_temp_lval(bcx, e);\n+    let mut {bcx, val, kind} = trans_temp_lval(bcx, e);\n     if kind == owned {\n         val = load_if_immediate(bcx, val, expr_ty(bcx, e));\n     }\n@@ -3044,8 +3054,8 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let t = expr_ty(bcx, src);\n         let {bcx: bcx, val: tmp_alloc} = alloc_ty(rhs_res.bcx, t);\n         // Swap through a temporary.\n-        bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n-        bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n+        let bcx = move_val(bcx, INIT, tmp_alloc, lhs_res, t);\n+        let bcx = move_val(bcx, INIT, lhs_res.val, rhs_res, t);\n         ret move_val(bcx, INIT, rhs_res.val, lval_owned(bcx, tmp_alloc), t);\n       }\n       ast::expr_assign_op(op, dst, src) {\n@@ -3099,7 +3109,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n \n fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let lv = trans_lval(bcx, e), ccx = bcx.ccx();\n-    let {bcx, val, kind} = lv;\n+    let mut {bcx, val, kind} = lv;\n     let last_use = kind == owned && ccx.maps.last_uses.contains_key(e.id);\n     let ty = expr_ty(bcx, e);\n     alt dest {\n@@ -3129,7 +3139,7 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n \n fn do_spill(cx: block, v: ValueRef, t: ty::t) -> result {\n     // We have a value but we have to spill it, and root it, to pass by alias.\n-    let bcx = cx;\n+    let mut bcx = cx;\n \n     if ty::type_is_bot(t) {\n         ret rslt(bcx, C_null(T_ptr(T_i8())));\n@@ -3219,7 +3229,7 @@ fn trans_check_expr(bcx: block, e: @ast::expr, s: str) -> block {\n \n fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n                    fail_expr: option<@ast::expr>) -> block {\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     alt fail_expr {\n       some(expr) {\n         let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -3253,19 +3263,20 @@ fn trans_fail(bcx: block, sp_opt: option<span>, fail_str: str) ->\n fn trans_fail_value(bcx: block, sp_opt: option<span>,\n                     V_fail_str: ValueRef) -> block {\n     let ccx = bcx.ccx();\n-    let V_filename;\n-    let V_line;\n-    alt sp_opt {\n+    let {V_filename, V_line} = alt sp_opt {\n       some(sp) {\n         let sess = bcx.sess();\n         let loc = codemap::lookup_char_pos(sess.parse_sess.cm, sp.lo);\n-        V_filename = C_cstr(bcx.ccx(), loc.file.name);\n-        V_line = loc.line as int;\n+        {V_filename: C_cstr(bcx.ccx(), loc.file.name),\n+         V_line: loc.line as int}\n       }\n-      none { V_filename = C_cstr(bcx.ccx(), \"<runtime>\"); V_line = 0; }\n-    }\n+      none {\n+        {V_filename: C_cstr(bcx.ccx(), \"<runtime>\"),\n+         V_line: 0}\n+      }\n+    };\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n-    V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n     let args = [V_str, V_filename, C_int(ccx, V_line)];\n     let bcx = invoke(bcx, bcx.ccx().upcalls._fail, args);\n     Unreachable(bcx);\n@@ -3275,7 +3286,8 @@ fn trans_fail_value(bcx: block, sp_opt: option<span>,\n fn trans_break_cont(bcx: block, to_end: bool)\n     -> block {\n     // Locate closest loop block, outputting cleanup as we go.\n-    let unwind = bcx, target = bcx;\n+    let mut unwind = bcx;\n+    let mut target = bcx;\n     loop {\n         alt unwind.kind {\n           block_scope({is_loop: some({cnt, brk}), _}) {\n@@ -3313,7 +3325,7 @@ fn trans_cont(cx: block) -> block {\n }\n \n fn trans_ret(bcx: block, e: option<@ast::expr>) -> block {\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     alt e {\n       some(x) { bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr); }\n       _ {}\n@@ -3347,7 +3359,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n                         \"init_local: Someone forgot to document why it's\\\n                          safe to assume local.node.init isn't none!\"); }\n             };\n-        let {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n+        let mut {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n         if kind != temporary {\n             if kind == owned { val = Load(bcx, val); }\n             let rs = take_ty_immediate(bcx, val, ty);\n@@ -3359,7 +3371,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n       }\n     };\n \n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     alt local.node.init {\n       some(init) {\n         if init.op == ast::init_assign || !expr_is_lval(bcx, init.expr) {\n@@ -3392,7 +3404,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n         add_span_comment(cx, s.span, stmt_to_str(s));\n     }\n \n-    let bcx = cx;\n+    let mut bcx = cx;\n     debuginfo::update_source_pos(cx, s.span);\n \n     alt s.node {\n@@ -3422,10 +3434,9 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n // next three functions instead.\n fn new_block(cx: fn_ctxt, parent: block_parent, kind: block_kind,\n              name: str, block_span: option<span>) -> block {\n-    let s = \"\";\n-    if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n-        s = cx.ccx.names(name);\n-    }\n+    let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n+        cx.ccx.names(name)\n+    } else { \"\" };\n     let llbb: BasicBlockRef = str::as_c_str(s, {|buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n@@ -3499,7 +3510,7 @@ fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n    block {\n     if bcx.unreachable { ret bcx; }\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     alt check cleanup_cx.kind {\n       block_scope({cleanups, _}) {\n         vec::riter(cleanups) {|cu|\n@@ -3515,7 +3526,7 @@ fn trans_block_cleanups(bcx: block, cleanup_cx: block) ->\n // instruction.\n fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n                      leave: option<BasicBlockRef>) {\n-    let cur = bcx, bcx = bcx;\n+    let mut cur = bcx, bcx = bcx;\n     loop {\n         alt cur.kind {\n           block_scope(info) if info.cleanups.len() > 0u {\n@@ -3644,7 +3655,7 @@ fn alloc_local(cx: block, local: @ast::local) -> block {\n \n fn trans_block(bcx: block, b: ast::blk, dest: dest)\n     -> block {\n-    let bcx = bcx;\n+    let mut bcx = bcx;\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for s: @ast::stmt in b.node.stmts {\n         debuginfo::update_source_pos(bcx, b.span);\n@@ -3727,7 +3738,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n                              ty_self: self_arg,\n                              args: [ast::arg]) {\n     // Skip the implicit arguments 0, and 1.\n-    let arg_n = first_real_arg;\n+    let mut arg_n = first_real_arg;\n     alt ty_self {\n       impl_self(tt) {\n         cx.llself = some({v: cx.llenv, t: tt});\n@@ -3751,7 +3762,7 @@ fn create_llargs_for_fn_args(cx: fn_ctxt,\n fn copy_args_to_allocas(fcx: fn_ctxt, bcx: block, args: [ast::arg],\n                         arg_tys: [ty::arg]) -> block {\n     let tcx = bcx.tcx();\n-    let arg_n: uint = 0u, bcx = bcx;\n+    let mut arg_n: uint = 0u, bcx = bcx;\n     let epic_fail = fn@() -> ! {\n         tcx.sess.bug(\"someone forgot\\\n                 to document an invariant in copy_args_to_allocas!\");\n@@ -3816,7 +3827,8 @@ fn trans_closure(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = top_scope_block(fcx, some(body.span)), bcx = bcx_top;\n+    let bcx_top = top_scope_block(fcx, some(body.span));\n+    let mut bcx = bcx_top;\n     let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.node.id);\n \n@@ -3880,7 +3892,7 @@ fn trans_res_ctor(ccx: @crate_ctxt, path: path, dtor: ast::fn_decl,\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n                                none, param_substs, none);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs);\n-    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n+    let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let fty = node_id_type(bcx, ctor_id);\n     let arg_t = ty::ty_fn_args(fty)[0].ty;\n     let arg = alt fcx.llargs.find(dtor.inputs[0].id) {\n@@ -3905,7 +3917,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n                       param_substs: option<param_substs>,\n                       llfndecl: ValueRef) {\n     // Translate variant arguments to function arguments.\n-    let fn_args = [], i = 0u;\n+    let mut fn_args = [], i = 0u;\n     for varg in variant.node.args {\n         fn_args += [{mode: ast::expl(ast::by_copy),\n                      ty: varg.ty,\n@@ -3919,7 +3931,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n       some(substs) { substs.tys }\n       none { [] }\n     };\n-    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n+    let mut bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n@@ -3933,7 +3945,7 @@ fn trans_enum_variant(ccx: @crate_ctxt, enum_id: ast::node_id,\n         Store(bcx, C_int(ccx, disr), lldiscrimptr);\n         GEPi(bcx, llenumptr, [0, 1])\n     };\n-    let i = 0u;\n+    let mut i = 0u;\n     let t_id = local_def(enum_id);\n     let v_id = local_def(variant.node.id);\n     for va: ast::variant_arg in variant.node.args {\n@@ -4107,7 +4119,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         if tps.len() == 0u {\n             let degen = variants.len() == 1u;\n             let vi = ty::enum_variants(ccx.tcx, local_def(item.id));\n-            let i = 0;\n+            let mut i = 0;\n             for variant: ast::variant in variants {\n                 if variant.node.args.len() > 0u {\n                     let llfn = get_item_val(ccx, variant.node.id);\n@@ -4149,10 +4161,11 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                                        node: ast::ty_infer,\n                                        span: ctor.node.body.span};\n         // kludgy\n-        let ty_args = [], i = 0u;\n+        let mut ty_args = [], i = 0u;\n         for tp in tps {\n             ty_args += [ty::mk_param(ccx.tcx, i,\n                                      local_def(tps[i].id))];\n+            i += 1u;\n         }\n         let rslt_ty =  ty::mk_class(ccx.tcx,\n                                     local_def(item.id),\n@@ -4285,7 +4298,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0 as c_uint);\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 1 as c_uint);\n-        let args = [lloutputarg, llenvarg];\n+        let mut args = [lloutputarg, llenvarg];\n         if takes_argv { args += [llvm::LLVMGetParam(llfdecl, 2 as c_uint)]; }\n         Call(bcx, main_llfn, args);\n         build_return(bcx);\n@@ -4357,7 +4370,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     alt ccx.item_vals.find(id) {\n       some(v) { v }\n       none {\n-        let exprt = false;\n+        let mut exprt = false;\n         let val = alt check ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) {\n             let my_path = *pth + [path_name(i.ident)];\n@@ -4445,7 +4458,8 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_enum(variants, _) {\n         let vi = ty::enum_variants(ccx.tcx, {crate: ast::local_crate,\n                                              node: it.id});\n-        let i = 0, path = item_path(ccx, it);\n+        let mut i = 0;\n+        let path = item_path(ccx, it);\n         for variant in variants {\n             let p = path + [path_name(variant.node.name),\n                             path_name(\"discrim\")];\n@@ -4550,7 +4564,7 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n         llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n-    let elts: [ValueRef] = [];\n+    let mut elts: [ValueRef] = [];\n     ccx.module_data.items {|key, val|\n         let elt = C_struct([p2i(ccx, C_cstr(ccx, key)),\n                             p2i(ccx, val)]);\n@@ -4567,7 +4581,7 @@ fn decl_crate_map(sess: session::session, mapname: str,\n                   llmod: ModuleRef) -> ValueRef {\n     let targ_cfg = sess.targ_cfg;\n     let int_type = T_int(targ_cfg);\n-    let n_subcrates = 1;\n+    let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     let mapname = if sess.building_library { mapname } else { \"toplevel\" };\n@@ -4583,8 +4597,8 @@ fn decl_crate_map(sess: session::session, mapname: str,\n \n // FIXME use hashed metadata instead of crate names once we have that\n fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n-    let subcrates: [ValueRef] = [];\n-    let i = 1;\n+    let mut subcrates: [ValueRef] = [];\n+    let mut i = 1;\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let nm = \"_rust_crate_map_\" + cstore::get_crate_data(cstore, i).name;\n@@ -4604,7 +4618,7 @@ fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n     if !cx.sess.building_library { ret; }\n     let llmeta = C_bytes(metadata::encoder::encode_metadata(cx, crate));\n     let llconst = C_struct([llmeta]);\n-    let llglobal = str::as_c_str(\"rust_metadata\", {|buf|\n+    let mut llglobal = str::as_c_str(\"rust_metadata\", {|buf|\n         llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n     });\n     llvm::LLVMSetInitializer(llglobal, llconst);"}, {"sha": "7c488aa14bda133a793e29e4f0380345c194ef2a", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -338,7 +338,7 @@ fn GEP(cx: block, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n fn GEPi(cx: block, base: ValueRef, ixs: [int]) -> ValueRef {\n-    let v: [ValueRef] = [];\n+    let mut v: [ValueRef] = [];\n     for i: int in ixs { v += [C_i32(i as i32)]; }\n     ret InBoundsGEP(cx, base, v);\n }"}, {"sha": "111f172a8ea3ed23a0cc82585b69c92166d40232", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -123,7 +123,7 @@ fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n fn mk_closure_tys(tcx: ty::ctxt,\n                   bound_values: [environment_value])\n     -> (ty::t, [ty::t]) {\n-    let bound_tys = [];\n+    let mut bound_tys = [];\n \n     // Compute the closed over data\n     for bv in bound_values {\n@@ -169,8 +169,8 @@ fn allocate_cbox(bcx: block,\n     }\n \n     // Allocate and initialize the box:\n-    let ti = none;\n-    let temp_cleanups = [];\n+    let mut ti = none;\n+    let mut temp_cleanups = [];\n     let (bcx, box) = alt ck {\n       ty::ck_box {\n         let {bcx, val: box} = trans_malloc_boxed_raw(bcx, cdata_ty, ti);\n@@ -219,7 +219,7 @@ fn store_environment(bcx: block,\n         mk_closure_tys(tcx, bound_values);\n \n     // allocate closure in the heap\n-    let (bcx, llbox, temp_cleanups) =\n+    let mut (bcx, llbox, temp_cleanups) =\n         allocate_cbox(bcx, ck, cdata_ty);\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -232,6 +232,7 @@ fn store_environment(bcx: block,\n     #debug[\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)];\n \n     // Copy expr values into boxed bindings.\n+    let mut bcx = bcx;\n     vec::iteri(bound_values) { |i, bv|\n         #debug[\"Copy %s into closure\", ev_to_str(ccx, bv)];\n \n@@ -287,15 +288,16 @@ fn build_closure(bcx0: block,\n                  ck: ty::closure_kind,\n                  id: ast::node_id) -> closure_result {\n     // If we need to, package up the iterator body to call\n-    let env_vals = [];\n-    let bcx = bcx0, ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let mut env_vals = [];\n+    let mut bcx = bcx0;\n+    let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // Package up the captured upvars\n     vec::iter(cap_vars) { |cap_var|\n         #debug[\"Building closure: captured variable %?\", cap_var];\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n-        let ty = node_id_type(bcx, nid);\n+        let mut ty = node_id_type(bcx, nid);\n         alt cap_var.mode {\n           capture::cap_ref {\n             assert ck == ty::ck_block;\n@@ -336,12 +338,12 @@ fn load_environment(fcx: fn_ctxt,\n     let llcdata = base::opaque_box_body(bcx, cdata_ty, fcx.llenv);\n \n     // Populate the upvars from the environment.\n-    let i = 0u;\n+    let mut i = 0u;\n     vec::iter(cap_vars) { |cap_var|\n         alt cap_var.mode {\n           capture::cap_drop { /* ignore */ }\n           _ {\n-            let upvarptr =\n+            let mut upvarptr =\n                 GEPi(bcx, llcdata, [0, abi::closure_body_bindings, i as int]);\n             alt ck {\n               ty::ck_block { upvarptr = Load(bcx, upvarptr); }\n@@ -410,11 +412,11 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n                 dest: dest) -> block {\n     assert option::is_none(f_res.tds);\n     let ccx = cx.ccx();\n-    let bound: [@ast::expr] = [];\n+    let mut bound: [@ast::expr] = [];\n     for argopt: option<@ast::expr> in args {\n         alt argopt { none { } some(e) { bound += [e]; } }\n     }\n-    let bcx = f_res.bcx;\n+    let mut bcx = f_res.bcx;\n     if dest == ignore {\n         for ex in bound { bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n@@ -648,7 +650,7 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n     let fcx = new_fn_ctxt(ccx, path, llthunk, none);\n-    let bcx = top_scope_block(fcx, none);\n+    let mut bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n     // Since we might need to construct derived tydescs that depend on\n     // our bound tydescs, we need to load tydescs out of the environment\n@@ -701,18 +703,18 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     let outgoing_args = ty::ty_fn_args(outgoing_fty);\n \n     // Set up the three implicit arguments to the thunk.\n-    let llargs: [ValueRef] = [fcx.llretptr, lltargetenv];\n+    let mut llargs: [ValueRef] = [fcx.llretptr, lltargetenv];\n \n-    let a: uint = first_real_arg; // retptr, env come first\n-    let b: int = starting_idx;\n-    let outgoing_arg_index: uint = 0u;\n+    let mut a: uint = first_real_arg; // retptr, env come first\n+    let mut b: int = starting_idx;\n+    let mut outgoing_arg_index: uint = 0u;\n     for arg: option<@ast::expr> in args {\n         let out_arg = outgoing_args[outgoing_arg_index];\n         alt arg {\n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n-            let val =\n+            let mut val =\n                 GEPi(bcx, llcdata, [0, abi::closure_body_bindings, b]);\n \n             alt ty::resolved_mode(tcx, out_arg.mode) {\n@@ -744,9 +746,8 @@ fn trans_bind_thunk(ccx: @crate_ctxt,\n     // This is necessary because the type of the function that we have\n     // in the closure does not know how many type descriptors the function\n     // needs to take.\n-    let lltargetty =\n-        type_of_fn_from_ty(ccx, outgoing_fty);\n-    lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n+    let lltargetty = type_of_fn_from_ty(ccx, outgoing_fty);\n+    let lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     Call(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);"}, {"sha": "9fcbdec48e94d3953b65f2b96356cf633a35f804", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -254,7 +254,7 @@ fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n // drop glue checks whether it is zero.\n fn revoke_clean(cx: block, val: ValueRef) {\n     in_scope_cx(cx) {|info|\n-        let i = 0u;\n+        let mut i = 0u;\n         for cu in info.cleanups {\n             alt cu {\n               clean_temp(v, _) if v == val {\n@@ -356,7 +356,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef unsafe {\n }\n \n fn in_scope_cx(cx: block, f: fn(scope_info)) {\n-    let cur = cx;\n+    let mut cur = cx;\n     loop {\n         alt cur.kind {\n           block_scope(info) { f(info); ret; }\n@@ -762,8 +762,8 @@ fn C_postr(s: str) -> ValueRef {\n }\n \n fn C_zero_byte_arr(size: uint) -> ValueRef unsafe {\n-    let i = 0u;\n-    let elts: [ValueRef] = [];\n+    let mut i = 0u;\n+    let mut elts: [ValueRef] = [];\n     while i < size { elts += [C_u8(0u)]; i += 1u; }\n     ret llvm::LLVMConstArray(T_i8(), vec::unsafe::to_ptr(elts),\n                              elts.len() as c_uint);\n@@ -809,11 +809,11 @@ enum mono_param_id {\n }\n type mono_id = @{def: ast::def_id, params: [mono_param_id]};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n-    let h = syntax::ast_util::hash_def_id(mi.def);\n+    let mut h = syntax::ast_util::hash_def_id(mi.def);\n     for param in mi.params {\n         h = h * alt param {\n           mono_precise(ty, vts) {\n-            let h = ty::type_id(ty);\n+            let mut h = ty::type_id(ty);\n             option::may(vts) {|vts|\n                 for vt in vts { h += hash_mono_id(vt); }\n             }\n@@ -843,7 +843,7 @@ fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n }\n \n fn path_str(p: path) -> str {\n-    let r = \"\", first = true;\n+    let mut r = \"\", first = true;\n     for e in p {\n         alt e { ast_map::path_name(s) | ast_map::path_mod(s) {\n           if first { first = false; }"}, {"sha": "0896f9000f1ca609c46e2979f69375a388dc82ec", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -235,7 +235,7 @@ fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n \n fn create_block(cx: block) -> @metadata<block_md> {\n     let cache = get_cache(cx.ccx());\n-    let cx = cx;\n+    let mut cx = cx;\n     while option::is_none(cx.block_span) {\n         alt cx.parent {\n           parent_some(b) { cx = b; }"}, {"sha": "45d23fdbfac0cedc9cdbf8b9e6bcba01ff0fab3e", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -31,7 +31,7 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n fn trans_self_arg(bcx: block, base: @ast::expr) -> result {\n     let basety = expr_ty(bcx, base);\n     let m_by_ref = ast::expl(ast::by_ref);\n-    let temp_cleanups = [];\n+    let mut temp_cleanups = [];\n     let result = trans_arg_expr(bcx, {mode: m_by_ref, ty: basety},\n                                 T_ptr(type_of::type_of(bcx.ccx(), basety)),\n                                 base, temp_cleanups);\n@@ -147,7 +147,7 @@ fn trans_iface_callee(bcx: block, base: @ast::expr,\n \n fn find_vtable_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     -> typeck::vtable_origin {\n-    let vtable_off = n_bound, i = 0u;\n+    let mut vtable_off = n_bound, i = 0u;\n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n     for bounds in *ps.bounds {\n@@ -258,7 +258,7 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n-    let {bcx, box, body} = trans_malloc_boxed(bcx, v_ty);\n+    let mut {bcx, box, body} = trans_malloc_boxed(bcx, v_ty);\n     add_clean_free(bcx, box, false);\n     bcx = trans_expr_save_in(bcx, val, body);\n     revoke_clean(bcx, box);"}, {"sha": "bb78a9b95bec48e3f213da8a1037bbcafbf0a319", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -142,7 +142,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n         if vec::is_empty(tys) {\n             classify(T_i64(), cls, i, off);\n         } else {\n-            let field_off = off;\n+            let mut field_off = off;\n             for ty in tys {\n                 field_off = align(field_off, ty);\n                 classify(ty, cls, i, field_off);\n@@ -159,7 +159,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n \n         let misalign = off % t_align;\n         if misalign != 0u {\n-            let i = off / 8u;\n+            let mut i = off / 8u;\n             let e = (off + t_size + 7u) / 8u;\n             while i < e {\n                 unify(cls, i, memory_class);\n@@ -193,7 +193,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n     }\n \n     fn fixup(ty: TypeRef, cls: [mut x86_64_reg_class]) {\n-        let i = 0u;\n+        let mut i = 0u;\n         let e = vec::len(cls);\n         if vec::len(cls) > 2u &&\n            llvm::LLVMGetTypeKind(ty) as int == 10 /* struct */ {\n@@ -250,7 +250,7 @@ fn classify_ty(ty: TypeRef) -> [x86_64_reg_class] {\n \n fn llreg_ty(cls: [x86_64_reg_class]) -> TypeRef {\n     fn llvec_len(cls: [x86_64_reg_class]) -> uint {\n-        let len = 1u;\n+        let mut len = 1u;\n         for c in cls {\n             if c != sseup_class {\n                 break;\n@@ -260,8 +260,8 @@ fn llreg_ty(cls: [x86_64_reg_class]) -> TypeRef {\n         ret len;\n     }\n \n-    let tys = [];\n-    let i = 0u;\n+    let mut tys = [];\n+    let mut i = 0u;\n     let e = vec::len(cls);\n     while i < e {\n         alt cls[i] {\n@@ -329,9 +329,9 @@ fn x86_64_tys(atys: [TypeRef],\n     fn x86_64_ty(ty: TypeRef,\n                  is_mem_cls: fn(cls: [x86_64_reg_class]) -> bool,\n                  attr: Attribute) -> (x86_64_llty, option<Attribute>) {\n-        let cast = false;\n-        let ty_attr = option::none;\n-        let llty = ty;\n+        let mut cast = false;\n+        let mut ty_attr = option::none;\n+        let mut llty = ty;\n         if !is_reg_ty(ty) {\n             let cls = classify_ty(ty);\n             if is_mem_cls(cls) {\n@@ -345,15 +345,15 @@ fn x86_64_tys(atys: [TypeRef],\n         ret ({ cast: cast, ty: llty }, ty_attr);\n     }\n \n-    let arg_tys = [];\n-    let attrs = [];\n+    let mut arg_tys = [];\n+    let mut attrs = [];\n     for t in atys {\n         let (ty, attr) = x86_64_ty(t, is_pass_byval, ByValAttribute);\n         arg_tys += [ty];\n         attrs += [attr];\n     }\n-    let (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n-                                            StructRetAttribute);\n+    let mut (ret_ty, ret_attr) = x86_64_ty(rty, is_ret_bysret,\n+                                       StructRetAttribute);\n     let sret = option::is_some(ret_attr);\n     if sret {\n         arg_tys = [ret_ty] + arg_tys;\n@@ -557,14 +557,14 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> [ValueRef] {\n-            let llargvals = [];\n-            let i = 0u;\n+            let mut llargvals = [];\n+            let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n \n             alt tys.x86_64_tys {\n                 some(x86_64) {\n-                    let atys = x86_64.arg_tys;\n-                    let attrs = x86_64.attrs;\n+                    let mut atys = x86_64.arg_tys;\n+                    let mut attrs = x86_64.attrs;\n                     if x86_64.sret {\n                         let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n                         let llretloc = Load(bcx, llretptr);\n@@ -575,9 +575,9 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                     while i < n {\n                         let llargval = if atys[i].cast {\n                             let arg_ptr = GEPi(bcx, llargbundle,\n-                                                    [0, i as int]);\n-                            arg_ptr = BitCast(bcx, arg_ptr,\n-                                                   T_ptr(atys[i].ty));\n+                                               [0, i as int]);\n+                            let arg_ptr = BitCast(bcx, arg_ptr,\n+                                              T_ptr(atys[i].ty));\n                             Load(bcx, arg_ptr)\n                         } else if option::is_some(attrs[i]) {\n                             GEPi(bcx, llargbundle, [0, i as int])\n@@ -668,7 +668,8 @@ fn trans_native_mod(ccx: @crate_ctxt,\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n-            let i = 0u, n = vec::len(tys.arg_tys);\n+            let mut i = 0u;\n+            let n = vec::len(tys.arg_tys);\n             let implicit_args = first_real_arg; // ret + env\n             while i < n {\n                 let llargval = llvm::LLVMGetParam(\n@@ -691,7 +692,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                        build_args, build_ret);\n     }\n \n-    let cc = lib::llvm::CCallConv;\n+    let mut cc = lib::llvm::CCallConv;\n     alt abi {\n       ast::native_abi_rust_intrinsic {\n         for item in native_mod.items { get_item_val(ccx, item.id); }\n@@ -735,8 +736,8 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n \n         fn build_args(bcx: block, tys: @c_stack_tys,\n                       llargbundle: ValueRef) -> [ValueRef] {\n-            let llargvals = [];\n-            let i = 0u;\n+            let mut llargvals = [];\n+            let mut i = 0u;\n             let n = vec::len(tys.arg_tys);\n             let llretptr = load_inbounds(bcx, llargbundle, [0, n as int]);\n             llargvals += [llretptr];\n@@ -770,9 +771,9 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n             alt tys.x86_64_tys {\n                 option::some(x86_64) {\n-                    let atys = x86_64.arg_tys;\n-                    let attrs = x86_64.attrs;\n-                    let j = 0u;\n+                    let mut atys = x86_64.arg_tys;\n+                    let mut attrs = x86_64.attrs;\n+                    let mut j = 0u;\n                     let llretptr = if x86_64.sret {\n                         atys = vec::tail(atys);\n                         attrs = vec::tail(attrs);\n@@ -785,18 +786,20 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         alloca(bcx, tys.ret_ty)\n                     };\n \n-                    let i = 0u, n = vec::len(atys);\n+                    let mut i = 0u;\n+                    let n = vec::len(atys);\n                     while i < n {\n-                        let argval = llvm::LLVMGetParam(llwrapfn,\n-                                                        (i + j) as c_uint);\n+                        let mut argval =\n+                            llvm::LLVMGetParam(llwrapfn, (i + j) as c_uint);\n                         if option::is_some(attrs[i]) {\n                             argval = Load(bcx, argval);\n                             store_inbounds(bcx, argval, llargbundle,\n                                                         [0, i as int]);\n                         } else if atys[i].cast {\n                             let argptr = GEPi(bcx, llargbundle,\n-                                                   [0, i as int]);\n-                            argptr = BitCast(bcx, argptr, T_ptr(atys[i].ty));\n+                                              [0, i as int]);\n+                            let argptr = BitCast(bcx, argptr,\n+                                                 T_ptr(atys[i].ty));\n                             Store(bcx, argval, argptr);\n                         } else {\n                             store_inbounds(bcx, argval, llargbundle,\n@@ -808,7 +811,8 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                 }\n                 _ {\n                     let llretptr = alloca(bcx, tys.ret_ty);\n-                    let i = 0u, n = vec::len(tys.arg_tys);\n+                    let mut i = 0u;\n+                    let n = vec::len(tys.arg_tys);\n                     while i < n {\n                         let llargval = llvm::LLVMGetParam(llwrapfn,\n                                                           i as c_uint);"}, {"sha": "7c1231e69518dc036a80a87f1af9689f4646bbe5", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -30,7 +30,7 @@ fn find_reachable(crate_mod: _mod, exp_map: resolve::exp_map,\n }\n \n fn traverse_exports(cx: ctx, vis: [@view_item]) -> bool {\n-    let found_export = false;\n+    let mut found_export = false;\n     for vi in vis {\n         alt vi.node {\n           view_item_export(vps) {"}, {"sha": "d13da3b0cfe1fa6985a7f0e46831b18dc7f8bcf2", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -62,7 +62,7 @@ const shape_class: u8 = 30u8;\n const shape_rptr: u8 = 31u8;\n \n fn hash_res_info(ri: res_info) -> uint {\n-    let h = 5381u;\n+    let mut h = 5381u;\n     h *= 33u;\n     h += ri.did.crate as uint;\n     h *= 33u;\n@@ -103,11 +103,11 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // FIXME: We could do better here; e.g. we know that any variant that\n     // contains (T,T) must be as least as large as any variant that contains\n     // just T.\n-    let ranges = [];\n+    let mut ranges = [];\n     let variants = ty::enum_variants(ccx.tcx, tag_id);\n     for variant: ty::variant_info in *variants {\n-        let bounded = true;\n-        let min_size = 0u, min_align = 0u;\n+        let mut bounded = true;\n+        let mut min_size = 0u, min_align = 0u;\n         for elem_t: ty::t in variant.args {\n             if ty::type_has_params(elem_t) {\n                 // FIXME: We could do better here; this causes us to\n@@ -127,16 +127,16 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     }\n \n     // Initialize the candidate set to contain all variants.\n-    let candidates = [mutable];\n+    let mut candidates = [mutable];\n     for variant in *variants { candidates += [mutable true]; }\n \n     // Do a pairwise comparison among all variants still in the candidate set.\n     // Throw out any variant that we know has size and alignment at least as\n     // small as some other variant.\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < vec::len(ranges) - 1u {\n         if candidates[i] {\n-            let j = i + 1u;\n+            let mut j = i + 1u;\n             while j < vec::len(ranges) {\n                 if candidates[j] {\n                     if ranges[i].size.bounded && ranges[i].align.bounded &&\n@@ -159,8 +159,8 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     }\n \n     // Return the resulting set.\n-    let result = [];\n-    i = 0u;\n+    let mut result = [];\n+    let mut i = 0u;\n     while i < vec::len(candidates) {\n         if candidates[i] { result += [i]; }\n         i += 1u;\n@@ -178,12 +178,12 @@ type size_align = {size: u16, align: u8};\n \n fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n                             did: ast::def_id) -> size_align {\n-    let max_size = 0u16;\n-    let max_align = 1u8;\n+    let mut max_size = 0u16;\n+    let mut max_align = 1u8;\n     let variants = ty::enum_variants(ccx.tcx, did);\n     for vid: uint in largest_variants {\n         // We increment a \"virtual data pointer\" to compute the size.\n-        let lltys = [];\n+        let mut lltys = [];\n         for typ: ty::t in variants[vid].args {\n             lltys += [type_of::type_of(ccx, typ)];\n         }\n@@ -308,7 +308,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_float(ast::ty_f32) { [shape_f32] }\n       ty::ty_float(ast::ty_f64) { [shape_f64] }\n       ty::ty_str {\n-        let s = [shape_vec];\n+        let mut s = [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n@@ -320,7 +320,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n           tk_unit { [s_variant_enum_t(ccx.tcx)] }\n           tk_enum { [s_variant_enum_t(ccx.tcx)] }\n           tk_newtype | tk_complex {\n-            let s = [shape_enum], id;\n+            let mut s = [shape_enum], id;\n             alt ccx.shape_cx.tag_id_to_index.find(did) {\n               none {\n                 id = ccx.shape_cx.next_tag_id;\n@@ -344,26 +344,26 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       }\n       ty::ty_box(_) | ty::ty_opaque_box { [shape_box] }\n       ty::ty_uniq(mt) {\n-        let s = [shape_uniq];\n+        let mut s = [shape_uniq];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n         s\n       }\n       ty::ty_vec(mt) {\n-        let s = [shape_vec];\n+        let mut s = [shape_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n         s\n       }\n       ty::ty_rec(fields) {\n-        let s = [shape_struct], sub = [];\n+        let mut s = [shape_struct], sub = [];\n         for f: field in fields {\n             sub += shape_of(ccx, f.mt.ty, ty_param_map);\n         }\n         add_substr(s, sub);\n         s\n       }\n       ty::ty_tup(elts) {\n-        let s = [shape_struct], sub = [];\n+        let mut s = [shape_struct], sub = [];\n         for elt in elts {\n             sub += shape_of(ccx, elt, ty_param_map);\n         }\n@@ -373,7 +373,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n       ty::ty_iface(_, _) { [shape_box_fn] }\n       ty::ty_class(_, _) { [shape_class] }\n       ty::ty_rptr(_, tm) {\n-        let s = [shape_rptr];\n+        let mut s = [shape_rptr];\n         add_substr(s, shape_of(ccx, tm.ty, ty_param_map));\n         s\n       }\n@@ -382,7 +382,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         let ri = {did: did, tps: tps};\n         let id = interner::intern(ccx.shape_cx.resources, ri);\n \n-        let s = [shape_res];\n+        let mut s = [shape_res];\n         add_u16(s, id as u16);\n         add_u16(s, vec::len(tps) as u16);\n         for tp: ty::t in tps {\n@@ -414,11 +414,11 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n // FIXME: We might discover other variants as we traverse these. Handle this.\n fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n                     ty_param_count: uint) -> [u8] {\n-    let ty_param_map = [];\n-    let i = 0u;\n+    let mut ty_param_map = [];\n+    let mut i = 0u;\n     while i < ty_param_count { ty_param_map += [i]; i += 1u; }\n \n-    let s = [];\n+    let mut s = [];\n     for t: ty::t in v.args { s += shape_of(ccx, t, ty_param_map); }\n     ret s;\n }\n@@ -427,9 +427,9 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // Loop over all the enum variants and write their shapes into a\n     // data buffer. As we do this, it's possible for us to discover\n     // new enums, so we must do this first.\n-    let i = 0u;\n-    let data = [];\n-    let offsets = [];\n+    let mut i = 0u;\n+    let mut data = [];\n+    let mut offsets = [];\n     while i < vec::len(ccx.shape_cx.tag_order) {\n         let did = ccx.shape_cx.tag_order[i];\n         let variants = ty::enum_variants(ccx.tcx, did);\n@@ -453,12 +453,12 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // info records for each enum) and the info space (which contains offsets\n     // to each variant shape). As we do so, build up the header.\n \n-    let header = [];\n-    let info = [];\n+    let mut header = [];\n+    let mut info = [];\n     let header_sz = 2u16 * ccx.shape_cx.next_tag_id;\n     let data_sz = vec::len(data) as u16;\n \n-    let info_sz = 0u16;\n+    let mut info_sz = 0u16;\n     for did_: ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n         let num_variants = vec::len(*ty::enum_variants(ccx.tcx, did)) as u16;\n@@ -470,7 +470,7 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // variant. Also construct the largest-variant table for each enum, which\n     // contains the variants that the size-of operation needs to look at.\n \n-    let lv_table = [];\n+    let mut lv_table = [];\n     i = 0u;\n     for did_: ast::def_id in ccx.shape_cx.tag_order {\n         let did = did_; // Satisfy alias checker.\n@@ -518,8 +518,8 @@ fn gen_enum_shapes(ccx: @crate_ctxt) -> ValueRef {\n }\n \n fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n-    let dtors = [];\n-    let i = 0u;\n+    let mut dtors = [];\n+    let mut i = 0u;\n     let len = interner::len(ccx.shape_cx.resources);\n     while i < len {\n         let ri = interner::get(ccx.shape_cx.resources, i);\n@@ -593,13 +593,13 @@ fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n     alt ty::get(t).struct {\n       ty::ty_enum(tid, subtys) {\n         // Compute max(variant sizes).\n-        let max_size = 0u;\n+        let mut max_size = 0u;\n         let variants = ty::enum_variants(cx.tcx, tid);\n         for variant: ty::variant_info in *variants {\n             let tup_ty = simplify_type(cx.tcx,\n                                        ty::mk_tup(cx.tcx, variant.args));\n             // Perform any type parameter substitutions.\n-            tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n+            let tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n             // Here we possibly do a recursive call.\n             let this_size =\n                 llsize_of_real(cx, type_of::type_of(cx, tup_ty));"}, {"sha": "b803102235448d97320114d4a91ed6d6e91e2a8f", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -67,7 +67,7 @@ fn duplicate(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n     let {bcx: bcx, val: newptr} =\n         trans_shared_malloc(bcx, val_ty(vptr), size);\n-    let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n+    let mut bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     Store(bcx, fill, GEPi(bcx, newptr, [0, abi::vec_elt_alloc]));\n     if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n@@ -88,24 +88,24 @@ fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n \n fn trans_vec(bcx: block, args: [@ast::expr], id: ast::node_id,\n              dest: dest) -> block {\n-    let ccx = bcx.ccx(), bcx = bcx;\n+    let ccx = bcx.ccx();\n+    let mut bcx = bcx;\n     if dest == base::ignore {\n         for arg in args {\n             bcx = base::trans_expr(bcx, arg, base::ignore);\n         }\n         ret bcx;\n     }\n     let vec_ty = node_id_type(bcx, id);\n-    let {bcx: bcx,\n-         val: vptr,\n-         unit_ty: unit_ty,\n-         llunitty: llunitty} =\n-        alloc(bcx, vec_ty, args.len());\n+    let mut {bcx: bcx,\n+             val: vptr,\n+             unit_ty: unit_ty,\n+             llunitty: llunitty} = alloc(bcx, vec_ty, args.len());\n \n     add_clean_free(bcx, vptr, true);\n     // Store the individual elements.\n     let dataptr = get_dataptr(bcx, vptr, llunitty);\n-    let i = 0u, temp_cleanups = [vptr];\n+    let mut i = 0u, temp_cleanups = [vptr];\n     for e in args {\n         let lleltptr = InBoundsGEP(bcx, dataptr, [C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n@@ -145,7 +145,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n     let lfill = get_fill(bcx, lhs);\n     let rfill = get_fill(bcx, rhs);\n-    let new_fill = Add(bcx, lfill, rfill);\n+    let mut new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n                                  T_ptr(T_ptr(ccx.opaque_vec_type)));\n@@ -156,7 +156,7 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let rhs = Select(bcx, self_append, lhs, rhs);\n \n     let lhs_data = get_dataptr(bcx, lhs, llunitty);\n-    let lhs_off = lfill;\n+    let mut lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n@@ -174,8 +174,8 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: [@ast::expr]) -> block {\n     let ccx = bcx.ccx();\n     let elt_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let ti = none;\n-    let {bcx: bcx, val: td} = get_tydesc(bcx, elt_ty, ti);\n+    let mut ti = none;\n+    let mut {bcx: bcx, val: td} = get_tydesc(bcx, elt_ty, ti);\n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr,\n                                T_ptr(T_ptr(ccx.opaque_vec_type)));\n@@ -206,7 +206,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n     let lhs_fill = get_fill(bcx, lhs);\n     let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n-    let {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n+    let mut {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n     new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(ccx, llunitty)));\n \n     let write_ptr_ptr = do_spill_noroot\n@@ -223,7 +223,7 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n     };\n \n     let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n-    bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n+    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n     ret base::store_in_dest(bcx, new_vec_ptr, dest);\n }\n \n@@ -253,7 +253,7 @@ fn iter_vec_raw(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     let body_cx = sub_block(header_cx, \"iter_vec_loop_body\");\n     let next_cx = sub_block(header_cx, \"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n-    body_cx = f(body_cx, data_ptr, unit_ty);\n+    let body_cx = f(body_cx, data_ptr, unit_ty);\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_cx, data_ptr,\n                                            [C_int(ccx, 1)]), body_cx.llbb);\n     Br(body_cx, header_cx.llbb);"}, {"sha": "70c4cf94fe5c3959bf536dd8b521ea030f3138b0", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -19,7 +19,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n }\n \n fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg], output: ty::t) -> TypeRef {\n-    let atys: [TypeRef] = [];\n+    let mut atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n     atys += [T_ptr(type_of(cx, output))];\n@@ -57,7 +57,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n       ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n       ty::ty_rec(fields) {\n-        let tys: [TypeRef] = [];\n+        let mut tys: [TypeRef] = [];\n         for f: ty::field in fields {\n             let mt_ty = f.mt.ty;\n             tys += [type_of(cx, mt_ty)];\n@@ -73,7 +73,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_param(_, _) { T_typaram(cx.tn) }\n       ty::ty_type { T_ptr(cx.tydesc_type) }\n       ty::ty_tup(elts) {\n-        let tys = [];\n+        let mut tys = [];\n         for elt in elts {\n             tys += [type_of(cx, elt)];\n         }\n@@ -82,14 +82,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n       ty::ty_constr(subt,_) { type_of(cx, subt) }\n       ty::ty_class(did, _) {\n-        let tys: [TypeRef] = [];\n         // only instance vars are record fields at runtime\n         let fields = lookup_class_fields(cx.tcx, did);\n-        for f in fields {\n+        let tys = vec::map(fields) {|f|\n             let t = ty::lookup_field_type(cx.tcx, did, f.id);\n-            let fty = type_of(cx, t);\n-            tys += [fty];\n-        }\n+            type_of(cx, t)\n+        };\n         T_struct(tys)\n       }\n       ty::ty_self(_) { cx.tcx.sess.unimpl(\"type_of: ty_self \\"}, {"sha": "cc7b67458aca5ff2f533e08690d4483327c35ac8", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -86,7 +86,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n }\n \n fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n-    let done = true;\n+    let mut done = true;\n     // Optimization -- don't descend type if all params already have this use\n     for u in cx.uses { if u & use != use { done = false } }\n     if !done { type_needs_inner(cx, use, ty); }"}, {"sha": "e1529664e99f087cf07670fb24d84e62012c4515", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -12,7 +12,7 @@ fn trans_uniq(bcx: block, contents: @ast::expr,\n     let uniq_ty = node_id_type(bcx, node_id);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n-    bcx = trans_expr_save_in(bcx, contents, llptr);\n+    let bcx = trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n     ret store_in_dest(bcx, llptr, dest);\n }"}, {"sha": "b2ed35d8f134d8c08561ae5576d52c13f02e2a5b", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -35,8 +35,8 @@ fn def_id_to_str(d: def_id) -> str {\n }\n \n fn comma_str(args: [@constr_arg_use]) -> str {\n-    let rslt = \"\";\n-    let comma = false;\n+    let mut rslt = \"\";\n+    let mut comma = false;\n     for a: @constr_arg_use in args {\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n@@ -64,8 +64,8 @@ fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n }\n \n fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n-    let s = \"\";\n-    let comma = false;\n+    let mut s = \"\";\n+    let mut comma = false;\n     for p: norm_constraint in constraints(fcx) {\n         alt tritv_get(v, p.bit_num) {\n           dont_care { }\n@@ -101,7 +101,7 @@ fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) {\n }\n \n fn tos(v: [uint]) -> str {\n-    let rslt = \"\";\n+    let mut rslt = \"\";\n     for i: uint in v {\n         if i == 0u {\n             rslt += \"0\";\n@@ -524,7 +524,7 @@ fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n         ret [{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n       }\n       cpred(p, descs) {\n-        let rslt: [norm_constraint] = [];\n+        let mut rslt: [norm_constraint] = [];\n         for pd: pred_args in *descs {\n             rslt +=\n                 [{bit_num: pd.node.bit_num,\n@@ -539,7 +539,7 @@ fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n-    let rslt: [norm_constraint] = [];\n+    let mut rslt: [norm_constraint] = [];\n     fcx.enclosing.constrs.items {|key, val|\n         rslt += norm_a_constraint(key, val);\n     };\n@@ -604,7 +604,7 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n \n fn exprs_to_constr_args(tcx: ty::ctxt, args: [@expr]) -> [@constr_arg_use] {\n     let f = bind expr_to_constr_arg(tcx, _);\n-    let rslt: [@constr_arg_use] = [];\n+    let mut rslt: [@constr_arg_use] = [];\n     for e: @expr in args { rslt += [f(e)]; }\n     rslt\n }\n@@ -638,7 +638,7 @@ fn pred_args_to_str(p: pred_args) -> str {\n \n fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr], c: @ty::constr) ->\n    tsconstr {\n-    let rslt: [@constr_arg_use] = [];\n+    let mut rslt: [@constr_arg_use] = [];\n     for a: @constr_arg in c.node.args {\n         rslt += [substitute_arg(cx, actuals, a)];\n     }\n@@ -663,7 +663,7 @@ fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n \n fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n    bool {\n-    let i = 0u;\n+    let mut i = 0u;\n     for c: @constr_arg_use in desc.node.args {\n         let n = pattern[i];\n         alt c.node {\n@@ -700,7 +700,7 @@ type subst = [{from: inst, to: inst}];\n fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n    [{from: uint, to: uint}] {\n \n-    let rslt = [];\n+    let mut rslt = [];\n     if vec::len(subst) == 0u { ret rslt; }\n \n     alt c {\n@@ -733,7 +733,7 @@ fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n }\n \n fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n-    let rslt = \"<\";\n+    let mut rslt = \"<\";\n     for i: constr_arg_general_<inst> in stuff {\n         rslt +=\n             \" \" +\n@@ -748,7 +748,7 @@ fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n }\n \n fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n-    let rslt: [constr_arg_general_<inst>] = [];\n+    let mut rslt: [constr_arg_general_<inst>] = [];\n     for c: @constr_arg_use in d.node.args {\n         alt c.node {\n           carg_ident(p) {\n@@ -844,7 +844,7 @@ fn copy_in_poststate(fcx: fn_ctxt, post: poststate, dest: inst, src: inst,\n fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n                          target_post: poststate, dest: inst, src: inst,\n                          ty: oper_type) {\n-    let subst;\n+    let mut subst;\n     alt ty {\n       oper_swap { subst = [{from: dest, to: src}, {from: src, to: dest}]; }\n       oper_assign_op {\n@@ -911,7 +911,7 @@ fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    let changed = false;\n+    let mut changed = false;\n     alt d {\n       some(d_id) {\n         for c: norm_constraint in constraints(fcx) {\n@@ -930,7 +930,7 @@ fn forget_in_poststate_still_init(fcx: fn_ctxt, p: poststate, dead_v: node_id)\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n-    let changed = false;\n+    let mut changed = false;\n     alt d {\n       some(d_id) {\n         for c: norm_constraint in constraints(fcx) {\n@@ -1013,7 +1013,7 @@ fn do_nothing<T>(_fk: visit::fn_kind, _decl: fn_decl, _body: blk,\n \n fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n                        indices: [@sp_constr_arg<uint>]) -> [@constr_arg_use] {\n-    let actuals: [@constr_arg_use] = [];\n+    let mut actuals: [@constr_arg_use] = [];\n     let num_args = vec::len(args);\n     for a: @sp_constr_arg<uint> in indices {\n         actuals +=\n@@ -1052,15 +1052,15 @@ fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n type binding = {lhs: [inst], rhs: option<initializer>};\n \n fn local_to_bindings(tcx: ty::ctxt, loc: @local) -> binding {\n-    let lhs = [];\n+    let mut lhs = [];\n     pat_bindings(tcx.def_map, loc.node.pat) {|p_id, _s, name|\n         lhs += [{ident: path_to_ident(name), node: p_id}];\n     };\n     {lhs: lhs, rhs: loc.node.init}\n }\n \n fn locals_to_bindings(tcx: ty::ctxt, locals: [@local]) -> [binding] {\n-    let rslt = [];\n+    let mut rslt = [];\n     for loc in locals { rslt += [local_to_bindings(tcx, loc)]; }\n     ret rslt;\n }\n@@ -1070,7 +1070,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [mode] {\n                                 ty::node_id_to_type(fcx.ccx.tcx, callee));\n     alt ty::get(ty).struct {\n       ty::ty_fn({inputs: args, _}) {\n-        let modes = [];\n+        let mut modes = [];\n         for arg: ty::arg in args { modes += [arg.mode]; }\n         ret modes;\n       }\n@@ -1092,8 +1092,8 @@ fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n }\n \n fn anon_bindings(ops: [init_op], es: [@expr]) -> [binding] {\n-    let bindings: [binding] = [];\n-    let i = 0;\n+    let mut bindings: [binding] = [];\n+    let mut i = 0;\n     for op: init_op in ops {\n         bindings += [{lhs: [], rhs: some({op: op, expr: es[i]})}];\n         i += 1;"}, {"sha": "1c1235ae4ed17235fed33b3de82c6c361984048c", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -55,7 +55,7 @@ fn seq_trit(u: trit, v: trit) -> trit {\n // 1 in q and 0 in p, it's 1 in the result; however,\n // if it's 0 in q and 1 in p, it's 0 in the result\n fn seq_tritv(p: postcond, q: postcond) {\n-    let i = 0u;\n+    let mut i = 0u;\n     assert (p.nbits == q.nbits);\n     while i < p.nbits {\n         tritv_set(i, p, seq_trit(tritv_get(p, i), tritv_get(q, i)));\n@@ -146,7 +146,7 @@ fn relax_precond_block_inner(b: blk, cx: relax_ctxt,\n fn relax_precond_block(fcx: fn_ctxt, i: node_id, b: blk) {\n     let cx = {fcx: fcx, i: i};\n     let visitor = visit::default_visitor::<relax_ctxt>();\n-    visitor =\n+    let visitor =\n         @{visit_block: relax_precond_block_inner,\n           visit_expr: relax_precond_expr,\n           visit_stmt: relax_precond_stmt,"}, {"sha": "bae113f8e1ec361e98126234bbf445281747981c", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -49,7 +49,7 @@ fn check_states_expr(e: @expr, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     */\n \n     if !implies(pres, prec) {\n-        let s = \"\";\n+        let mut s = \"\";\n         let diff = first_difference_string(fcx, prec, pres);\n         s +=\n             \"unsatisfied precondition constraint (for example, \" + diff +\n@@ -79,7 +79,7 @@ fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     log_tritv(fcx, pres);\n \n     if !implies(pres, prec) {\n-        let ss = \"\";\n+        let mut ss = \"\";\n         let diff = first_difference_string(fcx, prec, pres);\n         ss +=\n             \"unsatisfied precondition constraint (for example, \" + diff +\n@@ -182,13 +182,13 @@ fn check_crate(cx: ty::ctxt, crate: @crate) {\n     /* Compute the pre and postcondition for every subexpression */\n \n     let vtor = visit::default_visitor::<crate_ctxt>();\n-    vtor = @{visit_fn: fn_pre_post with *vtor};\n+    let vtor = @{visit_fn: fn_pre_post with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n \n     /* Check the pre- and postcondition against the pre- and poststate\n        for every expression */\n     let vtor = visit::default_visitor::<crate_ctxt>();\n-    vtor = @{visit_fn: fn_states with *vtor};\n+    let vtor = @{visit_fn: fn_states with *vtor};\n     visit::visit_crate(*crate, ccx, visit::mk_vt(vtor));\n }\n //"}, {"sha": "c0532c8222f94bf9e5e984e4c90afe5031044fe5", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -48,8 +48,7 @@ fn find_locals(tcx: ty::ctxt,\n                id: node_id) -> ctxt {\n     let cx: ctxt = {cs: @mutable [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n-\n-    visitor =\n+    let visitor =\n         @{visit_local: collect_local,\n           visit_expr: collect_pred,\n           visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n@@ -100,7 +99,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n               id: node_id) {\n     let name = visit::name_of_fn(fk);\n     let res_map = new_def_hash::<constraint>();\n-    let next: uint = 0u;\n+    let mut next: uint = 0u;\n \n     let cx: ctxt = find_locals(ccx.tcx, fk, f_decl, f_body, f_sp, id);\n     /* now we have to add bit nums for both the constraints\n@@ -111,7 +110,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n     }\n     /* if this function has any constraints, instantiate them to the\n        argument names and add them */\n-    let sc;\n+    let mut sc;\n     for c: @constr in f_decl.constraints {\n         sc = ast_constr_to_sp_constr(cx.tcx, f_decl.inputs, c);\n         next = add_constraint(cx.tcx, sc, next, res_map);"}, {"sha": "7ad99e0f5d1cd2431c3aae4e7642339f7adb731c", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -299,7 +299,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_call(operator, operands, _) {\n         /* copy */\n \n-        let args = operands;\n+        let mut args = operands;\n         args += [operator];\n \n         find_pre_post_exprs(fcx, args, e.id);\n@@ -355,7 +355,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         set_pre_and_post(fcx.ccx, e.id, p.precondition, p.postcondition);\n       }\n       expr_rec(fields, maybe_base) {\n-        let es = field_exprs(fields);\n+        let mut es = field_exprs(fields);\n         alt maybe_base { none {/* no-op */ } some(b) { es += [b]; } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n@@ -433,7 +433,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_do_while(body, test) {\n         find_pre_post_block(fcx, body);\n         find_pre_post_expr(fcx, test);\n-        let loop_postcond =\n+        let mut loop_postcond =\n             seq_postconds(fcx,\n                           [block_postcond(fcx.ccx, body),\n                            expr_postcond(fcx.ccx, test)]);\n@@ -452,7 +452,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_loop(body) {\n         find_pre_post_block(fcx, body);\n         /* Infinite loop: if control passes it, everything is true. */\n-        let loop_postcond = false_postcond(num_local_vars);\n+        let mut loop_postcond = false_postcond(num_local_vars);\n         /* Conservative approximation: if the body has any nonlocal exits,\n          the poststate is blank since we don't know what parts of it\n           execute. */\n@@ -476,7 +476,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n             find_pre_post_block(fcx, an_alt.body);\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n-        let alt_pps = [];\n+        let mut alt_pps = [];\n         for a: arm in alts { alt_pps += [do_an_alt(fcx, a)]; }\n         fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, &&pp: pre_and_post,\n                       &&next: pre_and_post) -> pre_and_post {\n@@ -499,7 +499,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         copy_pre_post(fcx.ccx, e.id, operator);\n       }\n       expr_fail(maybe_val) {\n-        let prestate;\n+        let mut prestate;\n         alt maybe_val {\n           none { prestate = empty_prestate(num_local_vars); }\n           some(fail_val) {\n@@ -534,10 +534,10 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n \n \n       expr_bind(operator, maybe_args) {\n-        let args = [];\n-        let cmodes = callee_modes(fcx, operator.id);\n-        let modes = [];\n-        let i = 0;\n+        let mut args = [];\n+        let mut cmodes = callee_modes(fcx, operator.id);\n+        let mut modes = [];\n+        let mut i = 0;\n         for expr_opt: option<@expr> in maybe_args {\n             alt expr_opt {\n               none {/* no-op */ }\n@@ -562,7 +562,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n       stmt_decl(adecl, id) {\n         alt adecl.node {\n           decl_local(alocals) {\n-            let e_pp;\n+            let mut e_pp;\n             let prev_pp = empty_pre_post(num_constraints(fcx.enclosing));\n             for alocal in alocals {\n                 alt alocal.node.init {\n@@ -578,7 +578,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                        initialized to the postcondition */\n                     copy_pre_post(fcx.ccx, id, an_init.expr);\n \n-                    let p = none;\n+                    let mut p = none;\n                     alt an_init.expr.node {\n                       expr_path(_p) { p = some(_p); }\n                       _ { }\n@@ -676,7 +676,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     let do_inner = bind do_inner_(fcx, _);\n     option::map::<@expr, ()>(b.node.expr, do_inner);\n \n-    let pps: [pre_and_post] = [];\n+    let mut pps: [pre_and_post] = [];\n     for s: @stmt in b.node.stmts { pps += [stmt_pp(fcx.ccx, *s)]; }\n     alt b.node.expr {\n       none {/* no-op */ }\n@@ -685,14 +685,14 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n \n     let block_precond = seq_preconds(fcx, pps);\n \n-    let postconds = [];\n+    let mut postconds = [];\n     for pp: pre_and_post in pps { postconds += [get_post(pp)]; }\n \n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n     postconds += [block_precond];\n \n-    let block_postcond = empty_poststate(nv);\n+    let mut block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n \n     if !has_nonlocal_exits(b) {"}, {"sha": "8c7cea6c7c94d67b431152a14c7d60050c55fff5", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -65,8 +65,8 @@ fn handle_fail(fcx: fn_ctxt, pres:prestate, post:poststate) {\n \n fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n    {changed: bool, post: poststate} {\n-    let changed = false;\n-    let post = tritv_clone(pres);\n+    let mut changed = false;\n+    let mut post = tritv_clone(pres);\n     for b: binding in bindings {\n         alt b.rhs {\n           some(an_init) {\n@@ -103,7 +103,7 @@ fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n \n fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n                            parent: node_id, c: option<tsconstr>) -> bool {\n-    let changed = find_pre_post_state_expr(fcx, pres, e);\n+    let mut changed = find_pre_post_state_expr(fcx, pres, e);\n \n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n \n@@ -120,7 +120,7 @@ fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n                            rhs: @expr, parent: node_id, ty: oper_type) ->\n    bool {\n-    let changed = set_prestate_ann(fcx.ccx, parent, pres);\n+    let mut changed = set_prestate_ann(fcx.ccx, parent, pres);\n     changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n     changed =\n         find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs), rhs) ||\n@@ -183,7 +183,7 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n                             id: node_id, ops: [init_op], bs: [@expr],\n                             cf: ret_style) -> bool {\n-    let changed = find_pre_post_state_expr(fcx, pres, a);\n+    let mut changed = find_pre_post_state_expr(fcx, pres, a);\n     // FIXME: This could be a typestate constraint\n     if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n@@ -199,7 +199,7 @@ fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n                              ops: [init_op], es: [@expr], cf: ret_style) ->\n    bool {\n     let rs = seq_states(fcx, pres, anon_bindings(ops, es));\n-    let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n+    let mut changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n     alt cf {\n       noreturn {\n@@ -218,7 +218,7 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n     // ever grow larger? It seems like it can't?\n     let loop_pres = intersect_states(pres, block_poststate(fcx.ccx, body));\n \n-    let changed =\n+    let mut changed =\n         set_prestate_ann(fcx.ccx, id, loop_pres) |\n             find_pre_post_state_expr(fcx, pres, index);\n \n@@ -260,7 +260,7 @@ fn gen_if_local(fcx: fn_ctxt, p: poststate, e: @expr) -> bool {\n fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n                   maybe_alt: option<@expr>, id: node_id, chk: if_ty,\n                   pres: prestate) -> bool {\n-    let changed =\n+    let mut changed =\n         set_prestate_ann(fcx.ccx, id, pres) |\n             find_pre_post_state_expr(fcx, pres, antec);\n \n@@ -305,7 +305,7 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n             find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, antec),\n                                      altern);\n \n-        let conseq_prestate = expr_poststate(fcx.ccx, antec);\n+        let mut conseq_prestate = expr_poststate(fcx.ccx, antec);\n         alt chk {\n           if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n@@ -371,10 +371,10 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n                                      controlflow_expr(fcx.ccx, operator));\n       }\n       expr_bind(operator, maybe_args) {\n-        let args = [];\n+        let mut args = [];\n         let callee_ops = callee_arg_init_ops(fcx, operator.id);\n-        let ops = [];\n-        let i = 0;\n+        let mut ops = [];\n+        let mut i = 0;\n         for a_opt: option<@expr> in maybe_args {\n             alt a_opt {\n               none {/* no-op */ }\n@@ -402,7 +402,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_rec(fields, maybe_base) {\n         let exs = field_exprs(fields);\n-        let changed =\n+        let mut changed =\n             find_pre_post_state_exprs(fcx, pres, e.id,\n                                       vec::from_elem(vec::len(fields),\n                                                     init_assign),\n@@ -435,7 +435,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         // lhs and rhs in constraints\n       }\n       expr_ret(maybe_ret_val) {\n-        let changed = set_prestate_ann(fcx.ccx, e.id, pres);\n+        let mut changed = set_prestate_ann(fcx.ccx, e.id, pres);\n         /* normally, everything is true if execution continues after\n            a ret expression (since execution never continues locally\n            after a ret expression */\n@@ -455,7 +455,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         ret changed;\n       }\n       expr_be(val) {\n-        let changed = set_prestate_ann(fcx.ccx, e.id, pres);\n+        let mut changed = set_prestate_ann(fcx.ccx, e.id, pres);\n         let post = false_postcond(num_constrs);\n         // except for the \"diverges\" bit...\n         kill_poststate_(fcx, fcx.enclosing.i_diverge, post);\n@@ -468,7 +468,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_binary(bop, l, r) {\n         if lazy_binop(bop) {\n-            let changed = find_pre_post_state_expr(fcx, pres, l);\n+            let mut changed = find_pre_post_state_expr(fcx, pres, l);\n             changed |=\n                 find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, l), r);\n             ret changed | set_prestate_ann(fcx.ccx, e.id, pres) |\n@@ -492,7 +492,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let loop_pres =\n             intersect_states(block_poststate(fcx.ccx, body), pres);\n \n-        let changed =\n+        let mut changed =\n             set_prestate_ann(fcx.ccx, e.id, loop_pres) |\n                 find_pre_post_state_expr(fcx, loop_pres, test) |\n                 find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, test),\n@@ -514,7 +514,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_do_while(body, test) {\n         let loop_pres = intersect_states(expr_poststate(fcx.ccx, test), pres);\n \n-        let changed = set_prestate_ann(fcx.ccx, e.id, loop_pres);\n+        let mut changed = set_prestate_ann(fcx.ccx, e.id, loop_pres);\n         changed |= find_pre_post_state_block(fcx, loop_pres, body);\n         /* conservative approximination: if the body of the loop\n            could break or cont, we revert to the prestate\n@@ -548,7 +548,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_loop(body) {\n         let loop_pres =\n             intersect_states(block_poststate(fcx.ccx, body), pres);\n-        let changed = set_prestate_ann(fcx.ccx, e.id, loop_pres)\n+        let mut changed = set_prestate_ann(fcx.ccx, e.id, loop_pres)\n               | find_pre_post_state_block(fcx, loop_pres, body);\n         /* conservative approximation: if a loop contains a break\n            or cont, we assume nothing about the poststate */\n@@ -569,11 +569,11 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         ret find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n       }\n       expr_alt(val, alts, _) {\n-        let changed =\n+        let mut changed =\n             set_prestate_ann(fcx.ccx, e.id, pres) |\n                 find_pre_post_state_expr(fcx, pres, val);\n         let e_post = expr_poststate(fcx.ccx, val);\n-        let a_post;\n+        let mut a_post;\n         if vec::len(alts) > 0u {\n             a_post = false_postcond(num_constrs);\n             for an_alt: arm in alts {\n@@ -660,7 +660,7 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n             termination (don't want to set changed to true\n             for intermediate changes) */\n \n-            let changed =\n+            let mut changed =\n                 set_poststate(stmt_ann, c_and_p.post) | c_and_p.changed;\n \n             #debug(\"Summary: stmt = \");\n@@ -681,7 +681,7 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n         }\n       }\n       stmt_expr(ex, _) | stmt_semi(ex, _) {\n-        let changed =\n+        let mut changed =\n             find_pre_post_state_expr(fcx, pres, ex) |\n                 set_prestate(stmt_ann, expr_prestate(fcx.ccx, ex)) |\n                 set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex));\n@@ -707,17 +707,17 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n     /* First, set the pre-states and post-states for every expression */\n \n-    let pres = pres0;\n+    let mut pres = pres0;\n     /* Iterate over each stmt. The new prestate is <pres>. The poststate\n      consist of improving <pres> with whatever variables this stmt\n      initializes.  Then <pres> becomes the new poststate. */\n \n-    let changed = false;\n+    let mut changed = false;\n     for s: @stmt in b.node.stmts {\n         changed |= find_pre_post_state_stmt(fcx, pres, s);\n         pres = stmt_poststate(fcx.ccx, *s);\n     }\n-    let post = pres;\n+    let mut post = pres;\n     alt b.node.expr {\n       none { }\n       some(e) {\n@@ -766,7 +766,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n         set_in_prestate_constr(fcx, tsc, block_pre);\n     }\n \n-    let changed = find_pre_post_state_block(fcx, block_pre, f_body);\n+    let mut changed = find_pre_post_state_block(fcx, block_pre, f_body);\n \n     // Treat the tail expression as a return statement\n     alt f_body.node.expr {"}, {"sha": "e6f68f7edb39017ebda7db22705b6e2d7144f883", "filename": "src/rustc/middle/tstate/tritv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Ftritv.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -160,10 +160,10 @@ fn change(changed: bool, old: trit, newv: trit) -> bool {\n }\n \n fn tritv_difference(p1: t, p2: t) -> bool {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n     let sz: uint = p1.nbits;\n-    let changed = false;\n+    let mut changed = false;\n     while i < sz {\n         let old = tritv_get(p1, i);\n         let newv = trit_minus(old, tritv_get(p2, i));\n@@ -175,10 +175,10 @@ fn tritv_difference(p1: t, p2: t) -> bool {\n }\n \n fn tritv_union(p1: t, p2: t) -> bool {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n     let sz: uint = p1.nbits;\n-    let changed = false;\n+    let mut changed = false;\n     while i < sz {\n         let old = tritv_get(p1, i);\n         let newv = trit_or(old, tritv_get(p2, i));\n@@ -190,10 +190,10 @@ fn tritv_union(p1: t, p2: t) -> bool {\n }\n \n fn tritv_intersect(p1: t, p2: t) -> bool {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n     let sz: uint = p1.nbits;\n-    let changed = false;\n+    let mut changed = false;\n     while i < sz {\n         let old = tritv_get(p1, i);\n         let newv = trit_and(old, tritv_get(p2, i));\n@@ -238,17 +238,17 @@ fn tritv_copy(target: t, source: t) -> bool {\n }\n \n fn tritv_set_all(v: t) {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < v.nbits { tritv_set(i, v, ttrue); i += 1u; }\n }\n \n fn tritv_clear(v: t) {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < v.nbits { tritv_set(i, v, dont_care); i += 1u; }\n }\n \n fn tritv_kill(v: t) {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < v.nbits { tritv_set(i, v, tfalse); i += 1u; }\n }\n \n@@ -259,7 +259,7 @@ fn tritv_clone(v: t) -> t {\n }\n \n fn tritv_doesntcare(v: t) -> bool {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     while i < v.nbits {\n         if tritv_get(v, i) != dont_care { ret false; }\n         i += 1u;\n@@ -268,8 +268,8 @@ fn tritv_doesntcare(v: t) -> bool {\n }\n \n fn to_vec(v: t) -> [uint] {\n-    let i: uint = 0u;\n-    let rslt: [uint] = [];\n+    let mut i: uint = 0u;\n+    let mut rslt: [uint] = [];\n     while i < v.nbits {\n         rslt +=\n             [alt tritv_get(v, i) {\n@@ -283,8 +283,8 @@ fn to_vec(v: t) -> [uint] {\n }\n \n fn to_str(v: t) -> str {\n-    let i: uint = 0u;\n-    let rs: str = \"\";\n+    let mut i: uint = 0u;\n+    let mut rs: str = \"\";\n     while i < v.nbits {\n         rs +=\n             alt tritv_get(v, i) {"}, {"sha": "7f8711cd799d4234c7e557978382c8905508d9a1", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 51, "deletions": 54, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -316,7 +316,7 @@ enum param_bound {\n }\n \n fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n-    let kind = kind_noncopyable;\n+    let mut kind = kind_noncopyable;\n     for bound in *bounds {\n         alt bound {\n           bound_copy {\n@@ -392,7 +392,7 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       some(t) { unsafe { ret unsafe::reinterpret_cast(t); } }\n       _ {}\n     }\n-    let has_params = false, has_vars = false, has_rptrs = false;\n+    let mut has_params = false, has_vars = false, has_rptrs = false;\n     fn derive_flags(&has_params: bool, &has_vars: bool, &has_rptrs: bool,\n                     tt: t) {\n         let t = get(tt);\n@@ -595,7 +595,7 @@ enum fold_mode {\n }\n \n fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n-    let ty = ty_0;\n+    let mut ty = ty_0;\n \n     let tb = get(ty);\n     alt fld {\n@@ -631,7 +631,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = mk_self(cx, vec::map(subtys, {|t| fold_ty(cx, fld, t) }));\n       }\n       ty_rec(fields) {\n-        let new_fields: [field] = [];\n+        let mut new_fields: [field] = [];\n         for fl: field in fields {\n             let new_ty = fold_ty(cx, fld, fl.mt.ty);\n             let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n@@ -640,12 +640,12 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         ty = mk_rec(cx, new_fields);\n       }\n       ty_tup(ts) {\n-        let new_ts = [];\n+        let mut new_ts = [];\n         for tt in ts { new_ts += [fold_ty(cx, fld, tt)]; }\n         ty = mk_tup(cx, new_ts);\n       }\n       ty_fn(f) {\n-        let new_args: [arg] = [];\n+        let mut new_args: [arg] = [];\n         for a: arg in f.inputs {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n@@ -655,7 +655,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n                         with f});\n       }\n       ty_res(did, subty, tps) {\n-        let new_tps = [];\n+        let mut new_tps = [];\n         for tp: t in tps { new_tps += [fold_ty(cx, fld, tp)]; }\n         ty = mk_res(cx, did, fold_ty(cx, fld, subty), new_tps);\n       }\n@@ -805,7 +805,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       none {/* fall through */ }\n     }\n \n-    let accum = false;\n+    let mut accum = false;\n     let result = alt get(ty).struct {\n       // scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n@@ -906,19 +906,19 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_vec(tm) | ty_uniq(tm) { type_kind(cx, tm.ty) }\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n-        let lowest = kind_sendable;\n+        let mut lowest = kind_sendable;\n         for f in flds { lowest = lower_kind(lowest, type_kind(cx, f.mt.ty)); }\n         lowest\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n-        let lowest = kind_sendable;\n+        let mut lowest = kind_sendable;\n         for ty in tys { lowest = lower_kind(lowest, type_kind(cx, ty)); }\n         lowest\n       }\n       // Enums lower to the lowest of their variants.\n       ty_enum(did, tps) {\n-        let lowest = kind_sendable;\n+        let mut lowest = kind_sendable;\n         for variant in *enum_variants(cx, did) {\n             for aty in variant.args {\n                 // Perform any type parameter substitutions.\n@@ -1038,7 +1038,7 @@ fn type_is_signed(ty: t) -> bool {\n // Whether a type is Plain Old Data -- meaning it does not contain pointers\n // that the cycle collector might care about.\n fn type_is_pod(cx: ctxt, ty: t) -> bool {\n-    let result = true;\n+    let mut result = true;\n     alt get(ty).struct {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n@@ -1053,7 +1053,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n             let tup_ty = mk_tup(cx, variant.args);\n \n             // Perform any type parameter substitutions.\n-            tup_ty = substitute_type_params(cx, tps, tup_ty);\n+            let tup_ty = substitute_type_params(cx, tps, tup_ty);\n             if !type_is_pod(cx, tup_ty) { result = false; }\n         }\n       }\n@@ -1108,15 +1108,15 @@ fn type_param(ty: t) -> option<uint> {\n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n fn vars_in_type(ty: t) -> [int] {\n-    let rslt = [];\n+    let mut rslt = [];\n     walk_ty(ty) {|ty|\n         alt get(ty).struct { ty_var(v) { rslt += [v]; } _ { } }\n     }\n     rslt\n }\n \n fn type_autoderef(cx: ctxt, t: t) -> t {\n-    let t1 = t;\n+    let mut t1 = t;\n     loop {\n         alt get(t1).struct {\n           ty_box(mt) | ty_uniq(mt) | ty::ty_rptr(_, mt) { t1 = mt.ty; }\n@@ -1145,12 +1145,12 @@ fn hash_type_structure(st: sty) -> uint {\n     }\n     fn hash_subty(id: uint, subty: t) -> uint { (id << 2u) + type_id(subty) }\n     fn hash_subtys(id: uint, subtys: [t]) -> uint {\n-        let h = id;\n+        let mut h = id;\n         for s in subtys { h = (h << 2u) + type_id(s) }\n         h\n     }\n     fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n-        let h = id;\n+        let mut h = id;\n         h = (h << 2u) + hash_def(h, c.node.id);\n         // FIXME this makes little sense\n         for a in c.node.args {\n@@ -1190,49 +1190,49 @@ fn hash_type_structure(st: sty) -> uint {\n       }\n       ty_str { 17u }\n       ty_enum(did, tys) {\n-        let h = hash_def(18u, did);\n+        let mut h = hash_def(18u, did);\n         for typ: t in tys { h = hash_subty(h, typ); }\n         h\n       }\n       ty_box(mt) { hash_subty(19u, mt.ty) }\n       ty_vec(mt) { hash_subty(21u, mt.ty) }\n       ty_rec(fields) {\n-        let h = 26u;\n+        let mut h = 26u;\n         for f in fields { h = hash_subty(h, f.mt.ty); }\n         h\n       }\n       ty_tup(ts) { hash_subtys(25u, ts) }\n       ty_fn(f) {\n-        let h = 27u;\n+        let mut h = 27u;\n         for a in f.inputs { h = hash_subty(h, a.ty); }\n         hash_subty(h, f.output)\n       }\n       ty_var(v) { hash_uint(30u, v as uint) }\n       ty_param(pid, did) { hash_def(hash_uint(31u, pid), did) }\n       ty_self(ts) {\n-        let h = 28u;\n+        let mut h = 28u;\n         for t in ts { h = hash_subty(h, t); }\n         h\n       }\n       ty_type { 32u }\n       ty_bot { 34u }\n       ty_ptr(mt) { hash_subty(35u, mt.ty) }\n       ty_rptr(region, mt) {\n-        let h = (46u << 2u) + hash_region(region);\n+        let mut h = (46u << 2u) + hash_region(region);\n         hash_subty(h, mt.ty)\n       }\n       ty_res(did, sub, tps) {\n-        let h = hash_subty(hash_def(18u, did), sub);\n+        let mut h = hash_subty(hash_def(18u, did), sub);\n         hash_subtys(h, tps)\n       }\n       ty_constr(t, cs) {\n-        let h = hash_subty(36u, t);\n+        let mut h = hash_subty(36u, t);\n         for c in cs { h = (h << 2u) + hash_type_constr(h, c); }\n         h\n       }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n       ty_iface(did, tys) {\n-        let h = hash_def(40u, did);\n+        let mut h = hash_def(40u, did);\n         for typ: t in tys { h = hash_subty(h, typ); }\n         h\n       }\n@@ -1241,7 +1241,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_opaque_closure_ptr(ck_uniq) { 43u }\n       ty_opaque_box { 44u }\n       ty_class(did, tys) {\n-          let h = hash_def(45u, did);\n+          let mut h = hash_def(45u, did);\n           for typ: t in tys { h = hash_subty(h, typ); }\n           h\n       }\n@@ -1270,7 +1270,7 @@ fn arg_eq<T>(eq: fn(T, T) -> bool,\n fn args_eq<T>(eq: fn(T, T) -> bool,\n               a: [@sp_constr_arg<T>],\n               b: [@sp_constr_arg<T>]) -> bool {\n-    let i: uint = 0u;\n+    let mut i: uint = 0u;\n     for arg: @sp_constr_arg<T> in a {\n         if !arg_eq(eq, arg, b[i]) { ret false; }\n         i += 1u;\n@@ -1287,7 +1287,7 @@ fn constr_eq(c: @constr, d: @constr) -> bool {\n \n fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     if vec::len(cs) != vec::len(ds) { ret false; }\n-    let i = 0u;\n+    let mut i = 0u;\n     for c: @constr in cs { if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n     ret true;\n }\n@@ -1411,7 +1411,7 @@ fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n }\n \n fn field_idx(id: ast::ident, fields: [field]) -> option<uint> {\n-    let i = 0u;\n+    let mut i = 0u;\n     for f in fields { if f.ident == id { ret some(i); } i += 1u; }\n     ret none;\n }\n@@ -1429,7 +1429,7 @@ fn get_fields(rec_ty:t) -> [field] {\n }\n \n fn method_idx(id: ast::ident, meths: [method]) -> option<uint> {\n-    let i = 0u;\n+    let mut i = 0u;\n     for m in meths { if m.ident == id { ret some(i); } i += 1u; }\n     ret none;\n }\n@@ -1676,7 +1676,7 @@ mod unify {\n \n         ufind::grow(vb.sets, (key as uint) + 1u);\n         let root = ufind::find(vb.sets, key as uint);\n-        let result_type = typ;\n+        let mut result_type = typ;\n         alt smallintmap::find(vb.types, root) {\n           some(old_type) {\n             alt unify_step(cx, old_type, typ, variance, {|v| ok(v)}) {\n@@ -1756,10 +1756,9 @@ mod unify {\n         let expected_arg_len = vec::len(expected.node.args);\n         let actual_arg_len = vec::len(actual_constr.node.args);\n         if expected_arg_len != actual_arg_len { ret err_res; }\n-        let i = 0u;\n-        let actual;\n+        let mut i = 0u;\n         for a: @ty_constr_arg in expected.node.args {\n-            actual = actual_constr.node.args[i];\n+            let actual = actual_constr.node.args[i];\n             alt a.node {\n               carg_base {\n                 alt actual.node { carg_base { } _ { ret err_res; } }\n@@ -2010,18 +2009,17 @@ mod unify {\n         cx: @uctxt, e_region: region, a_region: region,\n         variance: variance,\n         nxt: fn(region) -> ures<T>) -> ures<T> {\n-        let sub, super;\n-        alt variance {\n-            covariant { super = e_region; sub = a_region; }\n-            contravariant { super = a_region; sub = e_region; }\n-            invariant {\n-              ret if e_region == a_region {\n+        let {sub, super} = alt variance {\n+          covariant { {sub: a_region, super: e_region} }\n+          contravariant { {sub: e_region, super: a_region} }\n+          invariant {\n+            ret if e_region == a_region {\n                   nxt(e_region)\n               } else {\n                   err(terr_regions_differ(true, e_region, a_region))\n               };\n             }\n-        }\n+        };\n \n         // FIXME: This is wrong. We should be keeping a set of region bindings\n         // around.\n@@ -2187,19 +2185,18 @@ mod unify {\n         ret unify_step(cx, expected, actual, covariant, {|v| ok(v)});\n     }\n     fn dump_var_bindings(tcx: ctxt, vb: @var_bindings) {\n-        let i = 0u;\n+        let mut i = 0u;\n         while i < vec::len::<ufind::node>(vb.sets.nodes) {\n-            let sets = \"\";\n-            let j = 0u;\n+            let mut sets = \"\";\n+            let mut j = 0u;\n             while j < vec::len::<option<uint>>(vb.sets.nodes) {\n                 if ufind::find(vb.sets, j) == i { sets += #fmt[\" %u\", j]; }\n                 j += 1u;\n             }\n-            let typespec;\n-            alt smallintmap::find::<t>(vb.types, i) {\n-              none { typespec = \"\"; }\n-              some(typ) { typespec = \" =\" + ty_to_str(tcx, typ); }\n-            }\n+            let typespec = alt smallintmap::find::<t>(vb.types, i) {\n+              none { \"\" }\n+              some(typ) { \" =\" + ty_to_str(tcx, typ) }\n+            };\n             #error(\"set %u:%s%s\", i, typespec, sets);\n             i += 1u;\n         }\n@@ -2224,7 +2221,7 @@ mod unify {\n             alt smallintmap::find::<t>(vb.types, root_id) {\n               none { *unresolved = some(vid); ret mk_var(tcx, vid); }\n               some(rt) {\n-                let give_up = false;\n+                let mut give_up = false;\n                 std::list::iter(vars_seen) {|v|\n                     if v == vid {\n                         give_up = true;\n@@ -2466,7 +2463,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n         // moved there to avoid having to call eval_const_expr twice.\n         alt cx.items.get(id.node) {\n           ast_map::node_item(@{node: ast::item_enum(variants, _), _}, _) {\n-            let disr_val = -1;\n+            let mut disr_val = -1;\n             @vec::map(variants, {|variant|\n                 let ctor_ty = node_id_to_type(cx, variant.node.id);\n                 let arg_tys = if vec::len(variant.node.args) > 0u {\n@@ -2502,7 +2499,7 @@ fn enum_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n                         variant_id: ast::def_id) -> variant_info {\n     let variants = enum_variants(cx, enum_id);\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < vec::len::<variant_info>(*variants) {\n         let variant = variants[i];\n         if def_eq(variant.id, variant_id) { ret variant; }\n@@ -2614,7 +2611,7 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n }\n \n fn class_field_tys(items: [@class_item]) -> [field_ty] {\n-    let rslt = [];\n+    let mut rslt = [];\n     for it in items {\n        alt it.node.decl {\n           instance_var(nm, _, _, id) {\n@@ -2630,7 +2627,7 @@ fn class_field_tys(items: [@class_item]) -> [field_ty] {\n // Return a list of fields corresponding to the class's items\n // (as if the class was a record). trans uses this\n fn class_items_as_fields(cx:ctxt, did: ast::def_id) -> [field] {\n-    let rslt = [];\n+    let mut rslt = [];\n     for f in lookup_class_fields(cx, did) {\n        // consider all instance vars mutable, because the\n        // constructor may mutate all vars"}, {"sha": "931bf4d878071fa6fe2c48cb133847edcd889cf0", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -307,7 +307,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         }\n \n         // The typedef is type-parametric. Do the type substitution.\n-        let param_bindings: [ty::t] = [];\n+        let mut param_bindings: [ty::t] = [];\n         if vec::len(args) != vec::len(*ty_param_bounds_and_ty.bounds) {\n             tcx.sess.span_fatal(sp, \"wrong number of type arguments for a \\\n                                      polymorphic type\");\n@@ -377,11 +377,10 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             ty::mk_tup(tcx, flds)\n           }\n           ast::ty_rec(fields) {\n-            let flds: [field] = [];\n-            for f: ast::ty_field in fields {\n+            let flds = vec::map(fields) {|f|\n                 let tm = ast_mt_to_mt(tcx, use_site, mode, f.node.mt);\n-                flds += [{ident: f.node.ident, mt: tm}];\n-            }\n+                {ident: f.node.ident, mt: tm}\n+            };\n             ty::mk_rec(tcx, flds)\n           }\n           ast::ty_fn(proto, decl) {\n@@ -456,10 +455,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n             }\n           }\n           ast::ty_constr(t, cs) {\n-            let out_cs = [];\n-            for constr: @ast::ty_constr in cs {\n-                out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n-            }\n+            let out_cs = vec::map(cs) {|constr|\n+                ty::ast_constr_to_constr(tcx, constr)\n+            };\n             ty::mk_constr(tcx, do_ast_ty_to_ty(tcx, use_site, mode, t),\n                           out_cs)\n           }\n@@ -608,10 +606,9 @@ fn ty_of_fn_decl(tcx: ty::ctxt,\n     let input_tys = vec::map(decl.inputs) {|a| ty_of_arg(tcx, mode, a) };\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n-    let out_constrs = [];\n-    for constr: @ast::constr in decl.constraints {\n-        out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n-    }\n+    let out_constrs = vec::map(decl.constraints) {|constr|\n+        ty::ast_constr_to_constr(tcx, constr)\n+    };\n     {proto: proto, inputs: input_tys,\n      output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n }\n@@ -627,10 +624,10 @@ fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n                         ty_params: [ast::ty_param], def_id: ast::def_id)\n     -> ty::ty_param_bounds_and_ty {\n-    let input_tys = [], bounds = ty_param_bounds(tcx, mode, ty_params);\n-    for a: ast::arg in decl.inputs {\n-        input_tys += [ty_of_arg(tcx, mode, a)];\n-    }\n+    let bounds = ty_param_bounds(tcx, mode, ty_params);\n+    let input_tys = vec::map(decl.inputs) {|a|\n+        ty_of_arg(tcx, mode, a)\n+    };\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n     let t_fn = ty::mk_fn(tcx, {proto: ast::proto_bare,\n@@ -644,12 +641,12 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n }\n fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n     -> @[ty::param_bounds] {\n-    let result = [];\n+    let mut result = [];\n     for param in params {\n         result += [alt tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n-            let bounds = [];\n+            let mut bounds = [];\n             for b in *param.bounds {\n                 bounds += [alt b {\n                   ast::bound_send { ty::bound_send }\n@@ -728,7 +725,8 @@ fn write_bot(tcx: ty::ctxt, node_id: ast::node_id) {\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n     -> {bounds: @[ty::param_bounds], params: [ty::t]} {\n-    let i = 0u, bounds = ty_param_bounds(tcx, m_collect, atps);\n+    let mut i = 0u;\n+    let bounds = ty_param_bounds(tcx, m_collect, atps);\n     {bounds: bounds,\n      params: vec::map(atps, {|atp|\n          let t = ty::mk_param(tcx, i, local_def(atp.id));\n@@ -766,7 +764,7 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span, impl_m: ty::method,\n         let substs = substs + vec::from_fn(vec::len(*if_m.tps), {|i|\n             ty::mk_param(tcx, i + impl_tps, {crate: 0, node: 0})\n         });\n-        let if_fty = ty::mk_fn(tcx, if_m.fty);\n+        let mut if_fty = ty::mk_fn(tcx, if_m.fty);\n         if_fty = ty::substitute_type_params(tcx, substs, if_fty);\n         if ty::type_has_vars(if_fty) {\n             if_fty = fixup_self_in_method_ty(tcx, if_fty, substs,\n@@ -800,7 +798,7 @@ fn fixup_self_in_method_ty(cx: ty::ctxt, mty: ty::t, m_substs: [ty::t],\n                 if vec::len(tps) > 0u {\n                     // Move the substs into the type param system of the\n                     // context.\n-                    let substs = vec::map(tps, {|t|\n+                    let mut substs = vec::map(tps, {|t|\n                         let f = fixup_self_in_method_ty(cx, t, m_substs,\n                                                         self);\n                         ty::substitute_type_params(cx, m_substs, f)\n@@ -876,7 +874,7 @@ mod collect {\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n-                let args: [arg] = [];\n+                let mut args: [arg] = [];\n                 for va: ast::variant_arg in variant.node.args {\n                     let arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n                     args += [{mode: ast::expl(ast::by_copy), ty: arg_ty}];\n@@ -925,7 +923,7 @@ mod collect {\n     fn convert_methods(tcx: ty::ctxt, ms: [@ast::method],\n         i_bounds: @[ty::param_bounds], maybe_self: option<ty::t>)\n         -> [{mty: ty::method, id: ast::node_id, span: span}] {\n-        let my_methods = [];\n+        let mut my_methods = [];\n         for m in ms {\n            alt maybe_self {\n               some(selfty) {\n@@ -1111,7 +1109,7 @@ mod unify {\n // FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n // instead of ty::struct.\n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n-    let t1 = t;\n+    let mut t1 = t;\n     loop {\n         alt structure_of(fcx, sp, t1) {\n           ty::ty_box(inner) | ty::ty_uniq(inner) | ty::ty_rptr(_, inner) {\n@@ -1185,8 +1183,8 @@ mod demand {\n             ty_param_substs_0: [ty::t]) ->\n        ty_param_substs_and_ty {\n \n-        let ty_param_substs: [mutable ty::t] = [mutable];\n-        let ty_param_subst_var_ids: [int] = [];\n+        let mut ty_param_substs: [mutable ty::t] = [mutable];\n+        let mut ty_param_subst_var_ids: [int] = [];\n         for ty_param_subst: ty::t in ty_param_substs_0 {\n             // Generate a type variable and unify it with the type parameter\n             // substitution. We will then pull out these type variables.\n@@ -1199,7 +1197,7 @@ mod demand {\n         fn mk_result(fcx: @fn_ctxt, result_ty: ty::t,\n                      ty_param_subst_var_ids: [int]) ->\n            ty_param_substs_and_ty {\n-            let result_ty_param_substs: [ty::t] = [];\n+            let mut result_ty_param_substs: [ty::t] = [];\n             for var_id: int in ty_param_subst_var_ids {\n                 let tp_subst = ty::mk_var(fcx.ccx.tcx, var_id);\n                 result_ty_param_substs += [tp_subst];\n@@ -1241,7 +1239,7 @@ fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n // Returns the types of the arguments to a enum variant.\n fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n                      enum_ty_params: [ty::t]) -> [ty::t] {\n-    let result: [ty::t] = [];\n+    let mut result: [ty::t] = [];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::get(tpt.ty).struct {\n       ty::ty_fn(f) {\n@@ -1298,7 +1296,7 @@ mod writeback {\n             write_ty(tcx, id, t);\n             alt tcx.node_type_substs.find(id) {\n               some(substs) {\n-                let new_substs = [];\n+                let mut new_substs = [];\n                 for subst: ty::t in substs {\n                     alt resolve_type_vars_in_type(fcx, sp, subst) {\n                       some(t) { new_substs += [t]; }\n@@ -1454,7 +1452,7 @@ fn gather_locals(ccx: @crate_ctxt,\n \n     // Add formal parameters.\n     let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n-    let i = 0u;\n+    let mut i = 0u;\n     for arg: ty::arg in args {\n         assign(decl.inputs[i].id, some(arg.ty));\n         i += 1u;\n@@ -1600,7 +1598,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         // Get the number of arguments in this enum variant.\n         let arg_types = variant_arg_types(pcx.fcx.ccx, pat.span,\n                                           v_def_ids.var, expected_tps);\n-        arg_types = vec::map(arg_types,\n+        let arg_types = vec::map(arg_types,\n                              bind instantiate_self_regions(pcx.fcx.ccx.tcx,\n                                                            pcx.pat_region,\n                                                            _));\n@@ -1669,7 +1667,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       ast::pat_ident(name, sub)\n       if !pat_util::pat_is_variant(tcx.def_map, pat) {\n         let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n-        let typ = ty::mk_var(tcx, vid);\n+        let mut typ = ty::mk_var(tcx, vid);\n         typ = demand::simple(pcx.fcx, pat.span, expected, typ);\n         let canon_id = pcx.map.get(path_to_ident(name));\n         if canon_id != pat.id {\n@@ -1690,16 +1688,15 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n       ast::pat_rec(fields, etc) {\n-        let ex_fields;\n-        alt structure_of(pcx.fcx, pat.span, expected) {\n-          ty::ty_rec(fields) { ex_fields = fields; }\n+        let ex_fields = alt structure_of(pcx.fcx, pat.span, expected) {\n+          ty::ty_rec(fields) { fields }\n           _ {\n             tcx.sess.span_fatal\n                 (pat.span,\n                 #fmt[\"mismatched types: expected `%s` but found record\",\n                                 ty_to_str(tcx, expected)]);\n           }\n-        }\n+        };\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n@@ -1728,24 +1725,23 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         write_ty(tcx, pat.id, expected);\n       }\n       ast::pat_tup(elts) {\n-        let ex_elts;\n-        alt structure_of(pcx.fcx, pat.span, expected) {\n-          ty::ty_tup(elts) { ex_elts = elts; }\n+        let ex_elts = alt structure_of(pcx.fcx, pat.span, expected) {\n+          ty::ty_tup(elts) { elts }\n           _ {\n             tcx.sess.span_fatal\n                 (pat.span,\n                  #fmt[\"mismatched types: expected `%s`, found tuple\",\n                         ty_to_str(tcx, expected)]);\n           }\n-        }\n+        };\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n             tcx.sess.span_fatal\n                 (pat.span, #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\", vec::len(ex_elts), e_count]);\n         }\n-        let i = 0u;\n+        let mut i = 0u;\n         for elt in elts {\n             check_pat(pcx, elt, ex_elts[i]);\n             i += 1u;\n@@ -1878,7 +1874,8 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n     alt lookup_method_inner(fcx, expr, name, ty) {\n       some({method_ty: fty, n_tps: method_n_tps, substs, origin, self_sub}) {\n         let tcx = fcx.ccx.tcx;\n-        let substs = substs, n_tps = vec::len(substs), n_tys = vec::len(tps);\n+        let mut substs = substs;\n+        let n_tps = vec::len(substs), n_tys = vec::len(tps);\n         let has_self = ty::type_has_vars(fty);\n         if method_n_tps + n_tps > 0u {\n             if n_tys == 0u || n_tys != method_n_tps {\n@@ -1904,13 +1901,13 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n         }\n         if has_self && !option::is_none(self_sub) {\n             let fty = ty::node_id_to_type(tcx, node_id);\n-            fty = fixup_self_in_method_ty(\n+            let fty = fixup_self_in_method_ty(\n                 tcx, fty, substs, option::get(self_sub));\n             write_ty(tcx, node_id, fty);\n         }\n         if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n             let fty = ty::node_id_to_type(tcx, node_id);\n-            fty = fixup_self_region_in_method_ty(fcx, fty, expr);\n+            let fty = fixup_self_region_in_method_ty(fcx, fty, expr);\n             write_ty(tcx, node_id, fty);\n         }\n         some(origin)\n@@ -1929,7 +1926,7 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n     -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n         origin: method_origin, self_sub: option<self_subst>}> {\n     #debug(\"lookup_method_inner_: %? %? %s\", ms, parent, name);\n-    let i = 0u;\n+    let mut i = 0u;\n     for m in ms  {\n        if m.ident == name {\n           let fty = ty::mk_fn(tcx, {proto: ast::proto_box with m.fty});\n@@ -1977,7 +1974,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n     // First, see whether this is an interface-bounded parameter\n     alt ty::get(ty).struct {\n       ty::ty_param(n, did) {\n-        let bound_n = 0u;\n+        let mut bound_n = 0u;\n         for bound in *tcx.ty_param_bounds.get(did.node) {\n             alt bound {\n               ty::bound_iface(t) {\n@@ -2038,7 +2035,7 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n         }\n     }\n \n-    let result = none, complained = false;\n+    let mut result = none, complained = false;\n     std::list::iter(fcx.ccx.impl_map.get(expr.id)) {|impls|\n         if option::is_some(result) { ret; }\n         for @{did, methods, _} in *impls {\n@@ -2224,7 +2221,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let sty = structure_of(fcx, sp, fty);\n         // Grab the argument types\n-        let arg_tys = alt sty {\n+        let mut arg_tys = alt sty {\n           ty::ty_fn({inputs: arg_tys, _}) { arg_tys }\n           _ {\n             fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n@@ -2269,8 +2266,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // of arguments when we typecheck the functions. This isn't really the\n         // right way to do this.\n         let check_args = fn@(check_blocks: bool) -> bool {\n-            let i = 0u;\n-            let bot = false;\n+            let mut i = 0u;\n+            let mut bot = false;\n             for a_opt in args {\n                 alt a_opt {\n                   some(a) {\n@@ -2306,7 +2303,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     fn check_call(fcx: @fn_ctxt, sp: span, id: ast::node_id, f: @ast::expr,\n                   args: [@ast::expr])\n             -> check_call_or_bind_result {\n-        let args_opt_0: [option<@ast::expr>] = [];\n+        let mut args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n         }\n@@ -2451,7 +2448,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n-    let bot = false;\n+    let mut bot = false;\n     alt expr.node {\n       ast::expr_lit(lit) {\n         let typ = check_lit(fcx.ccx, lit);\n@@ -2484,7 +2481,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_unary(unop, oper) {\n         bot = check_expr(fcx, oper);\n-        let oper_t = expr_ty(tcx, oper);\n+        let mut oper_t = expr_ty(tcx, oper);\n         alt unop {\n           ast::box(mutbl) {\n             oper_t = ty::mk_box(tcx, {ty: oper_t, mutbl: mutbl});\n@@ -2540,7 +2537,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_addr_of(mutbl, oper) {\n         bot = check_expr(fcx, oper);\n-        let oper_t = expr_ty(tcx, oper);\n+        let mut oper_t = expr_ty(tcx, oper);\n \n         let region = region_of(fcx, oper);\n         let tm = { ty: oper_t, mutbl: mutbl };\n@@ -2637,7 +2634,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_for(decl, seq, body) {\n         bot = check_expr(fcx, seq);\n-        let elt_ty;\n+        let mut elt_ty;\n         let ety = expr_ty(tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n@@ -2687,8 +2684,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n         }\n         // Now typecheck the blocks.\n-        let result_ty = next_ty_var(fcx);\n-        let arm_non_bot = false;\n+        let mut result_ty = next_ty_var(fcx);\n+        let mut arm_non_bot = false;\n         for arm: ast::arm in arms {\n             alt arm.guard {\n               some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n@@ -2739,7 +2736,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // TODO: Perform substitutions on the return type.\n \n         // Pull the argument and return types out.\n-        let proto, arg_tys, rt, cf, constrs;\n+        let mut proto, arg_tys, rt, cf, constrs;\n         alt structure_of(fcx, expr.span, expr_ty(tcx, f)) {\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n@@ -2768,8 +2765,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         // For each blank argument, add the type of that argument\n         // to the resulting function type.\n-        let out_args = [];\n-        let i = 0u;\n+        let mut out_args = [];\n+        let mut i = 0u;\n         while i < vec::len(args) {\n             alt args[i] {\n               some(_) {/* no-op */ }\n@@ -2826,7 +2823,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write_ty(tcx, id, typ);\n       }\n       ast::expr_tup(elts) {\n-        let elt_ts = [];\n+        let mut elt_ts = [];\n         vec::reserve(elt_ts, vec::len(elts));\n         for e in elts {\n             check_expr(fcx, e);\n@@ -2838,7 +2835,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_rec(fields, base) {\n         alt base { none {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n-        let fields_t: [spanned<field>] = [];\n+        let mut fields_t: [spanned<field>] = [];\n         for f: ast::field in fields {\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n@@ -2858,7 +2855,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           some(bexpr) {\n             bot |= check_expr(fcx, bexpr);\n             let bexpr_t = expr_ty(tcx, bexpr);\n-            let base_fields: [field] = [];\n+            let mut base_fields: [field] = [];\n             alt structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) { base_fields = flds; }\n               _ {\n@@ -2868,7 +2865,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n             write_ty(tcx, id, bexpr_t);\n             for f: spanned<ty::field> in fields_t {\n-                let found = false;\n+                let mut found = false;\n                 for bf: ty::field in base_fields {\n                     if str::eq(f.node.ident, bf.ident) {\n                         demand::simple(fcx, f.span, bf.mt.ty, f.node.mt.ty);\n@@ -2889,7 +2886,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 expr_ty(tcx, base));\n         let base_t = do_autoderef(fcx, expr.span, expr_t);\n-        let handled = false, n_tys = vec::len(tys);\n+        let mut handled = false;\n+        let n_tys = vec::len(tys);\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_rec(fields) {\n             alt ty::field_idx(field, fields) {\n@@ -3060,7 +3058,7 @@ fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n }\n \n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n-    let bot = false;\n+    let mut bot = false;\n \n     let t = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(local.node.id));\n     write_ty(fcx.ccx.tcx, local.node.id, t);\n@@ -3086,8 +3084,8 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n }\n \n fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n-    let node_id;\n-    let bot = false;\n+    let mut node_id;\n+    let mut bot = false;\n     alt stmt.node {\n       ast::stmt_decl(decl, id) {\n         node_id = id;\n@@ -3127,8 +3125,8 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n       ast::unsafe_blk { @{purity: ast::unsafe_fn with *fcx0} }\n       ast::default_blk { fcx0 }\n     };\n-    let bot = false;\n-    let warned = false;\n+    let mut bot = false;\n+    let mut warned = false;\n     for s: @ast::stmt in blk.node.stmts {\n         if bot && !warned &&\n                alt s.node {\n@@ -3191,8 +3189,8 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           locals: int_hash::<int>(),\n           next_var_id: @mutable 0,\n           ccx: ccx};\n-    let disr_vals: [int] = [];\n-    let disr_val = 0;\n+    let mut disr_vals: [int] = [];\n+    let mut disr_val = 0;\n     for v in vs {\n         alt v.node.disr_expr {\n           some(e) {\n@@ -3223,7 +3221,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n         disr_vals += [disr_val];\n         disr_val += 1;\n     }\n-    let outer = true, did = local_def(id);\n+    let mut outer = true, did = local_def(id);\n     if ty::type_structurally_contains(ccx.tcx, rty, {|sty|\n         alt sty {\n           ty::ty_enum(id, _) if id == did {\n@@ -3287,7 +3285,7 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n }\n \n fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n-    let c_args;\n+    let mut c_args;\n     let num_args = vec::len(args);\n     for c: @ast::constr in cs {\n         c_args = [];\n@@ -3384,7 +3382,7 @@ fn check_fn(ccx: @crate_ctxt,\n     }\n \n     let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n-    let i = 0u;\n+    let mut i = 0u;\n     for arg: ty::arg in args {\n         write_ty(ccx.tcx, decl.inputs[i].id, arg.ty);\n         i += 1u;\n@@ -3442,7 +3440,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_impl(tps, _, ty, ms) {\n         let self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n         let self_region = ty::re_self({crate: ast::local_crate, node: it.id});\n-        self_ty = instantiate_self_regions(ccx.tcx, self_region, self_ty);\n+        let self_ty = instantiate_self_regions(ccx.tcx, self_region, self_ty);\n         ccx.self_infos += [self_impl(self_ty)];\n         for m in ms { check_method(ccx, m); }\n         vec::pop(ccx.self_infos);\n@@ -3493,7 +3491,7 @@ fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id, main_span: span) {\n          }\n          _ {}\n         }\n-        let ok = vec::len(constraints) == 0u;\n+        let mut ok = vec::len(constraints) == 0u;\n         ok &= ty::type_is_nil(output);\n         let num_args = vec::len(inputs);\n         ok &= num_args == 0u || num_args == 1u &&\n@@ -3534,7 +3532,8 @@ mod vtable {\n     fn lookup_vtables(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n                       bounds: @[ty::param_bounds], tys: [ty::t],\n                       allow_unsafe: bool) -> vtable_res {\n-        let tcx = fcx.ccx.tcx, result = [], i = 0u;\n+        let tcx = fcx.ccx.tcx;\n+        let mut result = [], i = 0u;\n         for ty in tys {\n             for bound in *bounds[i] {\n                 alt bound {\n@@ -3561,7 +3560,7 @@ mod vtable {\n         let ty = fixup_ty(fcx, sp, ty);\n         alt ty::get(ty).struct {\n           ty::ty_param(n, did) {\n-            let n_bound = 0u;\n+            let mut n_bound = 0u;\n             for bound in *tcx.ty_param_bounds.get(did.node) {\n                 alt bound {\n                   ty::bound_iface(ity) {\n@@ -3594,7 +3593,7 @@ mod vtable {\n             ret vtable_iface(did, tps);\n           }\n           _ {\n-            let found = none;\n+            let mut found = none;\n             std::list::iter(isc) {|impls|\n                 if option::is_some(found) { ret; }\n                 for im in *impls {"}, {"sha": "0fbc723ed8d20e6871fb8fb5f3f8dfcea7ac7a6d", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -142,8 +142,8 @@ fn float_ty_to_str(t: float_ty) -> str {\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {\n-    let local = false;\n-    let parent_enum : option<ident> = none;\n+    let mut local = false;\n+    let mut parent_enum : option<ident> = none;\n     for it: @item in m.items {\n         if it.ident == i { local = true; }\n         alt it.node {\n@@ -159,7 +159,7 @@ fn is_exported(i: ident, m: _mod) -> bool {\n         }\n         if local { break; }\n     }\n-    let has_explicit_exports = false;\n+    let mut has_explicit_exports = false;\n     for vi: @view_item in m.view_items {\n         alt vi.node {\n           view_item_export(vps) {\n@@ -438,7 +438,7 @@ pure fn class_item_ident(ci: @class_item) -> ident {\n type ivar = {ident: ident, ty: @ty, cm: class_mutability, id: node_id};\n \n fn split_class_items(cs: [@class_item]) -> ([ivar], [@method]) {\n-    let vs = [], ms = [];\n+    let mut vs = [], ms = [];\n     for c in cs {\n       alt c.node.decl {\n         instance_var(i, t, cm, id) {"}, {"sha": "c242b142bcc7546ac4fa9376feeb4a5bb4e03cb9", "filename": "src/rustc/syntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fcodemap.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -56,8 +56,8 @@ fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n     -> {fm: filemap, line: uint}\n {\n     let len = vec::len(map.files);\n-    let a = 0u;\n-    let b = len;\n+    let mut a = 0u;\n+    let mut b = len;\n     while b - a > 1u {\n         let m = (a + b) / 2u;\n         if lookup(map.files[m].start_pos) > pos { b = m; } else { a = m; }\n@@ -150,7 +150,7 @@ type file_lines = {file: filemap, lines: [uint]};\n fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n-    let lines = [];\n+    let mut lines = [];\n     uint::range(lo.line - 1u, hi.line as uint) {|i| lines += [i]; };\n     ret @{file: lo.file, lines: lines};\n }"}, {"sha": "99dd6410d12720e5552b312269691ff4725dfa9b", "filename": "src/rustc/syntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fbuild.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -67,7 +67,7 @@ fn mk_vec_e(cx: ext_ctxt, sp: span, exprs: [@ast::expr]) ->\n fn mk_rec_e(cx: ext_ctxt, sp: span,\n             fields: [{ident: ast::ident, ex: @ast::expr}]) ->\n     @ast::expr {\n-    let astfields: [ast::field] = [];\n+    let mut astfields: [ast::field] = [];\n     for field: {ident: ast::ident, ex: @ast::expr} in fields {\n         let ident = field.ident;\n         let val = field.ex;"}, {"sha": "f461458c21a7177bd17a625bf150c63ad1884b5c", "filename": "src/rustc/syntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -11,7 +11,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n             cx.span_fatal(sp, \"#concat_idents requires a vector argument .\")\n           }\n         };\n-    let res: ast::ident = \"\";\n+    let mut res: ast::ident = \"\";\n     for e: @ast::expr in args {\n         res += expr_to_ident(cx, e, \"expected an ident\");\n     }"}, {"sha": "cd30efbbfb8ad742e7115f2bc1bbf22db3d549f0", "filename": "src/rustc/syntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Ffmt.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -56,9 +56,9 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n \n     fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n         fn make_flags(cx: ext_ctxt, sp: span, flags: [flag]) -> @ast::expr {\n-            let flagexprs: [@ast::expr] = [];\n+            let mut flagexprs: [@ast::expr] = [];\n             for f: flag in flags {\n-                let fstr;\n+                let mut fstr;\n                 alt f {\n                   flag_left_justify { fstr = \"flag_left_justify\"; }\n                   flag_left_zero_pad { fstr = \"flag_left_zero_pad\"; }\n@@ -85,7 +85,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             }\n         }\n         fn make_ty(cx: ext_ctxt, sp: span, t: ty) -> @ast::expr {\n-            let rt_type;\n+            let mut rt_type;\n             alt t {\n               ty_hex(c) {\n                 alt c {\n@@ -249,8 +249,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         }\n     }\n     let fmt_sp = args[0].span;\n-    let n = 0u;\n-    let tmp_expr = mk_str(cx, sp, \"\");\n+    let mut n = 0u;\n+    let mut tmp_expr = mk_str(cx, sp, \"\");\n     let nargs = vec::len::<@ast::expr>(args);\n     for pc: piece in pieces {\n         alt pc {"}, {"sha": "55fd8645b31a49e5c1b10dbabffa9f371944e4c8", "filename": "src/rustc/syntax/ext/qquote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fqquote.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -136,7 +136,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n               arg: ast::mac_arg, body: ast::mac_body)\n     -> @ast::expr\n {\n-    let what = \"expr\";\n+    let mut what = \"expr\";\n     option::may(arg) {|arg|\n         let args: [@ast::expr] =\n             alt arg.node {\n@@ -211,10 +211,10 @@ fn finish<T: qq_helper>\n         // ^^ check that the spans are non-overlapping\n     }\n \n-    let str2 = \"\";\n+    let mut str2 = \"\";\n     enum state {active, skip(uint), blank};\n-    let state = active;\n-    let i = 0u, j = 0u;\n+    let mut state = active;\n+    let mut i = 0u, j = 0u;\n     let g_len = vec::len(cx.gather);\n     str::chars_iter(*str) {|ch|\n         if (j < g_len && i == cx.gather[j].lo) {\n@@ -260,7 +260,7 @@ fn finish<T: qq_helper>\n                                    \"cfg\"),\n                         mk_access_(cx,sp, session_call(), \"parse_sess\")]\n                       );\n-    let rcall = pcall;\n+    let mut rcall = pcall;\n     if (g_len > 0u) {\n         rcall = mk_call(cx,sp,\n                         [\"syntax\", \"ext\", \"qquote\", \"replace\"],"}, {"sha": "b7ee1c25f3ea8196146ac3d4d1ea2729a6d7cb09", "filename": "src/rustc/syntax/ext/simplext.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fsimplext.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -74,8 +74,8 @@ type selector = fn@(matchable) -> match_result;\n \n fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n    {pre: [@expr], rep: option<@expr>, post: [@expr]} {\n-    let idx: uint = 0u;\n-    let res = none;\n+    let mut idx: uint = 0u;\n+    let mut res = none;\n     for elt: @expr in elts {\n         alt elt.node {\n           expr_mac(m) {\n@@ -104,7 +104,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n \n fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option<U>, v: [T]) ->\n    option<[U]> {\n-    let res = [];\n+    let mut res = [];\n     for elem: T in v {\n         alt f(elem) { none { ret none; } some(fv) { res += [fv]; } }\n     }\n@@ -169,7 +169,7 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option<bindings> {\n     for sel: selector in b.literal_ast_matchers {\n         alt sel(match_expr(e)) { none { ret none; } _ { } }\n     }\n-    let never_mind: bool = false;\n+    let mut never_mind: bool = false;\n     b.real_binders.items {|key, val|\n         alt val(match_expr(e)) {\n           none { never_mind = true; }\n@@ -211,7 +211,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n /* helper: descend into a matcher */\n fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n    arb_depth<matchable> {\n-    let res: arb_depth<matchable> = m;\n+    let mut res: arb_depth<matchable> = m;\n     for idx: uint in *idx_path {\n         alt res {\n           leaf(_) { ret res;/* end of the line */ }\n@@ -263,11 +263,11 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                     recur: fn@(&&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n-        let res = vec::map(pre, recur);\n+        let mut res = vec::map(pre, recur);\n         alt repeat_me_maybe {\n           none { }\n           some(repeat_me) {\n-            let repeat: option<{rep_count: uint, name: ident}> = none;\n+            let mut repeat: option<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             free_vars(b, repeat_me) {|fv|\n@@ -301,7 +301,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n               }\n               some({rep_count: rc, _}) {\n                 /* Whew, we now know how how many times to repeat */\n-                let idx: uint = 0u;\n+                let mut idx: uint = 0u;\n                 while idx < rc {\n                     *idx_path += [idx];\n                     res += [recur(repeat_me)]; // whew!\n@@ -598,8 +598,8 @@ fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n               match_expr(e) {\n                 alt e.node {\n                   expr_vec(arg_elts, _) {\n-                    let elts = [];\n-                    let idx = offset;\n+                    let mut elts = [];\n+                    let mut idx = offset;\n                     while idx < vec::len(arg_elts) {\n                         elts += [leaf(match_expr(arg_elts[idx]))];\n                         idx += 1u;\n@@ -645,7 +645,7 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n \n fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,\n                          s: selector, b: binders) {\n-    let idx: uint = 0u;\n+    let mut idx: uint = 0u;\n     while idx < vec::len(elts) {\n         fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n             ret alt m {\n@@ -678,8 +678,8 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n           }\n         };\n \n-    let macro_name: option<str> = none;\n-    let clauses: [@clause] = [];\n+    let mut macro_name: option<str> = none;\n+    let mut clauses: [@clause] = [];\n     for arg: @expr in args {\n         alt arg.node {\n           expr_vec(elts, mutbl) {"}, {"sha": "ad649b28190c392e8663bc856d8591e40af71245", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -339,7 +339,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             pat_enum(fld.fold_path(pth), vec::map(pats, fld.fold_pat))\n           }\n           pat_rec(fields, etc) {\n-            let fs = [];\n+            let mut fs = [];\n             for f: ast::field_pat in fields {\n                 fs += [{ident: f.ident, pat: fld.fold_pat(f.pat)}];\n             }"}, {"sha": "b56f26230b962993d64720a16aa5d71b0cf9e7f3", "filename": "src/rustc/syntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Feval.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -28,8 +28,8 @@ fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive],\n            option::from_maybe(suffix, \"none\"));\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n-    let view_items: [@ast::view_item] = [];\n-    let items: [@ast::item] = [];\n+    let mut view_items: [@ast::view_item] = [];\n+    let mut items: [@ast::item] = [];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret ({view_items: view_items + cview_items,\n           items: items + citems},"}, {"sha": "a8e5d9c07238f51cc98f436b6f64b55156edcaf2", "filename": "src/rustc/syntax/parse/lexer.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Flexer.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -129,7 +129,7 @@ fn consume_any_line_comment(rdr: reader) {\n }\n \n fn consume_block_comment(rdr: reader) {\n-    let level: int = 1;\n+    let mut level: int = 1;\n     while level > 0 {\n         if rdr.is_eof() { rdr.fatal(\"unterminated block comment\"); }\n         if rdr.curr == '/' && rdr.next() == '*' {\n@@ -150,8 +150,8 @@ fn consume_block_comment(rdr: reader) {\n }\n \n fn scan_exponent(rdr: reader) -> option<str> {\n-    let c = rdr.curr;\n-    let rslt = \"\";\n+    let mut c = rdr.curr;\n+    let mut rslt = \"\";\n     if c == 'e' || c == 'E' {\n         str::push_char(rslt, c);\n         rdr.bump();\n@@ -168,7 +168,7 @@ fn scan_exponent(rdr: reader) -> option<str> {\n }\n \n fn scan_digits(rdr: reader, radix: uint) -> str {\n-    let rslt = \"\";\n+    let mut rslt = \"\";\n     loop {\n         let c = rdr.curr;\n         if c == '_' { rdr.bump(); cont; }\n@@ -183,7 +183,7 @@ fn scan_digits(rdr: reader, radix: uint) -> str {\n }\n \n fn scan_number(c: char, rdr: reader) -> token::token {\n-    let num_str, base = 10u, c = c, n = rdr.next();\n+    let mut num_str, base = 10u, c = c, n = rdr.next();\n     if c == '0' && n == 'x' {\n         rdr.bump();\n         rdr.bump();\n@@ -197,8 +197,11 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n     c = rdr.curr;\n     n = rdr.next();\n     if c == 'u' || c == 'i' {\n-        let signed = c == 'i', tp = if signed { either::left(ast::ty_i) }\n-                                         else { either::right(ast::ty_u) };\n+        let signed = c == 'i';\n+        let mut tp = {\n+            if signed { either::left(ast::ty_i) }\n+            else { either::right(ast::ty_u) }\n+        };\n         rdr.bump();\n         c = rdr.curr;\n         if c == '8' {\n@@ -232,7 +235,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n           either::right(t) { ret token::LIT_UINT(parsed, t); }\n         }\n     }\n-    let is_float = false;\n+    let mut is_float = false;\n     if rdr.curr == '.' && !(is_alpha(rdr.next()) || rdr.next() == '_') {\n         is_float = true;\n         rdr.bump();\n@@ -279,7 +282,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n }\n \n fn scan_numeric_escape(rdr: reader, n_hex_digits: uint) -> char {\n-    let accum_int = 0, i = n_hex_digits;\n+    let mut accum_int = 0, i = n_hex_digits;\n     while i != 0u {\n         let n = rdr.curr;\n         rdr.bump();\n@@ -302,8 +305,8 @@ fn next_token(rdr: reader) -> {tok: token::token, chpos: uint, bpos: uint} {\n }\n \n fn next_token_inner(rdr: reader) -> token::token {\n-    let accum_str = \"\";\n-    let c = rdr.curr;\n+    let mut accum_str = \"\";\n+    let mut c = rdr.curr;\n     if (c >= 'a' && c <= 'z')\n         || (c >= 'A' && c <= 'Z')\n         || c == '_'\n@@ -377,7 +380,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n       '$' {\n         rdr.bump();\n         if is_dec_digit(rdr.curr) {\n-            let val = dec_digit_val(rdr.curr) as uint;\n+            let mut val = dec_digit_val(rdr.curr) as uint;\n             while is_dec_digit(rdr.next()) {\n                 rdr.bump();\n                 val = val * 10u + (dec_digit_val(rdr.curr) as uint);\n@@ -441,7 +444,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n       }\n       '\\'' {\n         rdr.bump();\n-        let c2 = rdr.curr;\n+        let mut c2 = rdr.curr;\n         rdr.bump();\n         if c2 == '\\\\' {\n             let escaped = rdr.curr;\n@@ -548,7 +551,7 @@ enum cmnt_style {\n type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n \n fn read_to_eol(rdr: reader) -> str {\n-    let val = \"\";\n+    let mut val = \"\";\n     while rdr.curr != '\\n' && !rdr.is_eof() {\n         str::push_char(val, rdr.curr);\n         rdr.bump();\n@@ -591,7 +594,7 @@ fn consume_whitespace_counting_blank_lines(rdr: reader, &comments: [cmnt]) {\n fn read_line_comments(rdr: reader, code_to_the_left: bool) -> cmnt {\n     #debug(\">>> line comments\");\n     let p = rdr.chpos;\n-    let lines: [str] = [];\n+    let mut lines: [str] = [];\n     while rdr.curr == '/' && rdr.next() == '/' {\n         let line = read_one_line_comment(rdr);\n         log(debug, line);\n@@ -605,14 +608,14 @@ fn read_line_comments(rdr: reader, code_to_the_left: bool) -> cmnt {\n }\n \n fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n-    let i: uint = begin;\n+    let mut i: uint = begin;\n     while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n     ret true;\n }\n \n fn trim_whitespace_prefix_and_push_line(&lines: [str],\n                                         s: str, col: uint) unsafe {\n-    let s1;\n+    let mut s1;\n     if all_whitespace(s, 0u, col) {\n         if col < str::len(s) {\n             s1 = str::slice(s, col, str::len(s));\n@@ -625,12 +628,12 @@ fn trim_whitespace_prefix_and_push_line(&lines: [str],\n fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n     #debug(\">>> block comment\");\n     let p = rdr.chpos;\n-    let lines: [str] = [];\n-    let col: uint = rdr.col;\n+    let mut lines: [str] = [];\n+    let mut col: uint = rdr.col;\n     rdr.bump();\n     rdr.bump();\n-    let curr_line = \"/*\";\n-    let level: int = 1;\n+    let mut curr_line = \"/*\";\n+    let mut level: int = 1;\n     while level > 0 {\n         #debug(\"=== block comment level %d\", level);\n         if rdr.is_eof() { rdr.fatal(\"unterminated block comment\"); }\n@@ -658,7 +661,7 @@ fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n     if str::len(curr_line) != 0u {\n         trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n     }\n-    let style = if code_to_the_left { trailing } else { isolated };\n+    let mut style = if code_to_the_left { trailing } else { isolated };\n     consume_non_eol_whitespace(rdr);\n     if !rdr.is_eof() && rdr.curr != '\\n' && vec::len(lines) == 1u {\n         style = mixed;\n@@ -704,12 +707,12 @@ fn gather_comments_and_literals(cm: codemap::codemap,\n     let itr = @interner::mk::<str>(str::hash, str::eq);\n     let rdr = new_reader(cm, span_diagnostic,\n                          codemap::new_filemap(path, src, 0u, 0u), itr);\n-    let comments: [cmnt] = [];\n-    let literals: [lit] = [];\n-    let first_read: bool = true;\n+    let mut comments: [cmnt] = [];\n+    let mut literals: [lit] = [];\n+    let mut first_read: bool = true;\n     while !rdr.is_eof() {\n         loop {\n-            let code_to_the_left = !first_read;\n+            let mut code_to_the_left = !first_read;\n             consume_non_eol_whitespace(rdr);\n             if rdr.curr == '\\n' {\n                 code_to_the_left = false;"}, {"sha": "b35b68ea5e24253b0612b63d5fdfc3ef47ab80ce", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 98, "deletions": 96, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -169,7 +169,7 @@ fn expect(p: parser, t: token::token) {\n     if p.token == t {\n         p.bump();\n     } else {\n-        let s: str = \"expecting '\";\n+        let mut s: str = \"expecting '\";\n         s += token::to_str(p.reader, t);\n         s += \"' but found '\";\n         s += token::to_str(p.reader, p.token);\n@@ -185,7 +185,7 @@ fn expect_gt(p: parser) {\n     } else if p.token == token::BINOP(token::ASR) {\n         p.swap(token::BINOP(token::LSR), p.span.lo + 1u, p.span.hi);\n     } else {\n-        let s: str = \"expecting \";\n+        let mut s: str = \"expecting \";\n         s += token::to_str(p.reader, token::GT);\n         s += \", found \";\n         s += token::to_str(p.reader, p.token);\n@@ -313,14 +313,14 @@ fn parse_ty_field(p: parser) -> ast::ty_field {\n // if i is the jth ident in args, return j\n // otherwise, fail\n fn ident_index(p: parser, args: [ast::arg], i: ast::ident) -> uint {\n-    let j = 0u;\n+    let mut j = 0u;\n     for a: ast::arg in args { if a.ident == i { ret j; } j += 1u; }\n     p.fatal(\"unbound variable `\" + i + \"` in constraint arg\");\n }\n \n fn parse_type_constr_arg(p: parser) -> @ast::ty_constr_arg {\n     let sp = p.span;\n-    let carg = ast::carg_base;\n+    let mut carg = ast::carg_base;\n     expect(p, token::BINOP(token::STAR));\n     if p.token == token::DOT {\n         // \"*...\" notation for record fields\n@@ -334,7 +334,7 @@ fn parse_type_constr_arg(p: parser) -> @ast::ty_constr_arg {\n \n fn parse_constr_arg(args: [ast::arg], p: parser) -> @ast::constr_arg {\n     let sp = p.span;\n-    let carg = ast::carg_base;\n+    let mut carg = ast::carg_base;\n     if p.token == token::BINOP(token::STAR) {\n         p.bump();\n     } else {\n@@ -369,7 +369,7 @@ fn parse_constr_in_type(p: parser) -> @ast::ty_constr {\n fn parse_constrs<T: copy>(pser: fn(parser) -> @ast::constr_general<T>,\n                          p: parser) ->\n    [@ast::constr_general<T>] {\n-    let constrs: [@ast::constr_general<T>] = [];\n+    let mut constrs: [@ast::constr_general<T>] = [];\n     loop {\n         let constr = pser(p);\n         constrs += [constr];\n@@ -463,7 +463,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n             p.bump();\n             ast::ty_nil\n         } else {\n-            let ts = [parse_ty(p, false)];\n+            let mut ts = [parse_ty(p, false)];\n             while p.token == token::COMMA {\n                 p.bump();\n                 ts += [parse_ty(p, false)];\n@@ -564,8 +564,8 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n fn parse_seq_to_before_gt<T: copy>(sep: option<token::token>,\n                                   f: fn(parser) -> T,\n                                   p: parser) -> [T] {\n-    let first = true;\n-    let v = [];\n+    let mut first = true;\n+    let mut v = [];\n     while p.token != token::GT && p.token != token::BINOP(token::LSR) &&\n               p.token != token::BINOP(token::ASR) {\n         alt sep {\n@@ -622,8 +622,8 @@ fn seq_sep_none() -> seq_sep {\n fn parse_seq_to_before_end<T: copy>(ket: token::token,\n                                    sep: seq_sep,\n                                    f: fn(parser) -> T, p: parser) -> [T] {\n-    let first: bool = true;\n-    let v: [T] = [];\n+    let mut first: bool = true;\n+    let mut v: [T] = [];\n     while p.token != ket {\n         alt sep.sep {\n           some(t) { if first { first = false; } else { expect(p, t); } }\n@@ -701,7 +701,8 @@ fn is_plain_ident(p: parser) -> bool {\n \n fn parse_path(p: parser) -> @ast::path {\n     let lo = p.span.lo;\n-    let global = eat(p, token::MOD_SEP), ids = [parse_ident(p)];\n+    let global = eat(p, token::MOD_SEP);\n+    let mut ids = [parse_ident(p)];\n     while p.look_ahead(1u) != token::LT && eat(p, token::MOD_SEP) {\n         ids += [parse_ident(p)];\n     }\n@@ -800,9 +801,9 @@ fn to_expr(e: pexpr) -> @ast::expr {\n \n fn parse_bottom_expr(p: parser) -> pexpr {\n     let lo = p.span.lo;\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n \n-    let ex: ast::expr_;\n+    let mut ex: ast::expr_;\n \n     alt have_dollar(p) {\n       some(x) {ret pexpr(mk_mac_expr(p, lo, p.span.hi, x));}\n@@ -817,7 +818,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n             let lit = @spanned(lo, hi, ast::lit_nil);\n             ret mk_pexpr(p, lo, hi, ast::expr_lit(lit));\n         }\n-        let es = [parse_expr(p)];\n+        let mut es = [parse_expr(p)];\n         while p.token == token::COMMA { p.bump(); es += [parse_expr(p)]; }\n         hi = p.span.hi;\n         expect(p, token::RPAREN);\n@@ -832,8 +833,8 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         p.bump();\n         if is_word(p, \"mut\") || is_word(p, \"mutable\") ||\n                is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n-            let fields = [parse_field(p, token::COLON)];\n-            let base = none;\n+            let mut fields = [parse_field(p, token::COLON)];\n+            let mut base = none;\n             while p.token != token::RBRACE {\n                 if eat_word(p, \"with\") { base = some(parse_expr(p)); break; }\n                 expect(p, token::COMMA);\n@@ -1011,7 +1012,7 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n     let pth = parse_path(p);\n     //temporary for a backwards-compatible cycle:\n     let sep = seq_sep(token::COMMA);\n-    let e = none;\n+    let mut e = none;\n     if (p.token == token::LPAREN || p.token == token::LBRACKET) {\n         let es =\n             if p.token == token::LPAREN {\n@@ -1025,11 +1026,11 @@ fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n         e = some(mk_expr(p, es.span.lo, hi,\n                          ast::expr_vec(es.node, ast::m_imm)));\n     }\n-    let b = none;\n+    let mut b = none;\n     if p.token == token::LBRACE {\n         p.bump();\n         let lo = p.span.lo;\n-        let depth = 1u;\n+        let mut depth = 1u;\n         while (depth > 0u) {\n             alt (p.token) {\n               token::LBRACE {depth += 1u;}\n@@ -1055,9 +1056,9 @@ fn permits_call(p: parser) -> bool {\n }\n \n fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n-    let e = e0;\n+    let mut e = e0;\n     let lo = e.span.lo;\n-    let hi = e.span.hi;\n+    let mut hi = e.span.hi;\n     loop {\n         // expr.f\n         if eat(p, token::DOT) {\n@@ -1132,9 +1133,9 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n \n fn parse_prefix_expr(p: parser) -> pexpr {\n     let lo = p.span.lo;\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n \n-    let ex;\n+    let mut ex;\n     alt p.token {\n       token::NOT {\n         p.bump();\n@@ -1261,7 +1262,7 @@ fn parse_assign_expr(p: parser) -> @ast::expr {\n       token::BINOPEQ(op) {\n         p.bump();\n         let rhs = parse_expr(p);\n-        let aop = ast::add;\n+        let mut aop;\n         alt op {\n           token::PLUS { aop = ast::add; }\n           token::MINUS { aop = ast::subtract; }\n@@ -1302,8 +1303,8 @@ fn parse_if_expr_1(p: parser) ->\n     let lo = p.last_span.lo;\n     let cond = parse_expr(p);\n     let thn = parse_block(p);\n-    let els: option<@ast::expr> = none;\n-    let hi = thn.span.hi;\n+    let mut els: option<@ast::expr> = none;\n+    let mut hi = thn.span.hi;\n     if eat_word(p, \"else\") {\n         let elexpr = parse_else_expr(p);\n         els = some(elexpr);\n@@ -1337,7 +1338,7 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n     }\n \n     fn eat_ident_list(p: parser) -> [@ast::capture_item] {\n-        let res = [];\n+        let mut res = [];\n         loop {\n             alt p.token {\n               token::IDENT(_, _) {\n@@ -1355,8 +1356,8 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n         };\n     }\n \n-    let copies = [];\n-    let moves = [];\n+    let mut copies = [];\n+    let mut moves = [];\n \n     if eat(p, token::LBRACKET) {\n         while !eat(p, token::RBRACKET) {\n@@ -1407,15 +1408,15 @@ fn parse_for_expr(p: parser) -> @ast::expr {\n     expect_word(p, \"in\");\n     let seq = parse_expr(p);\n     let body = parse_block_no_value(p);\n-    let hi = body.span.hi;\n+    let mut hi = body.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_for(decl, seq, body));\n }\n \n fn parse_while_expr(p: parser) -> @ast::expr {\n     let lo = p.last_span.lo;\n     let cond = parse_expr(p);\n     let body = parse_block_no_value(p);\n-    let hi = body.span.hi;\n+    let mut hi = body.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_while(cond, body));\n }\n \n@@ -1424,14 +1425,14 @@ fn parse_do_while_expr(p: parser) -> @ast::expr {\n     let body = parse_block_no_value(p);\n     expect_word(p, \"while\");\n     let cond = parse_expr(p);\n-    let hi = cond.span.hi;\n+    let mut hi = cond.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_do_while(body, cond));\n }\n \n fn parse_loop_expr(p: parser) -> @ast::expr {\n     let lo = p.last_span.lo;\n     let body = parse_block_no_value(p);\n-    let hi = body.span.hi;\n+    let mut hi = body.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_loop(body));\n }\n \n@@ -1441,15 +1442,15 @@ fn parse_alt_expr(p: parser) -> @ast::expr {\n                else { ast::alt_exhaustive };\n     let discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n-    let arms: [ast::arm] = [];\n+    let mut arms: [ast::arm] = [];\n     while p.token != token::RBRACE {\n         let pats = parse_pats(p);\n-        let guard = none;\n+        let mut guard = none;\n         if eat_word(p, \"if\") { guard = some(parse_expr(p)); }\n         let blk = parse_block(p);\n         arms += [{pats: pats, guard: guard, body: blk}];\n     }\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     p.bump();\n     ret mk_expr(p, lo, hi, ast::expr_alt(discriminant, arms, mode));\n }\n@@ -1497,7 +1498,7 @@ fn parse_initializer(p: parser) -> option<ast::initializer> {\n }\n \n fn parse_pats(p: parser) -> [@ast::pat] {\n-    let pats = [];\n+    let mut pats = [];\n     loop {\n         pats += [parse_pat(p)];\n         if p.token == token::BINOP(token::OR) { p.bump(); } else { ret pats; }\n@@ -1506,8 +1507,8 @@ fn parse_pats(p: parser) -> [@ast::pat] {\n \n fn parse_pat(p: parser) -> @ast::pat {\n     let lo = p.span.lo;\n-    let hi = p.span.hi;\n-    let pat;\n+    let mut hi = p.span.hi;\n+    let mut pat;\n     alt p.token {\n       token::UNDERSCORE { p.bump(); pat = ast::pat_wild; }\n       token::AT {\n@@ -1524,9 +1525,9 @@ fn parse_pat(p: parser) -> @ast::pat {\n       }\n       token::LBRACE {\n         p.bump();\n-        let fields = [];\n-        let etc = false;\n-        let first = true;\n+        let mut fields = [];\n+        let mut etc = false;\n+        let mut first = true;\n         while p.token != token::RBRACE {\n             if first { first = false; } else { expect(p, token::COMMA); }\n \n@@ -1545,7 +1546,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n             let hi1 = p.last_span.lo;\n             let fieldpath = ast_util::ident_to_path(ast_util::mk_sp(lo1, hi1),\n                                           fieldname);\n-            let subpat;\n+            let mut subpat;\n             if p.token == token::COLON {\n                 p.bump();\n                 subpat = parse_pat(p);\n@@ -1572,7 +1573,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n             let expr = mk_expr(p, lo, hi, ast::expr_lit(lit));\n             pat = ast::pat_lit(expr);\n         } else {\n-            let fields = [parse_pat(p)];\n+            let mut fields = [parse_pat(p)];\n             while p.token == token::COMMA {\n                 p.bump();\n                 fields += [parse_pat(p)];\n@@ -1606,7 +1607,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n         } else {\n             let enum_path = parse_path_and_ty_param_substs(p, true);\n             hi = enum_path.span.hi;\n-            let args: [@ast::pat];\n+            let mut args: [@ast::pat];\n             alt p.token {\n               token::LPAREN {\n                 let a =\n@@ -1635,9 +1636,9 @@ fn parse_local(p: parser, is_mutbl: bool,\n                allow_init: bool) -> @ast::local {\n     let lo = p.span.lo;\n     let pat = parse_pat(p);\n-    let ty = @{id: p.get_id(),\n-               node: ast::ty_infer,\n-               span: ast_util::mk_sp(lo, lo)};\n+    let mut ty = @{id: p.get_id(),\n+                   node: ast::ty_infer,\n+                   span: ast_util::mk_sp(lo, lo)};\n     if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.last_span.hi,\n@@ -1648,7 +1649,7 @@ fn parse_local(p: parser, is_mutbl: bool,\n fn parse_let(p: parser) -> @ast::decl {\n     let is_mutbl = eat_word(p, \"mut\");\n     let lo = p.span.lo;\n-    let locals = [parse_local(p, is_mutbl, true)];\n+    let mut locals = [parse_local(p, is_mutbl, true)];\n     while eat(p, token::COMMA) {\n         locals += [parse_local(p, is_mutbl, true)];\n     }\n@@ -1657,7 +1658,7 @@ fn parse_let(p: parser) -> @ast::decl {\n \n /* assumes \"let\" token has already been consumed */\n fn parse_instance_var(p:parser) -> (ast::class_member, codemap::span) {\n-    let is_mutbl = ast::class_immutable;\n+    let mut is_mutbl = ast::class_immutable;\n     let lo = p.span.lo;\n     if eat_word(p, \"mut\") || eat_word(p, \"mutable\") {\n             is_mutbl = ast::class_mutable;\n@@ -1687,7 +1688,7 @@ fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n         let decl = parse_let(p);\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n-        let item_attrs;\n+        let mut item_attrs;\n         alt parse_outer_attrs_or_ext(p, first_item_attrs) {\n           none { item_attrs = []; }\n           some(left(attrs)) { item_attrs = attrs; }\n@@ -1700,7 +1701,7 @@ fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n \n         alt parse_item(p, item_attrs) {\n           some(i) {\n-            let hi = i.span.hi;\n+            let mut hi = i.span.hi;\n             let decl = @spanned(lo, hi, ast::decl_item(i));\n             ret @spanned(lo, hi, ast::stmt_decl(decl, p.get_id()));\n           }\n@@ -1805,10 +1806,10 @@ fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n \n fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n                      first_item_attrs: [ast::attribute]) -> ast::blk {\n-    let stmts = [];\n-    let expr = none;\n+    let mut stmts = [];\n+    let mut expr = none;\n     let view_items = maybe_parse_view_import_only(p, first_item_attrs);\n-    let initial_attrs = first_item_attrs;\n+    let mut initial_attrs = first_item_attrs;\n \n     if p.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n         p.fatal(\"expected item\");\n@@ -1854,15 +1855,15 @@ fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n           }\n         }\n     }\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     p.bump();\n     let bloc = {view_items: view_items, stmts: stmts, expr: expr,\n                 id: p.get_id(), rules: s};\n     ret spanned(lo, hi, bloc);\n }\n \n fn parse_ty_param(p: parser) -> ast::ty_param {\n-    let bounds = [];\n+    let mut bounds = [];\n     let ident = parse_ident(p);\n     if eat(p, token::COLON) {\n         while p.token != token::COMMA && p.token != token::GT {\n@@ -1888,7 +1889,7 @@ fn parse_fn_decl(p: parser, purity: ast::purity)\n     // Use the args list to translate each bound variable\n     // mentioned in a constraint to an arg index.\n     // Seems weird to do this in the parser, but I'm not sure how else to.\n-    let constrs = [];\n+    let mut constrs = [];\n     if p.token == token::COLON {\n         p.bump();\n         constrs = parse_constrs({|x| parse_ty_constr(inputs.node, x) }, p);\n@@ -1990,7 +1991,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     fn wrap_path(p: parser, pt: @ast::path) -> @ast::ty {\n         @{id: p.get_id(), node: ast::ty_path(pt, p.get_id()), span: pt.span}\n     }\n-    let (ident, tps) = if !is_word(p, \"of\") {\n+    let mut (ident, tps) = if !is_word(p, \"of\") {\n         if p.token == token::LT { (none, parse_ty_params(p)) }\n         else { (some(parse_ident(p)), parse_ty_params(p)) }\n     } else { (none, []) };\n@@ -2006,7 +2007,8 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n         none { expect_word(p, \"of\"); fail; }\n     };\n     expect_word(p, \"for\");\n-    let ty = parse_ty(p, false), meths = [];\n+    let ty = parse_ty(p, false);\n+    let mut meths = [];\n     expect(p, token::LBRACE);\n     while !eat(p, token::RBRACE) { meths += [parse_method(p)]; }\n     ret mk_item(p, lo, p.last_span.hi, ident,\n@@ -2044,9 +2046,9 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let class_path = ident_to_path(p.last_span, class_name);\n     let ty_params = parse_ty_params(p);\n     expect(p, token::LBRACE);\n-    let items: [@ast::class_item] = [];\n+    let mut items: [@ast::class_item] = [];\n     let ctor_id = p.get_id();\n-    let the_ctor : option<(ast::fn_decl, ast::blk, codemap::span)> = none;\n+    let mut the_ctor : option<(ast::fn_decl, ast::blk, codemap::span)> = none;\n     while p.token != token::RBRACE {\n         alt parse_class_item(p, class_path) {\n            ctor_decl(a_fn_decl, blk, s) {\n@@ -2109,7 +2111,7 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n     // FIXME: refactor\n     else if eat_word(p, \"priv\") {\n             expect(p, token::LBRACE);\n-            let results = [];\n+            let mut results = [];\n             while p.token != token::RBRACE {\n                if eat_word(p, \"let\") {\n                   let a_var = parse_instance_var(p);\n@@ -2142,8 +2144,8 @@ fn parse_mod_items(p: parser, term: token::token,\n                    first_item_attrs: [ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items = maybe_parse_view(p, first_item_attrs);\n-    let items: [@ast::item] = [];\n-    let initial_attrs = first_item_attrs;\n+    let mut items: [@ast::item] = [];\n+    let mut initial_attrs = first_item_attrs;\n     while p.token != term {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n         #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n@@ -2173,7 +2175,7 @@ fn parse_item_const(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let ty = parse_ty(p, false);\n     expect(p, token::EQ);\n     let e = parse_expr(p);\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n     ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n }\n@@ -2185,7 +2187,7 @@ fn parse_item_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let inner_attrs = parse_inner_attrs_and_next(p);\n     let first_item_outer_attrs = inner_attrs.next;\n     let m = parse_mod_items(p, token::RBRACE, first_item_outer_attrs);\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     expect(p, token::RBRACE);\n     ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs.inner);\n }\n@@ -2195,7 +2197,7 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n     let lo = p.last_span.lo;\n     let t = parse_fn_header(p);\n     let decl = parse_fn_decl(p, purity);\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,\n           attrs: attrs,\n@@ -2223,8 +2225,8 @@ fn parse_native_mod_items(p: parser, first_item_attrs: [ast::attribute]) ->\n         if vec::len(first_item_attrs) == 0u {\n             parse_native_view(p)\n         } else { [] };\n-    let items: [@ast::native_item] = [];\n-    let initial_attrs = first_item_attrs;\n+    let mut items: [@ast::native_item] = [];\n+    let mut initial_attrs = first_item_attrs;\n     while p.token != token::RBRACE {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n         initial_attrs = [];\n@@ -2243,7 +2245,7 @@ fn parse_item_native_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let inner_attrs = more_attrs.inner;\n     let first_item_outer_attrs = more_attrs.next;\n     let m = parse_native_mod_items(p, first_item_outer_attrs);\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     expect(p, token::RBRACE);\n     ret mk_item(p, lo, hi, id, ast::item_native_mod(m), attrs + inner_attrs);\n }\n@@ -2259,7 +2261,7 @@ fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n     let ty = parse_ty(p, false);\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     expect(p, token::SEMI);\n     ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n }\n@@ -2268,7 +2270,7 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let id = parse_ident(p);\n     let ty_params = parse_ty_params(p);\n-    let variants: [ast::variant] = [];\n+    let mut variants: [ast::variant] = [];\n     // Newtype syntax\n     if p.token == token::EQ {\n         if p.bad_expr_words.contains_key(id) {\n@@ -2289,13 +2291,13 @@ fn parse_item_enum(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     }\n     expect(p, token::LBRACE);\n \n-    let all_nullary = true, have_disr = false;\n+    let mut all_nullary = true, have_disr = false;\n \n     while p.token != token::RBRACE {\n         let variant_attrs = parse_outer_attributes(p);\n         let vlo = p.span.lo;\n         let ident = parse_value_ident(p);\n-        let args = [], disr_expr = none;\n+        let mut args = [], disr_expr = none;\n         if p.token == token::LPAREN {\n             all_nullary = false;\n             let arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n@@ -2416,7 +2418,7 @@ fn parse_outer_attrs_or_ext(\n \n // Parse attributes that appear before an item\n fn parse_outer_attributes(p: parser) -> [ast::attribute] {\n-    let attrs: [ast::attribute] = [];\n+    let mut attrs: [ast::attribute] = [];\n     while p.token == token::POUND {\n         attrs += [parse_attribute(p, ast::attr_outer)];\n     }\n@@ -2434,7 +2436,7 @@ fn parse_attribute_naked(p: parser, style: ast::attr_style, lo: uint) ->\n     expect(p, token::LBRACKET);\n     let meta_item = parse_meta_item(p);\n     expect(p, token::RBRACKET);\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     ret spanned(lo, hi, {style: style, value: *meta_item});\n }\n \n@@ -2446,8 +2448,8 @@ fn parse_attribute_naked(p: parser, style: ast::attr_style, lo: uint) ->\n // until we see the semi).\n fn parse_inner_attrs_and_next(p: parser) ->\n    {inner: [ast::attribute], next: [ast::attribute]} {\n-    let inner_attrs: [ast::attribute] = [];\n-    let next_outer_attrs: [ast::attribute] = [];\n+    let mut inner_attrs: [ast::attribute] = [];\n+    let mut next_outer_attrs: [ast::attribute] = [];\n     while p.token == token::POUND {\n         if p.look_ahead(1u) != token::LBRACKET {\n             // This is an extension\n@@ -2476,16 +2478,16 @@ fn parse_meta_item(p: parser) -> @ast::meta_item {\n       token::EQ {\n         p.bump();\n         let lit = parse_lit(p);\n-        let hi = p.span.hi;\n+        let mut hi = p.span.hi;\n         ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n       }\n       token::LPAREN {\n         let inner_items = parse_meta_seq(p);\n-        let hi = p.span.hi;\n+        let mut hi = p.span.hi;\n         ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n       }\n       _ {\n-        let hi = p.span.hi;\n+        let mut hi = p.span.hi;\n         ret @spanned(lo, hi, ast::meta_word(ident));\n       }\n     }\n@@ -2509,7 +2511,7 @@ fn parse_use(p: parser) -> ast::view_item_ {\n fn parse_view_path(p: parser) -> @ast::view_path {\n     let lo = p.span.lo;\n     let first_ident = parse_ident(p);\n-    let path = [first_ident];\n+    let mut path = [first_ident];\n     #debug(\"parsed view_path: %s\", first_ident);\n     alt p.token {\n       token::EQ {\n@@ -2521,7 +2523,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n             let id = parse_ident(p);\n             path += [id];\n         }\n-        let hi = p.span.hi;\n+        let mut hi = p.span.hi;\n         ret @spanned(lo, hi,\n                      ast::view_path_simple(first_ident,\n                                            @path, p.get_id()));\n@@ -2545,7 +2547,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n                     parse_seq(token::LBRACE, token::RBRACE,\n                               seq_sep(token::COMMA),\n                               parse_path_list_ident, p).node;\n-                let hi = p.span.hi;\n+                let mut hi = p.span.hi;\n                 ret @spanned(lo, hi,\n                              ast::view_path_list(@path, idents,\n                                                  p.get_id()));\n@@ -2554,7 +2556,7 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n               // foo::bar::*\n               token::BINOP(token::STAR) {\n                 p.bump();\n-                let hi = p.span.hi;\n+                let mut hi = p.span.hi;\n                 ret @spanned(lo, hi,\n                              ast::view_path_glob(@path,\n                                                  p.get_id()));\n@@ -2566,15 +2568,15 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n       }\n       _ { }\n     }\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     let last = path[vec::len(path) - 1u];\n     ret @spanned(lo, hi,\n                  ast::view_path_simple(last, @path,\n                                        p.get_id()));\n }\n \n fn parse_view_paths(p: parser) -> [@ast::view_path] {\n-    let vp = [parse_view_path(p)];\n+    let mut vp = [parse_view_path(p)];\n     while p.token == token::COMMA {\n         p.bump();\n         vp += [parse_view_path(p)];\n@@ -2594,7 +2596,7 @@ fn parse_view_item(p: parser) -> @ast::view_item {\n         } else {\n             fail\n     };\n-    let hi = p.span.lo;\n+    let mut hi = p.span.lo;\n     expect(p, token::SEMI);\n     ret @spanned(lo, hi, the_item);\n }\n@@ -2630,7 +2632,7 @@ fn maybe_parse_view_while(\n     f: fn@(parser) -> bool) -> [@ast::view_item] {\n \n     if vec::len(first_item_attrs) == 0u {\n-        let items = [];\n+        let mut items = [];\n         while f(p) { items += [parse_view_item(p)]; }\n         ret items;\n     } else {\n@@ -2729,7 +2731,7 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n         alt p.token {\n           // mod x = \"foo.rs\";\n           token::SEMI {\n-            let hi = p.span.hi;\n+            let mut hi = p.span.hi;\n             p.bump();\n             ret spanned(lo, hi, ast::cdir_src_mod(id, outer_attrs));\n           }\n@@ -2741,7 +2743,7 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n             let next_outer_attr = inner_attrs.next;\n             let cdirs =\n                 parse_crate_directives(p, token::RBRACE, next_outer_attr);\n-            let hi = p.span.hi;\n+            let mut hi = p.span.hi;\n             expect(p, token::RBRACE);\n             ret spanned(lo, hi,\n                         ast::cdir_dir_mod(id, cdirs, mod_attrs));\n@@ -2765,8 +2767,8 @@ fn parse_crate_directives(p: parser, term: token::token,\n         expect_word(p, \"mod\");\n     }\n \n-    let cdirs: [@ast::crate_directive] = [];\n-    let first_outer_attr = first_outer_attr;\n+    let mut cdirs: [@ast::crate_directive] = [];\n+    let mut first_outer_attr = first_outer_attr;\n     while p.token != term {\n         let cdir = @parse_crate_directive(p, first_outer_attr);\n         cdirs += [cdir];\n@@ -2793,7 +2795,7 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n     let (companionmod, _) = path::splitext(path::basename(input));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n         cx, cdirs, prefix, option::some(companionmod));\n-    let hi = p.span.hi;\n+    let mut hi = p.span.hi;\n     expect(p, token::EOF);\n     ret @spanned(lo, hi,\n                  {directives: cdirs,"}, {"sha": "bd010d03e947a06598e8c90b335340bb7e24bca4", "filename": "src/rustc/syntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Ftoken.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -137,7 +137,7 @@ fn to_str(r: reader, t: token) -> str {\n       /* Literals */\n       LIT_INT(c, ast::ty_char) {\n         // FIXME: escape.\n-        let tmp = \"'\";\n+        let mut tmp = \"'\";\n         str::push_char(tmp, c as char);\n         str::push_char(tmp, '\\'');\n         ret tmp;"}, {"sha": "bb71268870d9ec33684f9cdf7dfd70c39727b9a6", "filename": "src/rustc/syntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpp.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -74,9 +74,9 @@ fn buf_str(toks: [mutable token], szs: [mutable int], left: uint, right: uint,\n            lim: uint) -> str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n-    let i = left;\n-    let L = lim;\n-    let s = \"[\";\n+    let mut i = left;\n+    let mut L = lim;\n+    let mut s = \"[\";\n     while i != right && L != 0u {\n         L -= 1u;\n         if i != left { s += \", \"; }\n@@ -399,7 +399,8 @@ impl printer for printer {\n     }\n     fn get_top() -> print_stack_elt {\n         let n = vec::len(self.print_stack);\n-        let top: print_stack_elt = {offset: 0, pbreak: broken(inconsistent)};\n+        let mut top: print_stack_elt =\n+            {offset: 0, pbreak: broken(inconsistent)};\n         if n != 0u { top = self.print_stack[n - 1u]; }\n         ret top;\n     }"}, {"sha": "433424d27370dd88de7ac9fa8fd96437c04e08d2", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -268,7 +268,7 @@ fn synth_comment(s: ps, text: str) {\n \n fn commasep<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN)) {\n     box(s, 0u, b);\n-    let first = true;\n+    let mut first = true;\n     for elt: IN in elts {\n         if first { first = false; } else { word_space(s, \",\"); }\n         op(s, elt);\n@@ -281,7 +281,7 @@ fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN),\n                      get_span: fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n-    let i = 0u;\n+    let mut i = 0u;\n     for elt: IN in elts {\n         maybe_print_comment(s, get_span(elt).hi);\n         op(s, elt);\n@@ -626,7 +626,7 @@ fn print_method(s: ps, meth: @ast::method) {\n }\n \n fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n-    let count = 0;\n+    let mut count = 0;\n     for attr: ast::attribute in attrs {\n         alt attr.node.style {\n           ast::attr_outer { print_attribute(s, attr); count += 1; }\n@@ -637,7 +637,7 @@ fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n }\n \n fn print_inner_attributes(s: ps, attrs: [ast::attribute]) {\n-    let count = 0;\n+    let mut count = 0;\n     for attr: ast::attribute in attrs {\n         alt attr.node.style {\n           ast::attr_inner {\n@@ -856,7 +856,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       }\n       ast::expr_call(func, args, has_block) {\n         print_expr_parens_if_not_bot(s, func);\n-        let base_args = args, blk = none;\n+        let mut base_args = args, blk = none;\n         if has_block { blk = some(vec::pop(base_args)); }\n         if !has_block || vec::len(base_args) > 0u {\n             popen(s);\n@@ -952,7 +952,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             space(s.s);\n             cbox(s, alt_indent_unit);\n             ibox(s, 0u);\n-            let first = true;\n+            let mut first = true;\n             for p: @ast::pat in arm.pats {\n                 if first {\n                     first = false;\n@@ -1169,7 +1169,7 @@ fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.node.global { word(s.s, \"::\"); }\n-    let first = true;\n+    let mut first = true;\n     for id: ast::ident in path.node.idents {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n@@ -1383,7 +1383,7 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n }\n \n fn print_simple_path(s: ps, path: ast::simple_path) {\n-    let first = true;\n+    let mut first = true;\n     for id in path {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n@@ -1530,14 +1530,14 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n \n fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n                                 next_pos: option<uint>) {\n-    let cm;\n+    let mut cm;\n     alt s.cm { some(ccm) { cm = ccm; } _ { ret; } }\n     alt next_comment(s) {\n       some(cmnt) {\n         if cmnt.style != lexer::trailing { ret; }\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n-        let next = cmnt.pos + 1u;\n+        let mut next = cmnt.pos + 1u;\n         alt next_pos { none { } some(p) { next = p; } }\n         if span.hi < cmnt.pos && cmnt.pos < next &&\n                span_line.line == comment_line.line {\n@@ -1689,9 +1689,9 @@ fn print_string(s: ps, st: str) {\n }\n \n fn escape_str(st: str, to_escape: char) -> str {\n-    let out: str = \"\";\n+    let mut out: str = \"\";\n     let len = str::len(st);\n-    let i = 0u;\n+    let mut i = 0u;\n     while i < len {\n         alt st[i] as char {\n           '\\n' { out += \"\\\\n\"; }\n@@ -1731,8 +1731,8 @@ fn next_comment(s: ps) -> option<lexer::cmnt> {\n \n fn constr_args_to_str<T>(f: fn@(T) -> str, args: [@ast::sp_constr_arg<T>]) ->\n    str {\n-    let comma = false;\n-    let s = \"(\";\n+    let mut comma = false;\n+    let mut s = \"(\";\n     for a: @ast::sp_constr_arg<T> in args {\n         if comma { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str::<T>(f, a.node);\n@@ -1775,7 +1775,7 @@ fn ty_constr_to_str(&&c: @ast::ty_constr) -> str {\n }\n \n fn constrs_str<T>(constrs: [T], elt: fn(T) -> str) -> str {\n-    let s = \"\", colon = true;\n+    let mut s = \"\", colon = true;\n     for c in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += elt(c);"}, {"sha": "93c328ef2abc85f7dd1963e063fb631e687f4339", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -12,7 +12,7 @@ fn def_eq(a: ast::def_id, b: ast::def_id) -> bool {\n }\n \n fn hash_def(d: ast::def_id) -> uint {\n-    let h = 5381u;\n+    let mut h = 5381u;\n     h = (h << 5u) + h ^ (d.crate as uint);\n     h = (h << 5u) + h ^ (d.node as uint);\n     ret h;\n@@ -27,7 +27,7 @@ fn new_def_hash<V: copy>() -> std::map::hashmap<ast::def_id, V> {\n fn field_expr(f: ast::field) -> @ast::expr { ret f.node.expr; }\n \n fn field_exprs(fields: [ast::field]) -> [@ast::expr] {\n-    let es = [];\n+    let mut es = [];\n     for f: ast::field in fields { es += [f.node.expr]; }\n     ret es;\n }"}, {"sha": "9b6f9cddb59dda29d95483eb2c25520e1299e114", "filename": "src/rustc/util/filesearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Ffilesearch.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -130,10 +130,10 @@ fn get_cargo_root() -> result<path, str> {\n fn get_cargo_root_nearest() -> result<path, str> {\n     result::chain(get_cargo_root()) { |p|\n         let cwd = os::getcwd();\n-        let dirname = path::dirname(cwd);\n-        let dirpath = path::split(dirname);\n+        let mut dirname = path::dirname(cwd);\n+        let mut dirpath = path::split(dirname);\n         let cwd_cargo = path::connect(cwd, \".cargo\");\n-        let par_cargo = path::connect(dirname, \".cargo\");\n+        let mut par_cargo = path::connect(dirname, \".cargo\");\n \n         if os::path_is_dir(cwd_cargo) || cwd_cargo == p {\n             ret result::ok(cwd_cargo);"}, {"sha": "9cfd0299919a9a0468d8ff2a7c2cb2344194c4bc", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b653a1841631949f6d21c551a700a3cbe13bf42f/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=b653a1841631949f6d21c551a700a3cbe13bf42f", "patch": "@@ -60,10 +60,10 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_to_str(cx: ctxt, proto: ast::proto, ident: option<ast::ident>,\n                  inputs: [arg], output: t, cf: ast::ret_style,\n                  constrs: [@constr]) -> str {\n-        let s = proto_to_str(proto);\n+        let mut s = proto_to_str(proto);\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n-        let strs = [];\n+        let mut strs = [];\n         for a: arg in inputs { strs += [fn_input_to_str(cx, a)]; }\n         s += str::connect(strs, \", \");\n         s += \")\";\n@@ -137,12 +137,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n       ty_type { \"type\" }\n       ty_rec(elems) {\n-        let strs: [str] = [];\n+        let mut strs: [str] = [];\n         for fld: field in elems { strs += [field_to_str(cx, fld)]; }\n         \"{\" + str::connect(strs, \",\") + \"}\"\n       }\n       ty_tup(elems) {\n-        let strs = [];\n+        let mut strs = [];\n         for elem in elems { strs += [ty_to_str(cx, elem)]; }\n         \"(\" + str::connect(strs, \",\") + \")\"\n       }\n@@ -165,7 +165,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n }\n \n fn ty_to_short_str(cx: ctxt, typ: t) -> str {\n-    let s = encoder::encoded_ty(cx, typ);\n+    let mut s = encoder::encoded_ty(cx, typ);\n     if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }\n     ret s;\n }\n@@ -176,8 +176,8 @@ fn constr_to_str(c: @constr) -> str {\n }\n \n fn constrs_str(constrs: [@constr]) -> str {\n-    let s = \"\";\n-    let colon = true;\n+    let mut s = \"\";\n+    let mut colon = true;\n     for c: @constr in constrs {\n         if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n         s += constr_to_str(c);"}]}