{"sha": "a955ef2c8c95a289f0753e533b690c576b1806bf", "node_id": "C_kwDOAAsO6NoAKGE5NTVlZjJjOGM5NWEyODlmMDc1M2U1MzNiNjkwYzU3NmIxODA2YmY", "commit": {"author": {"name": "BlackHoleFox", "email": "blackholefoxdev@gmail.com", "date": "2022-10-05T05:48:22Z"}, "committer": {"name": "BlackHoleFox", "email": "blackholefoxdev@gmail.com", "date": "2022-10-05T05:48:22Z"}, "message": "Revert \"Use getentropy when possible on all Apple platforms\"\n\nThis reverts commit 3fc35b5b935e390c61ea2bbf744838b2632b2df1.", "tree": {"sha": "afc41c942fd43953cd2de3c1b8c91c767627024c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc41c942fd43953cd2de3c1b8c91c767627024c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a955ef2c8c95a289f0753e533b690c576b1806bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a955ef2c8c95a289f0753e533b690c576b1806bf", "html_url": "https://github.com/rust-lang/rust/commit/a955ef2c8c95a289f0753e533b690c576b1806bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a955ef2c8c95a289f0753e533b690c576b1806bf/comments", "author": {"login": "BlackHoleFox", "id": 20936452, "node_id": "MDQ6VXNlcjIwOTM2NDUy", "avatar_url": "https://avatars.githubusercontent.com/u/20936452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlackHoleFox", "html_url": "https://github.com/BlackHoleFox", "followers_url": "https://api.github.com/users/BlackHoleFox/followers", "following_url": "https://api.github.com/users/BlackHoleFox/following{/other_user}", "gists_url": "https://api.github.com/users/BlackHoleFox/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlackHoleFox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlackHoleFox/subscriptions", "organizations_url": "https://api.github.com/users/BlackHoleFox/orgs", "repos_url": "https://api.github.com/users/BlackHoleFox/repos", "events_url": "https://api.github.com/users/BlackHoleFox/events{/privacy}", "received_events_url": "https://api.github.com/users/BlackHoleFox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BlackHoleFox", "id": 20936452, "node_id": "MDQ6VXNlcjIwOTM2NDUy", "avatar_url": "https://avatars.githubusercontent.com/u/20936452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BlackHoleFox", "html_url": "https://github.com/BlackHoleFox", "followers_url": "https://api.github.com/users/BlackHoleFox/followers", "following_url": "https://api.github.com/users/BlackHoleFox/following{/other_user}", "gists_url": "https://api.github.com/users/BlackHoleFox/gists{/gist_id}", "starred_url": "https://api.github.com/users/BlackHoleFox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BlackHoleFox/subscriptions", "organizations_url": "https://api.github.com/users/BlackHoleFox/orgs", "repos_url": "https://api.github.com/users/BlackHoleFox/repos", "events_url": "https://api.github.com/users/BlackHoleFox/events{/privacy}", "received_events_url": "https://api.github.com/users/BlackHoleFox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8613f792c11d6d348b15eee79da561323fa0199", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8613f792c11d6d348b15eee79da561323fa0199", "html_url": "https://github.com/rust-lang/rust/commit/d8613f792c11d6d348b15eee79da561323fa0199"}], "stats": {"total": 94, "additions": 38, "deletions": 56}, "files": [{"sha": "a6fe07873d7ee4263b9362d9a5dda75c35916582", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 38, "deletions": 56, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a955ef2c8c95a289f0753e533b690c576b1806bf/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a955ef2c8c95a289f0753e533b690c576b1806bf/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=a955ef2c8c95a289f0753e533b690c576b1806bf", "patch": "@@ -137,9 +137,11 @@ mod imp {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+#[cfg(target_os = \"macos\")]\n mod imp {\n-    use crate::io;\n+    use crate::fs::File;\n+    use crate::io::Read;\n+    use crate::sys::os::errno;\n     use crate::sys::weak::weak;\n     use libc::{c_int, c_void, size_t};\n \n@@ -153,72 +155,22 @@ mod imp {\n                 for s in v.chunks_mut(256) {\n                     let ret = unsafe { f(s.as_mut_ptr() as *mut c_void, s.len()) };\n                     if ret == -1 {\n-                        panic!(\"unexpected getentropy error: {}\", io::Error::last_os_error());\n+                        panic!(\"unexpected getentropy error: {}\", errno());\n                     }\n                 }\n                 true\n             })\n             .unwrap_or(false)\n     }\n \n-    #[cfg(target_os = \"macos\")]\n-    fn fallback_fill_bytes(v: &mut [u8]) {\n-        use crate::fs::File;\n-        use crate::io::Read;\n-\n-        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n-        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n-    }\n-\n-    // On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n-    // `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n-    // from `/dev/random` and which runs on its own thread accessed via GCD.\n-    //\n-    // This is very heavyweight compared to the alternatives, but they may not be usable:\n-    // - `getentropy` was added in iOS 10, but we support a minimum of iOS 7\n-    // - `/dev/urandom` is not accessible inside the iOS app sandbox.\n-    //\n-    // Therefore `SecRandomCopyBytes` is only used on older iOS versions where no\n-    // better options are present.\n-    #[cfg(target_os = \"ios\")]\n-    fn fallback_fill_bytes(v: &mut [u8]) {\n-        use crate::ptr;\n-\n-        enum SecRandom {}\n-\n-        #[allow(non_upper_case_globals)]\n-        const kSecRandomDefault: *const SecRandom = ptr::null();\n-\n-        extern \"C\" {\n-            fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n-        }\n-\n-        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n-        if ret == -1 {\n-            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n-        }\n-    }\n-\n-    // All supported versions of watchOS (>= 5) have support for `getentropy`.\n-    #[cfg(target_os = \"watchos\")]\n-    #[cold]\n-    fn fallback_fill_bytes(_: &mut [u8]) {\n-        unreachable!()\n-    }\n-\n     pub fn fill_bytes(v: &mut [u8]) {\n         if getentropy_fill_bytes(v) {\n             return;\n         }\n \n-        // Older macOS versions (< 10.12) don't support `getentropy`. Fallback to\n-        // reading from `/dev/urandom` on these systems.\n-        //\n-        // Older iOS versions (< 10) don't support it either. Fallback to\n-        // `SecRandomCopyBytes` on these systems. On watchOS, this is unreachable\n-        // because the minimum supported version is 5 while `getentropy` became accessible\n-        // in 3.\n-        fallback_fill_bytes(v)\n+        // for older macos which doesn't support getentropy\n+        let mut file = File::open(\"/dev/urandom\").expect(\"failed to open /dev/urandom\");\n+        file.read_exact(v).expect(\"failed to read /dev/urandom\")\n     }\n }\n \n@@ -237,6 +189,36 @@ mod imp {\n     }\n }\n \n+// On iOS and MacOS `SecRandomCopyBytes` calls `CCRandomCopyBytes` with\n+// `kCCRandomDefault`. `CCRandomCopyBytes` manages a CSPRNG which is seeded\n+// from `/dev/random` and which runs on its own thread accessed via GCD.\n+// This seems needlessly heavyweight for the purposes of generating two u64s\n+// once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n+// only used on iOS where direct access to `/dev/urandom` is blocked by the\n+// sandbox.\n+#[cfg(any(target_os = \"ios\", target_os = \"watchos\"))]\n+mod imp {\n+    use crate::io;\n+    use crate::ptr;\n+    use libc::{c_int, size_t};\n+\n+    enum SecRandom {}\n+\n+    #[allow(non_upper_case_globals)]\n+    const kSecRandomDefault: *const SecRandom = ptr::null();\n+\n+    extern \"C\" {\n+        fn SecRandomCopyBytes(rnd: *const SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+    }\n+\n+    pub fn fill_bytes(v: &mut [u8]) {\n+        let ret = unsafe { SecRandomCopyBytes(kSecRandomDefault, v.len(), v.as_mut_ptr()) };\n+        if ret == -1 {\n+            panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n+        }\n+    }\n+}\n+\n #[cfg(any(target_os = \"freebsd\", target_os = \"netbsd\"))]\n mod imp {\n     use crate::ptr;"}]}