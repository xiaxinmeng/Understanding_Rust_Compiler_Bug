{"sha": "651cf58f2e906fa6d333013891adca5074440bea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MWNmNThmMmU5MDZmYTZkMzMzMDEzODkxYWRjYTUwNzQ0NDBiZWE=", "commit": {"author": {"name": "Cristi Cobzarenco", "email": "cristi.cobzarenco@gmail.com", "date": "2016-10-15T15:32:14Z"}, "committer": {"name": "Cristi Cobzarenco", "email": "cristi.cobzarenco@gmail.com", "date": "2016-11-05T00:50:41Z"}, "message": "Add `{into,from}_raw` to Rc and Arc", "tree": {"sha": "0a9de6025b1d0605d854beb2cbfbda06fb91c4d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a9de6025b1d0605d854beb2cbfbda06fb91c4d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/651cf58f2e906fa6d333013891adca5074440bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/651cf58f2e906fa6d333013891adca5074440bea", "html_url": "https://github.com/rust-lang/rust/commit/651cf58f2e906fa6d333013891adca5074440bea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/651cf58f2e906fa6d333013891adca5074440bea/comments", "author": {"login": "cristicbz", "id": 801328, "node_id": "MDQ6VXNlcjgwMTMyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/801328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cristicbz", "html_url": "https://github.com/cristicbz", "followers_url": "https://api.github.com/users/cristicbz/followers", "following_url": "https://api.github.com/users/cristicbz/following{/other_user}", "gists_url": "https://api.github.com/users/cristicbz/gists{/gist_id}", "starred_url": "https://api.github.com/users/cristicbz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cristicbz/subscriptions", "organizations_url": "https://api.github.com/users/cristicbz/orgs", "repos_url": "https://api.github.com/users/cristicbz/repos", "events_url": "https://api.github.com/users/cristicbz/events{/privacy}", "received_events_url": "https://api.github.com/users/cristicbz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cristicbz", "id": 801328, "node_id": "MDQ6VXNlcjgwMTMyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/801328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cristicbz", "html_url": "https://github.com/cristicbz", "followers_url": "https://api.github.com/users/cristicbz/followers", "following_url": "https://api.github.com/users/cristicbz/following{/other_user}", "gists_url": "https://api.github.com/users/cristicbz/gists{/gist_id}", "starred_url": "https://api.github.com/users/cristicbz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cristicbz/subscriptions", "organizations_url": "https://api.github.com/users/cristicbz/orgs", "repos_url": "https://api.github.com/users/cristicbz/repos", "events_url": "https://api.github.com/users/cristicbz/events{/privacy}", "received_events_url": "https://api.github.com/users/cristicbz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d34318dd538bf4c9175e4138b3e4188ea8211620", "url": "https://api.github.com/repos/rust-lang/rust/commits/d34318dd538bf4c9175e4138b3e4188ea8211620", "html_url": "https://github.com/rust-lang/rust/commit/d34318dd538bf4c9175e4138b3e4188ea8211620"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "5db5a315f4adde7fb23527650c396f753f775876", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=651cf58f2e906fa6d333013891adca5074440bea", "patch": "@@ -270,6 +270,68 @@ impl<T> Arc<T> {\n             Ok(elem)\n         }\n     }\n+\n+    /// Consumes the `Arc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n+    /// [`Arc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Arc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub fn into_raw(this: Self) -> *mut T {\n+        let ptr = unsafe { &mut (**this.ptr).data as *mut _ };\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Arc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Arc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Arc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Arc` to prevent leak.\n+    ///     let x = Arc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        // To find the corresponding pointer to the `ArcInner` we need to subtract the offset of the\n+        // `data` field from the pointer.\n+        Arc { ptr: Shared::new((ptr as *mut u8).offset(-offset_of!(ArcInner<T>, data)) as *mut _) }\n+    }\n }\n \n impl<T: ?Sized> Arc<T> {\n@@ -1179,6 +1241,23 @@ mod tests {\n         assert_eq!(Arc::try_unwrap(x), Ok(5));\n     }\n \n+    #[test]\n+    fn into_from_raw() {\n+        let x = Arc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Arc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Arc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n     #[test]\n     fn test_cowarc_clone_make_mut() {\n         let mut cow0 = Arc::new(75);"}, {"sha": "0d450184ed8773fc10339485ef53d11a638e35eb", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=651cf58f2e906fa6d333013891adca5074440bea", "patch": "@@ -99,6 +99,10 @@\n #[macro_use]\n extern crate std;\n \n+// Module with internal macros used by other modules (needs to be included before other modules).\n+#[macro_use]\n+mod macros;\n+\n // Heaps provided for low-level allocation strategies\n \n pub mod heap;"}, {"sha": "7da91c87e967e5beff35a4e4795985115934cb24", "filename": "src/liballoc/macros.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=651cf58f2e906fa6d333013891adca5074440bea", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Private macro to get the offset of a struct field in bytes from the address of the struct.\n+macro_rules! offset_of {\n+    ($container:path, $field:ident) => {{\n+        // Make sure the field actually exists. This line ensures that a compile-time error is\n+        // generated if $field is accessed through a Deref impl.\n+        let $container { $field : _, .. };\n+\n+        // Create an (invalid) instance of the container and calculate the offset to its\n+        // field. Using a null pointer might be UB if `&(*(0 as *const T)).field` is interpreted to\n+        // be nullptr deref.\n+        let invalid: $container = ::core::mem::uninitialized();\n+        let offset = &invalid.$field as *const _ as usize - &invalid as *const _ as usize;\n+\n+        // Do not run destructors on the made up invalid instance.\n+        ::core::mem::forget(invalid);\n+        offset as isize\n+    }};\n+}"}, {"sha": "bd87abc720dcb69341ee1e94618e9a75ea12e2e8", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/651cf58f2e906fa6d333013891adca5074440bea/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=651cf58f2e906fa6d333013891adca5074440bea", "patch": "@@ -363,6 +363,68 @@ impl<T> Rc<T> {\n     pub fn would_unwrap(this: &Self) -> bool {\n         Rc::strong_count(&this) == 1\n     }\n+\n+    /// Consumes the `Rc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Rc` using\n+    /// [`Rc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Rc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let x_ptr = Rc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub fn into_raw(this: Self) -> *mut T {\n+        let ptr = unsafe { &mut (**this.ptr).value as *mut _ };\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Rc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Rc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Rc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let x = Rc::new(10);\n+    /// let x_ptr = Rc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Rc` to prevent leak.\n+    ///     let x = Rc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[unstable(feature = \"rc_raw\", issue = \"37197\")]\n+    pub unsafe fn from_raw(ptr: *mut T) -> Self {\n+        // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n+        // `value` field from the pointer.\n+        Rc { ptr: Shared::new((ptr as *mut u8).offset(-offset_of!(RcBox<T>, value)) as *mut _) }\n+    }\n }\n \n impl<T: ?Sized> Rc<T> {\n@@ -1261,6 +1323,23 @@ mod tests {\n         assert_eq!(Rc::try_unwrap(x), Ok(5));\n     }\n \n+    #[test]\n+    fn into_from_raw() {\n+        let x = Rc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Rc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Rc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n     #[test]\n     fn get_mut() {\n         let mut x = Rc::new(3);"}]}