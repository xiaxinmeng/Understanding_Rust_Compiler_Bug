{"sha": "dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "node_id": "C_kwDOAAsO6NoAKGRjMTdlNzMxN2I3YmQ2ZDU4NWFiYWZhNGQ5MjdkY2Y4NzZkYzRkMTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T10:22:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-27T10:22:40Z"}, "message": "Auto merge of #10797 - est31:manual_let_else_pattern, r=llogiq\n\nImprove pattern printing for manual_let_else\n\n* Address a formatting issue pointed out in https://github.com/rust-lang/rust-clippy/pull/10175/files#r1137091002\n* Replace variables inside | patterns in the if let: `let v = if let V::A(v) | V::B(v) = v { v } else ...`\n* Support nested patterns: `let v = if let Ok(Ok(Ok(v))) = v { v } else ...`\n* Support tuple structs with more than one arg: `let v = V::W(v, _) = v { v } else ...`; note that more than one *capture* is still not supported, so it bails for `let (v, w) = if let E::F(vi, wi) = x { (vi, wi)}`\n* Correctly handle .. in tuple struct patterns: `let v = V::X(v, ..) = v { v } else ...`\n\n- \\[ ] Followed [lint naming conventions][lint_naming]\n- \\[x] Added passing UI tests (including committed `.stderr` file)\n- \\[x] `cargo test` passes locally\n- \\[ ] Executed `cargo dev update_lints`\n- \\[ ] Added lint documentation\n- \\[x] Run `cargo dev fmt`\n\n[lint_naming]: https://rust-lang.github.io/rfcs/0344-conventions-galore.html#lints\n\n---\n\nchangelog: [`manual_let_else`]: improve variable name in suggestions\n\nCloses #10431 as this PR is adding a test for the `mut` case.", "tree": {"sha": "f1de6ecaca6a05b7fc0d53e135bb683eb4f09901", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1de6ecaca6a05b7fc0d53e135bb683eb4f09901"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "html_url": "https://github.com/rust-lang/rust/commit/dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9ddcf0d06fded254fb185cb45830684383a96eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9ddcf0d06fded254fb185cb45830684383a96eb", "html_url": "https://github.com/rust-lang/rust/commit/c9ddcf0d06fded254fb185cb45830684383a96eb"}, {"sha": "ef38662d044714f55c87a12571bd30da51c199aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef38662d044714f55c87a12571bd30da51c199aa", "html_url": "https://github.com/rust-lang/rust/commit/ef38662d044714f55c87a12571bd30da51c199aa"}], "stats": {"total": 221, "additions": 144, "deletions": 77}, "files": [{"sha": "389b0a4a62dc55b70a2df1acd7da510a6e34995b", "filename": "clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 99, "deletions": 65, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "patch": "@@ -77,53 +77,54 @@ impl<'tcx> LateLintPass<'tcx> for ManualLetElse {\n             local.els.is_none() &&\n             local.ty.is_none() &&\n             init.span.ctxt() == stmt.span.ctxt() &&\n-            let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init) {\n-        match if_let_or_match {\n-            IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n-                if expr_is_simple_identity(let_pat, if_then);\n-                if let Some(if_else) = if_else;\n-                if expr_diverges(cx, if_else);\n-                then {\n-                    emit_manual_let_else(cx, stmt.span, if_let_expr, local.pat, let_pat, if_else);\n-                }\n-            },\n-            IfLetOrMatch::Match(match_expr, arms, source) => {\n-                if self.matches_behaviour == MatchLintBehaviour::Never {\n-                    return;\n-                }\n-                if source != MatchSource::Normal {\n-                    return;\n-                }\n-                // Any other number than two arms doesn't (necessarily)\n-                // have a trivial mapping to let else.\n-                if arms.len() != 2 {\n-                    return;\n-                }\n-                // Guards don't give us an easy mapping either\n-                if arms.iter().any(|arm| arm.guard.is_some()) {\n-                    return;\n-                }\n-                let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n-                let diverging_arm_opt = arms\n-                    .iter()\n-                    .enumerate()\n-                    .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n-                let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n-                // If the non-diverging arm is the first one, its pattern can be reused in a let/else statement.\n-                // However, if it arrives in second position, its pattern may cover some cases already covered\n-                // by the diverging one.\n-                // TODO: accept the non-diverging arm as a second position if patterns are disjointed.\n-                if idx == 0 {\n-                    return;\n-                }\n-                let pat_arm = &arms[1 - idx];\n-                if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n-                    return;\n-                }\n+            let Some(if_let_or_match) = IfLetOrMatch::parse(cx, init)\n+        {\n+            match if_let_or_match {\n+                IfLetOrMatch::IfLet(if_let_expr, let_pat, if_then, if_else) => if_chain! {\n+                    if expr_is_simple_identity(let_pat, if_then);\n+                    if let Some(if_else) = if_else;\n+                    if expr_diverges(cx, if_else);\n+                    then {\n+                        emit_manual_let_else(cx, stmt.span, if_let_expr, local.pat, let_pat, if_else);\n+                    }\n+                },\n+                IfLetOrMatch::Match(match_expr, arms, source) => {\n+                    if self.matches_behaviour == MatchLintBehaviour::Never {\n+                        return;\n+                    }\n+                    if source != MatchSource::Normal {\n+                        return;\n+                    }\n+                    // Any other number than two arms doesn't (necessarily)\n+                    // have a trivial mapping to let else.\n+                    if arms.len() != 2 {\n+                        return;\n+                    }\n+                    // Guards don't give us an easy mapping either\n+                    if arms.iter().any(|arm| arm.guard.is_some()) {\n+                        return;\n+                    }\n+                    let check_types = self.matches_behaviour == MatchLintBehaviour::WellKnownTypes;\n+                    let diverging_arm_opt = arms\n+                        .iter()\n+                        .enumerate()\n+                        .find(|(_, arm)| expr_diverges(cx, arm.body) && pat_allowed_for_else(cx, arm.pat, check_types));\n+                    let Some((idx, diverging_arm)) = diverging_arm_opt else { return; };\n+                    // If the non-diverging arm is the first one, its pattern can be reused in a let/else statement.\n+                    // However, if it arrives in second position, its pattern may cover some cases already covered\n+                    // by the diverging one.\n+                    // TODO: accept the non-diverging arm as a second position if patterns are disjointed.\n+                    if idx == 0 {\n+                        return;\n+                    }\n+                    let pat_arm = &arms[1 - idx];\n+                    if !expr_is_simple_identity(pat_arm.pat, pat_arm.body) {\n+                        return;\n+                    }\n \n-                emit_manual_let_else(cx, stmt.span, match_expr, local.pat, pat_arm.pat, diverging_arm.body);\n-            },\n-        }\n+                    emit_manual_let_else(cx, stmt.span, match_expr, local.pat, pat_arm.pat, diverging_arm.body);\n+                },\n+            }\n         };\n     }\n \n@@ -145,10 +146,9 @@ fn emit_manual_let_else(\n         \"this could be rewritten as `let...else`\",\n         |diag| {\n             // This is far from perfect, for example there needs to be:\n-            // * mut additions for the bindings\n-            // * renamings of the bindings for `PatKind::Or`\n+            // * tracking for multi-binding cases: let (foo, bar) = if let (Some(foo), Ok(bar)) = ...\n+            // * renamings of the bindings for many `PatKind`s like structs, slices, etc.\n             // * unused binding collision detection with existing ones\n-            // * putting patterns with at the top level | inside ()\n             // for this to be machine applicable.\n             let mut app = Applicability::HasPlaceholders;\n             let (sn_expr, _) = snippet_with_context(cx, expr.span, span.ctxt(), \"\", &mut app);\n@@ -159,28 +159,62 @@ fn emit_manual_let_else(\n             } else {\n                 format!(\"{{ {sn_else} }}\")\n             };\n-            let sn_bl = match pat.kind {\n-                PatKind::Or(..) => {\n-                    let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", &mut app);\n-                    format!(\"({sn_pat})\")\n-                },\n-                // Replace the variable name iff `TupleStruct` has one argument like `Variant(v)`.\n-                PatKind::TupleStruct(ref w, args, ..) if args.len() == 1 => {\n-                    let sn_wrapper = cx.sess().source_map().span_to_snippet(w.span()).unwrap_or_default();\n-                    let (sn_inner, _) = snippet_with_context(cx, local.span, span.ctxt(), \"\", &mut app);\n-                    format!(\"{sn_wrapper}({sn_inner})\")\n-                },\n-                _ => {\n-                    let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", &mut app);\n-                    sn_pat.into_owned()\n-                },\n-            };\n+            let sn_bl = replace_in_pattern(cx, span, local, pat, &mut app);\n             let sugg = format!(\"let {sn_bl} = {sn_expr} else {else_bl};\");\n             diag.span_suggestion(span, \"consider writing\", sugg, app);\n         },\n     );\n }\n \n+// replaces the locals in the pattern\n+fn replace_in_pattern(\n+    cx: &LateContext<'_>,\n+    span: Span,\n+    local: &Pat<'_>,\n+    pat: &Pat<'_>,\n+    app: &mut Applicability,\n+) -> String {\n+    let mut bindings_count = 0;\n+    pat.each_binding_or_first(&mut |_, _, _, _| bindings_count += 1);\n+    // If the pattern creates multiple bindings, exit early,\n+    // as otherwise we might paste the pattern to the positions of multiple bindings.\n+    if bindings_count > 1 {\n+        let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", app);\n+        return sn_pat.into_owned();\n+    }\n+\n+    match pat.kind {\n+        PatKind::Binding(..) => {\n+            let (sn_bdg, _) = snippet_with_context(cx, local.span, span.ctxt(), \"\", app);\n+            return sn_bdg.to_string();\n+        },\n+        PatKind::Or(pats) => {\n+            let patterns = pats\n+                .iter()\n+                .map(|pat| replace_in_pattern(cx, span, local, pat, app))\n+                .collect::<Vec<_>>();\n+            let or_pat = patterns.join(\" | \");\n+            return format!(\"({or_pat})\");\n+        },\n+        // Replace the variable name iff `TupleStruct` has one argument like `Variant(v)`.\n+        PatKind::TupleStruct(ref w, args, dot_dot_pos) => {\n+            let mut args = args\n+                .iter()\n+                .map(|pat| replace_in_pattern(cx, span, local, pat, app))\n+                .collect::<Vec<_>>();\n+            if let Some(pos) = dot_dot_pos.as_opt_usize() {\n+                args.insert(pos, \"..\".to_owned());\n+            }\n+            let args = args.join(\", \");\n+            let sn_wrapper = cx.sess().source_map().span_to_snippet(w.span()).unwrap_or_default();\n+            return format!(\"{sn_wrapper}({args})\");\n+        },\n+        _ => {},\n+    }\n+    let (sn_pat, _) = snippet_with_context(cx, pat.span, span.ctxt(), \"\", app);\n+    sn_pat.into_owned()\n+}\n+\n /// Check whether an expression is divergent. May give false negatives.\n fn expr_diverges(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     struct V<'cx, 'tcx> {"}, {"sha": "351ea0e4f509ea9919fc00ab392816d694d4c820", "filename": "tests/ui/manual_let_else.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.rs?ref=dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "patch": "@@ -146,10 +146,20 @@ fn fire() {\n         Variant::A(0, 0)\n     }\n \n-    // Should not be renamed\n     let v = if let Variant::A(a, 0) = e() { a } else { return };\n-    // Should be renamed\n-    let v = if let Variant::B(b) = e() { b } else { return };\n+\n+    // `mut v` is inserted into the pattern\n+    let mut v = if let Variant::B(b) = e() { b } else { return };\n+\n+    // Nesting works\n+    let nested = Ok(Some(e()));\n+    let v = if let Ok(Some(Variant::B(b))) | Err(Some(Variant::A(b, _))) = nested {\n+        b\n+    } else {\n+        return;\n+    };\n+    // dot dot works\n+    let v = if let Variant::A(.., a) = e() { a } else { return };\n }\n \n fn not_fire() {"}, {"sha": "0e876797134746dc3bafb84959730d6e6b017eae", "filename": "tests/ui/manual_let_else.stderr", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.stderr?ref=dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "patch": "@@ -260,25 +260,48 @@ LL |     create_binding_if_some!(w, g());\n    = note: this error originates in the macro `create_binding_if_some` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:150:5\n+  --> $DIR/manual_let_else.rs:149:5\n    |\n LL |     let v = if let Variant::A(a, 0) = e() { a } else { return };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::A(a, 0) = e() else { return };`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::A(v, 0) = e() else { return };`\n \n error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else.rs:152:5\n    |\n-LL |     let v = if let Variant::B(b) = e() { b } else { return };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::B(v) = e() else { return };`\n+LL |     let mut v = if let Variant::B(b) = e() { b } else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::B(mut v) = e() else { return };`\n \n error: this could be rewritten as `let...else`\n-  --> $DIR/manual_let_else.rs:262:5\n+  --> $DIR/manual_let_else.rs:156:5\n+   |\n+LL | /     let v = if let Ok(Some(Variant::B(b))) | Err(Some(Variant::A(b, _))) = nested {\n+LL | |         b\n+LL | |     } else {\n+LL | |         return;\n+LL | |     };\n+   | |______^\n+   |\n+help: consider writing\n+   |\n+LL ~     let (Ok(Some(Variant::B(v))) | Err(Some(Variant::A(v, _)))) = nested else {\n+LL +         return;\n+LL +     };\n+   |\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:162:5\n+   |\n+LL |     let v = if let Variant::A(.., a) = e() { a } else { return };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider writing: `let Variant::A(.., v) = e() else { return };`\n+\n+error: this could be rewritten as `let...else`\n+  --> $DIR/manual_let_else.rs:272:5\n    |\n LL | /     let _ = match ff {\n LL | |         Some(value) => value,\n LL | |         _ => macro_call!(),\n LL | |     };\n    | |______^ help: consider writing: `let Some(_) = ff else { macro_call!() };`\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "dfca3b023cd58259d7e7d683c40266d82a56bc60", "filename": "tests/ui/manual_let_else_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.rs?ref=dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "patch": "@@ -68,7 +68,7 @@ fn fire() {\n     let f = Variant::Bar(1);\n \n     let _value = match f {\n-        Variant::Bar(_) | Variant::Baz(_) => (),\n+        Variant::Bar(v) | Variant::Baz(v) => v,\n         _ => return,\n     };\n "}, {"sha": "13ed35bc1d5dbdb8896ae018ce754ac756afc85e", "filename": "tests/ui/manual_let_else_match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc17e7317b7bd6d585abafa4d927dcf876dc4d18/tests%2Fui%2Fmanual_let_else_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else_match.stderr?ref=dc17e7317b7bd6d585abafa4d927dcf876dc4d18", "patch": "@@ -58,10 +58,10 @@ error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:70:5\n    |\n LL | /     let _value = match f {\n-LL | |         Variant::Bar(_) | Variant::Baz(_) => (),\n+LL | |         Variant::Bar(v) | Variant::Baz(v) => v,\n LL | |         _ => return,\n LL | |     };\n-   | |______^ help: consider writing: `let (Variant::Bar(_) | Variant::Baz(_)) = f else { return };`\n+   | |______^ help: consider writing: `let (Variant::Bar(_value) | Variant::Baz(_value)) = f else { return };`\n \n error: this could be rewritten as `let...else`\n   --> $DIR/manual_let_else_match.rs:76:5"}]}