{"sha": "518c78fbd30849b379e25c54584c6d8541d33eb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOGM3OGZiZDMwODQ5YjM3OWUyNWM1NDU4NGM2ZDg1NDFkMzNlYjE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-07T12:13:35Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-03-14T21:52:28Z"}, "message": "Create Map after TyCtxt", "tree": {"sha": "39fd60a1a4bd572fc2d6040066bc1bdf02fe1a21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39fd60a1a4bd572fc2d6040066bc1bdf02fe1a21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/518c78fbd30849b379e25c54584c6d8541d33eb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/518c78fbd30849b379e25c54584c6d8541d33eb1", "html_url": "https://github.com/rust-lang/rust/commit/518c78fbd30849b379e25c54584c6d8541d33eb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/518c78fbd30849b379e25c54584c6d8541d33eb1/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21386e1355a1aa5b8709d969d7fef878b4602491", "url": "https://api.github.com/repos/rust-lang/rust/commits/21386e1355a1aa5b8709d969d7fef878b4602491", "html_url": "https://github.com/rust-lang/rust/commit/21386e1355a1aa5b8709d969d7fef878b4602491"}], "stats": {"total": 287, "additions": 130, "deletions": 157}, "files": [{"sha": "223bed5d635e5ab45df2e6d2d4c60e9659ec4f00", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -163,6 +163,8 @@ macro_rules! arena_types {\n             [] where_predicate: rustc_hir::WherePredicate<$tcx>,\n \n             // HIR query types\n+            [few] hir_map: rustc::hir::map::Map<$tcx>,\n+            [few] hir_definitions: rustc::hir::map::definitions::Definitions,\n             [] hir_owner: rustc::hir::HirOwner<$tcx>,\n             [] hir_owner_items: rustc::hir::HirOwnerItems<$tcx>,\n         ], $tcx);"}, {"sha": "0ac8f403cb7c983a1edaf890786a16d17dac54a4", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -209,6 +209,12 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         FxHashMap<DefIndex, &'hir mut HirOwnerItems<'hir>>,\n         Svh,\n     ) {\n+        // Insert bodies into the map\n+        for (id, body) in self.krate.bodies.iter() {\n+            let bodies = &mut self.owner_items_map.get_mut(&id.hir_id.owner).unwrap().bodies;\n+            assert!(bodies.insert(id.hir_id.local_id, body).is_none());\n+        }\n+\n         self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n         let node_hashes = self.hir_body_nodes.iter().fold("}, {"sha": "ef000f23d8baf26fab15582c9d669b7056523e05", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -1,15 +1,15 @@\n-use crate::hir::map::Map;\n-use rustc_data_structures::fx::FxHashSet;\n+use crate::hir::map::EarlyMap;\n+/*use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{HirId, ItemLocalId};\n+use rustc_hir::{HirId, ItemLocalId};*/\n \n-pub fn check_crate(hir_map: &Map<'_>, sess: &rustc_session::Session) {\n+pub fn check_crate(hir_map: &EarlyMap<'_>, sess: &rustc_session::Session) {\n     hir_map.dep_graph.assert_ignored();\n-\n+    /*\n     let errors = Lock::new(Vec::new());\n \n     par_iter(&hir_map.krate.modules).for_each(|(module_id, _)| {\n@@ -25,23 +25,23 @@ pub fn check_crate(hir_map: &Map<'_>, sess: &rustc_session::Session) {\n     if !errors.is_empty() {\n         let message = errors.iter().fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n         sess.delay_span_bug(rustc_span::DUMMY_SP, &message);\n-    }\n+    }*/\n }\n-\n+/*\n struct HirIdValidator<'a, 'hir> {\n-    hir_map: &'a Map<'hir>,\n+    hir_map: &'a EarlyMap<'hir>,\n     owner_def_index: Option<DefIndex>,\n     hir_ids_seen: FxHashSet<ItemLocalId>,\n     errors: &'a Lock<Vec<String>>,\n }\n \n struct OuterVisitor<'a, 'hir> {\n-    hir_map: &'a Map<'hir>,\n+    hir_map: &'a EarlyMap<'hir>,\n     errors: &'a Lock<Vec<String>>,\n }\n \n impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n-    fn new_inner_visitor(&self, hir_map: &'a Map<'hir>) -> HirIdValidator<'a, 'hir> {\n+    fn new_inner_visitor(&self, hir_map: &'a EarlyMap<'hir>) -> HirIdValidator<'a, 'hir> {\n         HirIdValidator {\n             hir_map,\n             owner_def_index: None,\n@@ -133,7 +133,7 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n }\n \n impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n-    type Map = Map<'hir>;\n+    type Map = EarlyMap<'hir>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<'_, Self::Map> {\n         intravisit::NestedVisitorMap::OnlyBodies(self.hir_map)\n@@ -173,3 +173,4 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         // different owner.\n     }\n }\n+*/"}, {"sha": "6b22ac01a0670cf3acc8c590c67db767cc654156", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 35, "deletions": 128, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -8,6 +8,7 @@ use crate::dep_graph::{DepGraph, DepKind, DepNode, DepNodeIndex};\n use crate::hir::{HirOwner, HirOwnerItems};\n use crate::middle::cstore::CrateStoreDyn;\n use crate::ty::query::Providers;\n+use crate::ty::TyCtxt;\n use rustc_ast::ast::{self, Name, NodeId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n@@ -138,9 +139,30 @@ impl<'hir> Entry<'hir> {\n pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Option<Entry<'hir>>>>;\n \n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n-#[derive(Clone)]\n+pub struct EarlyMap<'hir> {\n+    pub krate: &'hir Crate<'hir>,\n+\n+    pub dep_graph: DepGraph,\n+\n+    /// The SVH of the local crate.\n+    pub crate_hash: Svh,\n+\n+    pub(super) owner_map: FxHashMap<DefIndex, &'hir HirOwner<'hir>>,\n+    pub(super) owner_items_map: FxHashMap<DefIndex, &'hir HirOwnerItems<'hir>>,\n+\n+    pub(super) map: HirEntryMap<'hir>,\n+\n+    pub(crate) definitions: &'hir Definitions,\n+\n+    /// The reverse mapping of `node_to_hir_id`.\n+    pub(super) hir_to_node_id: FxHashMap<HirId, NodeId>,\n+}\n+\n+/// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n pub struct Map<'hir> {\n-    krate: &'hir Crate<'hir>,\n+    pub(super) tcx: TyCtxt<'hir>,\n+\n+    pub(super) krate: &'hir Crate<'hir>,\n \n     pub dep_graph: DepGraph,\n \n@@ -150,12 +172,12 @@ pub struct Map<'hir> {\n     pub(super) owner_map: FxHashMap<DefIndex, &'hir HirOwner<'hir>>,\n     pub(super) owner_items_map: FxHashMap<DefIndex, &'hir HirOwnerItems<'hir>>,\n \n-    map: HirEntryMap<'hir>,\n+    pub(super) map: HirEntryMap<'hir>,\n \n-    definitions: Definitions,\n+    pub(super) definitions: &'hir Definitions,\n \n     /// The reverse mapping of `node_to_hir_id`.\n-    hir_to_node_id: FxHashMap<HirId, NodeId>,\n+    pub(super) hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n /// An iterator that walks up the ancestor tree of a given `HirId`.\n@@ -406,11 +428,11 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.read(id.hir_id);\n-\n-        // N.B., intentionally bypass `self.krate()` so that we\n-        // do not trigger a read of the whole krate here\n-        self.krate.body(id)\n+        self.tcx\n+            .hir_owner_items(DefId::local(id.hir_id.owner))\n+            .bodies\n+            .get(&id.hir_id.local_id)\n+            .unwrap()\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n@@ -966,45 +988,6 @@ impl<'hir> Map<'hir> {\n         attrs.unwrap_or(&[])\n     }\n \n-    /// Returns an iterator that yields all the hir ids in the map.\n-    fn all_ids<'a>(&'a self) -> impl Iterator<Item = HirId> + 'a {\n-        // This code is a bit awkward because the map is implemented as 2 levels of arrays,\n-        // see the comment on `HirEntryMap`.\n-        // Iterate over all the indices and return a reference to\n-        // local maps and their index given that they exist.\n-        self.map.iter_enumerated().flat_map(move |(owner, local_map)| {\n-            // Iterate over each valid entry in the local map.\n-            local_map.iter_enumerated().filter_map(move |(i, entry)| {\n-                entry.map(move |_| {\n-                    // Reconstruct the `HirId` based on the 3 indices we used to find it.\n-                    HirId { owner, local_id: i }\n-                })\n-            })\n-        })\n-    }\n-\n-    /// Returns an iterator that yields the node id's with paths that\n-    /// match `parts`.  (Requires `parts` is non-empty.)\n-    ///\n-    /// For example, if given `parts` equal to `[\"bar\", \"quux\"]`, then\n-    /// the iterator will produce node id's for items with paths\n-    /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n-    /// any other such items it can find in the map.\n-    pub fn nodes_matching_suffix<'a>(\n-        &'a self,\n-        parts: &'a [String],\n-    ) -> impl Iterator<Item = NodeId> + 'a {\n-        let nodes = NodesMatchingSuffix {\n-            map: self,\n-            item_name: parts.last().unwrap(),\n-            in_which: &parts[..parts.len() - 1],\n-        };\n-\n-        self.all_ids()\n-            .filter(move |hir| nodes.matches_suffix(*hir))\n-            .map(move |hir| self.hir_to_node_id(hir))\n-    }\n-\n     pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n@@ -1087,82 +1070,6 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a> {\n-    map: &'a Map<'a>,\n-    item_name: &'a String,\n-    in_which: &'a [String],\n-}\n-\n-impl<'a> NodesMatchingSuffix<'a> {\n-    /// Returns `true` only if some suffix of the module path for parent\n-    /// matches `self.in_which`.\n-    ///\n-    /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;\n-    /// returns true if parent's path ends with the suffix\n-    /// `x_0::x_1::...::x_k`.\n-    fn suffix_matches(&self, parent: HirId) -> bool {\n-        let mut cursor = parent;\n-        for part in self.in_which.iter().rev() {\n-            let (mod_id, mod_name) = match find_first_mod_parent(self.map, cursor) {\n-                None => return false,\n-                Some((node_id, name)) => (node_id, name),\n-            };\n-            if mod_name.as_str() != *part {\n-                return false;\n-            }\n-            cursor = self.map.get_parent_item(mod_id);\n-        }\n-        return true;\n-\n-        // Finds the first mod in parent chain for `id`, along with\n-        // that mod's name.\n-        //\n-        // If `id` itself is a mod named `m` with parent `p`, then\n-        // returns `Some(id, m, p)`.  If `id` has no mod in its parent\n-        // chain, then returns `None`.\n-        fn find_first_mod_parent(map: &Map<'_>, mut id: HirId) -> Option<(HirId, Name)> {\n-            loop {\n-                if let Node::Item(item) = map.find(id)? {\n-                    if item_is_mod(&item) {\n-                        return Some((id, item.ident.name));\n-                    }\n-                }\n-                let parent = map.get_parent_item(id);\n-                if parent == id {\n-                    return None;\n-                }\n-                id = parent;\n-            }\n-\n-            fn item_is_mod(item: &Item<'_>) -> bool {\n-                match item.kind {\n-                    ItemKind::Mod(_) => true,\n-                    _ => false,\n-                }\n-            }\n-        }\n-    }\n-\n-    // We are looking at some node `n` with a given name and parent\n-    // id; do their names match what I am seeking?\n-    fn matches_names(&self, parent_of_n: HirId, name: Name) -> bool {\n-        name.as_str() == *self.item_name && self.suffix_matches(parent_of_n)\n-    }\n-\n-    fn matches_suffix(&self, hir: HirId) -> bool {\n-        let name = match self.map.find_entry(hir).map(|entry| entry.node) {\n-            Some(Node::Item(n)) => n.name(),\n-            Some(Node::ForeignItem(n)) => n.name(),\n-            Some(Node::TraitItem(n)) => n.name(),\n-            Some(Node::ImplItem(n)) => n.name(),\n-            Some(Node::Variant(n)) => n.name(),\n-            Some(Node::Field(n)) => n.name(),\n-            _ => return false,\n-        };\n-        self.matches_names(self.map.get_parent_item(hir), name)\n-    }\n-}\n-\n trait Named {\n     fn name(&self) -> Name;\n }\n@@ -1211,7 +1118,7 @@ pub fn map_crate<'hir>(\n     krate: &'hir Crate<'hir>,\n     dep_graph: DepGraph,\n     definitions: Definitions,\n-) -> Map<'hir> {\n+) -> EarlyMap<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n \n     // Build the reverse mapping of `node_to_hir_id`.\n@@ -1233,15 +1140,15 @@ pub fn map_crate<'hir>(\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, cstore, cmdline_args)\n     };\n \n-    let map = Map {\n+    let map = EarlyMap {\n         krate,\n         dep_graph,\n         crate_hash,\n         map,\n         owner_map,\n         owner_items_map: owner_items_map.into_iter().map(|(k, v)| (k, &*v)).collect(),\n         hir_to_node_id,\n-        definitions,\n+        definitions: arena.alloc(definitions),\n     };\n \n     sess.time(\"validate_HIR_map\", || {"}, {"sha": "d7999ee5f515d82074d3400c0fdaeccc7eaf7d38", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -7,6 +7,7 @@ pub mod map;\n \n use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n+use rustc_data_structures::cold_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::print;\n@@ -68,7 +69,17 @@ impl<'hir> print::PpAnn for Hir<'hir> {\n impl<'tcx> TyCtxt<'tcx> {\n     #[inline(always)]\n     pub fn hir(self) -> Hir<'tcx> {\n-        Hir { tcx: self, map: &self.hir_map }\n+        let map = self.late_hir_map.load();\n+        let map = if unlikely!(map.is_none()) {\n+            cold_path(|| {\n+                let map = self.hir_map(LOCAL_CRATE);\n+                self.late_hir_map.store(Some(map));\n+                map\n+            })\n+        } else {\n+            map.unwrap()\n+        };\n+        Hir { tcx: self, map }\n     }\n \n     pub fn parent_module(self, id: HirId) -> DefId {\n@@ -81,6 +92,35 @@ pub fn provide(providers: &mut Providers<'_>) {\n         let hir = tcx.hir();\n         hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id).unwrap()))\n     };\n-    providers.hir_crate = |tcx, _| tcx.hir_map.untracked_krate();\n+    providers.hir_crate = |tcx, _| tcx.hir_map(LOCAL_CRATE).untracked_krate();\n+    providers.hir_map = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        let early = tcx.hir_map.steal();\n+        tcx.arena.alloc(map::Map {\n+            tcx,\n+            krate: early.krate,\n+\n+            dep_graph: early.dep_graph,\n+\n+            crate_hash: early.crate_hash,\n+\n+            owner_map: early.owner_map,\n+            owner_items_map: early.owner_items_map,\n+\n+            map: early.map,\n+\n+            definitions: early.definitions,\n+\n+            hir_to_node_id: early.hir_to_node_id,\n+        })\n+    };\n+    providers.hir_owner = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        *tcx.hir().map.owner_map.get(&id.index).unwrap()\n+    };\n+    providers.hir_owner_items = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        *tcx.hir().map.owner_items_map.get(&id.index).unwrap()\n+    };\n     map::provide(providers);\n }"}, {"sha": "b843bc17d2c6c52ad34cf5b43b0f057e65d7a326", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -55,6 +55,12 @@ rustc_queries! {\n             desc { \"get the crate HIR\" }\n         }\n \n+        query hir_map(_: CrateNum) -> &'tcx map::Map<'tcx> {\n+            eval_always\n+            no_hash\n+            desc { \"index HIR\" }\n+        }\n+\n         query hir_owner(key: DefId) -> &'tcx HirOwner<'tcx> {\n             eval_always\n         }"}, {"sha": "cff93015d047f78ab3287edc69f4910228bdd554", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -5,6 +5,7 @@ use crate::dep_graph::DepGraph;\n use crate::dep_graph::{self, DepConstructor};\n use crate::hir::exports::Export;\n use crate::hir::map as hir_map;\n+use crate::hir::map::definitions::Definitions;\n use crate::hir::map::{DefPathData, DefPathHash};\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n@@ -52,7 +53,7 @@ use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n-use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n+use rustc_data_structures::sync::{self, AtomicCell, Lock, Lrc, WorkerLocal};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex, LOCAL_CRATE};\n@@ -971,8 +972,11 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n \n-    /// This should usually be accessed with the `tcx.hir()` method.\n-    pub(crate) hir_map: hir_map::Map<'tcx>,\n+    /// These should usually be accessed with the `tcx.hir()` method.\n+    pub(crate) hir_map: Steal<hir_map::EarlyMap<'tcx>>,\n+    pub(crate) late_hir_map: AtomicCell<Option<&'tcx hir_map::Map<'tcx>>>,\n+    pub(crate) untracked_crate: &'tcx hir::Crate<'tcx>,\n+    pub(crate) definitions: &'tcx Definitions,\n \n     /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n@@ -1116,7 +1120,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         extern_providers: ty::query::Providers<'tcx>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n-        hir: hir_map::Map<'tcx>,\n+        hir: hir_map::EarlyMap<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n         crate_name: &str,\n         output_filenames: &OutputFilenames,\n@@ -1129,6 +1133,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n         let dep_graph = hir.dep_graph.clone();\n+        let definitions = hir.definitions;\n         let cstore = resolutions.cstore;\n         let crates = cstore.crates_untracked();\n         let max_cnum = crates.iter().map(|c| c.as_usize()).max().unwrap_or(0);\n@@ -1139,7 +1144,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let def_path_tables = crates\n                 .iter()\n                 .map(|&cnum| (cnum, cstore.def_path_table(cnum)))\n-                .chain(iter::once((LOCAL_CRATE, hir.definitions().def_path_table())));\n+                .chain(iter::once((LOCAL_CRATE, definitions.def_path_table())));\n \n             // Precompute the capacity of the hashmap so we don't have to\n             // re-allocate when populating it.\n@@ -1159,11 +1164,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in resolutions.trait_map {\n-            let hir_id = hir.node_to_hir_id(k);\n+            let hir_id = definitions.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n             let v = v\n                 .into_iter()\n-                .map(|tc| tc.map_import_ids(|id| hir.definitions().node_to_hir_id(id)))\n+                .map(|tc| tc.map_import_ids(|id| definitions.node_to_hir_id(id)))\n                 .collect();\n             map.insert(hir_id.local_id, StableVec::new(v));\n         }\n@@ -1185,28 +1190,33 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .export_map\n                 .into_iter()\n                 .map(|(k, v)| {\n-                    let exports: Vec<_> =\n-                        v.into_iter().map(|e| e.map_id(|id| hir.node_to_hir_id(id))).collect();\n+                    let exports: Vec<_> = v\n+                        .into_iter()\n+                        .map(|e| e.map_id(|id| definitions.node_to_hir_id(id)))\n+                        .collect();\n                     (k, exports)\n                 })\n                 .collect(),\n             maybe_unused_trait_imports: resolutions\n                 .maybe_unused_trait_imports\n                 .into_iter()\n-                .map(|id| hir.local_def_id_from_node_id(id))\n+                .map(|id| definitions.local_def_id(id))\n                 .collect(),\n             maybe_unused_extern_crates: resolutions\n                 .maybe_unused_extern_crates\n                 .into_iter()\n-                .map(|(id, sp)| (hir.local_def_id_from_node_id(id), sp))\n+                .map(|(id, sp)| (definitions.local_def_id(id), sp))\n                 .collect(),\n             glob_map: resolutions\n                 .glob_map\n                 .into_iter()\n-                .map(|(id, names)| (hir.local_def_id_from_node_id(id), names))\n+                .map(|(id, names)| (definitions.local_def_id(id), names))\n                 .collect(),\n             extern_prelude: resolutions.extern_prelude,\n-            hir_map: hir,\n+            untracked_crate: hir.krate,\n+            hir_map: Steal::new(hir),\n+            late_hir_map: AtomicCell::new(None),\n+            definitions,\n             def_path_hash_to_def_id,\n             queries: query::Queries::new(providers, extern_providers, on_disk_query_result_cache),\n             rcache: Default::default(),\n@@ -1286,7 +1296,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n         if def_id.is_local() {\n-            self.hir().definitions().def_path_hash(def_id.index)\n+            self.definitions.def_path_hash(def_id.index)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -1333,9 +1343,9 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let krate = self.gcx.hir_map.untracked_krate();\n+        let krate = self.gcx.untracked_crate;\n \n-        StableHashingContext::new(self.sess, krate, self.hir().definitions(), &*self.cstore)\n+        StableHashingContext::new(self.sess, krate, self.definitions, &*self.cstore)\n     }\n \n     // This method makes sure that we have a DepNode and a Fingerprint for"}, {"sha": "b6976221ef7da5de8bb5159f05240a454586fd3e", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518c78fbd30849b379e25c54584c6d8541d33eb1/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=518c78fbd30849b379e25c54584c6d8541d33eb1", "patch": "@@ -1,5 +1,6 @@\n use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n+use crate::hir::map;\n use crate::hir::{HirOwner, HirOwnerItems};\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;"}]}