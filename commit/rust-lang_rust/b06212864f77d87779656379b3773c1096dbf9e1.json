{"sha": "b06212864f77d87779656379b3773c1096dbf9e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNjIxMjg2NGY3N2Q4Nzc3OTY1NjM3OWIzNzczYzEwOTZkYmY5ZTE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-07T17:09:06Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T01:20:34Z"}, "message": "rustc: fix fallout from using ptr::P.", "tree": {"sha": "a740c647fa01982f84b982aaed82fe136982f41a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a740c647fa01982f84b982aaed82fe136982f41a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b06212864f77d87779656379b3773c1096dbf9e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b06212864f77d87779656379b3773c1096dbf9e1", "html_url": "https://github.com/rust-lang/rust/commit/b06212864f77d87779656379b3773c1096dbf9e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b06212864f77d87779656379b3773c1096dbf9e1/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d379ad111ccef354730e51edea8119341a8e7871", "url": "https://api.github.com/repos/rust-lang/rust/commits/d379ad111ccef354730e51edea8119341a8e7871", "html_url": "https://github.com/rust-lang/rust/commit/d379ad111ccef354730e51edea8119341a8e7871"}], "stats": {"total": 4026, "additions": 1956, "deletions": 2070}, "files": [{"sha": "b80d53922f8a501ba485c4015c985850f4947843", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -35,6 +35,7 @@ use std::io::fs;\n use std::os;\n use arena::TypedArena;\n use syntax::ast;\n+use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::diagnostics;\n@@ -65,7 +66,7 @@ pub fn compile_input(sess: Session,\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n     let (outputs, trans, sess) = {\n-        let (outputs, expanded_crate, ast_map, id) = {\n+        let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n             if stop_after_phase_1(&sess) { return; }\n             let outputs = build_output_filenames(input,\n@@ -75,25 +76,28 @@ pub fn compile_input(sess: Session,\n                                                  &sess);\n             let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(),\n                                            input);\n-            let (expanded_crate, ast_map)\n+            let expanded_crate\n                 = match phase_2_configure_and_expand(&sess, krate, id.as_slice(),\n                                                      addl_plugins) {\n                     None => return,\n-                    Some(p) => p,\n+                    Some(k) => k\n                 };\n \n-            (outputs, expanded_crate, ast_map, id)\n+            (outputs, expanded_crate, id)\n         };\n+\n+        let mut forest = ast_map::Forest::new(expanded_crate);\n+        let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n+\n         write_out_deps(&sess, input, &outputs, id.as_slice());\n \n         if stop_after_phase_2(&sess) { return; }\n \n         let type_arena = TypedArena::new();\n-        let analysis = phase_3_run_analysis_passes(sess, &expanded_crate,\n-                                                   ast_map, &type_arena, id);\n-        phase_save_analysis(&analysis.ty_cx.sess, &expanded_crate, &analysis, outdir);\n+        let analysis = phase_3_run_analysis_passes(sess, ast_map, &type_arena, id);\n+        phase_save_analysis(&analysis.ty_cx.sess, analysis.ty_cx.map.krate(), &analysis, outdir);\n         if stop_after_phase_3(&analysis.ty_cx.sess) { return; }\n-        let (tcx, trans) = phase_4_translate_to_llvm(expanded_crate, analysis);\n+        let (tcx, trans) = phase_4_translate_to_llvm(analysis);\n \n         // Discard interned strings as they are no longer required.\n         token::get_ident_interner().clear();\n@@ -182,7 +186,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n                                     crate_name: &str,\n                                     addl_plugins: Option<Plugins>)\n-                                    -> Option<(ast::Crate, syntax::ast_map::Map)> {\n+                                    -> Option<ast::Crate> {\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n@@ -294,20 +298,37 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     krate = time(time_passes, \"prelude injection\", krate, |krate|\n                  front::std_inject::maybe_inject_prelude(sess, krate));\n \n-    let (krate, map) = time(time_passes, \"assigning node ids and indexing ast\", krate, |krate|\n-         front::assign_node_ids_and_map::assign_node_ids_and_map(sess, krate));\n+    time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n+         syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));\n+\n+    Some(krate)\n+}\n+\n+pub fn assign_node_ids_and_map<'ast>(sess: &Session,\n+                                     forest: &'ast mut ast_map::Forest)\n+                                     -> ast_map::Map<'ast> {\n+    struct NodeIdAssigner<'a> {\n+        sess: &'a Session\n+    }\n+\n+    impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n+        fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n+            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+            self.sess.next_node_id()\n+        }\n+    }\n+\n+    let map = time(sess.time_passes(), \"assigning node ids and indexing ast\", forest, |forest|\n+                   ast_map::map_crate(forest, NodeIdAssigner { sess: sess }));\n \n     if sess.opts.debugging_opts & config::AST_JSON != 0 {\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n         // unwrapping so IoError isn't ignored\n-        krate.encode(&mut json).unwrap();\n+        map.krate().encode(&mut json).unwrap();\n     }\n \n-    time(time_passes, \"checking that all macro invocations are gone\", &krate, |krate|\n-         syntax::ext::expand::check_for_macros(&sess.parse_sess, krate));\n-\n-    Some((krate, map))\n+    map\n }\n \n pub struct CrateAnalysis<'tcx> {\n@@ -324,11 +345,11 @@ pub struct CrateAnalysis<'tcx> {\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n-                                         krate: &ast::Crate,\n-                                         ast_map: syntax::ast_map::Map,\n+                                         ast_map: ast_map::Map<'tcx>,\n                                          type_arena: &'tcx TypedArena<ty::t_box_>,\n                                          name: String) -> CrateAnalysis<'tcx> {\n     let time_passes = sess.time_passes();\n+    let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n          creader::read_crates(&sess, krate));\n@@ -353,7 +374,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                                 |_| middle::resolve_lifetime::krate(&sess, krate));\n \n     time(time_passes, \"looking for entry point\", (),\n-         |_| middle::entry::find_entry_point(&sess, krate, &ast_map));\n+         |_| middle::entry::find_entry_point(&sess, &ast_map));\n \n     sess.plugin_registrar_fn.set(\n         time(time_passes, \"looking for plugin registrar\", (), |_|\n@@ -385,43 +406,43 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n                             stability_index);\n \n     // passes are timed inside typeck\n-    typeck::check_crate(&ty_cx, trait_map, krate);\n+    typeck::check_crate(&ty_cx, trait_map);\n \n     time(time_passes, \"check static items\", (), |_|\n-         middle::check_static::check_crate(&ty_cx, krate));\n+         middle::check_static::check_crate(&ty_cx));\n \n     // These next two const passes can probably be merged\n     time(time_passes, \"const marking\", (), |_|\n-         middle::const_eval::process_crate(krate, &ty_cx));\n+         middle::const_eval::process_crate(&ty_cx));\n \n     time(time_passes, \"const checking\", (), |_|\n-         middle::check_const::check_crate(krate, &ty_cx));\n+         middle::check_const::check_crate(&ty_cx));\n \n     let maps = (external_exports, last_private_map);\n     let (exported_items, public_items) =\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n-                 middle::privacy::check_crate(&ty_cx, &exp_map2, a, b, krate));\n+                 middle::privacy::check_crate(&ty_cx, &exp_map2, a, b));\n \n     time(time_passes, \"intrinsic checking\", (), |_|\n-         middle::intrinsicck::check_crate(&ty_cx, krate));\n+         middle::intrinsicck::check_crate(&ty_cx));\n \n     time(time_passes, \"effect checking\", (), |_|\n-         middle::effect::check_crate(&ty_cx, krate));\n+         middle::effect::check_crate(&ty_cx));\n \n     time(time_passes, \"match checking\", (), |_|\n-         middle::check_match::check_crate(&ty_cx, krate));\n+         middle::check_match::check_crate(&ty_cx));\n \n     time(time_passes, \"liveness checking\", (), |_|\n-         middle::liveness::check_crate(&ty_cx, krate));\n+         middle::liveness::check_crate(&ty_cx));\n \n     time(time_passes, \"borrow checking\", (), |_|\n-         middle::borrowck::check_crate(&ty_cx, krate));\n+         middle::borrowck::check_crate(&ty_cx));\n \n     time(time_passes, \"rvalue checking\", (), |_|\n          middle::check_rvalues::check_crate(&ty_cx, krate));\n \n     time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(&ty_cx, krate));\n+         kind::check_crate(&ty_cx));\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n@@ -430,12 +451,11 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"death checking\", (), |_| {\n         middle::dead::check_crate(&ty_cx,\n                                   &exported_items,\n-                                  &reachable_map,\n-                                  krate)\n+                                  &reachable_map)\n     });\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(&ty_cx, krate, &exported_items));\n+         lint::check_crate(&ty_cx, &exported_items));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,\n@@ -475,16 +495,16 @@ pub struct CrateTranslation {\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-pub fn phase_4_translate_to_llvm(krate: ast::Crate,\n-                                 analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n+pub fn phase_4_translate_to_llvm<'tcx>(analysis: CrateAnalysis<'tcx>)\n+                                       -> (ty::ctxt<'tcx>, CrateTranslation) {\n     let time_passes = analysis.ty_cx.sess.time_passes();\n \n     time(time_passes, \"resolving dependency formats\", (), |_|\n          dependency_format::calculate(&analysis.ty_cx));\n \n     // Option dance to work around the lack of stack once closures.\n-    time(time_passes, \"translation\", (krate, analysis), |(krate, analysis)|\n-         trans::base::trans_crate(krate, analysis))\n+    time(time_passes, \"translation\", analysis, |analysis|\n+         trans::base::trans_crate(analysis))\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file"}, {"sha": "7c27f23d4857a2456e0b0231a0dc0057280d105c", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 55, "deletions": 77, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -91,13 +91,13 @@ pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifie\n \n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<A,B>(&self,\n-                                 sess: Session,\n-                                 krate: &ast::Crate,\n-                                 ast_map: Option<ast_map::Map>,\n-                                 id: String,\n-                                 payload: B,\n-                                 f: |&PrinterSupport, B| -> A) -> A {\n+    fn call_with_pp_support<'tcx, A, B>(&self,\n+                                        sess: Session,\n+                                        ast_map: Option<ast_map::Map<'tcx>>,\n+                                        type_arena: &'tcx TypedArena<ty::t_box_>,\n+                                        id: String,\n+                                        payload: B,\n+                                        f: |&PrinterSupport, B| -> A) -> A {\n         match *self {\n             PpmNormal | PpmExpanded => {\n                 let annotation = NoAnn { sess: sess, ast_map: ast_map };\n@@ -114,79 +114,60 @@ impl PpSourceMode {\n             }\n             PpmTyped => {\n                 let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let type_arena = TypedArena::new();\n-                let analysis = driver::phase_3_run_analysis_passes(sess, krate, ast_map,\n-                                                                   &type_arena, id);\n+                let analysis = driver::phase_3_run_analysis_passes(sess, ast_map,\n+                                                                   type_arena, id);\n                 let annotation = TypedAnnotation { analysis: analysis };\n                 f(&annotation, payload)\n             }\n         }\n     }\n }\n \n-trait SessionCarrier {\n+trait PrinterSupport<'ast>: pprust::PpAnn {\n     /// Provides a uniform interface for re-extracting a reference to a\n     /// `Session` from a value that now owns it.\n     fn sess<'a>(&'a self) -> &'a Session;\n-}\n \n-trait AstMapCarrier {\n     /// Provides a uniform interface for re-extracting a reference to an\n     /// `ast_map::Map` from a value that now owns it.\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map>;\n-}\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>>;\n \n-trait PrinterSupport : SessionCarrier + AstMapCarrier {\n     /// Produces the pretty-print annotation object.\n     ///\n-    /// Usually implemented via `self as &pprust::PpAnn`.\n-    ///\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n }\n \n-struct NoAnn {\n+struct NoAnn<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for NoAnn {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    ast_map: Option<ast_map::Map<'ast>>\n }\n \n-impl SessionCarrier for NoAnn {\n+impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n \n-impl AstMapCarrier for NoAnn {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n }\n \n-impl pprust::PpAnn for NoAnn {}\n+impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n \n-struct IdentifiedAnnotation {\n+struct IdentifiedAnnotation<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for IdentifiedAnnotation {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    ast_map: Option<ast_map::Map<'ast>>,\n }\n \n-impl SessionCarrier for IdentifiedAnnotation {\n+impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n \n-impl AstMapCarrier for IdentifiedAnnotation {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n }\n \n-impl pprust::PpAnn for IdentifiedAnnotation {\n+impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -222,26 +203,20 @@ impl pprust::PpAnn for IdentifiedAnnotation {\n     }\n }\n \n-struct HygieneAnnotation {\n+struct HygieneAnnotation<'ast> {\n     sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for HygieneAnnotation {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+    ast_map: Option<ast_map::Map<'ast>>,\n }\n \n-impl SessionCarrier for HygieneAnnotation {\n+impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n \n-impl AstMapCarrier for HygieneAnnotation {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'ast>> {\n         self.ast_map.as_ref()\n     }\n }\n \n-impl pprust::PpAnn for HygieneAnnotation {\n+impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self,\n             s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -266,16 +241,10 @@ struct TypedAnnotation<'tcx> {\n     analysis: CrateAnalysis<'tcx>,\n }\n \n-impl<'tcx> PrinterSupport for TypedAnnotation<'tcx> {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n-}\n-\n-impl<'tcx> SessionCarrier for TypedAnnotation<'tcx> {\n+impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n-}\n \n-impl<'tcx> AstMapCarrier for TypedAnnotation<'tcx> {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map<'tcx>> {\n         Some(&self.analysis.ty_cx.map)\n     }\n }\n@@ -347,12 +316,12 @@ impl FromStr for UserIdentifiedItem {\n     }\n }\n \n-enum NodesMatchingUII<'a> {\n+enum NodesMatchingUII<'a, 'ast: 'a> {\n     NodesMatchingDirect(option::Item<ast::NodeId>),\n-    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, String>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, 'ast, String>),\n }\n \n-impl<'a> Iterator<ast::NodeId> for NodesMatchingUII<'a> {\n+impl<'a, 'ast> Iterator<ast::NodeId> for NodesMatchingUII<'a, 'ast> {\n     fn next(&mut self) -> Option<ast::NodeId> {\n         match self {\n             &NodesMatchingDirect(ref mut iter) => iter.next(),\n@@ -369,7 +338,8 @@ impl UserIdentifiedItem {\n         }\n     }\n \n-    fn all_matching_node_ids<'a>(&'a self, map: &'a ast_map::Map) -> NodesMatchingUII<'a> {\n+    fn all_matching_node_ids<'a, 'ast>(&'a self, map: &'a ast_map::Map<'ast>)\n+                                       -> NodesMatchingUII<'a, 'ast> {\n         match *self {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).move_iter()),\n@@ -443,15 +413,24 @@ pub fn pretty_print_input(sess: Session,\n     let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n \n     let is_expanded = needs_expansion(&ppm);\n-    let (krate, ast_map) = if needs_ast_map(&ppm, &opt_uii) {\n-        let k = driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None);\n-        let (krate, ast_map) = match k {\n+    let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n+    let krate = if compute_ast_map {\n+        match driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None) {\n             None => return,\n-            Some(p) => p,\n-        };\n-        (krate, Some(ast_map))\n+            Some(k) => k\n+        }\n+    } else {\n+        krate\n+    };\n+\n+    let mut forest = ast_map::Forest::new(krate);\n+    let type_arena = TypedArena::new();\n+\n+    let (krate, ast_map) = if compute_ast_map {\n+        let map = driver::assign_node_ids_and_map(&sess, &mut forest);\n+        (map.krate(), Some(map))\n     } else {\n-        (krate, None)\n+        (forest.krate(), None)\n     };\n \n     let src_name = driver::source_name(input);\n@@ -476,12 +455,12 @@ pub fn pretty_print_input(sess: Session,\n     match (ppm, opt_uii) {\n         (PpmSource(s), None) =>\n             s.call_with_pp_support(\n-                sess, &krate, ast_map, id, out, |annotation, out| {\n+                sess, ast_map, &type_arena, id, out, |annotation, out| {\n                     debug!(\"pretty printing source code {}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n                                         sess.diagnostic(),\n-                                        &krate,\n+                                        krate,\n                                         src_name.to_string(),\n                                         &mut rdr,\n                                         out,\n@@ -491,7 +470,7 @@ pub fn pretty_print_input(sess: Session,\n \n         (PpmSource(s), Some(uii)) =>\n             s.call_with_pp_support(\n-                sess, &krate, ast_map, id, (out,uii), |annotation, (out,uii)| {\n+                sess, ast_map, &type_arena, id, (out,uii), |annotation, (out,uii)| {\n                     debug!(\"pretty printing source code {}\", s);\n                     let sess = annotation.sess();\n                     let ast_map = annotation.ast_map()\n@@ -533,9 +512,8 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    let type_arena = TypedArena::new();\n-                    let analysis = driver::phase_3_run_analysis_passes(sess, &krate,\n-                                                                       ast_map, &type_arena, id);\n+                    let analysis = driver::phase_3_run_analysis_passes(sess, ast_map,\n+                                                                       &type_arena, id);\n                     print_flowgraph(variants, analysis, code, out)\n                 }\n                 None => {"}, {"sha": "6f020184b336d8a3d92a4f7a81d260b4d5aad3d5", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -263,7 +263,6 @@ pub fn build_session_(sopts: config::Options,\n }\n \n // Seems out of place, but it uses session, so I'm putting it here\n-pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> String)\n-              -> T {\n+pub fn expect<T>(sess: &Session, opt: Option<T>, msg: || -> String) -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }"}, {"sha": "f7c919131a80939eb1a1e8bb78184b6d18c2f98e", "filename": "src/librustc/front/assign_node_ids_and_map.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d379ad111ccef354730e51edea8119341a8e7871/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d379ad111ccef354730e51edea8119341a8e7871/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids_and_map.rs?ref=d379ad111ccef354730e51edea8119341a8e7871", "patch": "@@ -1,29 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use driver::session::Session;\n-\n-use syntax::ast;\n-use syntax::ast_map;\n-\n-struct NodeIdAssigner<'a> {\n-    sess: &'a Session\n-}\n-\n-impl<'a> ast_map::FoldOps for NodeIdAssigner<'a> {\n-    fn new_id(&self, old_id: ast::NodeId) -> ast::NodeId {\n-        assert_eq!(old_id, ast::DUMMY_NODE_ID);\n-        self.sess.next_node_id()\n-    }\n-}\n-\n-pub fn assign_node_ids_and_map(sess: &Session, krate: ast::Crate) -> (ast::Crate, ast_map::Map) {\n-    ast_map::map_crate(krate, NodeIdAssigner { sess: sess })\n-}"}, {"sha": "f028f5c97b7ef9216278c2595aa7e4aa4a3ac0c5", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 127, "deletions": 129, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -10,9 +10,8 @@\n \n use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n-use syntax::codemap;\n-\n-use std::gc::{Gc, GC};\n+use syntax::codemap::Spanned;\n+use syntax::ptr::P;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.\n@@ -28,22 +27,22 @@ pub fn strip_unconfigured_items(krate: ast::Crate) -> ast::Crate {\n }\n \n impl<'a> fold::Folder for Context<'a> {\n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         fold_mod(self, module)\n     }\n-    fn fold_block(&mut self, block: ast::P<ast::Block>) -> ast::P<ast::Block> {\n+    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n         fold_block(self, block)\n     }\n-    fn fold_foreign_mod(&mut self, foreign_mod: &ast::ForeignMod) -> ast::ForeignMod {\n+    fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n-    fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n+    fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n-    fn fold_expr(&mut self, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n+    fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n         fold_expr(self, expr)\n     }\n-    fn fold_mac(&mut self, mac: &ast::Mac) -> ast::Mac {\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n     }\n }\n@@ -57,169 +56,168 @@ pub fn strip_items(krate: ast::Crate,\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<'r>(cx: &mut Context, view_item: &'r ast::ViewItem)\n-                        -> Option<&'r ast::ViewItem> {\n-    if view_item_in_cfg(cx, view_item) {\n+fn filter_view_item(cx: &mut Context, view_item: ast::ViewItem) -> Option<ast::ViewItem> {\n+    if view_item_in_cfg(cx, &view_item) {\n         Some(view_item)\n     } else {\n         None\n     }\n }\n \n-fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items: Vec<&Gc<ast::Item>> = m.items.iter()\n-            .filter(|a| item_in_cfg(cx, &***a))\n-            .collect();\n-    let flattened_items = filtered_items.move_iter()\n-            .flat_map(|&x| cx.fold_item(x).move_iter())\n-            .collect();\n-    let filtered_view_items = m.view_items.iter().filter_map(|a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }).collect();\n+fn fold_mod(cx: &mut Context, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n     ast::Mod {\n-        inner: m.inner,\n-        view_items: filtered_view_items,\n-        items: flattened_items\n+        inner: inner,\n+        view_items: view_items.move_iter().filter_map(|a| {\n+            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+        }).collect(),\n+        items: items.move_iter().filter_map(|a| {\n+            if item_in_cfg(cx, &*a) {\n+                Some(cx.fold_item(a))\n+            } else {\n+                None\n+            }\n+        }).flat_map(|x| x.move_iter()).collect()\n     }\n }\n \n-fn filter_foreign_item(cx: &mut Context, item: Gc<ast::ForeignItem>)\n-                       -> Option<Gc<ast::ForeignItem>> {\n+fn filter_foreign_item(cx: &mut Context, item: P<ast::ForeignItem>)\n+                       -> Option<P<ast::ForeignItem>> {\n     if foreign_item_in_cfg(cx, &*item) {\n         Some(item)\n     } else {\n         None\n     }\n }\n \n-fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n-    let filtered_items = nm.items\n-                           .iter()\n-                           .filter_map(|a| filter_foreign_item(cx, *a))\n-                           .collect();\n-    let filtered_view_items = nm.view_items.iter().filter_map(|a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }).collect();\n+fn fold_foreign_mod(cx: &mut Context, ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                    -> ast::ForeignMod {\n     ast::ForeignMod {\n-        abi: nm.abi,\n-        view_items: filtered_view_items,\n-        items: filtered_items\n+        abi: abi,\n+        view_items: view_items.move_iter().filter_map(|a| {\n+            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+        }).collect(),\n+        items: items.move_iter()\n+                    .filter_map(|a| filter_foreign_item(cx, a))\n+                    .collect()\n     }\n }\n \n-fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n-    let item = match *item {\n-        ast::ItemImpl(ref a, ref b, c, ref impl_items) => {\n-            let impl_items = impl_items.iter()\n-                                       .filter(|ii| {\n-                                           impl_item_in_cfg(cx, &**ii)\n-                                       })\n-                                       .map(|x| *x)\n+fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n+    let item = match item {\n+        ast::ItemImpl(a, b, c, impl_items) => {\n+            let impl_items = impl_items.move_iter()\n+                                       .filter(|ii| impl_item_in_cfg(cx, ii))\n                                        .collect();\n-            ast::ItemImpl((*a).clone(), (*b).clone(), c, impl_items)\n+            ast::ItemImpl(a, b, c, impl_items)\n         }\n-        ast::ItemTrait(ref a, ref b, ref c, ref methods) => {\n-            let methods = methods.iter()\n-                                 .filter(|m| trait_method_in_cfg(cx, *m) )\n-                                 .map(|x| (*x).clone())\n+        ast::ItemTrait(a, b, c, methods) => {\n+            let methods = methods.move_iter()\n+                                 .filter(|m| trait_method_in_cfg(cx, m))\n                                  .collect();\n-            ast::ItemTrait((*a).clone(), (*b).clone(), (*c).clone(), methods)\n+            ast::ItemTrait(a, b, c, methods)\n         }\n-        ast::ItemStruct(ref def, ref generics) => {\n-            ast::ItemStruct(fold_struct(cx, &**def), generics.clone())\n+        ast::ItemStruct(def, generics) => {\n+            ast::ItemStruct(fold_struct(cx, def), generics)\n         }\n-        ast::ItemEnum(ref def, ref generics) => {\n-            let mut variants = def.variants.iter().map(|c| c.clone()).\n-            filter_map(|v| {\n+        ast::ItemEnum(def, generics) => {\n+            let mut variants = def.variants.move_iter().filter_map(|v| {\n                 if !(cx.in_cfg)(v.node.attrs.as_slice()) {\n                     None\n                 } else {\n-                    Some(match v.node.kind {\n-                                ast::TupleVariantKind(..) => v,\n-                                ast::StructVariantKind(ref def) => {\n-                                    let def = fold_struct(cx, &**def);\n-                                    box(GC) codemap::Spanned {\n-                                        node: ast::Variant_ {\n-                                            kind: ast::StructVariantKind(def.clone()),\n-                                            ..v.node.clone()\n-                                        },\n-                                        ..*v\n+                    Some(v.map(|Spanned {node: ast::Variant_ {id, name, attrs, kind,\n+                                                              disr_expr, vis}, span}| {\n+                        Spanned {\n+                            node: ast::Variant_ {\n+                                id: id,\n+                                name: name,\n+                                attrs: attrs,\n+                                kind: match kind {\n+                                    ast::TupleVariantKind(..) => kind,\n+                                    ast::StructVariantKind(def) => {\n+                                        ast::StructVariantKind(fold_struct(cx, def))\n                                     }\n-                                }\n-                            })\n-                    }\n-                });\n+                                },\n+                                disr_expr: disr_expr,\n+                                vis: vis\n+                            },\n+                            span: span\n+                        }\n+                    }))\n+                }\n+            });\n             ast::ItemEnum(ast::EnumDef {\n                 variants: variants.collect(),\n-            }, generics.clone())\n+            }, generics)\n         }\n-        ref item => item.clone(),\n+        item => item,\n     };\n \n-    fold::noop_fold_item_underscore(&item, cx)\n+    fold::noop_fold_item_underscore(item, cx)\n }\n \n-fn fold_struct(cx: &mut Context, def: &ast::StructDef) -> Gc<ast::StructDef> {\n-    let mut fields = def.fields.iter().map(|c| c.clone()).filter(|m| {\n-        (cx.in_cfg)(m.node.attrs.as_slice())\n-    });\n-    box(GC) ast::StructDef {\n-        fields: fields.collect(),\n-        ctor_id: def.ctor_id,\n-        super_struct: def.super_struct.clone(),\n-        is_virtual: def.is_virtual,\n-    }\n+fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n+    def.map(|ast::StructDef {fields, ctor_id, super_struct, is_virtual}| {\n+        ast::StructDef {\n+            fields: fields.move_iter().filter(|m| {\n+                (cx.in_cfg)(m.node.attrs.as_slice())\n+            }).collect(),\n+            ctor_id: ctor_id,\n+            super_struct: super_struct,\n+            is_virtual: is_virtual,\n+        }\n+    })\n }\n \n-fn retain_stmt(cx: &mut Context, stmt: Gc<ast::Stmt>) -> bool {\n+fn retain_stmt(cx: &mut Context, stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n-      ast::StmtDecl(decl, _) => {\n-        match decl.node {\n-          ast::DeclItem(ref item) => {\n-            item_in_cfg(cx, &**item)\n-          }\n-          _ => true\n+        ast::StmtDecl(ref decl, _) => {\n+            match decl.node {\n+                ast::DeclItem(ref item) => {\n+                    item_in_cfg(cx, &**item)\n+                }\n+                _ => true\n+            }\n         }\n-      }\n-      _ => true\n+        _ => true\n     }\n }\n \n-fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts: Vec<&Gc<ast::Stmt>> =\n-        b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n-    let resulting_stmts = resulting_stmts.move_iter()\n-        .flat_map(|stmt| cx.fold_stmt(&**stmt).move_iter())\n-        .collect();\n-    let filtered_view_items = b.view_items.iter().filter_map(|a| {\n-        filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-    }).collect();\n-    ast::P(ast::Block {\n-        view_items: filtered_view_items,\n-        stmts: resulting_stmts,\n-        expr: b.expr.map(|x| cx.fold_expr(x)),\n-        id: b.id,\n-        rules: b.rules,\n-        span: b.span,\n+fn fold_block(cx: &mut Context, b: P<ast::Block>) -> P<ast::Block> {\n+    b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n+        let resulting_stmts: Vec<P<ast::Stmt>> =\n+            stmts.move_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n+        let resulting_stmts = resulting_stmts.move_iter()\n+            .flat_map(|stmt| cx.fold_stmt(stmt).move_iter())\n+            .collect();\n+        let filtered_view_items = view_items.move_iter().filter_map(|a| {\n+            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n+        }).collect();\n+        ast::Block {\n+            id: id,\n+            view_items: filtered_view_items,\n+            stmts: resulting_stmts,\n+            expr: expr.map(|x| cx.fold_expr(x)),\n+            rules: rules,\n+            span: span,\n+        }\n     })\n }\n \n-fn fold_expr(cx: &mut Context, expr: Gc<ast::Expr>) -> Gc<ast::Expr> {\n-    let expr = match expr.node {\n-        ast::ExprMatch(ref m, ref arms) => {\n-            let arms = arms.iter()\n-                .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n-                .map(|a| a.clone())\n-                .collect();\n-            box(GC) ast::Expr {\n-                id: expr.id,\n-                span: expr.span.clone(),\n-                node: ast::ExprMatch(m.clone(), arms),\n-            }\n-        }\n-        _ => expr.clone()\n-    };\n-    fold::noop_fold_expr(expr, cx)\n+fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n+    expr.map(|ast::Expr {id, span, node}| {\n+        fold::noop_fold_expr(ast::Expr {\n+            id: id,\n+            node: match node {\n+                ast::ExprMatch(m, arms) => {\n+                    ast::ExprMatch(m, arms.move_iter()\n+                                        .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n+                                        .collect())\n+                }\n+                _ => node\n+            },\n+            span: span\n+        }, cx)\n+    })\n }\n \n fn item_in_cfg(cx: &mut Context, item: &ast::Item) -> bool {\n@@ -237,19 +235,19 @@ fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitItem) -> bool {\n     match *meth {\n         ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::ProvidedMethod(meth) => (cx.in_cfg)(meth.attrs.as_slice())\n+        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice())\n     }\n }\n \n fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n     match *impl_item {\n-        ast::MethodImplItem(meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::MethodImplItem(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n     }\n }\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &[Gc<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n-    attr::test_cfg(cfg, attrs.iter().map(|x| *x))\n+fn in_cfg(cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute]) -> bool {\n+    attr::test_cfg(cfg, attrs.iter())\n }\n "}, {"sha": "13a40aba93078321db65640e5d255ffc975e672a", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -33,6 +33,7 @@ use syntax::parse::token;\n use driver::session::Session;\n \n use std::cell::Cell;\n+use std::slice;\n \n /// This is a list of all known features since the beginning of time. This list\n /// can never shrink, it may only be expanded (in order to prevent old programs\n@@ -220,7 +221,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(struct_definition, _) => {\n+            ast::ItemStruct(ref struct_definition, _) => {\n                 if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n@@ -310,7 +311,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            ast::TyClosure(closure) if closure.onceness == ast::Once => {\n+            ast::TyClosure(ref closure) if closure.onceness == ast::Once => {\n                 self.gate_feature(\"once_fns\", t.span,\n                                   \"once functions are \\\n                                    experimental and likely to be removed\");\n@@ -352,7 +353,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_generics(&mut self, generics: &ast::Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             match type_parameter.default {\n-                Some(ty) => {\n+                Some(ref ty) => {\n                     self.gate_feature(\"default_type_params\", ty.span,\n                                       \"default type parameters are \\\n                                        experimental and possibly buggy\");\n@@ -364,7 +365,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n \n     fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-        if attr::contains_name([*attr], \"lang\") {\n+        if attr::contains_name(slice::ref_slice(attr), \"lang\") {\n             self.gate_feature(\"lang_items\",\n                               attr.span,\n                               \"language items are subject to change\");\n@@ -420,7 +421,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                                           expected #![feature(...)]\");\n             }\n             Some(list) => {\n-                for &mi in list.iter() {\n+                for mi in list.iter() {\n                     let name = match mi.node {\n                         ast::MetaWord(ref word) => (*word).clone(),\n                         _ => {"}, {"sha": "748641ba70c2bc2eee1698260f0ff0a7d19e6eed", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -21,10 +21,10 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n \n use std::mem;\n-use std::gc::{Gc, GC};\n \n pub fn maybe_inject_crates_ref(sess: &Session, krate: ast::Crate)\n                                -> ast::Crate {\n@@ -149,7 +149,6 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         if !no_prelude(krate.attrs.as_slice()) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n-\n             // fold_mod() will insert glob path.\n             let globs_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n                                                  attr::mk_list_item(\n@@ -161,23 +160,23 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             attr::mark_used(&globs_attr);\n             krate.attrs.push(globs_attr);\n \n-            krate.module = self.fold_mod(&krate.module);\n+            krate.module = self.fold_mod(krate.module);\n         }\n         krate\n     }\n \n-    fn fold_item(&mut self, item: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n+    fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         if !no_prelude(item.attrs.as_slice()) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree\n-            fold::noop_fold_item(&*item, self)\n+            fold::noop_fold_item(item, self)\n         } else {\n             SmallVector::one(item)\n         }\n     }\n \n-    fn fold_mod(&mut self, module: &ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, ast::Mod {inner, view_items, items}: ast::Mod) -> ast::Mod {\n         let prelude_path = ast::Path {\n             span: DUMMY_SP,\n             global: false,\n@@ -194,44 +193,41 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let vp = box(GC) codemap::dummy_spanned(ast::ViewPathGlob(prelude_path,\n-                                                                  ast::DUMMY_NODE_ID));\n-        let vi2 = ast::ViewItem {\n+        let (crates, uses) = view_items.partitioned(|x| {\n+            match x.node {\n+                ast::ViewItemExternCrate(..) => true,\n+                _ => false,\n+            }\n+        });\n+\n+        // add prelude after any `extern crate` but before any `use`\n+        let mut view_items = crates;\n+        let vp = P(codemap::dummy_spanned(ast::ViewPathGlob(prelude_path, ast::DUMMY_NODE_ID)));\n+        view_items.push(ast::ViewItem {\n             node: ast::ViewItemUse(vp),\n-            attrs: vec!(ast::Attribute {\n+            attrs: vec![ast::Attribute {\n                 span: DUMMY_SP,\n                 node: ast::Attribute_ {\n                     id: attr::mk_attr_id(),\n                     style: ast::AttrOuter,\n-                    value: box(GC) ast::MetaItem {\n+                    value: P(ast::MetaItem {\n                         span: DUMMY_SP,\n                         node: ast::MetaWord(token::get_name(\n                                 special_idents::prelude_import.name)),\n-                    },\n+                    }),\n                     is_sugared_doc: false,\n                 },\n-            }),\n+            }],\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n-        };\n-\n-        let (crates, uses) = module.view_items.partitioned(|x| {\n-            match x.node {\n-                ast::ViewItemExternCrate(..) => true,\n-                _ => false,\n-            }\n         });\n-\n-        // add vi2 after any `extern crate` but before any `use`\n-        let mut view_items = crates;\n-        view_items.push(vi2);\n         view_items.push_all_move(uses);\n \n-        let new_module = ast::Mod {\n+        fold::noop_fold_mod(ast::Mod {\n+            inner: inner,\n             view_items: view_items,\n-            ..(*module).clone()\n-        };\n-        fold::noop_fold_mod(&new_module, self)\n+            items: items\n+        }, self)\n     }\n }\n "}, {"sha": "a8c9c500095884f333c1075049129ab555e6b377", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -16,10 +16,10 @@\n use driver::session::Session;\n use front::config;\n \n-use std::gc::{Gc, GC};\n use std::slice;\n use std::mem;\n use std::vec;\n+use syntax::{ast, ast_util};\n use syntax::ast_util::*;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n@@ -28,13 +28,13 @@ use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n-use syntax::fold::Folder;\n+use syntax::fold::{Folder, MoveMap};\n use syntax::fold;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::print::pprust;\n-use syntax::{ast, ast_util};\n+use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n \n struct Test {\n@@ -105,12 +105,12 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         folded\n     }\n \n-    fn fold_item(&mut self, i: Gc<ast::Item>) -> SmallVector<Gc<ast::Item>> {\n+    fn fold_item(&mut self, i: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         self.cx.path.push(i.ident);\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(self.cx.path.as_slice()));\n \n-        if is_test_fn(&self.cx, i) || is_bench_fn(&self.cx, i) {\n+        if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n                 ast::ItemFn(_, ast::UnsafeFn, _, _, _) => {\n                     let sess = self.cx.sess;\n@@ -123,9 +123,9 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n-                        bench: is_bench_fn(&self.cx, i),\n-                        ignore: is_ignored(&self.cx, i),\n-                        should_fail: should_fail(i)\n+                        bench: is_bench_fn(&self.cx, &*i),\n+                        ignore: is_ignored(&self.cx, &*i),\n+                        should_fail: should_fail(&*i)\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n@@ -138,14 +138,14 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         let res = match i.node {\n-            ast::ItemMod(..) => fold::noop_fold_item(&*i, self),\n+            ast::ItemMod(..) => fold::noop_fold_item(i, self),\n             _ => SmallVector::one(i),\n         };\n         self.cx.path.pop();\n         res\n     }\n \n-    fn fold_mod(&mut self, m: &ast::Mod) -> ast::Mod {\n+    fn fold_mod(&mut self, m: ast::Mod) -> ast::Mod {\n         let tests = mem::replace(&mut self.tests, Vec::new());\n         let tested_submods = mem::replace(&mut self.tested_submods, Vec::new());\n         let mut mod_folded = fold::noop_fold_mod(m, self);\n@@ -155,22 +155,25 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Remove any #[main] from the AST so it doesn't clash with\n         // the one we're going to add. Only if compiling an executable.\n \n-        fn nomain(item: Gc<ast::Item>) -> Gc<ast::Item> {\n-            box(GC) ast::Item {\n-                attrs: item.attrs.iter().filter_map(|attr| {\n-                    if !attr.check_name(\"main\") {\n-                        Some(*attr)\n-                    } else {\n-                        None\n-                    }\n-                }).collect(),\n-                .. (*item).clone()\n-            }\n-        }\n+        mod_folded.items = mem::replace(&mut mod_folded.items, vec![]).move_map(|item| {\n+            item.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n+                ast::Item {\n+                    id: id,\n+                    ident: ident,\n+                    attrs: attrs.move_iter().filter_map(|attr| {\n+                        if !attr.check_name(\"main\") {\n+                            Some(attr)\n+                        } else {\n+                            None\n+                        }\n+                    }).collect(),\n+                    node: node,\n+                    vis: vis,\n+                    span: span\n+                }\n+            })\n+        });\n \n-        for i in mod_folded.items.mut_iter() {\n-            *i = nomain(*i);\n-        }\n         if !tests.is_empty() || !tested_submods.is_empty() {\n             let (it, sym) = mk_reexport_mod(&mut self.cx, tests, tested_submods);\n             mod_folded.items.push(it);\n@@ -188,7 +191,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n }\n \n fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n-                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (Gc<ast::Item>, ast::Ident) {\n+                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n     let mut view_items = Vec::new();\n     let super_ = token::str_to_ident(\"super\");\n \n@@ -208,14 +211,14 @@ fn mk_reexport_mod(cx: &mut TestCtxt, tests: Vec<ast::Ident>,\n     };\n \n     let sym = token::gensym_ident(\"__test_reexports\");\n-    let it = box(GC) ast::Item {\n+    let it = P(ast::Item {\n         ident: sym.clone(),\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemMod(reexport_mod),\n         vis: ast::Public,\n         span: DUMMY_SP,\n-    };\n+    });\n \n     (it, sym)\n }\n@@ -266,10 +269,10 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     })\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n+fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_test_attr = attr::contains_name(i.attrs.as_slice(), \"test\");\n \n-    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n+    fn has_test_signature(i: &ast::Item) -> bool {\n         match &i.node {\n           &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output.node {\n@@ -295,10 +298,10 @@ fn is_test_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_bench_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n+fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     let has_bench_attr = attr::contains_name(i.attrs.as_slice(), \"bench\");\n \n-    fn has_test_signature(i: Gc<ast::Item>) -> bool {\n+    fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n             ast::ItemFn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n@@ -325,19 +328,19 @@ fn is_bench_fn(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n     return has_bench_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: &TestCtxt, i: Gc<ast::Item>) -> bool {\n+fn is_ignored(cx: &TestCtxt, i: &ast::Item) -> bool {\n     i.attrs.iter().any(|attr| {\n         // check ignore(cfg(foo, bar))\n         attr.check_name(\"ignore\") && match attr.meta_item_list() {\n             Some(ref cfgs) => {\n-                attr::test_cfg(cx.config.as_slice(), cfgs.iter().map(|x| *x))\n+                attr::test_cfg(cx.config.as_slice(), cfgs.iter())\n             }\n             None => true\n         }\n     })\n }\n \n-fn should_fail(i: Gc<ast::Item>) -> bool {\n+fn should_fail(i: &ast::Item) -> bool {\n     attr::contains_name(i.attrs.as_slice(), \"should_fail\")\n }\n \n@@ -362,9 +365,9 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     let id_test = token::str_to_ident(\"test\");\n     let (vi, vis) = if cx.is_test_crate {\n         (ast::ViewItemUse(\n-            box(GC) nospan(ast::ViewPathSimple(id_test,\n-                                        path_node(vec!(id_test)),\n-                                        ast::DUMMY_NODE_ID))),\n+            P(nospan(ast::ViewPathSimple(id_test,\n+                                         path_node(vec!(id_test)),\n+                                         ast::DUMMY_NODE_ID)))),\n          ast::Public)\n     } else {\n         (ast::ViewItemExternCrate(id_test, None, ast::DUMMY_NODE_ID),\n@@ -378,7 +381,7 @@ fn mk_std(cx: &TestCtxt) -> ast::ViewItem {\n     }\n }\n \n-fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n+fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<ast::ViewItem>) {\n     // Link to test crate\n     let view_items = vec!(mk_std(cx));\n \n@@ -421,7 +424,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n                                        ast::DUMMY_NODE_ID));\n \n         ast::ViewItem {\n-            node: ast::ViewItemUse(box(GC) use_path),\n+            node: ast::ViewItemUse(P(use_path)),\n             attrs: vec![],\n             vis: ast::Inherited,\n             span: DUMMY_SP\n@@ -430,7 +433,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (Gc<ast::Item>, Option<ast::ViewItem>) {\n \n     debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n \n-    (box(GC) item, reexport)\n+    (P(item), reexport)\n }\n \n fn nospan<T>(t: T) -> codemap::Spanned<T> {\n@@ -449,7 +452,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn mk_tests(cx: &TestCtxt) -> Gc<ast::Item> {\n+fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n \n@@ -483,24 +486,24 @@ fn is_test_crate(krate: &ast::Crate) -> bool {\n     }\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> Gc<ast::Expr> {\n+fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.testfns.len());\n \n-    box(GC) ast::Expr {\n+    P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprAddrOf(ast::MutImmutable,\n-            box(GC) ast::Expr {\n+            P(ast::Expr {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprVec(cx.testfns.iter().map(|test| {\n                     mk_test_desc_and_fn_rec(cx, test)\n-            }).collect()),\n-            span: DUMMY_SP,\n-        }),\n+                }).collect()),\n+                span: DUMMY_SP,\n+            })),\n         span: DUMMY_SP,\n-    }\n+    })\n }\n \n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> Gc<ast::Expr> {\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // FIXME #15962: should be using quote_expr, but that stringifies\n     // __test_reexports, causing it to be reinterned, losing the\n     // gensym information."}, {"sha": "fd643a70c7b95b71ffe371504f7f5f9c10af5373", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -119,7 +119,6 @@ pub mod front {\n     pub mod config;\n     pub mod test;\n     pub mod std_inject;\n-    pub mod assign_node_ids_and_map;\n     pub mod feature_gate;\n     pub mod show_span;\n }"}, {"sha": "58c05bee443737b51279bd4ac69426b1df5faca9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -36,15 +36,16 @@ use lint::{Context, LintPass, LintArray};\n \n use std::cmp;\n use std::collections::HashMap;\n+use std::slice;\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n-use std::gc::Gc;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n+use syntax::ptr::P;\n use syntax::visit::Visitor;\n \n declare_lint!(WHILE_TRUE, Warn,\n@@ -59,9 +60,9 @@ impl LintPass for WhileTrue {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprWhile(cond, _, _) => {\n+            ast::ExprWhile(ref cond, _, _) => {\n                 match cond.node {\n-                    ast::ExprLit(lit) => {\n+                    ast::ExprLit(ref lit) => {\n                         match lit.node {\n                             ast::LitBool(true) => {\n                                 cx.span_lint(WHILE_TRUE, e.span,\n@@ -91,9 +92,9 @@ impl LintPass for UnusedCasts {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprCast(expr, ty) => {\n-                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &*ty);\n-                if ty::get(ty::expr_ty(cx.tcx, &*expr)).sty == ty::get(t_t).sty {\n+            ast::ExprCast(ref expr, ref ty) => {\n+                let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), &**ty);\n+                if ty::get(ty::expr_ty(cx.tcx, &**expr)).sty == ty::get(t_t).sty {\n                     cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n                 }\n             }\n@@ -131,9 +132,9 @@ impl LintPass for TypeLimits {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprUnary(ast::UnNeg, expr) => {\n+            ast::ExprUnary(ast::UnNeg, ref expr) => {\n                 match expr.node  {\n-                    ast::ExprLit(lit) => {\n+                    ast::ExprLit(ref lit) => {\n                         match lit.node {\n                             ast::LitInt(_, ast::UnsignedIntLit(_)) => {\n                                 cx.span_lint(UNSIGNED_NEGATE, e.span,\n@@ -144,7 +145,7 @@ impl LintPass for TypeLimits {\n                         }\n                     },\n                     _ => {\n-                        let t = ty::expr_ty(cx.tcx, &*expr);\n+                        let t = ty::expr_ty(cx.tcx, &**expr);\n                         match ty::get(t).sty {\n                             ty::ty_uint(_) => {\n                                 cx.span_lint(UNSIGNED_NEGATE, e.span,\n@@ -160,16 +161,16 @@ impl LintPass for TypeLimits {\n                     self.negated_expr_id = expr.id;\n                 }\n             },\n-            ast::ExprParen(expr) if self.negated_expr_id == e.id => {\n+            ast::ExprParen(ref expr) if self.negated_expr_id == e.id => {\n                 self.negated_expr_id = expr.id;\n             },\n-            ast::ExprBinary(binop, l, r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &*l, &*r) {\n+            ast::ExprBinary(binop, ref l, ref r) => {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n                     cx.span_lint(TYPE_LIMITS, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             },\n-            ast::ExprLit(lit) => {\n+            ast::ExprLit(ref lit) => {\n                 match ty::get(ty::expr_ty(cx.tcx, e)).sty {\n                     ty::ty_int(t) => {\n                         match lit.node {\n@@ -292,7 +293,7 @@ impl LintPass for TypeLimits {\n                 ty::ty_int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i64 = match lit.node {\n-                        ast::ExprLit(li) => match li.node {\n+                        ast::ExprLit(ref li) => match li.node {\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Plus)) |\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => v as i64,\n                             ast::LitInt(v, ast::SignedIntLit(_, ast::Minus)) |\n@@ -306,7 +307,7 @@ impl LintPass for TypeLimits {\n                 ty::ty_uint(uint_ty) => {\n                     let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n                     let lit_val: u64 = match lit.node {\n-                        ast::ExprLit(li) => match li.node {\n+                        ast::ExprLit(ref li) => match li.node {\n                             ast::LitInt(v, _) => v,\n                             _ => return true\n                         },\n@@ -400,8 +401,8 @@ impl LintPass for CTypes {\n             ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n                 for ni in nmod.items.iter() {\n                     match ni.node {\n-                        ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, &*decl),\n-                        ast::ForeignItemStatic(t, _) => check_ty(cx, &*t)\n+                        ast::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n+                        ast::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n                     }\n                 }\n             }\n@@ -477,7 +478,7 @@ impl LintPass for HeapMemory {\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n-            ast::ItemStruct(struct_def, _) => {\n+            ast::ItemStruct(ref struct_def, _) => {\n                 for struct_field in struct_def.fields.iter() {\n                     self.check_heap_type(cx, struct_field.span,\n                                          ty::node_id_to_type(cx.tcx, struct_field.node.id));\n@@ -658,7 +659,7 @@ impl LintPass for PathStatement {\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n-            ast::StmtSemi(expr, _) => {\n+            ast::StmtSemi(ref expr, _) => {\n                 match expr.node {\n                     ast::ExprPath(_) => cx.span_lint(PATH_STATEMENT, s.span,\n                                                      \"path statement with no effect\"),\n@@ -685,10 +686,10 @@ impl LintPass for UnusedResult {\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         let expr = match s.node {\n-            ast::StmtSemi(expr, _) => expr,\n+            ast::StmtSemi(ref expr, _) => &**expr,\n             _ => return\n         };\n-        let t = ty::expr_ty(cx.tcx, &*expr);\n+        let t = ty::expr_ty(cx.tcx, expr);\n         match ty::get(t).sty {\n             ty::ty_nil | ty::ty_bot | ty::ty_bool => return,\n             _ => {}\n@@ -698,7 +699,7 @@ impl LintPass for UnusedResult {\n             _ => {}\n         }\n \n-        let t = ty::expr_ty(cx.tcx, &*expr);\n+        let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n             ty::ty_struct(did, _) |\n@@ -1080,29 +1081,29 @@ impl LintPass for UnnecessaryParens {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n-            ast::ExprIf(cond, _, _) => (cond, \"`if` condition\", true),\n-            ast::ExprWhile(cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(head, _) => (head, \"`match` head expression\", true),\n-            ast::ExprRet(Some(value)) => (value, \"`return` value\", false),\n-            ast::ExprAssign(_, value) => (value, \"assigned value\", false),\n-            ast::ExprAssignOp(_, _, value) => (value, \"assigned value\", false),\n+            ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n+            ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n+            ast::ExprMatch(ref head, _) => (head, \"`match` head expression\", true),\n+            ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n+            ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n+            ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg, struct_lit_needs_parens);\n+        self.check_unnecessary_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         let (value, msg) = match s.node {\n-            ast::StmtDecl(decl, _) => match decl.node {\n-                ast::DeclLocal(local) => match local.init {\n-                    Some(value) => (value, \"assigned value\"),\n+            ast::StmtDecl(ref decl, _) => match decl.node {\n+                ast::DeclLocal(ref local) => match local.init {\n+                    Some(ref value) => (value, \"assigned value\"),\n                     None => return\n                 },\n                 _ => return\n             },\n             _ => return\n         };\n-        self.check_unnecessary_parens_core(cx, &*value, msg, false);\n+        self.check_unnecessary_parens_core(cx, &**value, msg, false);\n     }\n }\n \n@@ -1157,12 +1158,12 @@ declare_lint!(pub UNUSED_MUT, Warn,\n pub struct UnusedMut;\n \n impl UnusedMut {\n-    fn check_unused_mut_pat(&self, cx: &Context, pats: &[Gc<ast::Pat>]) {\n+    fn check_unused_mut_pat(&self, cx: &Context, pats: &[P<ast::Pat>]) {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n         let mut mutables = HashMap::new();\n-        for &p in pats.iter() {\n-            pat_util::pat_bindings(&cx.tcx.def_map, &*p, |mode, id, _, path1| {\n+        for p in pats.iter() {\n+            pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;\n                 match mode {\n                     ast::BindByValue(ast::MutMutable) => {\n@@ -1205,10 +1206,10 @@ impl LintPass for UnusedMut {\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n-            ast::StmtDecl(d, _) => {\n+            ast::StmtDecl(ref d, _) => {\n                 match d.node {\n-                    ast::DeclLocal(l) => {\n-                        self.check_unused_mut_pat(cx, &[l.pat]);\n+                    ast::DeclLocal(ref l) => {\n+                        self.check_unused_mut_pat(cx, slice::ref_slice(&l.pat));\n                     },\n                     _ => {}\n                 }\n@@ -1221,7 +1222,7 @@ impl LintPass for UnusedMut {\n                 _: visit::FnKind, decl: &ast::FnDecl,\n                 _: &ast::Block, _: Span, _: ast::NodeId) {\n         for a in decl.inputs.iter() {\n-            self.check_unused_mut_pat(cx, &[a.pat]);\n+            self.check_unused_mut_pat(cx, slice::ref_slice(&a.pat));\n         }\n     }\n }"}, {"sha": "4dd944415127e022d0cd4dc6b3a4767dfda31829", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -278,7 +278,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n \n         attr::mark_used(attr);\n \n-        let meta = attr.node.value;\n+        let meta = &attr.node.value;\n         let metas = match meta.node {\n             ast::MetaList(_, ref metas) => metas,\n             _ => {\n@@ -709,8 +709,8 @@ impl LintPass for GatherNodeLevels {\n ///\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &ast::Crate,\n                    exported_items: &ExportedItems) {\n+    let krate = tcx.map.krate();\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate."}, {"sha": "c27f1d9ed1f53387a66bd13a194081b0ee44141b", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -97,18 +97,18 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n         path.as_slice())\n }\n \n-pub enum found_ast {\n-    found(ast::InlinedItem),\n-    found_parent(ast::DefId, ast::InlinedItem),\n+pub enum found_ast<'ast> {\n+    found(&'ast ast::InlinedItem),\n+    found_parent(ast::DefId, &'ast ast::InlinedItem),\n     not_found,\n }\n \n // Finds the AST for this item in the crate metadata, if any.  If the item was\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n-pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n-                          decode_inlined_item: decoder::DecodeInlinedItem)\n-                       -> found_ast {\n+pub fn maybe_get_item_ast<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId,\n+                                decode_inlined_item: decoder::DecodeInlinedItem)\n+                                -> found_ast<'tcx> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::maybe_get_item_ast(&*cdata, tcx, def.node, decode_inlined_item)"}, {"sha": "bcf9a4f678d0a36c321ec02e2c1ad84d2c59722b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -30,7 +30,6 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-use std::gc::Gc;\n use std::hash::Hash;\n use std::hash;\n use std::io::extensions::u64_from_be_bytes;\n@@ -48,6 +47,7 @@ use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ast;\n use syntax::codemap;\n+use syntax::ptr::P;\n \n pub type Cmd<'a> = &'a crate_metadata;\n \n@@ -612,27 +612,28 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> Vec<ast_map::PathElem> {\n     item_path(lookup_item(id, cdata.data()))\n }\n \n-pub type DecodeInlinedItem<'a> = |cdata: Cmd,\n-                                  tcx: &ty::ctxt,\n-                                  path: Vec<ast_map::PathElem>,\n-                                  par_doc: rbml::Doc|: 'a\n-                                  -> Result<ast::InlinedItem, Vec<ast_map::PathElem> >;\n+pub type DecodeInlinedItem<'a> = <'tcx> |cdata: Cmd,\n+                                         tcx: &ty::ctxt<'tcx>,\n+                                         path: Vec<ast_map::PathElem>,\n+                                         par_doc: rbml::Doc|: 'a\n+                                         -> Result<&'tcx ast::InlinedItem,\n+                                                   Vec<ast_map::PathElem>>;\n \n-pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n-                          decode_inlined_item: DecodeInlinedItem)\n-                          -> csearch::found_ast {\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeId,\n+                                decode_inlined_item: DecodeInlinedItem)\n+                                -> csearch::found_ast<'tcx> {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n     let path = Vec::from_slice(item_path(item_doc).init());\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n-        Ok(ref ii) => csearch::found(*ii),\n+        Ok(ii) => csearch::found(ii),\n         Err(path) => {\n             match item_parent_item(item_doc) {\n                 Some(did) => {\n                     let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n-                        Ok(ref ii) => csearch::found_parent(did, *ii),\n+                        Ok(ii) => csearch::found_parent(did, ii),\n                         Err(_) => csearch::not_found\n                     }\n                 }\n@@ -1003,8 +1004,8 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     result\n }\n \n-fn get_meta_items(md: rbml::Doc) -> Vec<Gc<ast::MetaItem>> {\n-    let mut items: Vec<Gc<ast::MetaItem>> = Vec::new();\n+fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n+    let mut items: Vec<P<ast::MetaItem>> = Vec::new();\n     reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n@@ -1043,7 +1044,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n             assert_eq!(meta_items.len(), 1u);\n-            let meta_item = *meta_items.get(0);\n+            let meta_item = meta_items.move_iter().nth(0).unwrap();\n             attrs.push(\n                 codemap::Spanned {\n                     node: ast::Attribute_ {"}, {"sha": "376cccc3f10fc2c9646800136d725b0cee3f6cab", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 72, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -29,7 +29,6 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::hash::Hash;\n use std::hash;\n use std::mem;\n@@ -46,6 +45,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax;\n@@ -55,16 +55,11 @@ use rbml::io::SeekableMemWriter;\n /// A borrowed version of `ast::InlinedItem`.\n pub enum InlinedItemRef<'a> {\n     IIItemRef(&'a ast::Item),\n-    IITraitItemRef(ast::DefId, InlinedTraitItemRef<'a>),\n+    IITraitItemRef(ast::DefId, &'a ast::TraitItem),\n+    IIImplItemRef(ast::DefId, &'a ast::ImplItem),\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n-/// A borrowed version of `ast::InlinedTraitItem`.\n-pub enum InlinedTraitItemRef<'a> {\n-    ProvidedInlinedTraitItemRef(&'a Method),\n-    RequiredInlinedTraitItemRef(&'a Method),\n-}\n-\n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n \n pub type EncodeInlinedItem<'a> = |ecx: &EncodeContext,\n@@ -507,7 +502,7 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n /// * For enums, iterates through the node IDs of the variants.\n ///\n /// * For newtype structs, iterates through the node ID of the constructor.\n-fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n+fn each_auxiliary_node_id(item: &Item, callback: |NodeId| -> bool) -> bool {\n     let mut continue_ = true;\n     match item.node {\n         ItemEnum(ref enum_def, _) => {\n@@ -518,7 +513,7 @@ fn each_auxiliary_node_id(item: Gc<Item>, callback: |NodeId| -> bool) -> bool {\n                 }\n             }\n         }\n-        ItemStruct(struct_def, _) => {\n+        ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n@@ -587,7 +582,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n         rbml_w.end_tag();\n \n-        each_auxiliary_node_id(*item, |auxiliary_node_id| {\n+        each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());\n@@ -858,7 +853,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n                           parent_id: NodeId,\n-                          ast_method_opt: Option<Gc<Method>>) {\n+                          ast_item_opt: Option<&ImplItem>) {\n \n     debug!(\"encode_info_for_method: {:?} {}\", m.def_id,\n            token::get_ident(m.ident));\n@@ -877,26 +872,20 @@ fn encode_info_for_method(ecx: &EncodeContext,\n \n     let elem = ast_map::PathName(m.ident.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n-    match ast_method_opt {\n-        Some(ast_method) => {\n-            encode_attributes(rbml_w, ast_method.attrs.as_slice())\n-        }\n-        None => ()\n-    }\n-\n-    for &ast_method in ast_method_opt.iter() {\n-        let any_types = !pty.generics.types.is_empty();\n-        if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n-            encode_inlined_item(ecx,\n-                                rbml_w,\n-                                IITraitItemRef(local_def(parent_id),\n-                                               RequiredInlinedTraitItemRef(\n-                                                   &*ast_method)));\n-        }\n-        if !any_types {\n-            encode_symbol(ecx, rbml_w, m.def_id.node);\n+    match ast_item_opt {\n+        Some(&ast::MethodImplItem(ref ast_method)) => {\n+            encode_attributes(rbml_w, ast_method.attrs.as_slice());\n+            let any_types = !pty.generics.types.is_empty();\n+            if any_types || is_default_impl || should_inline(ast_method.attrs.as_slice()) {\n+                encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n+                                                               ast_item_opt.unwrap()));\n+            }\n+            if !any_types {\n+                encode_symbol(ecx, rbml_w, m.def_id.node);\n+            }\n+            encode_method_argument_names(rbml_w, ast_method.pe_fn_decl());\n         }\n-        encode_method_argument_names(rbml_w, &*ast_method.pe_fn_decl());\n+        None => {}\n     }\n \n     rbml_w.end_tag();\n@@ -1127,7 +1116,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                  (*enum_definition).variants.as_slice(),\n                                  index);\n       }\n-      ItemStruct(struct_def, _) => {\n+      ItemStruct(ref struct_def, _) => {\n         let fields = ty::lookup_struct_fields(tcx, def_id);\n \n         /* First, encode the fields\n@@ -1178,7 +1167,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n-      ItemImpl(_, ref opt_trait, ty, ref ast_items) => {\n+      ItemImpl(_, ref opt_trait, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1228,7 +1217,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_items.len();\n         for (i, &trait_item_def_id) in items.iter().enumerate() {\n             let ast_item = if i < num_implemented_methods {\n-                Some(*ast_items.get(i))\n+                Some(ast_items.get(i))\n             } else {\n                 None\n             };\n@@ -1238,29 +1227,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.writer.tell().unwrap(),\n             });\n \n-            let trait_item_type =\n+            let ty::MethodTraitItem(method_type) =\n                 ty::impl_or_trait_item(tcx, trait_item_def_id.def_id());\n-            match (trait_item_type, ast_item) {\n-                (ty::MethodTraitItem(method_type),\n-                 Some(ast::MethodImplItem(ast_method))) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           &*method_type,\n-                                           path.clone(),\n-                                           false,\n-                                           item.id,\n-                                           Some(ast_method))\n-                }\n-                (ty::MethodTraitItem(method_type), None) => {\n-                    encode_info_for_method(ecx,\n-                                           rbml_w,\n-                                           &*method_type,\n-                                           path.clone(),\n-                                           false,\n-                                           item.id,\n-                                           None)\n-                }\n-            }\n+            encode_info_for_method(ecx, rbml_w, &*method_type, path.clone(),\n+                                   false, item.id, ast_item)\n         }\n       }\n       ItemTrait(_, _, _, ref ms) => {\n@@ -1345,15 +1315,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         }\n                     }\n \n-                    match ms.get(i) {\n-                        &RequiredMethod(ref tm) => {\n+                    let trait_item = ms.get(i);\n+                    match *trait_item {\n+                        RequiredMethod(ref tm) => {\n                             encode_attributes(rbml_w, tm.attrs.as_slice());\n                             encode_item_sort(rbml_w, 'r');\n                             encode_parent_sort(rbml_w, 't');\n                             encode_method_argument_names(rbml_w, &*tm.decl);\n                         }\n \n-                        &ProvidedMethod(m) => {\n+                        ProvidedMethod(ref m) => {\n                             encode_attributes(rbml_w, m.attrs.as_slice());\n                             // If this is a static method, we've already\n                             // encoded this.\n@@ -1366,14 +1337,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             }\n                             encode_item_sort(rbml_w, 'p');\n                             encode_parent_sort(rbml_w, 't');\n-                            encode_inlined_item(\n-                                ecx,\n-                                rbml_w,\n-                                IITraitItemRef(\n-                                    def_id,\n-                                    ProvidedInlinedTraitItemRef(&*m)));\n-                            encode_method_argument_names(rbml_w,\n-                                                         &*m.pe_fn_decl());\n+                            encode_inlined_item(ecx, rbml_w,\n+                                                IITraitItemRef(def_id, trait_item));\n+                            encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                         }\n                     }\n                 }\n@@ -1571,7 +1537,7 @@ fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(rbml_w: &mut Encoder, mi: Gc<MetaItem>) {\n+fn encode_meta_item(rbml_w: &mut Encoder, mi: &MetaItem) {\n     match mi.node {\n       MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n@@ -1601,7 +1567,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: Gc<MetaItem>) {\n         rbml_w.writer.write(name.get().as_bytes());\n         rbml_w.end_tag();\n         for inner_item in items.iter() {\n-            encode_meta_item(rbml_w, *inner_item);\n+            encode_meta_item(rbml_w, &**inner_item);\n         }\n         rbml_w.end_tag();\n       }\n@@ -1613,7 +1579,7 @@ fn encode_attributes(rbml_w: &mut Encoder, attrs: &[Attribute]) {\n     for attr in attrs.iter() {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, attr.node.value);\n+        encode_meta_item(rbml_w, &*attr.node.value);\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n@@ -1852,12 +1818,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n                     rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n-    for &item in krate.module.items.iter() {\n+    for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n         rbml_w.wr_str(def_to_string(local_def(item.id)).as_slice());\n         rbml_w.end_tag();\n \n-        each_auxiliary_node_id(item, |auxiliary_node_id| {\n+        each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n                         auxiliary_node_id)).as_slice());"}, {"sha": "2dab3c2b1da02b488313106eefa0936a2d6bb6aa", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 263, "deletions": 287, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -36,6 +36,7 @@ use syntax::ast_util::PostExpansionMethod;\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax;\n \n use libc;\n@@ -52,25 +53,20 @@ use serialize::{EncoderHelpers};\n \n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::print::pprust;\n-#[cfg(test)] use std::gc::Gc;\n \n-struct DecodeContext<'a, 'tcx: 'a> {\n-    cdata: &'a cstore::crate_metadata,\n+struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-}\n-\n-struct ExtendedDecodeContext<'a, 'tcx: 'a> {\n-    dcx: &'a DecodeContext<'a, 'tcx>,\n+    cdata: &'b cstore::crate_metadata,\n     from_id_range: ast_util::IdRange,\n     to_id_range: ast_util::IdRange\n }\n \n trait tr {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> Self;\n+    fn tr(&self, dcx: &DecodeContext) -> Self;\n }\n \n trait tr_intern {\n-    fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n+    fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId;\n }\n \n pub type Encoder<'a> = writer::Encoder<'a, SeekableMemWriter>;\n@@ -84,19 +80,21 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let id = match ii {\n         e::IIItemRef(i) => i.id,\n         e::IIForeignRef(i) => i.id,\n-        e::IITraitItemRef(_, e::ProvidedInlinedTraitItemRef(m)) => m.id,\n-        e::IITraitItemRef(_, e::RequiredInlinedTraitItemRef(m)) => m.id,\n+        e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n+        e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n+        e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.tell());\n \n+    // Folding could be avoided with a smarter encoder.\n     let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n     rbml_w.start_tag(c::tag_ast as uint);\n     id_range.encode(rbml_w);\n-    encode_ast(rbml_w, ii);\n+    encode_ast(rbml_w, &ii);\n     encode_side_tables_for_ii(ecx, rbml_w, &ii);\n     rbml_w.end_tag();\n \n@@ -105,15 +103,28 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            rbml_w.writer.tell());\n }\n \n-pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n-                           tcx: &ty::ctxt,\n-                           path: Vec<ast_map::PathElem>,\n-                           par_doc: rbml::Doc)\n-                           -> Result<ast::InlinedItem, Vec<ast_map::PathElem>> {\n-    let dcx = &DecodeContext {\n-        cdata: cdata,\n-        tcx: tcx,\n-    };\n+impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n+    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n+        if id == ast::DUMMY_NODE_ID {\n+            // Used by ast_map to map the NodeInlinedParent.\n+            self.tcx.sess.next_node_id()\n+        } else {\n+            self.tr_id(id)\n+        }\n+    }\n+    fn new_def_id(&self, def_id: ast::DefId) -> ast::DefId {\n+        self.tr_def_id(def_id)\n+    }\n+    fn new_span(&self, span: Span) -> Span {\n+        self.tr_span(span)\n+    }\n+}\n+\n+pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n+                                 tcx: &ty::ctxt<'tcx>,\n+                                 path: Vec<ast_map::PathElem>,\n+                                 par_doc: rbml::Doc)\n+                                 -> Result<&'tcx ast::InlinedItem, Vec<ast_map::PathElem>> {\n     match par_doc.opt_child(c::tag_ast) {\n       None => Err(path),\n       Some(ast_doc) => {\n@@ -127,34 +138,41 @@ pub fn decode_inlined_item(cdata: &cstore::crate_metadata,\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n-        let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n-        let xcx = &ExtendedDecodeContext {\n-            dcx: dcx,\n+        let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n+        let dcx = &DecodeContext {\n+            cdata: cdata,\n+            tcx: tcx,\n             from_id_range: from_id_range,\n             to_id_range: to_id_range\n         };\n         let raw_ii = decode_ast(ast_doc);\n-        let ii = renumber_and_map_ast(xcx, &dcx.tcx.map, path, raw_ii);\n-        let ident = match ii {\n-            ast::IIItem(i) => i.ident,\n-            ast::IIForeign(i) => i.ident,\n-            ast::IITraitItem(_, iti) => {\n-                match iti {\n-                    ast::ProvidedInlinedTraitItem(m) => m.pe_ident(),\n-                    ast::RequiredInlinedTraitItem(m) => m.pe_ident(),\n+        let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n+\n+        let ident = match *ii {\n+            ast::IIItem(ref i) => i.ident,\n+            ast::IIForeign(ref i) => i.ident,\n+            ast::IITraitItem(_, ref ti) => {\n+                match *ti {\n+                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n+                    ast::RequiredMethod(ref ty_m) => ty_m.ident\n+                }\n+            },\n+            ast::IIImplItem(_, ref m) => {\n+                match *m {\n+                    ast::MethodImplItem(ref m) => m.pe_ident()\n                 }\n             }\n         };\n         debug!(\"Fn named: {}\", token::get_ident(ident));\n         debug!(\"< Decoded inlined fn: {}::{}\",\n                path_as_str.unwrap(),\n                token::get_ident(ident));\n-        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, &ii);\n-        decode_side_tables(xcx, ast_doc);\n-        match ii {\n-          ast::IIItem(i) => {\n+        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n+        decode_side_tables(dcx, ast_doc);\n+        match *ii {\n+          ast::IIItem(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_string(&*i));\n+                   syntax::print::pprust::item_to_string(&**i));\n           }\n           _ => { }\n         }\n@@ -176,7 +194,7 @@ fn reserve_id_range(sess: &Session,\n     ast_util::IdRange { min: to_id_min, max: to_id_max }\n }\n \n-impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n+impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     pub fn tr_id(&self, id: ast::NodeId) -> ast::NodeId {\n         /*!\n          * Translates an internal id, meaning a node id that is known\n@@ -214,7 +232,7 @@ impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n          * `tr_intern_def_id()` below.\n          */\n \n-        decoder::translate_def_id(self.dcx.cdata, did)\n+        decoder::translate_def_id(self.cdata, did)\n     }\n     pub fn tr_intern_def_id(&self, did: ast::DefId) -> ast::DefId {\n         /*!\n@@ -233,26 +251,26 @@ impl<'a, 'tcx> ExtendedDecodeContext<'a, 'tcx> {\n }\n \n impl tr_intern for ast::DefId {\n-    fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        xcx.tr_intern_def_id(*self)\n+    fn tr_intern(&self, dcx: &DecodeContext) -> ast::DefId {\n+        dcx.tr_intern_def_id(*self)\n     }\n }\n \n impl tr for ast::DefId {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        xcx.tr_def_id(*self)\n+    fn tr(&self, dcx: &DecodeContext) -> ast::DefId {\n+        dcx.tr_def_id(*self)\n     }\n }\n \n impl tr for Option<ast::DefId> {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> Option<ast::DefId> {\n-        self.map(|d| xcx.tr_def_id(d))\n+    fn tr(&self, dcx: &DecodeContext) -> Option<ast::DefId> {\n+        self.map(|d| dcx.tr_def_id(d))\n     }\n }\n \n impl tr for Span {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> Span {\n-        xcx.tr_span(*self)\n+    fn tr(&self, dcx: &DecodeContext) -> Span {\n+        dcx.tr_span(*self)\n     }\n }\n \n@@ -267,18 +285,18 @@ impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n-    fn read_def_id_noxcx(&mut self,\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId;\n+    fn read_def_id_nodcx(&mut self,\n                          cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n-    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n-        did.tr(xcx)\n+        did.tr(dcx)\n     }\n \n-    fn read_def_id_noxcx(&mut self,\n+    fn read_def_id_nodcx(&mut self,\n                          cdata: &cstore::crate_metadata) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n         decoder::translate_def_id(cdata, did)\n@@ -300,7 +318,7 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(rbml_w: &mut Encoder, item: ast::InlinedItem) {\n+fn encode_ast(rbml_w: &mut Encoder, item: &ast::InlinedItem) {\n     rbml_w.start_tag(c::tag_tree as uint);\n     item.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -309,29 +327,36 @@ fn encode_ast(rbml_w: &mut Encoder, item: ast::InlinedItem) {\n struct NestedItemsDropper;\n \n impl Folder for NestedItemsDropper {\n-    fn fold_block(&mut self, blk: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-        let stmts_sans_items = blk.stmts.iter().filter_map(|stmt| {\n-            match stmt.node {\n-                ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => Some(*stmt),\n-                ast::StmtDecl(decl, _) => {\n-                    match decl.node {\n-                        ast::DeclLocal(_) => Some(*stmt),\n-                        ast::DeclItem(_) => None,\n+    fn fold_block(&mut self, blk: P<ast::Block>) -> P<ast::Block> {\n+        blk.and_then(|ast::Block {id, stmts, expr, rules, span, ..}| {\n+            let stmts_sans_items = stmts.move_iter().filter_map(|stmt| {\n+                let use_stmt = match stmt.node {\n+                    ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => true,\n+                    ast::StmtDecl(ref decl, _) => {\n+                        match decl.node {\n+                            ast::DeclLocal(_) => true,\n+                            ast::DeclItem(_) => false,\n+                        }\n                     }\n+                    ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n+                };\n+                if use_stmt {\n+                    Some(stmt)\n+                } else {\n+                    None\n                 }\n-                ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n-            }\n-        }).collect();\n-        let blk_sans_items = ast::P(ast::Block {\n-            view_items: Vec::new(), // I don't know if we need the view_items\n-                                    // here, but it doesn't break tests!\n-            stmts: stmts_sans_items,\n-            expr: blk.expr,\n-            id: blk.id,\n-            rules: blk.rules,\n-            span: blk.span,\n-        });\n-        fold::noop_fold_block(blk_sans_items, self)\n+            }).collect();\n+            let blk_sans_items = P(ast::Block {\n+                view_items: Vec::new(), // I don't know if we need the view_items\n+                                        // here, but it doesn't break tests!\n+                stmts: stmts_sans_items,\n+                expr: expr,\n+                id: id,\n+                rules: rules,\n+                span: span,\n+            });\n+            fold::noop_fold_block(blk_sans_items, self)\n+        })\n     }\n }\n \n@@ -351,27 +376,35 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n     match ii {\n         // HACK we're not dropping items.\n         e::IIItemRef(i) => {\n-            ast::IIItem(fold::noop_fold_item(i, &mut fld)\n+            ast::IIItem(fold::noop_fold_item(P(i.clone()), &mut fld)\n                             .expect_one(\"expected one item\"))\n         }\n-        e::IITraitItemRef(d, iti) => {\n-            ast::IITraitItem(d, match iti {\n-                e::ProvidedInlinedTraitItemRef(m) => {\n-                    ast::ProvidedInlinedTraitItem(\n-                        fold::noop_fold_method(m, &mut fld)\n+        e::IITraitItemRef(d, ti) => {\n+            ast::IITraitItem(d, match *ti {\n+                ast::ProvidedMethod(ref m) => {\n+                    ast::ProvidedMethod(\n+                        fold::noop_fold_method(m.clone(), &mut fld)\n                             .expect_one(\"noop_fold_method must produce \\\n                                          exactly one method\"))\n                 }\n-                e::RequiredInlinedTraitItemRef(m) => {\n-                    ast::RequiredInlinedTraitItem(\n-                        fold::noop_fold_method(m, &mut fld)\n+                ast::RequiredMethod(ref ty_m) => {\n+                    ast::RequiredMethod(\n+                        fold::noop_fold_type_method(ty_m.clone(), &mut fld))\n+                }\n+            })\n+        }\n+        e::IIImplItemRef(d, m) => {\n+            ast::IIImplItem(d, match *m {\n+                ast::MethodImplItem(ref m) => {\n+                    ast::MethodImplItem(\n+                        fold::noop_fold_method(m.clone(), &mut fld)\n                             .expect_one(\"noop_fold_method must produce \\\n                                          exactly one method\"))\n                 }\n             })\n         }\n         e::IIForeignRef(i) => {\n-            ast::IIForeign(fold::noop_fold_foreign_item(i, &mut fld))\n+            ast::IIForeign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))\n         }\n     }\n }\n@@ -382,114 +415,61 @@ fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n     Decodable::decode(&mut d).unwrap()\n }\n \n-struct AstRenumberer<'a, 'tcx: 'a> {\n-    xcx: &'a ExtendedDecodeContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ast_map::FoldOps for AstRenumberer<'a, 'tcx> {\n-    fn new_id(&self, id: ast::NodeId) -> ast::NodeId {\n-        if id == ast::DUMMY_NODE_ID {\n-            // Used by ast_map to map the NodeInlinedParent.\n-            self.xcx.dcx.tcx.sess.next_node_id()\n-        } else {\n-            self.xcx.tr_id(id)\n-        }\n-    }\n-    fn new_span(&self, span: Span) -> Span {\n-        self.xcx.tr_span(span)\n-    }\n-}\n-\n-fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n-                        map: &ast_map::Map,\n-                        path: Vec<ast_map::PathElem> ,\n-                        ii: ast::InlinedItem) -> ast::InlinedItem {\n-    ast_map::map_decoded_item(map,\n-                              path.move_iter().collect(),\n-                              AstRenumberer { xcx: xcx },\n-                              |fld| {\n-        match ii {\n-            ast::IIItem(i) => {\n-                ast::IIItem(fld.fold_item(i).expect_one(\"expected one item\"))\n-            }\n-            ast::IITraitItem(d, iti) => {\n-                match iti {\n-                    ast::ProvidedInlinedTraitItem(m) => {\n-                        ast::IITraitItem(\n-                            xcx.tr_def_id(d),\n-                            ast::ProvidedInlinedTraitItem(\n-                                fld.fold_method(m)\n-                                   .expect_one(\"expected one method\")))\n-                    }\n-                    ast::RequiredInlinedTraitItem(m) => {\n-                        ast::IITraitItem(\n-                            xcx.tr_def_id(d),\n-                            ast::RequiredInlinedTraitItem(\n-                                fld.fold_method(m)\n-                                   .expect_one(\"expected one method\")))\n-                    }\n-                }\n-            }\n-            ast::IIForeign(i) => ast::IIForeign(fld.fold_foreign_item(i))\n-        }\n-    })\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(xcx: &ExtendedDecodeContext, doc: rbml::Doc) -> def::Def {\n+fn decode_def(dcx: &DecodeContext, doc: rbml::Doc) -> def::Def {\n     let mut dsr = reader::Decoder::new(doc);\n     let def: def::Def = Decodable::decode(&mut dsr).unwrap();\n-    def.tr(xcx)\n+    def.tr(dcx)\n }\n \n impl tr for def::Def {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> def::Def {\n+    fn tr(&self, dcx: &DecodeContext) -> def::Def {\n         match *self {\n-          def::DefFn(did, p) => def::DefFn(did.tr(xcx), p),\n+          def::DefFn(did, p) => def::DefFn(did.tr(dcx), p),\n           def::DefStaticMethod(did, wrapped_did2, p) => {\n-            def::DefStaticMethod(did.tr(xcx),\n+            def::DefStaticMethod(did.tr(dcx),\n                                    match wrapped_did2 {\n                                     def::FromTrait(did2) => {\n-                                        def::FromTrait(did2.tr(xcx))\n+                                        def::FromTrait(did2.tr(dcx))\n                                     }\n                                     def::FromImpl(did2) => {\n-                                        def::FromImpl(did2.tr(xcx))\n+                                        def::FromImpl(did2.tr(dcx))\n                                     }\n                                    },\n                                    p)\n           }\n           def::DefMethod(did0, did1) => {\n-            def::DefMethod(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+            def::DefMethod(did0.tr(dcx), did1.map(|did1| did1.tr(dcx)))\n           }\n-          def::DefSelfTy(nid) => { def::DefSelfTy(xcx.tr_id(nid)) }\n-          def::DefMod(did) => { def::DefMod(did.tr(xcx)) }\n-          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(xcx)) }\n-          def::DefStatic(did, m) => { def::DefStatic(did.tr(xcx), m) }\n-          def::DefArg(nid, b) => { def::DefArg(xcx.tr_id(nid), b) }\n-          def::DefLocal(nid, b) => { def::DefLocal(xcx.tr_id(nid), b) }\n+          def::DefSelfTy(nid) => { def::DefSelfTy(dcx.tr_id(nid)) }\n+          def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n+          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n+          def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n+          def::DefArg(nid, b) => { def::DefArg(dcx.tr_id(nid), b) }\n+          def::DefLocal(nid, b) => { def::DefLocal(dcx.tr_id(nid), b) }\n           def::DefVariant(e_did, v_did, is_s) => {\n-            def::DefVariant(e_did.tr(xcx), v_did.tr(xcx), is_s)\n+            def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n-          def::DefTrait(did) => def::DefTrait(did.tr(xcx)),\n-          def::DefTy(did) => def::DefTy(did.tr(xcx)),\n+          def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n+          def::DefTy(did) => def::DefTy(did.tr(dcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n-          def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(xcx), v),\n-          def::DefBinding(nid, bm) => def::DefBinding(xcx.tr_id(nid), bm),\n-          def::DefUse(did) => def::DefUse(did.tr(xcx)),\n+          def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n+          def::DefBinding(nid, bm) => def::DefBinding(dcx.tr_id(nid), bm),\n+          def::DefUse(did) => def::DefUse(did.tr(dcx)),\n           def::DefUpvar(nid1, def, nid2, nid3) => {\n-            def::DefUpvar(xcx.tr_id(nid1),\n-                           box(GC) (*def).tr(xcx),\n-                           xcx.tr_id(nid2),\n-                           xcx.tr_id(nid3))\n+            def::DefUpvar(dcx.tr_id(nid1),\n+                           box(GC) (*def).tr(dcx),\n+                           dcx.tr_id(nid2),\n+                           dcx.tr_id(nid3))\n           }\n-          def::DefStruct(did) => def::DefStruct(did.tr(xcx)),\n-          def::DefRegion(nid) => def::DefRegion(xcx.tr_id(nid)),\n+          def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n+          def::DefRegion(nid) => def::DefRegion(dcx.tr_id(nid)),\n           def::DefTyParamBinder(nid) => {\n-            def::DefTyParamBinder(xcx.tr_id(nid))\n+            def::DefTyParamBinder(dcx.tr_id(nid))\n           }\n-          def::DefLabel(nid) => def::DefLabel(xcx.tr_id(nid))\n+          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid))\n         }\n     }\n }\n@@ -498,44 +478,44 @@ impl tr for def::Def {\n // Encoding and decoding of ancillary information\n \n impl tr for ty::Region {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::Region {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::Region {\n         match *self {\n             ty::ReLateBound(id, br) => {\n-                ty::ReLateBound(xcx.tr_id(id), br.tr(xcx))\n+                ty::ReLateBound(dcx.tr_id(id), br.tr(dcx))\n             }\n             ty::ReEarlyBound(id, space, index, ident) => {\n-                ty::ReEarlyBound(xcx.tr_id(id), space, index, ident)\n+                ty::ReEarlyBound(dcx.tr_id(id), space, index, ident)\n             }\n             ty::ReScope(id) => {\n-                ty::ReScope(xcx.tr_id(id))\n+                ty::ReScope(dcx.tr_id(id))\n             }\n             ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => {\n                 *self\n             }\n             ty::ReFree(ref fr) => {\n-                ty::ReFree(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n-                                            bound_region: fr.bound_region.tr(xcx)})\n+                ty::ReFree(ty::FreeRegion {scope_id: dcx.tr_id(fr.scope_id),\n+                                            bound_region: fr.bound_region.tr(dcx)})\n             }\n         }\n     }\n }\n \n impl tr for ty::BoundRegion {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::BoundRegion {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::BoundRegion {\n         match *self {\n             ty::BrAnon(_) |\n             ty::BrFresh(_) => *self,\n-            ty::BrNamed(id, ident) => ty::BrNamed(xcx.tr_def_id(id),\n+            ty::BrNamed(id, ident) => ty::BrNamed(dcx.tr_def_id(id),\n                                                     ident),\n         }\n     }\n }\n \n impl tr for ty::TraitStore {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::TraitStore {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::TraitStore {\n         match *self {\n             ty::RegionTraitStore(r, m) => {\n-                ty::RegionTraitStore(r.tr(xcx), m)\n+                ty::RegionTraitStore(r.tr(dcx), m)\n             }\n             ty::UniqTraitStore => ty::UniqTraitStore\n         }\n@@ -554,16 +534,16 @@ fn encode_capture_mode(rbml_w: &mut Encoder, cm: CaptureMode) {\n }\n \n trait rbml_decoder_helper {\n-    fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> freevar_entry;\n     fn read_capture_mode(&mut self) -> CaptureMode;\n }\n \n impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n-    fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_freevar_entry(&mut self, dcx: &DecodeContext)\n                           -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self).unwrap();\n-        fv.tr(xcx)\n+        fv.tr(dcx)\n     }\n \n     fn read_capture_mode(&mut self) -> CaptureMode {\n@@ -573,19 +553,19 @@ impl<'a> rbml_decoder_helper for reader::Decoder<'a> {\n }\n \n impl tr for freevar_entry {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> freevar_entry {\n+    fn tr(&self, dcx: &DecodeContext) -> freevar_entry {\n         freevar_entry {\n-            def: self.def.tr(xcx),\n-            span: self.span.tr(xcx),\n+            def: self.def.tr(dcx),\n+            span: self.span.tr(dcx),\n         }\n     }\n }\n \n impl tr for ty::UpvarBorrow {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> ty::UpvarBorrow {\n+    fn tr(&self, dcx: &DecodeContext) -> ty::UpvarBorrow {\n         ty::UpvarBorrow {\n             kind: self.kind,\n-            region: self.region.tr(xcx)\n+            region: self.region.tr(dcx)\n         }\n     }\n }\n@@ -594,7 +574,7 @@ impl tr for ty::UpvarBorrow {\n // Encoding and decoding of MethodCallee\n \n trait read_method_callee_helper {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_method_callee(&mut self, dcx: &DecodeContext)\n         -> (typeck::ExprAdjustment, MethodCallee);\n }\n \n@@ -621,7 +601,7 @@ fn encode_method_callee(ecx: &e::EncodeContext,\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n-    fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_method_callee(&mut self, dcx: &DecodeContext)\n         -> (typeck::ExprAdjustment, MethodCallee) {\n \n         self.read_struct(\"MethodCallee\", 4, |this| {\n@@ -632,38 +612,38 @@ impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n                 origin: this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n                         Decodable::decode(this).unwrap();\n-                    Ok(method_origin.tr(xcx))\n+                    Ok(method_origin.tr(dcx))\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 2, |this| {\n-                    Ok(this.read_ty(xcx))\n+                    Ok(this.read_ty(dcx))\n                 }).unwrap(),\n                 substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    Ok(this.read_substs(xcx))\n+                    Ok(this.read_substs(dcx))\n                 }).unwrap()\n             }))\n         }).unwrap()\n     }\n }\n \n impl tr for MethodOrigin {\n-    fn tr(&self, xcx: &ExtendedDecodeContext) -> MethodOrigin {\n+    fn tr(&self, dcx: &DecodeContext) -> MethodOrigin {\n         match *self {\n-            typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(xcx)),\n+            typeck::MethodStatic(did) => typeck::MethodStatic(did.tr(dcx)),\n             typeck::MethodStaticUnboxedClosure(did) => {\n-                typeck::MethodStaticUnboxedClosure(did.tr(xcx))\n+                typeck::MethodStaticUnboxedClosure(did.tr(dcx))\n             }\n             typeck::MethodParam(ref mp) => {\n                 typeck::MethodParam(\n                     typeck::MethodParam {\n-                        trait_id: mp.trait_id.tr(xcx),\n+                        trait_id: mp.trait_id.tr(dcx),\n                         .. *mp\n                     }\n                 )\n             }\n             typeck::MethodObject(ref mo) => {\n                 typeck::MethodObject(\n                     typeck::MethodObject {\n-                        trait_id: mo.trait_id.tr(xcx),\n+                        trait_id: mo.trait_id.tr(dcx),\n                         .. *mo\n                     }\n                 )\n@@ -862,10 +842,10 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                   0 => {\n                     typeck::vtable_static(\n                         this.read_enum_variant_arg(0u, |this| {\n-                            Ok(this.read_def_id_noxcx(cdata))\n+                            Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap(),\n                         this.read_enum_variant_arg(1u, |this| {\n-                            Ok(this.read_substs_noxcx(tcx, cdata))\n+                            Ok(this.read_substs_nodcx(tcx, cdata))\n                         }).unwrap(),\n                         this.read_enum_variant_arg(2u, |this| {\n                             Ok(this.read_vtable_res(tcx, cdata))\n@@ -885,7 +865,7 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                   2 => {\n                     typeck::vtable_unboxed_closure(\n                         this.read_enum_variant_arg(0u, |this| {\n-                            Ok(this.read_def_id_noxcx(cdata))\n+                            Ok(this.read_def_id_nodcx(cdata))\n                         }).unwrap()\n                     )\n                   }\n@@ -1398,40 +1378,40 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers {\n-    fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t>;\n-    fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t;\n+    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t>;\n+    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef;\n-    fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_polytype(&mut self, dcx: &DecodeContext)\n                      -> ty::Polytype;\n-    fn read_existential_bounds(&mut self, xcx: &ExtendedDecodeContext) -> ty::ExistentialBounds;\n-    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs;\n-    fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment;\n-    fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds;\n+    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs;\n+    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment;\n+    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n                             -> ty::UnboxedClosure;\n-    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef;\n-    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef;\n-    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind;\n+    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef;\n+    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef;\n+    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind;\n     fn convert_def_id(&mut self,\n-                      xcx: &ExtendedDecodeContext,\n+                      dcx: &DecodeContext,\n                       source: DefIdSource,\n                       did: ast::DefId)\n                       -> ast::DefId;\n \n     // Versions of the type reading functions that don't need the full\n-    // ExtendedDecodeContext.\n-    fn read_ty_noxcx(&mut self,\n+    // DecodeContext.\n+    fn read_ty_nodcx(&mut self,\n                      tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t;\n-    fn read_tys_noxcx(&mut self,\n+    fn read_tys_nodcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t>;\n-    fn read_substs_noxcx(&mut self, tcx: &ty::ctxt,\n+    fn read_substs_nodcx(&mut self, tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n                          -> subst::Substs;\n }\n \n impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n-    fn read_ty_noxcx(&mut self,\n+    fn read_ty_nodcx(&mut self,\n                      tcx: &ty::ctxt, cdata: &cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             Ok(tydecode::parse_ty_data(\n@@ -1443,16 +1423,16 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_tys_noxcx(&mut self,\n+    fn read_tys_nodcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: &cstore::crate_metadata) -> Vec<ty::t> {\n-        self.read_to_vec(|this| Ok(this.read_ty_noxcx(tcx, cdata)) )\n+        self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .move_iter()\n             .collect()\n     }\n \n-    fn read_substs_noxcx(&mut self,\n+    fn read_substs_nodcx(&mut self,\n                          tcx: &ty::ctxt,\n                          cdata: &cstore::crate_metadata)\n                          -> subst::Substs\n@@ -1467,7 +1447,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_ty(&mut self, xcx: &ExtendedDecodeContext) -> ty::t {\n+    fn read_ty(&mut self, dcx: &DecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1478,10 +1458,10 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n             let ty = tydecode::parse_ty_data(\n                 doc.data,\n-                xcx.dcx.cdata.cnum,\n+                dcx.cdata.cnum,\n                 doc.start,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a));\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a));\n \n             Ok(ty)\n         }).unwrap();\n@@ -1495,23 +1475,23 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }\n     }\n \n-    fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t> {\n-        self.read_to_vec(|this| Ok(this.read_ty(xcx))).unwrap().move_iter().collect()\n+    fn read_tys(&mut self, dcx: &DecodeContext) -> Vec<ty::t> {\n+        self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().move_iter().collect()\n     }\n \n-    fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_type_param_def(&mut self, dcx: &DecodeContext)\n                            -> ty::TypeParameterDef {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_type_param_def_data(\n                 doc.data,\n                 doc.start,\n-                xcx.dcx.cdata.cnum,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a)))\n+                dcx.cdata.cnum,\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap()\n     }\n \n-    fn read_polytype(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_polytype(&mut self, dcx: &DecodeContext)\n                                    -> ty::Polytype {\n         self.read_struct(\"Polytype\", 2, |this| {\n             Ok(ty::Polytype {\n@@ -1521,7 +1501,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                             types:\n                             this.read_struct_field(\"types\", 0, |this| {\n                                 Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_type_param_def(xcx)))\n+                                    |this| this.read_type_param_def(dcx)))\n                             }).unwrap(),\n \n                             regions:\n@@ -1533,34 +1513,34 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     })\n                 }).unwrap(),\n                 ty: this.read_struct_field(\"ty\", 1, |this| {\n-                    Ok(this.read_ty(xcx))\n+                    Ok(this.read_ty(dcx))\n                 }).unwrap()\n             })\n         }).unwrap()\n     }\n \n-    fn read_existential_bounds(&mut self, xcx: &ExtendedDecodeContext) -> ty::ExistentialBounds\n+    fn read_existential_bounds(&mut self, dcx: &DecodeContext) -> ty::ExistentialBounds\n     {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_existential_bounds_data(doc.data,\n-                                                       xcx.dcx.cdata.cnum,\n+                                                       dcx.cdata.cnum,\n                                                        doc.start,\n-                                                       xcx.dcx.tcx,\n-                                                       |s, a| this.convert_def_id(xcx, s, a)))\n+                                                       dcx.tcx,\n+                                                       |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap()\n     }\n \n-    fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> subst::Substs {\n+    fn read_substs(&mut self, dcx: &DecodeContext) -> subst::Substs {\n         self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_substs_data(doc.data,\n-                                        xcx.dcx.cdata.cnum,\n+                                        dcx.cdata.cnum,\n                                         doc.start,\n-                                        xcx.dcx.tcx,\n-                                        |s, a| this.convert_def_id(xcx, s, a)))\n+                                        dcx.tcx,\n+                                        |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap()\n     }\n \n-    fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n+    fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1569,12 +1549,12 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AutoAddEnv(store.tr(xcx))\n+                        ty::AutoAddEnv(store.tr(dcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_auto_deref_ref(xcx))).unwrap();\n+                                |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n \n                         ty::AutoDerefRef(auto_deref_ref)\n                     }\n@@ -1584,7 +1564,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_auto_deref_ref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoDerefRef {\n+    fn read_auto_deref_ref(&mut self, dcx: &DecodeContext) -> ty::AutoDerefRef {\n         self.read_struct(\"AutoDerefRef\", 2, |this| {\n             Ok(ty::AutoDerefRef {\n                 autoderefs: this.read_struct_field(\"autoderefs\", 0, |this| {\n@@ -1593,7 +1573,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 autoref: this.read_struct_field(\"autoref\", 1, |this| {\n                     this.read_option(|this, b| {\n                         if b {\n-                            Ok(Some(this.read_autoref(xcx)))\n+                            Ok(Some(this.read_autoref(dcx)))\n                         } else {\n                             Ok(None)\n                         }\n@@ -1603,7 +1583,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_autoref(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoRef {\n+    fn read_autoref(&mut self, dcx: &DecodeContext) -> ty::AutoRef {\n         self.read_enum(\"AutoRef\", |this| {\n             let variants = [\"AutoPtr\",\n                             \"AutoUnsize\",\n@@ -1619,25 +1599,25 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let a: Option<Box<ty::AutoRef>> =\n                             this.read_enum_variant_arg(2, |this| this.read_option(|this, b| {\n                                 if b {\n-                                    Ok(Some(box this.read_autoref(xcx)))\n+                                    Ok(Some(box this.read_autoref(dcx)))\n                                 } else {\n                                     Ok(None)\n                                 }\n                             })).unwrap();\n \n-                        ty::AutoPtr(r.tr(xcx), m, a)\n+                        ty::AutoPtr(r.tr(dcx), m, a)\n                     }\n                     1 => {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n \n                         ty::AutoUnsize(uk)\n                     }\n                     2 => {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n \n                         ty::AutoUnsizeUniq(uk)\n                     }\n@@ -1647,7 +1627,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let a: Option<Box<ty::AutoRef>> =\n                             this.read_enum_variant_arg(1, |this| this.read_option(|this, b| {\n                                 if b {\n-                                    Ok(Some(box this.read_autoref(xcx)))\n+                                    Ok(Some(box this.read_autoref(dcx)))\n                                 } else {\n                                     Ok(None)\n                                 }\n@@ -1661,7 +1641,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_unsize_kind(&mut self, xcx: &ExtendedDecodeContext) -> ty::UnsizeKind {\n+    fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind {\n         self.read_enum(\"UnsizeKind\", |this| {\n             let variants = [\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n             this.read_enum_variant(variants, |this, i| {\n@@ -1675,7 +1655,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     1 => {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n-                                |this| Ok(this.read_unsize_kind(xcx))).unwrap();\n+                                |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n                         let idx: uint =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n@@ -1684,29 +1664,29 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     2 => {\n                         let b =\n                             this.read_enum_variant_arg(\n-                                0, |this| Ok(this.read_existential_bounds(xcx))).unwrap();\n+                                0, |this| Ok(this.read_existential_bounds(dcx))).unwrap();\n                         let def_id: ast::DefId =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n                         let substs = this.read_enum_variant_arg(2,\n-                            |this| Ok(this.read_substs(xcx))).unwrap();\n+                            |this| Ok(this.read_substs(dcx))).unwrap();\n \n-                        ty::UnsizeVtable(b, def_id.tr(xcx), substs)\n+                        ty::UnsizeVtable(b, def_id.tr(dcx), substs)\n                     }\n                     _ => fail!(\"bad enum variant for ty::UnsizeKind\")\n                 })\n             })\n         }).unwrap()\n     }\n \n-    fn read_unboxed_closure(&mut self, xcx: &ExtendedDecodeContext)\n+    fn read_unboxed_closure(&mut self, dcx: &DecodeContext)\n                             -> ty::UnboxedClosure {\n         let closure_type = self.read_opaque(|this, doc| {\n             Ok(tydecode::parse_ty_closure_data(\n                 doc.data,\n-                xcx.dcx.cdata.cnum,\n+                dcx.cdata.cnum,\n                 doc.start,\n-                xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a)))\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap();\n         let variants = [\n             \"FnUnboxedClosureKind\",\n@@ -1728,7 +1708,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn convert_def_id(&mut self,\n-                      xcx: &ExtendedDecodeContext,\n+                      dcx: &DecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::DefId)\n                       -> ast::DefId {\n@@ -1761,29 +1741,28 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n          */\n \n         let r = match source {\n-            NominalType | TypeWithId | RegionParameter => xcx.tr_def_id(did),\n-            TypeParameter => xcx.tr_intern_def_id(did)\n+            NominalType | TypeWithId | RegionParameter => dcx.tr_def_id(did),\n+            TypeParameter => dcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);\n         return r;\n     }\n }\n \n-fn decode_side_tables(xcx: &ExtendedDecodeContext,\n+fn decode_side_tables(dcx: &DecodeContext,\n                       ast_doc: rbml::Doc) {\n-    let dcx = xcx.dcx;\n     let tbl_doc = ast_doc.get(c::tag_table as uint);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n         let id0 = entry_doc.get(c::tag_table_id as uint).as_int();\n-        let id = xcx.tr_id(id0 as ast::NodeId);\n+        let id = dcx.tr_id(id0 as ast::NodeId);\n \n         debug!(\">> Side table document with tag 0x{:x} \\\n                 found for id {} (orig {})\",\n                tag, id, id0);\n \n         match c::astencode_tag::from_uint(tag) {\n             None => {\n-                xcx.dcx.tcx.sess.bug(\n+                dcx.tcx.sess.bug(\n                     format!(\"unknown tag found in side tables: {:x}\",\n                             tag).as_slice());\n             }\n@@ -1794,36 +1773,36 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n \n                 match value {\n                     c::tag_table_def => {\n-                        let def = decode_def(xcx, val_doc);\n+                        let def = decode_def(dcx, val_doc);\n                         dcx.tcx.def_map.borrow_mut().insert(id, def);\n                     }\n                     c::tag_table_node_type => {\n-                        let ty = val_dsr.read_ty(xcx);\n+                        let ty = val_dsr.read_ty(dcx);\n                         debug!(\"inserting ty for node {:?}: {}\",\n                                id, ty_to_string(dcx.tcx, ty));\n                         dcx.tcx.node_types.borrow_mut().insert(id as uint, ty);\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {\n-                            substs: val_dsr.read_substs(xcx)\n+                            substs: val_dsr.read_substs(dcx)\n                         };\n                         dcx.tcx.item_substs.borrow_mut().insert(\n                             id, item_substs);\n                     }\n                     c::tag_table_freevars => {\n                         let fv_info = val_dsr.read_to_vec(|val_dsr| {\n-                            Ok(val_dsr.read_freevar_entry(xcx))\n+                            Ok(val_dsr.read_freevar_entry(dcx))\n                         }).unwrap().move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_upvar_borrow_map => {\n                         let var_id: ast::NodeId = Decodable::decode(val_dsr).unwrap();\n                         let upvar_id = ty::UpvarId {\n-                            var_id: xcx.tr_id(var_id),\n+                            var_id: dcx.tr_id(var_id),\n                             closure_expr_id: id\n                         };\n                         let ub: ty::UpvarBorrow = Decodable::decode(val_dsr).unwrap();\n-                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(xcx));\n+                        dcx.tcx.upvar_borrow_map.borrow_mut().insert(upvar_id, ub.tr(dcx));\n                     }\n                     c::tag_table_capture_modes => {\n                         let capture_mode = val_dsr.read_capture_mode();\n@@ -1833,16 +1812,16 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                            .insert(id, capture_mode);\n                     }\n                     c::tag_table_tcache => {\n-                        let pty = val_dsr.read_polytype(xcx);\n+                        let pty = val_dsr.read_polytype(dcx);\n                         let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n                         dcx.tcx.tcache.borrow_mut().insert(lid, pty);\n                     }\n                     c::tag_table_param_defs => {\n-                        let bounds = val_dsr.read_type_param_def(xcx);\n+                        let bounds = val_dsr.read_type_param_def(dcx);\n                         dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n                     }\n                     c::tag_table_method_map => {\n-                        let (adjustment, method) = val_dsr.read_method_callee(xcx);\n+                        let (adjustment, method) = val_dsr.read_method_callee(dcx);\n                         let method_call = MethodCall {\n                             expr_id: id,\n                             adjustment: adjustment\n@@ -1851,29 +1830,29 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                     }\n                     c::tag_table_vtable_map => {\n                         let (adjustment, vtable_res) =\n-                            val_dsr.read_vtable_res_with_key(xcx.dcx.tcx,\n-                                                             xcx.dcx.cdata);\n+                            val_dsr.read_vtable_res_with_key(dcx.tcx,\n+                                                             dcx.cdata);\n                         let vtable_key = MethodCall {\n                             expr_id: id,\n                             adjustment: adjustment\n                         };\n                         dcx.tcx.vtable_map.borrow_mut().insert(vtable_key, vtable_res);\n                     }\n                     c::tag_table_adjustments => {\n-                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(xcx);\n+                        let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);\n                     }\n                     c::tag_table_unboxed_closures => {\n                         let unboxed_closure =\n-                            val_dsr.read_unboxed_closure(xcx);\n+                            val_dsr.read_unboxed_closure(dcx);\n                         dcx.tcx\n                            .unboxed_closures\n                            .borrow_mut()\n                            .insert(ast_util::local_def(id),\n                                    unboxed_closure);\n                     }\n                     _ => {\n-                        xcx.dcx.tcx.sess.bug(\n+                        dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\",\n                                     tag).as_slice());\n                     }\n@@ -1890,17 +1869,17 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(rbml_w: &mut Encoder, item: Gc<ast::Item>) {\n+fn encode_item_ast(rbml_w: &mut Encoder, item: &ast::Item) {\n     rbml_w.start_tag(c::tag_tree as uint);\n     (*item).encode(rbml_w);\n     rbml_w.end_tag();\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: rbml::Doc) -> Gc<ast::Item> {\n+fn decode_item_ast(par_doc: rbml::Doc) -> ast::Item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder::new(chi_doc);\n-    box(GC) Decodable::decode(&mut d).unwrap()\n+    Decodable::decode(&mut d).unwrap()\n }\n \n #[cfg(test)]\n@@ -1935,17 +1914,14 @@ fn mk_ctxt() -> parse::ParseSess {\n }\n \n #[cfg(test)]\n-fn roundtrip(in_item: Option<Gc<ast::Item>>) {\n+fn roundtrip(in_item: Option<P<ast::Item>>) {\n     let in_item = in_item.unwrap();\n     let mut wr = SeekableMemWriter::new();\n-    {\n-        let mut rbml_w = writer::Encoder::new(&mut wr);\n-        encode_item_ast(&mut rbml_w, in_item);\n-    }\n+    encode_item_ast(&mut writer::Encoder::new(&mut wr), &*in_item);\n     let rbml_doc = rbml::Doc::new(wr.get_ref());\n     let out_item = decode_item_ast(rbml_doc);\n \n-    assert!(in_item == out_item);\n+    assert!(*in_item == out_item);\n }\n \n #[test]"}, {"sha": "c789db5be0c012d3fdc9b884fc682d9311316077", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -44,7 +44,7 @@ impl Variant {\n }\n \n pub struct DataflowLabeller<'a, 'tcx: 'a> {\n-    pub inner: cfg_dot::LabelledCFG<'a>,\n+    pub inner: cfg_dot::LabelledCFG<'a, 'tcx>,\n     pub variants: Vec<Variant>,\n     pub borrowck_ctxt: &'a BorrowckCtxt<'a, 'tcx>,\n     pub analysis_data: &'a borrowck::AnalysisData<'a, 'tcx>,"}, {"sha": "0d584a7664f67e81e2002bbcedf016b27710dcf2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 31, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -22,9 +22,7 @@ use middle::mem_categorization as mc;\n use middle::ty;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n-use std::cell::{Cell};\n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n@@ -71,34 +69,33 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        stats: box(GC) BorrowStats {\n-            loaned_paths_same: Cell::new(0),\n-            loaned_paths_imm: Cell::new(0),\n-            stable_paths: Cell::new(0),\n-            guaranteed_paths: Cell::new(0),\n+        stats: BorrowStats {\n+            loaned_paths_same: 0,\n+            loaned_paths_imm: 0,\n+            stable_paths: 0,\n+            guaranteed_paths: 0\n         }\n     };\n \n-    visit::walk_crate(&mut bccx, krate);\n+    visit::walk_crate(&mut bccx, tcx.map.krate());\n \n     if tcx.sess.borrowck_stats() {\n         println!(\"--- borrowck stats ---\");\n         println!(\"paths requiring guarantees: {}\",\n-                 bccx.stats.guaranteed_paths.get());\n+                 bccx.stats.guaranteed_paths);\n         println!(\"paths requiring loans     : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_same.get()));\n+                 make_stat(&bccx, bccx.stats.loaned_paths_same));\n         println!(\"paths requiring imm loans : {}\",\n-                 make_stat(&bccx, bccx.stats.loaned_paths_imm.get()));\n+                 make_stat(&bccx, bccx.stats.loaned_paths_imm));\n         println!(\"stable paths              : {}\",\n-                 make_stat(&bccx, bccx.stats.stable_paths.get()));\n+                 make_stat(&bccx, bccx.stats.stable_paths));\n     }\n \n     fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> String {\n-        let total = bccx.stats.guaranteed_paths.get() as f64;\n+        let total = bccx.stats.guaranteed_paths as f64;\n         let perc = if total == 0.0 { 0.0 } else { stat as f64 * 100.0 / total };\n         format!(\"{} ({:.0f}%)\", stat, perc)\n     }\n@@ -110,8 +107,8 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n     // loan step is intended for things that have a data\n     // flow dependent conditions.\n     match item.node {\n-        ast::ItemStatic(_, _, ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, &*ex);\n+        ast::ItemStatic(_, _, ref ex) => {\n+            gather_loans::gather_loans_in_static_initializer(this, &**ex);\n         }\n         _ => {\n             visit::walk_item(this, item);\n@@ -206,11 +203,11 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n-        stats: box(GC) BorrowStats {\n-            loaned_paths_same: Cell::new(0),\n-            loaned_paths_imm: Cell::new(0),\n-            stable_paths: Cell::new(0),\n-            guaranteed_paths: Cell::new(0),\n+        stats: BorrowStats {\n+            loaned_paths_same: 0,\n+            loaned_paths_imm: 0,\n+            stable_paths: 0,\n+            guaranteed_paths: 0\n         }\n     };\n \n@@ -234,14 +231,14 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n \n     // Statistics:\n-    stats: Gc<BorrowStats>,\n+    stats: BorrowStats\n }\n \n-pub struct BorrowStats {\n-    loaned_paths_same: Cell<uint>,\n-    loaned_paths_imm: Cell<uint>,\n-    stable_paths: Cell<uint>,\n-    guaranteed_paths: Cell<uint>,\n+struct BorrowStats {\n+    loaned_paths_same: uint,\n+    loaned_paths_imm: uint,\n+    stable_paths: uint,\n+    guaranteed_paths: uint\n }\n \n pub type BckResult<T> = Result<T, BckError>;\n@@ -290,9 +287,9 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                     tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprProc(_, block) |\n-            ast::ExprFnBlock(_, _, block) |\n-            ast::ExprUnboxedFn(_, _, _, block) => { block.id }\n+            ast::ExprProc(_, ref block) |\n+            ast::ExprFnBlock(_, _, ref block) |\n+            ast::ExprUnboxedFn(_, _, _, ref block) => { block.id }\n             _ => fail!(\"encountered non-closure id: {}\", closure_id)\n         },\n         _ => fail!(\"encountered non-expr id: {}\", closure_id)"}, {"sha": "05cc61a754749b1d4af538ca5b78fe73d11c0a7d", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 78, "deletions": 87, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -15,10 +15,9 @@ use middle::typeck;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::ptr::P;\n use util::nodemap::NodeMap;\n \n-use std::gc::Gc;\n-\n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     exit_map: NodeMap<CFGIndex>,\n@@ -69,23 +68,23 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &ast::Block, pred: CFGIndex) -> CFGIndex {\n         let mut stmts_exit = pred;\n         for stmt in blk.stmts.iter() {\n-            stmts_exit = self.stmt(stmt.clone(), stmts_exit);\n+            stmts_exit = self.stmt(&**stmt, stmts_exit);\n         }\n \n-        let expr_exit = self.opt_expr(blk.expr.clone(), stmts_exit);\n+        let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n         self.add_node(blk.id, [expr_exit])\n     }\n \n-    fn stmt(&mut self, stmt: Gc<ast::Stmt>, pred: CFGIndex) -> CFGIndex {\n+    fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             ast::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n                 self.add_node(id, [exit])\n             }\n \n             ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n-                let exit = self.expr(expr.clone(), pred);\n+                let exit = self.expr(&**expr, pred);\n                 self.add_node(id, [exit])\n             }\n \n@@ -98,7 +97,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn decl(&mut self, decl: &ast::Decl, pred: CFGIndex) -> CFGIndex {\n         match decl.node {\n             ast::DeclLocal(ref local) => {\n-                let init_exit = self.opt_expr(local.init.clone(), pred);\n+                let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&*local.pat, init_exit)\n             }\n \n@@ -127,24 +126,20 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n-                let pats_exit =\n-                    self.pats_all(subpats.iter().map(|p| p.clone()), pred);\n+                let pats_exit = self.pats_all(subpats.iter(), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().map(|f| f.pat.clone()), pred);\n+                    self.pats_all(subpats.iter().map(|f| &f.pat), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::PatVec(ref pre, ref vec, ref post) => {\n-                let pre_exit =\n-                    self.pats_all(pre.iter().map(|p| *p), pred);\n-                let vec_exit =\n-                    self.pats_all(vec.iter().map(|p| *p), pre_exit);\n-                let post_exit =\n-                    self.pats_all(post.iter().map(|p| *p), vec_exit);\n+                let pre_exit = self.pats_all(pre.iter(), pred);\n+                let vec_exit = self.pats_all(vec.iter(), pre_exit);\n+                let post_exit = self.pats_all(post.iter(), vec_exit);\n                 self.add_node(pat.id, [post_exit])\n             }\n \n@@ -154,32 +149,32 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn pats_all<I: Iterator<Gc<ast::Pat>>>(&mut self,\n-                                        pats: I,\n-                                        pred: CFGIndex) -> CFGIndex {\n+    fn pats_all<'a, I: Iterator<&'a P<ast::Pat>>>(&mut self,\n+                                          pats: I,\n+                                          pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n         let mut pats = pats;\n-        pats.fold(pred, |pred, pat| self.pat(&*pat, pred))\n+        pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n     }\n \n     fn pats_any(&mut self,\n-                pats: &[Gc<ast::Pat>],\n+                pats: &[P<ast::Pat>],\n                 pred: CFGIndex) -> CFGIndex {\n         //! Handles case where just one of the patterns must match.\n \n         if pats.len() == 1 {\n             self.pat(&*pats[0], pred)\n         } else {\n             let collect = self.add_dummy_node([]);\n-            for &pat in pats.iter() {\n-                let pat_exit = self.pat(&*pat, pred);\n+            for pat in pats.iter() {\n+                let pat_exit = self.pat(&**pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n             }\n             collect\n         }\n     }\n \n-    fn expr(&mut self, expr: Gc<ast::Expr>, pred: CFGIndex) -> CFGIndex {\n+    fn expr(&mut self, expr: &ast::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n@@ -201,7 +196,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3   v 4\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n                 self.add_node(expr.id, [cond_exit, then_exit])           // 3,4\n             }\n@@ -221,9 +216,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 4   v 5\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(cond.clone(), pred);           // 1\n+                let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n-                let else_exit = self.expr(otherwise.clone(), cond_exit); // 3\n+                let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n                 self.add_node(expr.id, [then_exit, else_exit])           // 4, 5\n             }\n \n@@ -247,7 +242,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node([pred]);              // 1\n-                let cond_exit = self.expr(cond.clone(), loopback);       // 2\n+                let cond_exit = self.expr(&**cond, loopback);            // 2\n                 let expr_exit = self.add_node(expr.id, [cond_exit]);     // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n@@ -283,7 +278,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n-                let head = self.expr(head.clone(), pred);       // 1\n+                let head = self.expr(&**head, pred);            // 1\n                 let loopback = self.add_dummy_node([head]);     // 2\n                 let cond = self.add_dummy_node([loopback]);     // 3\n                 let expr_exit = self.add_node(expr.id, [cond]); // 4\n@@ -353,18 +348,17 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //     v 6   v    v\n                 //  [.....expr.....]\n                 //\n-                let discr_exit = self.expr(discr.clone(), pred);         // 1\n+                let discr_exit = self.expr(&**discr, pred);              // 1\n \n                 let expr_exit = self.add_node(expr.id, []);\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node([cond_exit]);        // 2\n                     let pats_exit = self.pats_any(arm.pats.as_slice(),\n                                                   cond_exit);            // 3\n-                    let guard_exit = self.opt_expr(arm.guard,\n+                    let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n-                    let body_exit = self.expr(arm.body.clone(),\n-                                              guard_exit);               // 5\n+                    let body_exit = self.expr(&*arm.body, guard_exit);   // 5\n                     self.add_contained_edge(body_exit, expr_exit);       // 6\n                 }\n                 expr_exit\n@@ -385,13 +379,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(l.clone(), pred);                  // 1\n-                let r_exit = self.expr(r.clone(), l_exit);               // 2\n+                let l_exit = self.expr(&**l, pred);                      // 1\n+                let r_exit = self.expr(&**r, l_exit);                    // 2\n                 self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n             }\n \n             ast::ExprRet(ref v) => {\n-                let v_exit = self.opt_expr(v.clone(), pred);\n+                let v_exit = self.opt_expr(v, pred);\n                 let b = self.add_node(expr.id, [v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_node(ast::DUMMY_NODE_ID, [])\n@@ -414,76 +408,74 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprVec(ref elems) => {\n-                self.straightline(expr, pred, elems.as_slice())\n+                self.straightline(expr, pred, elems.iter().map(|e| &**e))\n             }\n \n             ast::ExprCall(ref func, ref args) => {\n-                self.call(expr, pred, func.clone(), args.as_slice())\n+                self.call(expr, pred, &**func, args.iter().map(|e| &**e))\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, *args.get(0), args.slice_from(1))\n+                self.call(expr, pred, &**args.get(0), args.slice_from(1).iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |\n-            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(&*expr) => {\n-                self.call(expr, pred, l.clone(), [r.clone()])\n+            ast::ExprBinary(_, ref l, ref r) if self.is_method_call(expr) => {\n+                self.call(expr, pred, &**l, Some(&**r).move_iter())\n             }\n \n-            ast::ExprUnary(_, ref e) if self.is_method_call(&*expr) => {\n-                self.call(expr, pred, e.clone(), [])\n+            ast::ExprUnary(_, ref e) if self.is_method_call(expr) => {\n+                self.call(expr, pred, &**e, None::<ast::Expr>.iter())\n             }\n \n             ast::ExprTup(ref exprs) => {\n-                self.straightline(expr, pred, exprs.as_slice())\n+                self.straightline(expr, pred, exprs.iter().map(|e| &**e))\n             }\n \n-            ast::ExprStruct(_, ref fields, base) => {\n+            ast::ExprStruct(_, ref fields, ref base) => {\n                 let base_exit = self.opt_expr(base, pred);\n-                let field_exprs: Vec<Gc<ast::Expr>> =\n-                    fields.iter().map(|f| f.expr).collect();\n-                self.straightline(expr, base_exit, field_exprs.as_slice())\n+                self.straightline(expr, base_exit, fields.iter().map(|f| &*f.expr))\n             }\n \n-            ast::ExprRepeat(elem, count) => {\n-                self.straightline(expr, pred, [elem, count])\n+            ast::ExprRepeat(ref elem, ref count) => {\n+                self.straightline(expr, pred, [elem, count].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprAssign(l, r) |\n-            ast::ExprAssignOp(_, l, r) => {\n-                self.straightline(expr, pred, [r, l])\n+            ast::ExprAssign(ref l, ref r) |\n+            ast::ExprAssignOp(_, ref l, ref r) => {\n+                self.straightline(expr, pred, [r, l].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) => { // NB: && and || handled earlier\n-                self.straightline(expr, pred, [l, r])\n+            ast::ExprIndex(ref l, ref r) |\n+            ast::ExprBinary(_, ref l, ref r) => { // NB: && and || handled earlier\n+                self.straightline(expr, pred, [l, r].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprBox(p, e) => {\n-                self.straightline(expr, pred, [p, e])\n+            ast::ExprBox(ref p, ref e) => {\n+                self.straightline(expr, pred, [p, e].iter().map(|&e| &**e))\n             }\n \n-            ast::ExprAddrOf(_, e) |\n-            ast::ExprCast(e, _) |\n-            ast::ExprUnary(_, e) |\n-            ast::ExprParen(e) |\n-            ast::ExprField(e, _, _) |\n-            ast::ExprTupField(e, _, _) => {\n-                self.straightline(expr, pred, [e])\n+            ast::ExprAddrOf(_, ref e) |\n+            ast::ExprCast(ref e, _) |\n+            ast::ExprUnary(_, ref e) |\n+            ast::ExprParen(ref e) |\n+            ast::ExprField(ref e, _, _) |\n+            ast::ExprTupField(ref e, _, _) => {\n+                self.straightline(expr, pred, Some(&**e).move_iter())\n             }\n \n             ast::ExprInlineAsm(ref inline_asm) => {\n                 let inputs = inline_asm.inputs.iter();\n                 let outputs = inline_asm.outputs.iter();\n                 let post_inputs = self.exprs(inputs.map(|a| {\n                     debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n-                    let &(_, expr) = a;\n-                    expr\n+                    let &(_, ref expr) = a;\n+                    &**expr\n                 }), pred);\n                 let post_outputs = self.exprs(outputs.map(|a| {\n                     debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n-                    let &(_, expr, _) = a;\n-                    expr\n+                    let &(_, ref expr, _) = a;\n+                    &**expr\n                 }), post_inputs);\n                 self.add_node(expr.id, [post_outputs])\n             }\n@@ -494,16 +486,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::ExprUnboxedFn(..) |\n             ast::ExprLit(..) |\n             ast::ExprPath(..) => {\n-                self.straightline(expr, pred, [])\n+                self.straightline(expr, pred, None::<ast::Expr>.iter())\n             }\n         }\n     }\n \n-    fn call(&mut self,\n-            call_expr: Gc<ast::Expr>,\n+    fn call<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+            call_expr: &ast::Expr,\n             pred: CFGIndex,\n-            func_or_rcvr: Gc<ast::Expr>,\n-            args: &[Gc<ast::Expr>]) -> CFGIndex {\n+            func_or_rcvr: &ast::Expr,\n+            args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n \n@@ -516,28 +508,27 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn exprs<I:Iterator<Gc<ast::Expr>>>(&mut self,\n-                                        mut exprs: I,\n-                                        pred: CFGIndex) -> CFGIndex {\n+    fn exprs<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+                                             mut exprs: I,\n+                                             pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n         exprs.fold(pred, |p, e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n-                opt_expr: Option<Gc<ast::Expr>>,\n+                opt_expr: &Option<P<ast::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n-\n-        opt_expr.iter().fold(pred, |p, &e| self.expr(e, p))\n+        opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n     }\n \n-    fn straightline(&mut self,\n-                    expr: Gc<ast::Expr>,\n+    fn straightline<'a, I: Iterator<&'a ast::Expr>>(&mut self,\n+                    expr: &ast::Expr,\n                     pred: CFGIndex,\n-                    subexprs: &[Gc<ast::Expr>]) -> CFGIndex {\n+                    subexprs: I) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n-        let subexprs_exit = self.exprs(subexprs.iter().map(|&e|e), pred);\n+        let subexprs_exit = self.exprs(subexprs, pred);\n         self.add_node(expr.id, [subexprs_exit])\n     }\n \n@@ -566,7 +557,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn add_exiting_edge(&mut self,\n-                        from_expr: Gc<ast::Expr>,\n+                        from_expr: &ast::Expr,\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n@@ -581,7 +572,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn add_returning_edge(&mut self,\n-                          _from_expr: Gc<ast::Expr>,\n+                          _from_expr: &ast::Expr,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n             exiting_scopes: vec!(),\n@@ -593,7 +584,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn find_scope(&self,\n-                  expr: Gc<ast::Expr>,\n+                  expr: &ast::Expr,\n                   label: Option<ast::Ident>) -> LoopScope {\n         match label {\n             None => {"}, {"sha": "84b96edc12652cc32efa890aa97fdea6a18557a1", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -22,8 +22,8 @@ use middle::cfg;\n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a>{\n-    pub ast_map: &'a ast_map::Map,\n+pub struct LabelledCFG<'a, 'ast: 'a> {\n+    pub ast_map: &'a ast_map::Map<'ast>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n }\n@@ -49,7 +49,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n     }\n }\n \n-impl<'a> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a> {\n+impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n     fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.as_slice()) }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n@@ -110,7 +110,7 @@ impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for &'a cfg::CFG {\n     }\n }\n \n-impl<'a> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a>\n+impl<'a, 'ast> dot::GraphWalk<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast>\n {\n     fn nodes(&self) -> dot::Nodes<'a, Node<'a>> { self.cfg.nodes() }\n     fn edges(&self) -> dot::Edges<'a, Edge<'a>> { self.cfg.edges() }"}, {"sha": "303961105b526784a2efdf3a7766d558643d95f7", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -53,15 +53,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(krate: &Crate, tcx: &ty::ctxt) {\n-    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false }, krate);\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut CheckCrateVisitor { tcx: tcx, in_const: false },\n+                      tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n     match it.node {\n-        ItemStatic(_, _, ex) => {\n-            v.inside_const(|v| v.visit_expr(&*ex));\n+        ItemStatic(_, _, ref ex) => {\n+            v.inside_const(|v| v.visit_expr(&**ex));\n             check_item_recursion(&v.tcx.sess, &v.tcx.map, &v.tcx.def_map, it);\n         }\n         ItemEnum(ref enum_definition, _) => {\n@@ -78,9 +79,9 @@ fn check_item(v: &mut CheckCrateVisitor, it: &Item) {\n fn check_pat(v: &mut CheckCrateVisitor, p: &Pat) {\n     fn is_str(e: &Expr) -> bool {\n         match e.node {\n-            ExprBox(_, expr) => {\n+            ExprBox(_, ref expr) => {\n                 match expr.node {\n-                    ExprLit(lit) => ast_util::lit_is_str(lit),\n+                    ExprLit(ref lit) => ast_util::lit_is_str(&**lit),\n                     _ => false,\n                 }\n             }\n@@ -106,7 +107,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n             span_err!(v.tcx.sess, e.span, E0010, \"cannot do allocations in constant expressions\");\n             return;\n           }\n-          ExprLit(lit) if ast_util::lit_is_str(lit) => {}\n+          ExprLit(ref lit) if ast_util::lit_is_str(&**lit) => {}\n           ExprBinary(..) | ExprUnary(..) => {\n             let method_call = typeck::MethodCall::expr(e.id);\n             if v.tcx.method_map.borrow().contains_key(&method_call) {\n@@ -149,7 +150,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n               }\n             }\n           }\n-          ExprCall(callee, _) => {\n+          ExprCall(ref callee, _) => {\n             match v.tcx.def_map.borrow().find(&callee.id) {\n                 Some(&DefStruct(..)) => {}    // OK.\n                 Some(&DefVariant(..)) => {}    // OK.\n@@ -194,7 +195,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n           ExprTup(..) |\n           ExprRepeat(..) |\n           ExprStruct(..) => { }\n-          ExprAddrOf(_, inner) => {\n+          ExprAddrOf(_, ref inner) => {\n                 match inner.node {\n                     // Mutable slices are allowed.\n                     ExprVec(_) => {}\n@@ -214,12 +215,13 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) {\n     visit::walk_expr(v, e);\n }\n \n-struct CheckItemRecursionVisitor<'a> {\n+struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     root_it: &'a Item,\n     sess: &'a Session,\n-    ast_map: &'a ast_map::Map,\n+    ast_map: &'a ast_map::Map<'ast>,\n     def_map: &'a resolve::DefMap,\n-    idstack: Vec<NodeId> }\n+    idstack: Vec<NodeId>\n+}\n \n // Make sure a const item doesn't recursively refer to itself\n // FIXME: Should use the dependency graph when it's available (#1356)\n@@ -238,7 +240,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n     visitor.visit_item(it);\n }\n \n-impl<'a, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a> {\n+impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n             self.sess.span_fatal(self.root_it.span, \"recursive constant\");"}, {"sha": "eb308f903d3dd79546d4667ca3582e20340d7ae4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 171, "deletions": 166, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -19,19 +19,26 @@ use middle::pat_util::*;\n use middle::ty::*;\n use middle::ty;\n use std::fmt;\n-use std::gc::{Gc, GC};\n use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n+use std::slice;\n use syntax::ast::*;\n use syntax::ast_util::walk_pat;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::visit::{mod, Visitor, FnKind};\n use util::ppaux::ty_to_string;\n \n-struct Matrix(Vec<Vec<Gc<Pat>>>);\n+static DUMMY_WILD_PAT: Pat = Pat {\n+    id: DUMMY_NODE_ID,\n+    node: PatWild(PatWildSingle),\n+    span: DUMMY_SP\n+};\n+\n+struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n@@ -45,7 +52,7 @@ struct Matrix(Vec<Vec<Gc<Pat>>>);\n /// ++++++++++++++++++++++++++\n /// + _     + [_, _, ..tail] +\n /// ++++++++++++++++++++++++++\n-impl fmt::Show for Matrix {\n+impl<'a> fmt::Show for Matrix<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"\\n\"));\n \n@@ -80,8 +87,8 @@ impl fmt::Show for Matrix {\n     }\n }\n \n-impl FromIterator<Vec<Gc<Pat>>> for Matrix {\n-    fn from_iter<T: Iterator<Vec<Gc<Pat>>>>(mut iterator: T) -> Matrix {\n+impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n+    fn from_iter<T: Iterator<Vec<&'a Pat>>>(mut iterator: T) -> Matrix<'a> {\n         Matrix(iterator.collect())\n     }\n }\n@@ -110,7 +117,7 @@ pub enum Constructor {\n #[deriving(Clone, PartialEq)]\n enum Usefulness {\n     Useful,\n-    UsefulWithWitness(Vec<Gc<Pat>>),\n+    UsefulWithWitness(Vec<P<Pat>>),\n     NotUseful\n }\n \n@@ -132,16 +139,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, krate: &Crate) {\n-    let mut cx = MatchCheckCtxt { tcx: tcx };\n-    visit::walk_crate(&mut cx, krate);\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut MatchCheckCtxt { tcx: tcx }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n-        ExprMatch(scrut, ref arms) => {\n+        ExprMatch(ref scrut, ref arms) => {\n             // First, check legality of move bindings.\n             for arm in arms.iter() {\n                 check_legality_of_move_bindings(cx,\n@@ -156,28 +162,26 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n             // assigning or borrowing anything mutably.\n             for arm in arms.iter() {\n                 match arm.guard {\n-                    Some(guard) => check_for_mutation_in_guard(cx, &*guard),\n+                    Some(ref guard) => check_for_mutation_in_guard(cx, &**guard),\n                     None => {}\n                 }\n             }\n \n             let mut static_inliner = StaticInliner::new(cx.tcx);\n-            let inlined_arms = arms\n-                .iter()\n-                .map(|arm| Arm {\n-                    pats: arm.pats.iter().map(|pat| {\n-                        static_inliner.fold_pat(*pat)\n-                    }).collect(),\n-                    ..arm.clone()\n-                })\n-                .collect::<Vec<Arm>>();\n+            let inlined_arms = arms.iter().map(|arm| {\n+                (arm.pats.iter().map(|pat| {\n+                    static_inliner.fold_pat((*pat).clone())\n+                }).collect(), arm.guard.as_ref().map(|e| &**e))\n+            }).collect::<Vec<(Vec<P<Pat>>, Option<&Expr>)>>();\n \n             if static_inliner.failed {\n                 return;\n             }\n \n             // Third, check if there are any references to NaN that we should warn about.\n-            check_for_static_nan(cx, inlined_arms.as_slice());\n+            for &(ref pats, _) in inlined_arms.iter() {\n+                check_for_static_nan(cx, pats.as_slice());\n+            }\n \n             // Fourth, check for unreachable arms.\n             check_arms(cx, inlined_arms.as_slice());\n@@ -198,28 +202,25 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n             }\n \n             let matrix: Matrix = inlined_arms\n-                .move_iter()\n-                .filter(|arm| arm.guard.is_none())\n-                .flat_map(|arm| arm.pats.move_iter())\n-                .map(|pat| vec![pat])\n+                .iter()\n+                .filter(|&&(_, guard)| guard.is_none())\n+                .flat_map(|arm| arm.ref0().iter())\n+                .map(|pat| vec![&**pat])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);\n         },\n         ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n-            match is_refutable(cx, static_inliner.fold_pat(*pat)) {\n-                Some(uncovered_pat) => {\n-                    cx.tcx.sess.span_err(\n-                        pat.span,\n-                        format!(\"refutable pattern in `for` loop binding: \\\n-                                 `{}` not covered\",\n-                                pat_to_string(&*uncovered_pat)).as_slice());\n-                },\n-                None => {}\n-            }\n+            is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n+                cx.tcx.sess.span_err(\n+                    pat.span,\n+                    format!(\"refutable pattern in `for` loop binding: \\\n+                            `{}` not covered\",\n+                            pat_to_string(uncovered_pat)).as_slice());\n+            });\n \n             // Check legality of move bindings.\n-            check_legality_of_move_bindings(cx, false, [ *pat ]);\n+            check_legality_of_move_bindings(cx, false, slice::ref_slice(pat));\n             check_legality_of_bindings_in_at_patterns(cx, &**pat);\n         }\n         _ => ()\n@@ -234,36 +235,34 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &Expr) -> bool {\n }\n \n // Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    for arm in arms.iter() {\n-        for &pat in arm.pats.iter() {\n-            walk_pat(&*pat, |p| {\n-                match p.node {\n-                    PatLit(expr) if is_expr_const_nan(cx.tcx, &*expr) => {\n-                        span_warn!(cx.tcx.sess, p.span, E0003,\n-                            \"unmatchable NaN in pattern, \\\n-                             use the is_nan method in a guard instead\");\n-                    }\n-                    _ => ()\n+fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n+    for pat in pats.iter() {\n+        walk_pat(&**pat, |p| {\n+            match p.node {\n+                PatLit(ref expr) if is_expr_const_nan(cx.tcx, &**expr) => {\n+                    span_warn!(cx.tcx.sess, p.span, E0003,\n+                        \"unmatchable NaN in pattern, \\\n+                            use the is_nan method in a guard instead\");\n                 }\n-                true\n-            });\n-        }\n+                _ => ()\n+            }\n+            true\n+        });\n     }\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = Matrix(vec!());\n-    for arm in arms.iter() {\n-        for &pat in arm.pats.iter() {\n-            let v = vec![pat];\n+fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)]) {\n+    let mut seen = Matrix(vec![]);\n+    for &(ref pats, guard) in arms.iter() {\n+        for pat in pats.iter() {\n+            let v = vec![&**pat];\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\"),\n                 Useful => (),\n                 UsefulWithWitness(_) => unreachable!()\n             }\n-            if arm.guard.is_none() {\n+            if guard.is_none() {\n                 let Matrix(mut rows) = seen;\n                 rows.push(v);\n                 seen = Matrix(rows);\n@@ -272,17 +271,24 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     }\n }\n \n+fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n+    match p.node {\n+        PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        _ => p\n+    }\n+}\n+\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n-    match is_useful(cx, matrix, [wild()], ConstructWitness) {\n+    match is_useful(cx, matrix, &[&DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             let witness = match pats.as_slice() {\n-                [witness] => witness,\n-                [] => wild(),\n+                [ref witness] => &**witness,\n+                [] => &DUMMY_WILD_PAT,\n                 _ => unreachable!()\n             };\n             span_err!(cx.tcx.sess, sp, E0004,\n                 \"non-exhaustive patterns: `{}` not covered\",\n-                pat_to_string(&*witness)\n+                pat_to_string(witness)\n             );\n         }\n         NotUseful => {\n@@ -292,17 +298,17 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     }\n }\n \n-fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n+fn const_val_to_expr(value: &const_val) -> P<Expr> {\n     let node = match value {\n         &const_bool(b) => LitBool(b),\n         &const_nil => LitNil,\n         _ => unreachable!()\n     };\n-    box (GC) Expr {\n+    P(Expr {\n         id: 0,\n-        node: ExprLit(box(GC) Spanned { node: node, span: DUMMY_SP }),\n+        node: ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n         span: DUMMY_SP\n-    }\n+    })\n }\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n@@ -320,16 +326,18 @@ impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n-    fn fold_pat(&mut self, pat: Gc<Pat>) -> Gc<Pat> {\n+    fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         match pat.node {\n             PatIdent(..) | PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n                 match def {\n                     Some(DefStatic(did, _)) => match lookup_const_by_id(self.tcx, did) {\n-                        Some(const_expr) => box (GC) Pat {\n-                            span: pat.span,\n-                            ..(*const_expr_to_pat(self.tcx, const_expr)).clone()\n-                        },\n+                        Some(const_expr) => {\n+                            const_expr_to_pat(self.tcx, const_expr).map(|mut new_pat| {\n+                                new_pat.span = pat.span;\n+                                new_pat\n+                            })\n+                        }\n                         None => {\n                             self.failed = true;\n                             span_err!(self.tcx.sess, pat.span, E0158,\n@@ -359,9 +367,11 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n /// left_ty: struct X { a: (bool, &'static str), b: uint}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n-                     pats: Vec<Gc<Pat>>, left_ty: ty::t) -> Gc<Pat> {\n+                     pats: Vec<&Pat>, left_ty: ty::t) -> P<Pat> {\n+    let pats_len = pats.len();\n+    let mut pats = pats.move_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n-        ty::ty_tup(_) => PatTup(pats),\n+        ty::ty_tup(_) => PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n@@ -374,52 +384,52 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n             if is_structure {\n                 let fields = ty::lookup_struct_fields(cx.tcx, vid);\n                 let field_pats: Vec<FieldPat> = fields.move_iter()\n-                    .zip(pats.iter())\n-                    .filter(|&(_, pat)| pat.node != PatWild(PatWildSingle))\n+                    .zip(pats)\n+                    .filter(|&(_, ref pat)| pat.node != PatWild(PatWildSingle))\n                     .map(|(field, pat)| FieldPat {\n                         ident: Ident::new(field.name),\n-                        pat: pat.clone()\n+                        pat: pat\n                     }).collect();\n-                let has_more_fields = field_pats.len() < pats.len();\n+                let has_more_fields = field_pats.len() < pats_len;\n                 PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n             } else {\n-                PatEnum(def_to_path(cx.tcx, vid), Some(pats))\n+                PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n             }\n         }\n \n         ty::ty_rptr(_, ty::mt { ty: ty, .. }) => {\n             match ty::get(ty).sty {\n                ty::ty_vec(_, Some(n)) => match ctor {\n                     &Single => {\n-                        assert_eq!(pats.len(), n);\n-                        PatVec(pats, None, vec!())\n+                        assert_eq!(pats_len, n);\n+                        PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::ty_vec(_, None) => match ctor {\n                     &Slice(n) => {\n-                        assert_eq!(pats.len(), n);\n-                        PatVec(pats, None, vec!())\n+                        assert_eq!(pats_len, n);\n+                        PatVec(pats.collect(), None, vec!())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::ty_str => PatWild(PatWildSingle),\n \n                 _ => {\n-                    assert_eq!(pats.len(), 1);\n-                    PatRegion(pats.get(0).clone())\n+                    assert_eq!(pats_len, 1);\n+                    PatRegion(pats.nth(0).unwrap())\n                 }\n             }\n         }\n \n         ty::ty_box(_) => {\n-            assert_eq!(pats.len(), 1);\n-            PatBox(pats.get(0).clone())\n+            assert_eq!(pats_len, 1);\n+            PatBox(pats.nth(0).unwrap())\n         }\n \n         ty::ty_vec(_, Some(len)) => {\n-            assert_eq!(pats.len(), len);\n-            PatVec(pats, None, vec!())\n+            assert_eq!(pats_len, len);\n+            PatVec(pats.collect(), None, vec![])\n         }\n \n         _ => {\n@@ -430,11 +440,11 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n         }\n     };\n \n-    box (GC) Pat {\n+    P(Pat {\n         id: 0,\n         node: pat,\n         span: DUMMY_SP\n-    }\n+    })\n }\n \n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n@@ -492,7 +502,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n // So it assumes that v is non-empty.\n fn is_useful(cx: &MatchCheckCtxt,\n              matrix: &Matrix,\n-             v: &[Gc<Pat>],\n+             v: &[&Pat],\n              witness: WitnessPreference)\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n@@ -506,12 +516,12 @@ fn is_useful(cx: &MatchCheckCtxt,\n     if rows.get(0).len() == 0u {\n         return NotUseful;\n     }\n-    let real_pat = match rows.iter().find(|r| r.get(0).id != 0) {\n+    let real_pat = match rows.iter().find(|r| r.get(0).id != DUMMY_NODE_ID) {\n         Some(r) => raw_pat(*r.get(0)),\n         None if v.len() == 0 => return NotUseful,\n         None => v[0]\n     };\n-    let left_ty = if real_pat.id == 0 {\n+    let left_ty = if real_pat.id == DUMMY_NODE_ID {\n         ty::mk_nil()\n     } else {\n         ty::pat_ty(cx.tcx, &*real_pat)\n@@ -530,14 +540,13 @@ fn is_useful(cx: &MatchCheckCtxt,\n                     match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n-                            let subpats = {\n+                            let mut result = {\n                                 let pat_slice = pats.as_slice();\n-                                Vec::from_fn(arity, |i| {\n-                                    pat_slice.get(i).map(|p| p.clone())\n-                                        .unwrap_or_else(|| wild())\n-                                })\n+                                let subpats = Vec::from_fn(arity, |i| {\n+                                    pat_slice.get(i).map_or(&DUMMY_WILD_PAT, |p| &**p)\n+                                });\n+                                vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n-                            let mut result = vec!(construct_witness(cx, &c, subpats, left_ty));\n                             result.extend(pats.move_iter().skip(arity));\n                             result\n                         }),\n@@ -547,13 +556,21 @@ fn is_useful(cx: &MatchCheckCtxt,\n             },\n \n             Some(constructor) => {\n-                let matrix = rows.iter().filter_map(|r| default(cx, r.as_slice())).collect();\n+                let matrix = rows.iter().filter_map(|r| {\n+                    if pat_is_binding_or_wild(&cx.tcx.def_map, raw_pat(r[0])) {\n+                        Some(Vec::from_slice(r.tail()))\n+                    } else {\n+                        None\n+                    }\n+                }).collect();\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, wild());\n+                        let wild_pats = Vec::from_elem(arity, &DUMMY_WILD_PAT);\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n-                        UsefulWithWitness(vec!(enum_pat).append(pats.as_slice()))\n+                        let mut new_pats = vec![enum_pat];\n+                        new_pats.extend(pats.move_iter());\n+                        UsefulWithWitness(new_pats)\n                     },\n                     result => result\n                 }\n@@ -566,8 +583,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<Pat>],\n-                         ctor: Constructor, lty: ty::t, witness: WitnessPreference) -> Usefulness {\n+fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n+                         v: &[&Pat], ctor: Constructor, lty: ty::t,\n+                         witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n         specialize(cx, r.as_slice(), &ctor, 0u, arity)\n@@ -587,7 +605,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix, v: &[Gc<P\n ///\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n-fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n+fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: ty::t, max_slice_length: uint) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n@@ -613,10 +631,10 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: Gc<Pat>,\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n-        PatLit(expr) =>\n-            vec!(ConstantValue(eval_const_expr(cx.tcx, &*expr))),\n-        PatRange(lo, hi) =>\n-            vec!(ConstantRange(eval_const_expr(cx.tcx, &*lo), eval_const_expr(cx.tcx, &*hi))),\n+        PatLit(ref expr) =>\n+            vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n+        PatRange(ref lo, ref hi) =>\n+            vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n         PatVec(ref before, ref slice, ref after) =>\n             match ty::get(left_ty).sty {\n                 ty::ty_vec(_, Some(_)) => vec!(Single),\n@@ -691,14 +709,15 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n-                  constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<Gc<Pat>>> {\n+pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n+                      constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, node: ref node, span: pat_span\n-    } = &(*raw_pat(r[col]));\n-    let head: Option<Vec<Gc<Pat>>> = match node {\n+    } = raw_pat(r[col]);\n+    let head: Option<Vec<&Pat>> = match node {\n+\n         &PatWild(_) =>\n-            Some(Vec::from_elem(arity, wild())),\n+            Some(Vec::from_elem(arity, &DUMMY_WILD_PAT)),\n \n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(&pat_id);\n@@ -710,7 +729,7 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, wild()))\n+                _ => Some(Vec::from_elem(arity, &DUMMY_WILD_PAT))\n             }\n         }\n \n@@ -722,8 +741,8 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 DefVariant(_, id, _) if *constructor != Variant(id) => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n-                        &Some(ref args) => args.clone(),\n-                        &None => Vec::from_elem(arity, wild())\n+                        &Some(ref args) => args.iter().map(|p| &**p).collect(),\n+                        &None => Vec::from_elem(arity, &DUMMY_WILD_PAT)\n                     })\n                 }\n                 _ => None\n@@ -757,24 +776,24 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                 let struct_fields = ty::lookup_struct_fields(cx.tcx, variant_id);\n                 let args = struct_fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.ident.name == sf.name) {\n-                        Some(f) => f.pat,\n-                        _ => wild()\n+                        Some(ref f) => &*f.pat,\n+                        _ => &DUMMY_WILD_PAT\n                     }\n                 }).collect();\n                 args\n             })\n         }\n \n         &PatTup(ref args) =>\n-            Some(args.clone()),\n+            Some(args.iter().map(|p| &**p).collect()),\n \n         &PatBox(ref inner) | &PatRegion(ref inner) =>\n-            Some(vec!(inner.clone())),\n+            Some(vec![&**inner]),\n \n         &PatLit(ref expr) => {\n             let expr_value = eval_const_expr(cx.tcx, &**expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                Some(true) => Some(vec!()),\n+                Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n                     cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n@@ -787,7 +806,7 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             let from_value = eval_const_expr(cx.tcx, &**from);\n             let to_value = eval_const_expr(cx.tcx, &**to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n-                Some(true) => Some(vec!()),\n+                Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n                     cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n@@ -800,28 +819,28 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             match *constructor {\n                 // Fixed-length vectors.\n                 Single => {\n-                    let mut pats = before.clone();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n-                    let mut pats = before.clone();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| wild());\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.grow_fn(arity - before.len() - after.len(), |_| &DUMMY_WILD_PAT);\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() == length => {\n-                    let mut pats = before.clone();\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 SliceWithSubslice(prefix, suffix)\n                     if before.len() == prefix\n                         && after.len() == suffix\n                         && slice.is_some() => {\n-                    let mut pats = before.clone();\n-                    pats.push_all(after.as_slice());\n+                    let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n+                    pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 }\n                 _ => None\n@@ -836,14 +855,6 @@ pub fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n     head.map(|head| head.append(r.slice_to(col)).append(r.slice_from(col + 1)))\n }\n \n-fn default(cx: &MatchCheckCtxt, r: &[Gc<Pat>]) -> Option<Vec<Gc<Pat>>> {\n-    if pat_is_binding_or_wild(&cx.tcx.def_map, &*raw_pat(r[0])) {\n-        Some(Vec::from_slice(r.tail()))\n-    } else {\n-        None\n-    }\n-}\n-\n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     visit::walk_local(cx, loc);\n \n@@ -853,18 +864,15 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n     };\n \n     let mut static_inliner = StaticInliner::new(cx.tcx);\n-    match is_refutable(cx, static_inliner.fold_pat(loc.pat)) {\n-        Some(pat) => {\n-            span_err!(cx.tcx.sess, loc.pat.span, E0005,\n-                \"refutable pattern in {} binding: `{}` not covered\",\n-                name, pat_to_string(&*pat)\n-            );\n-        },\n-        None => ()\n-    }\n+    is_refutable(cx, &*static_inliner.fold_pat(loc.pat.clone()), |pat| {\n+        span_err!(cx.tcx.sess, loc.pat.span, E0005,\n+            \"refutable pattern in {} binding: `{}` not covered\",\n+            name, pat_to_string(pat)\n+        );\n+    });\n \n     // Check legality of move bindings and `@` patterns.\n-    check_legality_of_move_bindings(cx, false, [ loc.pat ]);\n+    check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n     check_legality_of_bindings_in_at_patterns(cx, &*loc.pat);\n }\n \n@@ -875,26 +883,23 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             sp: Span) {\n     visit::walk_fn(cx, kind, decl, body, sp);\n     for input in decl.inputs.iter() {\n-        match is_refutable(cx, input.pat) {\n-            Some(pat) => {\n-                span_err!(cx.tcx.sess, input.pat.span, E0006,\n-                    \"refutable pattern in function argument: `{}` not covered\",\n-                    pat_to_string(&*pat)\n-                );\n-            },\n-            None => ()\n-        }\n-        check_legality_of_move_bindings(cx, false, [input.pat]);\n+        is_refutable(cx, &*input.pat, |pat| {\n+            span_err!(cx.tcx.sess, input.pat.span, E0006,\n+                \"refutable pattern in function argument: `{}` not covered\",\n+                pat_to_string(pat)\n+            );\n+        });\n+        check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n         check_legality_of_bindings_in_at_patterns(cx, &*input.pat);\n     }\n }\n \n-fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n+fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n     let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, [wild()], ConstructWitness) {\n+    match is_useful(cx, &pats, [&DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n-            Some(pats.get(0).clone())\n+            Some(refutable(&*pats[0]))\n         },\n         NotUseful => None,\n         Useful => unreachable!()\n@@ -904,7 +909,7 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n // Legality of move bindings checking\n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n-                                   pats: &[Gc<Pat>]) {\n+                                   pats: &[P<Pat>]) {\n     let tcx = cx.tcx;\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n@@ -920,7 +925,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         })\n     }\n \n-    let check_move: |&Pat, Option<Gc<Pat>>| = |p, sub| {\n+    let check_move: |&Pat, Option<&Pat>| = |p, sub| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n@@ -939,10 +944,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         walk_pat(&**pat, |p| {\n             if pat_is_binding(def_map, &*p) {\n                 match p.node {\n-                    PatIdent(BindByValue(_), _, sub) => {\n+                    PatIdent(BindByValue(_), _, ref sub) => {\n                         let pat_ty = ty::node_id_to_type(tcx, p.id);\n                         if ty::type_moves_by_default(tcx, pat_ty) {\n-                            check_move(p, sub);\n+                            check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n                     }\n                     PatIdent(BindByRef(_), _, _) => {"}, {"sha": "7a11090a8eecbfa7a6a13a1d8086e1eb036f7551", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -56,8 +56,9 @@ struct CheckStaticVisitor<'a, 'tcx: 'a> {\n     in_const: bool\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n-    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false }, krate)\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut CheckStaticVisitor { tcx: tcx, in_const: false },\n+                      tcx.map.krate())\n }\n \n impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {"}, {"sha": "8c7c8eda2d27893c4a1cf47524e252c9f986118e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 64, "deletions": 59, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -22,12 +22,12 @@ use util::nodemap::{DefIdMap};\n \n use syntax::ast::*;\n use syntax::parse::token::InternedString;\n+use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_map, ast_util};\n \n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -83,7 +83,7 @@ pub fn join_all<It: Iterator<constness>>(mut cs: It) -> constness {\n     cs.fold(integral_const, |a, b| join(a, b))\n }\n \n-pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<Gc<Expr>> {\n+fn lookup_const<'a>(tcx: &'a ty::ctxt, e: &Expr) -> Option<&'a Expr> {\n     let opt_def = tcx.def_map.borrow().find_copy(&e.id);\n     match opt_def {\n         Some(def::DefStatic(def_id, false)) => {\n@@ -96,83 +96,90 @@ pub fn lookup_const(tcx: &ty::ctxt, e: &Expr) -> Option<Gc<Expr>> {\n     }\n }\n \n-pub fn lookup_variant_by_id(tcx: &ty::ctxt,\n+fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                             enum_def: ast::DefId,\n                             variant_def: ast::DefId)\n-                       -> Option<Gc<Expr>> {\n-    fn variant_expr(variants: &[ast::P<ast::Variant>],\n-                    id: ast::NodeId) -> Option<Gc<Expr>> {\n+                            -> Option<&'a Expr> {\n+    fn variant_expr<'a>(variants: &'a [P<ast::Variant>], id: ast::NodeId)\n+                        -> Option<&'a Expr> {\n         for variant in variants.iter() {\n             if variant.node.id == id {\n-                return variant.node.disr_expr;\n+                return variant.node.disr_expr.as_ref().map(|e| &**e);\n             }\n         }\n         None\n     }\n \n     if ast_util::is_local(enum_def) {\n-        {\n-            match tcx.map.find(enum_def.node) {\n-                None => None,\n-                Some(ast_map::NodeItem(it)) => match it.node {\n-                    ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                        variant_expr(variants.as_slice(), variant_def.node)\n-                    }\n-                    _ => None\n-                },\n-                Some(_) => None\n-            }\n+        match tcx.map.find(enum_def.node) {\n+            None => None,\n+            Some(ast_map::NodeItem(it)) => match it.node {\n+                ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n+                    variant_expr(variants.as_slice(), variant_def.node)\n+                }\n+                _ => None\n+            },\n+            Some(_) => None\n         }\n     } else {\n         match tcx.extern_const_variants.borrow().find(&variant_def) {\n-            Some(&e) => return e,\n+            Some(&ast::DUMMY_NODE_ID) => return None,\n+            Some(&expr_id) => {\n+                return Some(tcx.map.expect_expr(expr_id));\n+            }\n             None => {}\n         }\n-        let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n+        let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n-            csearch::found(ast::IIItem(item)) => match item.node {\n+            csearch::found(&ast::IIItem(ref item)) => match item.node {\n                 ItemEnum(ast::EnumDef { variants: ref variants }, _) => {\n-                    variant_expr(variants.as_slice(), variant_def.node)\n+                    // NOTE this doesn't do the right thing, it compares inlined\n+                    // NodeId's to the original variant_def's NodeId, but they\n+                    // come from different crates, so they will likely never match.\n+                    variant_expr(variants.as_slice(), variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n             _ => None\n         };\n-        tcx.extern_const_variants.borrow_mut().insert(variant_def, e);\n-        return e;\n+        tcx.extern_const_variants.borrow_mut().insert(variant_def,\n+                                                      expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n \n-pub fn lookup_const_by_id(tcx: &ty::ctxt, def_id: ast::DefId)\n-                          -> Option<Gc<Expr>> {\n+pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n+                          -> Option<&'a Expr> {\n     if ast_util::is_local(def_id) {\n-        {\n-            match tcx.map.find(def_id.node) {\n-                None => None,\n-                Some(ast_map::NodeItem(it)) => match it.node {\n-                    ItemStatic(_, ast::MutImmutable, const_expr) => {\n-                        Some(const_expr)\n-                    }\n-                    _ => None\n-                },\n-                Some(_) => None\n-            }\n+        match tcx.map.find(def_id.node) {\n+            None => None,\n+            Some(ast_map::NodeItem(it)) => match it.node {\n+                ItemStatic(_, ast::MutImmutable, ref const_expr) => {\n+                    Some(&**const_expr)\n+                }\n+                _ => None\n+            },\n+            Some(_) => None\n         }\n     } else {\n         match tcx.extern_const_statics.borrow().find(&def_id) {\n-            Some(&e) => return e,\n+            Some(&ast::DUMMY_NODE_ID) => return None,\n+            Some(&expr_id) => {\n+                return Some(tcx.map.expect_expr(expr_id));\n+            }\n             None => {}\n         }\n-        let e = match csearch::maybe_get_item_ast(tcx, def_id,\n+        let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n-            csearch::found(ast::IIItem(item)) => match item.node {\n-                ItemStatic(_, ast::MutImmutable, const_expr) => Some(const_expr),\n+            csearch::found(&ast::IIItem(ref item)) => match item.node {\n+                ItemStatic(_, ast::MutImmutable, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n             _ => None\n         };\n-        tcx.extern_const_statics.borrow_mut().insert(def_id, e);\n-        return e;\n+        tcx.extern_const_statics.borrow_mut().insert(def_id,\n+                                                     expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+        expr_id.map(|id| tcx.map.expect_expr(id))\n     }\n }\n \n@@ -271,8 +278,8 @@ impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &Ty) {\n         match t.node {\n-            TyFixedLengthVec(_, expr) => {\n-                check::check_const_in_type(self.tcx, &*expr, ty::mk_uint());\n+            TyFixedLengthVec(_, ref expr) => {\n+                check::check_const_in_type(self.tcx, &**expr, ty::mk_uint());\n             }\n             _ => {}\n         }\n@@ -285,13 +292,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn process_crate(krate: &ast::Crate,\n-                     tcx: &ty::ctxt) {\n-    let mut v = ConstEvalVisitor {\n+pub fn process_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut ConstEvalVisitor {\n         tcx: tcx,\n         ccache: DefIdMap::new(),\n-    };\n-    visit::walk_crate(&mut v, krate);\n+    }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -309,33 +314,33 @@ pub enum const_val {\n     const_nil\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: Gc<Expr>) -> Gc<Pat> {\n+pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<Pat> {\n     let pat = match expr.node {\n         ExprTup(ref exprs) =>\n-            PatTup(exprs.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect()),\n+            PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect()),\n \n-        ExprCall(callee, ref args) => {\n+        ExprCall(ref callee, ref args) => {\n             let def = tcx.def_map.borrow().get_copy(&callee.id);\n             tcx.def_map.borrow_mut().find_or_insert(expr.id, def);\n             let path = match def {\n                 def::DefStruct(def_id) => def_to_path(tcx, def_id),\n                 def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect();\n+            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n             PatEnum(path, Some(pats))\n         }\n \n         ExprStruct(ref path, ref fields, None) => {\n             let field_pats = fields.iter().map(|field| FieldPat {\n                 ident: field.ident.node,\n-                pat: const_expr_to_pat(tcx, field.expr)\n+                pat: const_expr_to_pat(tcx, &*field.expr)\n             }).collect();\n             PatStruct(path.clone(), field_pats, false)\n         }\n \n         ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|&expr| const_expr_to_pat(tcx, expr)).collect();\n+            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr)).collect();\n             PatVec(pats, None, vec![])\n         }\n \n@@ -347,17 +352,17 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: Gc<Expr>) -> Gc<Pat> {\n                 Some(def::DefVariant(..)) =>\n                     PatEnum(path.clone(), None),\n                 _ => {\n-                    match lookup_const(tcx, &*expr) {\n+                    match lookup_const(tcx, expr) {\n                         Some(actual) => return const_expr_to_pat(tcx, actual),\n                         _ => unreachable!()\n                     }\n                 }\n             }\n         }\n \n-        _ => PatLit(expr)\n+        _ => PatLit(P(expr.clone()))\n     };\n-    box (GC) Pat { id: expr.id, node: pat, span: expr.span }\n+    P(Pat { id: expr.id, node: pat, span: expr.span })\n }\n \n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {"}, {"sha": "46e3585912a7f6eab3e65d8b6e4e4d22b381663f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -219,12 +219,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {\n-                visit::walk_trait_item(self, &*trait_method);\n+                visit::walk_trait_item(self, trait_method);\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match *impl_item {\n-                    ast::MethodImplItem(method) => {\n-                        visit::walk_block(self, &*method.pe_body());\n+                    ast::MethodImplItem(ref method) => {\n+                        visit::walk_block(self, method.pe_body());\n                     }\n                 }\n             }\n@@ -338,7 +338,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n             ast::ItemImpl(_, Some(ref _trait_ref), _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(method) => {\n+                        ast::MethodImplItem(ref method) => {\n                             self.worklist.push(method.id);\n                         }\n                     }\n@@ -422,7 +422,7 @@ fn should_warn(item: &ast::Item) -> bool {\n \n fn get_struct_ctor_id(item: &ast::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        ast::ItemStruct(struct_def, _) => struct_def.ctor_id,\n+        ast::ItemStruct(ref struct_def, _) => struct_def.ctor_id,\n         _ => None\n     }\n }\n@@ -551,8 +551,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n \n pub fn check_crate(tcx: &ty::ctxt,\n                    exported_items: &privacy::ExportedItems,\n-                   reachable_symbols: &NodeSet,\n-                   krate: &ast::Crate) {\n+                   reachable_symbols: &NodeSet) {\n+    let krate = tcx.map.krate();\n     let live_symbols = find_live(tcx, exported_items,\n                                  reachable_symbols, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };"}, {"sha": "b492203b3521e99e13718763f88b85ca5212b138", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n \n     fn check_str_index(&mut self, e: &ast::Expr) {\n         let base_type = match e.node {\n-            ast::ExprIndex(base, _) => ty::node_id_to_type(self.tcx, base.id),\n+            ast::ExprIndex(ref base, _) => ty::node_id_to_type(self.tcx, base.id),\n             _ => return\n         };\n         debug!(\"effect: checking index with base type {}\",\n@@ -153,15 +153,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                                         \"invocation of unsafe method\")\n                 }\n             }\n-            ast::ExprCall(base, _) => {\n+            ast::ExprCall(ref base, _) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n-            ast::ExprUnary(ast::UnDeref, base) => {\n+            ast::ExprUnary(ast::UnDeref, ref base) => {\n                 let base_type = ty::node_id_to_type(self.tcx, base.id);\n                 debug!(\"effect: unary case, base type is {}\",\n                         ppaux::ty_to_string(self.tcx, base_type));\n@@ -197,11 +197,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt, krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         unsafe_context: SafeContext,\n     };\n \n-    visit::walk_crate(&mut visitor, krate);\n+    visit::walk_crate(&mut visitor, tcx.map.krate());\n }"}, {"sha": "01854564c05723ca52d9f0986785b569d1fbf35f", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -11,18 +11,18 @@\n \n use driver::config;\n use driver::session::Session;\n-use syntax::ast::{Crate, Name, NodeId, Item, ItemFn};\n+use syntax::ast::{Name, NodeId, Item, ItemFn};\n use syntax::ast_map;\n use syntax::attr;\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-struct EntryContext<'a> {\n+struct EntryContext<'a, 'ast: 'a> {\n     session: &'a Session,\n \n-    ast_map: &'a ast_map::Map,\n+    ast_map: &'a ast_map::Map<'ast>,\n \n     // The interned Name for \"main\".\n     main_name: Name,\n@@ -41,13 +41,13 @@ struct EntryContext<'a> {\n     non_main_fns: Vec<(NodeId, Span)> ,\n }\n \n-impl<'a, 'v> Visitor<'v> for EntryContext<'a> {\n+impl<'a, 'ast, 'v> Visitor<'v> for EntryContext<'a, 'ast> {\n     fn visit_item(&mut self, item: &Item) {\n         find_item(item, self);\n     }\n }\n \n-pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map) {\n+pub fn find_entry_point(session: &Session, ast_map: &ast_map::Map) {\n     let any_exe = session.crate_types.borrow().iter().any(|ty| {\n         *ty == config::CrateTypeExecutable\n     });\n@@ -57,7 +57,7 @@ pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(krate.attrs.as_slice(), \"no_main\") {\n+    if attr::contains_name(ast_map.krate().attrs.as_slice(), \"no_main\") {\n         session.entry_type.set(Some(config::EntryNone));\n         return\n     }\n@@ -72,7 +72,7 @@ pub fn find_entry_point(session: &Session, krate: &Crate, ast_map: &ast_map::Map\n         non_main_fns: Vec::new(),\n     };\n \n-    visit::walk_crate(&mut ctxt, krate);\n+    visit::walk_crate(&mut ctxt, ast_map.krate());\n \n     configure_main(&mut ctxt);\n }"}, {"sha": "1e79ea68eebacf19d6814a92bd2ee51f690c9da0", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -24,8 +24,8 @@ use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n use middle::typeck;\n use util::ppaux::Repr;\n \n-use std::gc::Gc;\n use syntax::ast;\n+use syntax::ptr::P;\n use syntax::codemap::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -242,7 +242,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 ty::ReScope(body.id), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_pat(arg_cmt, arg.pat.clone());\n+            self.walk_pat(arg_cmt, &*arg.pat);\n         }\n     }\n \n@@ -258,7 +258,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<Gc<ast::Expr>>) {\n+    fn consume_exprs(&mut self, exprs: &Vec<P<ast::Expr>>) {\n         for expr in exprs.iter() {\n             self.consume_expr(&**expr);\n         }\n@@ -315,7 +315,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             ast::ExprPath(..) => { }\n \n             ast::ExprUnary(ast::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, []) {\n+                if !self.walk_overloaded_operator(expr, &**base, None) {\n                     self.select_from_expr(&**base);\n                 }\n             }\n@@ -328,8 +328,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 self.select_from_expr(&**base);\n             }\n \n-            ast::ExprIndex(ref lhs, ref rhs) => {           // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+            ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n+                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -345,7 +345,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             }\n \n             ast::ExprStruct(_, ref fields, ref opt_with) => {\n-                self.walk_struct_expr(expr, fields, opt_with.clone());\n+                self.walk_struct_expr(expr, fields, opt_with);\n             }\n \n             ast::ExprTup(ref exprs) => {\n@@ -423,19 +423,19 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                                                  pat.span,\n                                                  ty::ReScope(blk.id),\n                                                  pattern_type);\n-                self.walk_pat(pat_cmt, pat.clone());\n+                self.walk_pat(pat_cmt, &**pat);\n \n                 self.walk_block(&**blk);\n             }\n \n             ast::ExprUnary(_, ref lhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, []) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, None) {\n                     self.consume_expr(&**lhs);\n                 }\n             }\n \n             ast::ExprBinary(_, ref lhs, ref rhs) => {\n-                if !self.walk_overloaded_operator(expr, &**lhs, [rhs.clone()]) {\n+                if !self.walk_overloaded_operator(expr, &**lhs, Some(&**rhs)) {\n                     self.consume_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -554,7 +554,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     ast::DeclLocal(ref local) => {\n-                        self.walk_local(local.clone());\n+                        self.walk_local(&**local);\n                     }\n \n                     ast::DeclItem(_) => {\n@@ -575,7 +575,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         }\n     }\n \n-    fn walk_local(&mut self, local: Gc<ast::Local>) {\n+    fn walk_local(&mut self, local: &ast::Local) {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n@@ -592,7 +592,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n                 let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n-                self.walk_pat(init_cmt, local.pat);\n+                self.walk_pat(init_cmt, &*local.pat);\n             }\n         }\n     }\n@@ -617,14 +617,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_struct_expr(&mut self,\n                         _expr: &ast::Expr,\n                         fields: &Vec<ast::Field>,\n-                        opt_with: Option<Gc<ast::Expr>>) {\n+                        opt_with: &Option<P<ast::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields.iter() {\n             self.consume_expr(&*field.expr);\n         }\n \n-        let with_expr = match opt_with {\n-            Some(ref w) => { w.clone() }\n+        let with_expr = match *opt_with {\n+            Some(ref w) => &**w,\n             None => { return; }\n         };\n \n@@ -773,7 +773,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     fn walk_overloaded_operator(&mut self,\n                                 expr: &ast::Expr,\n                                 receiver: &ast::Expr,\n-                                args: &[Gc<ast::Expr>])\n+                                rhs: Option<&ast::Expr>)\n                                 -> bool\n     {\n         if !self.typer.is_method_call(expr.id) {\n@@ -789,15 +789,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         let r = ty::ReScope(expr.id);\n         let bk = ty::ImmBorrow;\n \n-        for arg in args.iter() {\n-            self.borrow_expr(&**arg, r, bk, OverloadedOperator);\n+        for &arg in rhs.iter() {\n+            self.borrow_expr(arg, r, bk, OverloadedOperator);\n         }\n         return true;\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt, arm: &ast::Arm) {\n-        for &pat in arm.pats.iter() {\n-            self.walk_pat(discr_cmt.clone(), pat);\n+        for pat in arm.pats.iter() {\n+            self.walk_pat(discr_cmt.clone(), &**pat);\n         }\n \n         for guard in arm.guard.iter() {\n@@ -807,7 +807,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n         self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: Gc<ast::Pat>) {\n+    fn walk_pat(&mut self, cmt_discr: mc::cmt, pat: &ast::Pat) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n         let mc = &self.mc;\n@@ -859,14 +859,14 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             } else {\n                 match pat.node {\n-                    ast::PatVec(_, Some(slice_pat), _) => {\n+                    ast::PatVec(_, Some(ref slice_pat), _) => {\n                         // The `slice_pat` here creates a slice into\n                         // the original vector.  This is effectively a\n                         // borrow of the elements of the vector being\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) = {\n-                            match mc.cat_slice_pattern(cmt_pat, &*slice_pat) {\n+                            match mc.cat_slice_pattern(cmt_pat, &**slice_pat) {\n                                 Ok(v) => v,\n                                 Err(()) => {\n                                     tcx.sess.span_bug(slice_pat.span,"}, {"sha": "9d0d21d6d2af6e40f23d804832834b62908ffa03", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -148,11 +148,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ctxt, krate: &ast::Crate) {\n-    let mut visitor = IntrinsicCheckingVisitor {\n-        tcx: tcx,\n-    };\n-\n-    visit::walk_crate(&mut visitor, krate);\n+pub fn check_crate(tcx: &ctxt) {\n+    visit::walk_crate(&mut IntrinsicCheckingVisitor { tcx: tcx },\n+                      tcx.map.krate());\n }\n "}, {"sha": "33f7680d873c376a47bcc8d220e31071864dd21b", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -83,14 +83,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &Crate) {\n+pub fn check_crate(tcx: &ty::ctxt) {\n     let mut ctx = Context {\n         tcx: tcx,\n         struct_and_enum_bounds_checked: HashSet::new(),\n         parameter_environments: Vec::new(),\n     };\n-    visit::walk_crate(&mut ctx, krate);\n+    visit::walk_crate(&mut ctx, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n "}, {"sha": "aecfa36c108e096d98cd9f06554e78a43f0a6aaa", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -111,7 +111,6 @@ use lint;\n use util::nodemap::NodeMap;\n \n use std::fmt;\n-use std::gc::Gc;\n use std::io;\n use std::mem::transmute;\n use std::rc::Rc;\n@@ -122,16 +121,16 @@ use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{expr_to_string, block_to_string};\n+use syntax::ptr::P;\n use syntax::{visit, ast_util};\n use syntax::visit::{Visitor, FnKind};\n \n /// For use with `propagate_through_loop`.\n-#[deriving(PartialEq, Eq)]\n-enum LoopKind {\n+enum LoopKind<'a> {\n     /// An endless `loop` loop.\n     LoopLoop,\n     /// A `while` loop, with the given expression as condition.\n-    WhileLoop(Gc<Expr>),\n+    WhileLoop(&'a Expr),\n     /// A `for` loop.\n     ForLoop,\n }\n@@ -189,9 +188,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   krate: &Crate) {\n-    visit::walk_crate(&mut IrMaps::new(tcx), krate);\n+pub fn check_crate(tcx: &ty::ctxt) {\n+    visit::walk_crate(&mut IrMaps::new(tcx), tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }\n \n@@ -617,25 +615,25 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn arm_pats_bindings(&mut self,\n-                         pats: &[Gc<Pat>],\n+                         pat: Option<&Pat>,\n                          f: |&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId|) {\n-        // only consider the first pattern; any later patterns must have\n-        // the same bindings, and we also consider the first pattern to be\n-        // the \"authoritative\" set of ids\n-        if !pats.is_empty() {\n-            self.pat_bindings(&*pats[0], f)\n+        match pat {\n+            Some(pat) => {\n+                self.pat_bindings(pat, f);\n+            }\n+            None => {}\n         }\n     }\n \n-    fn define_bindings_in_pat(&mut self, pat: Gc<Pat>, succ: LiveNode)\n+    fn define_bindings_in_pat(&mut self, pat: &Pat, succ: LiveNode)\n                               -> LiveNode {\n-        self.define_bindings_in_arm_pats([pat], succ)\n+        self.define_bindings_in_arm_pats(Some(pat), succ)\n     }\n \n-    fn define_bindings_in_arm_pats(&mut self, pats: &[Gc<Pat>], succ: LiveNode)\n+    fn define_bindings_in_arm_pats(&mut self, pat: Option<&Pat>, succ: LiveNode)\n                                    -> LiveNode {\n         let mut succ = succ;\n-        self.arm_pats_bindings(pats, |this, ln, var, _sp, _id| {\n+        self.arm_pats_bindings(pat, |this, ln, var, _sp, _id| {\n             this.init_from_succ(ln, succ);\n             this.define(ln, var);\n             succ = ln;\n@@ -882,7 +880,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_block(&mut self, blk: &Block, succ: LiveNode)\n                                -> LiveNode {\n-        let succ = self.propagate_through_opt_expr(blk.expr, succ);\n+        let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n             self.propagate_through_stmt(&**stmt, succ)\n         })\n@@ -931,19 +929,19 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // initialization, which is mildly more complex than checking\n         // once at the func header but otherwise equivalent.\n \n-        let succ = self.propagate_through_opt_expr(local.init, succ);\n-        self.define_bindings_in_pat(local.pat, succ)\n+        let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n+        self.define_bindings_in_pat(&*local.pat, succ)\n     }\n \n-    fn propagate_through_exprs(&mut self, exprs: &[Gc<Expr>], succ: LiveNode)\n+    fn propagate_through_exprs(&mut self, exprs: &[P<Expr>], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n             self.propagate_through_expr(&**expr, succ)\n         })\n     }\n \n     fn propagate_through_opt_expr(&mut self,\n-                                  opt_expr: Option<Gc<Expr>>,\n+                                  opt_expr: Option<&Expr>,\n                                   succ: LiveNode)\n                                   -> LiveNode {\n         opt_expr.iter().fold(succ, |succ, expr| {\n@@ -1014,7 +1012,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //    v     v\n             //   (  succ  )\n             //\n-            let else_ln = self.propagate_through_opt_expr(els.clone(), succ);\n+            let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n             let then_ln = self.propagate_through_block(&**then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n@@ -1023,10 +1021,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ExprWhile(ref cond, ref blk, _) => {\n-            self.propagate_through_loop(expr,\n-                                        WhileLoop(cond.clone()),\n-                                        &**blk,\n-                                        succ)\n+            self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n \n           ExprForLoop(_, ref head, ref blk, _) => {\n@@ -1062,20 +1057,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let body_succ =\n                     self.propagate_through_expr(&*arm.body, succ);\n                 let guard_succ =\n-                    self.propagate_through_opt_expr(arm.guard, body_succ);\n+                    self.propagate_through_opt_expr(arm.guard.as_ref().map(|e| &**e), body_succ);\n+                // only consider the first pattern; any later patterns must have\n+                // the same bindings, and we also consider the first pattern to be\n+                // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.as_slice(),\n+                    self.define_bindings_in_arm_pats(arm.pats.as_slice().head().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n             self.propagate_through_expr(&**e, ln)\n           }\n \n-          ExprRet(o_e) => {\n+          ExprRet(ref o_e) => {\n             // ignore succ and subst exit_ln:\n             let exit_ln = self.s.exit_ln;\n-            self.propagate_through_opt_expr(o_e, exit_ln)\n+            self.propagate_through_opt_expr(o_e.as_ref().map(|e| &**e), exit_ln)\n           }\n \n           ExprBreak(opt_label) => {\n@@ -1134,7 +1132,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           ExprStruct(_, ref fields, ref with_expr) => {\n-            let succ = self.propagate_through_opt_expr(with_expr.clone(), succ);\n+            let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n                 self.propagate_through_expr(&*field.expr, succ)\n             })\n@@ -1182,7 +1180,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           ExprIndex(ref l, ref r) |\n           ExprBinary(_, ref l, ref r) |\n           ExprBox(ref l, ref r) => {\n-            self.propagate_through_exprs([l.clone(), r.clone()], succ)\n+            let r_succ = self.propagate_through_expr(&**r, succ);\n+            self.propagate_through_expr(&**l, r_succ)\n           }\n \n           ExprAddrOf(_, ref e) |\n@@ -1342,12 +1341,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut first_merge = true;\n         let ln = self.live_node(expr.id, expr.span);\n         self.init_empty(ln, succ);\n-        if kind != LoopLoop {\n-            // If this is not a `loop` loop, then it's possible we bypass\n-            // the body altogether. Otherwise, the only way is via a `break`\n-            // in the loop body.\n-            self.merge_from_succ(ln, succ, first_merge);\n-            first_merge = false;\n+        match kind {\n+            LoopLoop => {}\n+            _ => {\n+                // If this is not a `loop` loop, then it's possible we bypass\n+                // the body altogether. Otherwise, the only way is via a `break`\n+                // in the loop body.\n+                self.merge_from_succ(ln, succ, first_merge);\n+                first_merge = false;\n+            }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n                expr.id, block_to_string(body));\n@@ -1413,7 +1415,10 @@ fn check_local(this: &mut Liveness, local: &Local) {\n }\n \n fn check_arm(this: &mut Liveness, arm: &Arm) {\n-    this.arm_pats_bindings(arm.pats.as_slice(), |this, ln, var, sp, id| {\n+    // only consider the first pattern; any later patterns must have\n+    // the same bindings, and we also consider the first pattern to be\n+    // the \"authoritative\" set of ids\n+    this.arm_pats_bindings(arm.pats.as_slice().head().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);"}, {"sha": "3e42ee9187c4258227906d706f1b56362ecbb049", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -490,7 +490,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(_) => {\n-            let def = self.tcx().def_map.borrow().get_copy(&expr.id);\n+            let def = *self.tcx().def_map.borrow().get(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -1154,7 +1154,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             if_ok!(self.cat_pattern(subcmt, &**subpat, op));\n           }\n \n-          ast::PatVec(ref before, slice, ref after) => {\n+          ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n                   if_ok!(self.cat_pattern(elt_cmt.clone(), &**before_pat,"}, {"sha": "ac1a62b185231468524e7a6f4f2a72c7ce33e258", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -13,7 +13,6 @@ use middle::resolve;\n use middle::ty;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n use syntax::ast::*;\n use syntax::ast_util::{walk_pat};\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -115,17 +114,6 @@ pub fn simple_identifier<'a>(pat: &'a Pat) -> Option<&'a Ident> {\n     }\n }\n \n-pub fn wild() -> Gc<Pat> {\n-    box (GC) Pat { id: 0, node: PatWild(PatWildSingle), span: DUMMY_SP }\n-}\n-\n-pub fn raw_pat(p: Gc<Pat>) -> Gc<Pat> {\n-    match p.node {\n-        PatIdent(_, _, Some(s)) => { raw_pat(s) }\n-        _ => { p }\n-    }\n-}\n-\n pub fn def_to_path(tcx: &ty::ctxt, id: DefId) -> Path {\n     ty::with_path(tcx, id, |mut path| Path {\n         global: false,"}, {"sha": "feacbf84f6739cd79a1c0a1a2e1e04d9969f9e36", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -12,7 +12,6 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n-use std::gc::Gc;\n use std::mem::replace;\n \n use metadata::csearch;\n@@ -263,7 +262,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 if public_ty || public_trait {\n                     for impl_item in impl_items.iter() {\n                         match *impl_item {\n-                            ast::MethodImplItem(method) => {\n+                            ast::MethodImplItem(ref method) => {\n                                 let meth_public =\n                                     match method.pe_explicit_self().node {\n                                         ast::SelfStatic => public_ty,\n@@ -457,11 +456,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 // invocation.\n                 // FIXME(#10573) is this the right behavior? Why not consider\n                 //               where the method was defined?\n-                Some(ast_map::NodeImplItem(ref ii)) => {\n-                    match **ii {\n-                        ast::MethodImplItem(m) => {\n-                            let imp = self.tcx\n-                                          .map\n+                Some(ast_map::NodeImplItem(ii)) => {\n+                    match *ii {\n+                        ast::MethodImplItem(ref m) => {\n+                            let imp = self.tcx.map\n                                           .get_parent_did(closest_private_id);\n                             match ty::impl_trait_ref(self.tcx, imp) {\n                                 Some(..) => return Allowable,\n@@ -1108,7 +1106,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                                  impls\");\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(m) => {\n+                        ast::MethodImplItem(ref m) => {\n                             check_inherited(m.span, m.pe_vis(), \"\");\n                         }\n                     }\n@@ -1169,7 +1167,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &Gc<ast::StructDef>| {\n+        let check_struct = |def: &ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),\n@@ -1182,7 +1180,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n-                        ast::MethodImplItem(m) => {\n+                        ast::MethodImplItem(ref m) => {\n                             check_inherited(tcx, m.span, m.pe_vis());\n                         }\n                     }\n@@ -1198,13 +1196,13 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                     check_inherited(tcx, v.span, v.node.vis);\n \n                     match v.node.kind {\n-                        ast::StructVariantKind(ref s) => check_struct(s),\n+                        ast::StructVariantKind(ref s) => check_struct(&**s),\n                         ast::TupleVariantKind(..) => {}\n                     }\n                 }\n             }\n \n-            ast::ItemStruct(ref def, _) => check_struct(def),\n+            ast::ItemStruct(ref def, _) => check_struct(&**def),\n \n             ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n@@ -1305,7 +1303,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible.\n-            ast::ItemImpl(ref g, ref trait_ref, self_, ref impl_items) => {\n+            ast::ItemImpl(ref g, ref trait_ref, ref self_, ref impl_items) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -1320,7 +1318,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&*self_);\n+                    visitor.visit_ty(&**self_);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1349,7 +1347,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     impl_items.iter()\n                               .any(|impl_item| {\n                                   match *impl_item {\n-                                      ast::MethodImplItem(m) => {\n+                                      ast::MethodImplItem(ref m) => {\n                                           self.exported_items.contains(&m.id)\n                                       }\n                                   }\n@@ -1365,8 +1363,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         None => {\n                             for impl_item in impl_items.iter() {\n                                 match *impl_item {\n-                                    ast::MethodImplItem(method) => {\n-                                        visit::walk_method_helper(self, &*method)\n+                                    ast::MethodImplItem(ref method) => {\n+                                        visit::walk_method_helper(self, &**method)\n                                     }\n                                 }\n                             }\n@@ -1393,13 +1391,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item in impl_items.iter() {\n                         match *impl_item {\n-                            ast::MethodImplItem(method) => {\n+                            ast::MethodImplItem(ref method) => {\n                                 if method.pe_explicit_self().node ==\n                                         ast::SelfStatic &&\n                                         self.exported_items\n                                             .contains(&method.id) {\n                                     found_pub_static = true;\n-                                    visit::walk_method_helper(self, &*method);\n+                                    visit::walk_method_helper(self, &**method);\n                                 }\n                             }\n                         }\n@@ -1487,8 +1485,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt,\n                    exp_map2: &resolve::ExportMap2,\n                    external_exports: resolve::ExternalExports,\n-                   last_private_map: resolve::LastPrivateMap,\n-                   krate: &ast::Crate) -> (ExportedItems, PublicItems) {\n+                   last_private_map: resolve::LastPrivateMap)\n+                   -> (ExportedItems, PublicItems) {\n+    let krate = tcx.map.krate();\n+\n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n         parents: NodeMap::new(),"}, {"sha": "630b65f527878e0796ee1ca13e8efae120798f6d", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -201,7 +201,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n                 match *impl_item {\n-                    ast::MethodImplItem(method) => {\n+                    ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n                                     method.attrs.as_slice()) {\n@@ -333,10 +333,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             }\n             ast_map::NodeImplItem(impl_item) => {\n                 match *impl_item {\n-                    ast::MethodImplItem(method) => {\n+                    ast::MethodImplItem(ref method) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n-                        if method_might_be_inlined(self.tcx, &*method, did) {\n-                            visit::walk_block(self, &*method.pe_body())\n+                        if method_might_be_inlined(self.tcx, &**method, did) {\n+                            visit::walk_block(self, method.pe_body())\n                         }\n                     }\n                 }"}, {"sha": "4f81aac5eb049e6f1289231bc0d8a5b0951ded69", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -29,12 +29,12 @@ use util::common::can_reach;\n \n use std::cell::RefCell;\n use std::collections::{HashMap, HashSet};\n-use std::gc::Gc;\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n-use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n+use syntax::ptr::P;\n+use syntax::visit::{Visitor, FnKind};\n \n /**\n The region maps encode information about region relationships.\n@@ -422,7 +422,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n     visitor.region_maps.mark_as_terminating_scope(arm.body.id);\n \n     match arm.guard {\n-        Some(expr) => {\n+        Some(ref expr) => {\n             visitor.region_maps.mark_as_terminating_scope(expr.id);\n         }\n         None => { }\n@@ -471,28 +471,28 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n         // scopes, meaning that temporaries cannot outlive them.\n         // This ensures fixed size stacks.\n \n-        ast::ExprBinary(ast::BiAnd, _, r) |\n-        ast::ExprBinary(ast::BiOr, _, r) => {\n+        ast::ExprBinary(ast::BiAnd, _, ref r) |\n+        ast::ExprBinary(ast::BiOr, _, ref r) => {\n             // For shortcircuiting operators, mark the RHS as a terminating\n             // scope since it only executes conditionally.\n             visitor.region_maps.mark_as_terminating_scope(r.id);\n         }\n \n-        ast::ExprIf(_, then, Some(otherwise)) => {\n+        ast::ExprIf(_, ref then, Some(ref otherwise)) => {\n             visitor.region_maps.mark_as_terminating_scope(then.id);\n             visitor.region_maps.mark_as_terminating_scope(otherwise.id);\n         }\n \n-        ast::ExprIf(expr, then, None) => {\n+        ast::ExprIf(ref expr, ref then, None) => {\n             visitor.region_maps.mark_as_terminating_scope(expr.id);\n             visitor.region_maps.mark_as_terminating_scope(then.id);\n         }\n \n-        ast::ExprLoop(body, _) => {\n+        ast::ExprLoop(ref body, _) => {\n             visitor.region_maps.mark_as_terminating_scope(body.id);\n         }\n \n-        ast::ExprWhile(expr, body, _) => {\n+        ast::ExprWhile(ref expr, ref body, _) => {\n             visitor.region_maps.mark_as_terminating_scope(expr.id);\n             visitor.region_maps.mark_as_terminating_scope(body.id);\n         }\n@@ -776,7 +776,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n                 ast::ExprTupField(ref subexpr, _, _) |\n                 ast::ExprIndex(ref subexpr, _) |\n                 ast::ExprParen(ref subexpr) => {\n-                    let subexpr: &'a Gc<Expr> = subexpr; // FIXME(#11586)\n+                    let subexpr: &'a P<Expr> = subexpr; // FIXME(#11586)\n                     expr = &**subexpr;\n                 }\n                 _ => {"}, {"sha": "64ae2776ccc34de641f9a87b18769c858311b37b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -30,7 +30,7 @@ use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, Method};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n-use syntax::ast::{P, Pat, PatEnum, PatIdent, PatLit};\n+use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n use syntax::ast::{PrimTy, Public, SelfExplicit, SelfStatic};\n use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n@@ -43,15 +43,15 @@ use syntax::ast::{UnboxedFnTyParamBound, UnnamedField, UnsafeFn, Variant};\n use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse, ViewPathGlob};\n use syntax::ast::{ViewPathList, ViewPathSimple, Visibility};\n use syntax::ast;\n-use syntax::ast_util::{PostExpansionMethod, local_def};\n-use syntax::ast_util::{trait_item_to_ty_method, walk_pat};\n+use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::special_names;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::owned_slice::OwnedSlice;\n+use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -1164,7 +1164,7 @@ impl<'a> Resolver<'a> {\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n-                StmtDecl(declaration, _) => {\n+                StmtDecl(ref declaration, _) => {\n                     match declaration.node {\n                         DeclItem(_) => {\n                             return true;\n@@ -1277,7 +1277,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             // These items live in both the type and value namespaces.\n-            ItemStruct(struct_def, _) => {\n+            ItemStruct(ref struct_def, _) => {\n                 // Adding to both Type and Value namespaces or just Type?\n                 let (forbid, ctor_id) = match struct_def.ctor_id {\n                     Some(ctor_id)   => (ForbidDuplicateTypesAndValues, Some(ctor_id)),\n@@ -1309,7 +1309,7 @@ impl<'a> Resolver<'a> {\n                 parent\n             }\n \n-            ItemImpl(_, None, ty, ref impl_items) => {\n+            ItemImpl(_, None, ref ty, ref impl_items) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1364,7 +1364,7 @@ impl<'a> Resolver<'a> {\n                         // For each implementation item...\n                         for impl_item in impl_items.iter() {\n                             match *impl_item {\n-                                MethodImplItem(method) => {\n+                                MethodImplItem(ref method) => {\n                                     // Add the method to the module.\n                                     let ident = method.pe_ident();\n                                     let method_name_bindings =\n@@ -1430,37 +1430,42 @@ impl<'a> Resolver<'a> {\n \n                 // Add the names of all the methods to the trait info.\n                 for method in methods.iter() {\n-                    let ty_m = trait_item_to_ty_method(method);\n-\n-                    let ident = ty_m.ident;\n+                    let (m_id, m_ident, m_fn_style, m_self, m_span) = match *method {\n+                        ast::RequiredMethod(ref m) => {\n+                            (m.id, m.ident, m.fn_style, &m.explicit_self, m.span)\n+                        }\n+                        ast::ProvidedMethod(ref m) => {\n+                            (m.id, m.pe_ident(), m.pe_fn_style(), m.pe_explicit_self(), m.span)\n+                        }\n+                    };\n \n                     // Add it as a name in the trait module.\n-                    let (def, static_flag) = match ty_m.explicit_self.node {\n+                    let (def, static_flag) = match m_self.node {\n                         SelfStatic => {\n                             // Static methods become `def_static_method`s.\n-                            (DefStaticMethod(local_def(ty_m.id),\n+                            (DefStaticMethod(local_def(m_id),\n                                               FromTrait(local_def(item.id)),\n-                                              ty_m.fn_style),\n+                                              m_fn_style),\n                              StaticMethodTraitItemKind)\n                         }\n                         _ => {\n                             // Non-static methods become `def_method`s.\n-                            (DefMethod(local_def(ty_m.id),\n+                            (DefMethod(local_def(m_id),\n                                        Some(local_def(item.id))),\n                              NonstaticMethodTraitItemKind)\n                         }\n                     };\n \n                     let method_name_bindings =\n-                        self.add_child(ident,\n+                        self.add_child(m_ident,\n                                        module_parent.clone(),\n                                        ForbidDuplicateValues,\n-                                       ty_m.span);\n-                    method_name_bindings.define_value(def, ty_m.span, true);\n+                                       m_span);\n+                    method_name_bindings.define_value(def, m_span, true);\n \n                     self.trait_item_map\n                         .borrow_mut()\n-                        .insert((ident.name, def_id), static_flag);\n+                        .insert((m_ident.name, def_id), static_flag);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -4068,7 +4073,7 @@ impl<'a> Resolver<'a> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.super_struct,\n+                                    &struct_def.super_struct,\n                                     struct_def.fields.as_slice());\n             }\n \n@@ -4100,15 +4105,15 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            ItemFn(fn_decl, _, _, ref generics, block) => {\n+            ItemFn(ref fn_decl, _, _, ref generics, ref block) => {\n                 self.resolve_function(ItemRibKind,\n-                                      Some(fn_decl),\n+                                      Some(&**fn_decl),\n                                       HasTypeParameters\n                                         (generics,\n                                          FnSpace,\n                                          item.id,\n                                          ItemRibKind),\n-                                      block);\n+                                      &**block);\n             }\n \n             ItemStatic(..) => {\n@@ -4179,9 +4184,9 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_function(&mut self,\n                         rib_kind: RibKind,\n-                        optional_declaration: Option<P<FnDecl>>,\n+                        optional_declaration: Option<&FnDecl>,\n                         type_parameters: TypeParameters,\n-                        block: P<Block>) {\n+                        block: &Block) {\n         // Create a value rib for the function.\n         let function_value_rib = Rib::new(rib_kind);\n         self.value_ribs.borrow_mut().push(function_value_rib);\n@@ -4357,7 +4362,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_struct(&mut self,\n                       id: NodeId,\n                       generics: &Generics,\n-                      super_struct: Option<P<Ty>>,\n+                      super_struct: &Option<P<Ty>>,\n                       fields: &[StructField]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4370,8 +4375,8 @@ impl<'a> Resolver<'a> {\n             this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve the super struct.\n-            match super_struct {\n-                Some(t) => match t.node {\n+            match *super_struct {\n+                Some(ref t) => match t.node {\n                     TyPath(ref path, None, path_id) => {\n                         match this.resolve_path(id, path, TypeNS, true) {\n                             Some((DefTy(def_id), lp)) if this.structs.contains_key(&def_id) => {\n@@ -4489,7 +4494,7 @@ impl<'a> Resolver<'a> {\n                 this.with_current_self_type(self_type, |this| {\n                     for impl_item in impl_items.iter() {\n                         match *impl_item {\n-                            MethodImplItem(method) => {\n+                            MethodImplItem(ref method) => {\n                                 // If this is a trait impl, ensure the method\n                                 // exists in trait\n                                 this.check_trait_item(method.pe_ident(),\n@@ -4500,7 +4505,7 @@ impl<'a> Resolver<'a> {\n                                 this.resolve_method(\n                                     MethodRibKind(id,\n                                                   ProvidedMethod(method.id)),\n-                                    &*method);\n+                                    &**method);\n                             }\n                         }\n                     }\n@@ -4738,7 +4743,7 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n-            TyClosure(c) | TyProc(c) => {\n+            TyClosure(ref c) | TyProc(ref c) => {\n                 self.resolve_type_parameter_bounds(ty.id, &c.bounds,\n                                                    TraitBoundingTypeParameter);\n                 visit::walk_ty(self, ty);\n@@ -4775,7 +4780,7 @@ impl<'a> Resolver<'a> {\n                     let renamed = mtwt::resolve(ident);\n \n                     match self.resolve_bare_identifier_pattern(ident, pattern.span) {\n-                        FoundStructOrEnumVariant(def, lp)\n+                        FoundStructOrEnumVariant(ref def, lp)\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n@@ -4785,7 +4790,7 @@ impl<'a> Resolver<'a> {\n                                 pattern,\n                                 binding_mode,\n                                 \"an enum variant\");\n-                            self.record_def(pattern.id, (def, lp));\n+                            self.record_def(pattern.id, (def.clone(), lp));\n                         }\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n@@ -4795,7 +4800,7 @@ impl<'a> Resolver<'a> {\n                                          scope\",\n                                         token::get_name(renamed)).as_slice());\n                         }\n-                        FoundConst(def, lp) if mode == RefutableMode => {\n+                        FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    token::get_name(renamed));\n@@ -4804,7 +4809,7 @@ impl<'a> Resolver<'a> {\n                                 pattern,\n                                 binding_mode,\n                                 \"a constant\");\n-                            self.record_def(pattern.id, (def, lp));\n+                            self.record_def(pattern.id, (def.clone(), lp));\n                         }\n                         FoundConst(..) => {\n                             self.resolve_error(pattern.span,\n@@ -5024,7 +5029,7 @@ impl<'a> Resolver<'a> {\n         if path.segments.len() > 1 {\n             let def = self.resolve_module_relative_path(path, namespace);\n             match (def, unqualified_def) {\n-                (Some((d, _)), Some((ud, _))) if d == ud => {\n+                (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n                     self.session\n                         .add_lint(lint::builtin::UNNECESSARY_QUALIFICATION,\n                                   id,\n@@ -5386,8 +5391,8 @@ impl<'a> Resolver<'a> {\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n                 TyPath(ref path, _, node_id) => Some((path.clone(), node_id, allow)),\n-                TyPtr(mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n+                TyPtr(ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -5647,12 +5652,12 @@ impl<'a> Resolver<'a> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprFnBlock(_, fn_decl, block) |\n-            ExprProc(fn_decl, block) |\n-            ExprUnboxedFn(_, _, fn_decl, block) => {\n+            ExprFnBlock(_, ref fn_decl, ref block) |\n+            ExprProc(ref fn_decl, ref block) |\n+            ExprUnboxedFn(_, _, ref fn_decl, ref block) => {\n                 self.resolve_function(FunctionRibKind(expr.id, block.id),\n-                                      Some(fn_decl), NoTypeParameters,\n-                                      block);\n+                                      Some(&**fn_decl), NoTypeParameters,\n+                                      &**block);\n             }\n \n             ExprStruct(ref path, _, _) => {"}, {"sha": "04e04efd93c261fe19ca612f0ccbd59a670fc77e", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -35,7 +35,6 @@ use middle::ty;\n use middle::typeck;\n \n use std::cell::Cell;\n-use std::gc::Gc;\n use std::io;\n use std::io::File;\n use std::io::fs;\n@@ -54,6 +53,7 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::print::pprust::{path_to_string,ty_to_string};\n+use syntax::ptr::P;\n \n use middle::save::span_utils::SpanUtils;\n use middle::save::recorder::Recorder;\n@@ -289,9 +289,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 NodeItem(item) => {\n                     scope_id = item.id;\n                     match item.node {\n-                        ast::ItemImpl(_, _, ty, _) => {\n+                        ast::ItemImpl(_, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&*ty).as_slice());\n+                            result.push_str(ty_to_string(&**ty).as_slice());\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n@@ -466,9 +466,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_fn(&mut self,\n                   item: &ast::Item,\n-                  decl: ast::P<ast::FnDecl>,\n+                  decl: &ast::FnDecl,\n                   ty_params: &ast::Generics,\n-                  body: ast::P<ast::Block>) {\n+                  body: &ast::Block) {\n         let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n \n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Fn);\n@@ -494,7 +494,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_static(&mut self,\n                       item: &ast::Item,\n-                      typ: ast::P<ast::Ty>,\n+                      typ: &ast::Ty,\n                       mt: ast::Mutability,\n                       expr: &ast::Expr)\n     {\n@@ -611,7 +611,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     item: &ast::Item,\n                     type_parameters: &ast::Generics,\n                     trait_ref: &Option<ast::TraitRef>,\n-                    typ: ast::P<ast::Ty>,\n+                    typ: &ast::Ty,\n                     impl_items: &Vec<ast::ImplItem>) {\n         match typ.node {\n             ast::TyPath(ref path, _, id) => {\n@@ -643,8 +643,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n-                ast::MethodImplItem(method) => {\n-                    visit::walk_method_helper(self, &*method)\n+                ast::MethodImplItem(ref method) => {\n+                    visit::walk_method_helper(self, &**method)\n                 }\n             }\n         }\n@@ -833,7 +833,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n-                          base: &Option<Gc<ast::Expr>>) {\n+                          base: &Option<P<ast::Expr>>) {\n         if generated_code(path.span) {\n             return\n         }\n@@ -883,7 +883,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_method_call(&mut self,\n                            ex: &ast::Expr,\n-                           args: &Vec<Gc<ast::Expr>>) {\n+                           args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n         let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n         let (def_id, decl_id) = match method_callee.origin {\n@@ -1010,7 +1010,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path, immut, recorder::VarRef));\n                 match *optional_subpattern {\n                     None => {}\n-                    Some(subpattern) => self.visit_pat(&*subpattern),\n+                    Some(ref subpattern) => self.visit_pat(&**subpattern)\n                 }\n             }\n             _ => visit::walk_pat(self, p)\n@@ -1025,36 +1025,36 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match item.node {\n-            ast::ItemFn(decl, _, _, ref ty_params, body) =>\n-                self.process_fn(item, decl, ty_params, body),\n-            ast::ItemStatic(typ, mt, expr) =>\n-                self.process_static(item, typ, mt, &*expr),\n-            ast::ItemStruct(def, ref ty_params) => self.process_struct(item, &*def, ty_params),\n+            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n+                self.process_fn(item, &**decl, ty_params, &**body),\n+            ast::ItemStatic(ref typ, mt, ref expr) =>\n+                self.process_static(item, &**typ, mt, &**expr),\n+            ast::ItemStruct(ref def, ref ty_params) => self.process_struct(item, &**def, ty_params),\n             ast::ItemEnum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n             ast::ItemImpl(ref ty_params,\n                           ref trait_ref,\n-                          typ,\n+                          ref typ,\n                           ref impl_items) => {\n                 self.process_impl(item,\n                                   ty_params,\n                                   trait_ref,\n-                                  typ,\n+                                  &**typ,\n                                   impl_items)\n             }\n             ast::ItemTrait(ref generics, _, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n             ast::ItemMod(ref m) => self.process_mod(item, m),\n-            ast::ItemTy(ty, ref ty_params) => {\n+            ast::ItemTy(ref ty, ref ty_params) => {\n                 let qualname = self.analysis.ty_cx.map.path_to_string(item.id);\n-                let value = ty_to_string(&*ty);\n+                let value = ty_to_string(&**ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n                                      qualname.as_slice(),\n                                      value.as_slice());\n \n-                self.visit_ty(&*ty);\n+                self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n             },\n             ast::ItemMac(_) => (),\n@@ -1073,8 +1073,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n             }\n             match param.default {\n-                Some(ty) => self.visit_ty(&*ty),\n-                None => (),\n+                Some(ref ty) => self.visit_ty(&**ty),\n+                None => {}\n             }\n         }\n     }\n@@ -1139,7 +1139,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             qualname,\n                                             method_type.id);\n             }\n-            ast::ProvidedMethod(method) => self.process_method(&*method),\n+            ast::ProvidedMethod(ref method) => self.process_method(&**method)\n         }\n     }\n \n@@ -1269,7 +1269,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match ex.node {\n-            ast::ExprCall(_f, ref _args) => {\n+            ast::ExprCall(ref _f, ref _args) => {\n                 // Don't need to do anything for function calls,\n                 // because just walking the callee path does what we want.\n                 visit::walk_expr(self, ex);\n@@ -1278,14 +1278,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(sub_ex, ident, _) => {\n+            ast::ExprField(ref sub_ex, ident, _) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n \n-                self.visit_expr(&*sub_ex);\n+                self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n+                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n                 let t_box = ty::get(t);\n                 match t_box.sty {\n                     ty::ty_struct(def_id, _) => {\n@@ -1306,14 +1306,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprTupField(sub_ex, idx, _) => {\n+            ast::ExprTupField(ref sub_ex, idx, _) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n \n-                self.visit_expr(&*sub_ex);\n+                self.visit_expr(&**sub_ex);\n \n-                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &*sub_ex);\n+                let t = ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex);\n                 let t_box = ty::get(t);\n                 match t_box.sty {\n                     ty::ty_struct(def_id, _) => {\n@@ -1334,7 +1334,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             \"Expected struct type, but not ty_struct\"),\n                 }\n             },\n-            ast::ExprFnBlock(_, decl, body) => {\n+            ast::ExprFnBlock(_, ref decl, ref body) => {\n                 if generated_code(body.span) {\n                     return\n                 }\n@@ -1349,7 +1349,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.visit_ty(&*decl.output);\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&*body));\n+                self.nest(ex.id, |v| v.visit_block(&**body));\n             },\n             _ => {\n                 visit::walk_expr(self, ex)"}, {"sha": "755ff991fb60a11e33c14029819bcf437822fd83", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 156, "deletions": 153, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -218,55 +218,65 @@ use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n use std::collections::HashMap;\n-use std::gc::{Gc};\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::Ident;\n+use syntax::ast::{DUMMY_NODE_ID, Ident};\n use syntax::codemap::Span;\n use syntax::fold::Folder;\n+use syntax::ptr::P;\n \n-struct ConstantExpr<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>, Gc<ast::Expr>);\n+struct ConstantExpr<'a>(&'a ast::Expr);\n \n-impl<'a, 'tcx> Eq for ConstantExpr<'a, 'tcx> {\n-    fn assert_receiver_is_total_eq(&self) {}\n-}\n-\n-impl<'a, 'tcx> PartialEq for ConstantExpr<'a, 'tcx> {\n-    fn eq(&self, other: &ConstantExpr<'a, 'tcx>) -> bool {\n-        let &ConstantExpr(tcx, expr) = self;\n-        let &ConstantExpr(_, other_expr) = other;\n-        match const_eval::compare_lit_exprs(tcx, &*expr, &*other_expr) {\n+impl<'a> ConstantExpr<'a> {\n+    fn eq(self, other: ConstantExpr<'a>, tcx: &ty::ctxt) -> bool {\n+        let ConstantExpr(expr) = self;\n+        let ConstantExpr(other_expr) = other;\n+        match const_eval::compare_lit_exprs(tcx, expr, other_expr) {\n             Some(val1) => val1 == 0,\n             None => fail!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n-#[deriving(Eq, PartialEq)]\n-enum Opt<'blk, 'tcx: 'blk> {\n-    ConstantValue(ConstantExpr<'blk, 'tcx>),\n-    ConstantRange(ConstantExpr<'blk, 'tcx>, ConstantExpr<'blk, 'tcx>),\n+enum Opt<'a> {\n+    ConstantValue(ConstantExpr<'a>),\n+    ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n     Variant(ty::Disr, Rc<adt::Repr>, ast::DefId),\n     SliceLengthEqual(uint),\n     SliceLengthGreaterOrEqual(/* prefix length */ uint, /* suffix length */ uint),\n }\n \n-impl<'blk, 'tcx> Opt<'blk, 'tcx> {\n-    fn trans(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n+impl<'a> Opt<'a> {\n+    fn eq(&self, other: &Opt<'a>, tcx: &ty::ctxt) -> bool {\n+        match (self, other) {\n+            (&ConstantValue(a), &ConstantValue(b)) => a.eq(b, tcx),\n+            (&ConstantRange(a1, a2), &ConstantRange(b1, b2)) => {\n+                a1.eq(b1, tcx) && a2.eq(b2, tcx)\n+            }\n+            (&Variant(a_disr, ref a_repr, a_def), &Variant(b_disr, ref b_repr, b_def)) => {\n+                a_disr == b_disr && *a_repr == *b_repr && a_def == b_def\n+            }\n+            (&SliceLengthEqual(a), &SliceLengthEqual(b)) => a == b,\n+            (&SliceLengthGreaterOrEqual(a1, a2), &SliceLengthGreaterOrEqual(b1, b2)) => {\n+                a1 == b1 && a2 == b2\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn trans<'blk, 'tcx>(&self, mut bcx: Block<'blk, 'tcx>) -> OptResult<'blk, 'tcx> {\n         let _icx = push_ctxt(\"match::trans_opt\");\n         let ccx = bcx.ccx();\n         match *self {\n-            ConstantValue(ConstantExpr(_, lit_expr)) => {\n+            ConstantValue(ConstantExpr(lit_expr)) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n                 let (llval, _, _) = consts::const_expr(ccx, &*lit_expr, true);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n-            ConstantRange(\n-                ConstantExpr(_, ref l1),\n-                ConstantExpr(_, ref l2)) => {\n+            ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2)) => {\n                 let (l1, _, _) = consts::const_expr(ccx, &**l1, true);\n                 let (l2, _, _) = consts::const_expr(ccx, &**l2, true);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n@@ -325,9 +335,9 @@ pub struct BindingInfo {\n \n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n-struct ArmData<'a, 'blk, 'tcx: 'blk> {\n+struct ArmData<'p, 'blk, 'tcx: 'blk> {\n     bodycx: Block<'blk, 'tcx>,\n-    arm: &'a ast::Arm,\n+    arm: &'p ast::Arm,\n     bindings_map: BindingsMap\n }\n \n@@ -337,13 +347,13 @@ struct ArmData<'a, 'blk, 'tcx: 'blk> {\n  * As we proceed `bound_ptrs` are filled with pointers to values to be bound,\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n-struct Match<'a, 'blk: 'a, 'tcx: 'blk> {\n-    pats: Vec<Gc<ast::Pat>>,\n-    data: &'a ArmData<'a, 'blk, 'tcx>,\n+struct Match<'a, 'p: 'a, 'blk: 'a, 'tcx: 'blk> {\n+    pats: Vec<&'p ast::Pat>,\n+    data: &'a ArmData<'p, 'blk, 'tcx>,\n     bound_ptrs: Vec<(Ident, ValueRef)>\n }\n \n-impl<'a, 'blk, 'tcx> Repr for Match<'a, 'blk, 'tcx> {\n+impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -364,11 +374,11 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     return false;\n }\n \n-fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          m: &'a [Match<'a, 'blk, 'tcx>],\n-                                          col: uint,\n-                                          val: ValueRef)\n-                                          -> Vec<Match<'a, 'blk, 'tcx>> {\n+fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                              m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                              col: uint,\n+                                              val: ValueRef)\n+                                              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -381,9 +391,9 @@ fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut pat = *br.pats.get(col);\n         loop {\n             pat = match pat.node {\n-                ast::PatIdent(_, ref path, Some(inner)) => {\n+                ast::PatIdent(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node, val));\n-                    inner.clone()\n+                    &**inner\n                 },\n                 _ => break\n             }\n@@ -399,15 +409,15 @@ fn expand_nested_bindings<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }).collect()\n }\n \n-type EnterPatterns<'a> = |&[Gc<ast::Pat>]|: 'a -> Option<Vec<Gc<ast::Pat>>>;\n+type EnterPatterns<'a> = <'p> |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n \n-fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               dm: &DefMap,\n-                               m: &'a [Match<'a, 'blk, 'tcx>],\n-                               col: uint,\n-                               val: ValueRef,\n-                               e: EnterPatterns)\n-                               -> Vec<Match<'a, 'blk, 'tcx>> {\n+fn enter_match<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                   dm: &DefMap,\n+                                   m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                   col: uint,\n+                                   val: ValueRef,\n+                                   e: EnterPatterns)\n+                                   -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -425,7 +435,7 @@ fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         bound_ptrs.push((path.node, val));\n                     }\n                 }\n-                ast::PatVec(ref before, Some(slice), ref after) => {\n+                ast::PatVec(ref before, Some(ref slice), ref after) => {\n                     match slice.node {\n                         ast::PatIdent(_, ref path, None) => {\n                             let subslice_val = bind_subslice_pat(\n@@ -438,7 +448,6 @@ fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 _ => {}\n             }\n-\n             Match {\n                 pats: pats,\n                 data: br.data,\n@@ -448,12 +457,12 @@ fn enter_match<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }).collect()\n }\n \n-fn enter_default<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 dm: &DefMap,\n-                                 m: &'a [Match<'a, 'blk, 'tcx>],\n-                                 col: uint,\n-                                 val: ValueRef)\n-                                 -> Vec<Match<'a, 'blk, 'tcx>> {\n+fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     dm: &DefMap,\n+                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                     col: uint,\n+                                     val: ValueRef)\n+                                     -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -499,16 +508,16 @@ fn enter_default<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// takes the complete row of patterns rather than just the first one.\n /// Also, most of the enter_() family functions have been unified with\n /// the check_match specialization step.\n-fn enter_opt<'a, 'blk, 'tcx>(\n+fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n              dm: &DefMap,\n-             m: &'a [Match<'a, 'blk, 'tcx>],\n+             m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> Vec<Match<'a, 'blk, 'tcx>> {\n+             -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -518,10 +527,10 @@ fn enter_opt<'a, 'blk, 'tcx>(\n     let _indenter = indenter();\n \n     let ctor = match opt {\n-        &ConstantValue(ConstantExpr(_, expr)) => check_match::ConstantValue(\n+        &ConstantValue(ConstantExpr(expr)) => check_match::ConstantValue(\n             const_eval::eval_const_expr(bcx.tcx(), &*expr)\n         ),\n-        &ConstantRange(ConstantExpr(_, lo), ConstantExpr(_, hi)) => check_match::ConstantRange(\n+        &ConstantRange(ConstantExpr(lo), ConstantExpr(hi)) => check_match::ConstantRange(\n             const_eval::eval_const_expr(bcx.tcx(), &*lo),\n             const_eval::eval_const_expr(bcx.tcx(), &*hi)\n         ),\n@@ -542,51 +551,41 @@ fn enter_opt<'a, 'blk, 'tcx>(\n // Returns the options in one column of matches. An option is something that\n // needs to be conditionally matched at runtime; for example, the discriminant\n // on a set of enum variants or a literal.\n-fn get_branches<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                            m: &[Match], col: uint)\n-                            -> Vec<Opt<'blk, 'tcx>> {\n-    let ccx = bcx.ccx();\n-\n-    fn add_to_set<'blk, 'tcx>(set: &mut Vec<Opt<'blk, 'tcx>>, opt: Opt<'blk, 'tcx>) {\n-        if !set.contains(&opt) {\n-            set.push(opt);\n-        }\n-    }\n+fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    m: &[Match<'a, 'p, 'blk, 'tcx>], col: uint)\n+                                    -> Vec<Opt<'p>> {\n+    let tcx = bcx.tcx();\n \n-    let mut found = Vec::new();\n+    let mut found: Vec<Opt> = vec![];\n     for (i, br) in m.iter().enumerate() {\n         let cur = *br.pats.get(col);\n-        match cur.node {\n-            ast::PatLit(l) => {\n-                add_to_set(&mut found, ConstantValue(ConstantExpr(ccx.tcx(), l)));\n-            }\n+        let opt = match cur.node {\n+            ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n-                let opt_def = ccx.tcx().def_map.borrow().find_copy(&cur.id);\n+                let opt_def = tcx.def_map.borrow().find_copy(&cur.id);\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n-                        let variant = ty::enum_variant_with_id(ccx.tcx(), enum_id, var_id);\n-                        add_to_set(&mut found, Variant(\n-                            variant.disr_val,\n-                            adt::represent_node(bcx, cur.id), var_id\n-                        ));\n+                        let variant = ty::enum_variant_with_id(tcx, enum_id, var_id);\n+                        Variant(variant.disr_val, adt::represent_node(bcx, cur.id), var_id)\n                     }\n-                    _ => {}\n+                    _ => continue\n                 }\n             }\n-            ast::PatRange(l1, l2) => {\n-                add_to_set(&mut found, ConstantRange(\n-                    ConstantExpr(ccx.tcx(), l1),\n-                    ConstantExpr(ccx.tcx(), l2)\n-                ));\n+            ast::PatRange(ref l1, ref l2) => {\n+                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2))\n             }\n             ast::PatVec(ref before, None, ref after) => {\n-                add_to_set(&mut found, SliceLengthEqual(before.len() + after.len()));\n+                SliceLengthEqual(before.len() + after.len())\n             }\n             ast::PatVec(ref before, Some(_), ref after) => {\n-                add_to_set(&mut found, SliceLengthGreaterOrEqual(before.len(), after.len()));\n+                SliceLengthGreaterOrEqual(before.len(), after.len())\n             }\n-            _ => {}\n+            _ => continue\n+        };\n+\n+        if !found.iter().any(|x| x.eq(&opt, tcx)) {\n+            found.push(opt);\n         }\n     }\n     found\n@@ -870,14 +869,14 @@ fn insert_lllocals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn compile_guard<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 guard_expr: &ast::Expr,\n-                                 data: &ArmData,\n-                                 m: &'a [Match<'a, 'blk, 'tcx>],\n-                                 vals: &[ValueRef],\n-                                 chk: &FailureHandler,\n-                                 has_genuine_default: bool)\n-                                 -> Block<'blk, 'tcx> {\n+fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                     guard_expr: &ast::Expr,\n+                                     data: &ArmData,\n+                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                     vals: &[ValueRef],\n+                                     chk: &FailureHandler,\n+                                     has_genuine_default: bool)\n+                                     -> Block<'blk, 'tcx> {\n     debug!(\"compile_guard(bcx={}, guard_expr={}, m={}, vals={})\",\n            bcx.to_str(),\n            bcx.expr_to_string(guard_expr),\n@@ -918,11 +917,11 @@ fn compile_guard<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     })\n }\n \n-fn compile_submatch<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    m: &'a [Match<'a, 'blk, 'tcx>],\n-                                    vals: &[ValueRef],\n-                                    chk: &FailureHandler,\n-                                    has_genuine_default: bool) {\n+fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                        m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                        vals: &[ValueRef],\n+                                        chk: &FailureHandler,\n+                                        has_genuine_default: bool) {\n     debug!(\"compile_submatch(bcx={}, m={}, vals={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -978,13 +977,13 @@ fn compile_submatch<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-fn compile_submatch_continue<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                             m: &'a [Match<'a, 'blk, 'tcx>],\n-                                             vals: &[ValueRef],\n-                                             chk: &FailureHandler,\n-                                             col: uint,\n-                                             val: ValueRef,\n-                                             has_genuine_default: bool) {\n+fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                                 m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                                 vals: &[ValueRef],\n+                                                 chk: &FailureHandler,\n+                                                 col: uint,\n+                                                 val: ValueRef,\n+                                                 has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n@@ -994,9 +993,11 @@ fn compile_submatch_continue<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n     // each column is guaranteed to have at least one real pattern)\n-    let pat_id = m.iter().map(|br| br.pats.get(col).id).find(|&id| id != 0).unwrap_or(0);\n+    let pat_id = m.iter().map(|br| br.pats.get(col).id)\n+                         .find(|&id| id != DUMMY_NODE_ID)\n+                         .unwrap_or(DUMMY_NODE_ID);\n \n-    let left_ty = if pat_id == 0 {\n+    let left_ty = if pat_id == DUMMY_NODE_ID {\n         ty::mk_nil()\n     } else {\n         node_id_type(bcx, pat_id)\n@@ -1264,7 +1265,7 @@ impl euv::Delegate for ReassignmentChecker {\n     }\n }\n \n-fn create_bindings_map(bcx: Block, pat: Gc<ast::Pat>,\n+fn create_bindings_map(bcx: Block, pat: &ast::Pat,\n                       discr: &ast::Expr, body: &ast::Expr) -> BindingsMap {\n     // Create the bindings map, which is a mapping from each binding name\n     // to an alloca() that will be the value for that local variable.\n@@ -1345,14 +1346,17 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, *arm.pats.get(0), discr_expr, &*arm.body)\n+        bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n+    let arm_pats: Vec<Vec<P<ast::Pat>>> = arm_datas.iter().map(|arm_data| {\n+        arm_data.arm.pats.iter().map(|p| static_inliner.fold_pat((*p).clone())).collect()\n+    }).collect();\n     let mut matches = Vec::new();\n-    for arm_data in arm_datas.iter() {\n-        matches.extend(arm_data.arm.pats.iter().map(|&p| Match {\n-            pats: vec![static_inliner.fold_pat(p)],\n+    for (arm_data, pats) in arm_datas.iter().zip(arm_pats.iter()) {\n+        matches.extend(pats.iter().map(|p| Match {\n+            pats: vec![&**p],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n         }));\n@@ -1404,11 +1408,25 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"match::store_local\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n-    let pat = local.pat;\n-    let opt_init_expr = local.init;\n+    let pat = &*local.pat;\n+\n+    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                       pat: &ast::Pat)\n+                                       -> Block<'blk, 'tcx> {\n+        // create dummy memory for the variables if we have no\n+        // value to store into them immediately\n+        let tcx = bcx.tcx();\n+        pat_bindings(&tcx.def_map, pat, |_, p_id, _, path1| {\n+            let scope = cleanup::var_scope(tcx, p_id);\n+            bcx = mk_binding_alloca(\n+                bcx, p_id, &path1.node, BindLocal, scope, (),\n+                |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n+        });\n+        bcx\n+    }\n \n-    return match opt_init_expr {\n-        Some(init_expr) => {\n+    match local.init {\n+        Some(ref init_expr) => {\n             // Optimize the \"let x = expr\" case. This just writes\n             // the result of evaluating `expr` directly into the alloca\n             // for `x`. Often the general path results in similar or the\n@@ -1424,7 +1442,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let var_scope = cleanup::var_scope(tcx, local.id);\n                     return mk_binding_alloca(\n                         bcx, pat.id, ident, BindLocal, var_scope, (),\n-                        |(), bcx, v, _| expr::trans_into(bcx, &*init_expr,\n+                        |(), bcx, v, _| expr::trans_into(bcx, &**init_expr,\n                                                          expr::SaveIn(v)));\n                 }\n \n@@ -1433,8 +1451,8 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &*init_expr, \"let\"));\n-            if ty::type_is_bot(expr_ty(bcx, &*init_expr)) {\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &**init_expr, \"let\"));\n+            if ty::type_is_bot(expr_ty(bcx, &**init_expr)) {\n                 create_dummy_locals(bcx, pat)\n             } else {\n                 if bcx.sess().asm_comments() {\n@@ -1447,26 +1465,11 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             create_dummy_locals(bcx, pat)\n         }\n-    };\n-\n-    fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                       pat: Gc<ast::Pat>)\n-                                       -> Block<'blk, 'tcx> {\n-        // create dummy memory for the variables if we have no\n-        // value to store into them immediately\n-        let tcx = bcx.tcx();\n-        pat_bindings(&tcx.def_map, &*pat, |_, p_id, _, path1| {\n-                let scope = cleanup::var_scope(tcx, p_id);\n-                bcx = mk_binding_alloca(\n-                    bcx, p_id, &path1.node, BindLocal, scope, (),\n-                    |(), bcx, llval, ty| { zero_mem(bcx, llval, ty); bcx });\n-            });\n-        bcx\n     }\n }\n \n pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             pat: Gc<ast::Pat>,\n+                             pat: &ast::Pat,\n                              arg: Datum<Rvalue>,\n                              arg_scope: cleanup::ScopeId)\n                              -> Block<'blk, 'tcx> {\n@@ -1520,7 +1523,7 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n /// Generates code for the pattern binding in a `for` loop like\n /// `for <pat> in <expr> { ... }`.\n pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          pat: Gc<ast::Pat>,\n+                                          pat: &ast::Pat,\n                                           llvalue: ValueRef,\n                                           body_scope: cleanup::ScopeId)\n                                           -> Block<'blk, 'tcx> {\n@@ -1573,7 +1576,7 @@ fn mk_binding_alloca<'blk, 'tcx, A>(bcx: Block<'blk, 'tcx>,\n }\n \n fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    pat: Gc<ast::Pat>,\n+                                    pat: &ast::Pat,\n                                     val: ValueRef,\n                                     binding_mode: IrrefutablePatternBindingMode,\n                                     cleanup_scope: cleanup::ScopeId)\n@@ -1611,7 +1614,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        ast::PatIdent(pat_binding_mode, ref path1, inner) => {\n+        ast::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n             if pat_is_binding(&tcx.def_map, &*pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n@@ -1637,8 +1640,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     });\n             }\n \n-            for &inner_pat in inner.iter() {\n-                bcx = bind_irrefutable_pat(bcx, inner_pat, val,\n+            for inner_pat in inner.iter() {\n+                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val,\n                                            binding_mode, cleanup_scope);\n             }\n         }\n@@ -1655,9 +1658,9 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n-                        for (i, argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, *sub_pat.get(i),\n-                                                       *argval, binding_mode,\n+                        for (i, &argval) in args.vals.iter().enumerate() {\n+                            bcx = bind_irrefutable_pat(bcx, &**sub_pat.get(i),\n+                                                       argval, binding_mode,\n                                                        cleanup_scope);\n                         }\n                     }\n@@ -1674,7 +1677,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             for (i, elem) in elems.iter().enumerate() {\n                                 let fldptr = adt::trans_field_ptr(bcx, &*repr,\n                                                                   val, 0, i);\n-                                bcx = bind_irrefutable_pat(bcx, *elem,\n+                                bcx = bind_irrefutable_pat(bcx, &**elem,\n                                                            fldptr, binding_mode,\n                                                            cleanup_scope);\n                             }\n@@ -1695,7 +1698,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let ix = ty::field_idx_strict(tcx, f.ident.name, field_tys);\n                     let fldptr = adt::trans_field_ptr(bcx, &*pat_repr, val,\n                                                       discr, ix);\n-                    bcx = bind_irrefutable_pat(bcx, f.pat, fldptr,\n+                    bcx = bind_irrefutable_pat(bcx, &*f.pat, fldptr,\n                                                binding_mode, cleanup_scope);\n                 }\n             })\n@@ -1704,17 +1707,17 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr = adt::represent_node(bcx, pat.id);\n             for (i, elem) in elems.iter().enumerate() {\n                 let fldptr = adt::trans_field_ptr(bcx, &*repr, val, 0, i);\n-                bcx = bind_irrefutable_pat(bcx, *elem, fldptr,\n+                bcx = bind_irrefutable_pat(bcx, &**elem, fldptr,\n                                            binding_mode, cleanup_scope);\n             }\n         }\n-        ast::PatBox(inner) => {\n+        ast::PatBox(ref inner) => {\n             let llbox = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, llbox, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, llbox, binding_mode, cleanup_scope);\n         }\n-        ast::PatRegion(inner) => {\n+        ast::PatRegion(ref inner) => {\n             let loaded_val = Load(bcx, val);\n-            bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode, cleanup_scope);\n+            bcx = bind_irrefutable_pat(bcx, &**inner, loaded_val, binding_mode, cleanup_scope);\n         }\n         ast::PatVec(ref before, ref slice, ref after) => {\n             let pat_ty = node_id_type(bcx, pat.id);\n@@ -1733,8 +1736,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .chain(slice.iter())\n                 .chain(after.iter())\n                 .zip(extracted.vals.move_iter())\n-                .fold(bcx, |bcx, (&inner, elem)|\n-                    bind_irrefutable_pat(bcx, inner, elem, binding_mode, cleanup_scope)\n+                .fold(bcx, |bcx, (inner, elem)|\n+                    bind_irrefutable_pat(bcx, &**inner, elem, binding_mode, cleanup_scope)\n                 );\n         }\n         ast::PatMac(..) => {"}, {"sha": "c474aab9b2647a03ab3bfd09cb4e28e8cd275e6f", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -67,10 +67,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n         unpack_result!(bcx, {\n             callee::trans_arg_datum(bcx,\n-                                   expr_ty(bcx, &**input),\n-                                   in_datum,\n-                                   cleanup::CustomScope(temp_scope),\n-                                   callee::DontAutorefArg)\n+                                    expr_ty(bcx, &**input),\n+                                    in_datum,\n+                                    cleanup::CustomScope(temp_scope),\n+                                    callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>().append(ext_inputs.as_slice());\n "}, {"sha": "e86df8651187062424549effdec85d27e1f9b621", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -1356,7 +1356,7 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n     match tcx.map.find(id) {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n-                ast::ItemFn(_, _, _, _, blk) => {\n+                ast::ItemFn(_, _, _, _, ref blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                     let mut implicit = CheckForNestedReturnsVisitor::implicit();\n                     visit::walk_item(&mut explicit, &*i);\n@@ -1368,12 +1368,12 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeTraitItem(trait_method)) => {\n             match *trait_method {\n-                ast::ProvidedMethod(m) => {\n+                ast::ProvidedMethod(ref m) => {\n                     match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n                             let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                             let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                            visit::walk_method_helper(&mut explicit, &*m);\n+                            visit::walk_method_helper(&mut explicit, &**m);\n                             visit::walk_expr_opt(&mut implicit, &blk.expr);\n                             explicit.found || implicit.found\n                         }\n@@ -1386,11 +1386,11 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                 }\n             }\n         }\n-        Some(ast_map::NodeImplItem(ref ii)) => {\n-            match **ii {\n+        Some(ast_map::NodeImplItem(ii)) => {\n+            match *ii {\n                 ast::MethodImplItem(ref m) => {\n                     match m.node {\n-                        ast::MethDecl(_, _, _, _, _, _, blk, _) => {\n+                        ast::MethDecl(_, _, _, _, _, _, ref blk, _) => {\n                             let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                             let mut implicit = CheckForNestedReturnsVisitor::implicit();\n                             visit::walk_method_helper(&mut explicit, &**m);\n@@ -1404,12 +1404,12 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprFnBlock(_, _, blk) |\n-                ast::ExprProc(_, blk) |\n-                ast::ExprUnboxedFn(_, _, _, blk) => {\n+                ast::ExprFnBlock(_, _, ref blk) |\n+                ast::ExprProc(_, ref blk) |\n+                ast::ExprUnboxedFn(_, _, _, ref blk) => {\n                     let mut explicit = CheckForNestedReturnsVisitor::explicit();\n                     let mut implicit = CheckForNestedReturnsVisitor::implicit();\n-                    visit::walk_expr(&mut explicit, &*e);\n+                    visit::walk_expr(&mut explicit, e);\n                     visit::walk_expr_opt(&mut implicit, &blk.expr);\n                     explicit.found || implicit.found\n                 }\n@@ -1649,7 +1649,7 @@ fn copy_args_to_allocas<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n \n-        bcx = _match::store_arg(bcx, args[i].pat, arg_datum, arg_scope_id);\n+        bcx = _match::store_arg(bcx, &*args[i].pat, arg_datum, arg_scope_id);\n \n         if fcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n             debuginfo::create_argument_metadata(bcx, &args[i]);\n@@ -1701,7 +1701,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                           tuple_element_datum.to_rvalue_datum(bcx,\n                                                               \"arg\"));\n         bcx = _match::store_arg(bcx,\n-                                args[j].pat,\n+                                &*args[j].pat,\n                                 tuple_element_datum,\n                                 arg_scope_id);\n \n@@ -2008,7 +2008,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     if !type_is_zero_size(ccx, result_ty) {\n         match args {\n             callee::ArgExprs(exprs) => {\n-                let fields = exprs.iter().map(|x| *x).enumerate().collect::<Vec<_>>();\n+                let fields = exprs.iter().map(|x| &**x).enumerate().collect::<Vec<_>>();\n                 bcx = expr::trans_adt(bcx, result_ty, disr, fields.as_slice(),\n                                       None, expr::SaveIn(llresult));\n             }\n@@ -2792,15 +2792,15 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     ccx.sess().bug(\"unexpected variant: required trait method in \\\n                                    get_item_val()\");\n                 }\n-                ast::ProvidedMethod(m) => {\n-                    register_method(ccx, id, &*m)\n+                ast::ProvidedMethod(ref m) => {\n+                    register_method(ccx, id, &**m)\n                 }\n             }\n         }\n \n         ast_map::NodeImplItem(ii) => {\n             match *ii {\n-                ast::MethodImplItem(m) => register_method(ccx, id, &*m),\n+                ast::MethodImplItem(ref m) => register_method(ccx, id, &**m),\n             }\n         }\n \n@@ -3042,9 +3042,10 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     }\n }\n \n-pub fn trans_crate(krate: ast::Crate,\n-                   analysis: CrateAnalysis) -> (ty::ctxt, CrateTranslation) {\n+pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n+                         -> (ty::ctxt<'tcx>, CrateTranslation) {\n     let CrateAnalysis { ty_cx: tcx, exp_map2, reachable, name, .. } = analysis;\n+    let krate = tcx.map.krate();\n \n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n@@ -3064,7 +3065,7 @@ pub fn trans_crate(krate: ast::Crate,\n         }\n     }\n \n-    let link_meta = link::build_link_meta(&tcx.sess, &krate, name);\n+    let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n     let shared_ccx = SharedCrateContext::new(link_meta.crate_name.as_slice(),\n@@ -3096,7 +3097,7 @@ pub fn trans_crate(krate: ast::Crate,\n     }\n \n     // Translate the metadata.\n-    let metadata = write_metadata(&shared_ccx, &krate);\n+    let metadata = write_metadata(&shared_ccx, krate);\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();"}, {"sha": "878d95773ada5c512c16f15532f89aa5e8a6ce83", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -53,10 +53,10 @@ use middle::typeck::MethodCall;\n use util::ppaux::Repr;\n use util::ppaux::ty_to_string;\n \n-use std::gc::Gc;\n use syntax::abi as synabi;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ptr::P;\n \n pub struct MethodData {\n     pub llfn: ValueRef,\n@@ -902,7 +902,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub enum CallArgs<'a> {\n     // Supply value of arguments as a list of expressions that must be\n     // translated. This is used in the common case of `foo(bar, qux)`.\n-    ArgExprs(&'a [Gc<ast::Expr>]),\n+    ArgExprs(&'a [P<ast::Expr>]),\n \n     // Supply value of arguments as a list of LLVM value refs; frequently\n     // used with lang items and so forth, when the argument is an internal\n@@ -916,12 +916,12 @@ pub enum CallArgs<'a> {\n \n     // Supply value of arguments as a list of expressions that must be\n     // translated, for overloaded call operators.\n-    ArgOverloadedCall(&'a [Gc<ast::Expr>]),\n+    ArgOverloadedCall(Vec<&'a ast::Expr>),\n }\n \n fn trans_args_under_call_abi<'blk, 'tcx>(\n                              mut bcx: Block<'blk, 'tcx>,\n-                             arg_exprs: &[Gc<ast::Expr>],\n+                             arg_exprs: &[P<ast::Expr>],\n                              fn_ty: ty::t,\n                              llargs: &mut Vec<ValueRef>,\n                              arg_cleanup_scope: cleanup::ScopeId,\n@@ -941,13 +941,13 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     }\n \n     // Now untuple the rest of the arguments.\n-    let tuple_expr = arg_exprs[1];\n+    let tuple_expr = &arg_exprs[1];\n     let tuple_type = node_id_type(bcx, tuple_expr.id);\n \n     match ty::get(tuple_type).sty {\n         ty::ty_tup(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n-                                            expr::trans(bcx, &*tuple_expr));\n+                                            expr::trans(bcx, &**tuple_expr));\n             let tuple_lvalue_datum =\n                 unpack_datum!(bcx,\n                               tuple_datum.to_lvalue_datum(bcx,\n@@ -982,7 +982,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n \n fn trans_overloaded_call_args<'blk, 'tcx>(\n                               mut bcx: Block<'blk, 'tcx>,\n-                              arg_exprs: &[Gc<ast::Expr>],\n+                              arg_exprs: Vec<&ast::Expr>,\n                               fn_ty: ty::t,\n                               llargs: &mut Vec<ValueRef>,\n                               arg_cleanup_scope: cleanup::ScopeId,\n@@ -991,7 +991,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n     // Translate the `self` argument first.\n     let arg_tys = ty::ty_fn_args(fn_ty);\n     if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n+        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n                             *arg_tys.get(0),\n@@ -1007,7 +1007,7 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n         ty::ty_tup(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n                 let arg_datum =\n-                    unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[i + 1]));\n+                    unpack_datum!(bcx, expr::trans(bcx, arg_exprs[i + 1]));\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_datum(bcx,\n                                     field_type,"}, {"sha": "bbb9ba4bbb685c13740c8e7bbc9f2592d55d72f5", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -472,7 +472,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n         match self.tcx().def_map.borrow().find(&nid) {\n-            Some(&v) => v,\n+            Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n                     \"no def associated with node id {:?}\", nid).as_slice());"}, {"sha": "576031500b9588c609725fe0d81fc696e74cfa86", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -33,12 +33,12 @@ use middle::ty;\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n-use std::gc::Gc;\n use std::vec;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n+use syntax::ptr::P;\n \n-pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n+pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     debug!(\"const_lit: {}\", lit);\n@@ -102,7 +102,7 @@ fn first_two<R, S, T>((a, b, _): (R, S, T)) -> (R, S) {\n }\n \n fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[Gc<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n+             es: &[P<ast::Expr>], is_local: bool) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx(), e);\n     let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n@@ -321,7 +321,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n-    let map_list = |exprs: &[Gc<ast::Expr>]| {\n+    let map_list = |exprs: &[P<ast::Expr>]| {\n         exprs.iter().map(|e| first_two(const_expr(cx, &**e, is_local)))\n              .fold((Vec::new(), true),\n                    |(l, all_inlineable), (val, inlineable)| {\n@@ -332,7 +332,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(ref lit) => {\n-              (consts::const_lit(cx, e, (**lit).clone()), true)\n+              (consts::const_lit(cx, e, &**lit), true)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n             let (te1, _, _) = const_expr(cx, &**e1, is_local);\n@@ -653,7 +653,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr,\n                 }\n             }\n           }\n-          ast::ExprCall(callee, ref args) => {\n+          ast::ExprCall(ref callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().find_copy(&callee.id);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {"}, {"sha": "fb12520741bcf5656d884b60d295839d8b89c850", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -39,8 +39,6 @@ use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n \n-use std::gc::Gc;\n-\n pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                               s: &ast::Stmt)\n                               -> Block<'blk, 'tcx> {\n@@ -61,7 +59,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         ast::StmtExpr(ref e, _) | ast::StmtSemi(ref e, _) => {\n             bcx = trans_stmt_semi(bcx, &**e);\n         }\n-        ast::StmtDecl(d, _) => {\n+        ast::StmtDecl(ref d, _) => {\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n                     bcx = init_local(bcx, &**local);\n@@ -132,8 +130,8 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             if_id: ast::NodeId,\n                             cond: &ast::Expr,\n-                            thn: ast::P<ast::Block>,\n-                            els: Option<Gc<ast::Expr>>,\n+                            thn: &ast::Block,\n+                            els: Option<&ast::Expr>,\n                             dest: expr::Dest)\n                             -> Block<'blk, 'tcx> {\n     debug!(\"trans_if(bcx={}, if_id={}, cond={}, thn={:?}, dest={})\",\n@@ -251,7 +249,7 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Translates a `for` loop.\n pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              loop_info: NodeInfo,\n-                             pat: Gc<ast::Pat>,\n+                             pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n                              -> Block<'blk, 'tcx> {\n@@ -453,7 +451,7 @@ pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             e: Option<Gc<ast::Expr>>)\n+                             e: Option<&ast::Expr>)\n                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;"}, {"sha": "21ba2189414c21aad65d5ed131e0361e0af73ff9", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -207,7 +207,6 @@ use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::collections::HashSet;\n-use std::gc::Gc;\n use std::ptr;\n use std::rc::{Rc, Weak};\n use syntax::util::interner::Interner;\n@@ -1129,8 +1128,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n \n             match item.node {\n-                ast::ItemFn(fn_decl, _, _, ref generics, top_level_block) => {\n-                    (item.ident, fn_decl, generics, top_level_block, item.span, true)\n+                ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                    (item.ident, &**fn_decl, generics, &**top_level_block, item.span, true)\n                 }\n                 _ => {\n                     cx.sess().span_bug(item.span,\n@@ -1158,16 +1157,16 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprFnBlock(_, fn_decl, top_level_block) |\n-                ast::ExprProc(fn_decl, top_level_block) |\n-                ast::ExprUnboxedFn(_, _, fn_decl, top_level_block) => {\n+                ast::ExprFnBlock(_, ref fn_decl, ref top_level_block) |\n+                ast::ExprProc(ref fn_decl, ref top_level_block) |\n+                ast::ExprUnboxedFn(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n-                    (name, fn_decl,\n+                    (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n                         &empty_generics,\n-                        top_level_block,\n+                        &**top_level_block,\n                         expr.span,\n                         // Don't try to lookup the item path:\n                         false)\n@@ -1287,9 +1286,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         source_locations_enabled: Cell::new(false),\n     };\n \n-    let arg_pats = fn_decl.inputs.iter().map(|arg_ref| arg_ref.pat).collect::<Vec<_>>();\n     populate_scope_map(cx,\n-                       arg_pats.as_slice(),\n+                       fn_decl.inputs.as_slice(),\n                        &*top_level_block,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n@@ -3169,7 +3167,7 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n // introducing *artificial* lexical scope descriptors where necessary. These\n // artificial scopes allow GDB to correctly handle name shadowing.\n fn populate_scope_map(cx: &CrateContext,\n-                      arg_pats: &[Gc<ast::Pat>],\n+                      args: &[ast::Arg],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -3185,8 +3183,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n-    for &arg_pat in arg_pats.iter() {\n-        pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path1| {\n+    for arg in args.iter() {\n+        pat_util::pat_bindings(def_map, &*arg.pat, |_, _, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                ident: Some(path1.node) });\n         })\n@@ -3272,10 +3270,10 @@ fn populate_scope_map(cx: &CrateContext,\n                  scope_stack: &mut Vec<ScopeStackEntry> ,\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n-            codemap::Spanned { node: ast::DeclLocal(local), .. } => {\n+            codemap::Spanned { node: ast::DeclLocal(ref local), .. } => {\n                 scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n \n-                walk_pattern(cx, local.pat, scope_stack, scope_map);\n+                walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n \n                 for exp in local.init.iter() {\n                     walk_expr(cx, &**exp, scope_stack, scope_map);\n@@ -3286,7 +3284,7 @@ fn populate_scope_map(cx: &CrateContext,\n     }\n \n     fn walk_pattern(cx: &CrateContext,\n-                    pat: Gc<ast::Pat>,\n+                    pat: &ast::Pat,\n                     scope_stack: &mut Vec<ScopeStackEntry> ,\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n \n@@ -3367,8 +3365,8 @@ fn populate_scope_map(cx: &CrateContext,\n \n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &sub_pat in sub_pat_opt.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in sub_pat_opt.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n@@ -3379,32 +3377,32 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatEnum(_, ref sub_pats_opt) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for ref sub_pats in sub_pats_opt.iter() {\n-                    for &p in sub_pats.iter() {\n-                        walk_pattern(cx, p, scope_stack, scope_map);\n+                for sub_pats in sub_pats_opt.iter() {\n+                    for p in sub_pats.iter() {\n+                        walk_pattern(cx, &**p, scope_stack, scope_map);\n                     }\n                 }\n             }\n \n             ast::PatStruct(_, ref field_pats, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &ast::FieldPat { pat: sub_pat, .. } in field_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for &ast::FieldPat { pat: ref sub_pat, .. } in field_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatTup(ref sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n                 for sub_pat in sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n             ast::PatBox(ref sub_pat) | ast::PatRegion(ref sub_pat) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-                walk_pattern(cx, sub_pat.clone(), scope_stack, scope_map);\n+                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n             }\n \n             ast::PatLit(ref exp) => {\n@@ -3421,16 +3419,16 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n-                for &sub_pat in front_sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in front_sub_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for &sub_pat in middle_sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in middle_sub_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n \n-                for &sub_pat in back_sub_pats.iter() {\n-                    walk_pattern(cx, sub_pat, scope_stack, scope_map);\n+                for sub_pat in back_sub_pats.iter() {\n+                    walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n                 }\n             }\n \n@@ -3466,8 +3464,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n             }\n \n-            ast::ExprRet(exp_opt) => match exp_opt {\n-                Some(sub_exp) => walk_expr(cx, &*sub_exp, scope_stack, scope_map),\n+            ast::ExprRet(ref exp_opt) => match *exp_opt {\n+                Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n                 None => ()\n             },\n \n@@ -3538,7 +3536,7 @@ fn populate_scope_map(cx: &CrateContext,\n                                                 .unwrap()\n                                                 .scope_metadata);\n                     walk_pattern(cx,\n-                                 *pattern,\n+                                 &**pattern,\n                                  scope_stack,\n                                  scope_map);\n                     walk_block(cx, &**body, scope_stack, scope_map);\n@@ -3570,7 +3568,7 @@ fn populate_scope_map(cx: &CrateContext,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n                     for &ast::Arg { pat: ref pattern, .. } in decl.inputs.iter() {\n-                        walk_pattern(cx, pattern.clone(), scope_stack, scope_map);\n+                        walk_pattern(cx, &**pattern, scope_stack, scope_map);\n                     }\n \n                     walk_block(cx, &**block, scope_stack, scope_map);\n@@ -3607,8 +3605,8 @@ fn populate_scope_map(cx: &CrateContext,\n                                    scope_stack,\n                                    scope_map,\n                                    |cx, scope_stack, scope_map| {\n-                        for &pat in arm_ref.pats.iter() {\n-                            walk_pattern(cx, pat, scope_stack, scope_map);\n+                        for pat in arm_ref.pats.iter() {\n+                            walk_pattern(cx, &**pat, scope_stack, scope_map);\n                         }\n \n                         for guard_exp in arm_ref.guard.iter() {"}, {"sha": "8a6f3dd6ffab61898273b6cfb32da8b65a62c69d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -77,8 +77,7 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::codemap;\n use syntax::print::pprust::{expr_to_string};\n-\n-use std::gc::Gc;\n+use syntax::ptr::P;\n \n // Destinations\n \n@@ -597,7 +596,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n         }\n-        ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, (**lit).clone()),\n+        ast::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &**lit),\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n             trans_binary(bcx, expr, op, &**lhs, &**rhs)\n         }\n@@ -882,16 +881,16 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprAgain(label_opt) => {\n             controlflow::trans_cont(bcx, expr.id, label_opt)\n         }\n-        ast::ExprRet(ex) => {\n-            controlflow::trans_ret(bcx, ex)\n+        ast::ExprRet(ref ex) => {\n+            controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n             controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n         }\n         ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n             controlflow::trans_for(bcx,\n                                    expr_info(expr),\n-                                   *pat,\n+                                   &**pat,\n                                    &**head,\n                                    &**body)\n         }\n@@ -928,7 +927,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n-            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n+            trans_assign_op(bcx, expr, op, &**dst, &**src)\n         }\n         ast::ExprInlineAsm(ref a) => {\n             asm::trans_inline_asm(bcx, a)\n@@ -958,29 +957,29 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprPath(_) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n-        ast::ExprIf(ref cond, ref thn, els) => {\n-            controlflow::trans_if(bcx, expr.id, &**cond, thn.clone(), els, dest)\n+        ast::ExprIf(ref cond, ref thn, ref els) => {\n+            controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms) => {\n             _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n-        ast::ExprStruct(_, ref fields, base) => {\n+        ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n                          fields.as_slice(),\n-                         base,\n+                         base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n                          dest)\n         }\n         ast::ExprTup(ref args) => {\n-            let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n-                args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n+            let numbered_fields: Vec<(uint, &ast::Expr)> =\n+                args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n             trans_adt(bcx, expr_ty(bcx, expr), 0, numbered_fields.as_slice(), None, dest)\n         }\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n                     tvec::trans_lit_str(bcx, expr, (*s).clone(), dest)\n@@ -1005,14 +1004,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                    expr_to_string(expr), expr_ty.repr(tcx));\n             closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n         }\n-        ast::ExprUnboxedFn(_, _, decl, body) => {\n-            closure::trans_unboxed_closure(bcx, &*decl, &*body, expr.id, dest)\n+        ast::ExprUnboxedFn(_, _, ref decl, ref body) => {\n+            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n                 trans_overloaded_call(bcx,\n                                       expr,\n-                                      *f,\n+                                      &**f,\n                                       args.as_slice(),\n                                       Some(dest))\n             } else {\n@@ -1061,7 +1060,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n-            trans_assign_op(bcx, expr, op, &**dst, src.clone())\n+            trans_assign_op(bcx, expr, op, &**dst, &**src)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -1263,7 +1262,7 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n \n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[ast::Field],\n-                            base: Option<Gc<ast::Expr>>,\n+                       base: Option<&ast::Expr>,\n                             expr_span: codemap::Span,\n                             id: ast::NodeId,\n                             dest: Dest) -> Block<'blk, 'tcx> {\n@@ -1281,7 +1280,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match opt_pos {\n                 Some(i) => {\n                     *need_base.get_mut(i) = false;\n-                    (i, field.expr)\n+                    (i, &*field.expr)\n                 }\n                 None => {\n                     tcx.sess.span_bug(field.span,\n@@ -1320,11 +1319,12 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n  * Note that `fields` may be empty; the base expression must always be\n  * evaluated for side-effects.\n  */\n-pub struct StructBaseInfo {\n+pub struct StructBaseInfo<'a> {\n     /// The base expression; will be evaluated after all explicit fields.\n-    expr: Gc<ast::Expr>,\n+    expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: Vec<(uint, ty::t)> }\n+    fields: Vec<(uint, ty::t)>\n+}\n \n /**\n  * Constructs an ADT instance:\n@@ -1339,7 +1339,7 @@ pub struct StructBaseInfo {\n pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              ty: ty::t,\n                              discr: ty::Disr,\n-                             fields: &[(uint, Gc<ast::Expr>)],\n+                             fields: &[(uint, &ast::Expr)],\n                              optbase: Option<StructBaseInfo>,\n                              dest: Dest) -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n@@ -1407,7 +1407,7 @@ pub fn trans_adt<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n fn trans_immediate_lit<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    expr: &ast::Expr,\n-                                   lit: ast::Lit)\n+                                   lit: &ast::Lit)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     // must not be a string constant, that is a RvalueDpsExpr\n     let _icx = push_ctxt(\"trans_immediate_lit\");\n@@ -1750,20 +1750,20 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              dest)\n }\n \n-fn trans_overloaded_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                     expr: &ast::Expr,\n-                                     callee: Gc<ast::Expr>,\n-                                     args: &[Gc<ast::Expr>],\n-                                     dest: Option<Dest>)\n-                                     -> Block<'blk, 'tcx> {\n+fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n+                                         expr: &ast::Expr,\n+                                         callee: &'a ast::Expr,\n+                                         args: &'a [P<ast::Expr>],\n+                                         dest: Option<Dest>)\n+                                         -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n     let method_type = bcx.tcx()\n                          .method_map\n                          .borrow()\n                          .get(&method_call)\n                          .ty;\n     let mut all_args = vec!(callee);\n-    all_args.push_all(args);\n+    all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,\n                    callee::trans_call_inner(bcx,\n                                             Some(expr_info(expr)),\n@@ -1776,8 +1776,7 @@ fn trans_overloaded_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                     None,\n                                                     arg_cleanup_scope)\n                                             },\n-                                            callee::ArgOverloadedCall(\n-                                                all_args.as_slice()),\n+                                            callee::ArgOverloadedCall(all_args),\n                                             dest));\n     bcx\n }\n@@ -1957,7 +1956,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n                                op: ast::BinOp,\n                                dst: &ast::Expr,\n-                               src: Gc<ast::Expr>)\n+                               src: &ast::Expr)\n                                -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_assign_op\");\n     let mut bcx = bcx;"}, {"sha": "e1e728fbea018bd0dcf4fe6c9cacb26a78109a25", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -47,12 +47,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n         }\n-        csearch::found(ast::IIItem(item)) => {\n+        csearch::found(&ast::IIItem(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n             ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-            trans_item(ccx, &*item);\n+            trans_item(ccx, &**item);\n \n             let linkage = match item.node {\n                 ast::ItemFn(_, _, _, ref generics, _) => {\n@@ -104,12 +104,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             local_def(item.id)\n         }\n-        csearch::found(ast::IIForeign(item)) => {\n+        csearch::found(&ast::IIForeign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             local_def(item.id)\n         }\n-        csearch::found_parent(parent_id, ast::IIItem(item)) => {\n+        csearch::found_parent(parent_id, &ast::IIItem(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n@@ -135,32 +135,37 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             _ => ccx.sess().bug(\"maybe_instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n           }\n-          trans_item(ccx, &*item);\n+          trans_item(ccx, &**item);\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n-        csearch::found(ast::IITraitItem(impl_did, impl_item)) => {\n-            match impl_item {\n-                ast::ProvidedInlinedTraitItem(mth) |\n-                ast::RequiredInlinedTraitItem(mth) => {\n+        csearch::found(&ast::IITraitItem(_, ref trait_item)) => {\n+            match *trait_item {\n+                ast::RequiredMethod(_) => ccx.sess().bug(\"found RequiredMethod IITraitItem\"),\n+                ast::ProvidedMethod(ref mth) => {\n                     ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n                     ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n \n                     ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n-                }\n-            }\n \n-            match impl_item {\n-                ast::ProvidedInlinedTraitItem(mth) => {\n                     // If this is a default method, we can't look up the\n                     // impl type. But we aren't going to translate anyways, so\n                     // don't.\n                     local_def(mth.id)\n                 }\n-                ast::RequiredInlinedTraitItem(mth) => {\n+            }\n+        }\n+        csearch::found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n+            match *impl_item {\n+                ast::MethodImplItem(ref mth) => {\n+                    ccx.external().borrow_mut().insert(fn_id, Some(mth.id));\n+                    ccx.external_srcs().borrow_mut().insert(mth.id, fn_id);\n+\n+                    ccx.stats().n_inlines.set(ccx.stats().n_inlines.get() + 1);\n+\n                     let impl_tpt = ty::lookup_item_type(ccx.tcx(), impl_did);\n                     let unparameterized = impl_tpt.generics.types.is_empty() &&\n                             mth.pe_generics().ty_params.is_empty();"}, {"sha": "4202c2deff6fc8442c8067d6e05a758308a8d302", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -66,23 +66,23 @@ pub fn trans_impl(ccx: &CrateContext,\n         let mut v = TransItemVisitor{ ccx: ccx };\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n-                ast::MethodImplItem(method) => {\n-                    visit::walk_method_helper(&mut v, &*method);\n+                ast::MethodImplItem(ref method) => {\n+                    visit::walk_method_helper(&mut v, &**method);\n                 }\n             }\n         }\n         return;\n     }\n     for impl_item in impl_items.iter() {\n         match *impl_item {\n-            ast::MethodImplItem(method) => {\n+            ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n                     let trans_everywhere = attr::requests_inline(method.attrs.as_slice());\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n-                                 &*method.pe_fn_decl(),\n-                                 &*method.pe_body(),\n+                                 method.pe_fn_decl(),\n+                                 method.pe_body(),\n                                  llfn,\n                                  &param_substs::empty(),\n                                  method.id,\n@@ -96,7 +96,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 let mut v = TransItemVisitor {\n                     ccx: ccx,\n                 };\n-                visit::walk_method_helper(&mut v, &*method);\n+                visit::walk_method_helper(&mut v, &**method);\n             }\n         }\n     }"}, {"sha": "57004922ef7d163b16d963b2b1695eb7175b712f", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -221,13 +221,13 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n         ast_map::NodeImplItem(ii) => {\n             match *ii {\n-                ast::MethodImplItem(mth) => {\n+                ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n                     if needs_body {\n                         trans_fn(ccx,\n-                                 &*mth.pe_fn_decl(),\n-                                 &*mth.pe_body(),\n+                                 mth.pe_fn_decl(),\n+                                 mth.pe_body(),\n                                  d,\n                                  &psubsts,\n                                  mth.id,\n@@ -239,11 +239,11 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         }\n         ast_map::NodeTraitItem(method) => {\n             match *method {\n-                ast::ProvidedMethod(mth) => {\n+                ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n                     let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n                     if needs_body {\n-                        trans_fn(ccx, &*mth.pe_fn_decl(), &*mth.pe_body(), d,\n+                        trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  &psubsts, mth.id, []);\n                     }\n                     d"}, {"sha": "f5c3ed388b7f9af7c80d2ffb88ca272de3ada0a3", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -156,7 +156,7 @@ pub fn trans_slice_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Handle the \"...\" case (returns a slice since strings are always unsized):\n     match content_expr.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n                     let scratch = rvalue_scratch_datum(bcx, vec_ty, \"\");\n@@ -255,7 +255,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            bcx.expr_to_string(vstore_expr));\n \n     match content_expr.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => {\n                     match dest {\n@@ -363,7 +363,7 @@ pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::ExprLit(lit) => {\n+        ast::ExprLit(ref lit) => {\n             match lit.node {\n                 ast::LitStr(ref s, _) => s.get().len(),\n                 _ => {"}, {"sha": "bf35e25635aa2f94f19e262383b3ca1c2059bd23", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -44,7 +44,6 @@ use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip, Writer};\n-use std::gc::Gc;\n use std::iter::AdditiveIterator;\n use std::mem;\n use std::ops;\n@@ -459,7 +458,7 @@ pub struct ctxt<'tcx> {\n     pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n     pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n \n-    pub map: ast_map::Map,\n+    pub map: ast_map::Map<'tcx>,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n     pub freevars: RefCell<freevars::freevar_map>,\n     pub tcache: type_cache,\n@@ -533,8 +532,8 @@ pub struct ctxt<'tcx> {\n \n     /// These two caches are used by const_eval when decoding external statics\n     /// and variants that are found.\n-    pub extern_const_statics: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n-    pub extern_const_variants: RefCell<DefIdMap<Option<Gc<ast::Expr>>>>,\n+    pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n+    pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n \n     pub method_map: typeck::MethodMap,\n     pub vtable_map: typeck::vtable_map,\n@@ -1382,7 +1381,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      type_arena: &'tcx TypedArena<t_box_>,\n                      dm: resolve::DefMap,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n-                     map: ast_map::Map,\n+                     map: ast_map::Map<'tcx>,\n                      freevars: freevars::freevar_map,\n                      capture_modes: freevars::CaptureModeMap,\n                      region_maps: middle::region::RegionMaps,\n@@ -3619,7 +3618,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             RvalueDpsExpr\n         }\n \n-        ast::ExprLit(lit) if lit_is_str(lit) => {\n+        ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr\n         }\n \n@@ -3668,7 +3667,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             RvalueDatumExpr\n         }\n \n-        ast::ExprBox(place, _) => {\n+        ast::ExprBox(ref place, _) => {\n             // Special case `Box<T>`/`Gc<T>` for now:\n             let definition = match tcx.def_map.borrow().find(&place.id) {\n                 Some(&def) => def,\n@@ -3959,16 +3958,15 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n-                        let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n-                        p.iter()\n-                         .map(|m| {\n-                            match impl_or_trait_item(\n-                                    cx,\n-                                    ast_util::local_def(m.id)) {\n-                                MethodTraitItem(m) => m,\n+                        ms.iter().filter_map(|m| match *m {\n+                            ast::RequiredMethod(_) => None,\n+                            ast::ProvidedMethod(ref m) => {\n+                                match impl_or_trait_item(cx,\n+                                        ast_util::local_def(m.id)) {\n+                                    MethodTraitItem(m) => Some(m),\n+                                }\n                             }\n-                         })\n-                         .collect()\n+                         }).collect()\n                     }\n                     _ => {\n                         cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n@@ -4289,11 +4287,11 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n         match cx.map.get(id.node) {\n-            ast_map::NodeItem(item) => {\n+            ast_map::NodeItem(ref item) => {\n                 match item.node {\n                     ast::ItemEnum(ref enum_definition, _) => {\n                         let mut last_discriminant: Option<Disr> = None;\n-                        Rc::new(enum_definition.variants.iter().map(|&variant| {\n+                        Rc::new(enum_definition.variants.iter().map(|variant| {\n \n                             let mut discriminant = match last_discriminant {\n                                 Some(val) => val + 1,\n@@ -4324,7 +4322,7 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n                             };\n \n                             last_discriminant = Some(discriminant);\n-                            Rc::new(VariantInfo::from_ast_variant(cx, &*variant,\n+                            Rc::new(VariantInfo::from_ast_variant(cx, &**variant,\n                                                                   discriminant))\n                         }).collect())\n                     }"}, {"sha": "f2fe7fe6282215b87cdee1e20256bbfccefc0926", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -451,13 +451,10 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     for inner_ast_type in path.segments\n                                               .iter()\n                                               .flat_map(|s| s.types.iter()) {\n-                        let mt = ast::MutTy {\n-                            ty: *inner_ast_type,\n-                            mutbl: ast::MutImmutable,\n-                        };\n                         return Some(mk_pointer(this,\n                                                rscope,\n-                                               &mt,\n+                                               ast::MutImmutable,\n+                                               &**inner_ast_type,\n                                                Uniq,\n                                                |typ| ty::mk_uniq(this.tcx(), typ)));\n                     }\n@@ -478,13 +475,10 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     for inner_ast_type in path.segments\n                                               .iter()\n                                               .flat_map(|s| s.types.iter()) {\n-                        let mt = ast::MutTy {\n-                            ty: *inner_ast_type,\n-                            mutbl: ast::MutImmutable,\n-                        };\n                         return Some(mk_pointer(this,\n                                                rscope,\n-                                               &mt,\n+                                               ast::MutImmutable,\n+                                               &**inner_ast_type,\n                                                Box,\n                                                |typ| {\n                             match ty::get(typ).sty {\n@@ -578,14 +572,15 @@ pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         this: &AC,\n         rscope: &RS,\n-        a_seq_ty: &ast::MutTy,\n+        a_seq_mutbl: ast::Mutability,\n+        a_seq_ty: &ast::Ty,\n         ptr_ty: PointerTy,\n         constr: |ty::t| -> ty::t)\n         -> ty::t {\n     let tcx = this.tcx();\n     debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n \n-    match a_seq_ty.ty.node {\n+    match a_seq_ty.node {\n         ast::TyVec(ref ty) => {\n             let ty = ast_ty_to_ty(this, rscope, &**ty);\n             return constr(ty::mk_vec(tcx, ty, None));\n@@ -610,11 +605,11 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 RPtr(r) => {\n                     return ty::mk_rptr(this.tcx(),\n                                        r,\n-                                       ty::mt {mutbl: a_seq_ty.mutbl, ty: tr});\n+                                       ty::mt {mutbl: a_seq_mutbl, ty: tr});\n                 }\n                 _ => {\n                     tcx.sess.span_err(\n-                        a_seq_ty.ty.span,\n+                        a_seq_ty.span,\n                         \"~trait or &trait are the only supported \\\n                          forms of casting-to-trait\");\n                     return ty::mk_err();\n@@ -671,7 +666,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                             return ty::mk_uniq(tcx, tr);\n                         }\n                         RPtr(r) => {\n-                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_ty.mutbl, ty: tr});\n+                            return ty::mk_rptr(tcx, r, ty::mt{mutbl: a_seq_mutbl, ty: tr});\n                         }\n                         _ => {\n                             tcx.sess.span_err(\n@@ -688,7 +683,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         _ => {}\n     }\n \n-    constr(ast_ty_to_ty(this, rscope, &*a_seq_ty.ty))\n+    constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n }\n \n // Parses the programmer's textual representation of a type into our\n@@ -716,17 +711,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         match ast_ty.node {\n             ast::TyNil => ty::mk_nil(),\n             ast::TyBot => ty::mk_bot(),\n-            ast::TyBox(ty) => {\n-                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, Box, |ty| ty::mk_box(tcx, ty))\n+            ast::TyBox(ref ty) => {\n+                mk_pointer(this, rscope, ast::MutImmutable, &**ty, Box,\n+                           |ty| ty::mk_box(tcx, ty))\n             }\n-            ast::TyUniq(ty) => {\n-                let mt = ast::MutTy { ty: ty, mutbl: ast::MutImmutable };\n-                mk_pointer(this, rscope, &mt, Uniq,\n+            ast::TyUniq(ref ty) => {\n+                mk_pointer(this, rscope, ast::MutImmutable, &**ty, Uniq,\n                            |ty| ty::mk_uniq(tcx, ty))\n             }\n-            ast::TyVec(ty) => {\n-                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty), None)\n+            ast::TyVec(ref ty) => {\n+                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyPtr(ref mt) => {\n                 ty::mk_ptr(tcx, ty::mt {\n@@ -737,7 +731,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             ast::TyRptr(ref region, ref mt) => {\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n-                mk_pointer(this, rscope, mt, RPtr(r),\n+                mk_pointer(this, rscope, mt.mutbl, &*mt.ty, RPtr(r),\n                            |ty| ty::mk_rptr(tcx, r, ty::mt {ty: ty, mutbl: mt.mutbl}))\n             }\n             ast::TyTup(ref fields) => {\n@@ -870,15 +864,15 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                 }\n             }\n-            ast::TyFixedLengthVec(ty, e) => {\n-                match const_eval::eval_const_expr_partial(tcx, &*e) {\n+            ast::TyFixedLengthVec(ref ty, ref e) => {\n+                match const_eval::eval_const_expr_partial(tcx, &**e) {\n                     Ok(ref r) => {\n                         match *r {\n                             const_eval::const_int(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             const_eval::const_uint(i) =>\n-                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &*ty),\n+                                ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             _ => {\n                                 tcx.sess.span_fatal(\n@@ -895,7 +889,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                 }\n             }\n-            ast::TyTypeof(_e) => {\n+            ast::TyTypeof(ref _e) => {\n                 tcx.sess.span_bug(ast_ty.span, \"typeof is reserved but unimplemented\");\n             }\n             ast::TyInfer => {\n@@ -925,15 +919,15 @@ pub fn ty_of_arg<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(this: &AC, rscope: &R\n \n struct SelfInfo<'a> {\n     untransformed_self_ty: ty::t,\n-    explicit_self: ast::ExplicitSelf,\n+    explicit_self: &'a ast::ExplicitSelf,\n }\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n                     id: ast::NodeId,\n                     fn_style: ast::FnStyle,\n                     untransformed_self_ty: ty::t,\n-                    explicit_self: ast::ExplicitSelf,\n+                    explicit_self: &ast::ExplicitSelf,\n                     decl: &ast::FnDecl,\n                     abi: abi::Abi)\n                     -> (ty::BareFnTy, ty::ExplicitSelfCategory) {\n@@ -1087,8 +1081,8 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                                          lifetime);\n             ty::ByReferenceExplicitSelfCategory(region, mutability)\n         }\n-        ast::SelfExplicit(ast_type, _) => {\n-            let explicit_type = ast_ty_to_ty(this, rscope, &*ast_type);\n+        ast::SelfExplicit(ref ast_type, _) => {\n+            let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n \n             {\n                 let inference_context = infer::new_infer_ctxt(this.tcx());"}, {"sha": "1602dfeaa280afbcd7317ff7e52ffffb6bfe74b6", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -24,12 +24,12 @@ use middle::typeck::require_same_types;\n use util::ppaux;\n \n use std::collections::{HashMap, HashSet};\n-use std::gc::Gc;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::parse::token;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n \n pub fn check_match(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n@@ -66,17 +66,17 @@ pub fn check_match(fcx: &FnCtxt,\n         let mut guard_err = false;\n         let mut guard_bot = false;\n         match arm.guard {\n-          Some(ref e) => {\n-              check_expr_has_type(fcx, &**e, ty::mk_bool());\n-              let e_ty = fcx.expr_ty(&**e);\n-              if ty::type_is_error(e_ty) {\n-                  guard_err = true;\n-              }\n-              else if ty::type_is_bot(e_ty) {\n-                  guard_bot = true;\n-              }\n-          },\n-          None => ()\n+            Some(ref e) => {\n+                check_expr_has_type(fcx, &**e, ty::mk_bool());\n+                let e_ty = fcx.expr_ty(&**e);\n+                if ty::type_is_error(e_ty) {\n+                    guard_err = true;\n+                }\n+                else if ty::type_is_bot(e_ty) {\n+                    guard_bot = true;\n+                }\n+            },\n+            None => ()\n         }\n         check_expr(fcx, &*arm.body);\n         let bty = fcx.node_ty(arm.body.id);\n@@ -113,7 +113,7 @@ pub struct pat_ctxt<'a, 'tcx: 'a> {\n }\n \n pub fn check_pat_variant(pcx: &pat_ctxt, pat: &ast::Pat, path: &ast::Path,\n-                         subpats: &Option<Vec<Gc<ast::Pat>>>, expected: ty::t) {\n+                         subpats: &Option<Vec<P<ast::Pat>>>, expected: ty::t) {\n \n     // Typecheck the path.\n     let fcx = pcx.fcx;\n@@ -457,7 +457,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         demand::suptype(fcx, pat.span, expected, const_pty.ty);\n         fcx.write_ty(pat.id, const_pty.ty);\n       }\n-      ast::PatIdent(bm, ref path1, sub) if pat_is_binding(&tcx.def_map, pat) => {\n+      ast::PatIdent(bm, ref path1, ref sub) if pat_is_binding(&tcx.def_map, pat) => {\n         let typ = fcx.local_ty(pat.span, pat.id);\n \n         match bm {\n@@ -491,9 +491,9 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n                ppaux::ty_to_string(tcx, expected),\n                pat.id);\n \n-        match sub {\n-          Some(ref p) => check_pat(pcx, &**p, expected),\n-          _ => ()\n+        match *sub {\n+            Some(ref p) => check_pat(pcx, &**p, expected),\n+            _ => ()\n         }\n       }\n       // it's not a binding, it's an enum in disguise:\n@@ -624,14 +624,14 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n       ast::PatRegion(ref inner) => {\n           check_pointer_pat(pcx, Borrowed, &**inner, pat.id, pat.span, expected);\n       }\n-      ast::PatVec(ref before, slice, ref after) => {\n+      ast::PatVec(ref before, ref slice, ref after) => {\n         let default_region_var =\n             fcx.infcx().next_region_var(\n                 infer::PatternRegion(pat.span));\n \n         let check_err = |found: String| {\n-            for &elt in before.iter() {\n-                check_pat(pcx, &*elt, ty::mk_err());\n+            for elt in before.iter() {\n+                check_pat(pcx, &**elt, ty::mk_err());\n             }\n             for elt in slice.iter() {\n                 check_pat(pcx, &**elt, ty::mk_err());\n@@ -690,7 +690,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         };\n \n         let min_len = before.len() + after.len();\n-        fixed.and_then(|count| match slice {\n+        fixed.and_then(|count| match *slice {\n             Some(_) if count < min_len =>\n                 Some(format!(\"a fixed vector pattern of size at least {}\", min_len)),\n \n@@ -703,7 +703,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         for elt in before.iter() {\n             check_pat(pcx, &**elt, elt_type);\n         }\n-        match slice {\n+        match *slice {\n             Some(ref slice_pat) => {\n                 let slice_ty = ty::mk_slice(tcx,\n                                             region_var,"}, {"sha": "8ac9f072a0b32bb78a9a92cb1cee3798aa00a4db", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 114, "deletions": 109, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -124,7 +124,7 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::rc::Rc;\n-use std::gc::Gc;\n+use std::slice;\n use syntax::abi;\n use syntax::ast::{ProvidedMethod, RequiredMethod};\n use syntax::ast;\n@@ -137,6 +137,7 @@ use syntax::codemap;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n use syntax;\n@@ -401,7 +402,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n+pub fn check_item_types(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n+\n     let mut visit = CheckTypeWellFormedVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate);\n \n@@ -624,7 +627,7 @@ fn span_for_field(tcx: &ty::ctxt, field: &ty::field_ty, struct_id: ast::DefId) -\n     };\n \n     match item.node {\n-        ast::ItemStruct(struct_def, _) => {\n+        ast::ItemStruct(ref struct_def, _) => {\n             match struct_def.fields.iter().find(|f| match f.node.kind {\n                 ast::NamedField(ident, _) => ident.name == field.name,\n                 _ => false,\n@@ -818,8 +821,8 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for impl_item in impl_items.iter() {\n             match *impl_item {\n-                ast::MethodImplItem(m) => {\n-                    check_method_body(ccx, &impl_pty.generics, &*m);\n+                ast::MethodImplItem(ref m) => {\n+                    check_method_body(ccx, &impl_pty.generics, &**m);\n                 }\n             }\n         }\n@@ -841,14 +844,14 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       }\n       ast::ItemTrait(_, _, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n-        for trait_method in (*trait_methods).iter() {\n+        for trait_method in trait_methods.iter() {\n             match *trait_method {\n                 RequiredMethod(..) => {\n                     // Nothing to do, since required methods don't have\n                     // bodies to check.\n                 }\n-                ProvidedMethod(m) => {\n-                    check_method_body(ccx, &trait_def.generics, &*m);\n+                ProvidedMethod(ref m) => {\n+                    check_method_body(ccx, &trait_def.generics, &**m);\n                 }\n             }\n         }\n@@ -930,7 +933,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n     // and compatible with trait signature\n     for impl_item in impl_items.iter() {\n         match *impl_item {\n-            ast::MethodImplItem(impl_method) => {\n+            ast::MethodImplItem(ref impl_method) => {\n                 let impl_method_def_id = local_def(impl_method.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                           impl_method_def_id);\n@@ -983,7 +986,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                 let is_implemented =\n                     impl_items.iter().any(|ii| {\n                         match *ii {\n-                            ast::MethodImplItem(m) => {\n+                            ast::MethodImplItem(ref m) => {\n                                 m.pe_ident().name == trait_method.ident.name\n                             }\n                         }\n@@ -1968,9 +1971,9 @@ pub fn autoderef<T>(fcx: &FnCtxt, sp: Span, base_ty: ty::t,\n /// Attempts to resolve a call expression as an overloaded call.\n fn try_overloaded_call(fcx: &FnCtxt,\n                        call_expression: &ast::Expr,\n-                       callee: Gc<ast::Expr>,\n+                       callee: &ast::Expr,\n                        callee_type: ty::t,\n-                       args: &[Gc<ast::Expr>])\n+                       args: &[P<ast::Expr>])\n                        -> bool {\n     // Bail out if the callee is a bare function or a closure. We check those\n     // manually.\n@@ -2072,9 +2075,9 @@ fn try_overloaded_deref(fcx: &FnCtxt,\n fn try_overloaded_index(fcx: &FnCtxt,\n                         method_call: Option<MethodCall>,\n                         expr: &ast::Expr,\n-                        base_expr: Gc<ast::Expr>,\n+                        base_expr: &ast::Expr,\n                         base_ty: ty::t,\n-                        index_expr: Gc<ast::Expr>,\n+                        index_expr: &P<ast::Expr>,\n                         lvalue_pref: LvaluePreference)\n                         -> Option<ty::mt> {\n     // Try `IndexMut` first, if preferred.\n@@ -2119,7 +2122,7 @@ fn try_overloaded_index(fcx: &FnCtxt,\n                                 expr.span,\n                                 method_type,\n                                 expr,\n-                                [base_expr, index_expr],\n+                                slice::ref_slice(index_expr),\n                                 DoDerefArgs,\n                                 DontTupleArguments);\n \n@@ -2145,7 +2148,7 @@ fn try_overloaded_index(fcx: &FnCtxt,\n /// The return type of this function represents the concrete element type\n /// `A` in the type `Iterator<A>` that the method returns.\n fn lookup_method_for_for_loop(fcx: &FnCtxt,\n-                              iterator_expr: Gc<ast::Expr>,\n+                              iterator_expr: &ast::Expr,\n                               loop_id: ast::NodeId)\n                               -> ty::t {\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n@@ -2188,8 +2191,8 @@ fn lookup_method_for_for_loop(fcx: &FnCtxt,\n     let return_type = check_method_argument_types(fcx,\n                                                   iterator_expr.span,\n                                                   method_type,\n-                                                  &*iterator_expr,\n-                                                  [iterator_expr],\n+                                                  iterator_expr,\n+                                                  &[],\n                                                   DontDerefArgs,\n                                                   DontTupleArguments);\n \n@@ -2224,23 +2227,17 @@ fn check_method_argument_types(fcx: &FnCtxt,\n                                sp: Span,\n                                method_fn_ty: ty::t,\n                                callee_expr: &ast::Expr,\n-                               args: &[Gc<ast::Expr>],\n+                               args_no_rcvr: &[P<ast::Expr>],\n                                deref_args: DerefArgs,\n                                tuple_arguments: TupleArgumentsFlag)\n                                -> ty::t {\n-    // HACK(eddyb) ignore provided self (it has special typeck rules).\n-    let args = if tuple_arguments == DontTupleArguments {\n-        args.slice_from(1)\n-    } else {\n-        args\n-    };\n     if ty::type_is_error(method_fn_ty) {\n-        let err_inputs = err_args(args.len());\n+       let err_inputs = err_args(args_no_rcvr.len());\n         check_argument_types(fcx,\n                              sp,\n                              err_inputs.as_slice(),\n                              callee_expr,\n-                             args,\n+                             args_no_rcvr,\n                              deref_args,\n                              false,\n                              tuple_arguments);\n@@ -2253,7 +2250,7 @@ fn check_method_argument_types(fcx: &FnCtxt,\n                                      sp,\n                                      fty.sig.inputs.slice_from(1),\n                                      callee_expr,\n-                                     args,\n+                                     args_no_rcvr,\n                                      deref_args,\n                                      fty.sig.variadic,\n                                      tuple_arguments);\n@@ -2271,7 +2268,7 @@ fn check_argument_types(fcx: &FnCtxt,\n                         sp: Span,\n                         fn_inputs: &[ty::t],\n                         callee_expr: &ast::Expr,\n-                        args: &[Gc<ast::Expr>],\n+                        args: &[P<ast::Expr>],\n                         deref_args: DerefArgs,\n                         variadic: bool,\n                         tuple_arguments: TupleArgumentsFlag) {\n@@ -2665,7 +2662,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_call(fcx: &FnCtxt,\n                   call_expr: &ast::Expr,\n                   f: &ast::Expr,\n-                  args: &[Gc<ast::Expr>]) {\n+                  args: &[P<ast::Expr>]) {\n         // Store the type of `f` as the type of the callee\n         let fn_ty = fcx.expr_ty(f);\n \n@@ -2716,9 +2713,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_method_call(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::SpannedIdent,\n-                         args: &[Gc<ast::Expr>],\n-                         tps: &[ast::P<ast::Ty>]) {\n-        let rcvr = args[0].clone();\n+                         args: &[P<ast::Expr>],\n+                         tps: &[P<ast::Ty>]) {\n+        let rcvr = &*args[0];\n         // We can't know if we need &mut self before we look up the method,\n         // so treat the receiver as mutable just in case - only explicit\n         // overloaded dereferences care about the distinction.\n@@ -2779,7 +2776,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                  method_name.span,\n                                                  fn_ty,\n                                                  expr,\n-                                                 args,\n+                                                 args.slice_from(1),\n                                                  DontDerefArgs,\n                                                  DontTupleArguments);\n \n@@ -2791,7 +2788,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_then_else(fcx: &FnCtxt,\n                        cond_expr: &ast::Expr,\n                        then_blk: &ast::Block,\n-                       opt_else_expr: Option<Gc<ast::Expr>>,\n+                       opt_else_expr: Option<&ast::Expr>,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Expectation) {\n@@ -2852,22 +2849,31 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method(fcx: &FnCtxt,\n-                        op_ex: &ast::Expr,\n-                        self_t: ty::t,\n-                        opname: ast::Name,\n-                        trait_did: Option<ast::DefId>,\n-                        args: &[Gc<ast::Expr>],\n-                        autoderef_receiver: AutoderefReceiverFlag,\n-                        unbound_method: ||) -> ty::t {\n+    fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                                  op_ex: &ast::Expr,\n+                                  lhs_ty: ty::t,\n+                                  opname: ast::Name,\n+                                  trait_did: Option<ast::DefId>,\n+                                  lhs: &'a ast::Expr,\n+                                  rhs: Option<&P<ast::Expr>>,\n+                                  autoderef_receiver: AutoderefReceiverFlag,\n+                                  unbound_method: ||) -> ty::t {\n         let method = match trait_did {\n             Some(trait_did) => {\n-                method::lookup_in_trait(fcx, op_ex.span, Some(&*args[0]), opname,\n-                                        trait_did, self_t, [], autoderef_receiver,\n+                method::lookup_in_trait(fcx, op_ex.span, Some(lhs), opname,\n+                                        trait_did, lhs_ty, &[], autoderef_receiver,\n                                         IgnoreStaticMethods)\n             }\n             None => None\n         };\n+        let args = match rhs {\n+            Some(rhs) => slice::ref_slice(rhs),\n+            None => {\n+                // Work around the lack of coercion.\n+                let empty: &[_] = &[];\n+                empty\n+            }\n+        };\n         match method {\n             Some(method) => {\n                 let method_ty = method.ty;\n@@ -2903,8 +2909,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_binop(fcx: &FnCtxt,\n                    expr: &ast::Expr,\n                    op: ast::BinOp,\n-                   lhs: Gc<ast::Expr>,\n-                   rhs: Gc<ast::Expr>,\n+                   lhs: &ast::Expr,\n+                   rhs: &P<ast::Expr>,\n                    is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -2920,15 +2926,15 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n-            check_expr_has_type(fcx, &*rhs, ty::mk_uint());\n+            check_expr_has_type(fcx, &**rhs, ty::mk_uint());\n             fcx.write_ty(expr.id, lhs_t);\n             return;\n         }\n \n         if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            check_expr_has_type(fcx, &*rhs, tvar);\n+            check_expr_has_type(fcx, &**rhs, tvar);\n \n             let result_t = match op {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n@@ -2993,7 +2999,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                    },\n                                    lhs_t,\n                                    None);\n-            check_expr(fcx, &*rhs);\n+            check_expr(fcx, &**rhs);\n             ty::mk_err()\n         };\n \n@@ -3005,10 +3011,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n     fn check_user_binop(fcx: &FnCtxt,\n                         ex: &ast::Expr,\n-                        lhs_expr: Gc<ast::Expr>,\n+                        lhs_expr: &ast::Expr,\n                         lhs_resolved_t: ty::t,\n                         op: ast::BinOp,\n-                        rhs: Gc<ast::Expr>) -> ty::t {\n+                        rhs: &P<ast::Expr>) -> ty::t {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n         let (name, trait_did) = match op {\n@@ -3029,12 +3035,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             ast::BiEq => (\"eq\", lang.eq_trait()),\n             ast::BiNe => (\"ne\", lang.eq_trait()),\n             ast::BiAnd | ast::BiOr => {\n-                check_expr(fcx, &*rhs);\n+                check_expr(fcx, &**rhs);\n                 return ty::mk_err();\n             }\n         };\n         lookup_op_method(fcx, ex, lhs_resolved_t, token::intern(name),\n-                         trait_did, [lhs_expr, rhs], DontAutoderefReceiver, || {\n+                         trait_did, lhs_expr, Some(rhs), DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n                         ast_util::binop_to_string(op),\n@@ -3048,10 +3054,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        mname: &str,\n                        trait_did: Option<ast::DefId>,\n                        ex: &ast::Expr,\n-                       rhs_expr: Gc<ast::Expr>,\n+                       rhs_expr: &ast::Expr,\n                        rhs_t: ty::t) -> ty::t {\n        lookup_op_method(fcx, ex, rhs_t, token::intern(mname),\n-                        trait_did, [rhs_expr], DontAutoderefReceiver, || {\n+                        trait_did, rhs_expr, None, DontAutoderefReceiver, || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n@@ -3063,7 +3069,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              expr: &ast::Expr,\n                              kind: ast::UnboxedClosureKind,\n                              decl: &ast::FnDecl,\n-                             body: ast::P<ast::Block>) {\n+                             body: &ast::Block) {\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx,\n             expr.id,\n@@ -3131,7 +3137,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                      expr: &ast::Expr,\n                      store: ty::TraitStore,\n                      decl: &ast::FnDecl,\n-                     body: ast::P<ast::Block>,\n+                     body: &ast::Block,\n                      expected: Expectation) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -3228,7 +3234,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                    lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n                    field: &ast::SpannedIdent,\n-                   tys: &[ast::P<ast::Ty>]) {\n+                   tys: &[P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3302,7 +3308,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                        lvalue_pref: LvaluePreference,\n                        base: &ast::Expr,\n                        idx: codemap::Spanned<uint>,\n-                       _tys: &[ast::P<ast::Ty>]) {\n+                       _tys: &[P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3453,7 +3459,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                 span: codemap::Span,\n                                 class_id: ast::DefId,\n                                 fields: &[ast::Field],\n-                                base_expr: Option<Gc<ast::Expr>>) {\n+                                base_expr: Option<&ast::Expr>) {\n         let tcx = fcx.ccx.tcx;\n \n         // Look up the number of type parameters and the raw type, and\n@@ -3527,14 +3533,14 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n     fn check_struct_fields_on_error(fcx: &FnCtxt,\n                                     id: ast::NodeId,\n                                     fields: &[ast::Field],\n-                                    base_expr: Option<Gc<ast::Expr>>) {\n+                                    base_expr: &Option<P<ast::Expr>>) {\n         // Make sure to still write the types\n         // otherwise we might ICE\n         fcx.write_error(id);\n         for field in fields.iter() {\n             check_expr(fcx, &*field.expr);\n         }\n-        match base_expr {\n+        match *base_expr {\n             Some(ref base) => check_expr(fcx, &**base),\n             None => {}\n         }\n@@ -3578,12 +3584,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n \n-      ast::ExprLit(lit) => {\n-        let typ = check_lit(fcx, &*lit, expected);\n+      ast::ExprLit(ref lit) => {\n+        let typ = check_lit(fcx, &**lit, expected);\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprBinary(op, ref lhs, ref rhs) => {\n-        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), SimpleBinop);\n+        check_binop(fcx, expr, op, &**lhs, rhs, SimpleBinop);\n \n         let lhs_ty = fcx.expr_ty(&**lhs);\n         let rhs_ty = fcx.expr_ty(&**rhs);\n@@ -3597,7 +3603,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n-        check_binop(fcx, expr, op, lhs.clone(), rhs.clone(), BinopAssignment);\n+        check_binop(fcx, expr, op, &**lhs, rhs, BinopAssignment);\n \n         let lhs_t = fcx.expr_ty(&**lhs);\n         let result_t = fcx.expr_ty(expr);\n@@ -3691,7 +3697,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n                         oprnd_t = check_user_unop(fcx, \"!\", \"not\",\n                                                   tcx.lang_items.not_trait(),\n-                                                  expr, oprnd.clone(), oprnd_t);\n+                                                  expr, &**oprnd, oprnd_t);\n                     }\n                 }\n                 ast::UnNeg => {\n@@ -3701,7 +3707,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          ty::type_is_fp(oprnd_t)) {\n                         oprnd_t = check_user_unop(fcx, \"-\", \"neg\",\n                                                   tcx.lang_items.neg_trait(),\n-                                                  expr, oprnd.clone(), oprnd_t);\n+                                                  expr, &**oprnd, oprnd_t);\n                     }\n                 }\n             }\n@@ -3802,12 +3808,12 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n         fcx.write_bot(id);\n       }\n-      ast::ExprParen(a) => {\n+      ast::ExprParen(ref a) => {\n         check_expr_with_expectation_and_lvalue_pref(fcx,\n-                                                    &*a,\n+                                                    &**a,\n                                                     expected,\n                                                     lvalue_pref);\n-        fcx.write_ty(id, fcx.expr_ty(&*a));\n+        fcx.write_ty(id, fcx.expr_ty(&**a));\n       }\n       ast::ExprAssign(ref lhs, ref rhs) => {\n         check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n@@ -3831,7 +3837,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         }\n       }\n       ast::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.clone(),\n+        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.as_ref().map(|e| &**e),\n                         id, expr.span, expected);\n       }\n       ast::ExprWhile(ref cond, ref body, _) => {\n@@ -3851,7 +3857,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprForLoop(ref pat, ref head, ref block, _) => {\n         check_expr(fcx, &**head);\n-        let typ = lookup_method_for_for_loop(fcx, *head, expr.id);\n+        let typ = lookup_method_for_for_loop(fcx, &**head, expr.id);\n         vtable::early_resolve_expr(expr, fcx, true);\n \n         let pcx = pat_ctxt {\n@@ -3865,10 +3871,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, &**body);\n-        if !may_break(tcx, expr.id, body.clone()) {\n+        if !may_break(tcx, expr.id, &**body) {\n             fcx.write_bot(id);\n-        }\n-        else {\n+        } else {\n             fcx.write_nil(id);\n         }\n       }\n@@ -3884,22 +3889,22 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       expr,\n                       ty::RegionTraitStore(region, ast::MutMutable),\n                       &**decl,\n-                      body.clone(),\n+                      &**body,\n                       expected);\n       }\n       ast::ExprUnboxedFn(_, kind, ref decl, ref body) => {\n         check_unboxed_closure(fcx,\n                               expr,\n                               kind,\n                               &**decl,\n-                              *body);\n+                              &**body);\n       }\n       ast::ExprProc(ref decl, ref body) => {\n         check_expr_fn(fcx,\n                       expr,\n                       ty::UniqTraitStore,\n                       &**decl,\n-                      body.clone(),\n+                      &**body,\n                       expected);\n       }\n       ast::ExprBlock(ref b) => {\n@@ -3912,7 +3917,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           check_expr(fcx, &**f);\n           let f_ty = fcx.expr_ty(&**f);\n \n-          if !try_overloaded_call(fcx, expr, f.clone(), f_ty, args.as_slice()) {\n+          if !try_overloaded_call(fcx, expr, &**f, f_ty, args.as_slice()) {\n               check_call(fcx, expr, &**f, args.as_slice());\n               let (args_bot, args_err) = args.iter().fold((false, false),\n                  |(rest_bot, rest_err), a| {\n@@ -4050,7 +4055,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_ty(id, typ);\n         }\n       }\n-      ast::ExprStruct(ref path, ref fields, base_expr) => {\n+      ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n         let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n         let struct_id = match def {\n@@ -4079,7 +4084,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                  expr.span,\n                                                  struct_did,\n                                                  fields.as_slice(),\n-                                                 base_expr);\n+                                                 base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n                         span_err!(tcx.sess, path.span, E0071,\n@@ -4168,9 +4173,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                       match try_overloaded_index(fcx,\n                                                  Some(method_call),\n                                                  expr,\n-                                                 *base,\n+                                                 &**base,\n                                                  base_t,\n-                                                 *idx,\n+                                                 idx,\n                                                  lvalue_pref) {\n                           Some(mt) => fcx.write_ty(id, mt.ty),\n                           None => {\n@@ -4331,7 +4336,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n     let mut saw_bot = false;\n     let mut saw_err = false;\n     match stmt.node {\n-      ast::StmtDecl(decl, id) => {\n+      ast::StmtDecl(ref decl, id) => {\n         node_id = id;\n         match decl.node {\n           ast::DeclLocal(ref l) => {\n@@ -4404,7 +4409,7 @@ fn check_block_with_expected(fcx: &FnCtxt,\n         let s_id = ast_util::stmt_id(&**s);\n         let s_ty = fcx.node_ty(s_id);\n         if last_was_bot && !warned && match s.node {\n-            ast::StmtDecl(decl, _) => {\n+            ast::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     ast::DeclLocal(_) => true,\n                     _ => false,\n@@ -4431,14 +4436,12 @@ fn check_block_with_expected(fcx: &FnCtxt,\n     match blk.expr {\n         None => if any_err {\n             fcx.write_error(blk.id);\n-        }\n-        else if any_bot {\n+        } else if any_bot {\n             fcx.write_bot(blk.id);\n-        }\n-        else  {\n+        } else {\n             fcx.write_nil(blk.id);\n         },\n-        Some(e) => {\n+        Some(ref e) => {\n             if any_bot && !warned {\n                 fcx.ccx\n                     .tcx\n@@ -4450,12 +4453,12 @@ fn check_block_with_expected(fcx: &FnCtxt,\n             }\n             let ety = match expected {\n                 ExpectHasType(ety) => {\n-                    check_expr_coercable_to_type(fcx, &*e, ety);\n+                    check_expr_coercable_to_type(fcx, &**e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &*e, expected);\n-                    fcx.expr_ty(&*e)\n+                    check_expr_with_expectation(fcx, &**e, expected);\n+                    fcx.expr_ty(&**e)\n                 }\n             };\n \n@@ -4603,8 +4606,8 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n \n \n pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n-                                 vs: &[ast::P<ast::Variant>]) {\n-    for &v in vs.iter() {\n+                                 vs: &[P<ast::Variant>]) {\n+    for v in vs.iter() {\n         match v.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n@@ -4626,15 +4629,17 @@ pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n                     }\n                 }\n             },\n-            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, &*struct_def),\n+            ast::StructVariantKind(ref struct_def) => {\n+                check_fields_sized(ccx.tcx, &**struct_def)\n+            }\n             _ => {}\n         }\n     }\n }\n \n pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n-                           vs: &[ast::P<ast::Variant>],\n+                           vs: &[P<ast::Variant>],\n                            id: ast::NodeId) {\n \n     fn disr_in_range(ccx: &CrateCtxt,\n@@ -4665,7 +4670,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     fn do_check(ccx: &CrateCtxt,\n-                vs: &[ast::P<ast::Variant>],\n+                vs: &[P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n                 -> Vec<Rc<ty::VariantInfo>> {\n@@ -4675,7 +4680,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n-        for &v in vs.iter() {\n+        for v in vs.iter() {\n \n             // If the discriminant value is specified explicitly in the enum check whether the\n             // initialization expression is valid, otherwise use the last value plus one.\n@@ -4685,8 +4690,8 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             };\n \n             match v.node.disr_expr {\n-                Some(e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&*e));\n+                Some(ref e) => {\n+                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n \n                     let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n@@ -4699,12 +4704,12 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                             ty::mk_mach_uint(ity)\n                         },\n                     };\n-                    check_const_with_ty(&fcx, e.span, &*e, declty);\n+                    check_const_with_ty(&fcx, e.span, &**e, declty);\n                     // check_expr (from check_const pass) doesn't guarantee\n                     // that the expression is in a form that eval_const_expr can\n                     // handle, so we may still get an internal compiler error\n \n-                    match const_eval::eval_const_expr_partial(ccx.tcx, &*e) {\n+                    match const_eval::eval_const_expr_partial(ccx.tcx, &**e) {\n                         Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                         Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                         Ok(_) => {\n@@ -4742,7 +4747,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             }\n             disr_vals.push(current_disr_val);\n \n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &*v,\n+            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, &**v,\n                                                                      current_disr_val));\n             prev_disr_val = Some(current_disr_val);\n \n@@ -5051,8 +5056,8 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         {\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n-            for (i, &typ) in segment.types.iter().enumerate() {\n-                let t = fcx.to_ty(&*typ);\n+            for (i, typ) in segment.types.iter().enumerate() {\n+                let t = fcx.to_ty(&**typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n                 } else if i == type_count {\n@@ -5256,7 +5261,7 @@ pub fn type_is_c_like_enum(fcx: &FnCtxt, sp: Span, typ: ty::t) -> bool {\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: ast::P<ast::Block>) -> bool {\n+pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(&*b, |e| {"}, {"sha": "95b7e03e6d9aa99464724be57ab48f9f0863d4c6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -141,7 +141,6 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::cell::RefCell;\n-use std::gc::Gc;\n \n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n@@ -614,23 +613,20 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     match expr.node {\n         ast::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(*callee),\n-                               args.as_slice(), false);\n+                constrain_call(rcx, expr, Some(&**callee),\n+                               args.iter().map(|e| &**e), false);\n             } else {\n                 constrain_callee(rcx, callee.id, expr, &**callee);\n-                constrain_call(rcx,\n-                               expr,\n-                               None,\n-                               args.as_slice(),\n-                               false);\n+                constrain_call(rcx, expr, None,\n+                               args.iter().map(|e| &**e), false);\n             }\n \n             visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(*args.get(0)),\n-                           args.slice_from(1), false);\n+            constrain_call(rcx, expr, Some(&**args.get(0)),\n+                           args.slice_from(1).iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -642,8 +638,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(lhs.clone()),\n-                               [rhs.clone()], true);\n+                constrain_call(rcx, expr, Some(&**lhs),\n+                               Some(&**rhs).move_iter(), true);\n             }\n \n             adjust_borrow_kind_for_assignment_lhs(rcx, &**lhs);\n@@ -657,15 +653,16 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, expr, Some(lhs.clone()),\n-                           [rhs.clone()], true);\n+            constrain_call(rcx, expr, Some(&**lhs),\n+                           Some(&**rhs).move_iter(), true);\n \n             visit::walk_expr(rcx, expr);\n         }\n \n         ast::ExprUnary(_, ref lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, expr, Some(lhs.clone()), [], true);\n+            constrain_call(rcx, expr, Some(&**lhs),\n+                           None::<ast::Expr>.iter(), true);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -683,7 +680,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, expr, Some(base.clone()), [], true);\n+                    constrain_call(rcx, expr, Some(&**base),\n+                                   None::<ast::Expr>.iter(), true);\n                     ty::ty_fn_ret(method.ty)\n                 }\n                 None => rcx.resolve_node_type(base.id)\n@@ -1080,11 +1078,11 @@ fn constrain_callee(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_call(rcx: &mut Rcx,\n-                  call_expr: &ast::Expr,\n-                  receiver: Option<Gc<ast::Expr>>,\n-                  arg_exprs: &[Gc<ast::Expr>],\n-                  implicitly_ref_args: bool) {\n+fn constrain_call<'a, I: Iterator<&'a ast::Expr>>(rcx: &mut Rcx,\n+                                                  call_expr: &ast::Expr,\n+                                                  receiver: Option<&ast::Expr>,\n+                                                  mut arg_exprs: I,\n+                                                  implicitly_ref_args: bool) {\n     //! Invoked on every call site (i.e., normal calls, method calls,\n     //! and overloaded operators). Constrains the regions which appear\n     //! in the type of the function. Also constrains the regions that\n@@ -1093,11 +1091,9 @@ fn constrain_call(rcx: &mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     debug!(\"constrain_call(call_expr={}, \\\n             receiver={}, \\\n-            arg_exprs={}, \\\n             implicitly_ref_args={:?})\",\n             call_expr.repr(tcx),\n             receiver.repr(tcx),\n-            arg_exprs.repr(tcx),\n             implicitly_ref_args);\n \n     // `callee_region` is the scope representing the time in which the\n@@ -1109,7 +1105,7 @@ fn constrain_call(rcx: &mut Rcx,\n \n     debug!(\"callee_region={}\", callee_region.repr(tcx));\n \n-    for arg_expr in arg_exprs.iter() {\n+    for arg_expr in arg_exprs {\n         debug!(\"Argument: {}\", arg_expr.repr(tcx));\n \n         // ensure that any regions appearing in the argument type are\n@@ -1123,7 +1119,7 @@ fn constrain_call(rcx: &mut Rcx,\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &**arg_expr, callee_scope);\n+            link_by_ref(rcx, arg_expr, callee_scope);\n         }\n     }\n \n@@ -1292,10 +1288,10 @@ fn link_local(rcx: &Rcx, local: &ast::Local) {\n     debug!(\"regionck::for_local()\");\n     let init_expr = match local.init {\n         None => { return; }\n-        Some(ref expr) => expr,\n+        Some(ref expr) => &**expr,\n     };\n     let mc = mc::MemCategorizationContext::new(rcx);\n-    let discr_cmt = ignore_err!(mc.cat_expr(&**init_expr));\n+    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     link_pattern(rcx, mc, discr_cmt, &*local.pat);\n }\n "}, {"sha": "8de17627e28253be2921a28607c2b3fbeb40cfbc", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                         ast_items.iter()\n                                  .map(|ast_item| {\n                             match *ast_item {\n-                                ast::MethodImplItem(ast_method) => {\n+                                ast::MethodImplItem(ref ast_method) => {\n                                     MethodTraitItemId(\n                                         local_def(ast_method.id))\n                                 }\n@@ -820,9 +820,9 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n     )\n }\n \n-pub fn check_coherence(crate_context: &CrateCtxt, krate: &Crate) {\n+pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n-    }.check(krate);\n+    }.check(crate_context.tcx.map.krate());\n }"}, {"sha": "581bd8acbc97ea7053908fbc0e6c415dd5be9f38", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -53,22 +53,22 @@ use util::ppaux::{Repr,UserString};\n \n use std::collections::{HashMap, HashSet};\n use std::rc::Rc;\n-use std::gc::Gc;\n \n use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{local_def, split_trait_methods, PostExpansionMethod};\n+use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n use syntax::print::pprust::{path_to_string};\n+use syntax::ptr::P;\n use syntax::visit;\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n \n-pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n+pub fn collect_item_types(ccx: &CrateCtxt) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n         let ty::Polytype { ty: ty, .. } =\n@@ -84,10 +84,10 @@ pub fn collect_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     }\n \n     let mut visitor = CollectTraitDefVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, krate);\n+    visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n \n     let mut visitor = CollectItemTypesVisitor{ ccx: ccx };\n-    visit::walk_crate(&mut visitor, krate);\n+    visit::walk_crate(&mut visitor, ccx.tcx.map.krate());\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -179,7 +179,7 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n \n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n-                              variants: &[ast::P<ast::Variant>],\n+                              variants: &[P<ast::Variant>],\n                               generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n@@ -199,13 +199,13 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                 enum_ty\n             }\n \n-            ast::StructVariantKind(struct_def) => {\n+            ast::StructVariantKind(ref struct_def) => {\n                 let pty = Polytype {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx, &*struct_def, pty, variant.node.id);\n+                convert_struct(ccx, &**struct_def, pty, variant.node.id);\n \n                 let input_tys: Vec<_> = struct_def.fields.iter().map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id)).collect();\n@@ -332,7 +332,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                   *m_id,\n                                   *m_fn_style,\n                                   trait_self_ty,\n-                                  *m_explicit_self,\n+                                  m_explicit_self,\n                                   m_decl,\n                                   m_abi);\n         let ty_generics =\n@@ -386,28 +386,27 @@ pub fn convert_field(ccx: &CrateCtxt,\n     }\n }\n \n-fn convert_methods(ccx: &CrateCtxt,\n-                   container: ImplOrTraitItemContainer,\n-                   ms: &[Gc<ast::Method>],\n-                   untransformed_rcvr_ty: ty::t,\n-                   rcvr_ty_generics: &ty::Generics,\n-                   rcvr_visibility: ast::Visibility)\n-{\n+fn convert_methods<'a, I: Iterator<&'a ast::Method>>(ccx: &CrateCtxt,\n+        container: ImplOrTraitItemContainer,\n+        mut ms: I,\n+        untransformed_rcvr_ty: ty::t,\n+        rcvr_ty_generics: &ty::Generics,\n+        rcvr_visibility: ast::Visibility) {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n             rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n-    for m in ms.iter() {\n+    for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(ccx.tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n         let mty = Rc::new(ty_of_method(ccx,\n                                        container,\n-                                       &**m,\n+                                       m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n                                        rcvr_visibility));\n@@ -459,7 +458,7 @@ fn convert_methods(ccx: &CrateCtxt,\n                                   m.id,\n                                   m.pe_fn_style(),\n                                   untransformed_rcvr_ty,\n-                                  *m.pe_explicit_self(),\n+                                  m.pe_explicit_self(),\n                                   &*m.pe_fn_decl(),\n                                   real_abi);\n \n@@ -524,10 +523,10 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemImpl(ref generics,\n                       ref opt_trait_ref,\n-                      selfty,\n+                      ref selfty,\n                       ref impl_items) => {\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let selfty = ccx.to_ty(&ExplicitRscope, &*selfty);\n+            let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -554,14 +553,14 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                                &BindingRscope::new(method.id),\n                                                selfty,\n                                                method.pe_explicit_self());\n-                        methods.push(*method);\n+                        methods.push(&**method);\n                     }\n                 }\n             }\n \n             convert_methods(ccx,\n                             ImplContainer(local_def(it.id)),\n-                            methods.as_slice(),\n+                            methods.move_iter(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n@@ -600,12 +599,13 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             }\n \n             // Run convert_methods on the provided methods.\n-            let (_, provided_methods) =\n-                split_trait_methods(trait_methods.as_slice());\n             let untransformed_rcvr_ty = ty::mk_self_type(tcx, local_def(it.id));\n             convert_methods(ccx,\n                             TraitContainer(local_def(it.id)),\n-                            provided_methods.as_slice(),\n+                            trait_methods.iter().filter_map(|m| match *m {\n+                                ast::RequiredMethod(_) => None,\n+                                ast::ProvidedMethod(ref m) => Some(&**m)\n+                            }),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n                             it.vis);\n@@ -615,7 +615,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             // static trait methods. This is somewhat unfortunate.\n             collect_trait_methods(ccx, it.id, &*trait_def);\n         },\n-        ast::ItemStruct(struct_def, _) => {\n+        ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n             let pty = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, pty.ty);\n@@ -624,14 +624,14 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             // Write the super-struct type, if it exists.\n             match struct_def.super_struct {\n-                Some(ty) => {\n-                    let supserty = ccx.to_ty(&ExplicitRscope, &*ty);\n+                Some(ref ty) => {\n+                    let supserty = ccx.to_ty(&ExplicitRscope, &**ty);\n                     write_ty_to_tcx(tcx, it.id, supserty);\n                 },\n                 _ => {},\n             }\n \n-            convert_struct(ccx, &*struct_def, pty, it.id);\n+            convert_struct(ccx, &**struct_def, pty, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -683,7 +683,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let super_struct = match struct_def.super_struct {\n-        Some(t) => match t.node {\n+        Some(ref t) => match t.node {\n             ast::TyPath(_, _, path_id) => {\n                 let def_map = tcx.def_map.borrow();\n                 match def_map.find(&path_id) {\n@@ -692,7 +692,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                         // Check super-struct is virtual.\n                         match tcx.map.find(def_id.node) {\n                             Some(ast_map::NodeItem(i)) => match i.node {\n-                                ast::ItemStruct(struct_def, _) => {\n+                                ast::ItemStruct(ref struct_def, _) => {\n                                     if !struct_def.is_virtual {\n                                         span_err!(tcx.sess, t.span, E0126,\n                                                   \"struct inheritance is only \\\n@@ -908,21 +908,21 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         _ => {}\n     }\n     match it.node {\n-        ast::ItemStatic(t, _, _) => {\n-            let typ = ccx.to_ty(&ExplicitRscope, &*t);\n+        ast::ItemStatic(ref t, _, _) => {\n+            let typ = ccx.to_ty(&ExplicitRscope, &**t);\n             let pty = no_params(typ);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n             return pty;\n         }\n-        ast::ItemFn(decl, fn_style, abi, ref generics, _) => {\n+        ast::ItemFn(ref decl, fn_style, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn_or_method(ccx, generics,\n                                                            ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(ccx,\n                                               it.id,\n                                               fn_style,\n                                               abi,\n-                                              &*decl);\n+                                              &**decl);\n             let pty = Polytype {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n@@ -935,14 +935,14 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n             return pty;\n         }\n-        ast::ItemTy(t, ref generics) => {\n+        ast::ItemTy(ref t, ref generics) => {\n             match tcx.tcache.borrow_mut().find(&local_def(it.id)) {\n                 Some(pty) => return pty.clone(),\n                 None => { }\n             }\n \n             let pty = {\n-                let ty = ccx.to_ty(&ExplicitRscope, &*t);\n+                let ty = ccx.to_ty(&ExplicitRscope, &**t);\n                 Polytype {\n                     generics: ty_generics_for_type(ccx, generics),\n                     ty: ty\n@@ -990,17 +990,17 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                           abi: abi::Abi) -> ty::Polytype\n {\n     match it.node {\n-        ast::ForeignItemFn(fn_decl, ref generics) => {\n+        ast::ForeignItemFn(ref fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n-                                  &*fn_decl,\n+                                  &**fn_decl,\n                                   local_def(it.id),\n                                   generics,\n                                   abi)\n         }\n-        ast::ForeignItemStatic(t, _) => {\n+        ast::ForeignItemStatic(ref t, _) => {\n             ty::Polytype {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &*t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, &**t)\n             }\n         }\n     }\n@@ -1163,8 +1163,8 @@ fn ty_generics(ccx: &CrateCtxt,\n                                     &param.unbound,\n                                     param.span,\n                                     where_clause);\n-        let default = param.default.map(|path| {\n-            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n+            let default = param.default.as_ref().map(|path| {\n+            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {"}, {"sha": "b5b4cc80faac1b9d302ef7980c5d616178d1f05a", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 101, "deletions": 109, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -60,7 +60,6 @@ time of error detection.\n */\n \n use std::collections::HashSet;\n-use std::gc::GC;\n use middle::def;\n use middle::subst;\n use middle::ty;\n@@ -84,12 +83,12 @@ use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util;\n use syntax::ast_util::{name_to_dummy_lifetime, PostExpansionMethod};\n use syntax::owned_slice::OwnedSlice;\n use syntax::codemap;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use util::ppaux::bound_region_to_string;\n use util::ppaux::note_and_explain_region;\n \n@@ -161,7 +160,7 @@ trait ErrorReportingHelpers {\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,\n                                 ident: ast::Ident,\n-                                opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n                                 span: codemap::Span);\n }\n@@ -855,8 +854,8 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        ast::ItemFn(fn_decl, ref pur, _, ref gen, _) => {\n-                            Some((fn_decl, gen, *pur, item.ident, None, item.span))\n+                        ast::ItemFn(ref fn_decl, pur, _, ref gen, _) => {\n+                            Some((&**fn_decl, gen, pur, item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n@@ -868,7 +867,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                   m.pe_generics(),\n                                   m.pe_fn_style(),\n                                   m.pe_ident(),\n-                                  Some(m.pe_explicit_self().node),\n+                                  Some(&m.pe_explicit_self().node),\n                                   m.span))\n                         }\n                     }\n@@ -885,7 +884,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n         self.give_expl_lifetime_param(&fn_decl, fn_style, ident,\n-                                      expl_self, &generics, span);\n+                                      expl_self.as_ref(), &generics, span);\n     }\n }\n \n@@ -902,8 +901,8 @@ struct RebuildPathInfo<'a> {\n \n struct Rebuilder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    fn_decl: ast::P<ast::FnDecl>,\n-    expl_self_opt: Option<ast::ExplicitSelf_>,\n+    fn_decl: &'a ast::FnDecl,\n+    expl_self_opt: Option<&'a ast::ExplicitSelf_>,\n     generics: &'a ast::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n@@ -918,8 +917,8 @@ enum FreshOrKept {\n \n impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n-           fn_decl: ast::P<ast::FnDecl>,\n-           expl_self_opt: Option<ast::ExplicitSelf_>,\n+           fn_decl: &'a ast::FnDecl,\n+           expl_self_opt: Option<&'a ast::ExplicitSelf_>,\n            generics: &'a ast::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n@@ -938,9 +937,9 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n     fn rebuild(&self)\n                -> (ast::FnDecl, Option<ast::ExplicitSelf_>, ast::Generics) {\n-        let mut expl_self_opt = self.expl_self_opt;\n+        let mut expl_self_opt = self.expl_self_opt.map(|x| x.clone());\n         let mut inputs = self.fn_decl.inputs.clone();\n-        let mut output = self.fn_decl.output;\n+        let mut output = self.fn_decl.output.clone();\n         let mut ty_params = self.generics.ty_params.clone();\n         let where_clause = self.generics.where_clause.clone();\n         let mut kept_lifetimes = HashSet::new();\n@@ -958,7 +957,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                                    &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(inputs.as_slice(), lifetime,\n                                           &anon_nums, &region_names);\n-            output = self.rebuild_arg_ty_or_output(output, lifetime,\n+            output = self.rebuild_arg_ty_or_output(&*output, lifetime,\n                                                    &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n                                                &region_names);\n@@ -1068,7 +1067,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 id: ty_param.id,\n                 bounds: bounds,\n                 unbound: ty_param.unbound.clone(),\n-                default: ty_param.default,\n+                default: ty_param.default.clone(),\n                 span: ty_param.span,\n             }\n         })\n@@ -1087,8 +1086,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::UnboxedFnTyParamBound(unboxed_function_type) => {\n-                    ast::UnboxedFnTyParamBound(unboxed_function_type)\n+                &ast::UnboxedFnTyParamBound(ref unboxed_function_type) => {\n+                    ast::UnboxedFnTyParamBound((*unboxed_function_type).clone())\n                 }\n                 &ast::TraitTyParamBound(ref tr) => {\n                     let last_seg = tr.path.segments.last().unwrap();\n@@ -1122,7 +1121,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                          region_names: &HashSet<ast::Name>)\n                          -> Option<ast::ExplicitSelf_> {\n         match expl_self_opt {\n-            Some(expl_self) => match expl_self {\n+            Some(ref expl_self) => match *expl_self {\n                 ast::SelfRegion(lt_opt, muta, id) => match lt_opt {\n                     Some(lt) => if region_names.contains(&lt.name) {\n                         return Some(ast::SelfRegion(Some(lifetime), muta, id));\n@@ -1177,11 +1176,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        -> Vec<ast::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs.iter() {\n-            let new_ty = self.rebuild_arg_ty_or_output(arg.ty, lifetime,\n+            let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n                                                        anon_nums, region_names);\n             let possibly_new_arg = ast::Arg {\n                 ty: new_ty,\n-                pat: arg.pat,\n+                pat: arg.pat.clone(),\n                 id: arg.id\n             };\n             new_inputs.push(possibly_new_arg);\n@@ -1190,36 +1189,40 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n \n     fn rebuild_arg_ty_or_output(&self,\n-                                ty: ast::P<ast::Ty>,\n+                                ty: &ast::Ty,\n                                 lifetime: ast::Lifetime,\n                                 anon_nums: &HashSet<uint>,\n                                 region_names: &HashSet<ast::Name>)\n-                                -> ast::P<ast::Ty> {\n-        let mut new_ty = ty;\n+                                -> P<ast::Ty> {\n+        let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n-        let mut cur_ty;\n         while !ty_queue.is_empty() {\n-            cur_ty = ty_queue.shift().unwrap();\n+            let cur_ty = ty_queue.shift().unwrap();\n             match cur_ty.node {\n-                ast::TyRptr(lt_opt, mut_ty) => {\n-                    match lt_opt {\n-                        Some(lt) => if region_names.contains(&lt.name) {\n-                            new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                     lifetime, None);\n-                        },\n+                ast::TyRptr(lt_opt, ref mut_ty) => {\n+                    let rebuild = match lt_opt {\n+                        Some(lt) => region_names.contains(&lt.name),\n                         None => {\n                             let anon = self.cur_anon.get();\n-                            if anon_nums.contains(&anon) {\n-                                new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                         lifetime, None);\n+                            let rebuild = anon_nums.contains(&anon);\n+                            if rebuild {\n                                 self.track_anon(anon);\n                             }\n                             self.inc_and_offset_cur_anon(1);\n+                            rebuild\n                         }\n+                    };\n+                    if rebuild {\n+                        let to = ast::Ty {\n+                            id: cur_ty.id,\n+                            node: ast::TyRptr(Some(lifetime), mut_ty.clone()),\n+                            span: cur_ty.span\n+                        };\n+                        new_ty = self.rebuild_ty(new_ty, P(to));\n                     }\n-                    ty_queue.push(mut_ty.ty);\n+                    ty_queue.push(&*mut_ty.ty);\n                 }\n-                ast::TyPath(ref path, _, id) => {\n+                ast::TyPath(ref path, ref bounds, id) => {\n                     let a_def = match self.tcx.def_map.borrow().find(&id) {\n                         None => {\n                             self.tcx\n@@ -1232,10 +1235,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     };\n                     match a_def {\n                         def::DefTy(did) | def::DefStruct(did) => {\n-                            let ty::Polytype {\n-                                generics: generics,\n-                                ty: _\n-                            } = ty::lookup_item_type(self.tcx, did);\n+                            let generics = ty::lookup_item_type(self.tcx, did).generics;\n \n                             let expected =\n                                 generics.regions.len(subst::TypeSpace);\n@@ -1266,85 +1266,77 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 anon_nums: anon_nums,\n                                 region_names: region_names\n                             };\n-                            new_ty = self.rebuild_ty(new_ty, cur_ty,\n-                                                     lifetime,\n-                                                     Some(rebuild_info));\n+                            let new_path = self.rebuild_path(rebuild_info, lifetime);\n+                            let to = ast::Ty {\n+                                id: cur_ty.id,\n+                                node: ast::TyPath(new_path, bounds.clone(), id),\n+                                span: cur_ty.span\n+                            };\n+                            new_ty = self.rebuild_ty(new_ty, P(to));\n                         }\n                         _ => ()\n                     }\n \n                 }\n-                _ => ty_queue.push_all_move(ast_util::get_inner_tys(cur_ty))\n+\n+                ast::TyPtr(ref mut_ty) => {\n+                    ty_queue.push(&*mut_ty.ty);\n+                }\n+                ast::TyBox(ref ty) |\n+                ast::TyVec(ref ty) |\n+                ast::TyUniq(ref ty) |\n+                ast::TyFixedLengthVec(ref ty, _) => {\n+                    ty_queue.push(&**ty);\n+                }\n+                ast::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n+                _ => {}\n             }\n         }\n         new_ty\n     }\n \n     fn rebuild_ty(&self,\n-                  from: ast::P<ast::Ty>,\n-                  to: ast::P<ast::Ty>,\n-                  lifetime: ast::Lifetime,\n-                  rebuild_path_info: Option<RebuildPathInfo>)\n-                  -> ast::P<ast::Ty> {\n-\n-        fn build_to(from: ast::P<ast::Ty>,\n-                    to: ast::P<ast::Ty>)\n-                    -> ast::P<ast::Ty> {\n-            if from.id == to.id {\n-                return to;\n-            }\n-            let new_node = match from.node {\n-                ast::TyRptr(ref lifetime, ref mut_ty) => {\n-                    let new_mut_ty = ast::MutTy {\n-                        ty: build_to(mut_ty.ty, to),\n-                        mutbl: mut_ty.mutbl\n-                    };\n-                    ast::TyRptr(*lifetime, new_mut_ty)\n-                }\n-                ast::TyPtr(ref mut_ty) => {\n-                    let new_mut_ty = ast::MutTy {\n-                        ty: build_to(mut_ty.ty, to),\n-                        mutbl: mut_ty.mutbl\n-                    };\n-                    ast::TyPtr(new_mut_ty)\n-                }\n-                ast::TyBox(ref ty) => ast::TyBox(build_to(*ty, to)),\n-                ast::TyVec(ref ty) => ast::TyVec(build_to(*ty, to)),\n-                ast::TyUniq(ref ty) => ast::TyUniq(build_to(*ty, to)),\n-                ast::TyFixedLengthVec(ref ty, ref e) => {\n-                    ast::TyFixedLengthVec(build_to(*ty, to), *e)\n-                }\n-                ast::TyTup(ref tys) => {\n-                    let mut new_tys = Vec::new();\n-                    for ty in tys.iter() {\n-                        new_tys.push(build_to(*ty, to));\n+                  from: P<ast::Ty>,\n+                  to: P<ast::Ty>)\n+                  -> P<ast::Ty> {\n+\n+        fn build_to(from: P<ast::Ty>,\n+                    to: &mut Option<P<ast::Ty>>)\n+                    -> P<ast::Ty> {\n+            if Some(from.id) == to.as_ref().map(|ty| ty.id) {\n+                return to.take().expect(\"`to` type found more than once during rebuild\");\n+            }\n+            from.map(|ast::Ty {id, node, span}| {\n+                let new_node = match node {\n+                    ast::TyRptr(lifetime, mut_ty) => {\n+                        ast::TyRptr(lifetime, ast::MutTy {\n+                            mutbl: mut_ty.mutbl,\n+                            ty: build_to(mut_ty.ty, to),\n+                        })\n                     }\n-                    ast::TyTup(new_tys)\n-                }\n-                ast::TyParen(ref typ) => ast::TyParen(build_to(*typ, to)),\n-                ref other => other.clone()\n-            };\n-            box(GC) ast::Ty { id: from.id, node: new_node, span: from.span }\n+                    ast::TyPtr(mut_ty) => {\n+                        ast::TyPtr(ast::MutTy {\n+                            mutbl: mut_ty.mutbl,\n+                            ty: build_to(mut_ty.ty, to),\n+                        })\n+                    }\n+                    ast::TyBox(ty) => ast::TyBox(build_to(ty, to)),\n+                    ast::TyVec(ty) => ast::TyVec(build_to(ty, to)),\n+                    ast::TyUniq(ty) => ast::TyUniq(build_to(ty, to)),\n+                    ast::TyFixedLengthVec(ty, e) => {\n+                        ast::TyFixedLengthVec(build_to(ty, to), e)\n+                    }\n+                    ast::TyTup(tys) => {\n+                        ast::TyTup(tys.move_iter().map(|ty| build_to(ty, to)).collect())\n+                    }\n+                    ast::TyParen(typ) => ast::TyParen(build_to(typ, to)),\n+                    other => other\n+                };\n+                ast::Ty { id: id, node: new_node, span: span }\n+            })\n         }\n \n-        let new_ty_node = match to.node {\n-            ast::TyRptr(_, mut_ty) => ast::TyRptr(Some(lifetime), mut_ty),\n-            ast::TyPath(_, ref bounds, id) => {\n-                let rebuild_info = match rebuild_path_info {\n-                    Some(ri) => ri,\n-                    None => fail!(\"expect index_opt in rebuild_ty/ast::TyPath\")\n-                };\n-                let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                ast::TyPath(new_path, bounds.clone(), id)\n-            }\n-            _ => fail!(\"expect ast::TyRptr or ast::TyPath\")\n-        };\n-        let new_ty = box(GC) ast::Ty {\n-            id: to.id,\n-            node: new_ty_node,\n-            span: to.span\n-        };\n-        build_to(from, new_ty)\n+        build_to(from, &mut Some(to))\n     }\n \n     fn rebuild_path(&self,\n@@ -1384,8 +1376,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 }\n             }\n         }\n-        let new_types = last_seg.types.map(|&t| {\n-            self.rebuild_arg_ty_or_output(t, lifetime, anon_nums, region_names)\n+        let new_types = last_seg.types.map(|t| {\n+            self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n         });\n         let new_seg = ast::PathSegment {\n             identifier: last_seg.identifier,\n@@ -1408,7 +1400,7 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                                 decl: &ast::FnDecl,\n                                 fn_style: ast::FnStyle,\n                                 ident: ast::Ident,\n-                                opt_explicit_self: Option<ast::ExplicitSelf_>,\n+                                opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n                                 span: codemap::Span) {\n         let suggested_fn = pprust::fun_to_string(decl, fn_style, ident,\n@@ -1686,7 +1678,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n-                    ast::MethodImplItem(m) => {\n+                    ast::MethodImplItem(ref m) => {\n                         taken.push_all(m.pe_generics().lifetimes.as_slice());\n                         Some(m.id)\n                     }"}, {"sha": "c0236cefca3f9ec88beca937cf724d2dccb64317", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -36,13 +36,12 @@ use middle::typeck::infer::glb::Glb;\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note};\n-use syntax::ast;\n+use syntax::{ast, ast_map};\n use util::ppaux::{ty_to_string, UserString};\n \n use arena::TypedArena;\n \n struct Env<'a, 'tcx: 'a> {\n-    krate: ast::Crate,\n     infcx: &'a infer::InferCtxt<'a, 'tcx>,\n }\n \n@@ -117,19 +116,22 @@ fn test_env(_test_name: &str,\n     let krate_config = Vec::new();\n     let input = driver::StrInput(source_string.to_string());\n     let krate = driver::phase_1_parse_input(&sess, krate_config, &input);\n-    let (krate, ast_map) =\n-        driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n-            .expect(\"phase 2 aborted\");\n+    let krate = driver::phase_2_configure_and_expand(&sess, krate, \"test\", None)\n+                    .expect(\"phase 2 aborted\");\n+\n+    let mut forest = ast_map::Forest::new(krate);\n+    let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n+    let krate = ast_map.krate();\n \n     // run just enough stuff to build a tcx:\n-    let lang_items = lang_items::collect_language_items(&krate, &sess);\n+    let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map: def_map, .. } =\n-        resolve::resolve_crate(&sess, &lang_items, &krate);\n+        resolve::resolve_crate(&sess, &lang_items, krate);\n     let (freevars_map, captures_map) = freevars::annotate_freevars(&def_map,\n-                                                                   &krate);\n-    let named_region_map = resolve_lifetime::krate(&sess, &krate);\n-    let region_map = region::resolve_crate(&sess, &krate);\n-    let stability_index = stability::Index::build(&krate);\n+                                                                   krate);\n+    let named_region_map = resolve_lifetime::krate(&sess, krate);\n+    let region_map = region::resolve_crate(&sess, krate);\n+    let stability_index = stability::Index::build(krate);\n     let type_arena = TypedArena::new();\n     let tcx = ty::mk_ctxt(sess,\n                           &type_arena,\n@@ -142,11 +144,7 @@ fn test_env(_test_name: &str,\n                           lang_items,\n                           stability_index);\n     let infcx = infer::new_infer_ctxt(&tcx);\n-    let env = Env {\n-        krate: krate,\n-        infcx: &infcx\n-    };\n-    body(env);\n+    body(Env { infcx: &infcx });\n     infcx.resolve_regions_and_report_errors();\n     assert_eq!(tcx.sess.err_count(), expected_err_count);\n }\n@@ -171,7 +169,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n-        return match search_mod(self, &self.krate.module, 0, names) {\n+        return match search_mod(self, &self.infcx.tcx.map.krate().module, 0, names) {\n             Some(id) => id,\n             None => {\n                 fail!(\"no item found: `{}`\", names.connect(\"::\"));"}, {"sha": "e59f1aa3ce4c13780918b407310b73bc9ba0f4e8", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -308,7 +308,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n }\n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().find(&id) {\n-        Some(&x) => x,\n+        Some(x) => x.clone(),\n         _ => {\n             tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n         }\n@@ -474,30 +474,28 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   trait_map: resolve::TraitMap,\n-                   krate: &ast::Crate) {\n+pub fn check_crate(tcx: &ty::ctxt, trait_map: resolve::TraitMap) {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,\n         tcx: tcx\n     };\n \n     time(time_passes, \"type collecting\", (), |_|\n-        collect::collect_item_types(&ccx, krate));\n+        collect::collect_item_types(&ccx));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.abort_if_errors();\n \n     time(time_passes, \"variance inference\", (), |_|\n-         variance::infer_variance(tcx, krate));\n+         variance::infer_variance(tcx));\n \n     time(time_passes, \"coherence checking\", (), |_|\n-        coherence::check_coherence(&ccx, krate));\n+        coherence::check_coherence(&ccx));\n \n     time(time_passes, \"type checking\", (), |_|\n-        check::check_item_types(&ccx, krate));\n+        check::check_item_types(&ccx));\n \n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();"}, {"sha": "547fbce573bccf67636e81ba01f513f2a14e2e9f", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -208,8 +208,8 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::ppaux::Repr;\n \n-pub fn infer_variance(tcx: &ty::ctxt,\n-                      krate: &ast::Crate) {\n+pub fn infer_variance(tcx: &ty::ctxt) {\n+    let krate = tcx.map.krate();\n     let mut arena = arena::Arena::new();\n     let terms_cx = determine_parameters_to_be_inferred(tcx, &mut arena, krate);\n     let constraints_cx = add_constraints_from_crate(terms_cx, krate);"}, {"sha": "c39f011189a605392e235ab77a1c694c93516445", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'v> Visitor<'v> for BlockQueryVisitor<'a> {\n \n // Takes a predicate p, returns true iff p is true for any subexpressions\n // of b -- skipping any inner loops (loop, while, loop_body)\n-pub fn block_query(b: ast::P<ast::Block>, p: |&ast::Expr| -> bool) -> bool {\n+pub fn block_query(b: &ast::Block, p: |&ast::Expr| -> bool) -> bool {\n     let mut v = BlockQueryVisitor {\n         p: p,\n         flag: false,"}, {"sha": "ba1f7ca2cb2314dc7dc1749ff4a0a1ef174f3dd2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -27,7 +27,6 @@ use middle::typeck;\n use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n \n-use std::gc::Gc;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -546,9 +545,9 @@ impl<T:Repr> Repr for Rc<T> {\n     }\n }\n \n-impl<T:Repr + 'static> Repr for Gc<T> {\n+impl<'a, T:Repr> Repr for &'a T {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        (&**self).repr(tcx)\n+        (*self).repr(tcx)\n     }\n }\n \n@@ -822,21 +821,19 @@ impl Repr for ast::DefId {\n         // a path for a def-id, so I'll just make a best effort for now\n         // and otherwise fallback to just printing the crate/node pair\n         if self.krate == ast::LOCAL_CRATE {\n-            {\n-                match tcx.map.find(self.node) {\n-                    Some(ast_map::NodeItem(..)) |\n-                    Some(ast_map::NodeForeignItem(..)) |\n-                    Some(ast_map::NodeImplItem(..)) |\n-                    Some(ast_map::NodeTraitItem(..)) |\n-                    Some(ast_map::NodeVariant(..)) |\n-                    Some(ast_map::NodeStructCtor(..)) => {\n-                        return format!(\n+            match tcx.map.find(self.node) {\n+                Some(ast_map::NodeItem(..)) |\n+                Some(ast_map::NodeForeignItem(..)) |\n+                Some(ast_map::NodeImplItem(..)) |\n+                Some(ast_map::NodeTraitItem(..)) |\n+                Some(ast_map::NodeVariant(..)) |\n+                Some(ast_map::NodeStructCtor(..)) => {\n+                    return format!(\n                                 \"{:?}:{}\",\n                                 *self,\n                                 ty::item_path_str(tcx, *self))\n-                    }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n         return format!(\"{:?}\", *self)"}, {"sha": "415141c0b94004b918e9fd091484c027b383a40e", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b06212864f77d87779656379b3773c1096dbf9e1/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=b06212864f77d87779656379b3773c1096dbf9e1", "patch": "@@ -264,7 +264,7 @@ mod svh_visitor {\n             ExprTup(..)              => SawExprTup,\n             ExprBinary(op, _, _)     => SawExprBinary(op),\n             ExprUnary(op, _)         => SawExprUnary(op),\n-            ExprLit(lit)             => SawExprLit(lit.node.clone()),\n+            ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n             ExprCast(..)             => SawExprCast,\n             ExprIf(..)               => SawExprIf,\n             ExprWhile(..)            => SawExprWhile,"}]}