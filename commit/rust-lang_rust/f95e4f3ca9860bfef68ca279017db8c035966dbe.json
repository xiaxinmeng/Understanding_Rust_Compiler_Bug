{"sha": "f95e4f3ca9860bfef68ca279017db8c035966dbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NWU0ZjNjYTk4NjBiZmVmNjhjYTI3OTAxN2RiOGMwMzU5NjZkYmU=", "commit": {"author": {"name": "Ishi Tatsuyuki", "email": "ishitatsuyuki@gmail.com", "date": "2020-09-21T11:29:12Z"}, "committer": {"name": "Ishi Tatsuyuki", "email": "ishitatsuyuki@gmail.com", "date": "2020-09-21T11:29:12Z"}, "message": "Improve code and documentation clarity", "tree": {"sha": "c466c7833100b4a19b3b0554b9f88ce2c8433e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c466c7833100b4a19b3b0554b9f88ce2c8433e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f95e4f3ca9860bfef68ca279017db8c035966dbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f95e4f3ca9860bfef68ca279017db8c035966dbe", "html_url": "https://github.com/rust-lang/rust/commit/f95e4f3ca9860bfef68ca279017db8c035966dbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f95e4f3ca9860bfef68ca279017db8c035966dbe/comments", "author": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c98f6f58440d80f6116e4d060778ab0a9b98131", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c98f6f58440d80f6116e4d060778ab0a9b98131", "html_url": "https://github.com/rust-lang/rust/commit/7c98f6f58440d80f6116e4d060778ab0a9b98131"}], "stats": {"total": 116, "additions": 75, "deletions": 41}, "files": [{"sha": "ff14ffc2a11bdbd8b9c08efa00585272e9f72702", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f95e4f3ca9860bfef68ca279017db8c035966dbe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95e4f3ca9860bfef68ca279017db8c035966dbe/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=f95e4f3ca9860bfef68ca279017db8c035966dbe", "patch": "@@ -139,10 +139,10 @@\n //!\n //!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n //!    and we have three cases:\n-//!         1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!         1.2. `p_1 = _`. We return the rest of the stack:\n+//!         2.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n+//!         2.2. `p_1 = _`. We return the rest of the stack:\n //!                 p_2, .., p_n\n-//!         1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n+//!         2.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting\n //!           stack.\n //!                 D((r_1, p_2, .., p_n))\n //!                 D((r_2, p_2, .., p_n))\n@@ -509,6 +509,14 @@ impl<'p, 'tcx> FromIterator<&'p Pat<'tcx>> for PatStack<'p, 'tcx> {\n #[derive(Clone, Debug)]\n enum SpecializationCache {\n     /// Patterns consist of only enum variants.\n+    /// Variant patterns does not intersect with each other (in contrast to range patterns),\n+    /// so it is possible to precompute the result of `Matrix::specialize_constructor` at a\n+    /// lower computational complexity.\n+    /// `lookup` is responsible for holding the precomputed result of\n+    /// `Matrix::specialize_constructor`, while `wilds` is used for two purposes: the first one is\n+    /// the precomputed result of `Matrix::specialize_wildcard`, and the second is to be used as a\n+    /// fallback for `Matrix::specialize_constructor` when it tries to apply a constructor that\n+    /// has not been seen in the `Matrix`. See `update_cache` for further explanations.\n     Variants { lookup: FxHashMap<DefId, SmallVec<[usize; 1]>>, wilds: SmallVec<[usize; 1]> },\n     /// Does not belong to the cases above, use the slow path.\n     Incompatible,\n@@ -523,7 +531,8 @@ crate struct Matrix<'p, 'tcx> {\n \n impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     crate fn empty() -> Self {\n-        // Use SpecializationCache::Incompatible as a placeholder; the initialization is in push().\n+        // Use `SpecializationCache::Incompatible` as a placeholder; we will initialize it on the\n+        // first call to `push`. See the first half of `update_cache`.\n         Matrix { patterns: vec![], cache: SpecializationCache::Incompatible }\n     }\n \n@@ -536,47 +545,71 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                 self.push(row)\n             }\n         } else {\n-            if self.patterns.is_empty() {\n-                self.cache = if row.is_empty() {\n-                    SpecializationCache::Incompatible\n-                } else {\n-                    match *row.head().kind {\n-                        PatKind::Variant { .. } => SpecializationCache::Variants {\n-                            lookup: FxHashMap::default(),\n-                            wilds: SmallVec::new(),\n-                        },\n-                        // Note: If the first pattern is a wildcard, then all patterns after that is not\n-                        // useful. The check is simple enough so we treat it as the same as unsupported\n-                        // patterns.\n-                        _ => SpecializationCache::Incompatible,\n-                    }\n-                };\n-            }\n-            let idx_to_insert = self.patterns.len();\n-            match &mut self.cache {\n-                SpecializationCache::Variants { ref mut lookup, ref mut wilds } => {\n-                    let head = row.head();\n-                    match *head.kind {\n-                        _ if head.is_wildcard() => {\n-                            for (_, v) in lookup.iter_mut() {\n-                                v.push(idx_to_insert);\n-                            }\n-                            wilds.push(idx_to_insert);\n-                        }\n-                        PatKind::Variant { adt_def, variant_index, .. } => {\n-                            lookup\n-                                .entry(adt_def.variants[variant_index].def_id)\n-                                .or_insert_with(|| wilds.clone())\n-                                .push(idx_to_insert);\n-                        }\n-                        _ => {\n-                            self.cache = SpecializationCache::Incompatible;\n+            self.patterns.push(row);\n+            self.update_cache(self.patterns.len() - 1);\n+        }\n+    }\n+\n+    fn update_cache(&mut self, idx: usize) {\n+        let row = &self.patterns[idx];\n+        // We don't know which kind of cache could be used until we see the first row; therefore an\n+        // empty `Matrix` is initialized with `SpecializationCache::Empty`, then the cache is\n+        // assigned the appropriate variant below on the first call to `push`.\n+        if self.patterns.is_empty() {\n+            self.cache = if row.is_empty() {\n+                SpecializationCache::Incompatible\n+            } else {\n+                match *row.head().kind {\n+                    PatKind::Variant { .. } => SpecializationCache::Variants {\n+                        lookup: FxHashMap::default(),\n+                        wilds: SmallVec::new(),\n+                    },\n+                    // Note: If the first pattern is a wildcard, then all patterns after that is not\n+                    // useful. The check is simple enough so we treat it as the same as unsupported\n+                    // patterns.\n+                    _ => SpecializationCache::Incompatible,\n+                }\n+            };\n+        }\n+        // Update the cache.\n+        match &mut self.cache {\n+            SpecializationCache::Variants { ref mut lookup, ref mut wilds } => {\n+                let head = row.head();\n+                match *head.kind {\n+                    _ if head.is_wildcard() => {\n+                        // Per rule 1.3 in the top-level comments, a wildcard pattern is included in\n+                        // the result of `specialize_constructor` for *any* `Constructor`.\n+                        // We push the wildcard pattern to the precomputed result for constructors\n+                        // that we have seen before; results for constructors we have not yet seen\n+                        // defaults to `wilds`, which is updated right below.\n+                        for (_, v) in lookup.iter_mut() {\n+                            v.push(idx);\n                         }\n+                        // Per rule 2.1 and 2.2 in the top-level comments, only wildcard patterns\n+                        // are included in the result of `specialize_wildcard`.\n+                        // What we do here is to track the wildcards we have seen; so in addition to\n+                        // acting as the precomputed result of `specialize_wildcard`, `wilds` also\n+                        // serves as the default value of `specialize_constructor` for constructors\n+                        // that are not in `lookup`.\n+                        wilds.push(idx);\n+                    }\n+                    PatKind::Variant { adt_def, variant_index, .. } => {\n+                        // Handle the cases of rule 1.1 and 1.2 in the top-level comments.\n+                        // A variant pattern can only be included in the results of\n+                        // `specialize_constructor` for a particular constructor, therefore we are\n+                        // using a HashMap to track that.\n+                        lookup\n+                            .entry(adt_def.variants[variant_index].def_id)\n+                            // Default to `wilds` for absent keys. See above for an explanation.\n+                            .or_insert_with(|| wilds.clone())\n+                            .push(idx);\n+                    }\n+                    _ => {\n+                        self.cache = SpecializationCache::Incompatible;\n                     }\n                 }\n-                SpecializationCache::Incompatible => {}\n             }\n-            self.patterns.push(row);\n+            SpecializationCache::Incompatible => {}\n         }\n     }\n \n@@ -609,6 +642,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                 if let Constructor::Variant(id) = constructor {\n                     lookup\n                         .get(id)\n+                        // Default to `wilds` for absent keys. See `update_cache` for an explanation.\n                         .unwrap_or(&wilds)\n                         .iter()\n                         .filter_map(|&i| {"}]}