{"sha": "79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5ZjZmMTE4MTZjYmVmMmJiYTZmNWRhNmQ0YTRmMGFhMTA1MzViODg=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-02-12T22:41:00Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2021-02-13T19:30:07Z"}, "message": "Remove some unnecessary `trait_ref` calls", "tree": {"sha": "7a135d483d8f0ab00edebae2d8eeffd61764b826", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a135d483d8f0ab00edebae2d8eeffd61764b826"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "html_url": "https://github.com/rust-lang/rust/commit/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9526c0c6e83f37deb1d48e9761ee9bee2ae94f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/9526c0c6e83f37deb1d48e9761ee9bee2ae94f60", "html_url": "https://github.com/rust-lang/rust/commit/9526c0c6e83f37deb1d48e9761ee9bee2ae94f60"}], "stats": {"total": 55, "additions": 35, "deletions": 20}, "files": [{"sha": "0c340b2faaa479cf2c975e037557f282ea8b3fa5", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "patch": "@@ -77,6 +77,12 @@ trait DefIdVisitor<'tcx> {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> ControlFlow<Self::BreakTy> {\n         self.skeleton().visit_trait(trait_ref)\n     }\n+    fn visit_projection_ty(\n+        &mut self,\n+        projection: ty::ProjectionTy<'tcx>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.skeleton().visit_projection_ty(projection)\n+    }\n     fn visit_predicates(\n         &mut self,\n         predicates: ty::GenericPredicates<'tcx>,\n@@ -101,14 +107,28 @@ where\n         if self.def_id_visitor.shallow() { ControlFlow::CONTINUE } else { substs.visit_with(self) }\n     }\n \n+    fn visit_projection_ty(\n+        &mut self,\n+        projection: ty::ProjectionTy<'tcx>,\n+    ) -> ControlFlow<V::BreakTy> {\n+        let (trait_ref, assoc_substs) =\n+            projection.trait_ref_and_own_substs(self.def_id_visitor.tcx());\n+        self.visit_trait(trait_ref)?;\n+        if self.def_id_visitor.shallow() {\n+            ControlFlow::CONTINUE\n+        } else {\n+            assoc_substs.iter().try_for_each(|subst| subst.visit_with(self))\n+        }\n+    }\n+\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n         match predicate.kind().skip_binder() {\n             ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n             ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 ty.visit_with(self)?;\n-                self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+                self.visit_projection_ty(projection_ty)\n             }\n             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n@@ -197,7 +217,7 @@ where\n                     return ControlFlow::CONTINUE;\n                 }\n                 // This will also visit substs if necessary, so we don't need to recurse.\n-                return self.visit_trait(proj.trait_ref(tcx));\n+                return self.visit_projection_ty(proj);\n             }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n@@ -1204,10 +1224,9 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             }\n \n             for (poly_predicate, _) in bounds.projection_bounds {\n-                let tcx = self.tcx;\n                 if self.visit(poly_predicate.skip_binder().ty).is_break()\n                     || self\n-                        .visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                        .visit_projection_ty(poly_predicate.skip_binder().projection_ty)\n                         .is_break()\n                 {\n                     return;"}, {"sha": "f3bbf9016835e3b057e673c98053250df2127ab3", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "patch": "@@ -6,6 +6,7 @@ use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::{self, Binder, Const, Ty, TypeFoldable};\n use std::marker::PhantomData;\n@@ -633,9 +634,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // only reason we can fail to make progress on\n                 // trait selection is because we don't have enough\n                 // information about the types in the trait.\n-                *stalled_on = trait_ref_infer_vars(\n+                *stalled_on = substs_infer_vars(\n                     self.selcx,\n-                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref),\n+                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref.substs),\n                 );\n \n                 debug!(\n@@ -663,9 +664,9 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n             Ok(Ok(Some(os))) => ProcessResult::Changed(mk_pending(os)),\n             Ok(Ok(None)) => {\n-                *stalled_on = trait_ref_infer_vars(\n+                *stalled_on = substs_infer_vars(\n                     self.selcx,\n-                    project_obligation.predicate.to_poly_trait_ref(tcx),\n+                    project_obligation.predicate.map_bound(|pred| pred.projection_ty.substs),\n                 );\n                 ProcessResult::Unchanged\n             }\n@@ -678,16 +679,15 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-/// Returns the set of inference variables contained in a trait ref.\n-fn trait_ref_infer_vars<'a, 'tcx>(\n+/// Returns the set of inference variables contained in `substs`.\n+fn substs_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n+    substs: ty::Binder<SubstsRef<'tcx>>,\n ) -> Vec<TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()\n-        .resolve_vars_if_possible(trait_ref)\n-        .skip_binder()\n-        .substs\n+        .resolve_vars_if_possible(substs)\n+        .skip_binder() // ok because this check doesn't care about regions\n         .iter()\n         // FIXME(eddyb) try using `skip_current_subtree` to skip everything that\n         // doesn't contain inference variables, not just the outermost level."}, {"sha": "7de20e477fe0479769be5d14a9ecdaf44c00d2f0", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "patch": "@@ -292,11 +292,7 @@ fn predicate_references_self(\n             //\n             // This is ALT2 in issue #56288, see that for discussion of the\n             // possible alternatives.\n-            if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n-                Some(sp)\n-            } else {\n-                None\n-            }\n+            if data.projection_ty.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)"}, {"sha": "529de1a2874841b6055b333fb6f2a240cc0a163f", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79f6f11816cbef2bba6f5da6d4a4f0aa10535b88/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=79f6f11816cbef2bba6f5da6d4a4f0aa10535b88", "patch": "@@ -198,7 +198,7 @@ pub fn setup_constraining_predicates<'tcx>(\n                 //     `<<T as Bar>::Baz as Iterator>::Output = <U as Iterator>::Output`\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n-                let inputs = parameters_for(&projection.projection_ty.trait_ref(tcx), true);\n+                let inputs = parameters_for(&projection.projection_ty, true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;"}]}