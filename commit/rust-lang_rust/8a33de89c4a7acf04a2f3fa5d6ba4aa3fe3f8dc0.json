{"sha": "8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMzNkZTg5YzRhN2FjZjA0YTJmM2ZhNWQ2YmE0YWEzZmUzZjhkYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-20T16:12:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-20T16:12:37Z"}, "message": "auto merge of #20073 : nikomatsakis/rust/generalized-where-clause-parser, r=nikomatsakis\n\nThis is the same branch as #20002 but with the pretty-printing test fixed.", "tree": {"sha": "f9a55b4c52e9051f3742da588b500d1b34ba398d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a55b4c52e9051f3742da588b500d1b34ba398d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "html_url": "https://github.com/rust-lang/rust/commit/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8f2c7a9537c7f333b242f616aefb75a83860927", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f2c7a9537c7f333b242f616aefb75a83860927", "html_url": "https://github.com/rust-lang/rust/commit/f8f2c7a9537c7f333b242f616aefb75a83860927"}, {"sha": "acd31db22938968929913b54779cb33a3c2e03df", "url": "https://api.github.com/repos/rust-lang/rust/commits/acd31db22938968929913b54779cb33a3c2e03df", "html_url": "https://github.com/rust-lang/rust/commit/acd31db22938968929913b54779cb33a3c2e03df"}], "stats": {"total": 711, "additions": 561, "deletions": 150}, "files": [{"sha": "7c931700f8302dbd3df94804e8b51ad0bfd402e8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -1505,6 +1505,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                         self.check_ty_param_bound(bound_pred.span, bound)\n                     }\n                 }\n+                &ast::WherePredicate::RegionPredicate(_) => {}\n                 &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                     self.visit_ty(&*eq_pred.ty);\n                 }"}, {"sha": "be191801626a8495e6de39c48304ac2a75123318", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -206,13 +206,21 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ident,\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ ref bounded_ty,\n                                                                                ref bounds,\n-                                                                               span,\n                                                                                .. }) => {\n-                    self.visit_ident(span, ident);\n+                    self.visit_ty(&**bounded_ty);\n                     visit::walk_ty_param_bounds_helper(self, bounds);\n                 }\n+                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                                ref bounds,\n+                                                                                .. }) => {\n+\n+                    self.visit_lifetime_ref(lifetime);\n+                    for bound in bounds.iter() {\n+                        self.visit_lifetime_ref(bound);\n+                    }\n+                }\n                 &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ id,\n                                                                          ref path,\n                                                                          ref ty,\n@@ -545,9 +553,21 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounds, ..}) => {\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounds,\n+                                                                              ref bounded_ty,\n+                                                                              ..}) => {\n+                    collector.visit_ty(&**bounded_ty);\n                     visit::walk_ty_param_bounds_helper(&mut collector, bounds);\n                 }\n+                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                                ref bounds,\n+                                                                                ..}) => {\n+                    collector.visit_lifetime_ref(lifetime);\n+\n+                    for bound in bounds.iter() {\n+                        collector.visit_lifetime_ref(bound);\n+                    }\n+                }\n                 &ast::WherePredicate::EqPredicate(_) => unimplemented!()\n             }\n         }"}, {"sha": "99f0a6cdfc3cfca7346433ae8abba0777b536772", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -4360,27 +4360,14 @@ impl<'a> Resolver<'a> {\n         for predicate in where_clause.predicates.iter() {\n             match predicate {\n                 &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                    match self.resolve_identifier(bound_pred.ident,\n-                                                  TypeNS,\n-                                                  true,\n-                                                  bound_pred.span) {\n-                        Some((def @ DefTyParam(..), last_private)) => {\n-                            self.record_def(bound_pred.id, (def, last_private));\n-                        }\n-                        _ => {\n-                            self.resolve_error(\n-                                bound_pred.span,\n-                                format!(\"undeclared type parameter `{}`\",\n-                                        token::get_ident(\n-                                            bound_pred.ident)).as_slice());\n-                        }\n-                    }\n+                    self.resolve_type(&*bound_pred.bounded_ty);\n \n                     for bound in bound_pred.bounds.iter() {\n-                        self.resolve_type_parameter_bound(bound_pred.id, bound,\n+                        self.resolve_type_parameter_bound(bound_pred.bounded_ty.id, bound,\n                                                           TraitBoundingTypeParameter);\n                     }\n                 }\n+                &ast::WherePredicate::RegionPredicate(_) => {}\n                 &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n                     match self.resolve_path(eq_pred.id, &eq_pred.path, TypeNS, true) {\n                         Some((def @ DefTyParam(..), last_private)) => {"}, {"sha": "175763c874efa4e70733f461408f1ba1efb40949", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -1437,11 +1437,8 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n-    let ast_bound_refs: Vec<&ast::TyParamBound> =\n-        ast_bounds.iter().collect();\n-\n     let partitioned_bounds =\n-        partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n+        partition_bounds(this.tcx(), span, ast_bounds);\n \n     conv_existential_bounds_from_partitioned_bounds(\n         this, rscope, span, principal_trait_ref, partitioned_bounds)\n@@ -1455,7 +1452,6 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     -> Ty<'tcx>\n     where AC: AstConv<'tcx>, RS:RegionScope\n {\n-    let ast_bounds: Vec<&ast::TyParamBound> = ast_bounds.iter().collect();\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n@@ -1620,14 +1616,14 @@ pub struct PartitionedBounds<'a> {\n /// general trait bounds, and region bounds.\n pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                             _span: Span,\n-                            ast_bounds: &'a [&ast::TyParamBound])\n+                            ast_bounds: &'a [ast::TyParamBound])\n                             -> PartitionedBounds<'a>\n {\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n     let mut trait_def_ids = DefIdMap::new();\n-    for &ast_bound in ast_bounds.iter() {\n+    for ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n                 match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {"}, {"sha": "3f59b50337faf144bee74bc8388c1ceb7d7d7304", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -1364,8 +1364,7 @@ pub fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 self_param_ty,\n                                 bounds.as_slice(),\n                                 unbound,\n-                                it.span,\n-                                &generics.where_clause);\n+                                it.span);\n \n     let substs = mk_item_substs(ccx, &ty_generics);\n     let trait_def = Rc::new(ty::TraitDef {\n@@ -1619,7 +1618,6 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         subst::AssocSpace,\n                         &associated_type.ty_param,\n                         generics.types.len(subst::AssocSpace),\n-                        &ast_generics.where_clause,\n                         Some(local_def(trait_id)));\n                 ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n                                                           def.clone());\n@@ -1774,7 +1772,6 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                                                    space,\n                                                    param,\n                                                    i,\n-                                                   where_clause,\n                                                    None);\n         debug!(\"ty_generics: def for type param: {}, {}\",\n                def.repr(this.tcx()),\n@@ -1798,6 +1795,54 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     // into the predicates list. This is currently kind of non-DRY.\n     create_predicates(this.tcx(), &mut result, space);\n \n+    // Add the bounds not associated with a type parameter\n+    for predicate in where_clause.predicates.iter() {\n+        match predicate {\n+            &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                let ty = ast_ty_to_ty(this, &ExplicitRscope, &*bound_pred.bounded_ty);\n+\n+                for bound in bound_pred.bounds.iter() {\n+                    match bound {\n+                        &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref) => {\n+                            let trait_ref = astconv::instantiate_poly_trait_ref(\n+                                this,\n+                                &ExplicitRscope,\n+                                //@jroesch: for now trait_ref, poly_trait_ref?\n+                                poly_trait_ref,\n+                                Some(ty),\n+                                AllowEqConstraints::Allow\n+                            );\n+\n+                            result.predicates.push(space, ty::Predicate::Trait(trait_ref));\n+                        }\n+\n+                        &ast::TyParamBound::RegionTyParamBound(ref lifetime) => {\n+                            let region = ast_region_to_region(this.tcx(), lifetime);\n+                            let pred = ty::Binder(ty::OutlivesPredicate(ty, region));\n+                            result.predicates.push(space, ty::Predicate::TypeOutlives(pred))\n+                        }\n+                    }\n+                }\n+            }\n+\n+            &ast::WherePredicate::RegionPredicate(ref region_pred) => {\n+                let r1 = ast_region_to_region(this.tcx(), &region_pred.lifetime);\n+                for bound in region_pred.bounds.iter() {\n+                    let r2 = ast_region_to_region(this.tcx(), bound);\n+                    let pred = ty::Binder(ty::OutlivesPredicate(r1, r2));\n+                    result.predicates.push(space, ty::Predicate::RegionOutlives(pred))\n+                }\n+            }\n+\n+            &ast::WherePredicate::EqPredicate(ref eq_pred) => {\n+                // FIXME(#20041)\n+                this.tcx().sess.span_bug(eq_pred.span,\n+                                         \"Equality constraints are not yet \\\n+                                            implemented (#20041)\")\n+            }\n+        }\n+    }\n+\n     return result;\n \n     fn create_type_parameters_for_associated_types<'tcx, AC>(\n@@ -1915,7 +1960,6 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              space: subst::ParamSpace,\n                                              param: &ast::TyParam,\n                                              index: uint,\n-                                             where_clause: &ast::WhereClause,\n                                              associated_with: Option<ast::DefId>)\n                                              -> ty::TypeParameterDef<'tcx>\n     where AC: AstConv<'tcx>\n@@ -1931,8 +1975,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                 param_ty,\n                                 param.bounds.as_slice(),\n                                 &param.unbound,\n-                                param.span,\n-                                where_clause);\n+                                param.span);\n     let default = match param.default {\n         None => None,\n         Some(ref path) => {\n@@ -1977,15 +2020,13 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                            param_ty: ty::ParamTy,\n                            ast_bounds: &[ast::TyParamBound],\n                            unbound: &Option<ast::TraitRef>,\n-                           span: Span,\n-                           where_clause: &ast::WhereClause)\n+                           span: Span)\n                            -> ty::ParamBounds<'tcx>\n                            where AC: AstConv<'tcx> {\n     let mut param_bounds = conv_param_bounds(this,\n                                              span,\n                                              param_ty,\n-                                             ast_bounds,\n-                                             where_clause);\n+                                             ast_bounds);\n \n \n     add_unsized_bound(this,\n@@ -2031,16 +2072,14 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn conv_param_bounds<'tcx,AC>(this: &AC,\n                               span: Span,\n                               param_ty: ty::ParamTy,\n-                              ast_bounds: &[ast::TyParamBound],\n-                              where_clause: &ast::WhereClause)\n+                              ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n-                              where AC: AstConv<'tcx> {\n-    let all_bounds =\n-        merge_param_bounds(this.tcx(), param_ty, ast_bounds, where_clause);\n+                              where AC: AstConv<'tcx>\n+{\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n                                      region_bounds } =\n-        astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n+        astconv::partition_bounds(this.tcx(), span, ast_bounds.as_slice());\n     let trait_bounds: Vec<Rc<ty::PolyTraitRef>> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n@@ -2062,43 +2101,6 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n     }\n }\n \n-/// Merges the bounds declared on a type parameter with those found from where clauses into a\n-/// single list.\n-fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n-                          param_ty: ty::ParamTy,\n-                          ast_bounds: &'a [ast::TyParamBound],\n-                          where_clause: &'a ast::WhereClause)\n-                          -> Vec<&'a ast::TyParamBound> {\n-    let mut result = Vec::new();\n-\n-    for ast_bound in ast_bounds.iter() {\n-        result.push(ast_bound);\n-    }\n-\n-    for predicate in where_clause.predicates.iter() {\n-        match predicate {\n-            &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let predicate_param_id =\n-                    tcx.def_map\n-                       .borrow()\n-                       .get(&bound_pred.id)\n-                       .expect(\"merge_param_bounds(): resolve didn't resolve the \\\n-                                type parameter identifier in a `where` clause\")\n-                       .def_id();\n-                if param_ty.def_id != predicate_param_id {\n-                    continue\n-                }\n-                for bound in bound_pred.bounds.iter() {\n-                    result.push(bound);\n-                }\n-            }\n-            &ast::WherePredicate::EqPredicate(_) => panic!(\"not implemented\")\n-        }\n-    }\n-\n-    result\n-}\n-\n pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                        decl: &ast::FnDecl,\n                                        def_id: ast::DefId,"}, {"sha": "3e8bf9bd4fdfeaaf6f8da07f02e6d35d4c711a85", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -693,7 +693,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n \n #[deriving(Clone, Encodable, Decodable, PartialEq)]\n pub struct WherePredicate {\n-    pub name: String,\n+    pub ty: Type,\n     pub bounds: Vec<TyParamBound>\n }\n \n@@ -702,11 +702,12 @@ impl Clean<WherePredicate> for ast::WherePredicate {\n         match *self {\n             ast::WherePredicate::BoundPredicate(ref wbp) => {\n                 WherePredicate {\n-                    name: wbp.ident.clean(cx),\n+                    ty: wbp.bounded_ty.clean(cx),\n                     bounds: wbp.bounds.clean(cx)\n                 }\n             }\n-            ast::WherePredicate::EqPredicate(_) => {\n+            // FIXME(#20048)\n+            _ => {\n                 unimplemented!();\n             }\n         }"}, {"sha": "e01cbbc812b8e1b15fb693be99df9092608f305f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -129,7 +129,7 @@ impl<'a> fmt::Show for WhereClause<'a> {\n                 try!(f.write(\", \".as_bytes()));\n             }\n             let bounds = pred.bounds.as_slice();\n-            try!(write!(f, \"{}: {}\", pred.name, TyParamBounds(bounds)));\n+            try!(write!(f, \"{}: {}\", pred.ty, TyParamBounds(bounds)));\n         }\n         Ok(())\n     }"}, {"sha": "440e11e385fe0e6403feffcc7fd409a14989bf53", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -415,17 +415,24 @@ pub struct WhereClause {\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum WherePredicate {\n     BoundPredicate(WhereBoundPredicate),\n+    RegionPredicate(WhereRegionPredicate),\n     EqPredicate(WhereEqPredicate)\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct WhereBoundPredicate {\n-    pub id: NodeId,\n     pub span: Span,\n-    pub ident: Ident,\n+    pub bounded_ty: P<Ty>,\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WhereRegionPredicate {\n+    pub span: Span,\n+    pub lifetime: Lifetime,\n+    pub bounds: Vec<Lifetime>,\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,"}, {"sha": "d8de3d2db9795c992cba98d3d8d68e7ffa0a65c8", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -426,12 +426,18 @@ impl<'a> TraitDef<'a> {\n             match *clause {\n                 ast::WherePredicate::BoundPredicate(ref wb) => {\n                     ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                        id: ast::DUMMY_NODE_ID,\n                         span: self.span,\n-                        ident: wb.ident,\n+                        bounded_ty: wb.bounded_ty.clone(),\n                         bounds: OwnedSlice::from_vec(wb.bounds.iter().map(|b| b.clone()).collect())\n                     })\n                 }\n+                ast::WherePredicate::RegionPredicate(ref rb) => {\n+                    ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                        span: self.span,\n+                        lifetime: rb.lifetime,\n+                        bounds: rb.bounds.iter().map(|b| b.clone()).collect()\n+                    })\n+                }\n                 ast::WherePredicate::EqPredicate(ref we) => {\n                     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         id: ast::DUMMY_NODE_ID,"}, {"sha": "86df588386464d33bb270d34839a8a0291b99436", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -814,17 +814,24 @@ pub fn noop_fold_where_predicate<T: Folder>(\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     match pred {\n-        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{id,\n-                                                                     ident,\n+        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{bounded_ty,\n                                                                      bounds,\n                                                                      span}) => {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                id: fld.new_id(id),\n-                ident: fld.fold_ident(ident),\n+                bounded_ty: fld.fold_ty(bounded_ty),\n                 bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n                 span: fld.new_span(span)\n             })\n         }\n+        ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{lifetime,\n+                                                                       bounds,\n+                                                                       span}) => {\n+            ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                span: fld.new_span(span),\n+                lifetime: fld.fold_lifetime(lifetime),\n+                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound))\n+            })\n+        }\n         ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n                                                                path,\n                                                                ty,"}, {"sha": "f8b47e0405f29c58a21c87bf079f7d98466f7091", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 71, "deletions": 49, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -1497,9 +1497,6 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a type.\n-    ///\n-    /// The second parameter specifies whether the `+` binary operator is\n-    /// allowed in the type grammar.\n     pub fn parse_ty(&mut self) -> P<Ty> {\n         maybe_whole!(no_clone self, NtTy);\n \n@@ -4179,6 +4176,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an optional `where` clause and places it in `generics`.\n+    ///\n+    /// ```\n+    /// where T : Trait<U, V> + 'b, 'a : 'b\n+    /// ```\n     fn parse_where_clause(&mut self, generics: &mut ast::Generics) {\n         if !self.eat_keyword(keywords::Where) {\n             return\n@@ -4187,58 +4188,79 @@ impl<'a> Parser<'a> {\n         let mut parsed_something = false;\n         loop {\n             let lo = self.span.lo;\n-            let path = match self.token {\n-                token::Ident(..) => self.parse_path(NoTypesAllowed),\n-                _ => break,\n-            };\n+            match self.token {\n+                token::OpenDelim(token::Brace) => {\n+                    break\n+                }\n \n-            if self.eat(&token::Colon) {\n-                let bounds = self.parse_ty_param_bounds();\n-                let hi = self.span.hi;\n-                let span = mk_sp(lo, hi);\n+                token::Lifetime(..) => {\n+                    let bounded_lifetime =\n+                        self.parse_lifetime();\n \n-                if bounds.len() == 0 {\n-                    self.span_err(span,\n-                                  \"each predicate in a `where` clause must have \\\n-                                   at least one bound in it\");\n+                    self.eat(&token::Colon);\n+\n+                    let bounds =\n+                        self.parse_lifetimes(token::BinOp(token::Plus));\n+\n+                    let hi = self.span.hi;\n+                    let span = mk_sp(lo, hi);\n+\n+                    generics.where_clause.predicates.push(ast::WherePredicate::RegionPredicate(\n+                        ast::WhereRegionPredicate {\n+                            span: span,\n+                            lifetime: bounded_lifetime,\n+                            bounds: bounds\n+                        }\n+                    ));\n+\n+                    parsed_something = true;\n                 }\n \n-                let ident = match ast_util::path_to_ident(&path) {\n-                    Some(ident) => ident,\n-                    None => {\n-                        self.span_err(path.span, \"expected a single identifier \\\n-                                                  in bound where clause\");\n-                        break;\n-                    }\n-                };\n+                _ => {\n+                    let bounded_ty = self.parse_ty();\n \n-                generics.where_clause.predicates.push(\n-                    ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: span,\n-                        ident: ident,\n-                        bounds: bounds,\n-                }));\n-                parsed_something = true;\n-            } else if self.eat(&token::Eq) {\n-                let ty = self.parse_ty();\n-                let hi = self.span.hi;\n-                let span = mk_sp(lo, hi);\n-                generics.where_clause.predicates.push(\n-                    ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: span,\n-                        path: path,\n-                        ty: ty,\n-                }));\n-                parsed_something = true;\n-                // FIXME(#18433)\n-                self.span_err(span, \"equality constraints are not yet supported in where clauses\");\n-            } else {\n-                let last_span = self.last_span;\n-                self.span_err(last_span,\n+                    if self.eat(&token::Colon) {\n+                        let bounds = self.parse_ty_param_bounds();\n+                        let hi = self.span.hi;\n+                        let span = mk_sp(lo, hi);\n+\n+                        if bounds.len() == 0 {\n+                            self.span_err(span,\n+                                          \"each predicate in a `where` clause must have \\\n+                                   at least one bound in it\");\n+                        }\n+\n+                        generics.where_clause.predicates.push(ast::WherePredicate::BoundPredicate(\n+                                ast::WhereBoundPredicate {\n+                                    span: span,\n+                                    bounded_ty: bounded_ty,\n+                                    bounds: bounds,\n+                        }));\n+\n+                        parsed_something = true;\n+                    } else if self.eat(&token::Eq) {\n+                        // let ty = self.parse_ty();\n+                        let hi = self.span.hi;\n+                        let span = mk_sp(lo, hi);\n+                        // generics.where_clause.predicates.push(\n+                        //     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n+                        //         id: ast::DUMMY_NODE_ID,\n+                        //         span: span,\n+                        //         path: panic!(\"NYI\"), //bounded_ty,\n+                        //         ty: ty,\n+                        // }));\n+                        // parsed_something = true;\n+                        // // FIXME(#18433)\n+                        self.span_err(span,\n+                                     \"equality constraints are not yet supported \\\n+                                     in where clauses (#20041)\");\n+                    } else {\n+                        let last_span = self.last_span;\n+                        self.span_err(last_span,\n                               \"unexpected token in `where` clause\");\n-            }\n+                    }\n+                }\n+            };\n \n             if !self.eat(&token::Comma) {\n                 break"}, {"sha": "f27a476dbdd7514c62054588334a6c932c64bdf1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -2437,12 +2437,26 @@ impl<'a> State<'a> {\n             }\n \n             match predicate {\n-                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ident,\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounded_ty,\n                                                                               ref bounds,\n                                                                               ..}) => {\n-                    try!(self.print_ident(ident));\n+                    try!(self.print_type(&**bounded_ty));\n                     try!(self.print_bounds(\":\", bounds.as_slice()));\n                 }\n+                &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                                ref bounds,\n+                                                                                ..}) => {\n+                    try!(self.print_lifetime(lifetime));\n+                    try!(word(&mut self.s, \":\"));\n+\n+                    for (i, bound) in bounds.iter().enumerate() {\n+                        try!(self.print_lifetime(bound));\n+\n+                        if i != 0 {\n+                            try!(word(&mut self.s, \":\"));\n+                        }\n+                    }\n+                }\n                 &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n                     try!(self.print_path(path, false));\n                     try!(space(&mut self.s));"}, {"sha": "9938feb171eb0fc738509969e29cf5c7b6b6857a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -583,13 +583,21 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in generics.where_clause.predicates.iter() {\n         match predicate {\n-            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{span,\n-                                                                          ident,\n+            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ref bounded_ty,\n                                                                           ref bounds,\n                                                                           ..}) => {\n-                visitor.visit_ident(span, ident);\n+                visitor.visit_ty(&**bounded_ty);\n                 walk_ty_param_bounds_helper(visitor, bounds);\n             }\n+            &ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n+                                                                            ref bounds,\n+                                                                            ..}) => {\n+                visitor.visit_lifetime_ref(lifetime);\n+\n+                for bound in bounds.iter() {\n+                    visitor.visit_lifetime_ref(bound);\n+                }\n+            }\n             &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n                                                                     ref path,\n                                                                     ref ty,"}, {"sha": "381144f2599c1a28b9f361ec32cf548484b161b2", "filename": "src/test/compile-fail/region-lifetime-bounds-on-fns-where-clause.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-lifetime-bounds-on-fns-where-clause.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn a<'a, 'b>(x: &mut &'a int, y: &mut &'b int) where 'b: 'a {\n+    // Note: this is legal because of the `'b:'a` declaration.\n+    *x = *y;\n+}\n+\n+fn b<'a, 'b>(x: &mut &'a int, y: &mut &'b int) {\n+    // Illegal now because there is no `'b:'a` declaration.\n+    *x = *y; //~ ERROR mismatched types\n+}\n+\n+fn c<'a,'b>(x: &mut &'a int, y: &mut &'b int) {\n+    // Here we try to call `foo` but do not know that `'a` and `'b` are\n+    // related as required.\n+    a(x, y); //~ ERROR cannot infer\n+}\n+\n+fn d() {\n+    // 'a and 'b are early bound in the function `a` because they appear\n+    // inconstraints:\n+    let _: fn(&mut &int, &mut &int) = a; //~ ERROR mismatched types\n+}\n+\n+fn e() {\n+    // 'a and 'b are late bound in the function `b` because there are\n+    // no constraints:\n+    let _: fn(&mut &int, &mut &int) = b;\n+}\n+\n+fn main() { }"}, {"sha": "a03911e1d0e18127bdde883dc18875b1e12d77f1", "filename": "src/test/compile-fail/region-multiple-lifetime-bounds-on-fns-where-clause.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn a<'a, 'b, 'c>(x: &mut &'a int, y: &mut &'b int, z: &mut &'c int) where 'b: 'a + 'c {\n+    // Note: this is legal because of the `'b:'a` declaration.\n+    *x = *y;\n+    *z = *y;\n+}\n+\n+fn b<'a, 'b, 'c>(x: &mut &'a int, y: &mut &'b int, z: &mut &'c int) {\n+    // Illegal now because there is no `'b:'a` declaration.\n+    *x = *y; //~ ERROR mismatched types\n+    *z = *y; //~ ERROR mismatched types\n+}\n+\n+fn c<'a,'b, 'c>(x: &mut &'a int, y: &mut &'b int, z: &mut &'c int) {\n+    // Here we try to call `foo` but do not know that `'a` and `'b` are\n+    // related as required.\n+    a(x, y, z); //~ ERROR cannot infer\n+}\n+\n+fn d() {\n+    // 'a and 'b are early bound in the function `a` because they appear\n+    // inconstraints:\n+    let _: fn(&mut &int, &mut &int, &mut &int) = a; //~ ERROR mismatched types\n+}\n+\n+fn e() {\n+    // 'a and 'b are late bound in the function `b` because there are\n+    // no constraints:\n+    let _: fn(&mut &int, &mut &int, &mut &int) = b;\n+}\n+\n+fn main() { }"}, {"sha": "8d72e260a18f7485be40045d2f984290d04ecb3a", "filename": "src/test/compile-fail/where-clause-constraints-are-local-for-inherent-impl.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clause-constraints-are-local-for-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clause-constraints-are-local-for-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clause-constraints-are-local-for-inherent-impl.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn require_copy<T: Copy>(x: T) {}\n+\n+struct Foo<T> { x: T }\n+\n+// Ensure constraints are only attached to methods locally\n+impl<T> Foo<T> {\n+    fn needs_copy(self) where T: Copy {\n+        require_copy(self.x);\n+\n+    }\n+\n+    fn fails_copy(self) {\n+        require_copy(self.x);\n+        //~^ ERROR the trait `core::kinds::Copy` is not implemented for the type `T`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "096b53a1ea6244ba30127f17b15ed90817c632b5", "filename": "src/test/compile-fail/where-clause-constraints-are-local-for-trait-impl.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clause-constraints-are-local-for-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clause-constraints-are-local-for-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clause-constraints-are-local-for-trait-impl.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn require_copy<T: Copy>(x: T) {}\n+\n+struct Bar<T> { x: T }\n+\n+trait Foo<T> {\n+    fn needs_copy(self) where T: Copy;\n+    fn fails_copy(self);\n+}\n+\n+// Ensure constraints are only attached to methods locally\n+impl<T> Foo<T> for Bar<T> {\n+    fn needs_copy(self) where T: Copy {\n+        require_copy(self.x);\n+\n+    }\n+\n+    fn fails_copy(self) {\n+        require_copy(self.x);\n+        //~^ ERROR the trait `core::kinds::Copy` is not implemented for the type `T`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "40d2df45488f5a67468bbb822133d5e56db6fdbd", "filename": "src/test/compile-fail/where-clause-method-substituion.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clause-method-substituion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clause-method-substituion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clause-method-substituion.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo<T> {}\n+\n+trait Bar<A> {\n+    fn method<B>(&self) where A: Foo<B>;\n+}\n+\n+struct S;\n+struct X;\n+\n+// Remove this impl causing the below resolution to fail // impl Foo<S> for X {}\n+\n+impl Bar<X> for int {\n+    fn method<U>(&self) where X: Foo<U> {\n+    }\n+}\n+\n+fn main() {\n+    1.method::<X>();\n+    //~^ ERROR the trait `Foo<X>` is not implemented for the type `X`\n+}"}, {"sha": "e5b54582e4e3ffca0ccc224b7bf53062054a0fb7", "filename": "src/test/compile-fail/where-clauses-method-unsatisfied.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-method-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-method-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-method-unsatisfied.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a where clause attached to a method allows us to add\n+// additional constraints to a parameter out of scope.\n+\n+struct Foo<T> {\n+    value: T\n+}\n+\n+struct Bar; // does not implement Eq\n+\n+impl<T> Foo<T> {\n+    fn equals(&self, u: &Foo<T>) -> bool where T : Eq {\n+        self.value == u.value\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo { value: Bar };\n+    x.equals(&x);\n+    //~^ ERROR the trait `core::cmp::Eq` is not implemented for the type `Bar`\n+}"}, {"sha": "9e81703787f3e0f011c5b7c298c187797bf80832", "filename": "src/test/compile-fail/where-clauses-not-parameter.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -8,10 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn equal<T>(_: &T, _: &T) -> bool where int : Eq {\n-    //~^ ERROR undeclared type parameter\n+struct A;\n+\n+trait U {}\n+\n+// impl U for A {}\n+\n+fn equal<T>(_: &T, _: &T) -> bool where A : U {\n+    true\n }\n \n fn main() {\n+    equal(&0i, &0i);\n+    //~^ ERROR the trait `U` is not implemented for the type `A`\n }\n-"}, {"sha": "0f3b914334e12b09cb9b4fabfe668124419fadf0", "filename": "src/test/pretty/where-clauses.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fpretty%2Fwhere-clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Fpretty%2Fwhere-clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fwhere-clauses.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+\n+fn f<'a, 'b, T>(t: T) -> int where T: 'a, 'a:'b, T: Eq { 0 }\n+\n+fn main() { }\n+"}, {"sha": "cade99b83a2fe429bf6b9e31919b408f179f37a5", "filename": "src/test/run-pass/where-clause-early-bound-lifetimes.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clause-early-bound-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clause-early-bound-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clause-early-bound-lifetimes.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait TheTrait { }\n+\n+impl TheTrait for &'static int { }\n+\n+fn foo<'a,T>(_: &'a T) where &'a T : TheTrait { }\n+\n+fn bar<T>(_: &'static T) where &'static T : TheTrait { }\n+\n+fn main() {\n+    static x: int = 1;\n+    foo(&x);\n+    bar(&x);\n+}"}, {"sha": "b391df8500bb7e65ce50ea9ae4fc2d176f7b4a65", "filename": "src/test/run-pass/where-clause-method-substituion.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clause-method-substituion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clause-method-substituion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clause-method-substituion.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo<T> {}\n+\n+trait Bar<A> {\n+    fn method<B>(&self) where A: Foo<B>;\n+}\n+\n+struct S;\n+struct X;\n+\n+impl Foo<S> for X {}\n+\n+impl Bar<X> for int {\n+    fn method<U>(&self) where X: Foo<U> {\n+    }\n+}\n+\n+fn main() {\n+    1.method::<S>();\n+}\n+"}, {"sha": "1ecb4b6c2dc8f63e54c597d24718dd8caaa1c7c8", "filename": "src/test/run-pass/where-clause-region-outlives.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clause-region-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clause-region-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clause-region-outlives.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A<'a, 'b> where 'a : 'b { x: &'a int, y: &'b int }\n+\n+fn main() {\n+    let x = 1i;\n+    let y = 1i;\n+    let a = A { x: &x, y: &y };\n+}"}, {"sha": "2b87bcd4b3979547830aedd6d14e74bd93bbff6a", "filename": "src/test/run-pass/where-clauses-method.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clauses-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clauses-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clauses-method.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a where clause attached to a method allows us to add\n+// additional constraints to a parameter out of scope.\n+\n+struct Foo<T> {\n+    value: T\n+}\n+\n+impl<T> Foo<T> {\n+    fn equals(&self, u: &Foo<T>) -> bool where T : Eq {\n+        self.value == u.value\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo { value: 1i };\n+    let y = Foo { value: 2i };\n+    println!(\"{}\", x.equals(&x));\n+    println!(\"{}\", x.equals(&y));\n+}"}, {"sha": "bc5fc388ca1ea0f168b9c464d5bee1fc76ad5738", "filename": "src/test/run-pass/where-clauses-not-parameter.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0/src%2Ftest%2Frun-pass%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clauses-not-parameter.rs?ref=8a33de89c4a7acf04a2f3fa5d6ba4aa3fe3f8dc0", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn equal<T>(_: &T, _: &T) -> bool where int : Eq {\n+    true\n+}\n+\n+fn main() {\n+    equal(&0i, &0i);\n+}"}]}