{"sha": "a4aebf030e32d67e72db8b52be74fb6223a3006f", "node_id": "C_kwDOAAsO6NoAKGE0YWViZjAzMGUzMmQ2N2U3MmRiOGI1MmJlNzRmYjYyMjNhMzAwNmY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-30T05:50:06Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-30T05:50:06Z"}, "message": "Improve ICE messages for `*::expect_*`", "tree": {"sha": "3ebada40eab63ff791e1976d44c5cda7152cd2ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ebada40eab63ff791e1976d44c5cda7152cd2ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4aebf030e32d67e72db8b52be74fb6223a3006f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4aebf030e32d67e72db8b52be74fb6223a3006f", "html_url": "https://github.com/rust-lang/rust/commit/a4aebf030e32d67e72db8b52be74fb6223a3006f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4aebf030e32d67e72db8b52be74fb6223a3006f/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70f9d520793318617949e660458bd717548ec8d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f9d520793318617949e660458bd717548ec8d6", "html_url": "https://github.com/rust-lang/rust/commit/70f9d520793318617949e660458bd717548ec8d6"}], "stats": {"total": 118, "additions": 69, "deletions": 49}, "files": [{"sha": "ef4a8754ac27e678952ed66c780b66fb3e9a5633", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 69, "deletions": 49, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/a4aebf030e32d67e72db8b52be74fb6223a3006f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4aebf030e32d67e72db8b52be74fb6223a3006f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a4aebf030e32d67e72db8b52be74fb6223a3006f", "patch": "@@ -2277,23 +2277,28 @@ impl<'hir> TraitItem<'hir> {\n     /// Expect an [`TraitItemKind::Const`] or panic.\n     #[track_caller]\n     pub fn expect_const(&self) -> (&'hir Ty<'hir>, Option<BodyId>) {\n-        let TraitItemKind::Const(ty, body) = self.kind else { unreachable!() };\n+        let TraitItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n         (ty, body)\n     }\n \n     /// Expect an [`TraitItemKind::Fn`] or panic.\n     #[track_caller]\n     pub fn expect_fn(&self) -> (&FnSig<'hir>, &TraitFn<'hir>) {\n-        let TraitItemKind::Fn(ty, trfn) = &self.kind else { unreachable!() };\n+        let TraitItemKind::Fn(ty, trfn) = &self.kind else { self.expect_failed(\"a function\") };\n         (ty, trfn)\n     }\n \n     /// Expect an [`TraitItemKind::ExternCrate`] or panic.\n     #[track_caller]\n     pub fn expect_type(&self) -> (GenericBounds<'hir>, Option<&'hir Ty<'hir>>) {\n-        let TraitItemKind::Type(bounds, ty) = self.kind else { unreachable!() };\n+        let TraitItemKind::Type(bounds, ty) = self.kind else { self.expect_failed(\"a type\") };\n         (bounds, ty)\n     }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents a trait method's body (or just argument names).\n@@ -2360,23 +2365,28 @@ impl<'hir> ImplItem<'hir> {\n     /// Expect an [`ImplItemKind::Const`] or panic.\n     #[track_caller]\n     pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n-        let ImplItemKind::Const(ty, body) = self.kind else { unreachable!() };\n+        let ImplItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n         (ty, body)\n     }\n \n     /// Expect an [`ImplItemKind::Fn`] or panic.\n     #[track_caller]\n     pub fn expect_fn(&self) -> (&FnSig<'hir>, BodyId) {\n-        let ImplItemKind::Fn(ty, body) = &self.kind else { unreachable!() };\n+        let ImplItemKind::Fn(ty, body) = &self.kind else { self.expect_failed(\"a function\") };\n         (ty, *body)\n     }\n \n-    /// Expect an [`ImplItemKind::ExternCrate`] or panic.\n+    /// Expect an [`ImplItemKind::Type`] or panic.\n     #[track_caller]\n     pub fn expect_type(&self) -> &'hir Ty<'hir> {\n-        let ImplItemKind::Type(ty) = self.kind else { unreachable!() };\n+        let ImplItemKind::Type(ty) = self.kind else { self.expect_failed(\"a type\") };\n         ty\n     }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n /// Represents various kinds of content within an `impl`.\n@@ -3051,98 +3061,98 @@ impl<'hir> Item<'hir> {\n     /// Expect an [`ItemKind::ExternCrate`] or panic.\n     #[track_caller]\n     pub fn expect_extern_crate(&self) -> Option<Symbol> {\n-        let ItemKind::ExternCrate(s) = self.kind else { unreachable!() };\n+        let ItemKind::ExternCrate(s) = self.kind else { self.expect_failed(\"an extern crate\") };\n         s\n     }\n \n     /// Expect an [`ItemKind::Use`] or panic.\n     #[track_caller]\n     pub fn expect_use(&self) -> (&'hir UsePath<'hir>, UseKind) {\n-        let ItemKind::Use(p, uk) = self.kind else { unreachable!() };\n+        let ItemKind::Use(p, uk) = self.kind else { self.expect_failed(\"a use\") };\n         (p, uk)\n     }\n \n     /// Expect an [`ItemKind::Static`] or panic.\n     #[track_caller]\n     pub fn expect_static(&self) -> (&'hir Ty<'hir>, Mutability, BodyId) {\n-        let ItemKind::Static(ty, mutbl, body) = self.kind else { unreachable!() };\n+        let ItemKind::Static(ty, mutbl, body) = self.kind else { self.expect_failed(\"a static\") };\n         (ty, mutbl, body)\n     }\n     /// Expect an [`ItemKind::Const`] or panic.\n     #[track_caller]\n     pub fn expect_const(&self) -> (&'hir Ty<'hir>, BodyId) {\n-        let ItemKind::Const(ty, body) = self.kind else { unreachable!() };\n+        let ItemKind::Const(ty, body) = self.kind else { self.expect_failed(\"a constant\") };\n         (ty, body)\n     }\n     /// Expect an [`ItemKind::Fn`] or panic.\n     #[track_caller]\n     pub fn expect_fn(&self) -> (&FnSig<'hir>, &'hir Generics<'hir>, BodyId) {\n-        let ItemKind::Fn(sig, gen, body) = &self.kind else { unreachable!() };\n+        let ItemKind::Fn(sig, gen, body) = &self.kind else { self.expect_failed(\"a function\") };\n         (sig, gen, *body)\n     }\n \n     /// Expect an [`ItemKind::Macro`] or panic.\n     #[track_caller]\n     pub fn expect_macro(&self) -> (&ast::MacroDef, MacroKind) {\n-        let ItemKind::Macro(def, mk) = &self.kind else { unreachable!() };\n+        let ItemKind::Macro(def, mk) = &self.kind else { self.expect_failed(\"a macro\") };\n         (def, *mk)\n     }\n \n     /// Expect an [`ItemKind::Mod`] or panic.\n     #[track_caller]\n     pub fn expect_mod(&self) -> &'hir Mod<'hir> {\n-        let ItemKind::Mod(m) = self.kind else { unreachable!() };\n+        let ItemKind::Mod(m) = self.kind else { self.expect_failed(\"a module\") };\n         m\n     }\n \n     /// Expect an [`ItemKind::ForeignMod`] or panic.\n     #[track_caller]\n     pub fn expect_foreign_mod(&self) -> (Abi, &'hir [ForeignItemRef]) {\n-        let ItemKind::ForeignMod { abi, items } = self.kind else { unreachable!() };\n+        let ItemKind::ForeignMod { abi, items } = self.kind else { self.expect_failed(\"a foreign module\") };\n         (abi, items)\n     }\n \n     /// Expect an [`ItemKind::GlobalAsm`] or panic.\n     #[track_caller]\n     pub fn expect_global_asm(&self) -> &'hir InlineAsm<'hir> {\n-        let ItemKind::GlobalAsm(asm) = self.kind else { unreachable!() };\n+        let ItemKind::GlobalAsm(asm) = self.kind else { self.expect_failed(\"a global asm\") };\n         asm\n     }\n \n     /// Expect an [`ItemKind::TyAlias`] or panic.\n     #[track_caller]\n     pub fn expect_ty_alias(&self) -> (&'hir Ty<'hir>, &'hir Generics<'hir>) {\n-        let ItemKind::TyAlias(ty, gen) = self.kind else { unreachable!() };\n+        let ItemKind::TyAlias(ty, gen) = self.kind else { self.expect_failed(\"a type alias\") };\n         (ty, gen)\n     }\n \n     /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     /// Expect an [`ItemKind::OpaqueTy`] or panic.\n     #[track_caller]\n     pub fn expect_opaque_ty(&self) -> &OpaqueTy<'hir> {\n-        let ItemKind::OpaqueTy(ty) = &self.kind else { unreachable!() };\n+        let ItemKind::OpaqueTy(ty) = &self.kind else { self.expect_failed(\"an opaque type\") };\n         ty\n     }\n \n     /// Expect an [`ItemKind::Enum`] or panic.\n     #[track_caller]\n     pub fn expect_enum(&self) -> (&EnumDef<'hir>, &'hir Generics<'hir>) {\n-        let ItemKind::Enum(def, gen) = &self.kind else { unreachable!() };\n+        let ItemKind::Enum(def, gen) = &self.kind else { self.expect_failed(\"an enum\") };\n         (def, gen)\n     }\n \n     /// Expect an [`ItemKind::Struct`] or panic.\n     #[track_caller]\n     pub fn expect_struct(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n-        let ItemKind::Struct(data, gen) = &self.kind else { unreachable!() };\n+        let ItemKind::Struct(data, gen) = &self.kind else { self.expect_failed(\"a struct\") };\n         (data, gen)\n     }\n \n     /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n     /// Expect an [`ItemKind::Union`] or panic.\n     #[track_caller]\n     pub fn expect_union(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n-        let ItemKind::Union(data, gen) = &self.kind else { unreachable!() };\n+        let ItemKind::Union(data, gen) = &self.kind else { self.expect_failed(\"a union\") };\n         (data, gen)\n     }\n \n@@ -3151,23 +3161,28 @@ impl<'hir> Item<'hir> {\n     pub fn expect_trait(\n         self,\n     ) -> (IsAuto, Unsafety, &'hir Generics<'hir>, GenericBounds<'hir>, &'hir [TraitItemRef]) {\n-        let ItemKind::Trait(is_auto, unsafety, gen, bounds, items) = self.kind else { unreachable!() };\n+        let ItemKind::Trait(is_auto, unsafety, gen, bounds, items) = self.kind else { self.expect_failed(\"a trait\") };\n         (is_auto, unsafety, gen, bounds, items)\n     }\n \n     /// Expect an [`ItemKind::TraitAlias`] or panic.\n     #[track_caller]\n     pub fn expect_trait_alias(&self) -> (&'hir Generics<'hir>, GenericBounds<'hir>) {\n-        let ItemKind::TraitAlias(gen, bounds) = self.kind else { unreachable!() };\n+        let ItemKind::TraitAlias(gen, bounds) = self.kind else { self.expect_failed(\"a trait alias\") };\n         (gen, bounds)\n     }\n \n     /// Expect an [`ItemKind::Impl`] or panic.\n     #[track_caller]\n     pub fn expect_impl(&self) -> &'hir Impl<'hir> {\n-        let ItemKind::Impl(imp) = self.kind else { unreachable!() };\n+        let ItemKind::Impl(imp) = self.kind else { self.expect_failed(\"an impl\") };\n         imp\n     }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} item, found {self:?}\")\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -3757,176 +3772,181 @@ impl<'hir> Node<'hir> {\n     /// Expect a [`Node::Param`] or panic.\n     #[track_caller]\n     pub fn expect_param(self) -> &'hir Param<'hir> {\n-        let Node::Param(this) = self else { unreachable!() };\n+        let Node::Param(this) = self else { self.expect_failed(\"a parameter\") };\n         this\n     }\n \n     /// Expect a [`Node::Item`] or panic.\n     #[track_caller]\n     pub fn expect_item(self) -> &'hir Item<'hir> {\n-        let Node::Item(this) = self else { unreachable!() };\n+        let Node::Item(this) = self else { self.expect_failed(\"a item\") };\n         this\n     }\n \n     /// Expect a [`Node::ForeignItem`] or panic.\n     #[track_caller]\n     pub fn expect_foreign_item(self) -> &'hir ForeignItem<'hir> {\n-        let Node::ForeignItem(this) = self else { unreachable!() };\n+        let Node::ForeignItem(this) = self else { self.expect_failed(\"a foreign item\") };\n         this\n     }\n \n     /// Expect a [`Node::TraitItem`] or panic.\n     #[track_caller]\n     pub fn expect_trait_item(self) -> &'hir TraitItem<'hir> {\n-        let Node::TraitItem(this) = self else { unreachable!() };\n+        let Node::TraitItem(this) = self else { self.expect_failed(\"a trait item\") };\n         this\n     }\n \n     /// Expect a [`Node::ImplItem`] or panic.\n     #[track_caller]\n     pub fn expect_impl_item(self) -> &'hir ImplItem<'hir> {\n-        let Node::ImplItem(this) = self else { unreachable!() };\n+        let Node::ImplItem(this) = self else { self.expect_failed(\"an implementation item\") };\n         this\n     }\n \n     /// Expect a [`Node::Variant`] or panic.\n     #[track_caller]\n     pub fn expect_variant(self) -> &'hir Variant<'hir> {\n-        let Node::Variant(this) = self else { unreachable!() };\n+        let Node::Variant(this) = self else { self.expect_failed(\"a variant\") };\n         this\n     }\n \n     /// Expect a [`Node::Field`] or panic.\n     #[track_caller]\n     pub fn expect_field(self) -> &'hir FieldDef<'hir> {\n-        let Node::Field(this) = self else { unreachable!() };\n+        let Node::Field(this) = self else { self.expect_failed(\"a field definition\") };\n         this\n     }\n \n     /// Expect a [`Node::AnonConst`] or panic.\n     #[track_caller]\n     pub fn expect_anon_const(self) -> &'hir AnonConst {\n-        let Node::AnonConst(this) = self else { unreachable!() };\n+        let Node::AnonConst(this) = self else { self.expect_failed(\"an anonymous constant\") };\n         this\n     }\n \n     /// Expect a [`Node::Expr`] or panic.\n     #[track_caller]\n     pub fn expect_expr(self) -> &'hir Expr<'hir> {\n-        let Node::Expr(this) = self else { unreachable!() };\n+        let Node::Expr(this) = self else { self.expect_failed(\"an expression\") };\n         this\n     }\n     /// Expect a [`Node::ExprField`] or panic.\n     #[track_caller]\n     pub fn expect_expr_field(self) -> &'hir ExprField<'hir> {\n-        let Node::ExprField(this) = self else { unreachable!() };\n+        let Node::ExprField(this) = self else { self.expect_failed(\"an expression field\") };\n         this\n     }\n \n     /// Expect a [`Node::Stmt`] or panic.\n     #[track_caller]\n     pub fn expect_stmt(self) -> &'hir Stmt<'hir> {\n-        let Node::Stmt(this) = self else { unreachable!() };\n+        let Node::Stmt(this) = self else { self.expect_failed(\"a statement\") };\n         this\n     }\n \n     /// Expect a [`Node::PathSegment`] or panic.\n     #[track_caller]\n     pub fn expect_path_segment(self) -> &'hir PathSegment<'hir> {\n-        let Node::PathSegment(this) = self else { unreachable!() };\n+        let Node::PathSegment(this) = self else { self.expect_failed(\"a path segment\") };\n         this\n     }\n \n     /// Expect a [`Node::Ty`] or panic.\n     #[track_caller]\n     pub fn expect_ty(self) -> &'hir Ty<'hir> {\n-        let Node::Ty(this) = self else { unreachable!() };\n+        let Node::Ty(this) = self else { self.expect_failed(\"a type\") };\n         this\n     }\n \n     /// Expect a [`Node::TypeBinding`] or panic.\n     #[track_caller]\n     pub fn expect_type_binding(self) -> &'hir TypeBinding<'hir> {\n-        let Node::TypeBinding(this) = self else { unreachable!() };\n+        let Node::TypeBinding(this) = self else { self.expect_failed(\"a type binding\") };\n         this\n     }\n \n     /// Expect a [`Node::TraitRef`] or panic.\n     #[track_caller]\n     pub fn expect_trait_ref(self) -> &'hir TraitRef<'hir> {\n-        let Node::TraitRef(this) = self else { unreachable!() };\n+        let Node::TraitRef(this) = self else { self.expect_failed(\"a trait reference\") };\n         this\n     }\n \n     /// Expect a [`Node::Pat`] or panic.\n     #[track_caller]\n     pub fn expect_pat(self) -> &'hir Pat<'hir> {\n-        let Node::Pat(this) = self else { unreachable!() };\n+        let Node::Pat(this) = self else { self.expect_failed(\"a pattern\") };\n         this\n     }\n \n     /// Expect a [`Node::PatField`] or panic.\n     #[track_caller]\n     pub fn expect_pat_field(self) -> &'hir PatField<'hir> {\n-        let Node::PatField(this) = self else { unreachable!() };\n+        let Node::PatField(this) = self else { self.expect_failed(\"a pattern field\") };\n         this\n     }\n \n     /// Expect a [`Node::Arm`] or panic.\n     #[track_caller]\n     pub fn expect_arm(self) -> &'hir Arm<'hir> {\n-        let Node::Arm(this) = self else { unreachable!() };\n+        let Node::Arm(this) = self else { self.expect_failed(\"an arm\") };\n         this\n     }\n \n     /// Expect a [`Node::Block`] or panic.\n     #[track_caller]\n     pub fn expect_block(self) -> &'hir Block<'hir> {\n-        let Node::Block(this) = self else { unreachable!() };\n+        let Node::Block(this) = self else { self.expect_failed(\"a block\") };\n         this\n     }\n \n     /// Expect a [`Node::Local`] or panic.\n     #[track_caller]\n     pub fn expect_local(self) -> &'hir Local<'hir> {\n-        let Node::Local(this) = self else { unreachable!() };\n+        let Node::Local(this) = self else { self.expect_failed(\"a local\") };\n         this\n     }\n \n     /// Expect a [`Node::Ctor`] or panic.\n     #[track_caller]\n     pub fn expect_ctor(self) -> &'hir VariantData<'hir> {\n-        let Node::Ctor(this) = self else { unreachable!() };\n+        let Node::Ctor(this) = self else { self.expect_failed(\"a constructor\") };\n         this\n     }\n \n     /// Expect a [`Node::Lifetime`] or panic.\n     #[track_caller]\n     pub fn expect_lifetime(self) -> &'hir Lifetime {\n-        let Node::Lifetime(this) = self else { unreachable!() };\n+        let Node::Lifetime(this) = self else { self.expect_failed(\"a lifetime\") };\n         this\n     }\n \n     /// Expect a [`Node::GenericParam`] or panic.\n     #[track_caller]\n     pub fn expect_generic_param(self) -> &'hir GenericParam<'hir> {\n-        let Node::GenericParam(this) = self else { unreachable!() };\n+        let Node::GenericParam(this) = self else { self.expect_failed(\"a generic parameter\") };\n         this\n     }\n \n     /// Expect a [`Node::Crate`] or panic.\n     #[track_caller]\n     pub fn expect_crate(self) -> &'hir Mod<'hir> {\n-        let Node::Crate(this) = self else { unreachable!() };\n+        let Node::Crate(this) = self else { self.expect_failed(\"a crate\") };\n         this\n     }\n \n     /// Expect a [`Node::Infer`] or panic.\n     #[track_caller]\n     pub fn expect_infer(self) -> &'hir InferArg {\n-        let Node::Infer(this) = self else { unreachable!() };\n+        let Node::Infer(this) = self else { self.expect_failed(\"an infer\") };\n         this\n     }\n+\n+    #[track_caller]\n+    fn expect_failed(&self, expected: &'static str) -> ! {\n+        panic!(\"expected {expected} node, found {self:?}\")\n+    }\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger."}]}