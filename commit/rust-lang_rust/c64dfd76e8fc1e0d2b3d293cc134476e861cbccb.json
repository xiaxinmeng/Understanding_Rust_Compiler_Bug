{"sha": "c64dfd76e8fc1e0d2b3d293cc134476e861cbccb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NGRmZDc2ZThmYzFlMGQyYjNkMjkzY2MxMzQ0NzZlODYxY2JjY2I=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-20T23:06:08Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-10T21:03:08Z"}, "message": "Add a `Visitor` for dataflow results", "tree": {"sha": "fd35ef96e53ae23343b98a124ab05e60da6665c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd35ef96e53ae23343b98a124ab05e60da6665c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb", "html_url": "https://github.com/rust-lang/rust/commit/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ec99179c1ccb4305354d2d4ee503c40adcd714d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec99179c1ccb4305354d2d4ee503c40adcd714d", "html_url": "https://github.com/rust-lang/rust/commit/1ec99179c1ccb4305354d2d4ee503c40adcd714d"}], "stats": {"total": 275, "additions": 275, "deletions": 0}, "files": [{"sha": "d961ba7fffa251845d829ca796877594378e8330", "filename": "src/librustc_mir/dataflow/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fmod.rs?ref=c64dfd76e8fc1e0d2b3d293cc134476e861cbccb", "patch": "@@ -45,9 +45,12 @@ use crate::dataflow::BottomValue;\n mod cursor;\n mod engine;\n mod graphviz;\n+mod visitor;\n \n pub use self::cursor::{ResultsCursor, ResultsRefCursor};\n pub use self::engine::Engine;\n+pub use self::visitor::{visit_results, ResultsVisitor};\n+pub use self::visitor::{BorrowckFlowState, BorrowckResults};\n \n /// A dataflow analysis that has converged to fixpoint.\n pub struct Results<'tcx, A>"}, {"sha": "5bad8c61a0cd7068d8e8b3f016cf50ece8318d0f", "filename": "src/librustc_mir/dataflow/generic/visitor.rs", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64dfd76e8fc1e0d2b3d293cc134476e861cbccb/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric%2Fvisitor.rs?ref=c64dfd76e8fc1e0d2b3d293cc134476e861cbccb", "patch": "@@ -0,0 +1,272 @@\n+use rustc::mir::{self, BasicBlock, Location};\n+use rustc_index::bit_set::BitSet;\n+\n+use super::{Analysis, Results};\n+use crate::dataflow::impls::{borrows::Borrows, EverInitializedPlaces, MaybeUninitializedPlaces};\n+\n+/// Calls the corresponding method in `ResultsVisitor` for every location in a `mir::Body` with the\n+/// dataflow state at that location.\n+pub fn visit_results<F>(\n+    body: &'mir mir::Body<'tcx>,\n+    blocks: impl IntoIterator<Item = BasicBlock>,\n+    results: &impl ResultsVisitable<'tcx, FlowState = F>,\n+    vis: &mut impl ResultsVisitor<'mir, 'tcx, FlowState = F>,\n+) {\n+    let mut state = results.new_flow_state(body);\n+\n+    for block in blocks {\n+        let block_data = &body[block];\n+        results.reset_to_block_start(&mut state, block);\n+\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let loc = Location { block, statement_index };\n+\n+            results.reconstruct_before_statement_effect(&mut state, stmt, loc);\n+            vis.visit_statement(&mut state, stmt, loc);\n+\n+            results.reconstruct_statement_effect(&mut state, stmt, loc);\n+            vis.visit_statement_exit(&mut state, stmt, loc);\n+        }\n+\n+        let loc = body.terminator_loc(block);\n+        let term = block_data.terminator();\n+\n+        results.reconstruct_before_terminator_effect(&mut state, term, loc);\n+        vis.visit_terminator(&mut state, term, loc);\n+\n+        results.reconstruct_terminator_effect(&mut state, term, loc);\n+        vis.visit_terminator_exit(&mut state, term, loc);\n+    }\n+}\n+\n+pub trait ResultsVisitor<'mir, 'tcx> {\n+    type FlowState;\n+\n+    /// Called with the `before_statement_effect` of the given statement applied to `state` but not\n+    /// its `statement_effect`.\n+    fn visit_statement(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Called with both the `before_statement_effect` and the `statement_effect` of the given\n+    /// statement applied to `state`.\n+    fn visit_statement_exit(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _statement: &'mir mir::Statement<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Called with the `before_terminator_effect` of the given terminator applied to `state` but not\n+    /// its `terminator_effect`.\n+    fn visit_terminator(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+\n+    /// Called with both the `before_terminator_effect` and the `terminator_effect` of the given\n+    /// terminator applied to `state`.\n+    ///\n+    /// The `call_return_effect` (if one exists) will *not* be applied to `state`.\n+    fn visit_terminator_exit(\n+        &mut self,\n+        _state: &Self::FlowState,\n+        _terminator: &'mir mir::Terminator<'tcx>,\n+        _location: Location,\n+    ) {\n+    }\n+}\n+\n+/// Things that can be visited by a `ResultsVisitor`.\n+///\n+/// This trait exists so that we can visit the results of multiple dataflow analyses simultaneously.\n+/// DO NOT IMPLEMENT MANUALLY. Instead, use the `impl_visitable` macro below.\n+pub trait ResultsVisitable<'tcx> {\n+    type FlowState;\n+\n+    /// Creates an empty `FlowState` to hold the transient state for these dataflow results.\n+    ///\n+    /// The value of the newly created `FlowState` will be overwritten by `reset_to_block_start`\n+    /// before it can be observed by a `ResultsVisitor`.\n+    fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState;\n+\n+    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock);\n+\n+    fn reconstruct_before_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn reconstruct_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn reconstruct_before_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn reconstruct_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+}\n+\n+impl<'tcx, A> ResultsVisitable<'tcx> for Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    type FlowState = BitSet<A::Idx>;\n+\n+    fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n+        BitSet::new_empty(self.analysis.bits_per_block(body))\n+    }\n+\n+    fn reset_to_block_start(&self, state: &mut Self::FlowState, block: BasicBlock) {\n+        state.overwrite(&self.entry_set_for_block(block));\n+    }\n+\n+    fn reconstruct_before_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_before_statement_effect(state, stmt, loc);\n+    }\n+\n+    fn reconstruct_statement_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        stmt: &mir::Statement<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_statement_effect(state, stmt, loc);\n+    }\n+\n+    fn reconstruct_before_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        term: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_before_terminator_effect(state, term, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(\n+        &self,\n+        state: &mut Self::FlowState,\n+        term: &mir::Terminator<'tcx>,\n+        loc: Location,\n+    ) {\n+        self.analysis.apply_terminator_effect(state, term, loc);\n+    }\n+}\n+\n+/// A tuple with named fields that can hold either the results or the transient state of the\n+/// dataflow analyses used by the borrow checker.\n+#[derive(Debug)]\n+pub struct BorrowckAnalyses<B, U, E> {\n+    pub borrows: B,\n+    pub uninits: U,\n+    pub ever_inits: E,\n+}\n+\n+/// The results of the dataflow analyses used by the borrow checker.\n+pub type BorrowckResults<'mir, 'tcx> = BorrowckAnalyses<\n+    Results<'tcx, Borrows<'mir, 'tcx>>,\n+    Results<'tcx, MaybeUninitializedPlaces<'mir, 'tcx>>,\n+    Results<'tcx, EverInitializedPlaces<'mir, 'tcx>>,\n+>;\n+\n+/// The transient state of the dataflow analyses used by the borrow checker.\n+pub type BorrowckFlowState<'mir, 'tcx> =\n+    <BorrowckResults<'mir, 'tcx> as ResultsVisitable<'tcx>>::FlowState;\n+\n+macro_rules! impl_visitable {\n+    ( $(\n+        $T:ident { $( $field:ident : $A:ident ),* $(,)? }\n+    )* ) => { $(\n+        impl<'tcx, $($A),*> ResultsVisitable<'tcx> for $T<$( Results<'tcx, $A> ),*>\n+        where\n+            $( $A: Analysis<'tcx>, )*\n+        {\n+            type FlowState = $T<$( BitSet<$A::Idx> ),*>;\n+\n+            fn new_flow_state(&self, body: &mir::Body<'tcx>) -> Self::FlowState {\n+                $T {\n+                    $( $field: BitSet::new_empty(self.$field.analysis.bits_per_block(body)) ),*\n+                }\n+            }\n+\n+            fn reset_to_block_start(\n+                &self,\n+                state: &mut Self::FlowState,\n+                block: BasicBlock,\n+            ) {\n+                $( state.$field.overwrite(&self.$field.entry_sets[block]); )*\n+            }\n+\n+            fn reconstruct_before_statement_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                stmt: &mir::Statement<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_before_statement_effect(&mut state.$field, stmt, loc); )*\n+            }\n+\n+            fn reconstruct_statement_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                stmt: &mir::Statement<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_statement_effect(&mut state.$field, stmt, loc); )*\n+            }\n+\n+            fn reconstruct_before_terminator_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                term: &mir::Terminator<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_before_terminator_effect(&mut state.$field, term, loc); )*\n+            }\n+\n+            fn reconstruct_terminator_effect(\n+                &self,\n+                state: &mut Self::FlowState,\n+                term: &mir::Terminator<'tcx>,\n+                loc: Location,\n+            ) {\n+                $( self.$field.analysis\n+                    .apply_terminator_effect(&mut state.$field, term, loc); )*\n+            }\n+        }\n+    )* }\n+}\n+\n+impl_visitable! {\n+    BorrowckAnalyses { borrows: B, uninits: U, ever_inits: E }\n+}"}]}