{"sha": "721370481264784eeda3d5c5fe092e03ed78ab1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMTM3MDQ4MTI2NDc4NGVlZGEzZDVjNWZlMDkyZTAzZWQ3OGFiMWU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-11-04T07:52:36Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-12-03T08:27:17Z"}, "message": "New Guide: Ownership\n\nThis replaces the previous \"Lifetimes guide,\" since we are discussing\nthings from an owernship perspective now.", "tree": {"sha": "862d34dae79888631ea76d92123b16c0355bae7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/862d34dae79888631ea76d92123b16c0355bae7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721370481264784eeda3d5c5fe092e03ed78ab1e", "comment_count": 17, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721370481264784eeda3d5c5fe092e03ed78ab1e", "html_url": "https://github.com/rust-lang/rust/commit/721370481264784eeda3d5c5fe092e03ed78ab1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721370481264784eeda3d5c5fe092e03ed78ab1e/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2fe7a083ed63b1a739f5e0d0417cfd8a7da6510", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2fe7a083ed63b1a739f5e0d0417cfd8a7da6510", "html_url": "https://github.com/rust-lang/rust/commit/e2fe7a083ed63b1a739f5e0d0417cfd8a7da6510"}], "stats": {"total": 973, "additions": 431, "deletions": 542}, "files": [{"sha": "c1180f7e6a93a324bad9659c4ccb70905b7d7245", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 431, "deletions": 542, "changes": 973, "blob_url": "https://github.com/rust-lang/rust/blob/721370481264784eeda3d5c5fe092e03ed78ab1e/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/721370481264784eeda3d5c5fe092e03ed78ab1e/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=721370481264784eeda3d5c5fe092e03ed78ab1e", "patch": "@@ -1,565 +1,454 @@\n-% The Rust References and Lifetimes Guide\n-\n-# Introduction\n-\n-References are one of the more flexible and powerful tools available in\n-Rust. They can point anywhere: into the heap, stack, and even into the\n-interior of another data structure. A reference is as flexible as a C pointer\n-or C++ reference.\n-\n-Unlike C and C++ compilers, the Rust compiler includes special static\n-checks that ensure that programs use references safely.\n-\n-Despite their complete safety, a reference's representation at runtime\n-is the same as that of an ordinary pointer in a C program. They introduce zero\n-overhead. The compiler does all safety checks at compile time.\n-\n-Although references have rather elaborate theoretical underpinnings\n-(e.g. region pointers), the core concepts will be familiar to anyone\n-who has worked with C or C++. The best way to explain how they are\n-used\u2014and their limitations\u2014is probably just to work through several examples.\n-\n-# By example\n-\n-References, sometimes known as *borrowed pointers*, are only valid for\n-a limited duration. References never claim any kind of ownership\n-over the data that they point to. Instead, they are used for cases\n-where you would like to use data for a short time.\n-\n-Consider a simple struct type `Point`:\n-\n-~~~\n-struct Point {x: f64, y: f64}\n-~~~\n-\n-We can use this simple definition to allocate points in many different ways. For\n-example, in this code, each of these local variables contains a point,\n-but allocated in a different place:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack : Point      =     Point {x: 3.0, y: 4.0};\n-let on_the_heap  : Box<Point> = box Point {x: 7.0, y: 9.0};\n-~~~\n-\n-Suppose we wanted to write a procedure that computed the distance between any\n-two points, no matter where they were stored. One option is to define a function\n-that takes two arguments of type `Point`\u2014that is, it takes the points by value.\n-But if we define it this way, calling the function will cause the points to be\n-copied. For points, this is probably not so bad, but often copies are\n-expensive. So we'd like to define a function that takes the points just as\n-a reference.\n-\n-~~~\n-# use std::num::Float;\n-# struct Point {x: f64, y: f64}\n-# fn sqrt(f: f64) -> f64 { 0.0 }\n-fn compute_distance(p1: &Point, p2: &Point) -> f64 {\n-    let x_d = p1.x - p2.x;\n-    let y_d = p1.y - p2.y;\n-    (x_d * x_d + y_d * y_d).sqrt()\n+% The Rust Ownership Guide\n+\n+This guide presents Rust's ownership system. This is one of Rust's most unique\n+and compelling features, with which Rust developers should become quite\n+acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n+The ownership system has a few distinct concepts: **ownership**, **borrowing**,\n+and **lifetimes**. We'll talk about each one in turn.\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\"zero cost abstractions,\" which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero cost abstraction. All of the analysis we'll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \"fighting with the borrow\n+checker,\" where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer's mental model of\n+how ownership should work doesn't match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let's learn about ownership.\n+\n+# Ownership\n+\n+At its core, ownership is about 'resources.' For the purposes of the vast\n+majority of this guide, we will talk about a specific resource: memory. The\n+concept generalizes to any kind of resource, like a file handle, but to make it\n+more concrete, we'll focus on memory.\n+\n+When your program allocates some memory, it needs some way to deallocate that\n+memory. Imagine a function `foo` that allocates four bytes of memory, and then\n+never deallocates that memory. We call this problem 'leaking' memory, because\n+each time we call `foo`, we're allocating another four bytes. Eventually, with\n+enough calls to `foo`, we will run our system out of memory. That's no good. So\n+we need some way for `foo` to deallocate those four bytes. It's also important\n+that we don't deallocate too many times, either. Without getting into the\n+details, attempting to deallocate memory multiple times can lead to problems.\n+In other words, any time some memory is allocated, we need to make sure that we\n+deallocate that memory once and only once. Too many times is bad, not enough\n+times is bad. The counts must match.\n+\n+There's one other important detail with regards to allocating memory. Whenever\n+we request some amount of memory, what we are given is a handle to that memory.\n+This handle (often called a 'pointer', when we're referring to memory) is how\n+we interact with the allocated memory. As long as we have that handle, we can\n+do something with the memory. Once we're done with the handle, we're also done\n+with the memory, as we can't do anything useful without a handle to it.\n+\n+Historically, systems programming languages require you to track these\n+allocations, deallocations, and handles yourself. For example, if we want some\n+memory from the heap in a language like C, we do this:\n+\n+```c\n+{\n+    int *x = malloc(sizeof(int));\n+\n+    // we can now do stuff with our handle x\n+    *x = 5;\n+\n+    free(x);\n }\n-~~~\n-\n-Now we can call `compute_distance()`:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-# let on_the_stack :     Point  =     Point{x: 3.0, y: 4.0};\n-# let on_the_heap  : Box<Point> = box Point{x: 7.0, y: 9.0};\n-# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&on_the_stack, &*on_the_heap);\n-~~~\n-\n-Here, the `&` operator takes the address of the variable\n-`on_the_stack`; this is because `on_the_stack` has the type `Point`\n-(that is, a struct value) and we have to take its address to get a\n-value. We also call this _borrowing_ the local variable\n-`on_the_stack`, because we have created an alias: that is, another\n-name for the same data.\n-\n-Likewise, in the case of `on_the_heap`,\n-the `&` operator is used in conjunction with the `*` operator\n-to take a reference to the contents of the box.\n-\n-Whenever a caller lends data to a callee, there are some limitations on what\n-the caller can do with the original. For example, if the contents of a\n-variable have been lent out, you cannot send that variable to another task. In\n-addition, the compiler will reject any code that might cause the borrowed\n-value to be freed or overwrite its component fields with values of different\n-types (I'll get into what kinds of actions those are shortly). This rule\n-should make intuitive sense: you must wait for a borrower to return the value\n-that you lent it (that is, wait for the reference to go out of scope)\n-before you can make full use of it again.\n-\n-# Other uses for the & operator\n-\n-In the previous example, the value `on_the_stack` was defined like so:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack: Point = Point {x: 3.0, y: 4.0};\n-~~~\n-\n-This declaration means that code can only pass `Point` by value to other\n-functions. As a consequence, we had to explicitly take the address of\n-`on_the_stack` to get a reference. Sometimes however it is more\n-convenient to move the & operator into the definition of `on_the_stack`:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let on_the_stack2: &Point = &Point {x: 3.0, y: 4.0};\n-~~~\n-\n-Applying `&` to an rvalue (non-assignable location) is just a convenient\n-shorthand for creating a temporary and taking its address. A more verbose\n-way to write the same code is:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-let tmp = Point {x: 3.0, y: 4.0};\n-let on_the_stack2 : &Point = &tmp;\n-~~~\n-\n-# Taking the address of fields\n-\n-The `&` operator is not limited to taking the address of\n-local variables. It can also take the address of fields or\n-individual array elements. For example, consider this type definition\n-for `Rectangle`:\n-\n-~~~\n-struct Point {x: f64, y: f64} // as before\n-struct Size {w: f64, h: f64} // as before\n-struct Rectangle {origin: Point, size: Size}\n-~~~\n-\n-Now, as before, we can define rectangles in a few different ways:\n-\n-~~~\n-# struct Point {x: f64, y: f64}\n-# struct Size {w: f64, h: f64} // as before\n-# struct Rectangle {origin: Point, size: Size}\n-let rect_stack   =    &Rectangle {origin: Point {x: 1.0, y: 2.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-let rect_heap    = box Rectangle {origin: Point {x: 5.0, y: 6.0},\n-                                  size: Size {w: 3.0, h: 4.0}};\n-~~~\n-\n-In each case, we can extract out individual subcomponents with the `&`\n-operator. For example, I could write:\n-\n-~~~\n-# struct Point {x: f64, y: f64} // as before\n-# struct Size {w: f64, h: f64} // as before\n-# struct Rectangle {origin: Point, size: Size}\n-# let rect_stack  = &Rectangle {origin: Point {x: 1.0, y: 2.0}, size: Size {w: 3.0, h: 4.0}};\n-# let rect_heap   = box Rectangle {origin: Point {x: 5.0, y: 6.0}, size: Size {w: 3.0, h: 4.0}};\n-# fn compute_distance(p1: &Point, p2: &Point) -> f64 { 0.0 }\n-compute_distance(&rect_stack.origin, &rect_heap.origin);\n-~~~\n-\n-which would borrow the field `origin` from the rectangle on the stack\n-as well as from the owned box, and then compute the distance between them.\n+```\n \n-# Lifetimes\n+The call to `malloc` allocates some memory. The call to `free` deallocates the\n+memory. There's also bookkeeping about allocating the correct amount of memory.\n+\n+Rust combines these two aspects of allocating memory (and other resources) into\n+a concept called 'ownership.' Whenever we request some memory, that handle we\n+receive is called the 'owning handle.' Whenever that handle goes out of scope,\n+Rust knows that you cannot do anything with the memory anymore, and so\n+therefore deallocates the memory for you. Here's the equivalent example in\n+Rust:\n \n-We\u2019ve seen a few examples of borrowing data. To this point, we\u2019ve glossed\n-over issues of safety. As stated in the introduction, at runtime a reference\n-is simply a pointer, nothing more. Therefore, avoiding C's problems with\n-dangling pointers requires a compile-time safety check.\n-\n-The basis for the check is the notion of _lifetimes_. A lifetime is a\n-static approximation of the span of execution during which the pointer\n-is valid: it always corresponds to some expression or block within the\n-program.\n-\n-The compiler will only allow a borrow *if it can guarantee that the data will\n-not be reassigned or moved for the lifetime of the pointer*. This does not\n-necessarily mean that the data is stored in immutable memory. For example,\n-the following function is legal:\n-\n-~~~\n-# fn some_condition() -> bool { true }\n-# struct Foo { f: int }\n-fn example3() -> int {\n-    let mut x = box Foo {f: 3};\n-    if some_condition() {\n-        let y = &x.f;      // -+ L\n-        return *y;         //  |\n-    }                      // -+\n-    x = box Foo {f: 4};\n-    // ...\n-# return 0;\n+```rust\n+{\n+    let x = box 5i;\n }\n-~~~\n-\n-Here, the interior of the variable `x` is being borrowed\n-and `x` is declared as mutable. However, the compiler can prove that\n-`x` is not assigned anywhere in the lifetime L of the variable\n-`y`. Therefore, it accepts the function, even though `x` is mutable\n-and in fact is mutated later in the function.\n-\n-It may not be clear why we are so concerned about mutating a borrowed\n-variable. The reason is that the runtime system frees any box\n-_as soon as its owning reference changes or goes out of\n-scope_. Therefore, a program like this is illegal (and would be\n-rejected by the compiler):\n-\n-~~~ {.ignore}\n-fn example3() -> int {\n-    let mut x = box X {f: 3};\n-    let y = &x.f;\n-    x = box X {f: 4};  // Error reported here.\n-    *y\n+```\n+\n+The `box` keyword creates a `Box<T>` (specifically `Box<int>` in this case) by\n+allocating a small segment of memory on the heap with enough space to fit an\n+`int`. But where in the code is the box deallocated? We said before that we\n+must have a deallocation for each allocation. Rust handles this for you. It\n+knows that our handle, `x`, is the owning reference to our box. Rust knows that\n+`x` will go out of scope at the end of the block, and so it inserts a call to\n+deallocate the memory at the end of the scope. Because the compiler does this\n+for us, it's impossible to forget. We always exaclty one deallocations paired\n+with each of our allocations.\n+\n+This is pretty straightforward, but what happens when we want to pass our box\n+to a function? Let's look at some code:\n+\n+```rust\n+fn main() {\n+    let x = box 5i;\n+\n+    add_one(x);\n }\n-~~~\n-\n-To make this clearer, consider this diagram showing the state of\n-memory immediately before the re-assignment of `x`:\n-\n-~~~ {.text}\n-    Stack               Exchange Heap\n-\n-  x +-------------+\n-    | box {f:int} | ----+\n-  y +-------------+     |\n-    | &int        | ----+\n-    +-------------+     |    +---------+\n-                        +--> |  f: 3   |\n-                             +---------+\n-~~~\n-\n-Once the reassignment occurs, the memory will look like this:\n-\n-~~~ {.text}\n-    Stack               Exchange Heap\n-\n-  x +-------------+          +---------+\n-    | box {f:int} | -------> |  f: 4   |\n-  y +-------------+          +---------+\n-    | &int        | ----+\n-    +-------------+     |    +---------+\n-                        +--> | (freed) |\n-                             +---------+\n-~~~\n-\n-Here you can see that the variable `y` still points at the old `f`\n-property of Foo, which has been freed.\n-\n-In fact, the compiler can apply the same kind of reasoning to any\n-memory that is (uniquely) owned by the stack frame. So we could\n-modify the previous example to introduce additional owned pointers\n-and structs, and the compiler will still be able to detect possible\n-mutations. This time, we'll use an analogy to illustrate the concept.\n-\n-~~~ {.ignore}\n-fn example3() -> int {\n-    struct House { owner: Box<Person> }\n-    struct Person { age: int }\n-\n-    let mut house = box House {\n-        owner: box Person {age: 30}\n-    };\n-\n-    let owner_age = &house.owner.age;\n-    house = box House {owner: box Person {age: 40}};  // Error reported here.\n-    house.owner = box Person {age: 50};               // Error reported here.\n-    *owner_age\n+\n+fn add_one(mut num: Box<int>) {\n+    *num += 1;\n }\n-~~~\n-\n-In this case, two errors are reported, one when the variable `house` is\n-modified and another when `house.owner` is modified. Either modification would\n-invalidate the pointer `owner_age`.\n-\n-# Borrowing and enums\n-\n-The previous example showed that the type system forbids any mutations\n-of owned boxed values while they are being borrowed. In general, the type\n-system also forbids borrowing a value as mutable if it is already being\n-borrowed - either as a mutable reference or an immutable one. This restriction\n-prevents pointers from pointing into freed memory. There is one other\n-case where the compiler must be very careful to ensure that pointers\n-remain valid: pointers into the interior of an `enum`.\n-\n-Let\u2019s look at the following `shape` type that can represent both rectangles\n-and circles:\n-\n-~~~\n-struct Point {x: f64, y: f64}; // as before\n-struct Size {w: f64, h: f64}; // as before\n-enum Shape {\n-    Circle(Point, f64),   // origin, radius\n-    Rectangle(Point, Size)  // upper-left, dimensions\n+```\n+\n+This code works, but it's not ideal. For example, let's add one more line of\n+code, where we print out the value of `x`:\n+\n+```{rust,ignore}\n+fn main() {\n+    let x = box 5i;\n+\n+    add_one(x);\n+\n+    println!(\"{}\", x);\n }\n-~~~\n-\n-Now we might write a function to compute the area of a shape. This\n-function takes a reference to a shape, to avoid the need for\n-copying.\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-fn compute_area(shape: &Shape) -> f64 {\n-    match *shape {\n-        Shape::Circle(_, radius) => std::f64::consts::PI * radius * radius,\n-        Shape::Rectangle(_, ref size) => size.w * size.h\n-    }\n+\n+fn add_one(mut num: Box<int>) {\n+    *num += 1;\n }\n-~~~\n-\n-The first case matches against circles. Here, the pattern extracts the\n-radius from the shape variant and the action uses it to compute the\n-area of the circle.\n-\n-The second match is more interesting. Here we match against a\n-rectangle and extract its size: but rather than copy the `size`\n-struct, we use a by-reference binding to create a pointer to it. In\n-other words, a pattern binding like `ref size` binds the name `size`\n-to a pointer of type `&size` into the _interior of the enum_.\n-\n-To make this more clear, let's look at a diagram of memory layout in\n-the case where `shape` points at a rectangle:\n-\n-~~~ {.text}\n-Stack             Memory\n-\n-+-------+         +---------------+\n-| shape | ------> | rectangle(    |\n-+-------+         |   {x: f64,    |\n-| size  | -+      |    y: f64},   |\n-+-------+  +----> |   {w: f64,    |\n-                  |    h: f64})   |\n-                  +---------------+\n-~~~\n-\n-Here you can see that rectangular shapes are composed of five words of\n-memory. The first is a tag indicating which variant this enum is\n-(`rectangle`, in this case). The next two words are the `x` and `y`\n-fields for the point and the remaining two are the `w` and `h` fields\n-for the size. The binding `size` is then a pointer into the inside of\n-the shape.\n-\n-Perhaps you can see where the danger lies: if the shape were somehow\n-to be reassigned, perhaps to a circle, then although the memory used\n-to store that shape value would still be valid, _it would have a\n-different type_! The following diagram shows what memory would look\n-like if code overwrote `shape` with a circle:\n-\n-~~~ {.text}\n-Stack             Memory\n-\n-+-------+         +---------------+\n-| shape | ------> | circle(       |\n-+-------+         |   {x: f64,    |\n-| size  | -+      |    y: f64},   |\n-+-------+  +----> |   f64)        |\n-                  |               |\n-                  +---------------+\n-~~~\n-\n-As you can see, the `size` pointer would be pointing at a `f64`\n-instead of a struct. This is not good: dereferencing the second field\n-of a `f64` as if it were a struct with two fields would be a memory\n-safety violation.\n-\n-So, in fact, for every `ref` binding, the compiler will impose the\n-same rules as the ones we saw for borrowing the interior of an owned\n-box: it must be able to guarantee that the `enum` will not be\n-overwritten for the duration of the borrow.  In fact, the compiler\n-would accept the example we gave earlier. The example is safe because\n-the shape pointer has type `&Shape`, which means \"reference to\n-immutable memory containing a `shape`\". If, however, the type of that\n-pointer were `&mut Shape`, then the ref binding would be ill-typed.\n-Just as with owned boxes, the compiler will permit `ref` bindings\n-into data owned by the stack frame even if the data are mutable,\n-but otherwise it requires that the data reside in immutable memory.\n-\n-# Returning references\n-\n-So far, all of the examples we have looked at, use references in a\n-\u201cdownward\u201d direction. That is, a method or code block creates a\n-reference, then uses it within the same scope. It is also\n-possible to return references as the result of a function, but\n-as we'll see, doing so requires some explicit annotation.\n-\n-We could write a subroutine like this:\n-\n-~~~\n-struct Point {x: f64, y: f64}\n-fn get_x<'r>(p: &'r Point) -> &'r f64 { &p.x }\n-~~~\n-\n-Here, the function `get_x()` returns a pointer into the structure it\n-was given. The type of the parameter (`&'r Point`) and return type\n-(`&'r f64`) both use a new syntactic form that we have not seen so\n-far.  Here the identifier `r` names the lifetime of the pointer\n-explicitly. So in effect, this function declares that it takes a\n-pointer with lifetime `r` and returns a pointer with that same\n-lifetime.\n-\n-In general, it is only possible to return references if they\n-are derived from a parameter to the procedure. In that case, the\n-pointer result will always have the same lifetime as one of the\n-parameters; named lifetimes indicate which parameter that\n-is.\n-\n-In the previous code samples, function parameter types did not include a\n-lifetime name. The compiler simply creates a fresh name for the lifetime\n-automatically: that is, the lifetime name is guaranteed to refer to a distinct\n-lifetime from the lifetimes of all other parameters.\n-\n-Named lifetimes that appear in function signatures are conceptually\n-the same as the other lifetimes we have seen before, but they are a bit\n-abstract: they don\u2019t refer to a specific expression within `get_x()`,\n-but rather to some expression within the *caller of `get_x()`*.  The\n-lifetime `r` is actually a kind of *lifetime parameter*: it is defined\n-by the caller to `get_x()`, just as the value for the parameter `p` is\n-defined by that caller.\n-\n-In any case, whatever the lifetime of `r` is, the pointer produced by\n-`&p.x` always has the same lifetime as `p` itself: a pointer to a\n-field of a struct is valid as long as the struct is valid. Therefore,\n-the compiler accepts the function `get_x()`.\n-\n-In general, if you borrow a struct or box to create a\n-reference, it will only be valid within the function\n-and cannot be returned. This is why the typical way to return references\n-is to take references as input (the only other case in\n-which it can be legal to return a reference is if it\n-points at a static constant).\n-\n-# Named lifetimes\n-\n-Lifetimes can be named and referenced. For example, the special lifetime\n-`'static`, which does not go out of scope, can be used to create global\n-variables and communicate between tasks (see the manual for use cases).\n-\n-## Parameter Lifetimes\n-\n-Named lifetimes allow for grouping of parameters by lifetime.\n-For example, consider this function:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, T>(shape: &'r Shape, threshold: f64,\n-                 a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n+```\n+\n+This does not compile, and gives us an error:\n+\n+```{notrust,ignore}\n+error: use of moved value: `x`\n+   println!(\"{}\", x);\n+                  ^\n+```\n+\n+Remember, we need one deallocation for every allocation. When we try to pass\n+our box to `add_one`, we would have two handles to the memory: `x` in `main`,\n+and `num` in `add_one`. If we deallocated the memory when each handle went out\n+of scope, we would have two deallocations and one allocation, and that's wrong.\n+So when we call `add_one`, Rust defines `num` as the owner of the handle. And\n+so, now that we've given ownership to `num`, `x` is invalid. `x`'s value has\n+\"moved\" from `x` to `num`. Hence the error: use of moved value `x`.\n+\n+To fix this, we can have `add_one` give ownership back when it's done with the\n+box:\n+\n+```rust\n+fn main() {\n+    let x = box 5i;\n+\n+    let y = add_one(x);\n+\n+    println!(\"{}\", y);\n }\n-~~~\n-\n-This function takes three references and assigns each the same\n-lifetime `r`.  In practice, this means that, in the caller, the\n-lifetime `r` will be the *intersection of the lifetime of the three\n-region parameters*. This may be overly conservative, as in this\n-example:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-# fn select<'r, T>(shape: &Shape, threshold: f64,\n-#                  a: &'r T, b: &'r T) -> &'r T {\n-#     if compute_area(shape) > threshold {a} else {b}\n+\n+fn add_one(mut num: Box<int>) -> Box<int> {\n+    *num += 1;\n+\n+    num\n+}\n+```\n+\n+This code will compile and run just fine. Now, we return a `box`, and so the\n+ownership is transferred back to `y` in `main`. We only have ownership for the\n+duration of our function before giving it back. This pattern is very common,\n+and so Rust introduces a concept to describe a handle which temporarily refers\n+to something another handle owns. It's called \"borrowing,\" and it's done with\n+\"references\", designated by the `&` symbol.\n+\n+# Borrowing\n+\n+Here's the current state of our `add_one` function:\n+\n+```rust\n+fn add_one(mut num: Box<int>) -> Box<int> {\n+    *num += 1;\n+\n+    num\n+}\n+```\n+\n+This function takes ownership, because it takes a `Box`, which owns its\n+contents. But then we give ownership right back.\n+\n+In the physical world, you can give one of your possessions to someone for a\n+short period of time. You still own your posession, you're just letting someone\n+else use it for a while. We call that 'lending' something to someone, and that\n+person is said to be 'borrowing' that something from you.\n+\n+Rust's ownershp system also allows an owner to lend out a handle for a limited\n+period. This is also called 'borrowing.' Here's a version of `add_one` which\n+borrows its argument rather than taking ownership:\n+\n+```rust\n+fn add_one(num: &mut int) {\n+    *num += 1;\n+}\n+```\n+\n+This function borrows an `int` from its caller, and then increments it. When\n+the function is over, and `num` goes out of scope, the borrow is over.\n+\n+# Lifetimes\n+\n+Lending out a reference to a resource that someone else owns can be\n+complicated, however. For example, imagine this set of operations:\n+\n+1. I aquire a handle to some kind of resource.\n+2. I lend you a reference to the resource.\n+3. I decide I'm done with the resource, and deallocate it, while you still have\n+   your reference.\n+4. You decide to use the resource.\n+\n+Uh oh! Your reference is pointing to an invalid resource. This is called a\n+\"dangling pointer\" or \"use after free,\" when the resource is memory.\n+\n+To fix this, we have to make sure that step four never happens after step\n+three. The ownership system in Rust does this through a concept called\n+\"lifetimes,\" which describe the scope that a reference is valid for.\n+\n+Let's look at that function which borrows an `int` again:\n+\n+```rust\n+fn add_one(num: &int) -> int {\n+    *num + 1\n+}\n+```\n+\n+Rust has a feature called 'lifetime elision,' which allows you to not write\n+lifetime annotations in certain circumstances. This is one of them. Without\n+eliding the liftimes, `add_one` looks like this:\n+\n+```rust\n+fn add_one<'a>(num: &'a int) -> int {\n+    *num + 1\n+}\n+```\n+\n+The `'a` is called a **lifetime**. Most lifetimes are used in places where\n+short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n+have more descriptive names. Let's dig into the syntax in a bit more detail:\n+\n+```{rust,ignore}\n+fn add_one<'a>(...)\n+```\n+\n+This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n+`'a`. If we had two, it would look like this:\n+\n+```{rust,ignore}\n+fn add_two<'a, 'b>(...)\n+```\n+\n+Then in our parameter list, we use the liftimes we've named:\n+\n+```{rust,ignore}\n+...(num: &'a int) -> ...\n+```\n+\n+If you compare `&int` to `&'a int`, they're the same, it's just that the\n+lifetime `'a` has snuck in between the `&` and the `int`. We read `&int` as \"a\n+reference to an int\" and `&'a int` as \"a reference to an int with the lifetime 'a.'\"\n+\n+Why do lifetimes matter? Well, for example, here's some code:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a int,\n+}\n+\n+fn main() {\n+    let y = &5i; // this is the same as `let _y = 5; let y = &_y;\n+    let f = Foo { x: y };\n+\n+    println!(\"{}\", f.x);\n+}\n+```\n+\n+As you can see, `struct`s can also have liftimes. In a similar way to functions,\n+\n+```{rust}\n+struct Foo<'a> {\n+# x: &'a int,\n # }\n-                                                            // -+ r\n-fn select_based_on_unit_circle<'r, T>(                      //  |-+ B\n-    threshold: f64, a: &'r T, b: &'r T) -> &'r T {          //  | |\n-                                                            //  | |\n-    let shape = Shape::Circle(Point {x: 0., y: 0.}, 1.);    //  | |\n-    select(&shape, threshold, a, b)                         //  | |\n-}                                                           //  |-+\n-                                                            // -+\n-~~~\n-\n-In this call to `select()`, the lifetime of the first parameter shape\n-is B, the function body. Both of the second two parameters `a` and `b`\n-share the same lifetime, `r`, which is a lifetime parameter of\n-`select_based_on_unit_circle()`. The caller will infer the\n-intersection of these two lifetimes as the lifetime of the returned\n-value, and hence the return value of `select()` will be assigned a\n-lifetime of B. This will in turn lead to a compilation error, because\n-`select_based_on_unit_circle()` is supposed to return a value with the\n-lifetime `r`.\n-\n-To address this, we can modify the definition of `select()` to\n-distinguish the lifetime of the first parameter from the lifetime of\n-the latter two. After all, the first parameter is not being\n-returned. Here is how the new `select()` might look:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n+```\n+\n+declares a lifetime, and\n+\n+```rust\n+# struct Foo<'a> {\n+x: &'a int,\n # }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, 'tmp, T>(shape: &'tmp Shape, threshold: f64,\n-                       a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n+```\n+\n+uses it. So why do we need a liftime here? We need to ensure that any reference\n+to a `Foo` cannot outlive the reference to an `int` it contains.\n+\n+## Thinking in scopes\n+\n+A way to think about lifetimes is to visualize the scope that a reference is\n+valid for. For example:\n+\n+```rust\n+fn main() {\n+    let y = &5i;    // -+ y goes into scope\n+                    //  |\n+    // stuff        //  |\n+                    //  |\n+}                   // -+ y goes out of scope\n+```\n+\n+Adding in our `Foo`:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a int,\n }\n-~~~\n-\n-Here you can see that `shape`'s lifetime is now named `tmp`. The\n-parameters `a`, `b`, and the return value all have the lifetime `r`.\n-However, since the lifetime `tmp` is not returned, it would be more\n-concise to just omit the named lifetime for `shape` altogether:\n-\n-~~~\n-# struct Point {x: f64, y: f64}; // as before\n-# struct Size {w: f64, h: f64}; // as before\n-# enum Shape {\n-#     Circle(Point, f64),   // origin, radius\n-#     Rectangle(Point, Size)  // upper-left, dimensions\n-# }\n-# fn compute_area(shape: &Shape) -> f64 { 0.0 }\n-fn select<'r, T>(shape: &Shape, threshold: f64,\n-                 a: &'r T, b: &'r T) -> &'r T {\n-    if compute_area(shape) > threshold {a} else {b}\n+\n+fn main() {\n+    let y = &5i;          // -+ y goes into scope\n+    let f = Foo { x: y }; // -+ f goes into scope\n+    // stuff              //  |\n+                          //  |\n+}                         // -+ f & y go out of scope\n+```\n+\n+Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n+This code won't work:\n+\n+```{rust,ignore}\n+struct Foo<'a> {\n+    x: &'a int,\n+}\n+\n+fn main() {\n+    let x;                    // -+ x goes into scope\n+                              //  |\n+    {                         //  |\n+        let y = &5i;          // ---+ y goes into scope\n+        let f = Foo { x: y }; // ---+ f goes into scope\n+\tx = &f.x;\t      //  | | error here\n+    }                         // ---+ f & y go out of scope\n+                              //  |\n+    println!(\"{}\", x);        //  |\n+}                             // -+ x goes out of scope\n+```\n+\n+Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n+of `x`. But when we do `x = &f.x`, we make `x` a reference to something that's\n+about to go out of scope.\n+\n+Named lifetimes are a way of giving these scopes a name. Giving something a\n+name is the first step towards being able to talk about it.\n+\n+## 'static\n+\n+The lifetime named 'static' is a special lifetime. It signals that something\n+has the lifetime of the entire program. Most Rust programmers first come across\n+`'static` when dealing with strings:\n+\n+```rust\n+let x: &'static str = \"Hello, world.\";\n+```\n+\n+String literals have the type `&'static str` because the reference is always\n+alive: they are baked into the data segment of the final binary. Another\n+example are globals:\n+\n+```rust\n+static FOO: int = 5i;\n+let x: &'static int = &FOO;\n+```\n+\n+This adds an `int` to the data segment of the binary, and FOO is a reference to\n+it.\n+\n+# Shared Ownership\n+\n+In all the examples we've considered so far, we've assumed that each handle has\n+a singular owner. But sometimes, this doesn't work. Consider a car. Cars have\n+four wheels. We would want a wheel to know which car it was attached to. But\n+this won't work:\n+\n+```{rust,ignore}\n+struct Car {\n+    name: String,\n+}\n+\n+struct Wheel {\n+    size: int,\n+    owner: Car,\n }\n-~~~\n \n-This is equivalent to the previous definition.\n+fn main() {\n+    let car = Car { name: \"DeLorian\".to_string() };\n+\n+    for _ in range(0u, 4) {\n+        Wheel { size: 360, owner: car };\n+    }\n+}\n+```\n+\n+We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n+compiler knows that on the second iteration of the loop, there's a problem:\n+\n+```{notrust,ignore}\n+error: use of moved value: `car`\n+    Wheel { size: 360, owner: car };\n+                              ^~~\n+note: `car` moved here because it has type `Car`, which is non-copyable\n+    Wheel { size: 360, owner: car };\n+                              ^~~\n+```\n+\n+We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n+`Box<T>`, because it has a single owner. We can do t with `Rc<T>` instead:\n+\n+```rust\n+use std::rc::Rc;\n+\n+struct Car {\n+    name: String,\n+}\n+\n+struct Wheel {\n+    size: int,\n+    owner: Rc<Car>,\n+}\n \n-## Labeled Control Structures\n+fn main() {\n+    let car = Car { name: \"DeLorian\".to_string() };\n \n-Named lifetime notation can also be used to control the flow of execution:\n+    let car_owner = Rc::new(car);\n \n-~~~\n-'h: for i in range(0u, 10) {\n-    'g: loop {\n-        if i % 2 == 0 { continue 'h; }\n-        if i == 9 { break 'h; }\n-        break 'g;\n+    for _ in range(0u, 4) {\n+        Wheel { size: 360, owner: car_owner.clone() };\n     }\n }\n-~~~\n+```\n \n-> *Note:* Labelled breaks are not currently supported within `while` loops.\n+We wrap our `Car` in an `Rc<T>`, getting an `Rc<Car>`, and then use the\n+`clone()` method to make new references. We've also changed our `Wheel` to have\n+an `Rc<Car>` rather than just a `Car`.\n \n-Named labels are hygienic and can be used safely within macros.\n-See the macros guide section on hygiene for more details.\n+This is the simplest kind of multiple ownership possible. For example, there's\n+also `Arc<T>`, which uses more expensive atomic instructions to be the\n+thread-safe counterpart of `Rc<T>`.\n \n-# Conclusion\n+# Related Resources\n \n-So there you have it: a (relatively) brief tour of the lifetime\n-system. For more details, we refer to the (yet to be written) reference\n-document on references, which will explain the full notation\n-and give more examples.\n+Coming Soon."}]}