{"sha": "9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNjMzMzBiNmQ4NzIwZWY5YTZmZDBkZjQyYzA2ZWE0OTE1OTgxZDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T10:23:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:41Z"}, "message": "region_inference: tighten up `pub`, stop re-exporting enum variants", "tree": {"sha": "a42ad0c3d11e0928d32d46b935b89c488b2cda96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a42ad0c3d11e0928d32d46b935b89c488b2cda96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "html_url": "https://github.com/rust-lang/rust/commit/9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef5de07fc5b62ddd914c710a47d4a6be9a4f77cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5de07fc5b62ddd914c710a47d4a6be9a4f77cc", "html_url": "https://github.com/rust-lang/rust/commit/ef5de07fc5b62ddd914c710a47d4a6be9a4f77cc"}], "stats": {"total": 157, "additions": 75, "deletions": 82}, "files": [{"sha": "072f76eb6aa8da973c6314f1c9f1b30a120306fc", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "patch": "@@ -57,8 +57,7 @@\n \n use infer;\n use super::{InferCtxt, TypeTrace, SubregionOrigin, RegionVariableOrigin, ValuePairs};\n-use super::region_inference::{RegionResolutionError, ConcreteFailure, SubSupConflict,\n-                              GenericBoundFailure, GenericKind};\n+use super::region_inference::{RegionResolutionError, GenericKind};\n \n use std::fmt;\n use hir;\n@@ -293,33 +292,37 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             debug!(\"report_region_errors: error = {:?}\", error);\n \n             if !self.try_report_named_anon_conflict(&error) &&\n-               !self.try_report_anon_anon_conflict(&error) {\n-\n-               match error.clone() {\n-                  // These errors could indicate all manner of different\n-                  // problems with many different solutions. Rather\n-                  // than generate a \"one size fits all\" error, what we\n-                  // attempt to do is go through a number of specific\n-                  // scenarios and try to find the best way to present\n-                  // the error. If all of these fails, we fall back to a rather\n-                  // general bit of code that displays the error information\n-                  ConcreteFailure(origin, sub, sup) => {\n-                      self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n-                  }\n-\n-                  GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(region_scope_tree, kind, param_ty, sub);\n-                  }\n-\n-                  SubSupConflict(var_origin, sub_origin, sub_r, sup_origin, sup_r) => {\n+                !self.try_report_anon_anon_conflict(&error)\n+            {\n+                match error.clone() {\n+                    // These errors could indicate all manner of different\n+                    // problems with many different solutions. Rather\n+                    // than generate a \"one size fits all\" error, what we\n+                    // attempt to do is go through a number of specific\n+                    // scenarios and try to find the best way to present\n+                    // the error. If all of these fails, we fall back to a rather\n+                    // general bit of code that displays the error information\n+                    RegionResolutionError::ConcreteFailure(origin, sub, sup) => {\n+                        self.report_concrete_failure(region_scope_tree, origin, sub, sup).emit();\n+                    }\n+\n+                    RegionResolutionError::GenericBoundFailure(kind, param_ty, sub) => {\n+                        self.report_generic_bound_failure(region_scope_tree, kind, param_ty, sub);\n+                    }\n+\n+                    RegionResolutionError::SubSupConflict(var_origin,\n+                                                          sub_origin,\n+                                                          sub_r,\n+                                                          sup_origin,\n+                                                          sup_r) => {\n                         self.report_sub_sup_conflict(region_scope_tree,\n                                                      var_origin,\n                                                      sub_origin,\n                                                      sub_r,\n                                                      sup_origin,\n                                                      sup_r);\n-                  }\n-               }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -351,9 +354,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // the only thing in the list.\n \n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n-            ConcreteFailure(..) => false,\n-            SubSupConflict(..) => false,\n-            GenericBoundFailure(..) => true,\n+            RegionResolutionError::GenericBoundFailure(..) => true,\n+            RegionResolutionError::ConcreteFailure(..) |\n+            RegionResolutionError::SubSupConflict(..) => false,\n         };\n \n \n@@ -365,9 +368,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // sort the errors by span, for better error message stability.\n         errors.sort_by_key(|u| match *u {\n-            ConcreteFailure(ref sro, _, _) => sro.span(),\n-            GenericBoundFailure(ref sro, _, _) => sro.span(),\n-            SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n+            RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n+            RegionResolutionError::SubSupConflict(ref rvo, _, _, _, _) => rvo.span(),\n         });\n         errors\n     }"}, {"sha": "403ff3c4dfa218671987eac7edc69e9267bd4ff5", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "patch": "@@ -212,13 +212,13 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n-        Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n+        Constraint::VarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainRegSubVar(r_1, rv_2) =>\n+        Constraint::RegSubVar(r_1, rv_2) =>\n             (Node::Region(*r_1), Node::RegionVid(rv_2)),\n-        Constraint::ConstrainVarSubReg(rv_1, r_2) =>\n+        Constraint::VarSubReg(rv_1, r_2) =>\n             (Node::RegionVid(rv_1), Node::Region(*r_2)),\n-        Constraint::ConstrainRegSubReg(r_1, r_2) =>\n+        Constraint::RegSubReg(r_1, r_2) =>\n             (Node::Region(*r_1), Node::Region(*r_2)),\n     }\n }"}, {"sha": "682f5743e4bff8e7768f6b0a1fd3b589ca53c8a3", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "patch": "@@ -12,7 +12,6 @@\n \n use infer::SubregionOrigin;\n use infer::region_inference::Constraint;\n-use infer::region_inference::Constraint::*;\n use infer::region_inference::RegionVarBindings;\n use infer::region_inference::RegionResolutionError;\n use infer::region_inference::VarValue;\n@@ -230,18 +229,18 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n-                ConstrainRegSubVar(a_region, b_vid) => {\n+                Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = &mut var_values[b_vid.index as usize];\n                     self.expand_node(region_rels, a_region, b_vid, b_data)\n                 }\n-                ConstrainVarSubVar(a_vid, b_vid) => match var_values[a_vid.index as usize] {\n+                Constraint::VarSubVar(a_vid, b_vid) => match var_values[a_vid.index as usize] {\n                     VarValue::ErrorValue => false,\n                     VarValue::Value(a_region) => {\n                         let b_node = &mut var_values[b_vid.index as usize];\n                         self.expand_node(region_rels, a_region, b_vid, b_node)\n                     }\n                 },\n-                ConstrainRegSubReg(..) | ConstrainVarSubReg(..) => {\n+                Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n                     false\n@@ -311,11 +310,11 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 origin\n             );\n             match *constraint {\n-                ConstrainRegSubVar(..) | ConstrainVarSubVar(..) => {\n+                Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n                 }\n \n-                ConstrainRegSubReg(sub, sup) => {\n+                Constraint::RegSubReg(sub, sup) => {\n                     if region_rels.is_subregion_of(sub, sup) {\n                         continue;\n                     }\n@@ -331,7 +330,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     errors.push(RegionResolutionError::ConcreteFailure((*origin).clone(), sub, sup));\n                 }\n \n-                ConstrainVarSubReg(a_vid, b_region) => {\n+                Constraint::VarSubReg(a_vid, b_region) => {\n                     let a_data = &mut var_data[a_vid.index as usize];\n                     debug!(\"contraction: {:?} == {:?}, {:?}\", a_vid, a_data, b_region);\n \n@@ -473,20 +472,20 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         for (constraint, _) in constraints.iter() {\n             match *constraint {\n-                ConstrainVarSubVar(a_id, b_id) => {\n+                Constraint::VarSubVar(a_id, b_id) => {\n                     graph.add_edge(\n                         NodeIndex(a_id.index as usize),\n                         NodeIndex(b_id.index as usize),\n                         *constraint,\n                     );\n                 }\n-                ConstrainRegSubVar(_, b_id) => {\n+                Constraint::RegSubVar(_, b_id) => {\n                     graph.add_edge(dummy_source, NodeIndex(b_id.index as usize), *constraint);\n                 }\n-                ConstrainVarSubReg(a_id, _) => {\n+                Constraint::VarSubReg(a_id, _) => {\n                     graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n                 }\n-                ConstrainRegSubReg(..) => {\n+                Constraint::RegSubReg(..) => {\n                     // this would be an edge from `dummy_source` to\n                     // `dummy_sink`; just ignore it.\n                 }\n@@ -624,7 +623,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             let source_node_index = NodeIndex(source_vid.index as usize);\n             for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n-                    ConstrainVarSubVar(from_vid, to_vid) => {\n+                    Constraint::VarSubVar(from_vid, to_vid) => {\n                         let opp_vid = if from_vid == source_vid {\n                             to_vid\n                         } else {\n@@ -635,14 +634,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                         }\n                     }\n \n-                    ConstrainRegSubVar(region, _) | ConstrainVarSubReg(_, region) => {\n+                    Constraint::RegSubVar(region, _) | Constraint::VarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region,\n                             origin: this.constraints.borrow().get(&edge.data).unwrap().clone(),\n                         });\n                     }\n \n-                    ConstrainRegSubReg(..) => panic!(\n+                    Constraint::RegSubReg(..) => panic!(\n                         \"cannot reach reg-sub-reg edge in region inference \\\n                          post-processing\"\n                     ),"}, {"sha": "ef888ea4b9f0106dab115c0a04a65ae03ab3a479", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d63330b6d8720ef9a6fd0df42c06ea4915981d1/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=9d63330b6d8720ef9a6fd0df42c06ea4915981d1", "patch": "@@ -10,11 +10,8 @@\n \n //! See README.md\n \n-pub use self::Constraint::*;\n-pub use self::UndoLogEntry::*;\n-pub use self::CombineMapType::*;\n-pub use self::RegionResolutionError::*;\n-pub use self::VarValue::*;\n+use self::UndoLogEntry::*;\n+use self::CombineMapType::*;\n \n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n@@ -36,20 +33,20 @@ use std::u32;\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n pub enum Constraint<'tcx> {\n     /// One region variable is subregion of another\n-    ConstrainVarSubVar(RegionVid, RegionVid),\n+    VarSubVar(RegionVid, RegionVid),\n \n     /// Concrete region is subregion of region variable\n-    ConstrainRegSubVar(Region<'tcx>, RegionVid),\n+    RegSubVar(Region<'tcx>, RegionVid),\n \n     /// Region variable is subregion of concrete region. This does not\n     /// directly affect inference, but instead is checked after\n     /// inference is complete.\n-    ConstrainVarSubReg(RegionVid, Region<'tcx>),\n+    VarSubReg(RegionVid, Region<'tcx>),\n \n     /// A constraint where neither side is a variable. This does not\n     /// directly affect inference, but instead is checked after\n     /// inference is complete.\n-    ConstrainRegSubReg(Region<'tcx>, Region<'tcx>),\n+    RegSubReg(Region<'tcx>, Region<'tcx>),\n }\n \n /// VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n@@ -98,13 +95,13 @@ pub enum VerifyBound<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TwoRegions<'tcx> {\n+struct TwoRegions<'tcx> {\n     a: Region<'tcx>,\n     b: Region<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum UndoLogEntry<'tcx> {\n+enum UndoLogEntry<'tcx> {\n     /// Pushed when we start a snapshot.\n     OpenSnapshot,\n \n@@ -138,7 +135,7 @@ pub enum UndoLogEntry<'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum CombineMapType {\n+enum CombineMapType {\n     Lub,\n     Glb,\n }\n@@ -168,19 +165,13 @@ pub enum RegionResolutionError<'tcx> {\n                    Region<'tcx>),\n }\n \n-#[derive(Clone, Debug)]\n-pub enum ProcessedErrorOrigin<'tcx> {\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n-    VariableFailure(RegionVariableOrigin),\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum VarValue<'tcx> {\n     Value(Region<'tcx>),\n     ErrorValue,\n }\n \n-pub type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n+type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub(in infer) tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -426,7 +417,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n-    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry<'tcx>) {\n+    fn rollback_undo_entry(&self, undo_entry: UndoLogEntry<'tcx>) {\n         match undo_entry {\n             OpenSnapshot => {\n                 panic!(\"Failure to observe stack discipline\");\n@@ -578,13 +569,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                                  undo_entry: &UndoLogEntry<'tcx>)\n                                  -> bool {\n             match undo_entry {\n-                &AddConstraint(ConstrainVarSubVar(..)) =>\n+                &AddConstraint(Constraint::VarSubVar(..)) =>\n                     false,\n-                &AddConstraint(ConstrainRegSubVar(a, _)) =>\n+                &AddConstraint(Constraint::RegSubVar(a, _)) =>\n                     skols.contains(&a),\n-                &AddConstraint(ConstrainVarSubReg(_, b)) =>\n+                &AddConstraint(Constraint::VarSubReg(_, b)) =>\n                     skols.contains(&b),\n-                &AddConstraint(ConstrainRegSubReg(a, b)) =>\n+                &AddConstraint(Constraint::RegSubReg(a, b)) =>\n                     skols.contains(&a) || skols.contains(&b),\n                 &AddGiven(..) =>\n                     false,\n@@ -725,16 +716,16 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // all regions are subregions of static, so we can ignore this\n             }\n             (&ReVar(sub_id), &ReVar(sup_id)) => {\n-                self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n+                self.add_constraint(Constraint::VarSubVar(sub_id, sup_id), origin);\n             }\n             (_, &ReVar(sup_id)) => {\n-                self.add_constraint(ConstrainRegSubVar(sub, sup_id), origin);\n+                self.add_constraint(Constraint::RegSubVar(sub, sup_id), origin);\n             }\n             (&ReVar(sub_id), _) => {\n-                self.add_constraint(ConstrainVarSubReg(sub_id, sup), origin);\n+                self.add_constraint(Constraint::VarSubReg(sub_id, sup), origin);\n             }\n             _ => {\n-                self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n+                self.add_constraint(Constraint::RegSubReg(sub, sup), origin);\n             }\n         }\n     }\n@@ -817,13 +808,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn combine_vars<F>(&self,\n-                           t: CombineMapType,\n-                           a: Region<'tcx>,\n-                           b: Region<'tcx>,\n-                           origin: SubregionOrigin<'tcx>,\n-                           mut relate: F)\n-                           -> Region<'tcx>\n+    fn combine_vars<F>(&self,\n+                       t: CombineMapType,\n+                       a: Region<'tcx>,\n+                       b: Region<'tcx>,\n+                       origin: SubregionOrigin<'tcx>,\n+                       mut relate: F)\n+                       -> Region<'tcx>\n         where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>)\n     {\n         let vars = TwoRegions { a: a, b: b };"}]}