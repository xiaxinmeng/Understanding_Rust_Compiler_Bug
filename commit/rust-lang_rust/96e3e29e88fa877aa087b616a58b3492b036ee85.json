{"sha": "96e3e29e88fa877aa087b616a58b3492b036ee85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZTNlMjllODhmYTg3N2FhMDg3YjYxNmE1OGIzNDkyYjAzNmVlODU=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-16T23:43:29Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-16T23:43:29Z"}, "message": "Support left-justification in #fmt conversions", "tree": {"sha": "b54b028626fe283016d5358438a22f3dffd15e3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b54b028626fe283016d5358438a22f3dffd15e3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96e3e29e88fa877aa087b616a58b3492b036ee85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96e3e29e88fa877aa087b616a58b3492b036ee85", "html_url": "https://github.com/rust-lang/rust/commit/96e3e29e88fa877aa087b616a58b3492b036ee85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96e3e29e88fa877aa087b616a58b3492b036ee85/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7b68e9eddd3b637b8cd8457702354ad546f5d9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b68e9eddd3b637b8cd8457702354ad546f5d9f", "html_url": "https://github.com/rust-lang/rust/commit/f7b68e9eddd3b637b8cd8457702354ad546f5d9f"}], "stats": {"total": 107, "additions": 95, "deletions": 12}, "files": [{"sha": "241e71a8b94f2ad9396c8bd408dfc3f82b19b959", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/96e3e29e88fa877aa087b616a58b3492b036ee85/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e3e29e88fa877aa087b616a58b3492b036ee85/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=96e3e29e88fa877aa087b616a58b3492b036ee85", "patch": "@@ -78,6 +78,10 @@ fn expr_to_str(@ast.expr expr) -> str {\n     fail;\n }\n \n+// FIXME: A lot of these functions for producing expressions can probably\n+// be factored out in common with other code that builds expressions.\n+// FIXME: Probably should be using the parser's span functions\n+// FIXME: Cleanup the naming of these functions\n fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n \n     fn make_new_lit(common.span sp, ast.lit_ lit) -> @ast.expr {\n@@ -116,6 +120,12 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         ret sp_pathexpr;\n     }\n \n+    fn make_vec_expr(common.span sp, vec[@ast.expr] exprs) -> @ast.expr {\n+        auto vecexpr = ast.expr_vec(exprs, ast.imm, ast.ann_none);\n+        auto sp_vecexpr = @rec(node=vecexpr, span=sp);\n+        ret sp_vecexpr;\n+    }\n+\n     fn make_call(common.span sp, vec[ast.ident] fn_path,\n                  vec[@ast.expr] args) -> @ast.expr {\n         auto pathexpr = make_path_expr(sp, fn_path);\n@@ -149,13 +159,40 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n         ret vec(\"std\", \"ExtFmt\", \"RT\", ident);\n     }\n \n+    fn make_rt_path_expr(common.span sp, str ident) -> @ast.expr {\n+        auto path = make_path_vec(ident);\n+        ret make_path_expr(sp, path);\n+    }\n+\n+    // Produces an AST expression that represents a RT.conv record,\n+    // which tells the RT.conv* functions how to perform the conversion\n     fn make_rt_conv_expr(common.span sp, &conv cnv) -> @ast.expr {\n \n+        fn make_flags(common.span sp, vec[flag] flags) -> @ast.expr {\n+            let vec[@ast.expr] flagexprs = vec();\n+            for (flag f in flags) {\n+                alt (f) {\n+                    case (flag_left_justify) {\n+                        auto fstr = \"flag_left_justify\";\n+                        flagexprs += vec(make_rt_path_expr(sp, fstr));\n+                    }\n+                }\n+            }\n+\n+            // FIXME: 0-length vectors can't have their type inferred\n+            // through the rec that these flags are a member of, so\n+            // this is a hack placeholder flag\n+            if (_vec.len[@ast.expr](flagexprs) == 0u) {\n+                flagexprs += vec(make_rt_path_expr(sp, \"flag_none\"));\n+            }\n+\n+            ret make_vec_expr(sp, flagexprs);\n+        }\n+\n         fn make_count(common.span sp, &count cnt) -> @ast.expr {\n             alt (cnt) {\n                 case (count_implied) {\n-                    auto idents = make_path_vec(\"count_implied\");\n-                    ret make_path_expr(sp, idents);\n+                    ret make_rt_path_expr(sp, \"count_implied\");\n                 }\n                 case (count_is(?c)) {\n                     auto count_lit = make_new_int(sp, c);\n@@ -191,19 +228,23 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n                 }\n             }\n \n-            auto idents = make_path_vec(rt_type);\n-            ret make_path_expr(sp, idents);\n+            ret make_rt_path_expr(sp, rt_type);\n         }\n \n-        fn make_conv_rec(common.span sp, @ast.expr width_expr,\n+        fn make_conv_rec(common.span sp,\n+                         @ast.expr flags_expr,\n+                         @ast.expr width_expr,\n                          @ast.expr ty_expr) -> @ast.expr {\n-            ret make_rec_expr(sp, vec(tup(\"width\", width_expr),\n+            ret make_rec_expr(sp, vec(tup(\"flags\", flags_expr),\n+                                      tup(\"width\", width_expr),\n                                       tup(\"ty\", ty_expr)));\n         }\n \n+        auto rt_conv_flags = make_flags(sp, cnv.flags);\n         auto rt_conv_width = make_count(sp, cnv.width);\n         auto rt_conv_ty = make_ty(sp, cnv.ty);\n         ret make_conv_rec(sp,\n+                          rt_conv_flags,\n                           rt_conv_width,\n                           rt_conv_ty);\n     }\n@@ -230,9 +271,15 @@ fn pieces_to_expr(vec[piece] pieces, vec[@ast.expr] args) -> @ast.expr {\n             }\n         }\n \n-        if (_vec.len[flag](cnv.flags) != 0u) {\n-            log unsupported;\n-            fail;\n+        for (flag f in cnv.flags) {\n+            alt (f) {\n+                case (flag_left_justify) {\n+                }\n+                case (_) {\n+                    log unsupported;\n+                    fail;\n+                }\n+            }\n         }\n \n         alt (cnv.width) {"}, {"sha": "432e936f65fade160ab84e1ac8d7e13bdd7af0f1", "filename": "src/lib/ExtFmt.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/96e3e29e88fa877aa087b616a58b3492b036ee85/src%2Flib%2FExtFmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e3e29e88fa877aa087b616a58b3492b036ee85/src%2Flib%2FExtFmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FExtFmt.rs?ref=96e3e29e88fa877aa087b616a58b3492b036ee85", "patch": "@@ -294,6 +294,14 @@ mod CT {\n // implement it this way, I think.\n mod RT {\n \n+    tag flag {\n+        flag_left_justify;\n+        // FIXME: This is a hack to avoid creating 0-length vec exprs,\n+        // which have some difficulty typechecking currently. See\n+        // comments in front.extfmt.make_flags\n+        flag_none;\n+    }\n+\n     tag count {\n         count_is(int);\n         count_implied;\n@@ -306,7 +314,10 @@ mod RT {\n         ty_hex_lower;\n     }\n \n-    type conv = rec(count width,\n+    // FIXME: May not want to use a vector here for flags;\n+    // instead just use a bool per flag\n+    type conv = rec(vec[flag] flags,\n+                    count width,\n                     ty ty);\n \n     fn conv_int(&conv cv, int i) -> str {\n@@ -359,18 +370,33 @@ mod RT {\n                 auto strlen = _str.char_len(s);\n                 if (strlen < uwidth) {\n                     auto diff = uwidth - strlen;\n-                    // FIXME: Probably should be a _str fn for this\n+                    // FIXME: Probably should be a _str fn for\n+                    // initializing from n chars\n                     auto padvec = _vec.init_elt[u8](' ' as u8, diff);\n                     // FIXME: Using unsafe_from_bytes because rustboot\n                     // can't figure out the is_utf8 predicate on from_bytes?\n                     auto padstr = _str.unsafe_from_bytes(padvec);\n-                    ret padstr + s;\n+\n+                    if (have_flag(cv.flags, flag_left_justify)) {\n+                        ret s + padstr;\n+                    } else {\n+                        ret padstr + s;\n+                    }\n                 } else {\n                     ret s;\n                 }\n             }\n         }\n     }\n+\n+    fn have_flag(vec[flag] flags, flag f) -> bool {\n+        for (flag candidate in flags) {\n+            if (candidate == f) {\n+                ret true;\n+            }\n+        }\n+        ret false;\n+    }\n }\n \n // Local Variables:"}, {"sha": "2ffea946bc2ad1e95289debe405532328588ba1a", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96e3e29e88fa877aa087b616a58b3492b036ee85/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e3e29e88fa877aa087b616a58b3492b036ee85/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=96e3e29e88fa877aa087b616a58b3492b036ee85", "patch": "@@ -43,4 +43,14 @@ fn main() {\n   test(#fmt(\"%10x\", 0xff_u), \"        ff\");\n   test(#fmt(\"%10X\", 0xff_u), \"        FF\");\n   test(#fmt(\"%10t\", 0xff_u), \"  11111111\");\n+\n+  // Left justify\n+  test(#fmt(\"%-10d\", 500), \"500       \");\n+  test(#fmt(\"%-10d\", -500), \"-500      \");\n+  test(#fmt(\"%-10u\", 500u), \"500       \");\n+  test(#fmt(\"%-10s\", \"test\"), \"test      \");\n+  test(#fmt(\"%-10b\", true), \"true      \");\n+  test(#fmt(\"%-10x\", 0xff_u), \"ff        \");\n+  test(#fmt(\"%-10X\", 0xff_u), \"FF        \");\n+  test(#fmt(\"%-10t\", 0xff_u), \"11111111  \");\n }"}]}