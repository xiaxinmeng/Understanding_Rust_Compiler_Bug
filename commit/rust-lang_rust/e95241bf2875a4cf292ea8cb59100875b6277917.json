{"sha": "e95241bf2875a4cf292ea8cb59100875b6277917", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NTI0MWJmMjg3NWE0Y2YyOTJlYThjYjU5MTAwODc1YjYyNzc5MTc=", "commit": {"author": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2015-04-29T22:00:20Z"}, "committer": {"name": "Tamir Duberstein", "email": "tamird@gmail.com", "date": "2015-05-06T02:03:45Z"}, "message": "Don't repeat `Attribute` in the const names", "tree": {"sha": "6793d23ca3148f293c4e6204edfe7f8906d9230e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6793d23ca3148f293c4e6204edfe7f8906d9230e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e95241bf2875a4cf292ea8cb59100875b6277917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e95241bf2875a4cf292ea8cb59100875b6277917", "html_url": "https://github.com/rust-lang/rust/commit/e95241bf2875a4cf292ea8cb59100875b6277917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e95241bf2875a4cf292ea8cb59100875b6277917/comments", "author": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamird", "id": 1535036, "node_id": "MDQ6VXNlcjE1MzUwMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1535036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamird", "html_url": "https://github.com/tamird", "followers_url": "https://api.github.com/users/tamird/followers", "following_url": "https://api.github.com/users/tamird/following{/other_user}", "gists_url": "https://api.github.com/users/tamird/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamird/subscriptions", "organizations_url": "https://api.github.com/users/tamird/orgs", "repos_url": "https://api.github.com/users/tamird/repos", "events_url": "https://api.github.com/users/tamird/events{/privacy}", "received_events_url": "https://api.github.com/users/tamird/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cfa713a1c7f23fb8affc8dfaac8c44ef522f403", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cfa713a1c7f23fb8affc8dfaac8c44ef522f403", "html_url": "https://github.com/rust-lang/rust/commit/5cfa713a1c7f23fb8affc8dfaac8c44ef522f403"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "2a2aa2bf4cf93dcfc530e7e0504a4703ef050a4a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -125,32 +125,32 @@ pub enum DiagnosticSeverity {\n \n bitflags! {\n     flags Attribute : u32 {\n-        const ZExtAttribute            = 1 << 0,\n-        const SExtAttribute            = 1 << 1,\n-        const NoReturnAttribute        = 1 << 2,\n-        const InRegAttribute           = 1 << 3,\n-        const StructRetAttribute       = 1 << 4,\n-        const NoUnwindAttribute        = 1 << 5,\n-        const NoAliasAttribute         = 1 << 6,\n-        const ByValAttribute           = 1 << 7,\n-        const NestAttribute            = 1 << 8,\n-        const ReadNoneAttribute        = 1 << 9,\n-        const ReadOnlyAttribute        = 1 << 10,\n-        const NoInlineAttribute        = 1 << 11,\n-        const AlwaysInlineAttribute    = 1 << 12,\n-        const OptimizeForSizeAttribute = 1 << 13,\n-        const StackProtectAttribute    = 1 << 14,\n-        const StackProtectReqAttribute = 1 << 15,\n-        const AlignmentAttribute       = 1 << 16,\n-        const NoCaptureAttribute       = 1 << 21,\n-        const NoRedZoneAttribute       = 1 << 22,\n-        const NoImplicitFloatAttribute = 1 << 23,\n-        const NakedAttribute           = 1 << 24,\n-        const InlineHintAttribute      = 1 << 25,\n-        const StackAttribute           = 7 << 26,\n-        const ReturnsTwiceAttribute    = 1 << 29,\n-        const UWTableAttribute         = 1 << 30,\n-        const NonLazyBindAttribute     = 1 << 31,\n+        const ZExt            = 1 << 0,\n+        const SExt            = 1 << 1,\n+        const NoReturn        = 1 << 2,\n+        const InReg           = 1 << 3,\n+        const StructRet       = 1 << 4,\n+        const NoUnwind        = 1 << 5,\n+        const NoAlias         = 1 << 6,\n+        const ByVal           = 1 << 7,\n+        const Nest            = 1 << 8,\n+        const ReadNone        = 1 << 9,\n+        const ReadOnly        = 1 << 10,\n+        const NoInline        = 1 << 11,\n+        const AlwaysInline    = 1 << 12,\n+        const OptimizeForSize = 1 << 13,\n+        const StackProtect    = 1 << 14,\n+        const StackProtectReq = 1 << 15,\n+        const Alignment       = 1 << 16,\n+        const NoCapture       = 1 << 21,\n+        const NoRedZone       = 1 << 22,\n+        const NoImplicitFloat = 1 << 23,\n+        const Naked           = 1 << 24,\n+        const InlineHint      = 1 << 25,\n+        const Stack           = 7 << 26,\n+        const ReturnsTwice    = 1 << 29,\n+        const UWTable         = 1 << 30,\n+        const NonLazyBind     = 1 << 31,\n     }\n }\n "}, {"sha": "b32181426a33ef1f54db016f6af539c47fca669d", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -39,13 +39,13 @@ pub fn split_stack(val: ValueRef, set: bool) {\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHintAttribute),\n-        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInlineAttribute),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInlineAttribute),\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHint),\n+        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInline),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInline),\n         None   => {\n-            let attr = llvm::Attribute::InlineHintAttribute |\n-                       llvm::Attribute::AlwaysInlineAttribute |\n-                       llvm::Attribute::NoInlineAttribute;\n+            let attr = llvm::Attribute::InlineHint |\n+                       llvm::Attribute::AlwaysInline |\n+                       llvm::Attribute::NoInline;\n             unsafe {\n                 llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n             }\n@@ -57,12 +57,12 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n     if emit {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTableAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTable);\n     } else {\n         unsafe {\n             llvm::LLVMRemoveFunctionAttr(\n                 val,\n-                llvm::Attribute::UWTableAttribute.bits() as c_ulonglong,\n+                llvm::Attribute::UWTable.bits() as c_ulonglong,\n             );\n         }\n     }\n@@ -76,11 +76,11 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n         unsafe {\n             llvm::LLVMRemoveFunctionAttr(\n                 val,\n-                llvm::Attribute::NoUnwindAttribute.bits() as c_ulonglong,\n+                llvm::Attribute::NoUnwind.bits() as c_ulonglong,\n             );\n         }\n     } else {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwindAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwind);\n     }\n }\n \n@@ -89,12 +89,12 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n     if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSizeAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSize);\n     } else {\n         unsafe {\n             llvm::LLVMRemoveFunctionAttr(\n                 val,\n-                llvm::Attribute::OptimizeForSizeAttribute.bits() as c_ulonglong,\n+                llvm::Attribute::OptimizeForSize.bits() as c_ulonglong,\n             );\n         }\n     }\n@@ -116,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n                                                llvm::ColdAttribute as u64)\n             }\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attribute::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attribute::NoAlias.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n         }\n     }\n }\n@@ -185,9 +185,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(1, llvm::Attribute::StructRetAttribute)\n-                 .arg(1, llvm::Attribute::NoAliasAttribute)\n-                 .arg(1, llvm::Attribute::NoCaptureAttribute)\n+            attrs.arg(1, llvm::Attribute::StructRet)\n+                 .arg(1, llvm::Attribute::NoAlias)\n+                 .arg(1, llvm::Attribute::NoCapture)\n                  .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n             // Add one more since there's an outptr\n@@ -199,7 +199,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::Attribute::NoAliasAttribute);\n+                    attrs.ret(llvm::Attribute::NoAlias);\n                 }\n                 _ => {}\n             }\n@@ -216,7 +216,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             }\n \n             if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::Attribute::ZExtAttribute);\n+                attrs.ret(llvm::Attribute::ZExt);\n             }\n         }\n     }\n@@ -230,20 +230,20 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n-                     .arg(idx, llvm::Attribute::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAlias)\n+                     .arg(idx, llvm::Attribute::NoCapture)\n                      .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n \n             ty::ty_bool => {\n-                attrs.arg(idx, llvm::Attribute::ZExtAttribute);\n+                attrs.arg(idx, llvm::Attribute::ZExt);\n             }\n \n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n \n-                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAlias)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n@@ -256,23 +256,23 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n \n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAlias)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n \n                 if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::Attribute::ReadOnlyAttribute);\n+                    attrs.arg(idx, llvm::Attribute::ReadOnly);\n                 }\n \n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::Attribute::NoCaptureAttribute);\n+                    attrs.arg(idx, llvm::Attribute::NoCapture);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n             ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::Attribute::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoCapture)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n "}, {"sha": "f2434ceee2b857ee5e5fd09c3bf6037c4a55ccd3", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -163,7 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n@@ -185,12 +185,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRet))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {"}, {"sha": "c5116e738048d1f3341a034cbcd1d7f7f61679d8", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -131,7 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty, align_fn);\n@@ -145,12 +145,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRet))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = align_fn(ty);"}, {"sha": "bcffb238f5950c6d1251402a9b63f941dc635152", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -88,10 +88,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRet))\n     }\n }\n \n@@ -105,7 +105,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "1bcc8fd6bbb90e5133e416bf7712022e1b56d8c6", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -84,10 +84,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRet))\n     }\n }\n \n@@ -101,7 +101,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "50a3095dea16970d43c4b350255728c10e2897b4", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -52,11 +52,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 ret_ty = ArgType::direct(rty, Some(t), None, None);\n             }\n             RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRetAttribute));\n+                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRet));\n             }\n         }\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -67,11 +67,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 if size == 0 {\n                     ArgType::ignore(t)\n                 } else {\n-                    ArgType::indirect(t, Some(Attribute::ByValAttribute))\n+                    ArgType::indirect(t, Some(Attribute::ByVal))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "b64e24591fd98b9ec8d90a8b32990b2a724348dd", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -406,19 +406,19 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }\n \n     let mut arg_tys = Vec::new();\n     for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByVal);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRet)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}, {"sha": "262dcc4705961018d21369027ed396f630ff7ec7", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -31,10 +31,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n             4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n             8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(Attribute::StructRetAttribute))\n+            _ => ArgType::indirect(rty, Some(Attribute::StructRet))\n         };\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -46,11 +46,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                     2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n                     4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n                     8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, Some(Attribute::ByValAttribute))\n+                    _ => ArgType::indirect(t, Some(Attribute::ByVal))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "7849235fdbee5b9e044eeeafef632edf2c6063f9", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -71,12 +71,12 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturnAttribute);\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZoneAttribute)\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZone)\n     }\n \n     if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {"}, {"sha": "95c93d76585bfc5a7348b992b32ebc01bd10c053", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e95241bf2875a4cf292ea8cb59100875b6277917/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e95241bf2875a4cf292ea8cb59100875b6277917", "patch": "@@ -349,8 +349,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We also know it's nonnull as well\n         // as how many bytes we can dereference\n-        attrs.arg(1, llvm::Attribute::NoAliasAttribute)\n-             .arg(1, llvm::Attribute::NoCaptureAttribute)\n+        attrs.arg(1, llvm::Attribute::NoAlias)\n+             .arg(1, llvm::Attribute::NoCapture)\n              .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n "}]}