{"sha": "3aba50ff331f4d97b1ca2a60091b03e012837b98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYmE1MGZmMzMxZjRkOTdiMWNhMmE2MDA5MWIwM2UwMTI4MzdiOTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-18T22:52:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-02-18T22:52:33Z"}, "message": "Implement Robinson's algorithm for type unification. Closes #227.", "tree": {"sha": "5fb038e61f1ad702e5fbb708fa8efcd4e338bf83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fb038e61f1ad702e5fbb708fa8efcd4e338bf83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aba50ff331f4d97b1ca2a60091b03e012837b98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aba50ff331f4d97b1ca2a60091b03e012837b98", "html_url": "https://github.com/rust-lang/rust/commit/3aba50ff331f4d97b1ca2a60091b03e012837b98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aba50ff331f4d97b1ca2a60091b03e012837b98/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ddb832a4e34dfd0edcd22529e16732d7cb15f88", "html_url": "https://github.com/rust-lang/rust/commit/0ddb832a4e34dfd0edcd22529e16732d7cb15f88"}], "stats": {"total": 145, "additions": 70, "deletions": 75}, "files": [{"sha": "a9a4e93603919d66cefdcb573f91887a9cafb8d6", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/3aba50ff331f4d97b1ca2a60091b03e012837b98/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aba50ff331f4d97b1ca2a60091b03e012837b98/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=3aba50ff331f4d97b1ca2a60091b03e012837b98", "patch": "@@ -570,24 +570,6 @@ fn count_ty_params(@t ty) -> uint {\n     ret _vec.len[ast.def_id](*param_ids);\n }\n \n-fn type_contains_ty_vars(@t ty) -> bool {\n-    state obj checker(@mutable bool has_vars) {\n-        fn fold_simple_ty(@t ty) -> @t {\n-            alt (ty.struct) {\n-                case (ty_var(_)) {\n-                    *has_vars = true;\n-                }\n-                case (_) {}\n-            }\n-            ret ty;\n-        }\n-    }\n-\n-    let @mutable bool b = @mutable false;\n-    fold_ty(checker(b), ty);\n-    ret *b;\n-}\n-\n // Type accessors for substructures of types\n \n fn ty_fn_args(@t fty) -> vec[arg] {\n@@ -802,7 +784,10 @@ fn is_lval(@ast.expr expr) -> bool {\n     }\n }\n \n-// Type unification\n+// Type unification via Robinson's algorithm (Robinson 1965). Implemented as\n+// described in Hoder and Voronkov:\n+//\n+//     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n \n fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         -> unify_result {\n@@ -822,7 +807,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n-    fn unify_fn(&hashmap[int,@ty.t] bindings,\n+    fn unify_fn(@hashmap[int,@ty.t] bindings,\n                 @ty.t expected,\n                 @ty.t actual,\n                 &unify_handler handler,\n@@ -891,7 +876,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n     }\n \n-    fn unify_obj(&hashmap[int,@ty.t] bindings,\n+    fn unify_obj(@hashmap[int,@ty.t] bindings,\n                 @ty.t expected,\n                 @ty.t actual,\n                 &unify_handler handler,\n@@ -952,27 +937,44 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n       ret ures_ok(t);\n     }\n \n-    fn unify_step(&hashmap[int,@ty.t] bindings, @ty.t expected, @ty.t actual,\n-                  &unify_handler handler) -> unify_result {\n+    fn resolve(@hashmap[int,@t] bindings, @t typ) -> @t {\n+        alt (typ.struct) {\n+            case (ty_var(?id)) {\n+                alt (bindings.find(id)) {\n+                    case (some[@t](?typ2)) {\n+                        ret resolve(bindings, typ2);\n+                    }\n+                    case (none[@t]) {\n+                        // fall through\n+                    }\n+                }\n+            }\n+            case (_) {\n+                // fall through\n+            }\n+        }\n+        ret typ;\n+    }\n+\n+    fn unify_step(@hashmap[int,@ty.t] bindings, @ty.t in_expected,\n+                  @ty.t in_actual, &unify_handler handler) -> unify_result {\n+\n+        // Resolve any bindings.\n+        auto expected = resolve(bindings, in_expected);\n+        auto actual = resolve(bindings, in_actual);\n+\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n+        // TODO: occurs check, to make sure we don't loop forever when\n+        // unifying e.g. 'a and option['a]\n+\n         alt (actual.struct) {\n             // If the RHS is a variable type, then just do the appropriate\n             // binding.\n             case (ty.ty_var(?actual_id)) {\n-                alt (bindings.find(actual_id)) {\n-                    case (some[@ty.t](?actual_ty)) {\n-                        // FIXME: change the binding here?\n-                        // FIXME: \"be\"\n-                        ret unify_step(bindings, expected, actual_ty,\n-                                       handler);\n-                    }\n-                    case (none[@ty.t]) {\n-                        bindings.insert(actual_id, expected);\n-                        ret ures_ok(expected);\n-                    }\n-                }\n+                bindings.insert(actual_id, expected);\n+                ret ures_ok(expected);\n             }\n             case (ty.ty_local(?actual_id)) {\n                 auto actual_ty = handler.resolve_local(actual_id);\n@@ -1077,8 +1079,6 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         }\n                     }\n \n-                    // TODO: ty_var\n-\n                     case (_) {\n                         ret ures_err(terr_mismatch, expected, actual);\n                     }\n@@ -1102,8 +1102,6 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         }\n                     }\n \n-                    // TODO: ty_var\n-\n                     case (_) {\n                         ret ures_err(terr_mismatch, expected, actual);\n                    }\n@@ -1152,8 +1150,6 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         ret ures_ok(plain_ty(ty.ty_tup(result_elems)));\n                     }\n \n-                    // TODO: ty_var\n-\n                     case (_) {\n                         ret ures_err(terr_mismatch, expected, actual);\n                     }\n@@ -1213,8 +1209,6 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         ret ures_ok(plain_ty(ty.ty_rec(result_fields)));\n                     }\n \n-                    // TODO: ty_var\n-\n                     case (_) {\n                         ret ures_err(terr_mismatch, expected, actual);\n                     }\n@@ -1248,20 +1242,9 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             }\n \n             case (ty.ty_var(?expected_id)) {\n-                alt (bindings.find(expected_id)) {\n-                    case (some[@ty.t](?expected_ty)) {\n-                        // FIXME: change the binding here?\n-                        // FIXME: \"be\"\n-                        ret unify_step(bindings,\n-                                       expected_ty,\n-                                       actual,\n-                                       handler);\n-                    }\n-                    case (none[@ty.t]) {\n-                        bindings.insert(expected_id, actual);\n-                        ret ures_ok(actual);\n-                    }\n-                }\n+                // Add a binding.\n+                bindings.insert(expected_id, actual);\n+                ret ures_ok(actual);\n             }\n \n             case (ty.ty_local(?expected_id)) {\n@@ -1289,31 +1272,43 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         fail;\n     }\n \n+    // Performs type binding substitution.\n+    fn substitute(@hashmap[int,@t] bindings, @t typ) -> @t {\n+        state obj folder(@hashmap[int,@t] bindings) {\n+            fn fold_simple_ty(@t typ) -> @t {\n+                alt (typ.struct) {\n+                    case (ty_var(?id)) {\n+                        alt (bindings.find(id)) {\n+                            case (some[@t](?typ2)) {\n+                                ret substitute(bindings, typ2);\n+                            }\n+                            case (none[@t]) {\n+                                ret typ;\n+                            }\n+                        }\n+                    }\n+                    case (_) {\n+                        ret typ;\n+                    }\n+                }\n+            }\n+        }\n+\n+        ret ty.fold_ty(folder(bindings), typ);\n+    }\n+\n     fn hash_int(&int x) -> uint { ret x as uint; }\n     fn eq_int(&int a, &int b) -> bool { ret a == b; }\n     auto hasher = hash_int;\n     auto eqer = eq_int;\n-    auto bindings = map.mk_hashmap[int,@ty.t](hasher, eqer);\n-\n-    // FIXME: this is a slow way of driving types into residual vars that\n-    // occur up in the leaves of result type; it can likely be done better\n-    // when unification is actually ... down in the leaves.\n+    auto bindings = @map.mk_hashmap[int,@ty.t](hasher, eqer);\n \n     auto ures = unify_step(bindings, expected, actual, handler);\n-    while (true) {\n-        alt (ures) {\n-            case (ures_ok(?t)) {\n-                if (!type_contains_ty_vars(t)) {\n-                    ret ures;\n-                }\n-                ures = unify_step(bindings, t, actual, handler);\n-            }\n-            case (_) {\n-                ret ures;\n-            }\n-        }\n+    alt (ures) {\n+        case (ures_ok(?t))  { ret ures_ok(substitute(bindings, t)); }\n+        case (_)            { ret ures;                             }\n     }\n-    fail;\n+    fail;   // not reached\n }\n \n fn type_err_to_str(&ty.type_err err) -> str {"}]}