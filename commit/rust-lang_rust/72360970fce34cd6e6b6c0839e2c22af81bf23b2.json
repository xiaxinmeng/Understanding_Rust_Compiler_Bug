{"sha": "72360970fce34cd6e6b6c0839e2c22af81bf23b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMzYwOTcwZmNlMzRjZDZlNmI2YzA4MzllMmMyMmFmODFiZjIzYjI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-12T21:55:44Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-06-12T21:55:44Z"}, "message": "Change trans::common::block to be a class\n\nAnd replace trans::common::block_parent with option<block>. To handle\nthe recursive self-reference in the block_ class, I had to add a\nnewtype-like enum \"block\" which is equivalent to @block_ -- which due\nto an interaction with borrowck, resulted in having to change a few\nfunctions in trans::base to take their block argument in ++ mode,\nirritatingly enough (but not that irritatingly, since we're supposed to\nget rid of modes).", "tree": {"sha": "5ac2f2dfee81d5212f6cc8a0cffe4325b542aed9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac2f2dfee81d5212f6cc8a0cffe4325b542aed9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72360970fce34cd6e6b6c0839e2c22af81bf23b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72360970fce34cd6e6b6c0839e2c22af81bf23b2", "html_url": "https://github.com/rust-lang/rust/commit/72360970fce34cd6e6b6c0839e2c22af81bf23b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72360970fce34cd6e6b6c0839e2c22af81bf23b2/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ec1d4abb0200a46c20341b4d894d9c2198905b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ec1d4abb0200a46c20341b4d894d9c2198905b", "html_url": "https://github.com/rust-lang/rust/commit/d1ec1d4abb0200a46c20341b4d894d9c2198905b"}], "stats": {"total": 129, "additions": 69, "deletions": 60}, "files": [{"sha": "70d30c45da53d1f6dfb3af5c80c921075b8557c6", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/72360970fce34cd6e6b6c0839e2c22af81bf23b2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72360970fce34cd6e6b6c0839e2c22af81bf23b2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=72360970fce34cd6e6b6c0839e2c22af81bf23b2", "patch": "@@ -50,6 +50,7 @@ import type_of::type_of; // Issue #1873\n import syntax::ast_map::{path, path_mod, path_name};\n \n import std::smallintmap;\n+import option::is_none;\n \n // Destinations\n \n@@ -1207,7 +1208,8 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n     }\n }\n \n-fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n+// See [Note-arg-mode]\n+fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue_full\");\n     lazily_emit_tydesc_glue(cx.ccx(), field, static_ti);\n@@ -1245,8 +1247,9 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n                     C_null(T_ptr(T_ptr(cx.ccx().tydesc_type))), llrawptr]);\n }\n \n-fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint) ->\n-   block {\n+// See [Note-arg-mode]\n+fn call_tydesc_glue(++cx: block, v: ValueRef, t: ty::t, field: uint)\n+    -> block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n     let mut ti = none;\n     let td = get_tydesc(cx.ccx(), t, ti);\n@@ -3111,8 +3114,9 @@ fn body_contains_ret(body: ast::blk) -> bool {\n     cx.found\n }\n \n+// See [Note-arg-mode]\n fn trans_call_inner(\n-    in_cx: block,\n+    ++in_cx: block,\n     call_info: option<node_info>,\n     fn_expr_ty: ty::t,\n     ret_ty: ty::t,\n@@ -3240,8 +3244,8 @@ fn need_invoke(bcx: block) -> bool {\n           _ { }\n         }\n         cur = alt cur.parent {\n-          parent_some(next) { next }\n-          parent_none { ret false; }\n+          some(next) { next }\n+          none { ret false; }\n         }\n     }\n }\n@@ -3262,7 +3266,7 @@ fn in_lpad_scope_cx(bcx: block, f: fn(scope_info)) {\n     loop {\n         alt bcx.kind {\n           block_scope(inf) {\n-            if inf.cleanups.len() > 0u || bcx.parent == parent_none {\n+            if inf.cleanups.len() > 0u || is_none(bcx.parent) {\n                 f(inf); ret;\n             }\n           }\n@@ -3471,11 +3475,11 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n               some({id, _}) if id == scope_id { ret bcx_sid; }\n               _ {\n                 alt bcx_sid.parent {\n-                  parent_none {\n+                  none {\n                     bcx.tcx().sess.bug(\n                         #fmt[\"no enclosing scope with id %d\", scope_id]);\n                   }\n-                  parent_some(bcx_par) { bcx_par }\n+                  some(bcx_par) { bcx_par }\n                 }\n               }\n             }\n@@ -3785,7 +3789,10 @@ fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n \n // Since this function does *not* root, it is the caller's responsibility to\n // ensure that the referent is pointed to by a root.\n-fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n+// [Note-arg-mode]\n+// ++ mode is temporary, due to how borrowck treats enums. With hope,\n+// will go away anyway when we get rid of modes.\n+fn do_spill_noroot(++cx: block, v: ValueRef) -> ValueRef {\n     let llptr = alloca(cx, val_ty(v));\n     Store(cx, v, llptr);\n     ret llptr;\n@@ -3970,9 +3977,9 @@ fn trans_break_cont(bcx: block, to_end: bool)\n           _ {}\n         }\n         unwind = alt unwind.parent {\n-          parent_some(cx) { cx }\n+          some(cx) { cx }\n           // This is a return from a loop body block\n-          parent_none {\n+          none {\n             Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n             cleanup_and_leave(bcx, none, some(bcx.fcx.llreturn));\n             Unreachable(bcx);\n@@ -4090,7 +4097,7 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n \n // You probably don't want to use this one. See the\n // next three functions instead.\n-fn new_block(cx: fn_ctxt, parent: block_parent, +kind: block_kind,\n+fn new_block(cx: fn_ctxt, parent: option<block>, +kind: block_kind,\n              name: str, opt_node_info: option<node_info>) -> block {\n \n     let s = if cx.ccx.sess.opts.save_temps || cx.ccx.sess.opts.debuginfo {\n@@ -4099,19 +4106,10 @@ fn new_block(cx: fn_ctxt, parent: block_parent, +kind: block_kind,\n     let llbb: BasicBlockRef = str::as_c_str(s, {|buf|\n         llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n     });\n-    let bcx = @{llbb: llbb,\n-                mut terminated: false,\n-                mut unreachable: false,\n-                parent: parent,\n-                kind: kind,\n-                node_info: opt_node_info,\n-                fcx: cx};\n-    alt parent {\n-      parent_some(cx) {\n+    let bcx = mk_block(llbb, parent, kind, opt_node_info, cx);\n+    option::iter(parent) {|cx|\n         if cx.unreachable { Unreachable(bcx); }\n-      }\n-      _ {}\n-    }\n+    };\n     ret bcx;\n }\n \n@@ -4122,20 +4120,20 @@ fn simple_block_scope() -> block_kind {\n \n // Use this when you're at the top block of a function or the like.\n fn top_scope_block(fcx: fn_ctxt, opt_node_info: option<node_info>) -> block {\n-    ret new_block(fcx, parent_none, simple_block_scope(),\n+    ret new_block(fcx, none, simple_block_scope(),\n                   \"function top level\", opt_node_info);\n }\n \n fn scope_block(bcx: block,\n                opt_node_info: option<node_info>,\n                n: str) -> block {\n-    ret new_block(bcx.fcx, parent_some(bcx), simple_block_scope(),\n+    ret new_block(bcx.fcx, some(bcx), simple_block_scope(),\n                   n, opt_node_info);\n }\n \n fn loop_scope_block(bcx: block, loop_break: block, n: str,\n                     opt_node_info: option<node_info>) -> block {\n-    ret new_block(bcx.fcx, parent_some(bcx), block_scope({\n+    ret new_block(bcx.fcx, some(bcx), block_scope({\n         loop_break: some(loop_break),\n         mut cleanups: [],\n         mut cleanup_paths: [],\n@@ -4146,17 +4144,11 @@ fn loop_scope_block(bcx: block, loop_break: block, n: str,\n \n // Use this when you're making a general CFG BB within a scope.\n fn sub_block(bcx: block, n: str) -> block {\n-    ret new_block(bcx.fcx, parent_some(bcx), block_non_scope, n, none);\n+    new_block(bcx.fcx, some(bcx), block_non_scope, n, none)\n }\n \n fn raw_block(fcx: fn_ctxt, llbb: BasicBlockRef) -> block {\n-    ret @{llbb: llbb,\n-          mut terminated: false,\n-          mut unreachable: false,\n-          parent: parent_none,\n-          kind: block_non_scope,\n-          node_info: none,\n-          fcx: fcx};\n+    mk_block(llbb, none, block_non_scope, none, fcx)\n }\n \n \n@@ -4231,8 +4223,8 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n           _ {}\n         }\n         cur = alt cur.parent {\n-          parent_some(next) { next }\n-          parent_none { assert option::is_none(upto); break; }\n+          some(next) { next }\n+          none { assert is_none(upto); break; }\n         };\n     }\n     alt leave {"}, {"sha": "3bac52a949a0b6ab7292fb86f79e3ce966611be4", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/72360970fce34cd6e6b6c0839e2c22af81bf23b2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72360970fce34cd6e6b6c0839e2c22af81bf23b2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=72360970fce34cd6e6b6c0839e2c22af81bf23b2", "patch": "@@ -350,32 +350,44 @@ type node_info = {\n // code.  Each basic block we generate is attached to a function, typically\n // with many basic blocks per function.  All the basic blocks attached to a\n // function are organized as a directed graph.\n-type block = @{\n+class block_ {\n     // The BasicBlockRef returned from a call to\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n     // The block pointing to this one in the function's digraph.\n-    llbb: BasicBlockRef,\n-    mut terminated: bool,\n-    mut unreachable: bool,\n-    parent: block_parent,\n+    let llbb: BasicBlockRef;\n+    let mut terminated: bool;\n+    let mut unreachable: bool;\n+    let parent: option<block>;\n     // The 'kind' of basic block this is.\n-    kind: block_kind,\n+    let kind: block_kind;\n     // info about the AST node this block originated from, if any\n-    node_info: option<node_info>,\n+    let node_info: option<node_info>;\n     // The function context for the function to which this block is\n     // attached.\n-    fcx: fn_ctxt\n-};\n+    let fcx: fn_ctxt;\n+    new(llbb: BasicBlockRef, parent: option<block>, -kind: block_kind,\n+        node_info: option<node_info>, fcx: fn_ctxt) {\n+        // sigh\n+        self.llbb = llbb; self.terminated = false; self.unreachable = false;\n+        self.parent = parent; self.kind = kind; self.node_info = node_info;\n+        self.fcx = fcx;\n+    }\n+}\n+\n+/* This must be enum and not type, or trans goes into an infinite loop (#2572)\n+ */\n+enum block = @block_;\n+\n+fn mk_block(llbb: BasicBlockRef, parent: option<block>, -kind: block_kind,\n+         node_info: option<node_info>, fcx: fn_ctxt) -> block {\n+   block(@block_(llbb, parent, kind, node_info, fcx))\n+}\n \n // First two args are retptr, env\n const first_real_arg: uint = 2u;\n \n-// FIXME move blocks to a class once those are finished, and simply use\n-// option<block> for this. (#2532)\n-enum block_parent { parent_none, parent_some(block), }\n-\n type result = {bcx: block, val: ValueRef};\n type result_t = {bcx: block, val: ValueRef, ty: ty::t};\n \n@@ -412,7 +424,11 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n }\n \n fn block_parent(cx: block) -> block {\n-    alt check cx.parent { parent_some(b) { b } }\n+    alt cx.parent {\n+      some(b) { b }\n+      none    { cx.sess().bug(#fmt(\"block_parent called on root block %?\",\n+                                   cx)); }\n+    }\n }\n \n // Accessors"}, {"sha": "f45bb4d5011eafeb8fcd91b14393453cafa6fafc", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/72360970fce34cd6e6b6c0839e2c22af81bf23b2/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72360970fce34cd6e6b6c0839e2c22af81bf23b2/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=72360970fce34cd6e6b6c0839e2c22af81bf23b2", "patch": "@@ -236,8 +236,8 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     let mut cx = cx;\n     while option::is_none(cx.node_info) {\n         alt cx.parent {\n-          parent_some(b) { cx = b; }\n-          parent_none { fail; }\n+          some(b) { cx = b; }\n+          none { fail; }\n         }\n     }\n     let sp = option::get(cx.node_info).span;\n@@ -254,8 +254,8 @@ fn create_block(cx: block) -> @metadata<block_md> {\n     }*/\n \n     let parent = alt cx.parent {\n-        parent_none { create_function(cx.fcx).node }\n-        parent_some(bcx) { create_block(bcx).node }\n+        none { create_function(cx.fcx).node }\n+        some(bcx) { create_block(bcx).node }\n     };\n     let file_node = create_file(cx.ccx(), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n@@ -658,8 +658,8 @@ fn create_local_var(bcx: block, local: @ast::local)\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.file.name);\n     let context = alt bcx.parent {\n-        parent_none { create_function(bcx.fcx).node }\n-        parent_some(_) { create_block(bcx).node }\n+        none { create_function(bcx.fcx).node }\n+        some(_) { create_block(bcx).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n                             loc.line as int, tymd.node);\n@@ -761,9 +761,10 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n             (nm, decl.output, ctor_id)\n           }\n           ast_map::class_ctor(ctor,_) {\n-            fcx.ccx.sess.span_bug(ctor.span, \"create_function: \\\n-                  expected a resource ctor here\"); }\n+            // FIXME: output type may be wrong (#2194)\n+            (nm, ctor.node.dec.output, ctor.node.id)\n           }\n+        }\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {"}]}