{"sha": "4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYjZhOWI4MmZjZjcwMzljNDljZmY1M2E2MzAxYTlkMjdmMWE0ZGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-02-01T15:41:08Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-02-15T13:38:26Z"}, "message": "make generalization code create new variables in correct universe\n\nIn our type inference system, when we \"generalize\" a type T to become\na suitable value for a type variable V, we sometimes wind up creating\nnew inference variables. So, for example, if we are making V be some\nsubtype of `&'X u32`, then we might instantiate V with `&'Y u32`.\nThis generalized type is then related `&'Y u32 <: &'X u32`, resulting\nin a region constriant `'Y: 'X`. Previously, however, we were making\nthese fresh variables like `'Y` in the \"current universe\", but they\nshould be created in the universe of V. Moreover, we sometimes cheat\nin an invariant context and avoid creating fresh variables if we know\nthe result must be equal -- we can only do that when the universes\nwork out.", "tree": {"sha": "d1de7079e933790d1cd52fc8eeaefad8fc0b9e72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1de7079e933790d1cd52fc8eeaefad8fc0b9e72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "html_url": "https://github.com/rust-lang/rust/commit/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a49c9fb8c37081dca139834d4f7d336b443e6d0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a49c9fb8c37081dca139834d4f7d336b443e6d0b", "html_url": "https://github.com/rust-lang/rust/commit/a49c9fb8c37081dca139834d4f7d336b443e6d0b"}], "stats": {"total": 141, "additions": 110, "deletions": 31}, "files": [{"sha": "9cd5a844f15900a178ce8b9755783d8b0d34059d", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -255,10 +255,24 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n             RelationDir::SupertypeOf => ty::Contravariant,\n         };\n \n+        debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n+\n+        let for_universe = match self.infcx.type_variables.borrow_mut().probe(for_vid) {\n+            v @ TypeVariableValue::Known { .. } => panic!(\n+                \"instantiating {:?} which has a known value {:?}\",\n+                for_vid,\n+                v,\n+            ),\n+            TypeVariableValue::Unknown { universe } => universe,\n+        };\n+\n+        debug!(\"generalize: for_universe = {:?}\", for_universe);\n+\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n             for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            for_universe,\n             ambient_variance,\n             needs_wf: false,\n             root_ty: ty,\n@@ -288,6 +302,11 @@ struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// that means we would have created a cyclic type.\n     for_vid_sub_root: ty::TyVid,\n \n+    /// The universe of the type variable that is in the process of\n+    /// being instantiated. Any fresh variables that we create in this\n+    /// process should be in that same universe.\n+    for_universe: ty::UniverseIndex,\n+\n     /// Track the variance as we descend into the type.\n     ambient_variance: ty::Variance,\n \n@@ -386,6 +405,8 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n     fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n+        debug!(\"generalize: t={:?}\", t);\n+\n         // Check to see whether the type we are genealizing references\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n@@ -403,12 +424,17 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n+                            debug!(\"generalize: known value {:?}\", u);\n                             self.relate(&u, &u)\n                         }\n                         TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n-                                ty::Invariant => return Ok(t),\n+                                ty::Invariant => {\n+                                    if self.for_universe.can_name(universe) {\n+                                        return Ok(t);\n+                                    }\n+                                }\n \n                                 // Bivariant: make a fresh var, but we\n                                 // may need a WF predicate. See\n@@ -422,7 +448,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(universe, false, origin);\n+                            let new_var_id = variables.new_var(self.for_universe, false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);\n@@ -448,6 +474,8 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                -> RelateResult<'tcx, ty::Region<'tcx>> {\n         assert_eq!(r, r2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n+        debug!(\"generalize: regions r={:?}\", r);\n+\n         match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions.\n@@ -456,37 +484,40 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 return Ok(r);\n             }\n \n-            // Always make a fresh region variable for placeholder\n-            // regions; the higher-ranked decision procedures rely on\n-            // this.\n-            ty::RePlaceholder(..) => { }\n+            ty::ReClosureBound(..) => {\n+                span_bug!(\n+                    self.span,\n+                    \"encountered unexpected ReClosureBound: {:?}\",\n+                    r,\n+                );\n+            }\n \n-            // For anything else, we make a region variable, unless we\n-            // are *equating*, in which case it's just wasteful.\n+            ty::RePlaceholder(..) |\n+            ty::ReVar(..) |\n             ty::ReEmpty |\n             ty::ReStatic |\n             ty::ReScope(..) |\n-            ty::ReVar(..) |\n             ty::ReEarlyBound(..) |\n             ty::ReFree(..) => {\n-                match self.ambient_variance {\n-                    ty::Invariant => return Ok(r),\n-                    ty::Bivariant | ty::Covariant | ty::Contravariant => (),\n-                }\n+                // see common code below\n             }\n+        }\n \n-            ty::ReClosureBound(..) => {\n-                span_bug!(\n-                    self.span,\n-                    \"encountered unexpected ReClosureBound: {:?}\",\n-                    r,\n-                );\n+        // If we are in an invariant context, we can re-use the region\n+        // as is, unless it happens to be in some universe that we\n+        // can't name. (In the case of a region *variable*, we could\n+        // use it if we promoted it into our universe, but we don't\n+        // bother.)\n+        if let ty::Invariant = self.ambient_variance {\n+            let r_universe = self.infcx.universe_of_region(r);\n+            if self.for_universe.can_name(r_universe) {\n+                return Ok(r);\n             }\n         }\n \n         // FIXME: This is non-ideal because we don't give a\n         // very descriptive origin for this region variable.\n-        Ok(self.infcx.next_region_var(MiscVariable(self.span)))\n+        Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.span), self.for_universe))\n     }\n }\n "}, {"sha": "04d08c199802e53169047e0233a83584c6ce25a3", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -1018,6 +1018,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n+    /// Return the universe that the region `r` was created in.  For\n+    /// most regions (e.g., `'static`, named regions from the user,\n+    /// etc) this is the root universe U0. For inference variables or\n+    /// placeholders, however, it will return the universe which which\n+    /// they are associated.\n+    fn universe_of_region(\n+        &self,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::UniverseIndex {\n+        self.borrow_region_constraints().universe(r)\n+    }\n+\n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n         self.borrow_region_constraints().num_region_vars()"}, {"sha": "45d614167ea91bce7299a4a3e43ff692494f164f", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -824,7 +824,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         new_r\n     }\n \n-    fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n+    pub fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n         match *region {\n             ty::ReScope(..)\n             | ty::ReStatic"}, {"sha": "fa831ea81dcfb7707c2075fe7413e4ec28f6628a", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.krisskross.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.stderr?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -9,15 +9,15 @@ LL |    let a = bar(foo, y); //[krisskross]~ ERROR E0623\n    |                     ^ ...but data from `x` is returned here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/project-fn-ret-invariant.rs:55:8\n+  --> $DIR/project-fn-ret-invariant.rs:54:21\n    |\n LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-   |                                     --------     --------------------\n-   |                                     |\n-   |                                     this parameter and the return type are declared with different lifetimes...\n-...\n-LL |    (a, b) //[krisskross]~ ERROR E0623\n-   |        ^ ...but data from `x` is returned here\n+   |                        --------                  --------------------\n+   |                        |\n+   |                        this parameter and the return type are declared with different lifetimes...\n+LL |    let a = bar(foo, y); //[krisskross]~ ERROR E0623\n+LL |    let b = bar(foo, x); //[krisskross]~ ERROR E0623\n+   |                     ^ ...but data from `y` is returned here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "54b6e3642c2eacfc6be858e757e531566df923b7", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -51,8 +51,8 @@ fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n #[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    let a = bar(foo, y); //[krisskross]~ ERROR E0623\n-   let b = bar(foo, x);\n-   (a, b) //[krisskross]~ ERROR E0623\n+   let b = bar(foo, x); //[krisskross]~ ERROR E0623\n+   (a, b)\n }\n \n #[rustc_error]"}, {"sha": "dd1212eaac91d86eb1d8eda65fdb1f9843de12dd", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -1,4 +1,4 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n+error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n   --> $DIR/project-fn-ret-invariant.rs:48:8\n    |\n LL |    bar(foo, x) //[transmute]~ ERROR E0495"}, {"sha": "466082552667b5a6916091ba124aad6ed7483991", "filename": "src/test/ui/issues/issue-57843.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fissues%2Fissue-57843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fissues%2Fissue-57843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57843.rs?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -0,0 +1,24 @@\n+// Regression test for an ICE that occurred with the universes code:\n+//\n+// The signature of the closure `|_|` was being inferred to\n+// `exists<'r> fn(&'r u8)`. This should result in a type error since\n+// the signature `for<'r> fn(&'r u8)` is required. However, due to a\n+// bug in the type variable generalization code, the placeholder for\n+// `'r` was leaking out into the writeback phase, causing an ICE.\n+\n+trait ClonableFn<T> {\n+    fn clone(&self) -> Box<dyn Fn(T)>;\n+}\n+\n+impl<T, F: 'static> ClonableFn<T> for F\n+where F: Fn(T) + Clone {\n+    fn clone(&self) -> Box<dyn Fn(T)> {\n+        Box::new(self.clone())\n+    }\n+}\n+\n+struct Foo(Box<dyn for<'a> ClonableFn<&'a bool>>);\n+\n+fn main() {\n+    Foo(Box::new(|_| ())); //~ ERROR mismatched types\n+}"}, {"sha": "4ef884cb3f58960be82d6a22f659498211f334dc", "filename": "src/test/ui/issues/issue-57843.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fissues%2Fissue-57843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4db6a9b82fcf7039c49cff53a6301a9d27f1a4df/src%2Ftest%2Fui%2Fissues%2Fissue-57843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57843.stderr?ref=4db6a9b82fcf7039c49cff53a6301a9d27f1a4df", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57843.rs:23:9\n+   |\n+LL |     Foo(Box::new(|_| ())); //~ ERROR mismatched types\n+   |         ^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `std::ops::FnOnce<(&'a bool,)>`\n+              found type `std::ops::FnOnce<(&bool,)>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}