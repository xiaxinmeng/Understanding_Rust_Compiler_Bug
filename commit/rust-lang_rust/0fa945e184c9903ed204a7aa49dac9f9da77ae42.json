{"sha": "0fa945e184c9903ed204a7aa49dac9f9da77ae42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYTk0NWUxODRjOTkwM2VkMjA0YTdhYTQ5ZGFjOWY5ZGE3N2FlNDI=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-06-07T02:23:28Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-06-22T20:03:17Z"}, "message": "Change how we compute yield_in_scope\n\nCompound operators (e.g. 'a += b') have two different possible\nevaluation orders. When the left-hand side is a primitive type, the\nexpression is evaluated right-to-left. However, when the left-hand side\nis a non-primitive type, the expression is evaluated left-to-right.\n\nThis causes problems when we try to determine if a type is live across a\nyield point. Since we need to perform this computation before typecheck\nhas run, we can't simply check the types of the operands.\n\nThis commit calculates the most 'pessimistic' scenario - that is,\nerring on the side of treating more types as live, rather than fewer.\nThis is perfectly safe - in fact, this initial liveness computation is\nalready overly conservative (e.g. issue #57478). The important thing is\nthat we compute a superset of the types that are actually live across\nyield points. When we generate MIR, we'll determine which types actually\nneed to stay live across a given yield point, and which ones cam\nactually be dropped.\n\nConcretely, we force the computed HIR traversal index for\nright-hand-side yield expression to be equal to the maximum index for\nthe left-hand side. This covers both possible execution orders:\n\n* If the expression is evalauted right-to-left, our 'pessismitic' index\nis unecessary, but safe. We visit the expressions in an\nExprKind::AssignOp from right to left, so it actually would have been\nsafe to do nothing. However, while increasing the index of a yield point\nmight cause the compiler to reject code that could actually compile, it\nwill never cause incorrect code to be accepted.\n* If the expression is evaluated left-to-right, our 'pessimistic' index\ncorrectly ensures that types in the left-hand-side are seen as occuring\nbefore the yield - which is exactly what we want", "tree": {"sha": "aa3d6cdab8003a2589398ebc86a1031ed597059a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa3d6cdab8003a2589398ebc86a1031ed597059a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fa945e184c9903ed204a7aa49dac9f9da77ae42", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl0OiYUACgkQtAh+UQ6Y\nsWSPqw/+PlS2tIkazTXC9fp3HW+zxedfkyj0Ws2v6MXKVNC6x0GtBwTOwpZ3XYyZ\njZxX7Nn3n43XXROnTxANmmBT0zidiiGEah8D9H4C4H8iC5N42DlwWtZanKKTg9jJ\nZvdPapgwyttimYs7PBzAgo06Q/lsaWzTFM2cnq+R7iKKLLsTeyPAOgCT/P5O2RF1\nGCU6BkEZjfuB7q74nc/SnjNnibvztAiKKvtIIgfmZEk8a44ONdr0k+KF9WYwCFP+\nZ3XSOZey0A62lLThqa1dq5VgYzQUmRVlgymkameL7u2sEOrpdzXJvxplYJw0Pr/U\n1t6yWd8bbaKry/Z9li3m4HEUGSU3Skaiie4cNYmOYC45ZtCZQ5pBLgNezEd+IEzs\nl3IQkbZgPz+DkR4PaAwfL4ppRtUBBBHZ8k0c2RWXzpDUsYWeONEJt7o4WgHg++Ra\nqXxz4yJ/73rvXskCuLHSC/TC/msMF65/vayIJcSaXWxO5wkB/95AXwJBu4lOcFM/\nK4O0nYfyq7FKI243HWmjEG5ogNk/+WVvRvcDIUXt5UPatyxKooZGlcEgiNFI3aY0\nKOXzARN7wZP1wKl/6wkU/eSmbCeTvx3M8C8igXzvfoFcRNveVAj6YwCxeKhdE+Y/\nFBtCAqjK8V+YolnTL40r3qv2aBtN3dZyPta4t7CMHoLVg0+p/8o=\n=TmTI\n-----END PGP SIGNATURE-----", "payload": "tree aa3d6cdab8003a2589398ebc86a1031ed597059a\nparent 9d0960a6f8fbd561b2f5d9fb54ba49d533f61832\nauthor Aaron Hill <aa1ronham@gmail.com> 1559874208 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1561233797 -0400\n\nChange how we compute yield_in_scope\n\nCompound operators (e.g. 'a += b') have two different possible\nevaluation orders. When the left-hand side is a primitive type, the\nexpression is evaluated right-to-left. However, when the left-hand side\nis a non-primitive type, the expression is evaluated left-to-right.\n\nThis causes problems when we try to determine if a type is live across a\nyield point. Since we need to perform this computation before typecheck\nhas run, we can't simply check the types of the operands.\n\nThis commit calculates the most 'pessimistic' scenario - that is,\nerring on the side of treating more types as live, rather than fewer.\nThis is perfectly safe - in fact, this initial liveness computation is\nalready overly conservative (e.g. issue #57478). The important thing is\nthat we compute a superset of the types that are actually live across\nyield points. When we generate MIR, we'll determine which types actually\nneed to stay live across a given yield point, and which ones cam\nactually be dropped.\n\nConcretely, we force the computed HIR traversal index for\nright-hand-side yield expression to be equal to the maximum index for\nthe left-hand side. This covers both possible execution orders:\n\n* If the expression is evalauted right-to-left, our 'pessismitic' index\nis unecessary, but safe. We visit the expressions in an\nExprKind::AssignOp from right to left, so it actually would have been\nsafe to do nothing. However, while increasing the index of a yield point\nmight cause the compiler to reject code that could actually compile, it\nwill never cause incorrect code to be accepted.\n* If the expression is evaluated left-to-right, our 'pessimistic' index\ncorrectly ensures that types in the left-hand-side are seen as occuring\nbefore the yield - which is exactly what we want\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fa945e184c9903ed204a7aa49dac9f9da77ae42", "html_url": "https://github.com/rust-lang/rust/commit/0fa945e184c9903ed204a7aa49dac9f9da77ae42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fa945e184c9903ed204a7aa49dac9f9da77ae42/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d0960a6f8fbd561b2f5d9fb54ba49d533f61832", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0960a6f8fbd561b2f5d9fb54ba49d533f61832", "html_url": "https://github.com/rust-lang/rust/commit/9d0960a6f8fbd561b2f5d9fb54ba49d533f61832"}], "stats": {"total": 139, "additions": 138, "deletions": 1}, "files": [{"sha": "9c05f18762df1894130c8bbc63102c3eaf954d9f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=0fa945e184c9903ed204a7aa49dac9f9da77ae42", "patch": "@@ -1055,8 +1055,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(left_hand_expression)\n         }\n         ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(left_expression);\n             visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression);\n         }\n         ExprKind::Field(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);"}, {"sha": "13d07c720cb8963d035456c5aa2e9a9381304e40", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0fa945e184c9903ed204a7aa49dac9f9da77ae42", "patch": "@@ -371,6 +371,19 @@ struct RegionResolutionVisitor<'tcx> {\n \n     // The number of expressions and patterns visited in the current body\n     expr_and_pat_count: usize,\n+    // When this is 'true', we record the Scopes we encounter\n+    // when processing a Yield expression. This allows us to fix\n+    // up their indices.\n+    pessimistic_yield: bool,\n+    // Stores scopes when pessimistic_yield is true.\n+    // Each time we encounter an ExprKind::AssignOp, we push\n+    // a new Vec into the outermost Vec. This inner Vec is uesd\n+    // to store any scopes we encounter when visiting the inenr expressions\n+    // of the AssignOp. Once we finish visiting the inner expressions, we pop\n+    // off the inner Vec, and process the Scopes it contains.\n+    // This allows us to handle nested AssignOps - while a terrible idea,\n+    // they are valid Rust, so we need to handle them.\n+    fixup_scopes: Vec<Vec<Scope>>,\n \n     // Generated scope tree:\n     scope_tree: ScopeTree,\n@@ -947,12 +960,108 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n         }\n     }\n \n+    let prev_pessimistic = visitor.pessimistic_yield;\n+\n+    // Ordinarily, we can rely on the visit order of HIR intravisit\n+    // to correspond to the actual exectuion order of statements.\n+    // However, there's a weird corner case with compund assignment\n+    // operators (e.g. 'a += b'). The evaluation order depends on whether\n+    // or not the operator is overloaded (e.g. whether or not a trait\n+    // like AddAssign is implemented).\n+\n+    // For primitive types (which, despite having a trait impl, don't actually\n+    // end up calling it), the evluation order is right-to-left. For example,\n+    // the following code snippet:\n+    //\n+    //    let y = &mut 0;\n+    //    *{println!(\"LHS!\"); y} += {println!(\"RHS!\"); 1};\n+    //\n+    // will print:\n+    //\n+    // RHS!\n+    // LHS!\n+    //\n+    // However, if the operator is used on a non-primitive type,\n+    // the evaluation order will be left-to-right, since the operator\n+    // actually get desugared to a method call. For example, this\n+    // nearly identical code snippet:\n+    //\n+    //     let y = &mut String::new();\n+    //    *{println!(\"LHS String\"); y} += {println!(\"RHS String\"); \"hi\"};\n+    //\n+    // will print:\n+    // LHS String\n+    // RHS String\n+    //\n+    // To determine the actual execution order, we need to perform\n+    // trait resolution. Unfortunately, we need to be able to compute\n+    // yield_in_scope before type checking is even done, as it gets\n+    // used by AST borrowcheck\n+    //\n+    // Fortunately, we don't need to know the actual execution order.\n+    // It sufficies to know the 'worst case' order with respect to yields.\n+    // Specifically, we need to know the highest 'expr_and_pat_count'\n+    // that we could assign to the yield expression. To do this,\n+    // we pick the greater of the two values from the left-hand\n+    // and right-hand expressions. This makes us overly conservative\n+    // about what types could possibly live across yield points,\n+    // but we will never fail to detect that a type does actually\n+    // live across a yield point. The latter part is critical -\n+    // we're already overly conservative about what types will live\n+    // across yield points, as the generated MIR will determine\n+    // when things are actually live. However, for typecheck to work\n+    // properly, we can't miss any types.\n+\n+\n     match expr.node {\n         // Manually recurse over closures, because they are the only\n         // case of nested bodies that share the parent environment.\n         hir::ExprKind::Closure(.., body, _, _) => {\n             let body = visitor.tcx.hir().body(body);\n             visitor.visit_body(body);\n+        },\n+        hir::ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            debug!(\"resolve_expr - enabling pessimistic_yield, was previously {}\",\n+                   prev_pessimistic);\n+\n+            visitor.fixup_scopes.push(vec![]);\n+            visitor.pessimistic_yield = true;\n+\n+            // If the actual execution order turns out to be right-to-left,\n+            // then we're fine. However, if the actual execution order is left-to-right,\n+            // then we'll assign too low of a count to any 'yield' expressions\n+            // we encounter in 'right_expression' - they should really occur after all of the\n+            // expressions in 'left_expression'.\n+            visitor.visit_expr(&right_expression);\n+\n+            visitor.pessimistic_yield = prev_pessimistic;\n+\n+            let target_scopes = visitor.fixup_scopes.pop().unwrap();\n+            debug!(\"resolve_expr - restoring pessimistic_yield to {}\", prev_pessimistic);\n+\n+\n+            visitor.visit_expr(&left_expression);\n+            debug!(\"resolve_expr - fixing up counts to {}\", visitor.expr_and_pat_count);\n+\n+            for scope in target_scopes {\n+                let (span, count) = visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap();\n+                let count = *count;\n+                let span = *span;\n+\n+                // expr_and_pat_count never decreases. Since we recorded counts in yield_in_scope\n+                // before walking the left-hand side, it should be impossible for the recorded\n+                // count to be greater than the left-hand side count.\n+                if count > visitor.expr_and_pat_count {\n+                    bug!(\"Encountered greater count {} at span {:?} - expected no greater than {}\",\n+                         count, span, visitor.expr_and_pat_count);\n+                }\n+                let new_count = visitor.expr_and_pat_count;\n+                debug!(\"resolve_expr - increasing count for scope {:?} from {} to {} at span {:?}\",\n+                       scope, count, new_count, span);\n+\n+                visitor.scope_tree.yield_in_scope.insert(scope, (span, new_count));\n+            }\n+\n         }\n \n         _ => intravisit::walk_expr(visitor, expr)\n@@ -972,6 +1081,10 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 source: *source,\n             };\n             visitor.scope_tree.yield_in_scope.insert(scope, data);\n+            if visitor.pessimistic_yield {\n+                debug!(\"resolve_expr in pessimistic_yield - marking scope {:?} for fixup\", scope);\n+                visitor.fixup_scopes.last_mut().unwrap().push(scope);\n+            }\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1360,6 +1473,8 @@ fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree\n                 var_parent: None,\n             },\n             terminating_scopes: Default::default(),\n+            pessimistic_yield: false,\n+            fixup_scopes: vec![]\n         };\n \n         let body = tcx.hir().body(body_id);"}, {"sha": "d295c1f00c69fd4c52343a31b40c7336f7b0b165", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=0fa945e184c9903ed204a7aa49dac9f9da77ae42", "patch": "@@ -28,8 +28,14 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n               source_span: Span) {\n         use syntax_pos::DUMMY_SP;\n \n+        debug!(\"generator_interior: attempting to record type {:?} {:?} {:?} {:?}\",\n+               ty, scope, expr, source_span);\n+\n+\n         let live_across_yield = scope.map(|s| {\n             self.region_scope_tree.yield_in_scope(s).and_then(|yield_data| {\n+\n+\n                 // If we are recording an expression that is the last yield\n                 // in the scope, or that has a postorder CFG index larger\n                 // than the one of all of the yields, then its value can't"}, {"sha": "83b2c4b8189b0da43aea00c88b85e2aa3ad3af02", "filename": "src/test/run-pass/issues/issue-61442.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Ftest%2Frun-pass%2Fissues%2Fissue-61442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fa945e184c9903ed204a7aa49dac9f9da77ae42/src%2Ftest%2Frun-pass%2Fissues%2Fissue-61442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-61442.rs?ref=0fa945e184c9903ed204a7aa49dac9f9da77ae42", "patch": "@@ -5,6 +5,22 @@ fn foo() {\n         let mut s = String::new();\n         s += { yield; \"\" };\n     };\n+\n+    let _y = static || {\n+        let x = &mut 0;\n+        *{ yield; x } += match String::new() { _ => 0 };\n+    };\n+\n+    // Please don't ever actually write something like this\n+    let _z = static || {\n+        let x = &mut 0;\n+        *{\n+            let inner = &mut 1;\n+            *{ yield (); inner } += match String::new() { _ => 1};\n+            yield;\n+            x\n+        } += match String::new() { _ => 2 };\n+    };\n }\n \n fn main() {"}]}