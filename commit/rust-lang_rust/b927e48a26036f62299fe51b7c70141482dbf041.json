{"sha": "b927e48a26036f62299fe51b7c70141482dbf041", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5MjdlNDhhMjYwMzZmNjIyOTlmZTUxYjdjNzAxNDE0ODJkYmYwNDE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-30T04:09:15Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-30T04:09:15Z"}, "message": "Merge pull request #4682 from thestinger/treemap\n\nSet trait improvements + minor treemap cleanup", "tree": {"sha": "4c8a323cfd718a6d0ebb70b9b929522434813b95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c8a323cfd718a6d0ebb70b9b929522434813b95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b927e48a26036f62299fe51b7c70141482dbf041", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b927e48a26036f62299fe51b7c70141482dbf041", "html_url": "https://github.com/rust-lang/rust/commit/b927e48a26036f62299fe51b7c70141482dbf041", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b927e48a26036f62299fe51b7c70141482dbf041/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da4b3768971c7c025ba8a85ebf59572fd752dfb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/da4b3768971c7c025ba8a85ebf59572fd752dfb6", "html_url": "https://github.com/rust-lang/rust/commit/da4b3768971c7c025ba8a85ebf59572fd752dfb6"}, {"sha": "6b08683e15f2765b03e9c7c3b6cff83b0cfd7b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b08683e15f2765b03e9c7c3b6cff83b0cfd7b24", "html_url": "https://github.com/rust-lang/rust/commit/6b08683e15f2765b03e9c7c3b6cff83b0cfd7b24"}], "stats": {"total": 304, "additions": 268, "deletions": 36}, "files": [{"sha": "0a79a0ae19d96fa439092f6947d0523bbedd9fc6", "filename": "src/libcore/container.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b927e48a26036f62299fe51b7c70141482dbf041/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b927e48a26036f62299fe51b7c70141482dbf041/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=b927e48a26036f62299fe51b7c70141482dbf041", "patch": "@@ -65,4 +65,26 @@ pub trait Set<T>: Mutable {\n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n     fn remove(&mut self, value: &T) -> bool;\n+\n+    /// Return true if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    pure fn is_disjoint(&self, other: &self) -> bool;\n+\n+    /// Return true if the set is a subset of another\n+    pure fn is_subset(&self, other: &self) -> bool;\n+\n+    /// Return true if the set is a superset of another\n+    pure fn is_superset(&self, other: &self) -> bool;\n+\n+    /// Visit the values representing the difference\n+    pure fn difference(&self, other: &self, f: fn(&T) -> bool);\n+\n+    /// Visit the values representing the symmetric difference\n+    pure fn symmetric_difference(&self, other: &self, f: fn(&T) -> bool);\n+\n+    /// Visit the values representing the intersection\n+    pure fn intersection(&self, other: &self, f: fn(&T) -> bool);\n+\n+    /// Visit the values representing the union\n+    pure fn union(&self, other: &self, f: fn(&T) -> bool);\n }"}, {"sha": "bef1069eef1fe4805806329728ddb92c3a78e27e", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 223, "deletions": 4, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/b927e48a26036f62299fe51b7c70141482dbf041/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b927e48a26036f62299fe51b7c70141482dbf041/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=b927e48a26036f62299fe51b7c70141482dbf041", "patch": "@@ -14,17 +14,17 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n+use container::{Container, Mutable, Map, Set};\n use cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n /// Open addressing with linear probing.\n pub mod linear {\n+    use super::*;\n     use iter::BaseIter;\n-    use container::{Container, Mutable, Map, Set};\n-    use cmp::Eq;\n-    use cmp;\n     use hash::Hash;\n+    use iter;\n     use kinds::Copy;\n     use option::{None, Option, Some};\n     use option;\n@@ -453,6 +453,60 @@ pub mod linear {\n         /// Remove a value from the set. Return true if the value was\n         /// present in the set.\n         fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+\n+        /// Return true if the set has no elements in common with `other`.\n+        /// This is equivalent to checking for an empty intersection.\n+        pure fn is_disjoint(&self, other: &LinearSet<T>) -> bool {\n+            iter::all(self, |v| !other.contains(v))\n+        }\n+\n+        /// Return true if the set is a subset of another\n+        pure fn is_subset(&self, other: &LinearSet<T>) -> bool {\n+            iter::all(self, |v| other.contains(v))\n+        }\n+\n+        /// Return true if the set is a superset of another\n+        pure fn is_superset(&self, other: &LinearSet<T>) -> bool {\n+            other.is_subset(self)\n+        }\n+\n+        /// Visit the values representing the difference\n+        pure fn difference(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+            for self.each |v| {\n+                if !other.contains(v) {\n+                    if !f(v) { return }\n+                }\n+            }\n+        }\n+\n+        /// Visit the values representing the symmetric difference\n+        pure fn symmetric_difference(&self, other: &LinearSet<T>,\n+                                     f: fn(&T) -> bool) {\n+            self.difference(other, f);\n+            other.difference(self, f);\n+        }\n+\n+        /// Visit the values representing the intersection\n+        pure fn intersection(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+            for self.each |v| {\n+                if other.contains(v) {\n+                    if !f(v) { return }\n+                }\n+            }\n+        }\n+\n+        /// Visit the values representing the union\n+        pure fn union(&self, other: &LinearSet<T>, f: fn(&T) -> bool) {\n+            for self.each |v| {\n+                if !f(v) { return }\n+            }\n+\n+            for other.each |v| {\n+                if !self.contains(v) {\n+                    if !f(v) { return }\n+                }\n+            }\n+        }\n     }\n \n     pub impl <T: Hash IterBytes Eq> LinearSet<T> {\n@@ -462,7 +516,7 @@ pub mod linear {\n }\n \n #[test]\n-pub mod test {\n+mod test_map {\n     use container::{Container, Mutable, Map, Set};\n     use option::{None, Some};\n     use hashmap::linear::LinearMap;\n@@ -610,3 +664,168 @@ pub mod test {\n         assert !m.is_empty();\n     }\n }\n+\n+#[test]\n+mod test_set {\n+    use super::*;\n+\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = linear::LinearSet::new();\n+        let mut ys = linear::LinearSet::new();\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert xs.insert(5);\n+        assert ys.insert(11);\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert xs.insert(7);\n+        assert xs.insert(19);\n+        assert xs.insert(4);\n+        assert ys.insert(2);\n+        assert ys.insert(-11);\n+        assert xs.is_disjoint(&ys);\n+        assert ys.is_disjoint(&xs);\n+        assert ys.insert(7);\n+        assert !xs.is_disjoint(&ys);\n+        assert !ys.is_disjoint(&xs);\n+    }\n+\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = linear::LinearSet::new();\n+        assert a.insert(0);\n+        assert a.insert(5);\n+        assert a.insert(11);\n+        assert a.insert(7);\n+\n+        let mut b = linear::LinearSet::new();\n+        assert b.insert(0);\n+        assert b.insert(7);\n+        assert b.insert(19);\n+        assert b.insert(250);\n+        assert b.insert(11);\n+        assert b.insert(200);\n+\n+        assert !a.is_subset(&b);\n+        assert !a.is_superset(&b);\n+        assert !b.is_subset(&a);\n+        assert !b.is_superset(&a);\n+\n+        assert b.insert(5);\n+\n+        assert a.is_subset(&b);\n+        assert !a.is_superset(&b);\n+        assert !b.is_subset(&a);\n+        assert b.is_superset(&a);\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        let mut a = linear::LinearSet::new();\n+        let mut b = linear::LinearSet::new();\n+\n+        assert a.insert(11);\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(77);\n+        assert a.insert(103);\n+        assert a.insert(5);\n+        assert a.insert(-5);\n+\n+        assert b.insert(2);\n+        assert b.insert(11);\n+        assert b.insert(77);\n+        assert b.insert(-9);\n+        assert b.insert(-42);\n+        assert b.insert(5);\n+        assert b.insert(3);\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for a.intersection(&b) |x| {\n+            assert vec::contains(expected, x);\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        let mut a = linear::LinearSet::new();\n+        let mut b = linear::LinearSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+\n+        assert b.insert(3);\n+        assert b.insert(9);\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11];\n+        for a.difference(&b) |x| {\n+            assert vec::contains(expected, x);\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        let mut a = linear::LinearSet::new();\n+        let mut b = linear::LinearSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+\n+        assert b.insert(-2);\n+        assert b.insert(3);\n+        assert b.insert(9);\n+        assert b.insert(14);\n+        assert b.insert(22);\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 5, 11, 14, 22];\n+        for a.symmetric_difference(&b) |x| {\n+            assert vec::contains(expected, x);\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        let mut a = linear::LinearSet::new();\n+        let mut b = linear::LinearSet::new();\n+\n+        assert a.insert(1);\n+        assert a.insert(3);\n+        assert a.insert(5);\n+        assert a.insert(9);\n+        assert a.insert(11);\n+        assert a.insert(16);\n+        assert a.insert(19);\n+        assert a.insert(24);\n+\n+        assert b.insert(-2);\n+        assert b.insert(1);\n+        assert b.insert(5);\n+        assert b.insert(9);\n+        assert b.insert(13);\n+        assert b.insert(19);\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n+        for a.union(&b) |x| {\n+            assert vec::contains(expected, x);\n+            i += 1\n+        }\n+        assert i == expected.len();\n+    }\n+}"}, {"sha": "1105d65a4ed6fc6c4984800face4e6fd35cdd56f", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b927e48a26036f62299fe51b7c70141482dbf041/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b927e48a26036f62299fe51b7c70141482dbf041/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=b927e48a26036f62299fe51b7c70141482dbf041", "patch": "@@ -29,10 +29,10 @@ use core::prelude::*;\n // range search - O(log n) retrieval of an iterator from some key\n \n // (possibly) implement the overloads Python does for sets:\n-//   * union: |\n //   * intersection: &\n //   * difference: -\n //   * symmetric difference: ^\n+//   * union: |\n // These would be convenient since the methods work like `each`\n \n pub struct TreeMap<K, V> {\n@@ -49,10 +49,9 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    // ICE: x.next() != y.next()\n-\n                     x = x.next();\n                     y = y.next();\n+                    // FIXME: #4492 (ICE), x.get() == y.get()\n                     let (x1, x2) = x.get().unwrap();\n                     let (y1, y2) = y.get().unwrap();\n \n@@ -292,22 +291,6 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n     /// Remove a value from the set. Return true if the value was\n     /// present in the set.\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n-}\n-\n-impl <T: Ord> TreeSet<T> {\n-    /// Create an empty TreeSet\n-    static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n-\n-    /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n-        self.map.each_key_reverse(f)\n-    }\n-\n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n-    pure fn iter(&self) -> TreeSetIterator/&self<T> {\n-        TreeSetIterator{iter: self.map.iter()}\n-    }\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n@@ -336,12 +319,12 @@ impl <T: Ord> TreeSet<T> {\n         true\n     }\n \n-    /// Check of the set is a subset of another\n+    /// Return true if the set is a subset of another\n     pure fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         other.is_superset(self)\n     }\n \n-    /// Check of the set is a superset of another\n+    /// Return true if the set is a superset of another\n     pure fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -517,6 +500,22 @@ impl <T: Ord> TreeSet<T> {\n     }\n }\n \n+impl <T: Ord> TreeSet<T> {\n+    /// Create an empty TreeSet\n+    static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+\n+    /// Visit all values in reverse order\n+    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n+        self.map.each_key_reverse(f)\n+    }\n+\n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    pure fn iter(&self) -> TreeSetIterator/&self<T> {\n+        TreeSetIterator{iter: self.map.iter()}\n+    }\n+}\n+\n /// Lazy forward iterator over a set\n pub struct TreeSetIterator<T> {\n     priv iter: TreeMapIterator<T, ()>\n@@ -652,14 +651,12 @@ fn remove<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n                     let mut left = save.left.swap_unwrap();\n                     if left.right.is_some() {\n                         heir_swap(save, &mut left.right);\n-                        save.left = Some(left);\n-                        remove(&mut save.left, key);\n                     } else {\n                         save.key <-> left.key;\n                         save.value <-> left.value;\n-                        save.left = Some(left);\n-                        remove(&mut save.left, key);\n                     }\n+                    save.left = Some(left);\n+                    remove(&mut save.left, key);\n                 } else {\n                     save = save.left.swap_unwrap();\n                 }\n@@ -969,9 +966,7 @@ mod test_treemap {\n         let m = m;\n         let mut iter = m.iter();\n \n-        // ICE:\n-        //assert iter.next() == Some((&x1, &y1));\n-        //assert iter.next().eq(&Some((&x1, &y1)));\n+        // FIXME: #4492 (ICE): iter.next() == Some((&x1, &y1))\n \n         iter = iter.next();\n         assert iter.get().unwrap() == (&x1, &y1);\n@@ -984,10 +979,6 @@ mod test_treemap {\n         iter = iter.next();\n         assert iter.get().unwrap() == (&x5, &y5);\n \n-        // ICE:\n-        //assert iter.next() == None;\n-        //assert iter.next().eq(&None);\n-\n         iter = iter.next();\n         assert iter.get().is_none();\n     }"}]}