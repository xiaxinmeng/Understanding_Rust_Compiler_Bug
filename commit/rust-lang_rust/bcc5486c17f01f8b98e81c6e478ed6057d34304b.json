{"sha": "bcc5486c17f01f8b98e81c6e478ed6057d34304b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYzU0ODZjMTdmMDFmOGI5OGU4MWM2ZTQ3OGVkNjA1N2QzNDMwNGI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-04T22:26:51Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-04T22:26:51Z"}, "message": "Allow overloading explicit dereferences.", "tree": {"sha": "f6b669ca1690b67ac8ff71412201cc4c4f006a90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b669ca1690b67ac8ff71412201cc4c4f006a90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcc5486c17f01f8b98e81c6e478ed6057d34304b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc5486c17f01f8b98e81c6e478ed6057d34304b", "html_url": "https://github.com/rust-lang/rust/commit/bcc5486c17f01f8b98e81c6e478ed6057d34304b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcc5486c17f01f8b98e81c6e478ed6057d34304b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52532d13a6e72e4bf7f931a93f902de47d667baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/52532d13a6e72e4bf7f931a93f902de47d667baf", "html_url": "https://github.com/rust-lang/rust/commit/52532d13a6e72e4bf7f931a93f902de47d667baf"}], "stats": {"total": 598, "additions": 463, "deletions": 135}, "files": [{"sha": "4e30b5537c6cd3b2389bf8a09b03475a45664ba1", "filename": "src/doc/rust.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -2485,8 +2485,11 @@ before the expression they apply to.\n `*`\n   : Dereference. When applied to a [pointer](#pointer-types) it denotes the pointed-to location.\n     For pointers to mutable locations, the resulting [lvalue](#lvalues-rvalues-and-temporaries) can be assigned to.\n-    For [enums](#enumerated-types) that have only a single variant, containing a single parameter,\n-    the dereference operator accesses this parameter.\n+    On non-pointer types, it calls calls the `deref` method of the `std::ops::Deref` trait, or the\n+    `deref_mut` method of the `std::ops::DerefMut` trait (if implemented by the type and required\n+    for an outer expression that will or could mutate the dereference), and produces the\n+    result of dereferencing the `&` or `&mut` borrowed pointer returned from the overload method.\n+\n `!`\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the"}, {"sha": "9e70b89d5483c44f8adc8b76f558c5c26b039657", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -921,14 +921,17 @@ impl mc::Typer for TcxTyper {\n         Ok(ty::node_id_to_type(self.tcx, id))\n     }\n \n+    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t> {\n+        self.method_map.borrow().get().find(&id).map(|method| method.ty)\n+    }\n+\n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n         let adjustments = self.tcx.adjustments.borrow();\n         adjustments.get().find_copy(&id)\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        let method_map = self.method_map.borrow();\n-        method_map.get().contains_key(&id)\n+        self.method_map.borrow().get().contains_key(&id)\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {"}, {"sha": "45d1f112e958522105a6d8bd41f5842ff739a508", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -267,6 +267,7 @@ pub type McResult<T> = Result<T, ()>;\n pub trait Typer {\n     fn tcx(&self) -> ty::ctxt;\n     fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n+    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t>;\n     fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n     fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n     fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n@@ -433,11 +434,13 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(ast::UnDeref, e_base) => {\n-            if self.typer.is_method_call(expr.id) {\n-                return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n-            }\n-\n-            let base_cmt = if_ok!(self.cat_expr(e_base));\n+            let base_cmt = match self.typer.node_method_ty(expr.id) {\n+                Some(method_ty) => {\n+                    let ref_ty = ty::ty_fn_ret(method_ty);\n+                    self.cat_rvalue_node(expr.id(), expr.span(), ref_ty)\n+                }\n+                None => if_ok!(self.cat_expr(e_base))\n+            };\n             Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n "}, {"sha": "9a780678e4fe50977282ee80c8e5a72ba3b308f8", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -444,14 +444,12 @@ pub fn trans_call<'a>(\n                   call_ex: &ast::Expr,\n                   f: &ast::Expr,\n                   args: CallArgs,\n-                  id: ast::NodeId,\n                   dest: expr::Dest)\n                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_call\");\n     trans_call_inner(in_cx,\n                      Some(common::expr_info(call_ex)),\n                      expr_ty(in_cx, f),\n-                     node_id_type(in_cx, id),\n                      |cx, _| trans(cx, f),\n                      args,\n                      Some(dest)).bcx\n@@ -471,7 +469,6 @@ pub fn trans_method_call<'a>(\n         bcx,\n         Some(common::expr_info(call_ex)),\n         monomorphize_type(bcx, method_ty),\n-        expr_ty(bcx, call_ex),\n         |cx, arg_cleanup_scope| {\n             meth::trans_method_callee(cx, call_ex.id, rcvr, arg_cleanup_scope)\n         },\n@@ -490,11 +487,9 @@ pub fn trans_lang_call<'a>(\n     } else {\n         csearch::get_type(bcx.ccx().tcx, did).ty\n     };\n-    let rty = ty::ty_fn_ret(fty);\n     callee::trans_call_inner(bcx,\n                              None,\n                              fty,\n-                             rty,\n                              |bcx, _| {\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n@@ -520,12 +515,10 @@ pub fn trans_lang_call_with_type_params<'a>(\n         fty = csearch::get_type(bcx.tcx(), did).ty;\n     }\n \n-    let rty = ty::ty_fn_ret(fty);\n     return callee::trans_call_inner(\n         bcx,\n         None,\n         fty,\n-        rty,\n         |bcx, _| {\n             let callee =\n                 trans_fn_ref_with_vtables_to_callee(bcx, did, 0,\n@@ -554,7 +547,6 @@ pub fn trans_call_inner<'a>(\n                         bcx: &'a Block<'a>,\n                         call_info: Option<NodeInfo>,\n                         callee_ty: ty::t,\n-                        ret_ty: ty::t,\n                         get_callee: |bcx: &'a Block<'a>,\n                                      arg_cleanup_scope: cleanup::ScopeId|\n                                      -> Callee<'a>,\n@@ -610,9 +602,10 @@ pub fn trans_call_inner<'a>(\n         }\n     };\n \n-    let abi = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref f) => f.abis,\n-        _ => AbiSet::Rust()\n+    let (abi, ret_ty) = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref f) => (f.abis, f.sig.output),\n+        ty::ty_closure(ref f) => (AbiSet::Rust(), f.sig.output),\n+        _ => fail!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n     let is_rust_fn =\n         abi.is_rust() ||"}, {"sha": "fbb7decb30223bcce0738311b8a687b2a2cd9cfc", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 21, "deletions": 34, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -467,10 +467,6 @@ fn trans_datum_unadjusted<'a>(bcx: &'a Block<'a>,\n \n             trans_binary(bcx, expr, op, lhs, rhs)\n         }\n-        ast::ExprUnary(ast::UnDeref, base) => {\n-            let basedatum = unpack_datum!(bcx, trans(bcx, base));\n-            deref_once(bcx, expr, basedatum, 0)\n-        }\n         ast::ExprUnary(op, x) => {\n             trans_unary_datum(bcx, expr, op, x)\n         }\n@@ -782,12 +778,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             closure::trans_expr_fn(bcx, sigil, decl, body, expr.id, dest)\n         }\n         ast::ExprCall(f, ref args) => {\n-            callee::trans_call(bcx,\n-                               expr,\n-                               f,\n-                               callee::ArgExprs(args.as_slice()),\n-                               expr.id,\n-                               dest)\n+            callee::trans_call(bcx, expr, f, callee::ArgExprs(args.as_slice()), dest)\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n@@ -798,18 +789,15 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n         }\n         ast::ExprBinary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, lhs,\n-                                Some(&*rhs), expr_ty(bcx, expr), dest)\n+            trans_overloaded_op(bcx, expr, lhs, Some(&*rhs), Some(dest)).bcx\n         }\n         ast::ExprUnary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, subexpr,\n-                                None, expr_ty(bcx, expr), dest)\n+            trans_overloaded_op(bcx, expr, subexpr, None, Some(dest)).bcx\n         }\n         ast::ExprIndex(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            trans_overloaded_op(bcx, expr, base,\n-                                Some(&*idx), expr_ty(bcx, expr), dest)\n+            trans_overloaded_op(bcx, expr, base, Some(&*idx), Some(dest)).bcx\n         }\n         ast::ExprCast(val, _) => {\n             // DPS output mode means this is a trait cast:\n@@ -1185,17 +1173,14 @@ fn trans_unary_datum<'a>(\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_unary_datum\");\n \n-    // if deref, would be LvalueExpr\n-    assert!(op != ast::UnDeref);\n-\n-    // if overloaded, would be RvalueDpsExpr\n-    {\n+    let overloaded = {\n         let method_map = bcx.ccx().maps.method_map.borrow();\n-        assert!(!method_map.get().contains_key(&un_expr.id));\n-    }\n+        method_map.get().contains_key(&un_expr.id)\n+    };\n+    // if overloaded, would be RvalueDpsExpr\n+    assert!(!overloaded || op == ast::UnDeref);\n \n     let un_ty = expr_ty(bcx, un_expr);\n-    let sub_ty = expr_ty(bcx, sub_expr);\n \n     return match op {\n         ast::UnNot => {\n@@ -1226,15 +1211,19 @@ fn trans_unary_datum<'a>(\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n         }\n         ast::UnBox => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_managed)\n+            trans_boxed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr), heap_managed)\n         }\n         ast::UnUniq => {\n-            trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap_exchange)\n+            trans_boxed_expr(bcx, un_ty, sub_expr, expr_ty(bcx, sub_expr), heap_exchange)\n         }\n         ast::UnDeref => {\n-            bcx.sess().bug(\"deref expressions should have been \\\n-                            translated using trans_lvalue(), not \\\n-                            trans_unary_datum()\")\n+            if overloaded {\n+                let r = trans_overloaded_op(bcx, un_expr, sub_expr, None, None);\n+                DatumBlock(r.bcx, Datum(r.val, un_ty, LvalueExpr))\n+            } else {\n+                let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n+                deref_once(bcx, un_expr, datum, 0)\n+            }\n         }\n     };\n }\n@@ -1506,22 +1495,20 @@ fn trans_overloaded_op<'a, 'b>(\n                        expr: &ast::Expr,\n                        rcvr: &'b ast::Expr,\n                        arg: Option<&'b ast::Expr>,\n-                       ret_ty: ty::t,\n-                       dest: Dest)\n-                       -> &'a Block<'a> {\n+                       dest: Option<Dest>)\n+                       -> Result<'a> {\n     let method_ty = bcx.ccx().maps.method_map.borrow().get().get(&expr.id).ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n-                             ret_ty,\n                              |bcx, arg_cleanup_scope| {\n                                 meth::trans_method_callee(bcx,\n                                                           expr.id,\n                                                           rcvr,\n                                                           arg_cleanup_scope)\n                              },\n                              callee::ArgAutorefSecond(rcvr, arg),\n-                             Some(dest)).bcx\n+                             dest)\n }\n \n fn int_cast(bcx: &Block,"}, {"sha": "bb31ed0aef85f44d8cd13a88218cd370b9336914", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -105,9 +105,8 @@ impl<'a> Reflector<'a> {\n         for (i, a) in args.iter().enumerate() {\n             debug!(\"arg {}: {}\", i, bcx.val_to_str(*a));\n         }\n-        let bool_ty = ty::mk_bool();\n         let result = unpack_result!(bcx, callee::trans_call_inner(\n-            self.bcx, None, mth_ty, bool_ty,\n+            self.bcx, None, mth_ty,\n             |bcx, _| meth::trans_trait_callee_from_llval(bcx,\n                                                          mth_ty,\n                                                          mth_idx,"}, {"sha": "34442c565adc6e439f54c0e75e128fb0f0ea4dc9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -3284,6 +3284,7 @@ pub fn expr_kind(tcx: ctxt,\n             // exception, as its result is always unit.\n             return match expr.node {\n                 ast::ExprAssignOp(..) => RvalueStmtExpr,\n+                ast::ExprUnary(ast::UnDeref, _) => LvalueExpr,\n                 _ => RvalueDpsExpr\n             };\n         }"}, {"sha": "fe8d4caf9053c9e56c1b9c7f460a0f90aad796ec", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 123, "deletions": 69, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -1243,6 +1243,11 @@ impl FnCtxt {\n     }\n }\n \n+pub enum LvaluePreference {\n+    PreferMutLvalue,\n+    NoPreference\n+}\n+\n pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n     /*!\n      *\n@@ -1307,6 +1312,40 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n     };\n }\n \n+fn try_overloaded_deref(fcx: @FnCtxt,\n+                        expr: &ast::Expr,\n+                        base_expr: &ast::Expr,\n+                        base_ty: ty::t,\n+                        lvalue_pref: LvaluePreference)\n+                        -> Option<ty::mt> {\n+    // Try DerefMut first, if preferred.\n+    let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n+        (PreferMutLvalue, Some(trait_did)) => {\n+            method::lookup_in_trait(fcx, expr, base_expr, token::intern(\"deref_mut\"),\n+                                    trait_did, base_ty, [], DontAutoderefReceiver)\n+        }\n+        _ => None\n+    };\n+\n+    // Otherwise, fall back to Deref.\n+    let method = match (method, fcx.tcx().lang_items.deref_trait()) {\n+        (None, Some(trait_did)) => {\n+            method::lookup_in_trait(fcx, expr, base_expr, token::intern(\"deref\"),\n+                                    trait_did, base_ty, [], DontAutoderefReceiver)\n+        }\n+        (method, _) => method\n+    };\n+\n+    match method {\n+        Some(method) => {\n+            let ref_ty = ty::ty_fn_ret(method.ty);\n+            fcx.inh.method_map.borrow_mut().get().insert(expr.id, method);\n+            ty::deref(ref_ty, true)\n+        }\n+        None => None\n+    }\n+}\n+\n // AST fragment checking\n pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n@@ -1349,35 +1388,43 @@ pub fn valid_range_bounds(ccx: @CrateCtxt,\n pub fn check_expr_has_type(\n     fcx: @FnCtxt, expr: &ast::Expr,\n     expected: ty::t) {\n-    check_expr_with_unifier(fcx, expr, Some(expected), || {\n+    check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     });\n }\n \n-pub fn check_expr_coercable_to_type(\n-    fcx: @FnCtxt, expr: &ast::Expr,\n-    expected: ty::t) {\n-    check_expr_with_unifier(fcx, expr, Some(expected), || {\n+fn check_expr_coercable_to_type(fcx: @FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+    check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || {\n         demand::coerce(fcx, expr.span, expected, expr)\n     });\n }\n \n-pub fn check_expr_with_hint(\n-    fcx: @FnCtxt, expr: &ast::Expr,\n-    expected: ty::t) {\n-    check_expr_with_unifier(fcx, expr, Some(expected), || ())\n+fn check_expr_with_hint(fcx: @FnCtxt, expr: &ast::Expr, expected: ty::t) {\n+    check_expr_with_unifier(fcx, expr, Some(expected), NoPreference, || ())\n }\n \n-pub fn check_expr_with_opt_hint(\n-    fcx: @FnCtxt, expr: &ast::Expr,\n-    expected: Option<ty::t>)  {\n-    check_expr_with_unifier(fcx, expr, expected, || ())\n+fn check_expr_with_opt_hint(fcx: @FnCtxt, expr: &ast::Expr,\n+                            expected: Option<ty::t>)  {\n+    check_expr_with_unifier(fcx, expr, expected, NoPreference, || ())\n+}\n+\n+fn check_expr_with_opt_hint_and_lvalue_pref(fcx: @FnCtxt,\n+                                            expr: &ast::Expr,\n+                                            expected: Option<ty::t>,\n+                                            lvalue_pref: LvaluePreference) {\n+    check_expr_with_unifier(fcx, expr, expected, lvalue_pref, || ())\n }\n \n-pub fn check_expr(fcx: @FnCtxt, expr: &ast::Expr)  {\n-    check_expr_with_unifier(fcx, expr, None, || ())\n+fn check_expr(fcx: @FnCtxt, expr: &ast::Expr)  {\n+    check_expr_with_unifier(fcx, expr, None, NoPreference, || ())\n }\n \n+fn check_expr_with_lvalue_pref(fcx: @FnCtxt, expr: &ast::Expr,\n+                               lvalue_pref: LvaluePreference)  {\n+    check_expr_with_unifier(fcx, expr, None, lvalue_pref, || ())\n+}\n+\n+\n // determine the `self` type, using fresh variables for all variables\n // declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n@@ -1606,10 +1653,11 @@ fn check_type_parameter_positions_in_path(function_context: @FnCtxt,\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for both `ty_err` and\n /// `ty_bot`, so avoid that when err and bot need to be handled differently.\n-pub fn check_expr_with_unifier(fcx: @FnCtxt,\n-                               expr: &ast::Expr,\n-                               expected: Option<ty::t>,\n-                               unifier: ||) {\n+fn check_expr_with_unifier(fcx: @FnCtxt,\n+                           expr: &ast::Expr,\n+                           expected: Option<ty::t>,\n+                           lvalue_pref: LvaluePreference,\n+                           unifier: ||) {\n     debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n@@ -1795,18 +1843,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         vec::from_fn(len, |_| ty::mk_err())\n     }\n \n-    // A generic function for checking assignment expressions\n-    fn check_assignment(fcx: @FnCtxt,\n-                        lhs: &ast::Expr,\n-                        rhs: &ast::Expr,\n-                        id: ast::NodeId) {\n-        check_expr(fcx, lhs);\n-        let lhs_type = fcx.expr_ty(lhs);\n-        check_expr_has_type(fcx, rhs, lhs_type);\n-        fcx.write_ty(id, ty::mk_nil());\n-        // The callee checks for bot / err, we don't need to\n-    }\n-\n     fn write_call(fcx: @FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n         fcx.write_ty(call_expr.id, output);\n     }\n@@ -1868,7 +1904,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                          args: &[@ast::Expr],\n                          tps: &[ast::P<ast::Ty>]) {\n         let rcvr = args[0];\n-        check_expr(fcx, rcvr);\n+        // We can't know if we need &mut self before we look up the method,\n+        // so treat the receiver as mutable just in case - only explicit\n+        // overloaded dereferences care about the distinction.\n+        check_expr_with_lvalue_pref(fcx, rcvr, PreferMutLvalue);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n@@ -1999,7 +2038,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                    is_binop_assignment: IsBinopAssignment) {\n         let tcx = fcx.ccx.tcx;\n \n-        check_expr(fcx, lhs);\n+        let lvalue_pref = match is_binop_assignment {\n+            BinopAssignment => PreferMutLvalue,\n+            SimpleBinop => NoPreference\n+        };\n+        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n+\n         // Callee does bot / err checking\n         let lhs_t = structurally_resolved_type(fcx, lhs.span,\n                                                fcx.expr_ty(lhs));\n@@ -2246,11 +2290,12 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n     // Check field access expressions\n     fn check_field(fcx: @FnCtxt,\n                    expr: &ast::Expr,\n+                   lvalue_pref: LvaluePreference,\n                    base: &ast::Expr,\n                    field: ast::Name,\n                    tys: &[ast::P<ast::Ty>]) {\n         let tcx = fcx.ccx.tcx;\n-        let bot = check_expr(fcx, base);\n+        let bot = check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n@@ -2278,7 +2323,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             _ => ()\n         }\n \n-        let tps : ~[ty::t] = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n+        let tps: ~[ty::t] = tys.iter().map(|&ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2678,10 +2723,13 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                 ast::UnDeref => None\n             }\n         });\n-        check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n+        let lvalue_pref = match unop {\n+            ast::UnDeref => lvalue_pref,\n+            _ => NoPreference\n+        };\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, oprnd, exp_inner, lvalue_pref);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n-        if !ty::type_is_error(oprnd_t) &&\n-              !ty::type_is_bot(oprnd_t) {\n+        if !ty::type_is_error(oprnd_t) && !ty::type_is_bot(oprnd_t) {\n             match unop {\n                 ast::UnBox => {\n                     oprnd_t = ty::mk_box(tcx, oprnd_t)\n@@ -2690,33 +2738,35 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                     oprnd_t = ty::mk_uniq(tcx, oprnd_t);\n                 }\n                 ast::UnDeref => {\n-                    let sty = structure_of(fcx, expr.span, oprnd_t);\n-                    let operand_ty = ty::deref_sty(sty, true);\n-                    match operand_ty {\n-                        Some(mt) => {\n-                            oprnd_t = mt.ty\n-                        }\n-                        None => {\n-                            match *sty {\n-                                ty::ty_struct(did, ref substs) if {\n-                                    let fields = ty::struct_fields(fcx.tcx(), did, substs);\n-                                    fields.len() == 1\n-                                      && fields[0].ident == token::special_idents::unnamed_field\n-                                } => {\n+                    oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n+                    oprnd_t = match ty::deref(oprnd_t, true) {\n+                        Some(mt) => mt.ty,\n+                        None => match try_overloaded_deref(fcx, expr, oprnd,\n+                                                           oprnd_t, lvalue_pref) {\n+                            Some(mt) => mt.ty,\n+                            None => {\n+                                let is_newtype = match ty::get(oprnd_t).sty {\n+                                    ty::ty_struct(did, ref substs) => {\n+                                        let fields = ty::struct_fields(fcx.tcx(), did, substs);\n+                                        fields.len() == 1\n+                                        && fields[0].ident == token::special_idents::unnamed_field\n+                                    }\n+                                    _ => false\n+                                };\n+                                if is_newtype {\n                                     // This is an obsolete struct deref\n-                                    tcx.sess.span_err(\n-                                        expr.span,\n-                                        \"single-field tuple-structs can no longer be dereferenced\");\n-                                }\n-                                _ => {\n-                                    fcx.type_error_message(expr.span,\n-                                        |actual| {\n-                                            format!(\"type `{}` cannot be dereferenced\", actual)\n+                                    tcx.sess.span_err(expr.span,\n+                                        \"single-field tuple-structs can \\\n+                                         no longer be dereferenced\");\n+                                } else {\n+                                    fcx.type_error_message(expr.span, |actual| {\n+                                        format!(\"type `{}` cannot be dereferenced\", actual)\n                                     }, oprnd_t, None);\n                                 }\n+                                ty::mk_err()\n                             }\n                         }\n-                    }\n+                    };\n                 }\n                 ast::UnNot => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,\n@@ -2747,7 +2797,11 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n               fcx, expected,\n               |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n                                  _ => None });\n-        check_expr_with_opt_hint(fcx, oprnd, hint);\n+        let lvalue_pref = match mutbl {\n+            ast::MutMutable => PreferMutLvalue,\n+            ast::MutImmutable => NoPreference\n+        };\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, oprnd, hint, lvalue_pref);\n \n         // Note: at this point, we cannot say what the best lifetime\n         // is to use for resulting pointer.  We want to use the\n@@ -2817,26 +2871,26 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         fcx.write_ty(id, ty::mk_u32())\n       }\n       ast::ExprParen(a) => {\n-        check_expr_with_opt_hint(fcx, a, expected);\n+        check_expr_with_opt_hint_and_lvalue_pref(fcx, a, expected, lvalue_pref);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::ExprAssign(lhs, rhs) => {\n-        check_assignment(fcx, lhs, rhs, id);\n+        check_expr_with_lvalue_pref(fcx, lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n         if !ty::expr_is_lval(tcx, fcx.ccx.method_map, lhs) {\n             tcx.sess.span_err(lhs.span, \"illegal left-hand side expression\");\n         }\n \n         let lhs_ty = fcx.expr_ty(lhs);\n+        check_expr_has_type(fcx, rhs, lhs_ty);\n         let rhs_ty = fcx.expr_ty(rhs);\n+\n         if ty::type_is_error(lhs_ty) || ty::type_is_error(rhs_ty) {\n             fcx.write_error(id);\n-        }\n-        else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n+        } else if ty::type_is_bot(lhs_ty) || ty::type_is_bot(rhs_ty) {\n             fcx.write_bot(id);\n-        }\n-        else {\n+        } else {\n             fcx.write_nil(id);\n         }\n       }\n@@ -3111,10 +3165,10 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         }\n       }\n       ast::ExprField(base, field, ref tys) => {\n-        check_field(fcx, expr, base, field.name, tys.as_slice());\n+        check_field(fcx, expr, lvalue_pref, base, field.name, tys.as_slice());\n       }\n       ast::ExprIndex(base, idx) => {\n-          check_expr(fcx, base);\n+          check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n           check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n           let idx_t = fcx.expr_ty(idx);"}, {"sha": "381ff141bfbb4e18b0631a55c316c30517a0d0c0", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -226,12 +226,6 @@ impl Rcx {\n         self.resolve_type(t)\n     }\n \n-    /// Try to resolve the callee type for the given method call.\n-    pub fn resolve_method_type(&mut self, id: ast::NodeId) -> ty::t {\n-        let t = self.fcx.method_ty(id);\n-        self.resolve_type(t)\n-    }\n-\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n@@ -258,14 +252,19 @@ impl<'a> mc::Typer for &'a mut Rcx {\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n \n+    fn node_method_ty(&mut self, id: ast::NodeId) -> Option<ty::t> {\n+        self.fcx.inh.method_map.borrow().get().find(&id).map(|method| {\n+            self.resolve_type(method.ty)\n+        })\n+    }\n+\n     fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n         let adjustments = self.fcx.inh.adjustments.borrow();\n         adjustments.get().find_copy(&id)\n     }\n \n     fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n-        let method_map = self.fcx.inh.method_map.borrow();\n-        method_map.get().contains_key(&id)\n+        self.fcx.inh.method_map.borrow().get().contains_key(&id)\n     }\n \n     fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n@@ -489,7 +488,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprUnary(ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n-            let base_ty = rcx.resolve_node_type(base.id);\n+            let base_ty = match rcx.fcx.inh.method_map.get().find(&expr.id) {\n+                Some(method) => {\n+                    constrain_call(rcx, None, expr, Some(base), [], true);\n+                    ty::ty_fn_ret(method.ty)\n+                }\n+                None => rcx.resolve_node_type(base.id)\n+            };\n             constrain_derefs(rcx, expr, 1, base_ty);\n \n             visit::walk_expr(rcx, expr, ());\n@@ -764,7 +769,7 @@ fn constrain_call(rcx: &mut Rcx,\n             implicitly_ref_args);\n     let callee_ty = match fn_expr_id {\n         Some(id) => rcx.resolve_node_type(id),\n-        None => rcx.resolve_method_type(call_expr.id)\n+        None => rcx.resolve_type(rcx.fcx.method_ty(call_expr.id))\n     };\n     if ty::type_is_error(callee_ty) {\n         // Bail, as function type is unknown"}, {"sha": "4d220b3cc096dae796945919fba309769a6995b6", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref-mut.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how overloaded deref interacts with borrows when DerefMut\n+// is implemented.\n+\n+use std::ops::{Deref, DerefMut};\n+\n+struct Own<T> {\n+    value: *mut T\n+}\n+\n+impl<T> Deref<T> for Own<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+impl<T> DerefMut<T> for Own<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut *self.value }\n+    }\n+}\n+\n+fn deref_imm(x: Own<int>) {\n+    let _i = &*x;\n+}\n+\n+fn deref_mut1(x: Own<int>) {\n+    let _i = &mut *x; //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut2(mut x: Own<int>) {\n+    let _i = &mut *x;\n+}\n+\n+fn deref_extend<'a>(x: &'a Own<int>) -> &'a int {\n+    &**x\n+}\n+\n+fn deref_extend_mut1<'a>(x: &'a Own<int>) -> &'a mut int {\n+    &mut **x //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut2<'a>(x: &'a mut Own<int>) -> &'a mut int {\n+    &mut **x\n+}\n+\n+fn assign1<'a>(x: Own<int>) {\n+    *x = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign2<'a>(x: &'a Own<int>) {\n+    **x = 3; //~ ERROR cannot borrow\n+}\n+\n+fn assign3<'a>(x: &'a mut Own<int>) {\n+    **x = 3;\n+}\n+\n+pub fn main() {}\n\\ No newline at end of file"}, {"sha": "7aac9458e3c9ad58df0184115b7c09474414f733", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test how overloaded deref interacts with borrows when only\n+// Deref and not DerefMut is implemented.\n+\n+use std::ops::Deref;\n+\n+struct Rc<T> {\n+    value: *T\n+}\n+\n+impl<T> Deref<T> for Rc<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        unsafe { &*self.value }\n+    }\n+}\n+\n+fn deref_imm(x: Rc<int>) {\n+    let _i = &*x;\n+}\n+\n+fn deref_mut1(x: Rc<int>) {\n+    let _i = &mut *x; //~ ERROR cannot borrow\n+}\n+\n+fn deref_mut2(mut x: Rc<int>) {\n+    let _i = &mut *x; //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend<'a>(x: &'a Rc<int>) -> &'a int {\n+    &**x\n+}\n+\n+fn deref_extend_mut1<'a>(x: &'a Rc<int>) -> &'a mut int {\n+    &mut **x //~ ERROR cannot borrow\n+}\n+\n+fn deref_extend_mut2<'a>(x: &'a mut Rc<int>) -> &'a mut int {\n+    &mut **x //~ ERROR cannot borrow\n+}\n+\n+fn assign1<'a>(x: Rc<int>) {\n+    *x = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign2<'a>(x: &'a Rc<int>) {\n+    **x = 3; //~ ERROR cannot assign\n+}\n+\n+fn assign3<'a>(x: &'a mut Rc<int>) {\n+    **x = 3; //~ ERROR cannot assign\n+}\n+\n+pub fn main() {}"}, {"sha": "fc9210f54a04b52ca4457353bc3a25e6454a4b09", "filename": "src/test/compile-fail/borrowck-move-out-of-overloaded-deref.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-overloaded-deref.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+pub fn main() {\n+    let _x = *Rc::new(~\"hi\");\n+    //~^ ERROR cannot move out of dereference of `&`-pointer\n+}"}, {"sha": "28ac70c47c50984cfd2b16ef84f069c28b489f4c", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::Cell;\n+use std::ops::{Deref, DerefMut};\n+use std::vec_ng::Vec;\n+\n+struct DerefCounter<T> {\n+    count_imm: Cell<uint>,\n+    count_mut: uint,\n+    value: T\n+}\n+\n+impl<T> DerefCounter<T> {\n+    fn new(value: T) -> DerefCounter<T> {\n+        DerefCounter {\n+            count_imm: Cell::new(0),\n+            count_mut: 0,\n+            value: value\n+        }\n+    }\n+\n+    fn counts(&self) -> (uint, uint) {\n+        (self.count_imm.get(), self.count_mut)\n+    }\n+}\n+\n+impl<T> Deref<T> for DerefCounter<T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        self.count_imm.set(self.count_imm.get() + 1);\n+        &self.value\n+    }\n+}\n+\n+impl<T> DerefMut<T> for DerefCounter<T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        self.count_mut += 1;\n+        &mut self.value\n+    }\n+}\n+\n+pub fn main() {\n+    let mut n = DerefCounter::new(0);\n+    let mut v = DerefCounter::new(Vec::new());\n+\n+    let _ = *n; // Immutable deref + copy a POD.\n+    assert_eq!(n.counts(), (1, 0));\n+\n+    let _ = (&*n, &*v); // Immutable deref + borrow.\n+    assert_eq!(n.counts(), (2, 0)); assert_eq!(v.counts(), (1, 0));\n+\n+    let _ = (&mut *n, &mut *v); // Mutable deref + mutable borrow.\n+    assert_eq!(n.counts(), (2, 1)); assert_eq!(v.counts(), (1, 1));\n+\n+    let mut v2 = Vec::new();\n+    v2.push(1);\n+\n+    *n = 5; *v = v2; // Mutable deref + assignment.\n+    assert_eq!(n.counts(), (2, 2)); assert_eq!(v.counts(), (1, 2));\n+\n+    *n -= 3; // Mutable deref + assignment with binary operation.\n+    assert_eq!(n.counts(), (2, 3));\n+\n+    // Mutable deref used for calling a method taking &self.\n+    // N.B. This is required because method lookup hasn't been performed so\n+    // we don't know whether the called method takes mutable self, before\n+    // the dereference itself is type-checked (a chicken-and-egg problem).\n+    (*n).to_str();\n+    assert_eq!(n.counts(), (2, 4));\n+\n+    // Mutable deref used for calling a method taking &mut self.\n+    (*v).push(2);\n+    assert_eq!(v.counts(), (1, 3));\n+\n+    // Check the final states.\n+    assert_eq!(*n, 2);\n+    assert_eq!((*v).as_slice(), &[1, 2]);\n+}"}, {"sha": "86046e8e05df68e7a18df726b0ab503c583c1c91", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc5486c17f01f8b98e81c6e478ed6057d34304b/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=bcc5486c17f01f8b98e81c6e478ed6057d34304b", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+#[deriving(Eq, Show)]\n+struct Point {\n+    x: int,\n+    y: int\n+}\n+\n+pub fn main() {\n+    assert_eq!(*Rc::new(5), 5);\n+    assert_eq!(***Rc::new(~~5), 5);\n+    assert_eq!(*Rc::new(Point {x: 2, y: 4}), Point {x: 2, y: 4});\n+\n+    let i = Rc::new(RefCell::new(2));\n+    let i_value = *(*i).borrow();\n+    *(*i).borrow_mut() = 5;\n+    assert_eq!((i_value, *(*i).borrow()), (2, 5));\n+\n+    let s = Rc::new(~\"foo\");\n+    assert_eq!(*s, ~\"foo\");\n+    assert_eq!((*s).as_slice(), \"foo\");\n+\n+    let mut_s = Rc::new(RefCell::new(~\"foo\"));\n+    (*(*mut_s).borrow_mut()).push_str(\"bar\");\n+    // assert_eq! would fail here because it stores the LHS and RHS in two locals.\n+    assert!((*(*mut_s).borrow()).as_slice() == \"foobar\");\n+    assert!((*(*mut_s).borrow_mut()).as_slice() == \"foobar\");\n+\n+    let p = Rc::new(RefCell::new(Point {x: 1, y: 2}));\n+    (*(*p).borrow_mut()).x = 3;\n+    (*(*p).borrow_mut()).y += 3;\n+    assert_eq!(*(*p).borrow(), Point {x: 3, y: 5});\n+\n+    let v = Rc::new(RefCell::new(~[1, 2, 3]));\n+    (*(*v).borrow_mut())[0] = 3;\n+    (*(*v).borrow_mut())[1] += 3;\n+    assert_eq!(((*(*v).borrow())[0], (*(*v).borrow())[1], (*(*v).borrow())[2]), (3, 5, 3));\n+}"}]}