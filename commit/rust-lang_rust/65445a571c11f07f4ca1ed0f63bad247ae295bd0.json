{"sha": "65445a571c11f07f4ca1ed0f63bad247ae295bd0", "node_id": "C_kwDOAAsO6NoAKDY1NDQ1YTU3MWMxMWYwN2Y0Y2ExZWQwZjYzYmFkMjQ3YWUyOTViZDA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-29T13:27:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-29T13:27:28Z"}, "message": "Auto merge of #102471 - Dylan-DPC:rollup-ij3okjt, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #102336 (Fix associated type bindings with anon const in GAT position)\n - #102342 (Add negation methods for signed non-zero integers.)\n - #102385 (Don't export `__heap_base` and `__data_end` on wasm32-wasi.)\n - #102435 (Improve example of Iterator::reduce)\n - #102436 (rustdoc: clean up \"normalize.css 8\" input override CSS)\n - #102452 (fix minor ungrammatical sentence)\n - #102455 (Use let-chaining in `WhileTrue::check_expr`.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f98deb599ee3166a57ea2c49ac8939a6e9b36402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f98deb599ee3166a57ea2c49ac8939a6e9b36402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65445a571c11f07f4ca1ed0f63bad247ae295bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65445a571c11f07f4ca1ed0f63bad247ae295bd0", "html_url": "https://github.com/rust-lang/rust/commit/65445a571c11f07f4ca1ed0f63bad247ae295bd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65445a571c11f07f4ca1ed0f63bad247ae295bd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5bbf36a31796b6b7b3add65ba20805b6659392c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5bbf36a31796b6b7b3add65ba20805b6659392c", "html_url": "https://github.com/rust-lang/rust/commit/c5bbf36a31796b6b7b3add65ba20805b6659392c"}, {"sha": "f4e7094ffc3970a17884a5f933da45cb51dd3e1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4e7094ffc3970a17884a5f933da45cb51dd3e1c", "html_url": "https://github.com/rust-lang/rust/commit/f4e7094ffc3970a17884a5f933da45cb51dd3e1c"}], "stats": {"total": 387, "additions": 301, "deletions": 86}, "files": [{"sha": "061053ef2ac97508eed2714f748397b367048374", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -1320,10 +1320,12 @@ impl<'a> Linker for WasmLd<'a> {\n \n         // LLD will hide these otherwise-internal symbols since it only exports\n         // symbols explicitly passed via the `--export` flags above and hides all\n-        // others. Various bits and pieces of tooling use this, so be sure these\n-        // symbols make their way out of the linker as well.\n-        self.cmd.arg(\"--export=__heap_base\");\n-        self.cmd.arg(\"--export=__data_end\");\n+        // others. Various bits and pieces of wasm32-unknown-unknown tooling use\n+        // this, so be sure these symbols make their way out of the linker as well.\n+        if self.sess.target.os == \"unknown\" {\n+            self.cmd.arg(\"--export=__heap_base\");\n+            self.cmd.arg(\"--export=__data_end\");\n+        }\n     }\n \n     fn subsystem(&mut self, _subsystem: &str) {}"}, {"sha": "f8a62c849107632b68bd7e60a3d0106fcc2e5c71", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 87, "deletions": 30, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -333,7 +333,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     find_opaque_ty_constraints_for_tait(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner), in_trait, .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy {\n+                    origin:\n+                        hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner),\n+                    in_trait,\n+                    ..\n+                }) => {\n                     if in_trait {\n                         span_bug!(item.span, \"impl-trait in trait has no default\")\n                     } else {\n@@ -378,7 +383,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::Field(field) => icx.to_ty(field.ty),\n \n-        Node::Expr(&Expr { kind: ExprKind::Closure{..}, .. }) => tcx.typeck(def_id).node_type(hir_id),\n+        Node::Expr(&Expr { kind: ExprKind::Closure { .. }, .. }) => {\n+            tcx.typeck(def_id).node_type(hir_id)\n+        }\n \n         Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n             // We defer to `type_of` of the corresponding parameter\n@@ -410,40 +417,91 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n                     if asm.operands.iter().any(|(op, _op_sp)| match op {\n                         hir::InlineAsmOperand::Const { anon_const }\n-                        | hir::InlineAsmOperand::SymFn { anon_const } => anon_const.hir_id == hir_id,\n+                        | hir::InlineAsmOperand::SymFn { anon_const } => {\n+                            anon_const.hir_id == hir_id\n+                        }\n                         _ => false,\n                     }) =>\n                 {\n                     tcx.typeck(def_id).node_type(hir_id)\n                 }\n \n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => tcx\n-                    .adt_def(tcx.hir().get_parent_item(hir_id))\n-                    .repr()\n-                    .discr_type()\n-                    .to_ty(tcx),\n+                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                    tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n+                }\n \n-                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n-                    if let Node::TraitRef(trait_ref) = tcx.hir().get(\n-                        tcx.hir().get_parent_node(binding_id)\n-                    ) =>\n+                Node::TypeBinding(\n+                    binding @ &TypeBinding {\n+                        hir_id: binding_id,\n+                        kind: TypeBindingKind::Equality { term: Term::Const(ref e) },\n+                        ..\n+                    },\n+                ) if let Node::TraitRef(trait_ref) =\n+                    tcx.hir().get(tcx.hir().get_parent_node(binding_id))\n+                    && e.hir_id == hir_id =>\n                 {\n-                  let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                    return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n-                  };\n-                  let assoc_items = tcx.associated_items(trait_def_id);\n-                  let assoc_item = assoc_items.find_by_name_and_kind(\n-                    tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n-                  );\n-                  if let Some(assoc_item) = assoc_item {\n-                    tcx.type_of(assoc_item.def_id)\n-                  } else {\n-                      // FIXME(associated_const_equality): add a useful error message here.\n-                      tcx.ty_error_with_message(\n-                        DUMMY_SP,\n-                        \"Could not find associated const on trait\",\n-                    )\n-                  }\n+                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                        return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                    };\n+                    let assoc_items = tcx.associated_items(trait_def_id);\n+                    let assoc_item = assoc_items.find_by_name_and_kind(\n+                        tcx,\n+                        binding.ident,\n+                        ty::AssocKind::Const,\n+                        def_id.to_def_id(),\n+                    );\n+                    if let Some(assoc_item) = assoc_item {\n+                        tcx.type_of(assoc_item.def_id)\n+                    } else {\n+                        // FIXME(associated_const_equality): add a useful error message here.\n+                        tcx.ty_error_with_message(\n+                            DUMMY_SP,\n+                            \"Could not find associated const on trait\",\n+                        )\n+                    }\n+                }\n+\n+                Node::TypeBinding(\n+                    binding @ &TypeBinding { hir_id: binding_id, gen_args, ref kind, .. },\n+                ) if let Node::TraitRef(trait_ref) =\n+                    tcx.hir().get(tcx.hir().get_parent_node(binding_id))\n+                    && let Some((idx, _)) =\n+                        gen_args.args.iter().enumerate().find(|(_, arg)| {\n+                            if let GenericArg::Const(ct) = arg {\n+                                ct.value.hir_id == hir_id\n+                            } else {\n+                                false\n+                            }\n+                        }) =>\n+                {\n+                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                        return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n+                    };\n+                    let assoc_items = tcx.associated_items(trait_def_id);\n+                    let assoc_item = assoc_items.find_by_name_and_kind(\n+                        tcx,\n+                        binding.ident,\n+                        match kind {\n+                            // I think `<A: T>` type bindings requires that `A` is a type\n+                            TypeBindingKind::Constraint { .. }\n+                            | TypeBindingKind::Equality { term: Term::Ty(..) } => {\n+                                ty::AssocKind::Type\n+                            }\n+                            TypeBindingKind::Equality { term: Term::Const(..) } => {\n+                                ty::AssocKind::Const\n+                            }\n+                        },\n+                        def_id.to_def_id(),\n+                    );\n+                    if let Some(assoc_item) = assoc_item {\n+                        tcx.type_of(tcx.generics_of(assoc_item.def_id).params[idx].def_id)\n+                    } else {\n+                        // FIXME(associated_const_equality): add a useful error message here.\n+                        tcx.ty_error_with_message(\n+                            DUMMY_SP,\n+                            \"Could not find associated const on trait\",\n+                        )\n+                    }\n                 }\n \n                 Node::GenericParam(&GenericParam {\n@@ -452,8 +510,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     ..\n                 }) if ct.hir_id == hir_id => tcx.type_of(tcx.hir().local_def_id(param_hir_id)),\n \n-                x =>\n-                  tcx.ty_error_with_message(\n+                x => tcx.ty_error_with_message(\n                     DUMMY_SP,\n                     &format!(\"unexpected const parent in type_of(): {x:?}\"),\n                 ),"}, {"sha": "5d69c35ebfced90a07dd94323f31dd0383f189c1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -97,30 +97,28 @@ fn pierce_parens(mut expr: &ast::Expr) -> &ast::Expr {\n \n impl EarlyLintPass for WhileTrue {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        if let ast::ExprKind::While(cond, _, label) = &e.kind {\n-            if let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind {\n-                if let ast::LitKind::Bool(true) = lit.kind {\n-                    if !lit.span.from_expansion() {\n-                        let condition_span = e.span.with_hi(cond.span.hi());\n-                        cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n-                            lint.build(fluent::lint::builtin_while_true)\n-                                .span_suggestion_short(\n-                                    condition_span,\n-                                    fluent::lint::suggestion,\n-                                    format!(\n-                                        \"{}loop\",\n-                                        label.map_or_else(String::new, |label| format!(\n-                                            \"{}: \",\n-                                            label.ident,\n-                                        ))\n-                                    ),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n-                        })\n-                    }\n-                }\n-            }\n+        if let ast::ExprKind::While(cond, _, label) = &e.kind\n+            && let ast::ExprKind::Lit(ref lit) = pierce_parens(cond).kind\n+            && let ast::LitKind::Bool(true) = lit.kind\n+            && !lit.span.from_expansion()\n+        {\n+            let condition_span = e.span.with_hi(cond.span.hi());\n+            cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n+                lint.build(fluent::lint::builtin_while_true)\n+                    .span_suggestion_short(\n+                        condition_span,\n+                        fluent::lint::suggestion,\n+                        format!(\n+                            \"{}loop\",\n+                            label.map_or_else(String::new, |label| format!(\n+                                \"{}: \",\n+                                label.ident,\n+                            ))\n+                        ),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+            })\n         }\n     }\n }"}, {"sha": "6f23b9d908dba63ca67325e7bf6fce242e0dc488", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -440,7 +440,7 @@ pub trait TryInto<T>: Sized {\n ///\n ///     fn try_from(value: i32) -> Result<Self, Self::Error> {\n ///         if value <= 0 {\n-///             Err(\"GreaterThanZero only accepts value superior than zero!\")\n+///             Err(\"GreaterThanZero only accepts values greater than zero!\")\n ///         } else {\n ///             Ok(GreaterThanZero(value))\n ///         }"}, {"sha": "f6e6732b0e3910c3d65f6fd535b44da2f87813df", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -2431,22 +2431,13 @@ pub trait Iterator {\n     ///\n     /// # Example\n     ///\n-    /// Find the maximum value:\n-    ///\n     /// ```\n-    /// fn find_max<I>(iter: I) -> Option<I::Item>\n-    ///     where I: Iterator,\n-    ///           I::Item: Ord,\n-    /// {\n-    ///     iter.reduce(|accum, item| {\n-    ///         if accum >= item { accum } else { item }\n-    ///     })\n-    /// }\n-    /// let a = [10, 20, 5, -23, 0];\n-    /// let b: [u32; 0] = [];\n+    /// let reduced: i32 = (1..10).reduce(|acc, e| acc + e).unwrap();\n+    /// assert_eq!(reduced, 45);\n     ///\n-    /// assert_eq!(find_max(a.iter()), Some(&20));\n-    /// assert_eq!(find_max(b.iter()), None);\n+    /// // Which is equivalent to doing it with `fold`:\n+    /// let folded: i32 = (1..10).fold(0, |acc, e| acc + e);\n+    /// assert_eq!(reduced, folded);\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_fold_self\", since = \"1.51.0\")]"}, {"sha": "da402d66502a66a2532b5e23d9c2b91bd3cc0903", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -721,6 +721,160 @@ macro_rules! nonzero_signed_operations {\n                     // SAFETY: absolute value of nonzero cannot yield zero values.\n                     unsafe { $Uty::new_unchecked(self.get().unsigned_abs()) }\n                 }\n+\n+                /// Returns `true` if `self` is negative and `false` if the\n+                /// number is positive.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                ///\n+                /// assert!(neg_five.is_negative());\n+                /// assert!(!pos_five.is_negative());\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[must_use]\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn is_negative(self) -> bool {\n+                    self.get().is_negative()\n+                }\n+\n+                /// Checked negation. Computes `-self`, returning `None` if `self == i32::MIN`.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.checked_neg(), Some(neg_five));\n+                /// assert_eq!(min.checked_neg(), None);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn checked_neg(self) -> Option<$Ty> {\n+                    if let Some(result) = self.get().checked_neg() {\n+                        // SAFETY: negation of nonzero cannot yield zero values.\n+                        return Some(unsafe { $Ty::new_unchecked(result) });\n+                    }\n+                    None\n+                }\n+\n+                /// Negates self, overflowing if this is equal to the minimum value.\n+                ///\n+                #[doc = concat!(\"See [`\", stringify!($Int), \"::overflowing_neg`]\")]\n+                /// for documentation on overflow behaviour.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.overflowing_neg(), (neg_five, false));\n+                /// assert_eq!(min.overflowing_neg(), (min, true));\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn overflowing_neg(self) -> ($Ty, bool) {\n+                    let (result, overflow) = self.get().overflowing_neg();\n+                    // SAFETY: negation of nonzero cannot yield zero values.\n+                    ((unsafe { $Ty::new_unchecked(result) }), overflow)\n+                }\n+\n+                /// Saturating negation. Computes `-self`, returning `MAX` if\n+                /// `self == i32::MIN` instead of overflowing.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                #[doc = concat!(\"let min_plus_one = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN + 1)?;\")]\n+                #[doc = concat!(\"let max = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MAX)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.saturating_neg(), neg_five);\n+                /// assert_eq!(min.saturating_neg(), max);\n+                /// assert_eq!(max.saturating_neg(), min_plus_one);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn saturating_neg(self) -> $Ty {\n+                    if let Some(result) = self.checked_neg() {\n+                        return result;\n+                    }\n+                    $Ty::MAX\n+                }\n+\n+                /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n+                /// of the type.\n+                ///\n+                #[doc = concat!(\"See [`\", stringify!($Int), \"::wrapping_neg`]\")]\n+                /// for documentation on overflow behaviour.\n+                ///\n+                /// # Example\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_negation_ops)]\n+                ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n+                /// # fn main() { test().unwrap(); }\n+                /// # fn test() -> Option<()> {\n+                #[doc = concat!(\"let pos_five = \", stringify!($Ty), \"::new(5)?;\")]\n+                #[doc = concat!(\"let neg_five = \", stringify!($Ty), \"::new(-5)?;\")]\n+                #[doc = concat!(\"let min = \", stringify!($Ty), \"::new(\",\n+                                stringify!($Int), \"::MIN)?;\")]\n+                ///\n+                /// assert_eq!(pos_five.wrapping_neg(), neg_five);\n+                /// assert_eq!(min.wrapping_neg(), min);\n+                /// # Some(())\n+                /// # }\n+                /// ```\n+                #[inline]\n+                #[unstable(feature = \"nonzero_negation_ops\", issue = \"102443\")]\n+                pub const fn wrapping_neg(self) -> $Ty {\n+                    let result = self.get().wrapping_neg();\n+                    // SAFETY: negation of nonzero cannot yield zero values.\n+                    unsafe { $Ty::new_unchecked(result) }\n+                }\n             }\n         )+\n     }"}, {"sha": "7bc8fbb1ea7e40336e9ca3db4cd39e253266b315", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -191,6 +191,7 @@ h4.code-header {\n \tposition: relative;\n }\n \n+#crate-search,\n h1, h2, h3, h4, h5, h6,\n .sidebar,\n .mobile-topbar,\n@@ -304,16 +305,6 @@ summary {\n \n /* Fix some style changes due to normalize.css 8 */\n \n-button,\n-input,\n-optgroup,\n-select,\n-textarea {\n-\tcolor: inherit;\n-\tfont: inherit;\n-\tmargin: 0;\n-}\n-\n button {\n \t/* Buttons on Safari have different default padding than other platforms. Make them the same. */\n \tpadding: 1px 6px;\n@@ -887,6 +878,9 @@ table,\n \t/* Removes default arrow from firefox */\n \ttext-indent: 0.01px;\n \tbackground-color: var(--main-background-color);\n+\tcolor: inherit;\n+\tline-height: 1.5;\n+\tfont-weight: 500;\n }\n /* cancel stylistic differences in padding in firefox\n for \"appearance: none\"-style (or equivalent) <select>s */\n@@ -1363,6 +1357,8 @@ pre.rust {\n \tborder: 0;\n \tborder-top: 2px solid;\n \tflex: 1;\n+\tline-height: 1.5;\n+\tcolor: inherit;\n }\n \n #titles > button > div.count {\n@@ -1380,7 +1376,6 @@ pre.rust {\n \tposition: sticky;\n \ttop: 0;\n \tleft: 0;\n-\tfont-weight: bold;\n \tfont-size: 1.25rem;\n \tborder-bottom: 1px solid;\n \tdisplay: flex;\n@@ -1400,6 +1395,8 @@ pre.rust {\n \tmargin-bottom: 6px;\n }\n #sidebar-toggle > button {\n+\tfont-size: inherit;\n+\tfont-weight: bold;\n \tbackground: none;\n \tcolor: inherit;\n \tcursor: pointer;\n@@ -1428,6 +1425,7 @@ pre.rust {\n \tborder: 1px solid var(--border-color);\n \tborder-radius: 2px;\n \tcursor: pointer;\n+\tline-height: 1.5;\n }\n \n #settings-menu > a, #help-button > button {\n@@ -1887,7 +1885,6 @@ in storage.js plus the media query with (min-width: 701px)\n \t\tborder-top-right-radius: 3px;\n \t\tborder-bottom-right-radius: 3px;\n \t\tcursor: pointer;\n-\t\tfont-weight: bold;\n \t\tborder: 1px solid;\n \t\tborder-left: 0;\n \t}"}, {"sha": "821c4e978e8f5973d938b22965b33955aa7fa0c8", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -12,7 +12,8 @@\n \tmargin-right: 0.3em;\n \theight: 1.2rem;\n \twidth: 1.2rem;\n-\tborder: 1px solid;\n+\tcolor: inherit;\n+\tborder: 1px solid currentColor;\n \toutline: none;\n \t-webkit-appearance: none;\n \tcursor: pointer;"}, {"sha": "6c72563322f55f3fca0639758033bad7ac663dcf", "filename": "src/test/ui/generic-associated-types/issue-102333.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/65445a571c11f07f4ca1ed0f63bad247ae295bd0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65445a571c11f07f4ca1ed0f63bad247ae295bd0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-102333.rs?ref=65445a571c11f07f4ca1ed0f63bad247ae295bd0", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+\n+trait A {\n+    type T: B<U<1i32> = ()>;\n+}\n+\n+trait B {\n+    type U<const C: i32>;\n+}\n+\n+fn f<T: A>() {\n+    let _: <<T as A>::T as B>::U<1i32> = ();\n+}\n+\n+fn main() {}"}]}