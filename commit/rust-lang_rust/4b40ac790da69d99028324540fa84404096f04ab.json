{"sha": "4b40ac790da69d99028324540fa84404096f04ab", "node_id": "C_kwDOAAsO6NoAKDRiNDBhYzc5MGRhNjlkOTkwMjgzMjQ1NDBmYTg0NDA0MDk2ZjA0YWI", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-04T02:35:26Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-04T02:35:26Z"}, "message": "Support more SIMD intrinsics and refactor argument adjustment", "tree": {"sha": "453d0f06132d0731dde0caad3d4781b550ba4800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/453d0f06132d0731dde0caad3d4781b550ba4800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b40ac790da69d99028324540fa84404096f04ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b40ac790da69d99028324540fa84404096f04ab", "html_url": "https://github.com/rust-lang/rust/commit/4b40ac790da69d99028324540fa84404096f04ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b40ac790da69d99028324540fa84404096f04ab/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eba654c57ae2fe29ae963b128e5bf57ac2d08a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eba654c57ae2fe29ae963b128e5bf57ac2d08a6c", "html_url": "https://github.com/rust-lang/rust/commit/eba654c57ae2fe29ae963b128e5bf57ac2d08a6c"}], "stats": {"total": 320, "additions": 194, "deletions": 126}, "files": [{"sha": "df5c29f625eb075327e8107bdf2e2d0bc10bac99", "filename": "src/builder.rs", "status": "modified", "additions": 12, "deletions": 101, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4b40ac790da69d99028324540fa84404096f04ab/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b40ac790da69d99028324540fa84404096f04ab/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=4b40ac790da69d99028324540fa84404096f04ab", "patch": "@@ -48,6 +48,7 @@ use rustc_target::spec::{HasTargetSpec, Target};\n \n use crate::common::{SignType, TypeReflection, type_is_pointer};\n use crate::context::CodegenCx;\n+use crate::intrinsic::llvm;\n use crate::type_of::LayoutGccExt;\n \n // TODO(antoyo)\n@@ -224,18 +225,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             .zip(args.iter())\n             .enumerate()\n             .map(|(index, (expected_ty, &actual_val))| {\n-                // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-                // last argument type check.\n-                // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n-                match &*func_name {\n-                    \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                    | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n-                    | \"__builtin_ia32_sqrtpd512_mask\" => {\n-                        if index == args.len() - 1 {\n-                            return actual_val;\n-                        }\n-                    },\n-                    _ => (),\n+                if llvm::ignore_arg_cast(&func_name, index, args.len()) {\n+                    return actual_val;\n                 }\n \n                 let actual_ty = actual_val.get_type();\n@@ -302,7 +293,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let mut args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let args = self.check_ptr_call(\"call\", func_ptr, args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n@@ -314,92 +305,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n             let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n-            // arguments here.\n-            if gcc_func.get_param_count() != args.len() {\n-                let func_name = format!(\"{:?}\", func_ptr);\n-                match &*func_name {\n-                    \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n-                    // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n-                    | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n-                    | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                    | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n-                    | \"__builtin_ia32_pmaxuq128_mask\"\n-                    | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n-                    | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                    | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n-                    | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n-                    => {\n-                        // TODO: refactor by separating those intrinsics outside of this branch.\n-                        let add_before_last_arg =\n-                            match &*func_name {\n-                                \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n-                                _ => false,\n-                            };\n-                        let new_first_arg_is_zero =\n-                            match &*func_name {\n-                                \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n-                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n-                                _ => false\n-                            };\n-                        let arg3_index =\n-                            match &*func_name {\n-                                \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n-                                _ => 2,\n-                            };\n-                        let mut new_args = args.to_vec();\n-                        let arg3_type = gcc_func.get_param_type(arg3_index);\n-                        let first_arg =\n-                            if new_first_arg_is_zero {\n-                                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n-                                let zero = self.context.new_rvalue_zero(vector_type.get_element_type());\n-                                let num_units = vector_type.get_num_units();\n-                                self.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n-                            }\n-                            else {\n-                                self.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n-                            };\n-                        if add_before_last_arg {\n-                            new_args.insert(new_args.len() - 1, first_arg);\n-                        }\n-                        else {\n-                            new_args.push(first_arg);\n-                        }\n-                        let arg4_index =\n-                            match &*func_name {\n-                                \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n-                                _ => 3,\n-                            };\n-                        let arg4_type = gcc_func.get_param_type(arg4_index);\n-                        let minus_one = self.context.new_rvalue_from_int(arg4_type, -1);\n-                        if add_before_last_arg {\n-                            new_args.insert(new_args.len() - 1, minus_one);\n-                        }\n-                        else {\n-                            new_args.push(minus_one);\n-                        }\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmaddsub.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg4_type = gcc_func.get_param_type(3);\n-                            let minus_one = self.context.new_rvalue_from_int(arg4_type, -1);\n-                            new_args.push(minus_one);\n-                        }\n-\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        new_args.push(self.context.new_rvalue_from_int(arg5_type, 4));\n-                        args = new_args.into();\n-                    },\n-                    _ => (),\n-                }\n-            }\n+            let func_name = format!(\"{:?}\", func_ptr);\n+            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n             self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n             result.to_rvalue()\n         }\n@@ -1514,11 +1421,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         self.vector_reduce(src, |a, b, context| context.new_binary_op(None, op, a.get_type(), a, b))\n     }\n \n-    pub fn vector_reduce_fadd_fast(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+    pub fn vector_reduce_fadd_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n-    pub fn vector_reduce_fmul_fast(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+    pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n@@ -1553,6 +1460,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n         let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n         let inverted_masks = masks + ones;\n+        // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n+        // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n+        // operation to work.\n+        let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n         let else_vals = inverted_masks & else_val;\n \n         then_vals | else_vals"}, {"sha": "1175ea005472efb16ade9a7ffe95eedfa150ef1c", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 182, "deletions": 25, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/4b40ac790da69d99028324540fa84404096f04ab/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b40ac790da69d99028324540fa84404096f04ab/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=4b40ac790da69d99028324540fa84404096f04ab", "patch": "@@ -1,6 +1,169 @@\n-use gccjit::Function;\n+use std::borrow::Cow;\n \n-use crate::context::CodegenCx;\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+\n+use crate::{context::CodegenCx, builder::Builder};\n+\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+    // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n+    // arguments here.\n+    if gcc_func.get_param_count() != args.len() {\n+        match &*func_name {\n+            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n+                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+                | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n+                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                => {\n+                    // TODO: refactor by separating those intrinsics outside of this branch.\n+                    let add_before_last_arg =\n+                        match &*func_name {\n+                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n+                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n+                            _ => false,\n+                        };\n+                    let new_first_arg_is_zero =\n+                        match &*func_name {\n+                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n+                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n+                            _ => false\n+                        };\n+                    let arg3_index =\n+                        match &*func_name {\n+                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n+                            _ => 2,\n+                        };\n+                    let mut new_args = args.to_vec();\n+                    let arg3_type = gcc_func.get_param_type(arg3_index);\n+                    let first_arg =\n+                        if new_first_arg_is_zero {\n+                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                            let num_units = vector_type.get_num_units();\n+                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n+                        }\n+                        else {\n+                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n+                        };\n+                    if add_before_last_arg {\n+                        new_args.insert(new_args.len() - 1, first_arg);\n+                    }\n+                    else {\n+                        new_args.push(first_arg);\n+                    }\n+                    let arg4_index =\n+                        match &*func_name {\n+                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n+                            _ => 3,\n+                        };\n+                    let arg4_type = gcc_func.get_param_type(arg4_index);\n+                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                    if add_before_last_arg {\n+                        new_args.insert(new_args.len() - 1, minus_one);\n+                    }\n+                    else {\n+                        new_args.push(minus_one);\n+                    }\n+                    args = new_args.into();\n+                },\n+                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let arg5_type = gcc_func.get_param_type(4);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                        new_args.push(minus_one);\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+\n+                        let mut last_arg = None;\n+                        if args.len() == 4 {\n+                            last_arg = new_args.pop();\n+                        }\n+\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+\n+                        if args.len() == 3 {\n+                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                            // the same GCC intrinsic, but the former has 3 parameters and the\n+                            // latter has 4 so it doesn't require this additional argument.\n+                            let arg5_type = gcc_func.get_param_type(4);\n+                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                        }\n+\n+                        if let Some(last_arg) = last_arg {\n+                            new_args.push(last_arg);\n+                        }\n+\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+                        | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n+                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg3_type = gcc_func.get_param_type(2);\n+                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                        new_args.push(undefined);\n+                        let arg4_type = gcc_func.get_param_type(3);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n+                    _ => (),\n+        }\n+    }\n+\n+    args\n+}\n+\n+pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n+    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+    // last argument type check.\n+    // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n+    match func_name {\n+        \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+            | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n+            | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+            | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+            | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+            | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                if index == args_len - 1 {\n+                    return true;\n+                }\n+            },\n+        \"__builtin_ia32_vfmaddps512_mask\" => {\n+            if args_len == 4 && index == args_len - 1 {\n+                return true;\n+            }\n+        },\n+        _ => (),\n+    }\n+\n+    false\n+}\n \n #[cfg(not(feature=\"master\"))]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n@@ -37,29 +200,23 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n         \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n-        \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n-        \"llvm.x86.avx512.vfmaddsub.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n-        \"llvm.x86.avx512.rcp14.ps.256\" => \"__builtin_ia32_rcp14ps256_mask\",\n-        \"llvm.x86.avx512.rcp14.ps.128\" => \"__builtin_ia32_rcp14ps128_mask\",\n-        \"llvm.x86.avx512.rcp14.pd.256\" => \"__builtin_ia32_rcp14pd256_mask\",\n-        \"llvm.x86.avx512.rcp14.pd.128\" => \"__builtin_ia32_rcp14pd128_mask\",\n-        \"llvm.x86.avx512.rsqrt14.ps.256\" => \"__builtin_ia32_rsqrt14ps256_mask\",\n-        \"llvm.x86.avx512.rsqrt14.ps.128\" => \"__builtin_ia32_rsqrt14ps128_mask\",\n-        \"llvm.x86.avx512.rsqrt14.pd.256\" => \"__builtin_ia32_rsqrt14pd256_mask\",\n-        \"llvm.x86.avx512.rsqrt14.pd.128\" => \"__builtin_ia32_rsqrt14pd128_mask\",\n-        \"llvm.x86.avx512.mask.getexp.ps.512\" => \"__builtin_ia32_getexpps512_mask\",\n-        \"llvm.x86.avx512.mask.getexp.ps.256\" => \"__builtin_ia32_getexpps256_mask\",\n-        \"llvm.x86.avx512.mask.getexp.ps.128\" => \"__builtin_ia32_getexpps128_mask\",\n-        \"llvm.x86.avx512.mask.getexp.pd.512\" => \"__builtin_ia32_getexppd512_mask\",\n-        \"llvm.x86.avx512.mask.getexp.pd.256\" => \"__builtin_ia32_getexppd256_mask\",\n-        \"llvm.x86.avx512.mask.getexp.pd.128\" => \"__builtin_ia32_getexppd128_mask\",\n-        \"llvm.x86.avx512.mask.rndscale.ps.256\" => \"__builtin_ia32_rndscaleps_256_mask\",\n-        \"llvm.x86.avx512.mask.rndscale.ps.128\" => \"__builtin_ia32_rndscaleps_128_mask\",\n-        \"llvm.x86.avx512.mask.rndscale.pd.256\" => \"__builtin_ia32_rndscalepd_256_mask\",\n-        \"llvm.x86.avx512.mask.rndscale.pd.128\" => \"__builtin_ia32_rndscalepd_128_mask\",\n-        \"llvm.x86.avx512.mask.scalef.ps.512\" => \"__builtin_ia32_scalefps512_mask\",\n-        \"llvm.x86.avx512.mask.scalef.ps.256\" => \"__builtin_ia32_scalefps256_mask\",\n-        \"llvm.x86.avx512.mask.scalef.ps.128\" => \"__builtin_ia32_scalefps128_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n+        \"llvm.x86.avx512.vfmaddsub.pd.512\" => \"__builtin_ia32_vfmaddsubpd512_mask\",\n+        \"llvm.x86.avx512.pternlog.d.512\" => \"__builtin_ia32_pternlogd512_mask\",\n+        \"llvm.x86.avx512.pternlog.d.256\" => \"__builtin_ia32_pternlogd256_mask\",\n+        \"llvm.x86.avx512.pternlog.d.128\" => \"__builtin_ia32_pternlogd128_mask\",\n+        \"llvm.x86.avx512.pternlog.q.512\" => \"__builtin_ia32_pternlogq512_mask\",\n+        \"llvm.x86.avx512.pternlog.q.256\" => \"__builtin_ia32_pternlogq256_mask\",\n+        \"llvm.x86.avx512.pternlog.q.128\" => \"__builtin_ia32_pternlogq128_mask\",\n+        \"llvm.x86.avx512.add.ps.512\" => \"__builtin_ia32_addps512_mask\",\n+        \"llvm.x86.avx512.add.pd.512\" => \"__builtin_ia32_addpd512_mask\",\n+        \"llvm.x86.avx512.sub.ps.512\" => \"__builtin_ia32_subps512_mask\",\n+        \"llvm.x86.avx512.sub.pd.512\" => \"__builtin_ia32_subpd512_mask\",\n+        \"llvm.x86.avx512.mul.ps.512\" => \"__builtin_ia32_mulps512_mask\",\n+        \"llvm.x86.avx512.mul.pd.512\" => \"__builtin_ia32_mulpd512_mask\",\n+        \"llvm.x86.avx512.div.ps.512\" => \"__builtin_ia32_divps512_mask\",\n+        \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n+        \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\","}]}