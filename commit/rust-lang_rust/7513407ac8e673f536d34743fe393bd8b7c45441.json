{"sha": "7513407ac8e673f536d34743fe393bd8b7c45441", "node_id": "C_kwDOAAsO6NoAKDc1MTM0MDdhYzhlNjczZjUzNmQzNDc0M2ZlMzkzYmQ4YjdjNDU0NDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-17T10:30:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-17T10:30:59Z"}, "message": "Auto merge of #112330 - the8472:use-buf-reader-buffer, r=thomcc\n\nExtend io::copy buffer reuse to BufReader too\n\npreviously it was only able to use BufWriter. This was due to a limitation in the BufReader generics that prevented specialization. This change works around the issue by using `BufReader where Self: Read` instead of `BufReader<I> where I: Read`. This limits our options, e.g. we can't access the inner reader, but it happens to work out if we rely on some implementation details.\n\nCopying 1MiB from `/dev/zero` to `/dev/null` through a 256KiB BufReader yields following improvements\n\n```\nOLD:\n    io::copy::tests::bench_copy_buf_reader  51.44\u00b5s/iter +/- 703.00ns\nNEW:\n    io::copy::tests::bench_copy_buf_reader  18.55\u00b5s/iter +/- 237.00ns\n```\n\nPreviously this would read 256KiB into the reader but then copy 8KiB chunks to the writer through an additional intermediate buffer inside `io::copy`. Since those devices don't do much work most of the speedup should come from fewer syscalls and avoided memcopies.\n\nThe b3sum crate [notes that the default buffer size in io::copy is too small](https://github.com/BLAKE3-team/BLAKE3/blob/4108923f5284e0f8c3cf97b59041c2b6b2f601d3/b3sum/src/main.rs#L235-L239). With this optimization they could achieve the desired performance by wrapping the reader in a `BufReader` instead of handrolling it.\n\nCurrently the optimization doesn't apply to things like `StdinLock`, but this can be addressed with an additional `AsMutBufReader` specialization trait.", "tree": {"sha": "7842b67e97253168dd480cf520bada088569467f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7842b67e97253168dd480cf520bada088569467f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7513407ac8e673f536d34743fe393bd8b7c45441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7513407ac8e673f536d34743fe393bd8b7c45441", "html_url": "https://github.com/rust-lang/rust/commit/7513407ac8e673f536d34743fe393bd8b7c45441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7513407ac8e673f536d34743fe393bd8b7c45441/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d", "html_url": "https://github.com/rust-lang/rust/commit/f90d57d06ebc7f250b60b9cab583f111d9a5fb9d"}, {"sha": "373878573569371be876bb838607c64076f17f49", "url": "https://api.github.com/repos/rust-lang/rust/commits/373878573569371be876bb838607c64076f17f49", "html_url": "https://github.com/rust-lang/rust/commit/373878573569371be876bb838607c64076f17f49"}], "stats": {"total": 281, "additions": 207, "deletions": 74}, "files": [{"sha": "a66e6ccf673121833b6423bdaee450f489121f75", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=7513407ac8e673f536d34743fe393bd8b7c45441", "patch": "@@ -222,7 +222,7 @@ impl<R: ?Sized> BufReader<R> {\n \n     /// Invalidates all data in the internal buffer.\n     #[inline]\n-    fn discard_buffer(&mut self) {\n+    pub(in crate::io) fn discard_buffer(&mut self) {\n         self.buf.discard_buffer()\n     }\n }"}, {"sha": "ef1f4031ef2022c6f2d310de4a81ac1ea77edab6", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 97, "deletions": 13, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=7513407ac8e673f536d34743fe393bd8b7c45441", "patch": "@@ -1,6 +1,9 @@\n-use super::{BorrowedBuf, BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n+use super::{BorrowedBuf, BufReader, BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Copies the entire contents of a reader into a writer.\n ///\n /// This function will continuously read data from `reader` and then\n@@ -71,32 +74,113 @@ where\n     R: Read,\n     W: Write,\n {\n-    BufferedCopySpec::copy_to(reader, writer)\n+    let read_buf = BufferedReaderSpec::buffer_size(reader);\n+    let write_buf = BufferedWriterSpec::buffer_size(writer);\n+\n+    if read_buf >= DEFAULT_BUF_SIZE && read_buf >= write_buf {\n+        return BufferedReaderSpec::copy_to(reader, writer);\n+    }\n+\n+    BufferedWriterSpec::copy_from(writer, reader)\n+}\n+\n+/// Specialization of the read-write loop that reuses the internal\n+/// buffer of a BufReader. If there's no buffer then the writer side\n+/// should be used intead.\n+trait BufferedReaderSpec {\n+    fn buffer_size(&self) -> usize;\n+\n+    fn copy_to(&mut self, to: &mut (impl Write + ?Sized)) -> Result<u64>;\n+}\n+\n+impl<T> BufferedReaderSpec for T\n+where\n+    Self: Read,\n+    T: ?Sized,\n+{\n+    #[inline]\n+    default fn buffer_size(&self) -> usize {\n+        0\n+    }\n+\n+    default fn copy_to(&mut self, _to: &mut (impl Write + ?Sized)) -> Result<u64> {\n+        unimplemented!(\"only called from specializations\");\n+    }\n+}\n+\n+impl<I> BufferedReaderSpec for BufReader<I>\n+where\n+    Self: Read,\n+    I: ?Sized,\n+{\n+    fn buffer_size(&self) -> usize {\n+        self.capacity()\n+    }\n+\n+    fn copy_to(&mut self, to: &mut (impl Write + ?Sized)) -> Result<u64> {\n+        let mut len = 0;\n+\n+        loop {\n+            // Hack: this relies on `impl Read for BufReader` always calling fill_buf\n+            // if the buffer is empty, even for empty slices.\n+            // It can't be called directly here since specialization prevents us\n+            // from adding I: Read\n+            match self.read(&mut []) {\n+                Ok(_) => {}\n+                Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n+                Err(e) => return Err(e),\n+            }\n+            let buf = self.buffer();\n+            if self.buffer().len() == 0 {\n+                return Ok(len);\n+            }\n+\n+            // In case the writer side is a BufWriter then its write_all\n+            // implements an optimization that passes through large\n+            // buffers to the underlying writer. That code path is #[cold]\n+            // but we're still avoiding redundant memcopies when doing\n+            // a copy between buffered inputs and outputs.\n+            to.write_all(buf)?;\n+            len += buf.len() as u64;\n+            self.discard_buffer();\n+        }\n+    }\n }\n \n /// Specialization of the read-write loop that either uses a stack buffer\n /// or reuses the internal buffer of a BufWriter\n-trait BufferedCopySpec: Write {\n-    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64>;\n+trait BufferedWriterSpec: Write {\n+    fn buffer_size(&self) -> usize;\n+\n+    fn copy_from<R: Read + ?Sized>(&mut self, reader: &mut R) -> Result<u64>;\n }\n \n-impl<W: Write + ?Sized> BufferedCopySpec for W {\n-    default fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n-        stack_buffer_copy(reader, writer)\n+impl<W: Write + ?Sized> BufferedWriterSpec for W {\n+    #[inline]\n+    default fn buffer_size(&self) -> usize {\n+        0\n+    }\n+\n+    default fn copy_from<R: Read + ?Sized>(&mut self, reader: &mut R) -> Result<u64> {\n+        stack_buffer_copy(reader, self)\n     }\n }\n \n-impl<I: ?Sized + Write> BufferedCopySpec for BufWriter<I> {\n-    fn copy_to<R: Read + ?Sized>(reader: &mut R, writer: &mut Self) -> Result<u64> {\n-        if writer.capacity() < DEFAULT_BUF_SIZE {\n-            return stack_buffer_copy(reader, writer);\n+impl<I: Write + ?Sized> BufferedWriterSpec for BufWriter<I> {\n+    fn buffer_size(&self) -> usize {\n+        self.capacity()\n+    }\n+\n+    fn copy_from<R: Read + ?Sized>(&mut self, reader: &mut R) -> Result<u64> {\n+        if self.capacity() < DEFAULT_BUF_SIZE {\n+            return stack_buffer_copy(reader, self);\n         }\n \n         let mut len = 0;\n         let mut init = 0;\n \n         loop {\n-            let buf = writer.buffer_mut();\n+            let buf = self.buffer_mut();\n             let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n \n             unsafe {\n@@ -127,7 +211,7 @@ impl<I: ?Sized + Write> BufferedCopySpec for BufWriter<I> {\n                     Err(e) => return Err(e),\n                 }\n             } else {\n-                writer.flush_buf()?;\n+                self.flush_buf()?;\n                 init = 0;\n             }\n         }"}, {"sha": "8c816af15b808b4cf5610e8ec6f1e26a82ed4b2c", "filename": "library/std/src/io/copy/tests.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Fcopy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Fcopy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy%2Ftests.rs?ref=7513407ac8e673f536d34743fe393bd8b7c45441", "patch": "@@ -0,0 +1,108 @@\n+use crate::cmp::{max, min};\n+use crate::io::*;\n+\n+#[test]\n+fn copy_copies() {\n+    let mut r = repeat(0).take(4);\n+    let mut w = sink();\n+    assert_eq!(copy(&mut r, &mut w).unwrap(), 4);\n+\n+    let mut r = repeat(0).take(1 << 17);\n+    assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n+}\n+\n+struct ShortReader {\n+    cap: usize,\n+    read_size: usize,\n+    observed_buffer: usize,\n+}\n+\n+impl Read for ShortReader {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n+        let bytes = min(self.cap, self.read_size);\n+        self.cap -= bytes;\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(bytes)\n+    }\n+}\n+\n+struct WriteObserver {\n+    observed_buffer: usize,\n+}\n+\n+impl Write for WriteObserver {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n+        self.observed_buffer = max(self.observed_buffer, buf.len());\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn copy_specializes_bufwriter() {\n+    let cap = 117 * 1024;\n+    let buf_sz = 16 * 1024;\n+    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n+    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n+    assert_eq!(\n+        copy(&mut r, &mut w).unwrap(),\n+        cap as u64,\n+        \"expected the whole capacity to be copied\"\n+    );\n+    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n+    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n+}\n+\n+#[test]\n+fn copy_specializes_bufreader() {\n+    let mut source = vec![0; 768 * 1024];\n+    source[1] = 42;\n+    let mut buffered = BufReader::with_capacity(256 * 1024, Cursor::new(&mut source));\n+\n+    let mut sink = Vec::new();\n+    assert_eq!(crate::io::copy(&mut buffered, &mut sink).unwrap(), source.len() as u64);\n+    assert_eq!(source.as_slice(), sink.as_slice());\n+\n+    let buf_sz = 71 * 1024;\n+    assert!(buf_sz > DEFAULT_BUF_SIZE, \"test precondition\");\n+\n+    let mut buffered = BufReader::with_capacity(buf_sz, Cursor::new(&mut source));\n+    let mut sink = WriteObserver { observed_buffer: 0 };\n+    assert_eq!(crate::io::copy(&mut buffered, &mut sink).unwrap(), source.len() as u64);\n+    assert_eq!(\n+        sink.observed_buffer, buf_sz,\n+        \"expected a large buffer to be provided to the writer\"\n+    );\n+}\n+\n+#[cfg(unix)]\n+mod io_benches {\n+    use crate::fs::File;\n+    use crate::fs::OpenOptions;\n+    use crate::io::prelude::*;\n+    use crate::io::BufReader;\n+\n+    use test::Bencher;\n+\n+    #[bench]\n+    fn bench_copy_buf_reader(b: &mut Bencher) {\n+        let mut file_in = File::open(\"/dev/zero\").expect(\"opening /dev/zero failed\");\n+        // use dyn to avoid specializations unrelated to readbuf\n+        let dyn_in = &mut file_in as &mut dyn Read;\n+        let mut reader = BufReader::with_capacity(256 * 1024, dyn_in.take(0));\n+        let mut writer =\n+            OpenOptions::new().write(true).open(\"/dev/null\").expect(\"opening /dev/null failed\");\n+\n+        const BYTES: u64 = 1024 * 1024;\n+\n+        b.bytes = BYTES;\n+\n+        b.iter(|| {\n+            reader.get_mut().set_limit(BYTES);\n+            crate::io::copy(&mut reader, &mut writer).unwrap()\n+        });\n+    }\n+}"}, {"sha": "1baa94e64c94c63145b6aa0cee5d04e788e42c59", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7513407ac8e673f536d34743fe393bd8b7c45441/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=7513407ac8e673f536d34743fe393bd8b7c45441", "patch": "@@ -1,67 +1,8 @@\n-use crate::cmp::{max, min};\n use crate::io::prelude::*;\n-use crate::io::{\n-    copy, empty, repeat, sink, BorrowedBuf, BufWriter, Empty, Repeat, Result, SeekFrom, Sink,\n-    DEFAULT_BUF_SIZE,\n-};\n+use crate::io::{empty, repeat, sink, BorrowedBuf, Empty, Repeat, SeekFrom, Sink};\n \n use crate::mem::MaybeUninit;\n \n-#[test]\n-fn copy_copies() {\n-    let mut r = repeat(0).take(4);\n-    let mut w = sink();\n-    assert_eq!(copy(&mut r, &mut w).unwrap(), 4);\n-\n-    let mut r = repeat(0).take(1 << 17);\n-    assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n-}\n-\n-struct ShortReader {\n-    cap: usize,\n-    read_size: usize,\n-    observed_buffer: usize,\n-}\n-\n-impl Read for ShortReader {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\n-        let bytes = min(self.cap, self.read_size);\n-        self.cap -= bytes;\n-        self.observed_buffer = max(self.observed_buffer, buf.len());\n-        Ok(bytes)\n-    }\n-}\n-\n-struct WriteObserver {\n-    observed_buffer: usize,\n-}\n-\n-impl Write for WriteObserver {\n-    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n-        self.observed_buffer = max(self.observed_buffer, buf.len());\n-        Ok(buf.len())\n-    }\n-\n-    fn flush(&mut self) -> Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn copy_specializes_bufwriter() {\n-    let cap = 117 * 1024;\n-    let buf_sz = 16 * 1024;\n-    let mut r = ShortReader { cap, observed_buffer: 0, read_size: 1337 };\n-    let mut w = BufWriter::with_capacity(buf_sz, WriteObserver { observed_buffer: 0 });\n-    assert_eq!(\n-        copy(&mut r, &mut w).unwrap(),\n-        cap as u64,\n-        \"expected the whole capacity to be copied\"\n-    );\n-    assert_eq!(r.observed_buffer, buf_sz, \"expected a large buffer to be provided to the reader\");\n-    assert!(w.get_mut().observed_buffer > DEFAULT_BUF_SIZE, \"expected coalesced writes\");\n-}\n-\n #[test]\n fn sink_sinks() {\n     let mut s = sink();"}]}