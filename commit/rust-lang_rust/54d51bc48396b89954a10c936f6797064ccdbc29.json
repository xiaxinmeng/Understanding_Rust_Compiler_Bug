{"sha": "54d51bc48396b89954a10c936f6797064ccdbc29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZDUxYmM0ODM5NmI4OTk1NGExMGM5MzZmNjc5NzA2NGNjZGJjMjk=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-16T05:40:05Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-21T22:08:33Z"}, "message": "Allow multiple cfgs per comment in \"revisions:\" tests\n\nThe `//[X]~` syntax filters errors for tests that are run across\nmultiple cfgs with  `// revisions:`. This commit extends that syntax to\naccept `//[X,Y]~`, which will match multiple cfgs to the same error\nannotation. This is functionally the same as writing two comments,\n`//[X]~` and `//[Y]~`, but can fit on a single line.", "tree": {"sha": "df6be71ca7e202d55334b6f9acd50ec3367a0f70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df6be71ca7e202d55334b6f9acd50ec3367a0f70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54d51bc48396b89954a10c936f6797064ccdbc29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54d51bc48396b89954a10c936f6797064ccdbc29", "html_url": "https://github.com/rust-lang/rust/commit/54d51bc48396b89954a10c936f6797064ccdbc29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54d51bc48396b89954a10c936f6797064ccdbc29/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53712f8637dbe326df569a90814aae1cc5429710", "url": "https://api.github.com/repos/rust-lang/rust/commits/53712f8637dbe326df569a90814aae1cc5429710", "html_url": "https://github.com/rust-lang/rust/commit/53712f8637dbe326df569a90814aae1cc5429710"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "2524468766f2734d4814774fd7024b69c716d559", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/54d51bc48396b89954a10c936f6797064ccdbc29/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54d51bc48396b89954a10c936f6797064ccdbc29/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=54d51bc48396b89954a10c936f6797064ccdbc29", "patch": "@@ -7,7 +7,9 @@ use std::io::BufReader;\n use std::path::Path;\n use std::str::FromStr;\n \n+use lazy_static::lazy_static;\n use log::*;\n+use regex::Regex;\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum ErrorKind {\n@@ -85,20 +87,16 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n     // updating it in the map callback below.)\n     let mut last_nonfollow_error = None;\n \n-    let tag = match cfg {\n-        Some(rev) => format!(\"//[{}]~\", rev),\n-        None => \"//~\".to_string(),\n-    };\n-\n     rdr.lines()\n         .enumerate()\n         .filter_map(|(line_num, line)| {\n-            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), &tag).map(\n+            parse_expected(last_nonfollow_error, line_num + 1, &line.unwrap(), cfg).map(\n                 |(which, error)| {\n                     match which {\n                         FollowPrevious(_) => {}\n                         _ => last_nonfollow_error = Some(error.line_num),\n                     }\n+\n                     error\n                 },\n             )\n@@ -110,46 +108,53 @@ fn parse_expected(\n     last_nonfollow_error: Option<usize>,\n     line_num: usize,\n     line: &str,\n-    tag: &str,\n+    cfg: Option<&str>,\n ) -> Option<(WhichLine, Error)> {\n-    let start = line.find(tag)?;\n-    let (follow, adjusts) = if line[start + tag.len()..].chars().next().unwrap() == '|' {\n-        (true, 0)\n-    } else {\n-        (\n-            false,\n-            line[start + tag.len()..]\n-                .chars()\n-                .take_while(|c| *c == '^')\n-                .count(),\n-        )\n+    // Matches comments like:\n+    //     //~\n+    //     //~|\n+    //     //~^\n+    //     //~^^^^^\n+    //     //[cfg1]~\n+    //     //[cfg1,cfg2]~^^\n+    lazy_static! {\n+        static ref RE: Regex =\n+            Regex::new(r\"//(?:\\[(?P<cfgs>[\\w,]+)])?~(?P<adjust>\\||\\^*)\").unwrap();\n+    }\n+\n+    let captures = RE.captures(line)?;\n+\n+    match (cfg, captures.name(\"cfgs\")) {\n+        // Only error messages that contain our `cfg` betweeen the square brackets apply to us.\n+        (Some(cfg), Some(filter)) if !filter.as_str().split(',').any(|s| s == cfg)\n+            => return None,\n+        (Some(_), Some(_)) => {}\n+\n+        (None, Some(_)) => panic!(\"Only tests with revisions should use `//[X]~`\"),\n+\n+        // If an error has no list of revisions, it applies to all revisions.\n+        (Some(_), None) | (None, None) => {}\n+    }\n+\n+    let (follow, adjusts) = match &captures[\"adjust\"] {\n+        \"|\" => (true, 0),\n+        circumflexes => (false, circumflexes.len()),\n     };\n-    let kind_start = start + tag.len() + adjusts + (follow as usize);\n-    let (kind, msg);\n-    match line[kind_start..]\n+\n+    // Get the part of the comment after the sigil (e.g. `~^^` or ~|).\n+    let (_, mut msg) = line.split_at(captures.get(0).unwrap().end());\n+\n+    let first_word = msg\n         .split_whitespace()\n         .next()\n-        .expect(\"Encountered unexpected empty comment\")\n-        .parse::<ErrorKind>()\n-    {\n-        Ok(k) => {\n-            // If we find `//~ ERROR foo` or something like that:\n-            kind = Some(k);\n-            let letters = line[kind_start..].chars();\n-            msg = letters\n-                .skip_while(|c| c.is_whitespace())\n-                .skip_while(|c| !c.is_whitespace())\n-                .collect::<String>();\n-        }\n-        Err(_) => {\n-            // Otherwise we found `//~ foo`:\n-            kind = None;\n-            let letters = line[kind_start..].chars();\n-            msg = letters\n-                .skip_while(|c| c.is_whitespace())\n-                .collect::<String>();\n-        }\n+        .expect(\"Encountered unexpected empty comment\");\n+\n+    // If we find `//~ ERROR foo` or something like that, skip the first word.\n+    let kind = first_word.parse::<ErrorKind>().ok();\n+    if let Some(_) = kind {\n+        msg = &msg.trim_start().split_at(first_word.len()).1;\n     }\n+\n     let msg = msg.trim().to_owned();\n \n     let (which, line_num) = if follow {\n@@ -171,7 +176,7 @@ fn parse_expected(\n \n     debug!(\n         \"line={} tag={:?} which={:?} kind={:?} msg={:?}\",\n-        line_num, tag, which, kind, msg\n+        line_num, &captures[0], which, kind, msg\n     );\n     Some((\n         which,"}]}