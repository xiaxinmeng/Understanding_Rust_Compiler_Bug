{"sha": "c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZTc0ZjM0N2U0NGUzYTU0ZjZmZjA5NGVmOGI3NDE1ODlkNjlhYjU=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2019-12-29T01:25:57Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:36:52Z"}, "message": "Move some methods to region_infer/mod.rs", "tree": {"sha": "11b2b5d3a53c50b9a61333ff3d4bddbe6bc48b17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11b2b5d3a53c50b9a61333ff3d4bddbe6bc48b17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "html_url": "https://github.com/rust-lang/rust/commit/c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "109c30f3d4783f569eb4d9350e6045a1e96af80d", "url": "https://api.github.com/repos/rust-lang/rust/commits/109c30f3d4783f569eb4d9350e6045a1e96af80d", "html_url": "https://github.com/rust-lang/rust/commit/109c30f3d4783f569eb4d9350e6045a1e96af80d"}], "stats": {"total": 871, "additions": 440, "deletions": 431}, "files": [{"sha": "afccf8a0922a73cd5f05a38814d99b538c42445e", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "patch": "@@ -2,21 +2,22 @@\n \n use std::collections::VecDeque;\n \n+use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n     Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::adjustment::PointerCast;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_index::vec::IndexVec;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n use crate::borrow_check::{\n-    borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n-    WriteKind,\n+    borrow_set::BorrowData, diagnostics::RegionErrorNamingCtx, nll::ConstraintDescription,\n+    region_infer::Cause, MirBorrowckCtxt, WriteKind,\n };\n \n use super::{find_use, RegionName, UseSpans};\n@@ -254,6 +255,32 @@ impl BorrowExplanation {\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+    fn free_region_constraint_info(\n+        &self,\n+        borrow_region: RegionVid,\n+        outlived_region: RegionVid,\n+    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n+        let (category, from_closure, span) = self.nonlexical_regioncx.best_blame_constraint(\n+            &self.body,\n+            borrow_region,\n+            NLLRegionVariableOrigin::FreeRegion,\n+            |r| {\n+                self.nonlexical_regioncx.provides_universal_region(\n+                    r,\n+                    borrow_region,\n+                    outlived_region,\n+                )\n+            },\n+        );\n+\n+        let mut renctx = RegionErrorNamingCtx::new();\n+        let outlived_fr_name =\n+            self.nonlexical_regioncx.give_region_a_name(self, &mut renctx, outlived_region);\n+        // TODO(mark-i-m): just return the region and let the caller name it\n+\n+        (category, from_closure, span, outlived_fr_name)\n+    }\n+\n     /// Returns structured explanation for *why* the borrow contains the\n     /// point from `location`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d].\n@@ -285,7 +312,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_region_vid = borrow.region;\n         debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n \n-        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, location);\n+        let region_sub =\n+            self.nonlexical_regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {\n@@ -330,9 +358,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             None => {\n                 if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) = self\n-                        .nonlexical_regioncx\n-                        .free_region_constraint_info(self, borrow_region_vid, region);\n+                    let (category, from_closure, span, region_name) =\n+                        self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n                         BorrowExplanation::MustBeValidFor {\n@@ -345,14 +372,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     } else {\n                         debug!(\n                             \"explain_why_borrow_contains_point: \\\n-                                Could not generate a region name\"\n+                             Could not generate a region name\"\n                         );\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n                     debug!(\n                         \"explain_why_borrow_contains_point: \\\n-                            Could not generate an error region vid\"\n+                         Could not generate an error region vid\"\n                     );\n                     BorrowExplanation::Unexplained\n                 }"}, {"sha": "f9ec4ccb52a09ded964aece05de8ed5855df86ae", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 9, "deletions": 422, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "patch": "@@ -3,22 +3,18 @@\n use rustc::infer::{\n     error_reporting::nice_region_error::NiceRegionError, InferCtxt, NLLRegionVariableOrigin,\n };\n-use rustc::mir::{Body, ConstraintCategory, Location};\n+use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::IndexVec;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n-use std::collections::VecDeque;\n \n use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n-    constraints::OutlivesConstraint,\n     nll::ConstraintDescription,\n     region_infer::{values::RegionElement, RegionInferenceContext, TypeTest},\n-    type_check::Locations,\n     universal_regions::DefiningTy,\n     MirBorrowckCtxt,\n };\n@@ -48,13 +44,6 @@ impl ConstraintDescription for ConstraintCategory {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Trace {\n-    StartRegion,\n-    FromOutlivesConstraint(OutlivesConstraint),\n-    NotVisited,\n-}\n-\n /// A collection of errors encountered during region inference. This is needed to efficiently\n /// report errors after borrow checking.\n ///\n@@ -142,270 +131,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Tries to find the best constraint to blame for the fact that\n-    /// `R: from_region`, where `R` is some region that meets\n-    /// `target_test`. This works by following the constraint graph,\n-    /// creating a constraint path that forces `R` to outlive\n-    /// `from_region`, and then finding the best choices within that\n-    /// path to blame.\n-    fn best_blame_constraint(\n-        &self,\n-        body: &Body<'tcx>,\n-        from_region: RegionVid,\n-        from_region_origin: NLLRegionVariableOrigin,\n-        target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (ConstraintCategory, bool, Span) {\n-        debug!(\n-            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n-            from_region, from_region_origin\n-        );\n-\n-        // Find all paths\n-        let (path, target_region) =\n-            self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n-        debug!(\n-            \"best_blame_constraint: path={:#?}\",\n-            path.iter()\n-                .map(|&c| format!(\n-                    \"{:?} ({:?}: {:?})\",\n-                    c,\n-                    self.constraint_sccs.scc(c.sup),\n-                    self.constraint_sccs.scc(c.sub),\n-                ))\n-                .collect::<Vec<_>>()\n-        );\n-\n-        // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n-            .iter()\n-            .map(|constraint| {\n-                if constraint.category == ConstraintCategory::ClosureBounds {\n-                    self.retrieve_closure_constraint_info(body, &constraint)\n-                } else {\n-                    (constraint.category, false, constraint.locations.span(body))\n-                }\n-            })\n-            .collect();\n-        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n-\n-        // To find the best span to cite, we first try to look for the\n-        // final constraint that is interesting and where the `sup` is\n-        // not unified with the ultimate target region. The reason\n-        // for this is that we have a chain of constraints that lead\n-        // from the source to the target region, something like:\n-        //\n-        //    '0: '1 ('0 is the source)\n-        //    '1: '2\n-        //    '2: '3\n-        //    '3: '4\n-        //    '4: '5\n-        //    '5: '6 ('6 is the target)\n-        //\n-        // Some of those regions are unified with `'6` (in the same\n-        // SCC).  We want to screen those out. After that point, the\n-        // \"closest\" constraint we have to the end is going to be the\n-        // most likely to be the point where the value escapes -- but\n-        // we still want to screen for an \"interesting\" point to\n-        // highlight (e.g., a call site or something).\n-        let target_scc = self.constraint_sccs.scc(target_region);\n-        let mut range = 0..path.len();\n-\n-        // As noted above, when reporting an error, there is typically a chain of constraints\n-        // leading from some \"source\" region which must outlive some \"target\" region.\n-        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n-        // but there is one exception. When constraints arise from higher-ranked subtyping,\n-        // we generally prefer to blame the source value,\n-        // as the \"target\" in this case tends to be some type annotation that the user gave.\n-        // Therefore, if we find that the region origin is some instantiation\n-        // of a higher-ranked region, we start our search from the \"source\" point\n-        // rather than the \"target\", and we also tweak a few other things.\n-        //\n-        // An example might be this bit of Rust code:\n-        //\n-        // ```rust\n-        // let x: fn(&'static ()) = |_| {};\n-        // let y: for<'a> fn(&'a ()) = x;\n-        // ```\n-        //\n-        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n-        // In particular, the 'static is imposed through a type ascription:\n-        //\n-        // ```rust\n-        // x = ...;\n-        // AscribeUserType(x, fn(&'static ())\n-        // y = x;\n-        // ```\n-        //\n-        // We wind up ultimately with constraints like\n-        //\n-        // ```rust\n-        // !a: 'temp1 // from the `y = x` statement\n-        // 'temp1: 'temp2\n-        // 'temp2: 'static // from the AscribeUserType\n-        // ```\n-        //\n-        // and here we prefer to blame the source (the y = x statement).\n-        let blame_source = match from_region_origin {\n-            NLLRegionVariableOrigin::FreeRegion\n-            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NLLRegionVariableOrigin::Placeholder(_)\n-            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n-        };\n-\n-        let find_region = |i: &usize| {\n-            let constraint = path[*i];\n-\n-            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n-\n-            if blame_source {\n-                match categorized_path[*i].0 {\n-                    ConstraintCategory::OpaqueType\n-                    | ConstraintCategory::Boring\n-                    | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n-                    ConstraintCategory::TypeAnnotation\n-                    | ConstraintCategory::Return\n-                    | ConstraintCategory::Yield => true,\n-                    _ => constraint_sup_scc != target_scc,\n-                }\n-            } else {\n-                match categorized_path[*i].0 {\n-                    ConstraintCategory::OpaqueType\n-                    | ConstraintCategory::Boring\n-                    | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n-                    _ => true,\n-                }\n-            }\n-        };\n-\n-        let best_choice =\n-            if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n-\n-        debug!(\n-            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n-            best_choice, blame_source\n-        );\n-\n-        if let Some(i) = best_choice {\n-            if let Some(next) = categorized_path.get(i + 1) {\n-                if categorized_path[i].0 == ConstraintCategory::Return\n-                    && next.0 == ConstraintCategory::OpaqueType\n-                {\n-                    // The return expression is being influenced by the return type being\n-                    // impl Trait, point at the return type and not the return expr.\n-                    return *next;\n-                }\n-            }\n-            return categorized_path[i];\n-        }\n-\n-        // If that search fails, that is.. unusual. Maybe everything\n-        // is in the same SCC or something. In that case, find what\n-        // appears to be the most interesting point to report to the\n-        // user via an even more ad-hoc guess.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n-        debug!(\"`: sorted_path={:#?}\", categorized_path);\n-\n-        *categorized_path.first().unwrap()\n-    }\n-\n-    /// Walks the graph of constraints (where `'a: 'b` is considered\n-    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n-    /// `to_region`. The paths are accumulated into the vector\n-    /// `results`. The paths are stored as a series of\n-    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n-    ///\n-    /// Returns: a series of constraints as well as the region `R`\n-    /// that passed the target test.\n-    fn find_constraint_paths_between_regions(\n-        &self,\n-        from_region: RegionVid,\n-        target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n-        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n-        context[from_region] = Trace::StartRegion;\n-\n-        // Use a deque so that we do a breadth-first search. We will\n-        // stop at the first match, which ought to be the shortest\n-        // path (fewest constraints).\n-        let mut deque = VecDeque::new();\n-        deque.push_back(from_region);\n-\n-        while let Some(r) = deque.pop_front() {\n-            debug!(\n-                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n-                from_region,\n-                r,\n-                self.region_value_str(r),\n-            );\n-\n-            // Check if we reached the region we were looking for. If so,\n-            // we can reconstruct the path that led to it and return it.\n-            if target_test(r) {\n-                let mut result = vec![];\n-                let mut p = r;\n-                loop {\n-                    match context[p] {\n-                        Trace::NotVisited => {\n-                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n-                        }\n-\n-                        Trace::FromOutlivesConstraint(c) => {\n-                            result.push(c);\n-                            p = c.sup;\n-                        }\n-\n-                        Trace::StartRegion => {\n-                            result.reverse();\n-                            return Some((result, r));\n-                        }\n-                    }\n-                }\n-            }\n-\n-            // Otherwise, walk over the outgoing constraints and\n-            // enqueue any regions we find, keeping track of how we\n-            // reached them.\n-\n-            // A constraint like `'r: 'x` can come from our constraint\n-            // graph.\n-            let fr_static = self.universal_regions.fr_static;\n-            let outgoing_edges_from_graph =\n-                self.constraint_graph.outgoing_edges(r, &self.constraints, fr_static);\n-\n-            // Always inline this closure because it can be hot.\n-            let mut handle_constraint = #[inline(always)]\n-            |constraint: OutlivesConstraint| {\n-                debug_assert_eq!(constraint.sup, r);\n-                let sub_region = constraint.sub;\n-                if let Trace::NotVisited = context[sub_region] {\n-                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n-                    deque.push_back(sub_region);\n+    /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n+    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, 'tcx>, fr: RegionVid) -> bool {\n+        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n+            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n+                if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n+                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, infcx.tcx);\n+                    return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n                 }\n-            };\n-\n-            // This loop can be hot.\n-            for constraint in outgoing_edges_from_graph {\n-                handle_constraint(constraint);\n-            }\n-\n-            // Member constraints can also give rise to `'r: 'x` edges that\n-            // were not part of the graph initially, so watch out for those.\n-            // (But they are extremely rare; this loop is very cold.)\n-            for constraint in self.applied_member_constraints(r) {\n-                let p_c = &self.member_constraints[constraint.member_constraint_index];\n-                let constraint = OutlivesConstraint {\n-                    sup: r,\n-                    sub: constraint.min_choice,\n-                    locations: Locations::All(p_c.definition_span),\n-                    category: ConstraintCategory::OpaqueType,\n-                };\n-                handle_constraint(constraint);\n             }\n         }\n \n-        None\n+        false\n     }\n \n     /// Report an error because the universal region `fr` was required to outlive\n@@ -484,30 +221,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// We have a constraint `fr1: fr2` that is not satisfied, where\n-    /// `fr2` represents some universal region. Here, `r` is some\n-    /// region where we know that `fr1: r` and this function has the\n-    /// job of determining whether `r` is \"to blame\" for the fact that\n-    /// `fr1: fr2` is required.\n-    ///\n-    /// This is true under two conditions:\n-    ///\n-    /// - `r == fr2`\n-    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n-    ///   that cannot be named by `fr1`; in that case, we will require\n-    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n-    ///   be satisfied. (See `add_incompatible_universe`.)\n-    fn provides_universal_region(&self, r: RegionVid, fr1: RegionVid, fr2: RegionVid) -> bool {\n-        debug!(\"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\", r, fr1, fr2);\n-        let result = {\n-            r == fr2 || {\n-                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n-            }\n-        };\n-        debug!(\"provides_universal_region: result = {:?}\", result);\n-        result\n-    }\n-\n     /// Report a specialized error when `FnMut` closures return a reference to a captured variable.\n     /// This function expects `fr` to be local and `outlived_fr` to not be local.\n     ///\n@@ -817,130 +530,4 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n     }\n-\n-    crate fn free_region_constraint_info(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        borrow_region: RegionVid,\n-        outlived_region: RegionVid,\n-    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) = self.best_blame_constraint(\n-            &mbcx.body,\n-            borrow_region,\n-            NLLRegionVariableOrigin::FreeRegion,\n-            |r| self.provides_universal_region(r, borrow_region, outlived_region),\n-        );\n-\n-        let mut renctx = RegionErrorNamingCtx::new();\n-        let outlived_fr_name = self.give_region_a_name(mbcx, &mut renctx, outlived_region);\n-\n-        (category, from_closure, span, outlived_fr_name)\n-    }\n-\n-    // Finds some region R such that `fr1: R` and `R` is live at\n-    // `elem`.\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n-        self.find_constraint_paths_between_regions(fr1, |r| {\n-            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n-            debug!(\n-                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n-                r,\n-                self.liveness_constraints.region_value_str(r),\n-            );\n-            self.liveness_constraints.contains(r, elem)\n-        })\n-        .or_else(|| {\n-            // If we fail to find that, we may find some `r` such that\n-            // `fr1: r` and `r` is a placeholder from some universe\n-            // `fr1` cannot name. This would force `fr1` to be\n-            // `'static`.\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.cannot_name_placeholder(fr1, r)\n-            })\n-        })\n-        .or_else(|| {\n-            // If we fail to find THAT, it may be that `fr1` is a\n-            // placeholder that cannot \"fit\" into its SCC. In that\n-            // case, there should be some `r` where `fr1: r`, both\n-            // `fr1` and `r` are in the same SCC, and `fr1` is a\n-            // placeholder that `r` cannot name. We can blame that\n-            // edge.\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n-                    && self.cannot_name_placeholder(r, fr1)\n-            })\n-        })\n-        .map(|(_path, r)| r)\n-        .unwrap()\n-    }\n-\n-    // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n-    crate fn find_outlives_blame_span(\n-        &self,\n-        body: &Body<'tcx>,\n-        fr1: RegionVid,\n-        fr1_origin: NLLRegionVariableOrigin,\n-        fr2: RegionVid,\n-    ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-            self.provides_universal_region(r, fr1, fr2)\n-        });\n-        (category, span)\n-    }\n-\n-    fn retrieve_closure_constraint_info(\n-        &self,\n-        body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint,\n-    ) -> (ConstraintCategory, bool, Span) {\n-        let loc = match constraint.locations {\n-            Locations::All(span) => return (constraint.category, false, span),\n-            Locations::Single(loc) => loc,\n-        };\n-\n-        let opt_span_category =\n-            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n-            constraint.category,\n-            false,\n-            body.source_info(loc).span,\n-        ))\n-    }\n-\n-    /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, 'tcx>, fr: RegionVid) -> bool {\n-        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n-            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n-                if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n-                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, infcx.tcx);\n-                    return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// If `r2` represents a placeholder region, then this returns\n-    /// `true` if `r1` cannot name that placeholder in its\n-    /// value; otherwise, returns `false`.\n-    fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n-        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n-\n-        match self.definitions[r2].origin {\n-            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n-                let universe1 = self.definitions[r1].universe;\n-                debug!(\n-                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n-                    universe1, placeholder\n-                );\n-                universe1.cannot_name(placeholder.universe)\n-            }\n-\n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n-                false\n-            }\n-        }\n-    }\n }"}, {"sha": "406b28e1e3256764e6759a3a2878485ba6f2c905", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3e74f347e44e3a54f6ff094ef8b741589d69ab5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "patch": "@@ -1,3 +1,4 @@\n+use std::collections::VecDeque;\n use std::rc::Rc;\n \n use rustc::infer::canonical::QueryOutlivesConstraint;\n@@ -225,6 +226,13 @@ enum RegionRelationCheckResult {\n     Error,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Trace {\n+    StartRegion,\n+    FromOutlivesConstraint(OutlivesConstraint),\n+    NotVisited,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -1612,6 +1620,393 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .unwrap(),\n         }\n     }\n+\n+    /// We have a constraint `fr1: fr2` that is not satisfied, where\n+    /// `fr2` represents some universal region. Here, `r` is some\n+    /// region where we know that `fr1: r` and this function has the\n+    /// job of determining whether `r` is \"to blame\" for the fact that\n+    /// `fr1: fr2` is required.\n+    ///\n+    /// This is true under two conditions:\n+    ///\n+    /// - `r == fr2`\n+    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n+    ///   that cannot be named by `fr1`; in that case, we will require\n+    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n+    ///   be satisfied. (See `add_incompatible_universe`.)\n+    crate fn provides_universal_region(\n+        &self,\n+        r: RegionVid,\n+        fr1: RegionVid,\n+        fr2: RegionVid,\n+    ) -> bool {\n+        debug!(\"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\", r, fr1, fr2);\n+        let result = {\n+            r == fr2 || {\n+                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n+            }\n+        };\n+        debug!(\"provides_universal_region: result = {:?}\", result);\n+        result\n+    }\n+\n+    /// If `r2` represents a placeholder region, then this returns\n+    /// `true` if `r1` cannot name that placeholder in its\n+    /// value; otherwise, returns `false`.\n+    crate fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n+\n+        match self.definitions[r2].origin {\n+            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                let universe1 = self.definitions[r1].universe;\n+                debug!(\n+                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n+                    universe1, placeholder\n+                );\n+                universe1.cannot_name(placeholder.universe)\n+            }\n+\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n+        }\n+    }\n+\n+    crate fn retrieve_closure_constraint_info(\n+        &self,\n+        body: &Body<'tcx>,\n+        constraint: &OutlivesConstraint,\n+    ) -> (ConstraintCategory, bool, Span) {\n+        let loc = match constraint.locations {\n+            Locations::All(span) => return (constraint.category, false, span),\n+            Locations::Single(loc) => loc,\n+        };\n+\n+        let opt_span_category =\n+            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n+        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n+            constraint.category,\n+            false,\n+            body.source_info(loc).span,\n+        ))\n+    }\n+\n+    /// Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n+    crate fn find_outlives_blame_span(\n+        &self,\n+        body: &Body<'tcx>,\n+        fr1: RegionVid,\n+        fr1_origin: NLLRegionVariableOrigin,\n+        fr2: RegionVid,\n+    ) -> (ConstraintCategory, Span) {\n+        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n+            self.provides_universal_region(r, fr1, fr2)\n+        });\n+        (category, span)\n+    }\n+\n+    /// Walks the graph of constraints (where `'a: 'b` is considered\n+    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n+    /// `to_region`. The paths are accumulated into the vector\n+    /// `results`. The paths are stored as a series of\n+    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// Returns: a series of constraints as well as the region `R`\n+    /// that passed the target test.\n+    crate fn find_constraint_paths_between_regions(\n+        &self,\n+        from_region: RegionVid,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n+        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n+        context[from_region] = Trace::StartRegion;\n+\n+        // Use a deque so that we do a breadth-first search. We will\n+        // stop at the first match, which ought to be the shortest\n+        // path (fewest constraints).\n+        let mut deque = VecDeque::new();\n+        deque.push_back(from_region);\n+\n+        while let Some(r) = deque.pop_front() {\n+            debug!(\n+                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n+                from_region,\n+                r,\n+                self.region_value_str(r),\n+            );\n+\n+            // Check if we reached the region we were looking for. If so,\n+            // we can reconstruct the path that led to it and return it.\n+            if target_test(r) {\n+                let mut result = vec![];\n+                let mut p = r;\n+                loop {\n+                    match context[p] {\n+                        Trace::NotVisited => {\n+                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n+                        }\n+\n+                        Trace::FromOutlivesConstraint(c) => {\n+                            result.push(c);\n+                            p = c.sup;\n+                        }\n+\n+                        Trace::StartRegion => {\n+                            result.reverse();\n+                            return Some((result, r));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Otherwise, walk over the outgoing constraints and\n+            // enqueue any regions we find, keeping track of how we\n+            // reached them.\n+\n+            // A constraint like `'r: 'x` can come from our constraint\n+            // graph.\n+            let fr_static = self.universal_regions.fr_static;\n+            let outgoing_edges_from_graph =\n+                self.constraint_graph.outgoing_edges(r, &self.constraints, fr_static);\n+\n+            // Always inline this closure because it can be hot.\n+            let mut handle_constraint = #[inline(always)]\n+            |constraint: OutlivesConstraint| {\n+                debug_assert_eq!(constraint.sup, r);\n+                let sub_region = constraint.sub;\n+                if let Trace::NotVisited = context[sub_region] {\n+                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n+                    deque.push_back(sub_region);\n+                }\n+            };\n+\n+            // This loop can be hot.\n+            for constraint in outgoing_edges_from_graph {\n+                handle_constraint(constraint);\n+            }\n+\n+            // Member constraints can also give rise to `'r: 'x` edges that\n+            // were not part of the graph initially, so watch out for those.\n+            // (But they are extremely rare; this loop is very cold.)\n+            for constraint in self.applied_member_constraints(r) {\n+                let p_c = &self.member_constraints[constraint.member_constraint_index];\n+                let constraint = OutlivesConstraint {\n+                    sup: r,\n+                    sub: constraint.min_choice,\n+                    locations: Locations::All(p_c.definition_span),\n+                    category: ConstraintCategory::OpaqueType,\n+                };\n+                handle_constraint(constraint);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n+    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        self.find_constraint_paths_between_regions(fr1, |r| {\n+            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n+            debug!(\n+                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n+                r,\n+                self.liveness_constraints.region_value_str(r),\n+            );\n+            self.liveness_constraints.contains(r, elem)\n+        })\n+        .or_else(|| {\n+            // If we fail to find that, we may find some `r` such that\n+            // `fr1: r` and `r` is a placeholder from some universe\n+            // `fr1` cannot name. This would force `fr1` to be\n+            // `'static`.\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.cannot_name_placeholder(fr1, r)\n+            })\n+        })\n+        .or_else(|| {\n+            // If we fail to find THAT, it may be that `fr1` is a\n+            // placeholder that cannot \"fit\" into its SCC. In that\n+            // case, there should be some `r` where `fr1: r`, both\n+            // `fr1` and `r` are in the same SCC, and `fr1` is a\n+            // placeholder that `r` cannot name. We can blame that\n+            // edge.\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n+                    && self.cannot_name_placeholder(r, fr1)\n+            })\n+        })\n+        .map(|(_path, r)| r)\n+        .unwrap()\n+    }\n+\n+    /// Tries to find the best constraint to blame for the fact that\n+    /// `R: from_region`, where `R` is some region that meets\n+    /// `target_test`. This works by following the constraint graph,\n+    /// creating a constraint path that forces `R` to outlive\n+    /// `from_region`, and then finding the best choices within that\n+    /// path to blame.\n+    crate fn best_blame_constraint(\n+        &self,\n+        body: &Body<'tcx>,\n+        from_region: RegionVid,\n+        from_region_origin: NLLRegionVariableOrigin,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> (ConstraintCategory, bool, Span) {\n+        debug!(\n+            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n+            from_region, from_region_origin\n+        );\n+\n+        // Find all paths\n+        let (path, target_region) =\n+            self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n+        debug!(\n+            \"best_blame_constraint: path={:#?}\",\n+            path.iter()\n+                .map(|&c| format!(\n+                    \"{:?} ({:?}: {:?})\",\n+                    c,\n+                    self.constraint_sccs.scc(c.sup),\n+                    self.constraint_sccs.scc(c.sub),\n+                ))\n+                .collect::<Vec<_>>()\n+        );\n+\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n+            .iter()\n+            .map(|constraint| {\n+                if constraint.category == ConstraintCategory::ClosureBounds {\n+                    self.retrieve_closure_constraint_info(body, &constraint)\n+                } else {\n+                    (constraint.category, false, constraint.locations.span(body))\n+                }\n+            })\n+            .collect();\n+        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n+\n+        // To find the best span to cite, we first try to look for the\n+        // final constraint that is interesting and where the `sup` is\n+        // not unified with the ultimate target region. The reason\n+        // for this is that we have a chain of constraints that lead\n+        // from the source to the target region, something like:\n+        //\n+        //    '0: '1 ('0 is the source)\n+        //    '1: '2\n+        //    '2: '3\n+        //    '3: '4\n+        //    '4: '5\n+        //    '5: '6 ('6 is the target)\n+        //\n+        // Some of those regions are unified with `'6` (in the same\n+        // SCC).  We want to screen those out. After that point, the\n+        // \"closest\" constraint we have to the end is going to be the\n+        // most likely to be the point where the value escapes -- but\n+        // we still want to screen for an \"interesting\" point to\n+        // highlight (e.g., a call site or something).\n+        let target_scc = self.constraint_sccs.scc(target_region);\n+        let mut range = 0..path.len();\n+\n+        // As noted above, when reporting an error, there is typically a chain of constraints\n+        // leading from some \"source\" region which must outlive some \"target\" region.\n+        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n+        // but there is one exception. When constraints arise from higher-ranked subtyping,\n+        // we generally prefer to blame the source value,\n+        // as the \"target\" in this case tends to be some type annotation that the user gave.\n+        // Therefore, if we find that the region origin is some instantiation\n+        // of a higher-ranked region, we start our search from the \"source\" point\n+        // rather than the \"target\", and we also tweak a few other things.\n+        //\n+        // An example might be this bit of Rust code:\n+        //\n+        // ```rust\n+        // let x: fn(&'static ()) = |_| {};\n+        // let y: for<'a> fn(&'a ()) = x;\n+        // ```\n+        //\n+        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n+        // In particular, the 'static is imposed through a type ascription:\n+        //\n+        // ```rust\n+        // x = ...;\n+        // AscribeUserType(x, fn(&'static ())\n+        // y = x;\n+        // ```\n+        //\n+        // We wind up ultimately with constraints like\n+        //\n+        // ```rust\n+        // !a: 'temp1 // from the `y = x` statement\n+        // 'temp1: 'temp2\n+        // 'temp2: 'static // from the AscribeUserType\n+        // ```\n+        //\n+        // and here we prefer to blame the source (the y = x statement).\n+        let blame_source = match from_region_origin {\n+            NLLRegionVariableOrigin::FreeRegion\n+            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n+            NLLRegionVariableOrigin::Placeholder(_)\n+            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n+        };\n+\n+        let find_region = |i: &usize| {\n+            let constraint = path[*i];\n+\n+            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n+\n+            if blame_source {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType\n+                    | ConstraintCategory::Boring\n+                    | ConstraintCategory::BoringNoLocation\n+                    | ConstraintCategory::Internal => false,\n+                    ConstraintCategory::TypeAnnotation\n+                    | ConstraintCategory::Return\n+                    | ConstraintCategory::Yield => true,\n+                    _ => constraint_sup_scc != target_scc,\n+                }\n+            } else {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType\n+                    | ConstraintCategory::Boring\n+                    | ConstraintCategory::BoringNoLocation\n+                    | ConstraintCategory::Internal => false,\n+                    _ => true,\n+                }\n+            }\n+        };\n+\n+        let best_choice =\n+            if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n+\n+        debug!(\n+            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n+            best_choice, blame_source\n+        );\n+\n+        if let Some(i) = best_choice {\n+            if let Some(next) = categorized_path.get(i + 1) {\n+                if categorized_path[i].0 == ConstraintCategory::Return\n+                    && next.0 == ConstraintCategory::OpaqueType\n+                {\n+                    // The return expression is being influenced by the return type being\n+                    // impl Trait, point at the return type and not the return expr.\n+                    return *next;\n+                }\n+            }\n+            return categorized_path[i];\n+        }\n+\n+        // If that search fails, that is.. unusual. Maybe everything\n+        // is in the same SCC or something. In that case, find what\n+        // appears to be the most interesting point to report to the\n+        // user via an even more ad-hoc guess.\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"`: sorted_path={:#?}\", categorized_path);\n+\n+        *categorized_path.first().unwrap()\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}]}