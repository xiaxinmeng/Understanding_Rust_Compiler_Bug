{"sha": "e243f623174e661e7e2392eb234a0af9ce9129cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNDNmNjIzMTc0ZTY2MWU3ZTIzOTJlYjIzNGEwYWY5Y2U5MTI5Y2Q=", "commit": {"author": {"name": "Ayaz Hafiz", "email": "ayaz.hafiz.1@gmail.com", "date": "2020-06-09T18:45:40Z"}, "committer": {"name": "Ayaz Hafiz", "email": "ayaz.hafiz.1@gmail.com", "date": "2020-06-11T16:04:24Z"}, "message": "Provide suggestion to convert numeric op LHS rather than unwrapping RHS\n\nGiven a code\n\n```rust\nfn foo(x: u8, y: u32) -> bool {\n    x > y\n}\nfn main() {}\n```\n\nit could be more helpful to provide a suggestion to do \"u32::from(x)\"\nrather than \"y.try_into().unwrap()\", since the latter may panic.\n\nWe do this by passing the LHS of a binary expression up the stack into\nthe coercion checker.\n\nCloses #73145", "tree": {"sha": "a1b5c451a08651cda180c8d4f94d505293b3f671", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b5c451a08651cda180c8d4f94d505293b3f671"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e243f623174e661e7e2392eb234a0af9ce9129cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEP1kDyr3I3sjT29nTtEP3owMMmu0FAl7iVgoACgkQtEP3owMM\nmu2ilQ//d02MXwalbcItckdigZ2F0miEPMV+aWROUnEne9HTEuM9jQnggIcDzkPe\nM6Ca5vICNWABPoWglz++Y6RBdurzIn6mbSG7X5gWW1IdsvNx2pm9mUh7xvODc8Jn\nq7CT9PXbKSFegBa8nMZarbzJYV4heHN85XAyRJBmJ2qeClhQC183sIRp4VC5Pbov\nCEcx5GA8hU0ZAlqS/c4jGfnQkh/IitEycNDz6OE36iSFZ6YRHZ1UWnhZlb3w0i7W\nzebBnyOzpJm/WTcb/FVLHeoIjtxt55OEak0uPbBWu0TGdoRDp3BG3+APiS7xh3LO\nKDNaCv3WtiG0kG1jE3H+vZINik7PnAdWefycfWKw+GI8B0Cd7L2FbiAl/m5ZcK6k\na7TOwKEdXAcxnEnFh6RjNiIzcCGrfbGzrc7lsgLNZw1zyvouPPgVMbv7r4w13TBE\na4tTNqZTI/NN6IuC261CRKyrHpGk/UsmbxKGJpnVAna/z3Vg0Ntp+P0i20Iio/hK\nQsd5EE0IDyPKHlk7cJQgz9BfPy/Awa1lvWRebIlOPOnBxNQgF6uBfEAEuDWlVwbe\n68cE5gnJQQtZUAsDxc6XuqL+dY9H394wDWG8g8W4sKdAyIR/gue8jSEFrSEOY0s8\nDa+slo/InWtiwIGVcOnjZXo+FBLxIJxvFBVDAr7p5IUJf3xKy2o=\n=+CrU\n-----END PGP SIGNATURE-----", "payload": "tree a1b5c451a08651cda180c8d4f94d505293b3f671\nparent 50c0192c64241d723066add22c53d472e2b9cba9\nauthor Ayaz Hafiz <ayaz.hafiz.1@gmail.com> 1591728340 -0700\ncommitter Ayaz Hafiz <ayaz.hafiz.1@gmail.com> 1591891464 -0700\n\nProvide suggestion to convert numeric op LHS rather than unwrapping RHS\n\nGiven a code\n\n```rust\nfn foo(x: u8, y: u32) -> bool {\n    x > y\n}\nfn main() {}\n```\n\nit could be more helpful to provide a suggestion to do \"u32::from(x)\"\nrather than \"y.try_into().unwrap()\", since the latter may panic.\n\nWe do this by passing the LHS of a binary expression up the stack into\nthe coercion checker.\n\nCloses #73145\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e243f623174e661e7e2392eb234a0af9ce9129cd", "html_url": "https://github.com/rust-lang/rust/commit/e243f623174e661e7e2392eb234a0af9ce9129cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e243f623174e661e7e2392eb234a0af9ce9129cd/comments", "author": {"login": "ayazhafiz", "id": 20735482, "node_id": "MDQ6VXNlcjIwNzM1NDgy", "avatar_url": "https://avatars.githubusercontent.com/u/20735482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayazhafiz", "html_url": "https://github.com/ayazhafiz", "followers_url": "https://api.github.com/users/ayazhafiz/followers", "following_url": "https://api.github.com/users/ayazhafiz/following{/other_user}", "gists_url": "https://api.github.com/users/ayazhafiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayazhafiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayazhafiz/subscriptions", "organizations_url": "https://api.github.com/users/ayazhafiz/orgs", "repos_url": "https://api.github.com/users/ayazhafiz/repos", "events_url": "https://api.github.com/users/ayazhafiz/events{/privacy}", "received_events_url": "https://api.github.com/users/ayazhafiz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ayazhafiz", "id": 20735482, "node_id": "MDQ6VXNlcjIwNzM1NDgy", "avatar_url": "https://avatars.githubusercontent.com/u/20735482?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ayazhafiz", "html_url": "https://github.com/ayazhafiz", "followers_url": "https://api.github.com/users/ayazhafiz/followers", "following_url": "https://api.github.com/users/ayazhafiz/following{/other_user}", "gists_url": "https://api.github.com/users/ayazhafiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ayazhafiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ayazhafiz/subscriptions", "organizations_url": "https://api.github.com/users/ayazhafiz/orgs", "repos_url": "https://api.github.com/users/ayazhafiz/repos", "events_url": "https://api.github.com/users/ayazhafiz/events{/privacy}", "received_events_url": "https://api.github.com/users/ayazhafiz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50c0192c64241d723066add22c53d472e2b9cba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/50c0192c64241d723066add22c53d472e2b9cba9", "html_url": "https://github.com/rust-lang/rust/commit/50c0192c64241d723066add22c53d472e2b9cba9"}], "stats": {"total": 1851, "additions": 1801, "deletions": 50}, "files": [{"sha": "96c0d98ab0618d7d19f71a9bc69277646d9f74cc", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -1377,7 +1377,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 }\n \n                 if let Some(expr) = expression {\n-                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected);\n+                    fcx.emit_coerce_suggestions(&mut err, expr, found, expected, None);\n                 }\n \n                 // Error possibly reported in `check_assign` so avoid emitting error again."}, {"sha": "cc2244ccf406b59d4f30bb893dbd2ec563b8257d", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 79, "deletions": 30, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -24,10 +24,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n-        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty);\n+        self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr);\n         if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n             return;\n         }\n@@ -102,9 +103,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> Ty<'tcx> {\n-        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n+        let (ty, err) =\n+            self.demand_coerce_diag(expr, checked_ty, expected, expected_ty_expr, allow_two_phase);\n         if let Some(mut err) = err {\n             err.emit();\n         }\n@@ -121,6 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         allow_two_phase: AllowTwoPhase,\n     ) -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_vars_with_obligations(expected);\n@@ -141,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return (expected, None);\n         }\n \n-        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected);\n+        self.emit_coerce_suggestions(&mut err, expr, expr_ty, expected, expected_ty_expr);\n \n         (expected, Some(err))\n     }\n@@ -671,6 +675,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         if self.tcx.sess.source_map().is_imported(expr.span) {\n             // Ignore if span is from within a macro.\n@@ -747,7 +752,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);\n-        let try_msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n         let lit_msg = format!(\n             \"change the type of the numeric literal from `{}` to `{}`\",\n             checked_ty, expected_ty,\n@@ -761,7 +765,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n \n         let cast_suggestion = format!(\"{}{} as {}\", prefix, with_opt_paren(&src), expected_ty);\n-        let try_into_suggestion = format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n         let into_suggestion = format!(\"{}{}.into()\", prefix, with_opt_paren(&src));\n         let suffix_suggestion = with_opt_paren(&format_args!(\n             \"{}{}\",\n@@ -782,22 +785,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let in_const_context = self.tcx.hir().is_inside_const_context(expr.hir_id);\n+\n+        let suggest_fallible_into_or_lhs_from =\n+            |err: &mut DiagnosticBuilder<'_>, exp_to_found_is_fallible: bool| {\n+                // If we know the expression the expected type is derived from, we might be able\n+                // to suggest a widening conversion rather than a narrowing one (which may\n+                // panic). For example, given x: u8 and y: u32, if we know the span of \"x\",\n+                //   x > y\n+                // can be given the suggestion \"u32::from(x) > y\" rather than\n+                // \"x > y.try_into().unwrap()\".\n+                let lhs_expr_and_src = expected_ty_expr.and_then(|expr| {\n+                    match self.tcx.sess.source_map().span_to_snippet(expr.span).ok() {\n+                        Some(src) => Some((expr, src)),\n+                        None => None,\n+                    }\n+                });\n+                let (span, msg, suggestion) = if let (Some((lhs_expr, lhs_src)), false) =\n+                    (lhs_expr_and_src, exp_to_found_is_fallible)\n+                {\n+                    let msg = format!(\n+                        \"you can convert `{}` from `{}` to `{}`, matching the type of `{}`\",\n+                        lhs_src, expected_ty, checked_ty, src\n+                    );\n+                    let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src,);\n+                    (lhs_expr.span, msg, suggestion)\n+                } else {\n+                    let msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n+                    let suggestion =\n+                        format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n+                    (expr.span, msg, suggestion)\n+                };\n+                err.span_suggestion(span, &msg, suggestion, Applicability::MachineApplicable);\n+            };\n+\n         let suggest_to_change_suffix_or_into =\n-            |err: &mut DiagnosticBuilder<'_>, is_fallible: bool| {\n+            |err: &mut DiagnosticBuilder<'_>,\n+             found_to_exp_is_fallible: bool,\n+             exp_to_found_is_fallible: bool| {\n                 let msg = if literal_is_ty_suffixed(expr) {\n                     &lit_msg\n                 } else if in_const_context {\n                     // Do not recommend `into` or `try_into` in const contexts.\n                     return;\n-                } else if is_fallible {\n-                    &try_msg\n+                } else if found_to_exp_is_fallible {\n+                    return suggest_fallible_into_or_lhs_from(err, exp_to_found_is_fallible);\n                 } else {\n                     &msg\n                 };\n                 let suggestion = if literal_is_ty_suffixed(expr) {\n                     suffix_suggestion.clone()\n-                } else if is_fallible {\n-                    try_into_suggestion\n                 } else {\n                     into_suggestion.clone()\n                 };\n@@ -806,41 +842,54 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match (&expected_ty.kind, &checked_ty.kind) {\n             (&ty::Int(ref exp), &ty::Int(ref found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if exp < found => true,\n-                    (None, Some(8 | 16)) => false,\n-                    (None, _) | (_, None) => true,\n-                    _ => false,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Uint(ref exp), &ty::Uint(ref found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if exp < found => true,\n-                    (None, Some(8 | 16)) => false,\n-                    (None, _) | (_, None) => true,\n-                    _ => false,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if exp < found => (true, false),\n+                    (Some(exp), Some(found)) if exp > found => (false, true),\n+                    (None, Some(8 | 16)) => (false, true),\n+                    (Some(8 | 16), None) => (true, false),\n+                    (None, _) | (_, None) => (true, true),\n+                    _ => (false, false),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Int(exp), &ty::Uint(found)) => {\n-                let is_fallible = match (exp.bit_width(), found.bit_width()) {\n-                    (Some(exp), Some(found)) if found < exp => false,\n-                    (None, Some(8)) => false,\n-                    _ => true,\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found < exp => (false, true),\n+                    (None, Some(8)) => (false, true),\n+                    _ => (true, true),\n                 };\n-                suggest_to_change_suffix_or_into(err, is_fallible);\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n-            (&ty::Uint(_), &ty::Int(_)) => {\n-                suggest_to_change_suffix_or_into(err, true);\n+            (&ty::Uint(exp), &ty::Int(found)) => {\n+                let (f2e_is_fallible, e2f_is_fallible) = match (exp.bit_width(), found.bit_width())\n+                {\n+                    (Some(exp), Some(found)) if found > exp => (true, false),\n+                    (Some(8), None) => (true, false),\n+                    _ => (true, true),\n+                };\n+                suggest_to_change_suffix_or_into(err, f2e_is_fallible, e2f_is_fallible);\n                 true\n             }\n             (&ty::Float(ref exp), &ty::Float(ref found)) => {\n                 if found.bit_width() < exp.bit_width() {\n-                    suggest_to_change_suffix_or_into(err, false);\n+                    suggest_to_change_suffix_or_into(err, false, true);\n                 } else if literal_is_ty_suffixed(expr) {\n                     err.span_suggestion(\n                         expr.span,"}, {"sha": "902fae9dcd4705ab1b8f0f725a6c54aae9f3d46a", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n             let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty);\n+            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n             extend_err(&mut err);\n             // Error possibly reported in `check_assign` so avoid emitting error again.\n             err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n@@ -98,10 +98,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n         // checks don't need two phase\n-        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n+        self.demand_coerce(expr, ty, expected, expected_ty_expr, AllowTwoPhase::No)\n     }\n \n     pub(super) fn check_expr_with_hint(\n@@ -776,7 +777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: &Span,\n     ) -> Ty<'tcx> {\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty, Some(lhs));\n \n         let expected_ty = expected.coercion_target_type(self, expr.span);\n         if expected_ty == self.tcx.types.bool {\n@@ -1026,7 +1027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                self.check_expr_coercable_to_type(&element, uty);\n+                self.check_expr_coercable_to_type(&element, uty, None);\n                 (uty, uty)\n             }\n             None => {\n@@ -1063,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n             Some(ref fs) if i < fs.len() => {\n                 let ety = fs[i].expect_ty();\n-                self.check_expr_coercable_to_type(&e, ety);\n+                self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n             }\n             _ => self.check_expr_with_expectation(&e, NoExpectation),\n@@ -1237,7 +1238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type);\n+            self.check_expr_coercable_to_type(&field.expr, field_type, None);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -1735,7 +1736,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n-                    self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n                     element_ty\n                 }\n                 None => {\n@@ -1788,7 +1789,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         match self.resume_yield_tys {\n             Some((resume_ty, yield_ty)) => {\n-                self.check_expr_coercable_to_type(&value, yield_ty);\n+                self.check_expr_coercable_to_type(&value, yield_ty, None);\n \n                 resume_ty\n             }\n@@ -1797,7 +1798,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n             None if src.is_await() => {\n-                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n+                self.check_expr_coercable_to_type(&value, self.tcx.mk_unit(), None);\n                 self.tcx.mk_unit()\n             }\n             _ => {\n@@ -1836,11 +1837,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind {\n                 ty::FnDef(..) => {\n                     let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n-                    self.demand_coerce(expr, ty, fnptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, fnptr_ty, None, AllowTwoPhase::No);\n                 }\n                 ty::Ref(_, base_ty, mutbl) => {\n                     let ptr_ty = self.tcx.mk_ptr(ty::TypeAndMut { ty: base_ty, mutbl });\n-                    self.demand_coerce(expr, ty, ptr_ty, AllowTwoPhase::No);\n+                    self.demand_coerce(expr, ty, ptr_ty, None, AllowTwoPhase::No);\n                 }\n                 _ => {}\n             }"}, {"sha": "657565949fe12ddf585ad23b103ba002a36af026", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -1046,7 +1046,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n             // Gather locals in statics (because of block expressions).\n             GatherLocalsVisitor { fcx: &fcx, parent_id: id }.visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, revealed_ty);\n+            fcx.check_expr_coercable_to_type(&body.value, revealed_ty, None);\n \n             fcx.write_ty(id, revealed_ty);\n \n@@ -4123,7 +4123,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n                 final_arg_types.push((i, checked_ty, coerce_ty));\n \n                 // 3. Relate the expected type and the formal one,\n@@ -4541,7 +4541,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n-            self.check_expr_coercable_to_type(init, local_ty)\n+            self.check_expr_coercable_to_type(init, local_ty, None)\n         }\n     }\n \n@@ -5027,6 +5027,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some((sp, msg, suggestion, applicability)) = self.check_ref(expr, found, expected) {\n             err.span_suggestion(sp, msg, suggestion, applicability);\n@@ -5037,7 +5038,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let sp = self.sess().source_map().guess_head_span(sp);\n                 err.span_label(sp, &format!(\"{} defined here\", found));\n             }\n-        } else if !self.check_for_cast(err, expr, found, expected) {\n+        } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let is_struct_pat_shorthand_field =\n                 self.is_hir_id_from_struct_pattern_shorthand_field(expr.hir_id, expr.span);\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);"}, {"sha": "a3a27dc138be96f11605c2b3d898905673bc3160", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -57,9 +57,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n-                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(lhs_expr, tcx.types.bool, None);\n                 let lhs_diverges = self.diverges.get();\n-                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool);\n+                self.check_expr_coercable_to_type(rhs_expr, tcx.types.bool, None);\n \n                 // Depending on the LHS' value, the RHS can never execute.\n                 self.diverges.set(lhs_diverges);\n@@ -170,7 +170,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     kind: TypeVariableOriginKind::MiscVariable,\n                     span: lhs_expr.span,\n                 });\n-                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, AllowTwoPhase::No)\n+                self.demand_coerce(lhs_expr, lhs_ty, fresh_var, Some(rhs_expr), AllowTwoPhase::No)\n             }\n             IsAssign::Yes => {\n                 // rust-lang/rust#52126: We have to use strict\n@@ -196,7 +196,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n \n         // see `NB` above\n-        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var);\n+        let rhs_ty = self.check_expr_coercable_to_type(rhs_expr, rhs_ty_var, Some(lhs_expr));\n         let rhs_ty = self.resolve_vars_with_obligations(rhs_ty);\n \n         let return_ty = match result {"}, {"sha": "3cecdf18c5bac97e424ceb7ff11ffccf79f0fe0f", "filename": "src/test/ui/numeric/numeric-cast-binop.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.rs?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -0,0 +1,315 @@\n+fn main() {\n+    let x_usize: usize = 1;\n+    let x_u128: u128 = 2;\n+    let x_u64: u64 = 3;\n+    let x_u32: u32 = 4;\n+    let x_u16: u16 = 5;\n+    let x_u8: u8 = 6;\n+    let x_isize: isize = 7;\n+    let x_i128: i128 = 8;\n+    let x_i64: i64 = 9;\n+    let x_i32: i32 = 10;\n+    let x_i16: i16 = 11;\n+    let x_i8: i8 = 12;\n+    let x_i128: i128 = 13;\n+\n+    /* u<->u */\n+    {\n+        x_u8 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_u8;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u16;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u32;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u64;\n+        //~^ ERROR mismatched types\n+        x_usize > x_u128;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->i */\n+    {\n+        x_i8 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_i8;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i16;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i32;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i64;\n+        //~^ ERROR mismatched types\n+        x_isize > x_i128;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* u<->i */\n+    {\n+        x_u8 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u8 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u16 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u16 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u32 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u32 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u64 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u64 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_u128 > x_i8;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i16;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i32;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i64;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_i128;\n+        //~^ ERROR mismatched types\n+        x_u128 > x_isize;\n+        //~^ ERROR mismatched types\n+\n+        x_usize > x_i8;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i16;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i32;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i64;\n+        //~^ ERROR mismatched types\n+        x_usize > x_i128;\n+        //~^ ERROR mismatched types\n+        x_usize > x_isize;\n+        //~^ ERROR mismatched types\n+    }\n+\n+    /* i<->u */\n+    {\n+        x_i8 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i8 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i16 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i16 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i32 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i32 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i64 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i64 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_i128 > x_u8;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u16;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u32;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u64;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_u128;\n+        //~^ ERROR mismatched types\n+        x_i128 > x_usize;\n+        //~^ ERROR mismatched types\n+\n+        x_isize > x_u8;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u16;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u32;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u64;\n+        //~^ ERROR mismatched types\n+        x_isize > x_u128;\n+        //~^ ERROR mismatched types\n+        x_isize > x_usize;\n+        //~^ ERROR mismatched types\n+    }\n+}"}, {"sha": "f305c2725587c4ee10b4426f84b56ae8df6da69b", "filename": "src/test/ui/numeric/numeric-cast-binop.stderr", "status": "added", "additions": 1385, "deletions": 0, "changes": 1385, "blob_url": "https://github.com/rust-lang/rust/blob/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e243f623174e661e7e2392eb234a0af9ce9129cd/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-binop.stderr?ref=e243f623174e661e7e2392eb234a0af9ce9129cd", "patch": "@@ -0,0 +1,1385 @@\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:18:16\n+   |\n+LL |         x_u8 > x_u16;\n+   |                ^^^^^ expected `u8`, found `u16`\n+   |\n+help: you can convert `x_u8` from `u8` to `u16`, matching the type of `x_u16`\n+   |\n+LL |         u16::from(x_u8) > x_u16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:20:16\n+   |\n+LL |         x_u8 > x_u32;\n+   |                ^^^^^ expected `u8`, found `u32`\n+   |\n+help: you can convert `x_u8` from `u8` to `u32`, matching the type of `x_u32`\n+   |\n+LL |         u32::from(x_u8) > x_u32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:22:16\n+   |\n+LL |         x_u8 > x_u64;\n+   |                ^^^^^ expected `u8`, found `u64`\n+   |\n+help: you can convert `x_u8` from `u8` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u8) > x_u64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:24:16\n+   |\n+LL |         x_u8 > x_u128;\n+   |                ^^^^^^ expected `u8`, found `u128`\n+   |\n+help: you can convert `x_u8` from `u8` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u8) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:26:16\n+   |\n+LL |         x_u8 > x_usize;\n+   |                ^^^^^^^ expected `u8`, found `usize`\n+   |\n+help: you can convert `x_u8` from `u8` to `usize`, matching the type of `x_usize`\n+   |\n+LL |         usize::from(x_u8) > x_usize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:29:17\n+   |\n+LL |         x_u16 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u16`, found `u8`\n+   |                 help: you can convert an `u8` to `u16`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:31:17\n+   |\n+LL |         x_u16 > x_u32;\n+   |                 ^^^^^ expected `u16`, found `u32`\n+   |\n+help: you can convert `x_u16` from `u16` to `u32`, matching the type of `x_u32`\n+   |\n+LL |         u32::from(x_u16) > x_u32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:33:17\n+   |\n+LL |         x_u16 > x_u64;\n+   |                 ^^^^^ expected `u16`, found `u64`\n+   |\n+help: you can convert `x_u16` from `u16` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u16) > x_u64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:35:17\n+   |\n+LL |         x_u16 > x_u128;\n+   |                 ^^^^^^ expected `u16`, found `u128`\n+   |\n+help: you can convert `x_u16` from `u16` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u16) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:37:17\n+   |\n+LL |         x_u16 > x_usize;\n+   |                 ^^^^^^^ expected `u16`, found `usize`\n+   |\n+help: you can convert `x_u16` from `u16` to `usize`, matching the type of `x_usize`\n+   |\n+LL |         usize::from(x_u16) > x_usize;\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:40:17\n+   |\n+LL |         x_u32 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u32`, found `u8`\n+   |                 help: you can convert an `u8` to `u32`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:42:17\n+   |\n+LL |         x_u32 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u32`, found `u16`\n+   |                 help: you can convert an `u16` to `u32`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:44:17\n+   |\n+LL |         x_u32 > x_u64;\n+   |                 ^^^^^ expected `u32`, found `u64`\n+   |\n+help: you can convert `x_u32` from `u32` to `u64`, matching the type of `x_u64`\n+   |\n+LL |         u64::from(x_u32) > x_u64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:46:17\n+   |\n+LL |         x_u32 > x_u128;\n+   |                 ^^^^^^ expected `u32`, found `u128`\n+   |\n+help: you can convert `x_u32` from `u32` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u32) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:48:17\n+   |\n+LL |         x_u32 > x_usize;\n+   |                 ^^^^^^^ expected `u32`, found `usize`\n+   |\n+help: you can convert an `usize` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:51:17\n+   |\n+LL |         x_u64 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `u64`, found `u8`\n+   |                 help: you can convert an `u8` to `u64`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:53:17\n+   |\n+LL |         x_u64 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u64`, found `u16`\n+   |                 help: you can convert an `u16` to `u64`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:55:17\n+   |\n+LL |         x_u64 > x_u32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `u64`, found `u32`\n+   |                 help: you can convert an `u32` to `u64`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:57:17\n+   |\n+LL |         x_u64 > x_u128;\n+   |                 ^^^^^^ expected `u64`, found `u128`\n+   |\n+help: you can convert `x_u64` from `u64` to `u128`, matching the type of `x_u128`\n+   |\n+LL |         u128::from(x_u64) > x_u128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:59:17\n+   |\n+LL |         x_u64 > x_usize;\n+   |                 ^^^^^^^ expected `u64`, found `usize`\n+   |\n+help: you can convert an `usize` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:62:18\n+   |\n+LL |         x_u128 > x_u8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `u128`, found `u8`\n+   |                  help: you can convert an `u8` to `u128`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:64:18\n+   |\n+LL |         x_u128 > x_u16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u16`\n+   |                  help: you can convert an `u16` to `u128`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:66:18\n+   |\n+LL |         x_u128 > x_u32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u32`\n+   |                  help: you can convert an `u32` to `u128`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:68:18\n+   |\n+LL |         x_u128 > x_u64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `u128`, found `u64`\n+   |                  help: you can convert an `u64` to `u128`: `x_u64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:70:18\n+   |\n+LL |         x_u128 > x_usize;\n+   |                  ^^^^^^^ expected `u128`, found `usize`\n+   |\n+help: you can convert an `usize` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_usize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:73:19\n+   |\n+LL |         x_usize > x_u8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `usize`, found `u8`\n+   |                   help: you can convert an `u8` to `usize`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:75:19\n+   |\n+LL |         x_usize > x_u16;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected `usize`, found `u16`\n+   |                   help: you can convert an `u16` to `usize`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:77:19\n+   |\n+LL |         x_usize > x_u32;\n+   |                   ^^^^^ expected `usize`, found `u32`\n+   |\n+help: you can convert an `u32` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:79:19\n+   |\n+LL |         x_usize > x_u64;\n+   |                   ^^^^^ expected `usize`, found `u64`\n+   |\n+help: you can convert an `u64` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:81:19\n+   |\n+LL |         x_usize > x_u128;\n+   |                   ^^^^^^ expected `usize`, found `u128`\n+   |\n+help: you can convert an `u128` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_u128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:87:16\n+   |\n+LL |         x_i8 > x_i16;\n+   |                ^^^^^ expected `i8`, found `i16`\n+   |\n+help: you can convert `x_i8` from `i8` to `i16`, matching the type of `x_i16`\n+   |\n+LL |         i16::from(x_i8) > x_i16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:89:16\n+   |\n+LL |         x_i8 > x_i32;\n+   |                ^^^^^ expected `i8`, found `i32`\n+   |\n+help: you can convert `x_i8` from `i8` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_i8) > x_i32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:91:16\n+   |\n+LL |         x_i8 > x_i64;\n+   |                ^^^^^ expected `i8`, found `i64`\n+   |\n+help: you can convert `x_i8` from `i8` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i8) > x_i64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:93:16\n+   |\n+LL |         x_i8 > x_i128;\n+   |                ^^^^^^ expected `i8`, found `i128`\n+   |\n+help: you can convert `x_i8` from `i8` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i8) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:95:16\n+   |\n+LL |         x_i8 > x_isize;\n+   |                ^^^^^^^ expected `i8`, found `isize`\n+   |\n+help: you can convert `x_i8` from `i8` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_i8) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:98:17\n+   |\n+LL |         x_i16 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i16`, found `i8`\n+   |                 help: you can convert an `i8` to `i16`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:100:17\n+   |\n+LL |         x_i16 > x_i32;\n+   |                 ^^^^^ expected `i16`, found `i32`\n+   |\n+help: you can convert `x_i16` from `i16` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_i16) > x_i32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:102:17\n+   |\n+LL |         x_i16 > x_i64;\n+   |                 ^^^^^ expected `i16`, found `i64`\n+   |\n+help: you can convert `x_i16` from `i16` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i16) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:104:17\n+   |\n+LL |         x_i16 > x_i128;\n+   |                 ^^^^^^ expected `i16`, found `i128`\n+   |\n+help: you can convert `x_i16` from `i16` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i16) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:106:17\n+   |\n+LL |         x_i16 > x_isize;\n+   |                 ^^^^^^^ expected `i16`, found `isize`\n+   |\n+help: you can convert `x_i16` from `i16` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_i16) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:109:17\n+   |\n+LL |         x_i32 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i32`, found `i8`\n+   |                 help: you can convert an `i8` to `i32`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:111:17\n+   |\n+LL |         x_i32 > x_i16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i32`, found `i16`\n+   |                 help: you can convert an `i16` to `i32`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:113:17\n+   |\n+LL |         x_i32 > x_i64;\n+   |                 ^^^^^ expected `i32`, found `i64`\n+   |\n+help: you can convert `x_i32` from `i32` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_i32) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:115:17\n+   |\n+LL |         x_i32 > x_i128;\n+   |                 ^^^^^^ expected `i32`, found `i128`\n+   |\n+help: you can convert `x_i32` from `i32` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i32) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:117:17\n+   |\n+LL |         x_i32 > x_isize;\n+   |                 ^^^^^^^ expected `i32`, found `isize`\n+   |\n+help: you can convert an `isize` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:120:17\n+   |\n+LL |         x_i64 > x_i8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i64`, found `i8`\n+   |                 help: you can convert an `i8` to `i64`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:122:17\n+   |\n+LL |         x_i64 > x_i16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `i16`\n+   |                 help: you can convert an `i16` to `i64`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:124:17\n+   |\n+LL |         x_i64 > x_i32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `i32`\n+   |                 help: you can convert an `i32` to `i64`: `x_i32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:126:17\n+   |\n+LL |         x_i64 > x_i128;\n+   |                 ^^^^^^ expected `i64`, found `i128`\n+   |\n+help: you can convert `x_i64` from `i64` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_i64) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:128:17\n+   |\n+LL |         x_i64 > x_isize;\n+   |                 ^^^^^^^ expected `i64`, found `isize`\n+   |\n+help: you can convert an `isize` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:131:18\n+   |\n+LL |         x_i128 > x_i8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `i128`, found `i8`\n+   |                  help: you can convert an `i8` to `i128`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:133:18\n+   |\n+LL |         x_i128 > x_i16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i16`\n+   |                  help: you can convert an `i16` to `i128`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:135:18\n+   |\n+LL |         x_i128 > x_i32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i32`\n+   |                  help: you can convert an `i32` to `i128`: `x_i32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:137:18\n+   |\n+LL |         x_i128 > x_i64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `i64`\n+   |                  help: you can convert an `i64` to `i128`: `x_i64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:139:18\n+   |\n+LL |         x_i128 > x_isize;\n+   |                  ^^^^^^^ expected `i128`, found `isize`\n+   |\n+help: you can convert an `isize` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_isize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:142:19\n+   |\n+LL |         x_isize > x_i8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `isize`, found `i8`\n+   |                   help: you can convert an `i8` to `isize`: `x_i8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:144:19\n+   |\n+LL |         x_isize > x_i16;\n+   |                   ^^^^^\n+   |                   |\n+   |                   expected `isize`, found `i16`\n+   |                   help: you can convert an `i16` to `isize`: `x_i16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:146:19\n+   |\n+LL |         x_isize > x_i32;\n+   |                   ^^^^^ expected `isize`, found `i32`\n+   |\n+help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:148:19\n+   |\n+LL |         x_isize > x_i64;\n+   |                   ^^^^^ expected `isize`, found `i64`\n+   |\n+help: you can convert an `i64` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:150:19\n+   |\n+LL |         x_isize > x_i128;\n+   |                   ^^^^^^ expected `isize`, found `i128`\n+   |\n+help: you can convert an `i128` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_i128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:156:16\n+   |\n+LL |         x_u8 > x_i8;\n+   |                ^^^^ expected `u8`, found `i8`\n+   |\n+help: you can convert an `i8` to `u8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u8 > x_i8.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:158:16\n+   |\n+LL |         x_u8 > x_i16;\n+   |                ^^^^^ expected `u8`, found `i16`\n+   |\n+help: you can convert `x_u8` from `u8` to `i16`, matching the type of `x_i16`\n+   |\n+LL |         i16::from(x_u8) > x_i16;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:160:16\n+   |\n+LL |         x_u8 > x_i32;\n+   |                ^^^^^ expected `u8`, found `i32`\n+   |\n+help: you can convert `x_u8` from `u8` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_u8) > x_i32;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:162:16\n+   |\n+LL |         x_u8 > x_i64;\n+   |                ^^^^^ expected `u8`, found `i64`\n+   |\n+help: you can convert `x_u8` from `u8` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u8) > x_i64;\n+   |         ^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:164:16\n+   |\n+LL |         x_u8 > x_i128;\n+   |                ^^^^^^ expected `u8`, found `i128`\n+   |\n+help: you can convert `x_u8` from `u8` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u8) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:166:16\n+   |\n+LL |         x_u8 > x_isize;\n+   |                ^^^^^^^ expected `u8`, found `isize`\n+   |\n+help: you can convert `x_u8` from `u8` to `isize`, matching the type of `x_isize`\n+   |\n+LL |         isize::from(x_u8) > x_isize;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:169:17\n+   |\n+LL |         x_u16 > x_i8;\n+   |                 ^^^^ expected `u16`, found `i8`\n+   |\n+help: you can convert an `i8` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:171:17\n+   |\n+LL |         x_u16 > x_i16;\n+   |                 ^^^^^ expected `u16`, found `i16`\n+   |\n+help: you can convert an `i16` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:173:17\n+   |\n+LL |         x_u16 > x_i32;\n+   |                 ^^^^^ expected `u16`, found `i32`\n+   |\n+help: you can convert `x_u16` from `u16` to `i32`, matching the type of `x_i32`\n+   |\n+LL |         i32::from(x_u16) > x_i32;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:175:17\n+   |\n+LL |         x_u16 > x_i64;\n+   |                 ^^^^^ expected `u16`, found `i64`\n+   |\n+help: you can convert `x_u16` from `u16` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u16) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:177:17\n+   |\n+LL |         x_u16 > x_i128;\n+   |                 ^^^^^^ expected `u16`, found `i128`\n+   |\n+help: you can convert `x_u16` from `u16` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u16) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:179:17\n+   |\n+LL |         x_u16 > x_isize;\n+   |                 ^^^^^^^ expected `u16`, found `isize`\n+   |\n+help: you can convert an `isize` to `u16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u16 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:182:17\n+   |\n+LL |         x_u32 > x_i8;\n+   |                 ^^^^ expected `u32`, found `i8`\n+   |\n+help: you can convert an `i8` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:184:17\n+   |\n+LL |         x_u32 > x_i16;\n+   |                 ^^^^^ expected `u32`, found `i16`\n+   |\n+help: you can convert an `i16` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:186:17\n+   |\n+LL |         x_u32 > x_i32;\n+   |                 ^^^^^ expected `u32`, found `i32`\n+   |\n+help: you can convert an `i32` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_i32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:188:17\n+   |\n+LL |         x_u32 > x_i64;\n+   |                 ^^^^^ expected `u32`, found `i64`\n+   |\n+help: you can convert `x_u32` from `u32` to `i64`, matching the type of `x_i64`\n+   |\n+LL |         i64::from(x_u32) > x_i64;\n+   |         ^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:190:17\n+   |\n+LL |         x_u32 > x_i128;\n+   |                 ^^^^^^ expected `u32`, found `i128`\n+   |\n+help: you can convert `x_u32` from `u32` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u32) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:192:17\n+   |\n+LL |         x_u32 > x_isize;\n+   |                 ^^^^^^^ expected `u32`, found `isize`\n+   |\n+help: you can convert an `isize` to `u32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u32 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:195:17\n+   |\n+LL |         x_u64 > x_i8;\n+   |                 ^^^^ expected `u64`, found `i8`\n+   |\n+help: you can convert an `i8` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i8.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:197:17\n+   |\n+LL |         x_u64 > x_i16;\n+   |                 ^^^^^ expected `u64`, found `i16`\n+   |\n+help: you can convert an `i16` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:199:17\n+   |\n+LL |         x_u64 > x_i32;\n+   |                 ^^^^^ expected `u64`, found `i32`\n+   |\n+help: you can convert an `i32` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:201:17\n+   |\n+LL |         x_u64 > x_i64;\n+   |                 ^^^^^ expected `u64`, found `i64`\n+   |\n+help: you can convert an `i64` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_i64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:203:17\n+   |\n+LL |         x_u64 > x_i128;\n+   |                 ^^^^^^ expected `u64`, found `i128`\n+   |\n+help: you can convert `x_u64` from `u64` to `i128`, matching the type of `x_i128`\n+   |\n+LL |         i128::from(x_u64) > x_i128;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:205:17\n+   |\n+LL |         x_u64 > x_isize;\n+   |                 ^^^^^^^ expected `u64`, found `isize`\n+   |\n+help: you can convert an `isize` to `u64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u64 > x_isize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:208:18\n+   |\n+LL |         x_u128 > x_i8;\n+   |                  ^^^^ expected `u128`, found `i8`\n+   |\n+help: you can convert an `i8` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i8.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:210:18\n+   |\n+LL |         x_u128 > x_i16;\n+   |                  ^^^^^ expected `u128`, found `i16`\n+   |\n+help: you can convert an `i16` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i16.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:212:18\n+   |\n+LL |         x_u128 > x_i32;\n+   |                  ^^^^^ expected `u128`, found `i32`\n+   |\n+help: you can convert an `i32` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i32.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:214:18\n+   |\n+LL |         x_u128 > x_i64;\n+   |                  ^^^^^ expected `u128`, found `i64`\n+   |\n+help: you can convert an `i64` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i64.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:216:18\n+   |\n+LL |         x_u128 > x_i128;\n+   |                  ^^^^^^ expected `u128`, found `i128`\n+   |\n+help: you can convert an `i128` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_i128.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:218:18\n+   |\n+LL |         x_u128 > x_isize;\n+   |                  ^^^^^^^ expected `u128`, found `isize`\n+   |\n+help: you can convert an `isize` to `u128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_u128 > x_isize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:221:19\n+   |\n+LL |         x_usize > x_i8;\n+   |                   ^^^^ expected `usize`, found `i8`\n+   |\n+help: you can convert an `i8` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i8.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:223:19\n+   |\n+LL |         x_usize > x_i16;\n+   |                   ^^^^^ expected `usize`, found `i16`\n+   |\n+help: you can convert an `i16` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i16.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:225:19\n+   |\n+LL |         x_usize > x_i32;\n+   |                   ^^^^^ expected `usize`, found `i32`\n+   |\n+help: you can convert an `i32` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:227:19\n+   |\n+LL |         x_usize > x_i64;\n+   |                   ^^^^^ expected `usize`, found `i64`\n+   |\n+help: you can convert an `i64` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:229:19\n+   |\n+LL |         x_usize > x_i128;\n+   |                   ^^^^^^ expected `usize`, found `i128`\n+   |\n+help: you can convert an `i128` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_i128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:231:19\n+   |\n+LL |         x_usize > x_isize;\n+   |                   ^^^^^^^ expected `usize`, found `isize`\n+   |\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_usize > x_isize.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:237:16\n+   |\n+LL |         x_i8 > x_u8;\n+   |                ^^^^ expected `i8`, found `u8`\n+   |\n+help: you can convert an `u8` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u8.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:239:16\n+   |\n+LL |         x_i8 > x_u16;\n+   |                ^^^^^ expected `i8`, found `u16`\n+   |\n+help: you can convert an `u16` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u16.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:241:16\n+   |\n+LL |         x_i8 > x_u32;\n+   |                ^^^^^ expected `i8`, found `u32`\n+   |\n+help: you can convert an `u32` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u32.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:243:16\n+   |\n+LL |         x_i8 > x_u64;\n+   |                ^^^^^ expected `i8`, found `u64`\n+   |\n+help: you can convert an `u64` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u64.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:245:16\n+   |\n+LL |         x_i8 > x_u128;\n+   |                ^^^^^^ expected `i8`, found `u128`\n+   |\n+help: you can convert an `u128` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_u128.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:247:16\n+   |\n+LL |         x_i8 > x_usize;\n+   |                ^^^^^^^ expected `i8`, found `usize`\n+   |\n+help: you can convert an `usize` to `i8` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i8 > x_usize.try_into().unwrap();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:250:17\n+   |\n+LL |         x_i16 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i16`, found `u8`\n+   |                 help: you can convert an `u8` to `i16`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:252:17\n+   |\n+LL |         x_i16 > x_u16;\n+   |                 ^^^^^ expected `i16`, found `u16`\n+   |\n+help: you can convert an `u16` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u16.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:254:17\n+   |\n+LL |         x_i16 > x_u32;\n+   |                 ^^^^^ expected `i16`, found `u32`\n+   |\n+help: you can convert an `u32` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:256:17\n+   |\n+LL |         x_i16 > x_u64;\n+   |                 ^^^^^ expected `i16`, found `u64`\n+   |\n+help: you can convert an `u64` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:258:17\n+   |\n+LL |         x_i16 > x_u128;\n+   |                 ^^^^^^ expected `i16`, found `u128`\n+   |\n+help: you can convert an `u128` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:260:17\n+   |\n+LL |         x_i16 > x_usize;\n+   |                 ^^^^^^^ expected `i16`, found `usize`\n+   |\n+help: you can convert an `usize` to `i16` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i16 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:263:17\n+   |\n+LL |         x_i32 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i32`, found `u8`\n+   |                 help: you can convert an `u8` to `i32`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:265:17\n+   |\n+LL |         x_i32 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i32`, found `u16`\n+   |                 help: you can convert an `u16` to `i32`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:267:17\n+   |\n+LL |         x_i32 > x_u32;\n+   |                 ^^^^^ expected `i32`, found `u32`\n+   |\n+help: you can convert an `u32` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u32.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:269:17\n+   |\n+LL |         x_i32 > x_u64;\n+   |                 ^^^^^ expected `i32`, found `u64`\n+   |\n+help: you can convert an `u64` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:271:17\n+   |\n+LL |         x_i32 > x_u128;\n+   |                 ^^^^^^ expected `i32`, found `u128`\n+   |\n+help: you can convert an `u128` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:273:17\n+   |\n+LL |         x_i32 > x_usize;\n+   |                 ^^^^^^^ expected `i32`, found `usize`\n+   |\n+help: you can convert an `usize` to `i32` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i32 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:276:17\n+   |\n+LL |         x_i64 > x_u8;\n+   |                 ^^^^\n+   |                 |\n+   |                 expected `i64`, found `u8`\n+   |                 help: you can convert an `u8` to `i64`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:278:17\n+   |\n+LL |         x_i64 > x_u16;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `u16`\n+   |                 help: you can convert an `u16` to `i64`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:280:17\n+   |\n+LL |         x_i64 > x_u32;\n+   |                 ^^^^^\n+   |                 |\n+   |                 expected `i64`, found `u32`\n+   |                 help: you can convert an `u32` to `i64`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:282:17\n+   |\n+LL |         x_i64 > x_u64;\n+   |                 ^^^^^ expected `i64`, found `u64`\n+   |\n+help: you can convert an `u64` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_u64.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:284:17\n+   |\n+LL |         x_i64 > x_u128;\n+   |                 ^^^^^^ expected `i64`, found `u128`\n+   |\n+help: you can convert an `u128` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_u128.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:286:17\n+   |\n+LL |         x_i64 > x_usize;\n+   |                 ^^^^^^^ expected `i64`, found `usize`\n+   |\n+help: you can convert an `usize` to `i64` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i64 > x_usize.try_into().unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:289:18\n+   |\n+LL |         x_i128 > x_u8;\n+   |                  ^^^^\n+   |                  |\n+   |                  expected `i128`, found `u8`\n+   |                  help: you can convert an `u8` to `i128`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:291:18\n+   |\n+LL |         x_i128 > x_u16;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u16`\n+   |                  help: you can convert an `u16` to `i128`: `x_u16.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:293:18\n+   |\n+LL |         x_i128 > x_u32;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u32`\n+   |                  help: you can convert an `u32` to `i128`: `x_u32.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:295:18\n+   |\n+LL |         x_i128 > x_u64;\n+   |                  ^^^^^\n+   |                  |\n+   |                  expected `i128`, found `u64`\n+   |                  help: you can convert an `u64` to `i128`: `x_u64.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:297:18\n+   |\n+LL |         x_i128 > x_u128;\n+   |                  ^^^^^^ expected `i128`, found `u128`\n+   |\n+help: you can convert an `u128` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_u128.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:299:18\n+   |\n+LL |         x_i128 > x_usize;\n+   |                  ^^^^^^^ expected `i128`, found `usize`\n+   |\n+help: you can convert an `usize` to `i128` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_i128 > x_usize.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:302:19\n+   |\n+LL |         x_isize > x_u8;\n+   |                   ^^^^\n+   |                   |\n+   |                   expected `isize`, found `u8`\n+   |                   help: you can convert an `u8` to `isize`: `x_u8.into()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:304:19\n+   |\n+LL |         x_isize > x_u16;\n+   |                   ^^^^^ expected `isize`, found `u16`\n+   |\n+help: you can convert an `u16` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u16.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:306:19\n+   |\n+LL |         x_isize > x_u32;\n+   |                   ^^^^^ expected `isize`, found `u32`\n+   |\n+help: you can convert an `u32` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u32.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:308:19\n+   |\n+LL |         x_isize > x_u64;\n+   |                   ^^^^^ expected `isize`, found `u64`\n+   |\n+help: you can convert an `u64` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u64.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:310:19\n+   |\n+LL |         x_isize > x_u128;\n+   |                   ^^^^^^ expected `isize`, found `u128`\n+   |\n+help: you can convert an `u128` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_u128.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/numeric-cast-binop.rs:312:19\n+   |\n+LL |         x_isize > x_usize;\n+   |                   ^^^^^^^ expected `isize`, found `usize`\n+   |\n+help: you can convert an `usize` to `isize` and panic if the converted value wouldn't fit\n+   |\n+LL |         x_isize > x_usize.try_into().unwrap();\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 132 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}