{"sha": "b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NDE2NzdlYTMxNzVlYTBiYmExNGJiNmNlZDA1MGM4ZThmY2EzY2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-20T00:47:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T21:01:26Z"}, "message": "librustc: De-`@mut` the crate context", "tree": {"sha": "d3b5304e7663d76edcd19dcdef8d49d855f17f60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3b5304e7663d76edcd19dcdef8d49d855f17f60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "html_url": "https://github.com/rust-lang/rust/commit/b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2418cc021240f9e2b3a9a487561f387d8b97f752", "url": "https://api.github.com/repos/rust-lang/rust/commits/2418cc021240f9e2b3a9a487561f387d8b97f752", "html_url": "https://github.com/rust-lang/rust/commit/2418cc021240f9e2b3a9a487561f387d8b97f752"}], "stats": {"total": 348, "additions": 174, "deletions": 174}, "files": [{"sha": "32cdbfe59fa17c059cf5ce25ad1b0d93af4cdde8", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -520,7 +520,7 @@ pub fn symbol_hash(tcx: ty::ctxt,\n     hash.to_managed()\n }\n \n-pub fn get_symbol_hash(ccx: &mut CrateContext, t: ty::t) -> @str {\n+pub fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> @str {\n     {\n         let type_hashcodes = ccx.type_hashcodes.borrow();\n         match type_hashcodes.get().find(&t) {\n@@ -662,7 +662,7 @@ pub fn exported_name(sess: Session,\n     mangle(sess, path, Some(hash), Some(vers.as_slice()))\n }\n \n-pub fn mangle_exported_name(ccx: &mut CrateContext,\n+pub fn mangle_exported_name(ccx: &CrateContext,\n                             path: path,\n                             t: ty::t) -> ~str {\n     let hash = get_symbol_hash(ccx, t);\n@@ -671,7 +671,7 @@ pub fn mangle_exported_name(ccx: &mut CrateContext,\n                          ccx.link_meta.pkgid.version_or_default());\n }\n \n-pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n+pub fn mangle_internal_name_by_type_only(ccx: &CrateContext,\n                                          t: ty::t,\n                                          name: &str) -> ~str {\n     let s = ppaux::ty_to_short_str(ccx.tcx, t);\n@@ -683,7 +683,7 @@ pub fn mangle_internal_name_by_type_only(ccx: &mut CrateContext,\n                   None);\n }\n \n-pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n+pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,\n                                             t: ty::t,\n                                             name: &str) -> ~str {\n     let s = ppaux::ty_to_str(ccx.tcx, t);\n@@ -695,15 +695,15 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n                   None);\n }\n \n-pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n+pub fn mangle_internal_name_by_path_and_seq(ccx: &CrateContext,\n                                             mut path: path,\n                                             flav: &str) -> ~str {\n     let (_, name) = gensym_name(flav);\n     path.push(name);\n     mangle(ccx.sess, path, None, None)\n }\n \n-pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n+pub fn mangle_internal_name_by_path(ccx: &CrateContext, path: path) -> ~str {\n     mangle(ccx.sess, path, None, None)\n }\n "}, {"sha": "5d70a3ad2664cb538231c85d08fde999194ec33a", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -116,7 +116,7 @@ pub fn represent_node(bcx: @Block, node: ast::NodeId) -> @Repr {\n }\n \n /// Decides how to represent a given type.\n-pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n+pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n     debug!(\"Representing: {}\", ty_to_str(cx.tcx, t));\n     {\n         let adt_reprs = cx.adt_reprs.borrow();\n@@ -133,7 +133,7 @@ pub fn represent_type(cx: &mut CrateContext, t: ty::t) -> @Repr {\n     return repr;\n }\n \n-fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n+fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n             return Univariant(mk_struct(cx, *elems, false), false)\n@@ -255,7 +255,7 @@ pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n // this should probably all be in ty\n struct Case { discr: Disr, tys: ~[ty::t] }\n impl Case {\n-    fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n+    fn is_zerolen(&self, cx: &CrateContext) -> bool {\n         mk_struct(cx, self.tys, false).size == 0\n     }\n     fn find_ptr(&self) -> Option<uint> {\n@@ -273,7 +273,7 @@ fn get_cases(tcx: ty::ctxt, def_id: ast::DefId, substs: &ty::substs) -> ~[Case]\n }\n \n \n-fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n+fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n     let llty_rec = Type::struct_(lltys, packed);\n     Struct {\n@@ -291,15 +291,15 @@ struct IntBounds {\n     uhi: u64\n }\n \n-fn mk_cenum(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n+fn mk_cenum(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> Repr {\n     let it = range_to_inttype(cx, hint, bounds);\n     match it {\n         attr::SignedInt(_) => CEnum(it, bounds.slo as Disr, bounds.shi as Disr),\n         attr::UnsignedInt(_) => CEnum(it, bounds.ulo, bounds.uhi)\n     }\n }\n \n-fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n+fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntType {\n     debug!(\"range_to_inttype: {:?} {:?}\", hint, bounds);\n     // Lists of sizes to try.  u64 is always allowed as a fallback.\n     static choose_shortest: &'static[IntType] = &[\n@@ -339,14 +339,14 @@ fn range_to_inttype(cx: &mut CrateContext, hint: Hint, bounds: &IntBounds) -> In\n     return attr::UnsignedInt(ast::ty_u64);\n }\n \n-pub fn ll_inttype(cx: &mut CrateContext, ity: IntType) -> Type {\n+pub fn ll_inttype(cx: &CrateContext, ity: IntType) -> Type {\n     match ity {\n         attr::SignedInt(t) => Type::int_from_ty(cx, t),\n         attr::UnsignedInt(t) => Type::uint_from_ty(cx, t)\n     }\n }\n \n-fn bounds_usable(cx: &mut CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n+fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     debug!(\"bounds_usable: {:?} {:?}\", ity, bounds);\n     match ity {\n         attr::SignedInt(_) => {\n@@ -380,24 +380,24 @@ pub fn ty_of_inttype(ity: IntType) -> ty::t {\n  * and fill in the actual contents in a second pass to prevent\n  * unbounded recursion; see also the comments in `trans::type_of`.\n  */\n-pub fn type_of(cx: &mut CrateContext, r: &Repr) -> Type {\n+pub fn type_of(cx: &CrateContext, r: &Repr) -> Type {\n     generic_type_of(cx, r, None, false)\n }\n-pub fn sizing_type_of(cx: &mut CrateContext, r: &Repr) -> Type {\n+pub fn sizing_type_of(cx: &CrateContext, r: &Repr) -> Type {\n     generic_type_of(cx, r, None, true)\n }\n-pub fn incomplete_type_of(cx: &mut CrateContext, r: &Repr, name: &str) -> Type {\n+pub fn incomplete_type_of(cx: &CrateContext, r: &Repr, name: &str) -> Type {\n     generic_type_of(cx, r, Some(name), false)\n }\n-pub fn finish_type_of(cx: &mut CrateContext, r: &Repr, llty: &mut Type) {\n+pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) => { }\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n             llty.set_struct_body(struct_llfields(cx, st, false), st.packed)\n     }\n }\n \n-fn generic_type_of(cx: &mut CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n+fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n@@ -449,7 +449,7 @@ fn generic_type_of(cx: &mut CrateContext, r: &Repr, name: Option<&str>, sizing:\n     }\n }\n \n-fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n+fn struct_llfields(cx: &CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n     } else {\n@@ -705,7 +705,7 @@ pub fn trans_drop_flag_ptr(bcx: @Block, r: &Repr, val: ValueRef) -> ValueRef {\n  * this could be changed in the future to avoid allocating unnecessary\n  * space after values of shorter-than-maximum cases.\n  */\n-pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n+pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n         CEnum(ity, min, max) => {\n@@ -750,7 +750,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n  * a two-element struct will locate it at offset 4, and accesses to it\n  * will read the wrong memory.\n  */\n-fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n+fn build_const_struct(ccx: &CrateContext, st: &Struct, vals: &[ValueRef])\n     -> ~[ValueRef] {\n     assert_eq!(vals.len(), st.fields.len());\n \n@@ -791,7 +791,7 @@ fn padding(size: u64) -> ValueRef {\n fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n /// Get the discriminant of a constant value.  (Not currently used.)\n-pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n+pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n     -> Disr {\n     match *r {\n         CEnum(ity, _, _) => {\n@@ -825,7 +825,7 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n  * (Not to be confused with `common::const_get_elt`, which operates on\n  * raw LLVM-level structs and arrays.)\n  */\n-pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n+pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess.bug(\"element access in C-like enum const\"),\n@@ -836,7 +836,7 @@ pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &mut CrateContext, val: ValueRef, ix: uint)\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint)\n     -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct"}, {"sha": "d0675620dea8659042e5059d1cf987a8c18bb12d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -131,14 +131,14 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n }\n \n pub struct StatRecorder<'a> {\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n     name: &'a str,\n     start: u64,\n     istart: uint,\n }\n \n impl<'a> StatRecorder<'a> {\n-    pub fn new(ccx: @mut CrateContext,\n+    pub fn new(ccx: @CrateContext,\n                name: &'a str) -> StatRecorder<'a> {\n         let start = if ccx.sess.trans_stats() {\n             time::precise_time_ns()\n@@ -203,7 +203,7 @@ pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n     f\n }\n \n-fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n                       name: &str, did: ast::DefId) -> ValueRef {\n     {\n         let externs = ccx.externs.borrow();\n@@ -223,7 +223,7 @@ fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n     f\n }\n \n-fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t, name: &str) -> ValueRef {\n+fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str) -> ValueRef {\n     let llfty = type_of_rust_fn(ccx, inputs, output);\n     let llfn = decl_cdecl_fn(ccx.llmod, name, llfty);\n \n@@ -276,7 +276,7 @@ fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t, name: &\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+pub fn decl_internal_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n                              name: &str) -> ValueRef {\n     let llfn = decl_rust_fn(ccx, inputs, output, name);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n@@ -440,11 +440,11 @@ pub fn maybe_set_managed_unique_rc(bcx: @Block, bx: ValueRef, heap: heap) {\n \n // Type descriptor and type glue stuff\n \n-pub fn get_tydesc_simple(ccx: &mut CrateContext, t: ty::t) -> ValueRef {\n+pub fn get_tydesc_simple(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     get_tydesc(ccx, t).tydesc\n }\n \n-pub fn get_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n+pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> @mut tydesc_info {\n     {\n         let tydescs = ccx.tydescs.borrow();\n         match tydescs.get().find(&t) {\n@@ -515,7 +515,7 @@ pub fn set_no_split_stack(f: ValueRef) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: &mut CrateContext, sym: @str) {\n+pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: @str) {\n     let mut all_llvm_symbols = ccx.all_llvm_symbols.borrow_mut();\n     if all_llvm_symbols.get().contains(&sym) {\n         ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n@@ -524,7 +524,7 @@ pub fn note_unique_llvm_symbol(ccx: &mut CrateContext, sym: @str) {\n }\n \n \n-pub fn get_res_dtor(ccx: @mut CrateContext,\n+pub fn get_res_dtor(ccx: @CrateContext,\n                     did: ast::DefId,\n                     parent_id: ast::DefId,\n                     substs: &[ty::t])\n@@ -862,7 +862,7 @@ pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n     C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n-pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n+pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n@@ -1652,7 +1652,7 @@ pub fn make_return_pointer(fcx: @mut FunctionContext, output_type: ty::t) -> Val\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n+pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         path: path,\n                         llfndecl: ValueRef,\n                         id: ast::NodeId,\n@@ -1726,7 +1726,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     fcx\n }\n \n-pub fn new_fn_ctxt(ccx: @mut CrateContext,\n+pub fn new_fn_ctxt(ccx: @CrateContext,\n                    path: path,\n                    llfndecl: ValueRef,\n                    output_type: ty::t,\n@@ -1888,7 +1888,7 @@ pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-pub fn trans_closure(ccx: @mut CrateContext,\n+pub fn trans_closure(ccx: @CrateContext,\n                      path: path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n@@ -1965,7 +1965,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-pub fn trans_fn(ccx: @mut CrateContext,\n+pub fn trans_fn(ccx: @CrateContext,\n                 path: path,\n                 decl: &ast::fn_decl,\n                 body: &ast::Block,\n@@ -2022,7 +2022,7 @@ fn insert_synthetic_type_entries(bcx: @Block,\n     }\n }\n \n-pub fn trans_enum_variant(ccx: @mut CrateContext,\n+pub fn trans_enum_variant(ccx: @CrateContext,\n                           _enum_id: ast::NodeId,\n                           variant: &ast::variant,\n                           args: &[ast::variant_arg],\n@@ -2040,7 +2040,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n         llfndecl);\n }\n \n-pub fn trans_tuple_struct(ccx: @mut CrateContext,\n+pub fn trans_tuple_struct(ccx: @CrateContext,\n                           fields: &[ast::struct_field],\n                           ctor_id: ast::NodeId,\n                           param_substs: Option<@param_substs>,\n@@ -2072,7 +2072,7 @@ impl IdAndTy for ast::struct_field {\n }\n \n pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n     ctor_id: ast::NodeId,\n     args: &[A],\n     disr: ty::Disr,\n@@ -2150,7 +2150,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     finish_fn(fcx, bcx);\n }\n \n-pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n+pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::enum_def,\n                       id: ast::NodeId, vi: @~[@ty::VariantInfo],\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n@@ -2174,7 +2174,7 @@ pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n }\n \n pub struct TransItemVisitor {\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n }\n \n impl Visitor<()> for TransItemVisitor {\n@@ -2183,7 +2183,7 @@ impl Visitor<()> for TransItemVisitor {\n     }\n }\n \n-pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n+pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n     let _icx = push_ctxt(\"trans_item\");\n     let path = match ccx.tcx.items.get_copy(&item.id) {\n         ast_map::node_item(_, p) => p,\n@@ -2279,7 +2279,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n     }\n }\n \n-pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n+pub fn trans_struct_def(ccx: @CrateContext, struct_def: @ast::struct_def) {\n     // If this is a tuple-like struct, translate the constructor.\n     match struct_def.ctor_id {\n         // We only need to translate a constructor if there are fields;\n@@ -2298,14 +2298,14 @@ pub fn trans_struct_def(ccx: @mut CrateContext, struct_def: @ast::struct_def) {\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n // and control visibility.\n-pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n+pub fn trans_mod(ccx: @CrateContext, m: &ast::_mod) {\n     let _icx = push_ctxt(\"trans_mod\");\n     for item in m.items.iter() {\n         trans_item(ccx, *item);\n     }\n }\n \n-fn finish_register_fn(ccx: @mut CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n+fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::NodeId,\n                       llfn: ValueRef) {\n     {\n         let mut item_symbols = ccx.item_symbols.borrow_mut();\n@@ -2321,7 +2321,7 @@ fn finish_register_fn(ccx: @mut CrateContext, sp: Span, sym: ~str, node_id: ast:\n     }\n }\n \n-pub fn register_fn(ccx: @mut CrateContext,\n+pub fn register_fn(ccx: @CrateContext,\n                    sp: Span,\n                    sym: ~str,\n                    node_id: ast::NodeId,\n@@ -2341,7 +2341,7 @@ pub fn register_fn(ccx: @mut CrateContext,\n }\n \n // only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: @mut CrateContext,\n+pub fn register_fn_llvmty(ccx: @CrateContext,\n                           sp: Span,\n                           sym: ~str,\n                           node_id: ast::NodeId,\n@@ -2366,7 +2366,7 @@ pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n \n // Create a _rust_main(args: ~[str]) function which will be called from the\n // runtime rust_start function\n-pub fn create_entry_wrapper(ccx: @mut CrateContext,\n+pub fn create_entry_wrapper(ccx: @CrateContext,\n                            _sp: Span,\n                            main_llfn: ValueRef) {\n     let et = ccx.sess.entry_type.unwrap();\n@@ -2378,7 +2378,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         session::EntryNone => {}    // Do nothing.\n     }\n \n-    fn create_entry_fn(ccx: @mut CrateContext,\n+    fn create_entry_fn(ccx: @CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n         let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()],\n@@ -2454,7 +2454,7 @@ pub fn item_path(ccx: &CrateContext, id: &ast::NodeId) -> path {\n     ty::item_path(ccx.tcx, ast_util::local_def(*id))\n }\n \n-fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n+fn exported_name(ccx: &CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n     match attr::first_attr_value_str_by_name(attrs, \"export_name\") {\n         // Use provided name\n         Some(name) => name.to_owned(),\n@@ -2468,7 +2468,7 @@ fn exported_name(ccx: &mut CrateContext, path: path, ty: ty::t, attrs: &[ast::At\n     }\n }\n \n-pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n+pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n     debug!(\"get_item_val(id=`{:?}`)\", id);\n \n     let val = {\n@@ -2736,7 +2736,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n }\n \n-pub fn register_method(ccx: @mut CrateContext,\n+pub fn register_method(ccx: @CrateContext,\n                        id: ast::NodeId,\n                        path: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n@@ -2927,7 +2927,7 @@ pub fn trap(bcx: @Block) {\n     }\n }\n \n-pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n+pub fn decl_gc_metadata(ccx: &CrateContext, llmod_id: &str) {\n     if !ccx.sess.opts.gc || !ccx.uses_gc {\n         return;\n     }\n@@ -2947,7 +2947,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     }\n }\n \n-pub fn create_module_map(ccx: &mut CrateContext) -> (ValueRef, uint) {\n+pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n     let str_slice_type = Type::struct_([Type::i8p(), ccx.int_type], false);\n     let elttype = Type::struct_([str_slice_type, ccx.int_type], false);\n     let maptype = {\n@@ -3035,7 +3035,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     return (sym_name, map);\n }\n \n-pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n+pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     let mut subcrates: ~[ValueRef] = ~[];\n     let mut i = 1;\n     let cstore = ccx.sess.cstore;\n@@ -3165,7 +3165,7 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.pkgid.name.clone() + \".rc\";\n \n-    let ccx = @mut CrateContext::new(sess,\n+    let ccx = @CrateContext::new(sess,\n                                      llmod_id,\n                                      analysis.ty_cx,\n                                      analysis.exp_map2,"}, {"sha": "d2677294945c3cd68faeb315968a54a3a99ab0ba", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -25,7 +25,7 @@ use std::ptr::is_not_null;\n \n pub struct Builder {\n     llbuilder: BuilderRef,\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -38,7 +38,7 @@ pub fn noname() -> *c_char {\n }\n \n impl Builder {\n-    pub fn new(ccx: @mut CrateContext) -> Builder {\n+    pub fn new(ccx: @CrateContext) -> Builder {\n         Builder {\n             llbuilder: ccx.builder.B,\n             ccx: ccx,"}, {"sha": "bb05221ae10190880eb1add628ad1438fe90c3a4", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -89,7 +89,7 @@ pub struct FnType {\n     ret_ty: ArgType,\n }\n \n-pub fn compute_abi_info(ccx: &mut CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "a73c098805d6a9898910110252c18beb43ad41fd", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -127,7 +127,7 @@ fn is_reg_ty(ty: Type) -> bool {\n     }\n }\n \n-pub fn compute_abi_info(_ccx: &mut CrateContext,\n+pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "54155cd3f7825f05aa7ceed61f6abdb2c7f88dc5", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -158,7 +158,7 @@ fn struct_ty(ty: Type) -> Type {\n     return Type::struct_(fields, false);\n }\n \n-pub fn compute_abi_info(_ccx: &mut CrateContext,\n+pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "616dc0703a73e7616c4e8369c9fab3a4ba6c1c47", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -16,7 +16,7 @@ use super::common::*;\n use super::machine::*;\n use middle::trans::type_::Type;\n \n-pub fn compute_abi_info(ccx: &mut CrateContext,\n+pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "564efa8c06864770cebfe9bacefb1aeac04a4770", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -332,7 +332,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n     return Type::struct_(tys, false);\n }\n \n-pub fn compute_abi_info(_ccx: &mut CrateContext,\n+pub fn compute_abi_info(_ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {"}, {"sha": "7f9451859c7ae62849042729654dc281c83dc163", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -47,7 +47,7 @@ use syntax::{ast, ast_map};\n \n pub use middle::trans::context::CrateContext;\n \n-fn type_is_newtype_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     match ty::get(ty).sty {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n@@ -59,7 +59,7 @@ fn type_is_newtype_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+pub fn type_is_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n     use middle::trans::machine::llsize_of_alloc;\n     use middle::trans::type_of::sizing_type_of;\n     let tcx = ccx.tcx;\n@@ -261,7 +261,7 @@ pub struct FunctionContext {\n     path: path,\n \n     // This function's enclosing crate context.\n-    ccx: @mut CrateContext,\n+    ccx: @CrateContext,\n \n     // Used and maintained by the debuginfo module.\n     debug_context: debuginfo::FunctionDebugContext,\n@@ -306,7 +306,7 @@ impl FunctionContext {\n     }\n }\n \n-pub fn warn_not_to_commit(ccx: &mut CrateContext, msg: &str) {\n+pub fn warn_not_to_commit(ccx: &CrateContext, msg: &str) {\n     if !ccx.do_not_commit_warning_issued.get() {\n         ccx.do_not_commit_warning_issued.set(true);\n         ccx.sess.warn(msg.to_str() + \" -- do not commit like this!\");\n@@ -692,7 +692,7 @@ impl Block {\n         }\n     }\n \n-    pub fn ccx(&self) -> @mut CrateContext { self.fcx.ccx }\n+    pub fn ccx(&self) -> @CrateContext { self.fcx.ccx }\n     pub fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n     pub fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n@@ -888,7 +888,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n+pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         {\n             let const_cstr_cache = cx.const_cstr_cache.borrow();\n@@ -918,15 +918,15 @@ pub fn C_cstr(cx: &mut CrateContext, s: @str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: &mut CrateContext, s: @str) -> ValueRef {\n+pub fn C_estr_slice(cx: &CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n         C_struct([cs, C_uint(cx, len)], false)\n     }\n }\n \n-pub fn C_binary_slice(cx: &mut CrateContext, data: &[u8]) -> ValueRef {\n+pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n     unsafe {\n         let len = data.len();\n         let lldata = C_bytes(data);"}, {"sha": "91e737b2cd1284bf2ec5975167dbc1d89334704d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -35,7 +35,7 @@ use std::libc::c_uint;\n use std::vec;\n use syntax::{ast, ast_util, ast_map};\n \n-pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n+pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n     match lit.node {\n@@ -76,7 +76,7 @@ pub fn const_lit(cx: &mut CrateContext, e: &ast::Expr, lit: ast::lit)\n     }\n }\n \n-pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n+pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n         let mut const_globals = cx.const_globals.borrow_mut();\n@@ -85,7 +85,7 @@ pub fn const_ptrcast(cx: &mut CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     }\n }\n \n-fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n+fn const_vec(cx: @CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueRef, Type, bool) {\n     let vec_ty = ty::expr_ty(cx.tcx, e);\n     let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n@@ -99,7 +99,7 @@ fn const_vec(cx: @mut CrateContext, e: &ast::Expr, es: &[@ast::Expr]) -> (ValueR\n     (v, llunitty, inlineable.iter().fold(true, |a, &b| a && b))\n }\n \n-fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n+fn const_addr_of(cx: &CrateContext, cv: ValueRef) -> ValueRef {\n     unsafe {\n         let gv = \"const\".with_c_str(|name| {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(cv).to_ref(), name)\n@@ -111,7 +111,7 @@ fn const_addr_of(cx: &mut CrateContext, cv: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_ptr(cx: &mut CrateContext, v: ValueRef) -> ValueRef {\n+fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n     let const_globals = cx.const_globals.borrow();\n     let v = match const_globals.get().find(&(v as int)) {\n         Some(&v) => v,\n@@ -123,13 +123,13 @@ fn const_deref_ptr(cx: &mut CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype(cx: &mut CrateContext, v: ValueRef, t: ty::t)\n+fn const_deref_newtype(cx: &CrateContext, v: ValueRef, t: ty::t)\n     -> ValueRef {\n     let repr = adt::represent_type(cx, t);\n     adt::const_get_field(cx, repr, v, 0, 0)\n }\n \n-fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n+fn const_deref(cx: &CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     -> (ValueRef, ty::t) {\n     match ty::deref(cx.tcx, t, explicit) {\n         Some(ref mt) => {\n@@ -155,7 +155,7 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n     }\n }\n \n-pub fn get_const_val(cx: @mut CrateContext,\n+pub fn get_const_val(cx: @CrateContext,\n                      mut def_id: ast::DefId) -> (ValueRef, bool) {\n     let contains_key = {\n         let const_values = cx.const_values.borrow();\n@@ -181,7 +181,7 @@ pub fn get_const_val(cx: @mut CrateContext,\n      !non_inlineable_statics.get().contains(&def_id.node))\n }\n \n-pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n+pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n     let (llconst, inlineable) = const_expr_unadjusted(cx, e);\n     let mut llconst = llconst;\n     let mut inlineable = inlineable;\n@@ -265,9 +265,9 @@ pub fn const_expr(cx: @mut CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n \n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n-fn const_expr_unadjusted(cx: @mut CrateContext,\n+fn const_expr_unadjusted(cx: @CrateContext,\n                          e: &ast::Expr) -> (ValueRef, bool) {\n-    fn map_list(cx: @mut CrateContext,\n+    fn map_list(cx: @CrateContext,\n                 exprs: &[@ast::Expr]) -> (~[ValueRef], bool) {\n         exprs.iter().map(|&e| const_expr(cx, e))\n              .fold((~[], true), |(L, all_inlineable), (val, inlineable)| {\n@@ -642,7 +642,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n     }\n }\n \n-pub fn trans_const(ccx: @mut CrateContext, m: ast::Mutability, id: ast::NodeId) {\n+pub fn trans_const(ccx: @CrateContext, m: ast::Mutability, id: ast::NodeId) {\n     unsafe {\n         let _icx = push_ctxt(\"trans_const\");\n         let g = base::get_item_val(ccx, id);"}, {"sha": "0c492eac6250770333fe7c9099edfa95553a6f4e", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -237,7 +237,7 @@ impl CrateContext {\n         }\n     }\n \n-    pub fn builder(@mut self) -> Builder {\n+    pub fn builder(@self) -> Builder {\n         Builder::new(self)\n     }\n "}, {"sha": "6b8ff815a8360d94ecb6d7b14e4f611943ef9b22", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -188,7 +188,7 @@ pub fn scratch_datum(bcx: @Block, ty: ty::t, name: &str, zero: bool) -> Datum {\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n-pub fn appropriate_mode(ccx: &mut CrateContext, ty: ty::t) -> DatumMode {\n+pub fn appropriate_mode(ccx: &CrateContext, ty: ty::t) -> DatumMode {\n     /*!\n      * Indicates the \"appropriate\" mode for this value,\n      * which is either by ref or by value, depending\n@@ -492,7 +492,7 @@ impl Datum {\n         }\n     }\n \n-    pub fn appropriate_mode(&self, ccx: &mut CrateContext) -> DatumMode {\n+    pub fn appropriate_mode(&self, ccx: &CrateContext) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n         appropriate_mode(ccx, self.ty)\n@@ -857,7 +857,7 @@ impl DatumBlock {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n \n-    pub fn ccx(&self) -> @mut CrateContext {\n+    pub fn ccx(&self) -> @CrateContext {\n         self.bcx.ccx()\n     }\n "}, {"sha": "edbd2f77272feef4fb162d7ece4079cf06c219e4", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -269,7 +269,7 @@ enum VariableKind {\n }\n \n /// Create any deferred debug metadata nodes\n-pub fn finalize(cx: @mut CrateContext) {\n+pub fn finalize(cx: @CrateContext) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -593,7 +593,7 @@ pub fn start_emitting_source_locations(fcx: &mut FunctionContext) {\n /// Returns the FunctionDebugContext for the function which holds state needed for debug info\n /// creation. The function may also return another variant of the FunctionDebugContext enum which\n /// indicates why no debuginfo should be created for the function.\n-pub fn create_function_debug_context(cx: &mut CrateContext,\n+pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: Option<@param_substs>,\n                                      llfn: ValueRef) -> FunctionDebugContext {\n@@ -758,7 +758,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n     return FunctionDebugContext(fn_debug_context);\n \n-    fn get_function_signature(cx: &mut CrateContext,\n+    fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n                               fn_decl: &ast::fn_decl,\n                               param_substs: Option<@param_substs>,\n@@ -806,7 +806,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n         return create_DIArray(DIB(cx), signature);\n     }\n \n-    fn get_template_parameters(cx: &mut CrateContext,\n+    fn get_template_parameters(cx: &CrateContext,\n                                generics: &ast::Generics,\n                                param_substs: Option<@param_substs>,\n                                file_metadata: DIFile,\n@@ -918,7 +918,7 @@ fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     };\n }\n \n-fn compile_unit_metadata(cx: @mut CrateContext) {\n+fn compile_unit_metadata(cx: @CrateContext) {\n     let dcx = debug_context(cx);\n     let crate_name: &str = dcx.crate_file;\n \n@@ -959,7 +959,7 @@ fn declare_local(bcx: @Block,\n                  variable_access: VariableAccess,\n                  variable_kind: VariableKind,\n                  span: Span) {\n-    let cx: &mut CrateContext = bcx.ccx();\n+    let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name;\n     let file_metadata = file_metadata(cx, filename);\n@@ -1031,7 +1031,7 @@ fn declare_local(bcx: @Block,\n     }\n }\n \n-fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n+fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     {\n         let created_files = debug_context(cx).created_files.borrow();\n         match created_files.get().find_equiv(&full_path) {\n@@ -1083,7 +1083,7 @@ fn scope_metadata(fcx: &FunctionContext,\n     }\n }\n \n-fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n+fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n \n     debug!(\"basic_type_metadata: {:?}\", ty::get(t));\n \n@@ -1129,7 +1129,7 @@ fn basic_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     return ty_metadata;\n }\n \n-fn pointer_type_metadata(cx: &mut CrateContext,\n+fn pointer_type_metadata(cx: &CrateContext,\n                          pointer_type: ty::t,\n                          pointee_type_metadata: DIType)\n                       -> DIType {\n@@ -1150,7 +1150,7 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n }\n \n trait MemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription];\n }\n \n@@ -1160,7 +1160,7 @@ struct StructMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.fields.map(|field| {\n             let name = if field.ident.name == special_idents::unnamed_field.name {\n@@ -1179,7 +1179,7 @@ impl MemberDescriptionFactory for StructMemberDescriptionFactory {\n     }\n }\n \n-fn prepare_struct_metadata(cx: &mut CrateContext,\n+fn prepare_struct_metadata(cx: &CrateContext,\n                            struct_type: ty::t,\n                            def_id: ast::DefId,\n                            substs: &ty::substs,\n@@ -1227,7 +1227,7 @@ enum RecursiveTypeDescription {\n \n impl RecursiveTypeDescription {\n \n-    fn finalize(&self, cx: &mut CrateContext) -> DICompositeType {\n+    fn finalize(&self, cx: &CrateContext) -> DICompositeType {\n         match *self {\n             FinalMetadata(metadata) => metadata,\n             UnfinishedMetadata {\n@@ -1267,7 +1267,7 @@ struct TupleMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.component_types.map(|&component_type| {\n             MemberDescription {\n@@ -1280,7 +1280,7 @@ impl MemberDescriptionFactory for TupleMemberDescriptionFactory {\n     }\n }\n \n-fn prepare_tuple_metadata(cx: &mut CrateContext,\n+fn prepare_tuple_metadata(cx: &CrateContext,\n                           tuple_type: ty::t,\n                           component_types: &[ty::t],\n                           span: Span)\n@@ -1318,7 +1318,7 @@ struct GeneralMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for GeneralMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         // Capture type_rep, so we don't have to copy the struct_defs array\n         let struct_defs = match *self.type_rep {\n@@ -1365,7 +1365,7 @@ struct EnumVariantMemberDescriptionFactory {\n }\n \n impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n-    fn create_member_descriptions(&self, cx: &mut CrateContext)\n+    fn create_member_descriptions(&self, cx: &CrateContext)\n                                   -> ~[MemberDescription] {\n         self.args.iter().enumerate().map(|(i, &(name, ty))| {\n             MemberDescription {\n@@ -1381,7 +1381,7 @@ impl MemberDescriptionFactory for EnumVariantMemberDescriptionFactory {\n     }\n }\n \n-fn describe_variant(cx: &mut CrateContext,\n+fn describe_variant(cx: &CrateContext,\n                     struct_def: &adt::Struct,\n                     variant_info: &ty::VariantInfo,\n                     discriminant_type_metadata: Option<DIType>,\n@@ -1444,7 +1444,7 @@ fn describe_variant(cx: &mut CrateContext,\n     (metadata_stub, variant_llvm_type, member_description_factory)\n }\n \n-fn prepare_enum_metadata(cx: &mut CrateContext,\n+fn prepare_enum_metadata(cx: &CrateContext,\n                          enum_type: ty::t,\n                          enum_def_id: ast::DefId,\n                          span: Span)\n@@ -1609,7 +1609,7 @@ struct MemberDescription {\n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n-fn composite_type_metadata(cx: &mut CrateContext,\n+fn composite_type_metadata(cx: &CrateContext,\n                            composite_llvm_type: Type,\n                            composite_type_name: &str,\n                            member_descriptions: &[MemberDescription],\n@@ -1636,7 +1636,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n     return composite_type_metadata;\n }\n \n-fn set_members_of_composite_type(cx: &mut CrateContext,\n+fn set_members_of_composite_type(cx: &CrateContext,\n                                  composite_type_metadata: DICompositeType,\n                                  composite_llvm_type: Type,\n                                  member_descriptions: &[MemberDescription],\n@@ -1696,7 +1696,7 @@ fn set_members_of_composite_type(cx: &mut CrateContext,\n \n // A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any caching, does not\n // add any fields to the struct. This can be done later with set_members_of_composite_type().\n-fn create_struct_stub(cx: &mut CrateContext,\n+fn create_struct_stub(cx: &CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n                       containing_scope: DIScope,\n@@ -1739,7 +1739,7 @@ fn create_struct_stub(cx: &mut CrateContext,\n     };\n }\n \n-fn boxed_type_metadata(cx: &mut CrateContext,\n+fn boxed_type_metadata(cx: &CrateContext,\n                        content_type_name: Option<&str>,\n                        content_llvm_type: Type,\n                        content_type_metadata: DIType,\n@@ -1818,7 +1818,7 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn fixed_vec_metadata(cx: &mut CrateContext,\n+fn fixed_vec_metadata(cx: &CrateContext,\n                       element_type: ty::t,\n                       len: uint,\n                       span: Span)\n@@ -1845,7 +1845,7 @@ fn fixed_vec_metadata(cx: &mut CrateContext,\n     };\n }\n \n-fn vec_metadata(cx: &mut CrateContext,\n+fn vec_metadata(cx: &CrateContext,\n                 element_type: ty::t,\n                 span: Span)\n              -> DICompositeType {\n@@ -1905,7 +1905,7 @@ fn vec_metadata(cx: &mut CrateContext,\n         span);\n }\n \n-fn boxed_vec_metadata(cx: &mut CrateContext,\n+fn boxed_vec_metadata(cx: &CrateContext,\n                       element_type: ty::t,\n                       span: Span)\n                    -> DICompositeType {\n@@ -1922,7 +1922,7 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n         span);\n }\n \n-fn vec_slice_metadata(cx: &mut CrateContext,\n+fn vec_slice_metadata(cx: &CrateContext,\n                       vec_type: ty::t,\n                       element_type: ty::t,\n                       span: Span)\n@@ -1967,7 +1967,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n         file_metadata,\n         span);\n \n-    fn slice_layout_is_correct(cx: &mut CrateContext,\n+    fn slice_layout_is_correct(cx: &CrateContext,\n                                member_llvm_types: &[Type],\n                                element_type: ty::t)\n                             -> bool {\n@@ -1977,7 +1977,7 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn subroutine_type_metadata(cx: &mut CrateContext,\n+fn subroutine_type_metadata(cx: &CrateContext,\n                             signature: &ty::FnSig,\n                             span: Span)\n                          -> DICompositeType {\n@@ -2005,7 +2005,7 @@ fn subroutine_type_metadata(cx: &mut CrateContext,\n     };\n }\n \n-fn trait_metadata(cx: &mut CrateContext,\n+fn trait_metadata(cx: &CrateContext,\n                   def_id: ast::DefId,\n                   trait_type: ty::t,\n                   substs: &ty::substs,\n@@ -2046,7 +2046,7 @@ fn cache_id_for_type(t: ty::t) -> uint {\n     ty::type_id(t)\n }\n \n-fn type_metadata(cx: &mut CrateContext,\n+fn type_metadata(cx: &CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n@@ -2060,7 +2060,7 @@ fn type_metadata(cx: &mut CrateContext,\n         }\n     }\n \n-    fn create_pointer_to_box_metadata(cx: &mut CrateContext,\n+    fn create_pointer_to_box_metadata(cx: &CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n@@ -2192,7 +2192,7 @@ impl DebugLocation {\n     }\n }\n \n-fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n+fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n     if debug_location == debug_context(cx).current_debug_location.get() {\n         return;\n     }\n@@ -2232,7 +2232,7 @@ fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n     cx.sess.codemap.lookup_char_pos(span.lo)\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, llvm_type: Type) -> (uint, uint) {\n+fn size_and_align_of(cx: &CrateContext, llvm_type: Type) -> (uint, uint) {\n     (machine::llsize_of_alloc(cx, llvm_type), machine::llalign_of_min(cx, llvm_type))\n }\n \n@@ -2241,8 +2241,8 @@ fn bytes_to_bits(bytes: uint) -> c_ulonglong {\n }\n \n #[inline]\n-fn debug_context<'a>(cx: &'a mut CrateContext) -> &'a CrateDebugContext {\n-    let debug_context: &'a CrateDebugContext = cx.dbg_cx.get_mut_ref();\n+fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n+    let debug_context: &'a CrateDebugContext = cx.dbg_cx.get_ref();\n     debug_context\n }\n \n@@ -2264,7 +2264,7 @@ fn assert_type_for_node_id(cx: &CrateContext, node_id: ast::NodeId, error_span:\n     }\n }\n \n-fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n+fn get_namespace_and_span_for_item(cx: &CrateContext,\n                                    def_id: ast::DefId,\n                                    warning_span: Span)\n                                 -> (DIScope, Span) {\n@@ -2295,7 +2295,7 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n // scope, creating DIScope DIEs along the way, and introducing *artificial* lexical scope\n // descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n // shadowing.\n-fn populate_scope_map(cx: &mut CrateContext,\n+fn populate_scope_map(cx: &CrateContext,\n                       arg_pats: &[@ast::Pat],\n                       fn_entry_block: &ast::Block,\n                       fn_metadata: DISubprogram,\n@@ -2328,11 +2328,11 @@ fn populate_scope_map(cx: &mut CrateContext,\n     });\n \n     // local helper functions for walking the AST.\n-    fn with_new_scope(cx: &mut CrateContext,\n+    fn with_new_scope(cx: &CrateContext,\n                       scope_span: Span,\n                       scope_stack: &mut ~[ScopeStackEntry],\n                       scope_map: &mut HashMap<ast::NodeId, DIScope>,\n-                      inner_walk: |&mut CrateContext,\n+                      inner_walk: |&CrateContext,\n                                    &mut ~[ScopeStackEntry],\n                                    &mut HashMap<ast::NodeId, DIScope>|) {\n         // Create a new lexical scope and push it onto the stack\n@@ -2365,7 +2365,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         scope_stack.pop();\n     }\n \n-    fn walk_block(cx: &mut CrateContext,\n+    fn walk_block(cx: &CrateContext,\n                   block: &ast::Block,\n                   scope_stack: &mut ~[ScopeStackEntry],\n                   scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2388,7 +2388,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    fn walk_decl(cx: &mut CrateContext,\n+    fn walk_decl(cx: &CrateContext,\n                  decl: &ast::Decl,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2406,7 +2406,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    fn walk_pattern(cx: &mut CrateContext,\n+    fn walk_pattern(cx: &CrateContext,\n                     pat: @ast::Pat,\n                     scope_stack: &mut ~[ScopeStackEntry],\n                     scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2553,7 +2553,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n         }\n     }\n \n-    fn walk_expr(cx: &mut CrateContext,\n+    fn walk_expr(cx: &CrateContext,\n                  exp: &ast::Expr,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n@@ -2791,7 +2791,7 @@ impl NamespaceTreeNode {\n     }\n }\n \n-fn namespace_for_item(cx: &mut CrateContext,\n+fn namespace_for_item(cx: &CrateContext,\n                       def_id: ast::DefId,\n                       warning_span: Span)\n                    -> @NamespaceTreeNode {"}, {"sha": "095dee497030b1a33ad19f82cfd39a4b2284f859", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -997,7 +997,7 @@ fn trans_lvalue_unadjusted(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n             ast::DefStatic(did, _) => {\n                 let const_ty = expr_ty(bcx, ref_expr);\n \n-                fn get_did(ccx: @mut CrateContext, did: ast::DefId)\n+                fn get_did(ccx: @CrateContext, did: ast::DefId)\n                     -> ast::DefId {\n                     if did.crate != ast::LOCAL_CRATE {\n                         inline::maybe_instantiate_inline(ccx, did)"}, {"sha": "21f268fb9471fcf81080a2ff30b2b03da54ecf29", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -72,7 +72,7 @@ struct LlvmSignature {\n ///////////////////////////////////////////////////////////////////////////\n // Calls to external functions\n \n-pub fn llvm_calling_convention(ccx: &mut CrateContext,\n+pub fn llvm_calling_convention(ccx: &CrateContext,\n                                abis: AbiSet) -> Option<CallConv> {\n     let os = ccx.sess.targ_cfg.os;\n     let arch = ccx.sess.targ_cfg.arch;\n@@ -105,7 +105,7 @@ pub fn llvm_calling_convention(ccx: &mut CrateContext,\n }\n \n \n-pub fn register_foreign_item_fn(ccx: @mut CrateContext,\n+pub fn register_foreign_item_fn(ccx: @CrateContext,\n                                 abis: AbiSet,\n                                 path: &ast_map::path,\n                                 foreign_item: @ast::foreign_item) -> ValueRef {\n@@ -349,7 +349,7 @@ pub fn trans_native_call(bcx: @Block,\n     return bcx;\n }\n \n-pub fn trans_foreign_mod(ccx: @mut CrateContext,\n+pub fn trans_foreign_mod(ccx: @CrateContext,\n                          foreign_mod: &ast::foreign_mod) {\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n@@ -398,7 +398,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n // inline the one into the other. Of course we could just generate the\n // correct code in the first place, but this is much simpler.\n \n-pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+pub fn register_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                                          sp: Span,\n                                          sym: ~str,\n                                          node_id: ast::NodeId)\n@@ -427,7 +427,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n     llfn\n }\n \n-pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n+pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                                       path: &ast_map::path,\n                                       decl: &ast::fn_decl,\n                                       body: &ast::Block,\n@@ -445,7 +445,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         return build_wrap_fn(ccx, llrustfn, llwrapfn, &tys);\n     }\n \n-    fn build_rust_fn(ccx: @mut CrateContext,\n+    fn build_rust_fn(ccx: @CrateContext,\n                      path: &ast_map::path,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n@@ -494,7 +494,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n         return llfndecl;\n     }\n \n-    unsafe fn build_wrap_fn(ccx: @mut CrateContext,\n+    unsafe fn build_wrap_fn(ccx: @CrateContext,\n                             llrustfn: ValueRef,\n                             llwrapfn: ValueRef,\n                             tys: &ForeignTypes) {\n@@ -746,7 +746,7 @@ pub fn link_name(ccx: &CrateContext, i: @ast::foreign_item) -> @str {\n     }\n }\n \n-fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n+fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n                      -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n@@ -765,12 +765,12 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::\n     }\n }\n \n-fn foreign_types_for_id(ccx: &mut CrateContext,\n+fn foreign_types_for_id(ccx: &CrateContext,\n                         id: ast::NodeId) -> ForeignTypes {\n     foreign_types_for_fn_ty(ccx, ty::node_id_to_type(ccx.tcx, id))\n }\n \n-fn foreign_types_for_fn_ty(ccx: &mut CrateContext,\n+fn foreign_types_for_fn_ty(ccx: &CrateContext,\n                            ty: ty::t) -> ForeignTypes {\n     let fn_sig = match ty::get(ty).sty {\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n@@ -842,7 +842,7 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n     }\n }\n \n-pub fn lltype_for_foreign_fn(ccx: &mut CrateContext, ty: ty::t) -> Type {\n+pub fn lltype_for_foreign_fn(ccx: &CrateContext, ty: ty::t) -> Type {\n     let fn_types = foreign_types_for_fn_ty(ccx, ty);\n     lltype_for_fn_from_foreign_types(&fn_types)\n }"}, {"sha": "a6869dce2133a7959276e4ddc13cf653a6d431e0", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -108,7 +108,7 @@ pub fn free_ty_immediate(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     }\n }\n \n-pub fn lazily_emit_all_tydesc_glue(ccx: @mut CrateContext,\n+pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n                                    static_ti: @mut tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n@@ -173,7 +173,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n+pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n                                           field: uint,\n                                           ti: &mut tydesc_info) -> bool {\n     let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n@@ -198,7 +198,7 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @mut CrateContext,\n }\n \n \n-pub fn lazily_emit_tydesc_glue(ccx: @mut CrateContext,\n+pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                                field: uint,\n                                ti: @mut tydesc_info) {\n     let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n@@ -586,7 +586,7 @@ pub fn incr_refcnt_of_boxed(cx: @Block, box_ptr: ValueRef) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n+pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @mut tydesc_info {\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n     assert!(!ccx.finished_tydescs.get());\n@@ -642,7 +642,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n pub type glue_helper<'a> = 'a |@Block, ValueRef, ty::t|\n                                      -> @Block;\n \n-pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n+pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n                             name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n@@ -652,7 +652,7 @@ pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,\n     return llfn;\n }\n \n-pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n+pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                t: ty::t,\n                                llfn: ValueRef,\n                                helper: glue_helper)\n@@ -679,7 +679,7 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     return llfn;\n }\n \n-pub fn make_generic_glue(ccx: @mut CrateContext,\n+pub fn make_generic_glue(ccx: @CrateContext,\n                          t: ty::t,\n                          llfn: ValueRef,\n                          helper: glue_helper,\n@@ -691,7 +691,7 @@ pub fn make_generic_glue(ccx: @mut CrateContext,\n     make_generic_glue_inner(ccx, t, llfn, helper)\n }\n \n-pub fn emit_tydescs(ccx: &mut CrateContext) {\n+pub fn emit_tydescs(ccx: &CrateContext) {\n     let _icx = push_ctxt(\"emit_tydescs\");\n     // As of this point, allow no more tydescs to be created.\n     ccx.finished_tydescs.set(true);"}, {"sha": "81f04d0c373e73df5097110317a9a701c2a13559", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -23,7 +23,7 @@ use syntax::ast_map::path_name;\n use syntax::ast_util::local_def;\n use syntax::attr;\n \n-pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n+pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n     -> ast::DefId {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n     {"}, {"sha": "cd19bc7be0ca70d44883b5eda2fd9cd66aa2d3eb", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::ty_to_str;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n \n-pub fn trans_intrinsic(ccx: @mut CrateContext,\n+pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: &ast::foreign_item,\n                        path: ast_map::path,"}, {"sha": "2fdc444920a7305f0b99c73aae95b3428b0d26d0", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -46,7 +46,7 @@ for non-monomorphized methods only.  Other methods will\n be generated once they are invoked with specific type parameters,\n see `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n */\n-pub fn trans_impl(ccx: @mut CrateContext,\n+pub fn trans_impl(ccx: @CrateContext,\n                   path: path,\n                   name: ast::Ident,\n                   methods: &[@ast::method],\n@@ -97,7 +97,7 @@ pub fn trans_impl(ccx: @mut CrateContext,\n /// * `impl_id`: the node ID of the impl this method is inside\n ///\n /// XXX(pcwalton) Can we take `path` by reference?\n-pub fn trans_method(ccx: @mut CrateContext,\n+pub fn trans_method(ccx: @CrateContext,\n                     path: path,\n                     method: &ast::method,\n                     param_substs: Option<@param_substs>,\n@@ -293,7 +293,7 @@ pub fn trans_static_method_callee(bcx: @Block,\n     }\n }\n \n-pub fn method_with_name(ccx: &mut CrateContext,\n+pub fn method_with_name(ccx: &CrateContext,\n                         impl_id: ast::DefId,\n                         name: ast::Name) -> ast::DefId {\n     {\n@@ -509,7 +509,7 @@ pub fn trans_trait_callee_from_llval(bcx: @Block,\n     };\n }\n \n-pub fn vtable_id(ccx: @mut CrateContext,\n+pub fn vtable_id(ccx: @CrateContext,\n                  origin: &typeck::vtable_origin)\n               -> mono_id {\n     match origin {\n@@ -573,7 +573,7 @@ pub fn get_vtable(bcx: @Block,\n }\n \n /// Helper function to declare and initialize the vtable.\n-pub fn make_vtable(ccx: &mut CrateContext,\n+pub fn make_vtable(ccx: &CrateContext,\n                    tydesc: &tydesc_info,\n                    ptrs: &[ValueRef])\n                    -> ValueRef {"}, {"sha": "1b7f52619a59b71393fba96d0b20796d66b0e879", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -28,7 +28,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n \n-pub fn monomorphic_fn(ccx: @mut CrateContext,\n+pub fn monomorphic_fn(ccx: @CrateContext,\n                       fn_id: ast::DefId,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n@@ -307,7 +307,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     (lldecl, must_cast)\n }\n \n-pub fn make_mono_id(ccx: @mut CrateContext,\n+pub fn make_mono_id(ccx: @CrateContext,\n                     item: ast::DefId,\n                     substs: &param_substs) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get"}, {"sha": "fae677497b869d0634d94d6f09ea9aa9d1373592", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -187,7 +187,7 @@ impl Type {\n         Type::array(&Type::i8().ptr_to(), 1)\n     }\n \n-    pub fn generic_glue_fn(cx: &mut CrateContext) -> Type {\n+    pub fn generic_glue_fn(cx: &CrateContext) -> Type {\n         match cx.tn.find_type(\"glue_fn\") {\n             Some(ty) => return ty,\n             None => ()"}, {"sha": "c1e6e46676181d533eed05daa52dcf85ec407fda", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941677ea3175ea0bba14bb6ced050c8e8fca3cf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=b941677ea3175ea0bba14bb6ced050c8e8fca3cf", "patch": "@@ -21,15 +21,15 @@ use middle::trans::type_::Type;\n use syntax::ast;\n use syntax::opt_vec;\n \n-pub fn arg_is_indirect(ccx: &mut CrateContext, arg_ty: ty::t) -> bool {\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: ty::t) -> bool {\n     !type_is_immediate(ccx, arg_ty)\n }\n \n-pub fn return_uses_outptr(ccx: &mut CrateContext, ty: ty::t) -> bool {\n+pub fn return_uses_outptr(ccx: &CrateContext, ty: ty::t) -> bool {\n     !type_is_immediate(ccx, ty)\n }\n \n-pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n+pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n     let llty = type_of(ccx, arg_ty);\n     if arg_is_indirect(ccx, arg_ty) {\n         llty.ptr_to()\n@@ -38,12 +38,12 @@ pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: ty::t) -> Type {\n     }\n }\n \n-pub fn type_of_explicit_args(ccx: &mut CrateContext,\n+pub fn type_of_explicit_args(ccx: &CrateContext,\n                              inputs: &[ty::t]) -> ~[Type] {\n     inputs.map(|&arg_ty| type_of_explicit_arg(ccx, arg_ty))\n }\n \n-pub fn type_of_rust_fn(cx: &mut CrateContext,\n+pub fn type_of_rust_fn(cx: &CrateContext,\n                        inputs: &[ty::t],\n                        output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n@@ -71,7 +71,7 @@ pub fn type_of_rust_fn(cx: &mut CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n+pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n     return match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n@@ -100,7 +100,7 @@ pub fn type_of_fn_from_ty(cx: &mut CrateContext, fty: ty::t) -> Type {\n //     type behind pointers. This can help prevent infinite loops for\n //     recursive types. For example, enum types rely on this behavior.\n \n-pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n+pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n     {\n         let llsizingtypes = cx.llsizingtypes.borrow();\n         match llsizingtypes.get().find_copy(&t) {\n@@ -175,7 +175,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n }\n \n // NB: If you update this, be sure to update `sizing_type_of()` as well.\n-pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n+pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     // Check the cache.\n     {\n         let lltypes = cx.lltypes.borrow();\n@@ -359,7 +359,7 @@ pub fn llvm_type_name(cx: &CrateContext,\n     }\n }\n \n-pub fn type_of_dtor(ccx: &mut CrateContext, self_ty: ty::t) -> Type {\n+pub fn type_of_dtor(ccx: &CrateContext, self_ty: ty::t) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n     Type::func([self_ty], &Type::void())\n }"}]}