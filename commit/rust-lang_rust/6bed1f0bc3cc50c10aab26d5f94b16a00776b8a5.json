{"sha": "6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZWQxZjBiYzNjYzUwYzEwYWFiMjZkNWY5NGIxNmEwMDc3NmI4YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-12T10:33:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-12T10:33:14Z"}, "message": "Auto merge of #87666 - ivmarkov:master, r=Amanieu\n\nSTD support for the ESP-IDF framework\n\nDear all,\n\nThis PR is implementing libStd support for the [ESP-IDF](https://github.com/espressif/esp-idf) newlib-based framework, which is the open source SDK provided by Espressif for their MCU family (esp32, esp32s2, esp32c3 and all other forthcoming ones).\n\nNote that this PR has a [sibling PR](https://github.com/rust-lang/libc/pull/2310) against the libc crate, which implements proper declarations for all ESP-IDF APIs which are necessary for libStd support.\n\n# Implementation approach\n\nThe ESP-IDF framework - despite being bare metal - offers a relatively complete POSIX API based on newlib. `pthread`, BSD sockets, file descriptors, and even a small file-system VFS layer. Perhaps the only significant exception is the lack of support for processes, which is to be expected of course on bare metal.\n\nTherefore, the libStd support is implemented as a set of (hopefully small) changes to the `sys/unix` family of modules, in the form of conditional-compilation branches based either on `target_os = \"espidf\"` or in a couple of cases - based on `target_env = \"newlib\"` (the latter was already there actually and is not part of this patch).\n\nThe PR also contains two new targets:\n- `riscv32imc-esp-espidf`\n- `riscv32imac-esp-espidf`\n\n... which are essentially copies of `riscv32imc-unknown-none-elf` and `riscv32imac-unknown-none-elf`, but enriched with proper `linker`, `linker_flavor`, `families`, `os`, `env` etc. specifications so that (a) the proper conditional compilation branches in libStd are selected when compiling with these targets and (b) the correct linker is used.\n\nSince support for atomics is a precondition for libStd, the `riscv32imc-esp-espidf` target additionally is configured in such a way, so as to emit libcalls to the `__sync*` & `__atomic*` GCC functions, which are already implemented in the ESP-IDF framework. If this modification is not acceptable, we can also live with only the `riscv32imac-esp-espidf` target as well.  While the RiscV chips of Espressif lack native atomics support, the relevant instructions are transparently emulated in the ESP-IDF framework using invalid instruction trap. This modification was implemented specifically with Rust support in mind.\n\n# Target maintainers\n\nIn case this PR eventually gets merged, you can list myself as a Target Maintainer.\n\nMore importantly, Espressif (the chip vendor) is now actively involved and [embracing](https://github.com/espressif/rust-esp32-example/blob/main/docs/rust-on-xtensa.md) all [Rust-related efforts](https://github.com/esp-rs) which were originally a community effort. In light of that, I suppose `@MabezDev` - who initiated the Rust-on-Espressif efforts back in time and who now works for Espressif won't object to being listed as a maintainer as well.\n\n**EDIT:** I was hinted (thanks, `@Urgau)` that answering the Tier 3 policy explicitly might be helpful. Answers below.\n\n# Tier 3 Target Policy - answers\n\n> A proposed target or target-specific patch that substantially changes code shared with other targets (not just target-specific code) must be reviewed and approved by the appropriate team for that shared code before acceptance.\n\nHopefully, the changes introduced by the ESP-IDF libStd support are rather on the small side. They are completely contained within the `sys/unix` set of modules (that is, aside from the obviously necessary one-liners in the `unwind` crate and in `build.rs`).\n\n> A tier 3 target must have a designated developer or developers (the \"target maintainers\") on record to be CCed when issues arise regarding the target. (The mechanism to track and CC such developers may evolve over time.)\n\n`@ivmarkov`\n`@MabezDev`\n\n> Targets must use naming consistent with any existing targets; for instance, a target for the same CPU or OS as an existing Rust target should use the same name for that CPU or OS. Targets should normally use the same names and naming conventions as used elsewhere in the broader ecosystem beyond Rust (such as in other toolchains), unless they have a very good reason to diverge. Changing the name of a target can be highly disruptive, especially once the target reaches a higher tier, so getting the name right is important even for a tier 3 target.\n\nThe two introduced targets follow as much as possible the naming conventions of the other targets. I.e. taking the bare-metal `riscv32imac_unknown_none_elf` as a base:\n* The name of the new target was derived by replacing `none` with `espidf` to designate the `target_os`.\n* `_elf` was removed, as the non-bare metal targets seem not to have it\n* `-newlib` was deliberately NOT added at the end, as I believe the chance of having two simultaneously active separate targets for the ESP-IDF framework with different C libraries (say, newlib vs musl) is way too small\n* Finally, we replaced the middle `unknown` with `esp` which is kind of the name of the whole chipset MCU family (and abbreviation from Espressif which is too long). It will stay `esp` for all RiscV32-based MCUs of the company, as they all use the riscv32imc instruction set. By necessity however (disambiguation), it will be `esp32` or `esp32s2` or `esp32s3` for the Xtensa-based MCUs as all of these have their own variation of the Xtensa architecture. (The Xtensa targets are not part of this PR, even though they would use 1:1 the same LibStd implementation provided here, as they depend on the upstreaming of the Xtensa architecture support in LLVM; this upstreaming this is currently in progress.)\n\nThere was also a preceding discussion on the topic [here](https://github.com/espressif/rust-esp32-example/issues/14).\n\n> Target names should not introduce undue confusion or ambiguity unless absolutely necessary to maintain ecosystem compatibility. For example, if the name of the target makes people extremely likely to form incorrect beliefs about what it targets, the name should be changed or augmented to disambiguate it.\n\nWe are explicitly putting an `-espidf` suffix to designate that the target is *specifically* for Rust + ESP-IDF\n\n> Tier 3 targets may have unusual requirements to build or use, but must not create legal issues or impose onerous legal terms for the Rust project or for Rust developers or users.\n\nAgreed.\n\n> The target must not introduce license incompatibilities.\n\nTo the best of our knowledge, it doesn't.\n\n> Anything added to the Rust repository must be under the standard Rust license (MIT OR Apache-2.0).\n\nMIT + Apache 2.0\n\n> The target must not cause the Rust tools or libraries built for any other host (even when supporting cross-compilation to the target) to depend on any new dependency less permissive than the Rust licensing policy. This applies whether the dependency is a Rust crate that would require adding new license exceptions (as specified by the tidy tool in the rust-lang/rust repository), or whether the dependency is a native library or binary. In other words, the introduction of the target must not cause a user installing or running a version of Rust or the Rust tools to be subject to any new license requirements.\n\nRequirements are not changed for any other target.\n\n> If the target supports building host tools (such as rustc or cargo), those host tools must not depend on proprietary (non-FOSS) libraries, other than ordinary runtime libraries supplied by the platform and commonly used by other binaries built for the target. For instance, rustc built for the target may depend on a common proprietary C runtime library or console output library, but must not depend on a proprietary code generation library or code optimization library. Rust's license permits such combinations, but the Rust project has no interest in maintaining such combinations within the scope of Rust itself, even at tier 3.\n\nThe targets are for bare-metal environment which is not hosting build tools or a compiler.\n\n> Targets should not require proprietary (non-FOSS) components to link a functional binary or library.\n\nThe linker used by the targets is the GCC linker from the GCC toolchain cross-compiled for riscv. GNU GPL.\n\n> \"onerous\" here is an intentionally subjective term. At a minimum, \"onerous\" legal/licensing terms include but are not limited to: non-disclosure requirements, non-compete requirements, contributor license agreements (CLAs) or equivalent, \"non-commercial\"/\"research-only\"/etc terms, requirements conditional on the employer or employment of any particular Rust developers, revocable terms, any requirements that create liability for the Rust project or its developers or users, or any requirements that adversely affect the livelihood or prospects of the Rust project or its developers or users.\n> Neither this policy nor any decisions made regarding targets shall create any binding agreement or estoppel by any party. If any member of an approving Rust team serves as one of the maintainers of a target, or has any legal or employment requirement (explicit or implicit) that might affect their decisions regarding a target, they must recuse themselves from any approval decisions regarding the target's tier status, though they may otherwise participate in discussions.\n> This requirement does not prevent part or all of this policy from being cited in an explicit contract or work agreement (e.g. to implement or maintain support for a target). This requirement exists to ensure that a developer or team responsible for reviewing and approving a target does not face any legal threats or obligations that would prevent them from freely exercising their judgment in such approval, even if such judgment involves subjective matters or goes beyond the letter of these requirements.\n\nAgreed.\n\n> Tier 3 targets should attempt to implement as much of the standard libraries as possible and appropriate (core for most targets, alloc for targets that can support dynamic memory allocation, std for targets with an operating system or equivalent layer of system-provided functionality), but may leave some code unimplemented (either unavailable or stubbed out as appropriate), whether because the target makes it impossible to implement or challenging to implement. The authors of pull requests are not obligated to avoid calling any portions of the standard library on the basis of a tier 3 target not implementing those portions.\n\nThe targets implement libStd almost in its entirety, except for the missing support for process, as this is a bare metal platform. The process `sys\\unix` module is currently stubbed to return \"not implemented\" errors.\n\n> The target must provide documentation for the Rust community explaining how to build for the target, using cross-compilation if possible. If the target supports running tests (even if they do not pass), the documentation must explain how to run tests for the target, using emulation if possible or dedicated hardware if necessary.\n\nTarget does not (yet) support running tests. We would gladly provide all documentation how to build for the target (where?). It is currently hosted in this [README.md](https://github.com/ivmarkov/rust-esp32-std-hello) file, but will likely be moved to the [esp-rs](https://github.com/esp-rs) organization. Since the build for the target is driven by cargo and [all other tooling is downloaded automatically during the build](https://github.com/esp-rs/esp-idf-sys/blob/master/build.rs), there is no need for extensive documentation.\n\n> Tier 3 targets must not impose burden on the authors of pull requests, or other developers in the community, to maintain the target. In particular, do not post comments (automated or manual) on a PR that derail or suggest a block on the PR based on a tier 3 target. Do not send automated messages or notifications (via any medium, including via `@)` to a PR author or others involved with a PR regarding a tier 3 target, unless they have opted into such messages.\n\nAgreed.\n\n> Backlinks such as those generated by the issue/PR tracker when linking to an issue or PR are not considered a violation of this policy, within reason. However, such messages (even on a separate repository) must not generate notifications to anyone involved with a PR who has not requested such notifications.\n\nAgreed.\n\n> Patches adding or updating tier 3 targets must not break any existing tier 2 or tier 1 target, and must not knowingly break another tier 3 target without approval of either the compiler team or the maintainers of the other tier 3 target.\n\nTo the best of our knowledge, we believe we are not breaking any other target (be it tier 1, 2 or 3).\n\n> In particular, this may come up when working on closely related targets, such as variations of the same architecture with different features. Avoid introducing unconditional uses of features that another variation of the target may not have; use conditional compilation or runtime detection, as appropriate, to let each target run code supported by that target.\n\nTo the best of our knowledge, we have not introduced any unconditional use of a feature that affects any other target.\n\n> If a tier 3 target stops meeting these requirements, or the target maintainers no longer have interest or time, or the target shows no signs of activity and has not built for some time, or removing the target would improve the quality of the Rust codebase, we may post a PR to remove it; any such PR will be CCed to the target maintainers (and potentially other people who have previously worked on the target), to check potential interest in improving the situation.\n\nAgreed.", "tree": {"sha": "4f5193aa664b2e165f3f3b942af1d217c49223b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f5193aa664b2e165f3f3b942af1d217c49223b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "html_url": "https://github.com/rust-lang/rust/commit/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e900176b6c402035a6e52da03d453c848f0b336", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e900176b6c402035a6e52da03d453c848f0b336", "html_url": "https://github.com/rust-lang/rust/commit/4e900176b6c402035a6e52da03d453c848f0b336"}, {"sha": "459eaa6baea4127b37769d0b7944fa00c175e770", "url": "https://api.github.com/repos/rust-lang/rust/commits/459eaa6baea4127b37769d0b7944fa00c175e770", "html_url": "https://github.com/rust-lang/rust/commit/459eaa6baea4127b37769d0b7944fa00c175e770"}], "stats": {"total": 628, "additions": 581, "deletions": 47}, "files": [{"sha": "940608975c5ecd3d4a15412339a85a3869e75bcf", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -1880,9 +1880,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.98\"\n+version = \"0.2.99\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n+checksum = \"a7f823d141fe0a24df1e23b4af4e3c7ba9e5966ec514ea068c93024aa7deb765\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "218fa0344b6a7bb7e4fb40aa59e4cf7b79791798", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -903,6 +903,7 @@ supported_targets! {\n \n     (\"riscv32i-unknown-none-elf\", riscv32i_unknown_none_elf),\n     (\"riscv32imc-unknown-none-elf\", riscv32imc_unknown_none_elf),\n+    (\"riscv32imc-esp-espidf\", riscv32imc_esp_espidf),\n     (\"riscv32imac-unknown-none-elf\", riscv32imac_unknown_none_elf),\n     (\"riscv32gc-unknown-linux-gnu\", riscv32gc_unknown_linux_gnu),\n     (\"riscv32gc-unknown-linux-musl\", riscv32gc_unknown_linux_musl),"}, {"sha": "fb084afe960de8d478130f801a6dfea4e50049de", "filename": "compiler/rustc_target/src/spec/riscv32imc_esp_espidf.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32imc_esp_espidf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32imc_esp_espidf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv32imc_esp_espidf.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -0,0 +1,37 @@\n+use crate::spec::{LinkerFlavor, PanicStrategy, RelocModel};\n+use crate::spec::{Target, TargetOptions};\n+\n+pub fn target() -> Target {\n+    Target {\n+        data_layout: \"e-m:e-p:32:32-i64:64-n32-S128\".to_string(),\n+        llvm_target: \"riscv32\".to_string(),\n+        pointer_width: 32,\n+        arch: \"riscv32\".to_string(),\n+\n+        options: TargetOptions {\n+            families: vec![\"unix\".to_string()],\n+            os: \"espidf\".to_string(),\n+            env: \"newlib\".to_string(),\n+            vendor: \"espressif\".to_string(),\n+            linker_flavor: LinkerFlavor::Gcc,\n+            linker: Some(\"riscv32-esp-elf-gcc\".to_string()),\n+            cpu: \"generic-rv32\".to_string(),\n+\n+            // While the RiscV32IMC architecture does not natively support atomics, ESP-IDF does support\n+            // the __atomic* and __sync* GCC builtins, so setting `max_atomic_width` to `Some(32)`\n+            // and `atomic_cas` to `true` will cause the compiler to emit libcalls to these builtins.\n+            //\n+            // Support for atomics is necessary for the Rust STD library, which is supported by the ESP-IDF framework.\n+            max_atomic_width: Some(32),\n+            atomic_cas: true,\n+\n+            features: \"+m,+c\".to_string(),\n+            executables: true,\n+            panic_strategy: PanicStrategy::Abort,\n+            relocation_model: RelocModel::Static,\n+            emit_debug_gdb_scripts: false,\n+            eh_frame_header: false,\n+            ..Default::default()\n+        },\n+    }\n+}"}, {"sha": "ac7d8c18e3e029282473c1f695ea1ef1d993eb2c", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -45,7 +45,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         all(target_family = \"windows\", target_env = \"gnu\"),\n         target_os = \"psp\",\n-        target_family = \"unix\",\n+        all(target_family = \"unix\", not(target_os = \"espidf\")),\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {\n         // Rust runtime's startup objects depend on these symbols, so make them public.\n@@ -58,6 +58,7 @@ cfg_if::cfg_if! {\n         // - arch=wasm32\n         // - os=none (\"bare metal\" targets)\n         // - os=uefi\n+        // - os=espidf\n         // - nvptx64-nvidia-cuda\n         // - arch=avr\n         #[path = \"dummy.rs\"]"}, {"sha": "64f413acd9709383b9850eedc7cea835272502d0", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -15,7 +15,7 @@ cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.98\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.99\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.44\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "726157c1f1a41a9e1dd301264f825dfaeadba2c4", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -26,6 +26,7 @@ fn main() {\n         || target.contains(\"vxworks\")\n         || target.contains(\"wasm32\")\n         || target.contains(\"asmjs\")\n+        || target.contains(\"espidf\")\n     {\n         // These platforms don't have any special requirements.\n     } else {"}, {"sha": "93dc2c0cab7eee510e3f821eb0b27dd08923e484", "filename": "library/std/src/os/espidf/fs.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Ffs.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -0,0 +1,117 @@\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use crate::fs::Metadata;\n+use crate::sys_common::AsInner;\n+\n+#[allow(deprecated)]\n+use crate::os::espidf::raw;\n+\n+/// OS-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: crate::fs::Metadata\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.8.0\",\n+        reason = \"deprecated in favor of the accessor \\\n+                  methods of this trait\"\n+    )]\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat;\n+\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_spare4(&self) -> [u32; 2];\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat {\n+        unsafe { &*(self.as_inner().as_inner() as *const libc::stat as *const raw::stat) }\n+    }\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        0\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+    fn st_spare4(&self) -> [u32; 2] {\n+        let spare4 = self.as_inner().as_inner().st_spare4;\n+        [spare4[0] as u32, spare4[1] as u32]\n+    }\n+}"}, {"sha": "a9cef970930823f4a588820d352a3962495961be", "filename": "library/std/src/os/espidf/mod.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fmod.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -0,0 +1,6 @@\n+//! Definitions for the ESP-IDF framework.\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod fs;\n+pub mod raw;"}, {"sha": "fb18ec6f6f82abf2bdb72c4391a9c40a6b809140", "filename": "library/std/src/os/espidf/raw.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fespidf%2Fraw.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -0,0 +1,69 @@\n+//! Raw type definitions for the ESP-IDF framework.\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![rustc_deprecated(\n+    since = \"1.8.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n+\n+use crate::os::raw::c_long;\n+use crate::os::unix::raw::{gid_t, uid_t};\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub type pthread_t = libc::pthread_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blkcnt_t = libc::blkcnt_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type blksize_t = libc::blksize_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type dev_t = libc::dev_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type ino_t = libc::ino_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type mode_t = libc::mode_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type nlink_t = libc::nlink_t;\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type off_t = libc::off_t;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub type time_t = libc::time_t;\n+\n+#[repr(C)]\n+#[derive(Clone)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub struct stat {\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_dev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ino: ino_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mode: mode_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_nlink: nlink_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_uid: uid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_gid: gid_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_rdev: dev_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_size: off_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_atime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_mtime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_ctime: time_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blksize: blksize_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_blocks: blkcnt_t,\n+    #[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+    pub st_spare4: [c_long; 2usize],\n+}"}, {"sha": "4c9814919cdfa5e2aee68672909ff60b4c054c22", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -80,6 +80,8 @@ mod imp {\n     pub mod dragonfly;\n     #[cfg(target_os = \"emscripten\")]\n     pub mod emscripten;\n+    #[cfg(target_os = \"espidf\")]\n+    pub mod espidf;\n     #[cfg(target_os = \"freebsd\")]\n     pub mod freebsd;\n     #[cfg(target_os = \"fuchsia\")]"}, {"sha": "6c73d4b21dd3dbc71f51e289316825df9409031c", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -40,6 +40,8 @@ mod platform {\n     pub use crate::os::dragonfly::*;\n     #[cfg(target_os = \"emscripten\")]\n     pub use crate::os::emscripten::*;\n+    #[cfg(target_os = \"espidf\")]\n+    pub use crate::os::espidf::*;\n     #[cfg(target_os = \"freebsd\")]\n     pub use crate::os::freebsd::*;\n     #[cfg(target_os = \"fuchsia\")]"}, {"sha": "576667c017392054ff825cfdde82b1dc7be202ba", "filename": "library/std/src/sys/common/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Falloc.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -14,7 +14,8 @@ use crate::ptr;\n     target_arch = \"asmjs\",\n     target_arch = \"wasm32\",\n     target_arch = \"hexagon\",\n-    target_arch = \"riscv32\"\n+    target_arch = \"riscv32\",\n+    target_arch = \"xtensa\"\n )))]\n pub const MIN_ALIGN: usize = 8;\n #[cfg(all(any("}, {"sha": "7c3d9573940ae500d53b3638ffc0fe9257689221", "filename": "library/std/src/sys/unix/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Falloc.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -57,7 +57,8 @@ cfg_if::cfg_if! {\n         target_os = \"android\",\n         target_os = \"illumos\",\n         target_os = \"redox\",\n-        target_os = \"solaris\"\n+        target_os = \"solaris\",\n+        target_os = \"espidf\"\n     ))] {\n         #[inline]\n         unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {"}, {"sha": "ee5e3983ac26ae4bc53377aa071cbc9cd70d30de", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -246,3 +246,15 @@ mod imp {\n         Args { iter: res.into_iter() }\n     }\n }\n+\n+#[cfg(target_os = \"espidf\")]\n+mod imp {\n+    use super::Args;\n+\n+    #[inline(always)]\n+    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n+\n+    pub fn args() -> Args {\n+        Args { iter: Vec::new().into_iter() }\n+    }\n+}"}, {"sha": "61261c0aa84e3e084aca6bc5a7f46698b8f91b3e", "filename": "library/std/src/sys/unix/condvar.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -34,12 +34,23 @@ impl Condvar {\n     ))]\n     pub unsafe fn init(&mut self) {}\n \n+    // NOTE: ESP-IDF's PTHREAD_COND_INITIALIZER support is not released yet\n+    // So on that platform, init() should always be called\n+    // Moreover, that platform does not have pthread_condattr_setclock support,\n+    // hence that initialization should be skipped as well\n+    #[cfg(target_os = \"espidf\")]\n+    pub unsafe fn init(&mut self) {\n+        let r = libc::pthread_cond_init(self.inner.get(), crate::ptr::null());\n+        assert_eq!(r, 0);\n+    }\n+\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n         target_os = \"l4re\",\n         target_os = \"android\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"espidf\"\n     )))]\n     pub unsafe fn init(&mut self) {\n         use crate::mem::MaybeUninit;\n@@ -76,7 +87,12 @@ impl Condvar {\n     // where we configure condition variable to use monotonic clock (instead of\n     // default system clock). This approach avoids all problems that result\n     // from changes made to the system time.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n+    #[cfg(not(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"android\",\n+        target_os = \"espidf\"\n+    )))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use crate::mem;\n \n@@ -103,7 +119,12 @@ impl Condvar {\n     // This implementation is modeled after libcxx's condition_variable\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n+    #[cfg(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"android\",\n+        target_os = \"espidf\"\n+    ))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n         use crate::ptr;\n         use crate::time::Instant;"}, {"sha": "60551aeb3e73e5f1c0ee92452c48cd146908dbef", "filename": "library/std/src/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -184,3 +184,14 @@ pub mod os {\n     pub const EXE_SUFFIX: &str = \"\";\n     pub const EXE_EXTENSION: &str = \"\";\n }\n+\n+#[cfg(target_os = \"espidf\")]\n+pub mod os {\n+    pub const FAMILY: &str = \"unix\";\n+    pub const OS: &str = \"espidf\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".so\";\n+    pub const DLL_EXTENSION: &str = \"so\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}"}, {"sha": "28e32681e15b3d3624d1ba3c7ab935600e7ccad0", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -91,6 +91,7 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::readv(\n@@ -102,9 +103,14 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(target_os = \"espidf\")]\n+    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        return crate::io::default_read_vectored(|b| self.read(b), bufs);\n+    }\n+\n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        true\n+        cfg!(not(target_os = \"espidf\"))\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -148,6 +154,7 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n         let ret = cvt(unsafe {\n             libc::writev(\n@@ -159,9 +166,14 @@ impl FileDesc {\n         Ok(ret as usize)\n     }\n \n+    #[cfg(target_os = \"espidf\")]\n+    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        return crate::io::default_write_vectored(|b| self.write(b), bufs);\n+    }\n+\n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        true\n+        cfg!(not(target_os = \"espidf\"))\n     }\n \n     pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n@@ -217,7 +229,7 @@ impl FileDesc {\n         }\n     }\n     #[cfg(any(\n-        target_env = \"newlib\",\n+        all(target_env = \"newlib\", not(target_os = \"espidf\")),\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"emscripten\",\n@@ -238,6 +250,12 @@ impl FileDesc {\n             Ok(())\n         }\n     }\n+    #[cfg(target_os = \"espidf\")]\n+    pub fn set_cloexec(&self) -> io::Result<()> {\n+        // FD_CLOEXEC is not supported in ESP-IDF but there's no need to,\n+        // because ESP-IDF does not support spawning processes either.\n+        Ok(())\n+    }\n \n     #[cfg(target_os = \"linux\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n@@ -268,7 +286,17 @@ impl FileDesc {\n         // We want to atomically duplicate this file descriptor and set the\n         // CLOEXEC flag, and currently that's done via F_DUPFD_CLOEXEC. This\n         // is a POSIX flag that was added to Linux in 2.6.24.\n-        let fd = cvt(unsafe { libc::fcntl(self.raw(), libc::F_DUPFD_CLOEXEC, 0) })?;\n+        #[cfg(not(target_os = \"espidf\"))]\n+        let cmd = libc::F_DUPFD_CLOEXEC;\n+\n+        // For ESP-IDF, F_DUPFD is used instead, because the CLOEXEC semantics\n+        // will never be supported, as this is a bare metal framework with\n+        // no capabilities for multi-process execution.  While F_DUPFD is also\n+        // not supported yet, it might be (currently it returns ENOSYS).\n+        #[cfg(target_os = \"espidf\")]\n+        let cmd = libc::F_DUPFD;\n+\n+        let fd = cvt(unsafe { libc::fcntl(self.raw(), cmd, 0) })?;\n         Ok(FileDesc::new(fd))\n     }\n }"}, {"sha": "fd4defd72eb4736b5f6389265820a78e5848be89", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -312,31 +312,31 @@ impl FileAttr {\n \n #[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n-    #[cfg(not(target_os = \"vxworks\"))]\n+    #[cfg(all(not(target_os = \"vxworks\"), not(target_os = \"espidf\")))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: self.stat.st_mtime_nsec as _,\n         }))\n     }\n \n-    #[cfg(target_os = \"vxworks\")]\n+    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: 0,\n         }))\n     }\n \n-    #[cfg(not(target_os = \"vxworks\"))]\n+    #[cfg(all(not(target_os = \"vxworks\"), not(target_os = \"espidf\")))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n             tv_nsec: self.stat.st_atime_nsec as _,\n         }))\n     }\n \n-    #[cfg(target_os = \"vxworks\")]\n+    #[cfg(any(target_os = \"vxworks\", target_os = \"espidf\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n@@ -609,7 +609,8 @@ impl DirEntry {\n         target_os = \"l4re\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     ))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -648,7 +649,8 @@ impl DirEntry {\n         target_os = \"emscripten\",\n         target_os = \"l4re\",\n         target_os = \"haiku\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n@@ -1106,8 +1108,8 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n     let original = cstr(original)?;\n     let link = cstr(link)?;\n     cfg_if::cfg_if! {\n-        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n-            // VxWorks and Redox lack `linkat`, so use `link` instead. POSIX leaves\n+        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\", target_os = \"espidf\"))] {\n+            // VxWorks, Redox and ESP-IDF lack `linkat`, so use `link` instead. POSIX leaves\n             // it implementation-defined whether `link` follows symlinks, so rely on the\n             // `symlink_hard_link` test in library/std/src/fs/tests.rs to check the behavior.\n             // Android has `linkat` on newer versions, but we happen to know `link`\n@@ -1199,6 +1201,18 @@ fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)>\n     Ok((reader, metadata))\n }\n \n+#[cfg(target_os = \"espidf\")]\n+fn open_to_and_set_permissions(\n+    to: &Path,\n+    reader_metadata: crate::fs::Metadata,\n+) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n+    use crate::fs::OpenOptions;\n+    let writer = OpenOptions::new().open(to)?;\n+    let writer_metadata = writer.metadata()?;\n+    Ok((writer, writer_metadata))\n+}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n fn open_to_and_set_permissions(\n     to: &Path,\n     reader_metadata: crate::fs::Metadata,"}, {"sha": "f5424e3d282140abebd04d371147d56e9f4a715f", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -5,6 +5,7 @@ use crate::io::ErrorKind;\n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;\n \n+#[cfg(not(target_os = \"espidf\"))]\n #[macro_use]\n pub mod weak;\n \n@@ -43,6 +44,10 @@ pub mod thread_local_dtor;\n pub mod thread_local_key;\n pub mod time;\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn init(argc: isize, argv: *const *const u8) {}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n // SAFETY: must be called only once during runtime initialization.\n // NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n pub unsafe fn init(argc: isize, argv: *const *const u8) {\n@@ -304,3 +309,19 @@ cfg_if::cfg_if! {\n         extern \"C\" {}\n     }\n }\n+\n+#[cfg(target_os = \"espidf\")]\n+mod unsupported {\n+    use crate::io;\n+\n+    pub fn unsupported<T>() -> io::Result<T> {\n+        Err(unsupported_err())\n+    }\n+\n+    pub fn unsupported_err() -> io::Error {\n+        io::Error::new_const(\n+            io::ErrorKind::Unsupported,\n+            &\"operation not supported on this platform\",\n+        )\n+    }\n+}"}, {"sha": "3f614fde08aca6482e0b8b1988266083f575aeb9", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -9,7 +9,7 @@ use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::{Duration, Instant};\n \n-use libc::{c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n+use libc::{c_int, c_void, size_t, sockaddr, socklen_t, MSG_PEEK};\n \n pub use crate::sys::{cvt, cvt_r};\n \n@@ -30,13 +30,19 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n     on_resolver_failure();\n \n-    if err == EAI_SYSTEM {\n+    #[cfg(not(target_os = \"espidf\"))]\n+    if err == libc::EAI_SYSTEM {\n         return Err(io::Error::last_os_error());\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     let detail = unsafe {\n         str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n     };\n+\n+    #[cfg(target_os = \"espidf\")]\n+    let detail = \"\";\n+\n     Err(io::Error::new(\n         io::ErrorKind::Uncategorized,\n         &format!(\"failed to lookup address information: {}\", detail)[..],"}, {"sha": "1d5ffb073211bcde9f40a679e2d296422bc45053", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -128,6 +128,12 @@ pub fn error_string(errno: i32) -> String {\n     }\n }\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    Ok(PathBuf::from(\"/\"))\n+}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n pub fn getcwd() -> io::Result<PathBuf> {\n     let mut buf = Vec::with_capacity(512);\n     loop {\n@@ -154,6 +160,12 @@ pub fn getcwd() -> io::Result<PathBuf> {\n     }\n }\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    super::unsupported::unsupported()\n+}\n+\n+#[cfg(not(target_os = \"espidf\"))]\n pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let p: &OsStr = p.as_ref();\n     let p = CString::new(p.as_bytes())?;\n@@ -432,6 +444,11 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     path.canonicalize()\n }\n \n+#[cfg(target_os = \"espidf\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    super::unsupported::unsupported()\n+}\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n }\n@@ -541,6 +558,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     }\n }\n \n+#[cfg(not(target_os = \"espidf\"))]\n pub fn page_size() -> usize {\n     unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }\n }\n@@ -563,7 +581,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     ))]\n     unsafe fn fallback() -> Option<OsString> {\n         None\n@@ -573,7 +592,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n         target_os = \"redox\",\n-        target_os = \"vxworks\"\n+        target_os = \"vxworks\",\n+        target_os = \"espidf\"\n     )))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {"}, {"sha": "0165ece849ee5034aba41becf2552fe03b61c139", "filename": "library/std/src/sys/unix/process/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -13,6 +13,9 @@ cfg_if::cfg_if! {\n     } else if #[cfg(target_os = \"vxworks\")] {\n         #[path = \"process_vxworks.rs\"]\n         mod process_inner;\n+    } else if #[cfg(target_os = \"espidf\")] {\n+        #[path = \"process_unsupported.rs\"]\n+        mod process_inner;\n     } else {\n         #[path = \"process_unix.rs\"]\n         mod process_inner;"}, {"sha": "7d549d060fd88cfafbf877b4ad28394509c9deee", "filename": "library/std/src/sys/unix/process/process_unsupported.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unsupported.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -0,0 +1,122 @@\n+use crate::convert::{TryFrom, TryInto};\n+use crate::fmt;\n+use crate::io;\n+use crate::io::ErrorKind;\n+use crate::num::NonZeroI32;\n+use crate::os::raw::NonZero_c_int;\n+use crate::sys;\n+use crate::sys::cvt;\n+use crate::sys::pipe::AnonPipe;\n+use crate::sys::process::process_common::*;\n+use crate::sys::unix::unsupported::*;\n+\n+use libc::{c_int, pid_t};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(\n+        &mut self,\n+        default: Stdio,\n+        needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        unsupported_err()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Process {\n+    handle: pid_t,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        0\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        unsupported()\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        unsupported()\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        unsupported()\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn exit_ok(&self) -> Result<(), ExitStatusError> {\n+        Err(ExitStatusError(1.try_into().unwrap()))\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        None\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        None\n+    }\n+\n+    pub fn core_dumped(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn stopped_signal(&self) -> Option<i32> {\n+        None\n+    }\n+\n+    pub fn continued(&self) -> bool {\n+        false\n+    }\n+\n+    pub fn into_raw(&self) -> c_int {\n+        0\n+    }\n+}\n+\n+/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a as i32)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"exit code: {}\", self.0)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatusError(NonZero_c_int);\n+\n+impl Into<ExitStatus> for ExitStatusError {\n+    fn into(self) -> ExitStatus {\n+        ExitStatus(self.0.into())\n+    }\n+}\n+\n+impl ExitStatusError {\n+    pub fn code(self) -> Option<NonZeroI32> {\n+        ExitStatus(self.0.into()).code().map(|st| st.try_into().unwrap())\n+    }\n+}"}, {"sha": "7a3f6b0d95a09aace1cdba7529287315eeb6655a", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -44,12 +44,17 @@ mod imp {\n         unsafe { getrandom(buf.as_mut_ptr().cast(), buf.len(), libc::GRND_NONBLOCK) }\n     }\n \n-    #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+    #[cfg(target_os = \"espidf\")]\n+    fn getrandom(buf: &mut [u8]) -> libc::ssize_t {\n+        unsafe { libc::getrandom(buf.as_mut_ptr().cast(), buf.len(), 0) }\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"android\", target_os = \"espidf\")))]\n     fn getrandom_fill_bytes(_buf: &mut [u8]) -> bool {\n         false\n     }\n \n-    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"espidf\"))]\n     fn getrandom_fill_bytes(v: &mut [u8]) -> bool {\n         use crate::sync::atomic::{AtomicBool, Ordering};\n         use crate::sys::os::errno;"}, {"sha": "133ad3ea420b83b6bceb81d63020619154eb42d5", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 46, "deletions": 17, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -9,12 +9,14 @@ use crate::time::Duration;\n \n #[cfg(any(target_os = \"linux\", target_os = \"solaris\", target_os = \"illumos\"))]\n use crate::sys::weak::weak;\n-#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\n+#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\", target_os = \"espidf\")))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n #[cfg(target_os = \"vxworks\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n+#[cfg(target_os = \"espidf\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 0; // 0 indicates that the stack size configured in the ESP-IDF menuconfig system should be used\n \n #[cfg(target_os = \"fuchsia\")]\n mod zircon {\n@@ -50,22 +52,35 @@ impl Thread {\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n-        let stack_size = cmp::max(stack, min_stack_size(&attr));\n-\n-        match libc::pthread_attr_setstacksize(&mut attr, stack_size) {\n-            0 => {}\n-            n => {\n-                assert_eq!(n, libc::EINVAL);\n-                // EINVAL means |stack_size| is either too small or not a\n-                // multiple of the system page size.  Because it's definitely\n-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = os::page_size();\n-                let stack_size =\n-                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n-            }\n-        };\n+        #[cfg(target_os = \"espidf\")]\n+        if stack > 0 {\n+            // Only set the stack if a non-zero value is passed\n+            // 0 is used as an indication that the default stack size configured in the ESP-IDF menuconfig system should be used\n+            assert_eq!(\n+                libc::pthread_attr_setstacksize(&mut attr, cmp::max(stack, min_stack_size(&attr))),\n+                0\n+            );\n+        }\n+\n+        #[cfg(not(target_os = \"espidf\"))]\n+        {\n+            let stack_size = cmp::max(stack, min_stack_size(&attr));\n+\n+            match libc::pthread_attr_setstacksize(&mut attr, stack_size) {\n+                0 => {}\n+                n => {\n+                    assert_eq!(n, libc::EINVAL);\n+                    // EINVAL means |stack_size| is either too small or not a\n+                    // multiple of the system page size.  Because it's definitely\n+                    // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n+                    // Round up to the nearest page and try again.\n+                    let page_size = os::page_size();\n+                    let stack_size =\n+                        (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n+                    assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n+                }\n+            };\n+        }\n \n         let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n         // Note: if the thread creation fails and this assert fails, then p will\n@@ -183,6 +198,7 @@ impl Thread {\n         // Newlib, Emscripten, and VxWorks have no way to set a thread name.\n     }\n \n+    #[cfg(not(target_os = \"espidf\"))]\n     pub fn sleep(dur: Duration) {\n         let mut secs = dur.as_secs();\n         let mut nsecs = dur.subsec_nanos() as _;\n@@ -208,6 +224,19 @@ impl Thread {\n         }\n     }\n \n+    #[cfg(target_os = \"espidf\")]\n+    pub fn sleep(dur: Duration) {\n+        let mut micros = dur.as_micros();\n+        unsafe {\n+            while micros > 0 {\n+                let st = if micros > u32::MAX as u128 { u32::MAX } else { micros as u32 };\n+                libc::usleep(st);\n+\n+                micros -= st as u128;\n+            }\n+        }\n+    }\n+\n     pub fn join(self) {\n         unsafe {\n             let ret = libc::pthread_join(self.id, ptr::null_mut());"}, {"sha": "7dc09add27fd717c7487bd2af781a4c9dc1f7131", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -361,9 +361,9 @@ mod inner {\n         }\n     }\n \n-    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"espidf\")))]\n     pub type clock_t = libc::c_int;\n-    #[cfg(target_os = \"dragonfly\")]\n+    #[cfg(any(target_os = \"dragonfly\", target_os = \"espidf\"))]\n     pub type clock_t = libc::c_ulong;\n \n     fn now(clock: clock_t) -> Timespec {"}, {"sha": "ea9108f17133af8491544944727c7fc2a4f46a72", "filename": "library/std/src/sys_common/io.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fio.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -1,4 +1,6 @@\n-pub const DEFAULT_BUF_SIZE: usize = 8 * 1024;\n+// Bare metal platforms usually have very small amounts of RAM\n+// (in the order of hundreds of KB)\n+pub const DEFAULT_BUF_SIZE: usize = if cfg!(target_os = \"espidf\") { 512 } else { 8 * 1024 };\n \n #[cfg(test)]\n #[allow(dead_code)] // not used on emscripten"}, {"sha": "53b13b9043b3a2e9fef7fe26e318e2f8a83303e4", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -13,6 +13,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         target_os = \"l4re\",\n         target_os = \"none\",\n+        target_os = \"espidf\",\n     ))] {\n         // These \"unix\" family members do not have unwinder.\n         // Note this also matches x86_64-unknown-none-linuxkernel."}, {"sha": "0bfe35ea861899ae80009c4250775f30a05c46ca", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=6bed1f0bc3cc50c10aab26d5f94b16a00776b8a5", "patch": "@@ -256,6 +256,7 @@ target | std | host | notes\n `powerpc64le-unknown-linux-musl` | ? |  |\n `riscv32gc-unknown-linux-gnu` |   |   | RISC-V Linux (kernel 5.4, glibc 2.33)\n `riscv32gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)\n+`riscv32imc-esp-espidf` | \u2713 |  | RISC-V ESP-IDF\n `riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)\n `s390x-unknown-linux-musl` |  |  | S390x Linux (kernel 2.6.32, MUSL)\n `sparc-unknown-linux-gnu` | \u2713 |  | 32-bit SPARC Linux"}]}