{"sha": "6ae617b31348e6397b581a7b5f1c66d30d335024", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZTYxN2IzMTM0OGU2Mzk3YjU4MWE3YjVmMWM2NmQzMGQzMzUwMjQ=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-04-12T06:21:03Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-04-12T06:21:03Z"}, "message": "Fix useless_format false negative\n\nCloses #2546", "tree": {"sha": "a3caa518884f7e3c8730d0c995f8d6c75382952d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3caa518884f7e3c8730d0c995f8d6c75382952d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ae617b31348e6397b581a7b5f1c66d30d335024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae617b31348e6397b581a7b5f1c66d30d335024", "html_url": "https://github.com/rust-lang/rust/commit/6ae617b31348e6397b581a7b5f1c66d30d335024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ae617b31348e6397b581a7b5f1c66d30d335024/comments", "author": null, "committer": null, "parents": [{"sha": "c067bc3cd04c282e2a4b1f81ddb96aabfe98d50b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c067bc3cd04c282e2a4b1f81ddb96aabfe98d50b", "html_url": "https://github.com/rust-lang/rust/commit/c067bc3cd04c282e2a4b1f81ddb96aabfe98d50b"}], "stats": {"total": 124, "additions": 105, "deletions": 19}, "files": [{"sha": "bce0eff2fc5bed56fc7318905f692efd6c1efcbe", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6ae617b31348e6397b581a7b5f1c66d30d335024/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae617b31348e6397b581a7b5f1c66d30d335024/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=6ae617b31348e6397b581a7b5f1c66d30d335024", "patch": "@@ -2,8 +2,9 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n use syntax::ast::LitKind;\n+use syntax_pos::Span;\n use utils::paths;\n-use utils::{in_macro, is_expn_of, match_def_path, match_type, opt_def_id, resolve_node, snippet, span_lint_and_then, walk_ptrs_ty};\n+use utils::{in_macro, is_expn_of, last_path_segment, match_def_path, match_type, opt_def_id, resolve_node, snippet, span_lint_and_then, walk_ptrs_ty};\n \n /// **What it does:** Checks for the use of `format!(\"string literal with no\n /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n@@ -43,20 +44,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 return;\n             }\n             match expr.node {\n+\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n                     if_chain! {\n                         if let ExprPath(ref qpath) = fun.node;\n-                        if args.len() == 2;\n+                        if args.len() == 3;\n                         if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n-                        if match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        // ensure the format string is `\"{..}\"` with only one argument and no text\n-                        if check_static_str(&args[0]);\n-                        // ensure the format argument is `{}` ie. Display with no fancy option\n-                        // and that the argument is a string\n-                        if check_arg_is_display(cx, &args[1]);\n+                        if match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1FORMATTED);\n+                        if check_single_piece(&args[0]);\n+                        if let Some(format_arg) = get_single_string_arg(cx, &args[1]);\n+                        if check_unformatted(&args[2]);\n                         then {\n-                            let sugg = format!(\"{}.to_string()\", snippet(cx, expr.span, \"<expr>\").into_owned());\n+                            let sugg = format!(\"{}.to_string()\", snippet(cx, format_arg, \"<arg>\").into_owned());\n                             span_lint_and_then(cx, USELESS_FORMAT, span, \"useless use of `format!`\", |db| {\n                                 db.span_suggestion(expr.span, \"consider using .to_string()\", sugg);\n                             });\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n }\n \n /// Checks if the expressions matches `&[\"\"]`\n-fn check_static_str(expr: &Expr) -> bool {\n+fn check_single_piece(expr: &Expr) -> bool {\n     if_chain! {\n         if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\"]\n         if let ExprArray(ref exprs) = expr.node; // [\"\"]\n@@ -96,15 +96,17 @@ fn check_static_str(expr: &Expr) -> bool {\n \n /// Checks if the expressions matches\n /// ```rust,ignore\n-/// &match (&42,) {\n+/// &match (&\"arg\",) {\n /// (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0,\n /// ::std::fmt::Display::fmt)],\n /// }\n /// ```\n-fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n+/// and that type of `__arg0` is `&str` or `String`\n+/// then returns the span of first element of the matched tuple\n+fn get_single_string_arg(cx: &LateContext, expr: &Expr) -> Option<Span> {\n     if_chain! {\n         if let ExprAddrOf(_, ref expr) = expr.node;\n-        if let ExprMatch(_, ref arms, _) = expr.node;\n+        if let ExprMatch(ref match_expr, ref arms, _) = expr.node;\n         if arms.len() == 1;\n         if arms[0].pats.len() == 1;\n         if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n@@ -118,8 +120,40 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n+            if ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING) {\n+                if let ExprTup(ref values) = match_expr.node {\n+                    return Some(values[0].span);\n+                }\n+            }\n+        }\n+    }\n+\n+    None\n+}\n \n-            return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n+/// Checks if the expression matches\n+/// ```rust,ignore\n+/// &[_ {\n+///    format: _ {\n+///         width: _::Implied,\n+///         ...\n+///    },\n+///    ...,\n+/// }]\n+/// ```\n+fn check_unformatted(expr: &Expr) -> bool {\n+    if_chain! {\n+        if let ExprAddrOf(_, ref expr) = expr.node;\n+        if let ExprArray(ref exprs) = expr.node;\n+        if exprs.len() == 1;\n+        if let ExprStruct(_, ref fields, _) = exprs[0].node;\n+        if let Some(format_field) = fields.iter().filter(|f| f.name.node == \"format\").next();\n+        if let ExprStruct(_, ref fields, _) = format_field.expr.node;\n+        if let Some(align_field) = fields.iter().filter(|f| f.name.node == \"width\").next();\n+        if let ExprPath(ref qpath) = align_field.expr.node;\n+        if last_path_segment(qpath).name == \"Implied\";\n+        then {\n+            return true;\n         }\n     }\n "}, {"sha": "783c6ea095dc2b09eb4be3a67083f4139fef98e0", "filename": "tests/ui/format.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ae617b31348e6397b581a7b5f1c66d30d335024/tests%2Fui%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae617b31348e6397b581a7b5f1c66d30d335024/tests%2Fui%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.rs?ref=6ae617b31348e6397b581a7b5f1c66d30d335024", "patch": "@@ -12,15 +12,19 @@ fn main() {\n     format!(\"foo\");\n \n     format!(\"{}\", \"foo\");\n-    format!(\"{:?}\", \"foo\"); // we only want to warn about `{}`\n-    format!(\"{:+}\", \"foo\"); // we only want to warn about `{}`\n+    format!(\"{:?}\", \"foo\"); // don't warn about debug\n+    format!(\"{:8}\", \"foo\");\n+    format!(\"{:+}\", \"foo\"); // warn when the format makes no difference\n+    format!(\"{:<}\", \"foo\"); // warn when the format makes no difference\n     format!(\"foo {}\", \"bar\");\n     format!(\"{} bar\", \"foo\");\n \n     let arg: String = \"\".to_owned();\n     format!(\"{}\", arg);\n-    format!(\"{:?}\", arg); // we only want to warn about `{}`\n-    format!(\"{:+}\", arg); // we only want to warn about `{}`\n+    format!(\"{:?}\", arg); // don't warn about debug\n+    format!(\"{:8}\", arg);\n+    format!(\"{:+}\", arg); // warn when the format makes no difference\n+    format!(\"{:<}\", arg); // warn when the format makes no difference\n     format!(\"foo {}\", arg);\n     format!(\"{} bar\", arg);\n "}, {"sha": "fa5c740c551b51f953ead07dc34bfa1d2854043a", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6ae617b31348e6397b581a7b5f1c66d30d335024/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6ae617b31348e6397b581a7b5f1c66d30d335024/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=6ae617b31348e6397b581a7b5f1c66d30d335024", "patch": "@@ -6,5 +6,53 @@ error: useless use of `format!`\n    |\n    = note: `-D useless-format` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: useless use of `format!`\n+  --> $DIR/format.rs:14:5\n+   |\n+14 |     format!(\"{}\", \"foo\");\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string()`\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:17:5\n+   |\n+17 |     format!(\"{:+}\", \"foo\"); // warn when the format makes no difference\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string()`\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:18:5\n+   |\n+18 |     format!(\"{:<}\", \"foo\"); // warn when the format makes no difference\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `\"foo\".to_string()`\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:23:5\n+   |\n+23 |     format!(\"{}\", arg);\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string()`\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:26:5\n+   |\n+26 |     format!(\"{:+}\", arg); // warn when the format makes no difference\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string()`\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: useless use of `format!`\n+  --> $DIR/format.rs:27:5\n+   |\n+27 |     format!(\"{:<}\", arg); // warn when the format makes no difference\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `arg.to_string()`\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: aborting due to 7 previous errors\n "}]}