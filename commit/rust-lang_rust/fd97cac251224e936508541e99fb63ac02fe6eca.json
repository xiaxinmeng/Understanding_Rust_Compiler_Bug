{"sha": "fd97cac251224e936508541e99fb63ac02fe6eca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkOTdjYWMyNTEyMjRlOTM2NTA4NTQxZTk5ZmI2M2FjMDJmZTZlY2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-12T05:10:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-21T01:03:24Z"}, "message": "syntax: remove unused 'mut' variables", "tree": {"sha": "2060b9ee3c146637e30843a14ed7b463acdff7fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2060b9ee3c146637e30843a14ed7b463acdff7fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd97cac251224e936508541e99fb63ac02fe6eca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd97cac251224e936508541e99fb63ac02fe6eca", "html_url": "https://github.com/rust-lang/rust/commit/fd97cac251224e936508541e99fb63ac02fe6eca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd97cac251224e936508541e99fb63ac02fe6eca/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d317fe7e584832f4aac113d3d5d19d90536c081", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d317fe7e584832f4aac113d3d5d19d90536c081", "html_url": "https://github.com/rust-lang/rust/commit/7d317fe7e584832f4aac113d3d5d19d90536c081"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "c170ee5c1195c1b79a3f18590883477b26fa96e5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -342,7 +342,7 @@ fn highlight_lines_internal(cm: @codemap::CodeMap,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let mut left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n+        let left = str::len(fm.name) + digits + lo.col.to_uint() + 3u;\n         let mut s = ~\"\";\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line."}, {"sha": "6a877040f480879b0cf2e827e870cabb9ac4cd87", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -96,7 +96,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             }\n         }\n         fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n-            let mut rt_type;\n+            let rt_type;\n             match t {\n               TyHex(c) => match c {\n                 CaseUpper => rt_type = ~\"TyHexUpper\",\n@@ -272,16 +272,18 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     /* Translate each piece (portion of the fmt expression) by invoking the\n        corresponding function in core::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n+    let npieces = pieces.len();\n     do vec::consume(pieces) |i, pc| {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {\n                 let portion = mk_uniq_str(cx, fmt_sp, s);\n \n                 /* If this is the first portion, then initialize the local\n-                   buffer with it directly */\n+                   buffer with it directly. If it's actually the only piece,\n+                   then there's no need for it to be mutable */\n                 if i == 0 {\n-                    stms.push(mk_local(cx, fmt_sp, true, ident, portion));\n+                    stms.push(mk_local(cx, fmt_sp, npieces > 1, ident, portion));\n                 } else {\n                     let args = ~[mk_mut_addr_of(cx, fmt_sp, buf()), portion];\n                     let call = mk_call_global(cx,"}, {"sha": "f851b9781ab83336d2510b5a511c5dc150f7f8f7", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -73,7 +73,7 @@ impl parser_attr for Parser {\n         self.expect(&token::LBRACKET);\n         let meta_item = self.parse_meta_item();\n         self.expect(&token::RBRACKET);\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         return spanned(lo, hi, ast::attribute_ { style: style,\n                                                  value: meta_item,\n                                                  is_sugared_doc: false });\n@@ -141,16 +141,16 @@ impl parser_attr for Parser {\n             token::EQ => {\n                 self.bump();\n                 let lit = self.parse_lit();\n-                let mut hi = self.span.hi;\n+                let hi = self.span.hi;\n                 @spanned(lo, hi, ast::meta_name_value(name, lit))\n             }\n             token::LPAREN => {\n                 let inner_items = self.parse_meta_seq();\n-                let mut hi = self.span.hi;\n+                let hi = self.span.hi;\n                 @spanned(lo, hi, ast::meta_list(name, inner_items))\n             }\n             _ => {\n-                let mut hi = self.span.hi;\n+                let hi = self.span.hi;\n                 @spanned(lo, hi, ast::meta_word(name))\n             }\n         }"}, {"sha": "b73544e95d60802094fb5a6be9aad4bf3da36213", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -229,7 +229,7 @@ fn read_block_comment(rdr: @mut StringReader,\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n-    let mut col: CharPos = rdr.col;\n+    let col: CharPos = rdr.col;\n     bump(rdr);\n     bump(rdr);\n "}, {"sha": "f164eb06df532a0fa4e0f0e89d34fa07db86988e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -810,7 +810,7 @@ pub impl Parser {\n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n     fn parse_arg_general(&self, require_name: bool) -> arg {\n-        let mut m;\n+        let m;\n         let mut is_mutbl = false;\n         let pat = if require_name || self.is_named_argument() {\n             m = self.parse_arg_mode();\n@@ -1154,7 +1154,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n-        let mut ex: expr_;\n+        let ex: expr_;\n \n         if *self.token == token::LPAREN {\n             self.bump();\n@@ -1629,9 +1629,9 @@ pub impl Parser {\n     // parse a prefix-operator expr\n     fn parse_prefix_expr(&self) -> @expr {\n         let lo = self.span.lo;\n-        let mut hi;\n+        let hi;\n \n-        let mut ex;\n+        let ex;\n         match *self.token {\n           token::NOT => {\n             self.bump();\n@@ -1781,7 +1781,7 @@ pub impl Parser {\n           token::BINOPEQ(op) => {\n               self.bump();\n               let rhs = self.parse_expr();\n-              let mut aop;\n+              let aop;\n               match op {\n                   token::PLUS => aop = add,\n                   token::MINUS => aop = subtract,\n@@ -1956,7 +1956,7 @@ pub impl Parser {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let body = self.parse_block_no_value();\n-        let mut hi = body.span.hi;\n+        let hi = body.span.hi;\n         return self.mk_expr(lo, hi, expr_while(cond, body));\n     }\n \n@@ -1984,7 +1984,7 @@ pub impl Parser {\n \n             let lo = self.last_span.lo;\n             let body = self.parse_block_no_value();\n-            let mut hi = body.span.hi;\n+            let hi = body.span.hi;\n             return self.mk_expr(lo, hi, expr_loop(body, opt_ident));\n         } else {\n             // This is a 'continue' expression\n@@ -2043,7 +2043,7 @@ pub impl Parser {\n \n             arms.push(ast::arm { pats: pats, guard: guard, body: blk });\n         }\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         self.bump();\n         return self.mk_expr(lo, hi, expr_match(discriminant, arms));\n     }\n@@ -2162,7 +2162,7 @@ pub impl Parser {\n             let hi1 = self.last_span.lo;\n             let fieldpath = ast_util::ident_to_path(mk_sp(lo1, hi1),\n                                                     fieldname);\n-            let mut subpat;\n+            let subpat;\n             if *self.token == token::COLON {\n                 self.bump();\n                 subpat = self.parse_pat(refutable);\n@@ -2183,7 +2183,7 @@ pub impl Parser {\n \n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n-        let mut pat;\n+        let pat;\n         match *self.token {\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n           token::AT => {\n@@ -2534,7 +2534,7 @@ pub impl Parser {\n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n                                                true, false, false) {\n               iovi_item(i) => {\n-                let mut hi = i.span.hi;\n+                let hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n                 return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n               }\n@@ -2704,7 +2704,7 @@ pub impl Parser {\n                 }\n             }\n         }\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         self.bump();\n         let bloc = ast::blk_ {\n             view_items: view_items,\n@@ -3590,7 +3590,7 @@ pub impl Parser {\n         let purity = self.parse_fn_purity();\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n-        let mut hi = self.span.hi;\n+        let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n@@ -3798,7 +3798,7 @@ pub impl Parser {\n             }\n         }\n         self.bump();\n-        let mut actual_dtor = do the_dtor.map |dtor| {\n+        let actual_dtor = do the_dtor.map |dtor| {\n             let (d_body, d_attrs, d_s) = copy *dtor;\n             codemap::spanned { node: ast::struct_dtor_ { id: self.get_id(),\n                                                      attrs: d_attrs,"}, {"sha": "17add33d67316f63eb2faf6c373caa686d940c8d", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -146,9 +146,9 @@ pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer %u\", linewidth);\n-    let mut token: ~[token] = vec::from_elem(n, EOF);\n-    let mut size: ~[int] = vec::from_elem(n, 0);\n-    let mut scan_stack: ~[uint] = vec::from_elem(n, 0u);\n+    let token: ~[token] = vec::from_elem(n, EOF);\n+    let size: ~[int] = vec::from_elem(n, 0);\n+    let scan_stack: ~[uint] = vec::from_elem(n, 0u);\n     @mut Printer {\n         out: @out,\n         buf_len: n,"}, {"sha": "ce772ca7c35f2eca5dfaccd6f6f8af6ec1975f6b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd97cac251224e936508541e99fb63ac02fe6eca/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fd97cac251224e936508541e99fb63ac02fe6eca", "patch": "@@ -1972,7 +1972,7 @@ pub fn print_ty_fn(s: @ps,\n \n pub fn maybe_print_trailing_comment(s: @ps, span: codemap::span,\n                                     next_pos: Option<BytePos>) {\n-    let mut cm;\n+    let cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n     match next_comment(s) {\n       Some(ref cmnt) => {"}]}