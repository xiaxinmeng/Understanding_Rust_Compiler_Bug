{"sha": "2a23d08aaefd60d294d63600a707575a6efcf292", "node_id": "C_kwDOAAsO6NoAKDJhMjNkMDhhYWVmZDYwZDI5NGQ2MzYwMGE3MDc1NzVhNmVmY2YyOTI", "commit": {"author": {"name": "Raoul Strackx", "email": "raoul.strackx@fortanix.com", "date": "2022-08-10T13:38:53Z"}, "committer": {"name": "Raoul Strackx", "email": "raoul.strackx@fortanix.com", "date": "2022-08-17T07:51:03Z"}, "message": "Mitigate Stale Data Read for xAPIC vulnerability\n\nIn order to mitigate the Stale Data Read for xAPIC vulnerability completely, reading userspace from an SGX enclave must be aligned and in 8-bytes chunks.\n\nReferences:\n\n - https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00657.html\n - https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/stale-data-read-from-xapic.html", "tree": {"sha": "2ce9ab204571dc27b64643713e4cd28f9d13b17f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce9ab204571dc27b64643713e4cd28f9d13b17f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a23d08aaefd60d294d63600a707575a6efcf292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a23d08aaefd60d294d63600a707575a6efcf292", "html_url": "https://github.com/rust-lang/rust/commit/2a23d08aaefd60d294d63600a707575a6efcf292", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a23d08aaefd60d294d63600a707575a6efcf292/comments", "author": {"login": "raoulstrackx", "id": 56830709, "node_id": "MDQ6VXNlcjU2ODMwNzA5", "avatar_url": "https://avatars.githubusercontent.com/u/56830709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raoulstrackx", "html_url": "https://github.com/raoulstrackx", "followers_url": "https://api.github.com/users/raoulstrackx/followers", "following_url": "https://api.github.com/users/raoulstrackx/following{/other_user}", "gists_url": "https://api.github.com/users/raoulstrackx/gists{/gist_id}", "starred_url": "https://api.github.com/users/raoulstrackx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raoulstrackx/subscriptions", "organizations_url": "https://api.github.com/users/raoulstrackx/orgs", "repos_url": "https://api.github.com/users/raoulstrackx/repos", "events_url": "https://api.github.com/users/raoulstrackx/events{/privacy}", "received_events_url": "https://api.github.com/users/raoulstrackx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "raoulstrackx", "id": 56830709, "node_id": "MDQ6VXNlcjU2ODMwNzA5", "avatar_url": "https://avatars.githubusercontent.com/u/56830709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raoulstrackx", "html_url": "https://github.com/raoulstrackx", "followers_url": "https://api.github.com/users/raoulstrackx/followers", "following_url": "https://api.github.com/users/raoulstrackx/following{/other_user}", "gists_url": "https://api.github.com/users/raoulstrackx/gists{/gist_id}", "starred_url": "https://api.github.com/users/raoulstrackx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raoulstrackx/subscriptions", "organizations_url": "https://api.github.com/users/raoulstrackx/orgs", "repos_url": "https://api.github.com/users/raoulstrackx/repos", "events_url": "https://api.github.com/users/raoulstrackx/events{/privacy}", "received_events_url": "https://api.github.com/users/raoulstrackx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25de53f76842544b695f826303034fd0419a5d6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/25de53f76842544b695f826303034fd0419a5d6a", "html_url": "https://github.com/rust-lang/rust/commit/25de53f76842544b695f826303034fd0419a5d6a"}], "stats": {"total": 144, "additions": 137, "deletions": 7}, "files": [{"sha": "34634da44de67f257814a6f2c2a119d90e2fe0a2", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 109, "deletions": 5, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2a23d08aaefd60d294d63600a707575a6efcf292/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a23d08aaefd60d294d63600a707575a6efcf292/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=2a23d08aaefd60d294d63600a707575a6efcf292", "patch": "@@ -313,9 +313,9 @@ where\n //   +--------+\n //   | small1 | Chunk smaller than 8 bytes\n //   +--------+\n-fn region_as_aligned_chunks(ptr: *const u8, len: usize) -> (u8, usize, u8) {\n-    let small0_size = (8 - ptr as usize % 8) as u8;\n-    let small1_size = ((len - small0_size as usize) % 8) as u8;\n+fn region_as_aligned_chunks(ptr: *const u8, len: usize) -> (usize, usize, usize) {\n+    let small0_size = if ptr as usize % 8 == 0 { 0 } else { 8 - ptr as usize % 8 };\n+    let small1_size = (len - small0_size as usize) % 8;\n     let big_size = len - small0_size as usize - small1_size as usize;\n \n     (small0_size, big_size, small1_size)\n@@ -417,6 +417,106 @@ pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize)\n     }\n }\n \n+/// Copies `len` bytes of data from userspace pointer `src` to enclave pointer `dst`\n+///\n+/// This function mitigates AEPIC leak vulnerabilities by ensuring all reads from untrusted memory are 8-byte aligned\n+///\n+/// # Panics\n+/// This function panics if:\n+///\n+/// * The `src` pointer is null\n+/// * The `dst` pointer is null\n+/// * The `src` memory range is not in user memory\n+/// * The `dst` memory range is not in enclave memory\n+///\n+/// # References\n+///  - https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00657.html\n+///  - https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/advisory-guidance/stale-data-read-from-xapic.html\n+pub(crate) unsafe fn copy_from_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+    // Copies memory region `src..src + len` to the enclave at `dst`. The source memory region\n+    // is:\n+    //  - strictly less than 8 bytes in size and may be\n+    //  - located at a misaligned memory location\n+    fn copy_misaligned_chunk_to_enclave(src: *const u8, dst: *mut u8, len: usize) {\n+        let mut tmp_buff = [0u8; 16];\n+\n+        unsafe {\n+            // Compute an aligned memory region to read from\n+            // +--------+ <-- aligned_src + aligned_len (8B-aligned)\n+            // |  pad1  |\n+            // +--------+ <-- src + len (misaligned)\n+            // |        |\n+            // |        |\n+            // |        |\n+            // +--------+ <-- src (misaligned)\n+            // |  pad0  |\n+            // +--------+ <-- aligned_src (8B-aligned)\n+            let pad0_size = src as usize % 8;\n+            let aligned_src = src.sub(pad0_size);\n+\n+            let pad1_size = 8 - (src.add(len) as usize % 8);\n+            let aligned_len = pad0_size + len + pad1_size;\n+\n+            debug_assert!(len < 8);\n+            debug_assert_eq!(aligned_src as usize % 8, 0);\n+            debug_assert_eq!(aligned_len % 8, 0);\n+            debug_assert!(aligned_len <= 16);\n+\n+            // Copy the aligned buffer to a temporary buffer\n+            // Note: copying from a slightly different memory location is a bit odd. In this case it\n+            // can't lead to page faults or inadvertent copying from the enclave as we only ensured\n+            // that the `src` pointer is aligned at an 8 byte boundary. As pages are 4096 bytes\n+            // aligned, `aligned_src` must be on the same page as `src`. A similar argument can be made\n+            // for `src + len`\n+            copy_quadwords(aligned_src as _, tmp_buff.as_mut_ptr(), aligned_len);\n+\n+            // Copy the correct parts of the temporary buffer to the destination\n+            ptr::copy(tmp_buff.as_ptr().add(pad0_size), dst, len);\n+        }\n+    }\n+\n+    assert!(!src.is_null());\n+    assert!(!dst.is_null());\n+    assert!(is_user_range(src, len));\n+    assert!(is_enclave_range(dst, len));\n+    assert!(!(src as usize).overflowing_add(len + 8).1);\n+    assert!(!(dst as usize).overflowing_add(len + 8).1);\n+\n+    if len < 8 {\n+        copy_misaligned_chunk_to_enclave(src, dst, len);\n+    } else if len % 8 == 0 && src as usize % 8 == 0 {\n+        // Copying 8-byte aligned quadwords: copy quad word per quad word\n+        unsafe {\n+            copy_quadwords(src, dst, len);\n+        }\n+    } else {\n+        // Split copies into three parts:\n+        //   +--------+\n+        //   | small0 | Chunk smaller than 8 bytes\n+        //   +--------+\n+        //   |   big  | Chunk 8-byte aligned, and size a multiple of 8 bytes\n+        //   +--------+\n+        //   | small1 | Chunk smaller than 8 bytes\n+        //   +--------+\n+        let (small0_size, big_size, small1_size) = region_as_aligned_chunks(dst, len);\n+\n+        unsafe {\n+            // Copy small0\n+            copy_misaligned_chunk_to_enclave(src, dst, small0_size);\n+\n+            // Copy big\n+            let big_src = src.add(small0_size);\n+            let big_dst = dst.add(small0_size);\n+            copy_quadwords(big_src, big_dst, big_size);\n+\n+            // Copy small1\n+            let small1_src = src.add(big_size + small0_size);\n+            let small1_dst = dst.add(big_size + small0_size);\n+            copy_misaligned_chunk_to_enclave(small1_src, small1_dst, small1_size);\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T>\n where\n@@ -481,7 +581,7 @@ where\n     pub fn copy_to_enclave(&self, dest: &mut T) {\n         unsafe {\n             assert_eq!(mem::size_of_val(dest), mem::size_of_val(&*self.0.get()));\n-            ptr::copy(\n+            copy_from_userspace(\n                 self.0.get() as *const T as *const u8,\n                 dest as *mut T as *mut u8,\n                 mem::size_of_val(dest),\n@@ -507,7 +607,11 @@ where\n {\n     /// Copies the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n-        unsafe { ptr::read(self.0.get()) }\n+        unsafe {\n+            let mut data: T = mem::MaybeUninit::uninit().assume_init();\n+            copy_from_userspace(self.0.get() as _, &mut data as *mut T as _, mem::size_of::<T>());\n+            data\n+        }\n     }\n }\n "}, {"sha": "4320f0bccd199b99b3301393508b04e56a74e0d8", "filename": "library/std/src/sys/sgx/abi/usercalls/tests.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a23d08aaefd60d294d63600a707575a6efcf292/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a23d08aaefd60d294d63600a707575a6efcf292/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs?ref=2a23d08aaefd60d294d63600a707575a6efcf292", "patch": "@@ -1,8 +1,8 @@\n-use super::alloc::copy_to_userspace;\n use super::alloc::User;\n+use super::alloc::{copy_from_userspace, copy_to_userspace};\n \n #[test]\n-fn test_copy_function() {\n+fn test_copy_to_userspace_function() {\n     let mut src = [0u8; 100];\n     let mut dst = User::<[u8]>::uninitialized(100);\n \n@@ -28,3 +28,29 @@ fn test_copy_function() {\n         }\n     }\n }\n+\n+#[test]\n+fn test_copy_from_userspace_function() {\n+    let mut dst = [0u8; 100];\n+    let mut src = User::<[u8]>::uninitialized(100);\n+\n+    src.copy_from_enclave(&[0u8; 100]);\n+\n+    for size in 0..48 {\n+        // For all possible alignment\n+        for offset in 0..8 {\n+            // overwrite complete dst\n+            dst = [0u8; 100];\n+\n+            // Copy src[0..size] to dst + offset\n+            unsafe { copy_from_userspace(src.as_ptr().offset(offset), dst.as_mut_ptr(), size) };\n+\n+            // Verify copy\n+            for byte in 0..size {\n+                unsafe {\n+                    assert_eq!(dst[byte as usize], *src.as_ptr().offset(offset + byte as isize));\n+                }\n+            }\n+        }\n+    }\n+}"}]}