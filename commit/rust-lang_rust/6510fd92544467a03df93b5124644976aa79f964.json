{"sha": "6510fd92544467a03df93b5124644976aa79f964", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1MTBmZDkyNTQ0NDY3YTAzZGY5M2I1MTI0NjQ0OTc2YWE3OWY5NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-19T22:57:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-19T22:57:50Z"}, "message": "auto merge of #5960 : brson/rust/io, r=pcwalton\n\nr?\r\n\r\nThis pull request is a grab bag of work on the new scheduler.\r\n\r\nThe most important commit here is where I [outline](https://github.com/brson/rust/blob/io/src/libcore/rt/io/mod.rs) a fairly complete I/O API, based on `Reader` and `Writer` types, as in the current `core::io` module. I've organized this version into a number of modules with declarations for Files, TCP, UDP, Unix sockets, blocking/non-blocking implementations, memory buffers, compression adapters. I'm trying to get this into shape to present on the mailing list.\r\n\r\nThis branch also wires up `spawn` to the new scheduler, and simplifies the core scheduler operations.", "tree": {"sha": "58b8f87b6432f171e4dd7d0b82cc9adbb4938b83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58b8f87b6432f171e4dd7d0b82cc9adbb4938b83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6510fd92544467a03df93b5124644976aa79f964", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6510fd92544467a03df93b5124644976aa79f964", "html_url": "https://github.com/rust-lang/rust/commit/6510fd92544467a03df93b5124644976aa79f964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6510fd92544467a03df93b5124644976aa79f964/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bffe23b0cfee2e6957a81a98f8c8a885522e3444", "url": "https://api.github.com/repos/rust-lang/rust/commits/bffe23b0cfee2e6957a81a98f8c8a885522e3444", "html_url": "https://github.com/rust-lang/rust/commit/bffe23b0cfee2e6957a81a98f8c8a885522e3444"}, {"sha": "7270fadfccb8f7b767bf45bda106a55b6a874c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/7270fadfccb8f7b767bf45bda106a55b6a874c03", "html_url": "https://github.com/rust-lang/rust/commit/7270fadfccb8f7b767bf45bda106a55b6a874c03"}], "stats": {"total": 2120, "additions": 1903, "deletions": 217}, "files": [{"sha": "1d6893b3ca6166edf340f171563525e633c0ff6a", "filename": "src/libcore/rt/io/comm_adapters.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fcomm_adapters.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::{Reader, Writer};\n+\n+struct PortReader<P>;\n+\n+impl<P: GenericPort<~[u8]>> PortReader<P> {\n+    pub fn new(_port: P) -> PortReader<P> { fail!() }\n+}\n+\n+impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+struct ChanWriter<C>;\n+\n+impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n+    pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n+}\n+\n+impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n+    pub fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    pub fn flush(&mut self) { fail!() }\n+}\n+\n+struct ReaderPort<R>;\n+\n+impl<R: Reader> ReaderPort<R> {\n+    pub fn new(_reader: R) -> ReaderPort<R> { fail!() }\n+}\n+\n+impl<R: Reader> GenericPort<~[u8]> for ReaderPort<R> {\n+    fn recv(&self) -> ~[u8] { fail!() }\n+\n+    fn try_recv(&self) -> Option<~[u8]> { fail!() }\n+}\n+\n+struct WriterChan<W>;\n+\n+impl<W: Writer> WriterChan<W> {\n+    pub fn new(_writer: W) -> WriterChan<W> { fail!() }\n+}\n+\n+impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n+    fn send(&self, _x: ~[u8]) { fail!() }\n+}\n+"}, {"sha": "e041183b5845250a62522495b6f0a2f9d25bfe63", "filename": "src/libcore/rt/io/file.rs", "status": "modified", "additions": 54, "deletions": 10, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Ffile.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -9,35 +9,79 @@\n // except according to those terms.\n \n use prelude::*;\n-use super::Stream;\n+use super::misc::PathLike;\n+use super::{Reader, Writer, Seek, Close};\n+use super::{IoError, SeekStyle};\n+\n+/// Open a file with the default FileMode and FileAccess\n+/// # XXX are there sane defaults here?\n+pub fn open_file<P: PathLike>(_path: &P) -> FileStream { fail!() }\n+\n+/// # XXX\n+/// * Ugh, this is ridiculous. What is the best way to represent these options?\n+enum FileMode {\n+    /// Opens an existing file. IoError if file does not exist.\n+    Open,\n+    /// Creates a file. IoError if file exists.\n+    Create,\n+    /// Opens an existing file or creates a new one.\n+    OpenOrCreate,\n+    /// Opens an existing file or creates a new one, positioned at EOF.\n+    Append,\n+    /// Opens an existing file, truncating it to 0 bytes.\n+    Truncate,\n+    /// Opens an existing file or creates a new one, truncating it to 0 bytes.\n+    CreateOrTruncate,\n+}\n+\n+enum FileAccess {\n+    Read,\n+    Write,\n+    ReadWrite\n+}\n \n pub struct FileStream;\n \n-pub impl FileStream {\n-    fn new(_path: Path) -> FileStream {\n+impl FileStream {\n+    pub fn open<P: PathLike>(_path: &P,\n+                             _mode: FileMode,\n+                             _access: FileAccess\n+                            ) -> Result<FileStream, IoError> {\n         fail!()\n     }\n }\n \n-impl Stream for FileStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> uint {\n+impl Reader for FileStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n         fail!()\n     }\n \n     fn eof(&mut self) -> bool {\n         fail!()\n     }\n+}\n \n-    fn write(&mut self, _v: &const [u8]) {\n-        fail!()\n-    }\n+impl Writer for FileStream {\n+    fn write(&mut self, _v: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Seek for FileStream {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+impl Close for FileStream {\n+    fn close(&mut self) { fail!() }\n }\n \n #[test]\n #[ignore]\n fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {\n     let message = \"it's alright. have a good time\";\n-    let filename = Path(\"test.txt\");\n-    let mut outstream = FileStream::new(filename);\n+    let filename = &Path(\"test.txt\");\n+    let mut outstream = FileStream::open(filename, Create, Read).unwrap();\n     outstream.write(message.to_bytes());\n }"}, {"sha": "24537bef329abb35e0bfb09c215b91a761c345b6", "filename": "src/libcore/rt/io/flate.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fflate.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Some various other I/O types\n+\n+// NOTE: These ultimately belong somewhere else\n+\n+use prelude::*;\n+use super::*;\n+\n+/// A Writer decorator that compresses using the 'deflate' scheme\n+pub struct DeflateWriter<W> {\n+    inner_writer: W\n+}\n+\n+impl<W: Writer> DeflateWriter<W> {\n+    pub fn new(inner_writer: W) -> DeflateWriter<W> {\n+        DeflateWriter {\n+            inner_writer: inner_writer\n+        }\n+    }\n+}\n+\n+impl<W: Writer> Writer for DeflateWriter<W> {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl<W: Writer> Decorator<W> for DeflateWriter<W> {\n+    fn inner(self) -> W {\n+        match self {\n+            DeflateWriter { inner_writer: w } => w\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a W {\n+        match *self {\n+            DeflateWriter { inner_writer: ref w } => w\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut W {\n+        match *self {\n+            DeflateWriter { inner_writer: ref mut w } => w\n+        }\n+    }\n+}\n+\n+/// A Reader decorator that decompresses using the 'deflate' scheme\n+pub struct InflateReader<R> {\n+    inner_reader: R\n+}\n+\n+impl<R: Reader> InflateReader<R> {\n+    pub fn new(inner_reader: R) -> InflateReader<R> {\n+        InflateReader {\n+            inner_reader: inner_reader\n+        }\n+    }\n+}\n+\n+impl<R: Reader> Reader for InflateReader<R> {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl<R: Reader> Decorator<R> for InflateReader<R> {\n+    fn inner(self) -> R {\n+        match self {\n+            InflateReader { inner_reader: r } => r\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a R {\n+        match *self {\n+            InflateReader { inner_reader: ref r } => r\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n+        match *self {\n+            InflateReader { inner_reader: ref mut r } => r\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::*;\n+    use super::super::mem::*;\n+    use super::super::Decorator;\n+\n+    #[test]\n+    #[ignore]\n+    fn smoke_test() {\n+        let mem_writer = MemWriter::new();\n+        let mut deflate_writer = DeflateWriter::new(mem_writer);\n+        let in_msg = \"test\";\n+        let in_bytes = in_msg.to_bytes();\n+        deflate_writer.write(in_bytes);\n+        deflate_writer.flush();\n+        let buf = deflate_writer.inner().inner();\n+        let mem_reader = MemReader::new(buf);\n+        let mut inflate_reader = InflateReader::new(mem_reader);\n+        let mut out_bytes = [0, .. 100];\n+        let bytes_read = inflate_reader.read(out_bytes).get();\n+        assert!(bytes_read == in_bytes.len());\n+        let out_msg = str::from_bytes(out_bytes);\n+        assert!(in_msg == out_msg);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "600968a3c710544f9b225b5b16737032a3e014be", "filename": "src/libcore/rt/io/mem.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmem.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,166 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Readers and Writers for in-memory buffers\n+//!\n+//! # XXX\n+//!\n+//! * Should probably have something like this for strings.\n+//! * Should they implement Closable? Would take extra state.\n+\n+use prelude::*;\n+use super::*;\n+\n+\n+/// Writes to an owned, growable byte vector\n+pub struct MemWriter {\n+    buf: ~[u8]\n+}\n+\n+impl MemWriter {\n+    pub fn new() -> MemWriter { MemWriter { buf: ~[] } }\n+}\n+\n+impl Writer for MemWriter {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { /* no-op */ }\n+}\n+\n+impl Seek for MemWriter {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+impl Decorator<~[u8]> for MemWriter {\n+\n+    fn inner(self) -> ~[u8] {\n+        match self {\n+            MemWriter { buf: buf } => buf\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n+        match *self {\n+            MemWriter { buf: ref buf } => buf\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n+        match *self {\n+            MemWriter { buf: ref mut buf } => buf\n+        }\n+    }\n+}\n+\n+/// Reads from an owned byte vector\n+pub struct MemReader {\n+    buf: ~[u8],\n+    pos: uint\n+}\n+\n+impl MemReader {\n+    pub fn new(buf: ~[u8]) -> MemReader {\n+        MemReader {\n+            buf: buf,\n+            pos: 0\n+        }\n+    }\n+}\n+\n+impl Reader for MemReader {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Seek for MemReader {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+impl Decorator<~[u8]> for MemReader {\n+\n+    fn inner(self) -> ~[u8] {\n+        match self {\n+            MemReader { buf: buf, _ } => buf\n+        }\n+    }\n+\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n+        match *self {\n+            MemReader { buf: ref buf, _ } => buf\n+        }\n+    }\n+\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n+        match *self {\n+            MemReader { buf: ref mut buf, _ } => buf\n+        }\n+    }\n+}\n+\n+\n+/// Writes to a fixed-size byte slice\n+struct BufWriter<'self> {\n+    buf: &'self mut [u8],\n+    pos: uint\n+}\n+\n+impl<'self> BufWriter<'self> {\n+    pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n+        BufWriter {\n+            buf: buf,\n+            pos: 0\n+        }\n+    }\n+}\n+\n+impl<'self> Writer for BufWriter<'self> {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl<'self> Seek for BufWriter<'self> {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+\n+/// Reads from a fixed-size byte slice\n+struct BufReader<'self> {\n+    buf: &'self [u8],\n+    pos: uint\n+}\n+\n+impl<'self> BufReader<'self> {\n+    pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n+        BufReader {\n+            buf: buf,\n+            pos: 0\n+        }\n+    }\n+}\n+\n+impl<'self> Reader for BufReader<'self> {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl<'self> Seek for BufReader<'self> {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n\\ No newline at end of file"}, {"sha": "7bace5d6df2ccfdba1cfe7538ab05cbed10da6cb", "filename": "src/libcore/rt/io/misc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmisc.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::*;\n+\n+pub trait PathLike {\n+    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T;\n+}\n+\n+impl<'self> PathLike for &'self str {\n+    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n+        f(*self)\n+    }\n+}\n+\n+impl PathLike for Path {\n+    fn path_as_str<T>(&self, f: &fn(&str) -> T) -> T {\n+        let s = self.to_str();\n+        f(s)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use path::*;\n+    use super::PathLike;\n+\n+    #[test]\n+    fn path_like_smoke_test() {\n+        let expected = \"/home\";\n+        let path = Path(expected);\n+        path.path_as_str(|p| assert!(p == expected));\n+        path.path_as_str(|p| assert!(p == expected));\n+    }\n+}"}, {"sha": "b035532144c44dfc4b8423886e3325eea51f74a4", "filename": "src/libcore/rt/io/mod.rs", "status": "modified", "additions": 255, "deletions": 14, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fmod.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -8,35 +8,276 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*! Synchronous I/O\n+\n+This module defines the Rust interface for synchronous I/O.\n+It supports file access,\n+\n+This will likely live in core::io, not core::rt::io.\n+\n+# Examples\n+\n+Some examples of obvious things you might want to do\n+\n+* Read lines from stdin\n+\n+    for stdin().each_line |line| {\n+        println(line)\n+    }\n+\n+* Read a complete file to a string, (converting newlines?)\n+\n+    let contents = open(\"message.txt\").read_to_str(); // read_to_str??\n+\n+* Write a line to a file\n+\n+    let file = FileStream::open(\"message.txt\", Create, Write);\n+    file.write_line(\"hello, file!\");\n+\n+* Iterate over the lines of a file\n+\n+* Pull the lines of a file into a vector of strings\n+\n+* Connect based on URL? Requires thinking about where the URL type lives\n+  and how to make protocol handlers extensible, e.g. the \"tcp\" protocol\n+  yields a `TcpStream`.\n+\n+    connect(\"tcp://localhost:8080\").write_line(\"HTTP 1.0 GET /\");\n+\n+# Terms\n+\n+* reader\n+* writer\n+* stream\n+* Blocking vs. non-blocking\n+* synchrony and asynchrony\n+\n+I tend to call this implementation non-blocking, because performing I/O\n+doesn't block the progress of other tasks. Is that how we want to present\n+it, 'synchronous but non-blocking'?\n+\n+# Error Handling\n+\n+# Resource management\n+\n+* `close` vs. RAII\n+\n+# Paths and URLs\n+\n+# std\n+\n+Some I/O things don't belong in core\n+\n+  - url\n+  - net - `fn connect`\n+    - http\n+  - flate\n+\n+# XXX\n+\n+* Should default constructors take `Path` or `&str`? `Path` makes simple cases verbose.\n+  Overloading would be nice.\n+* Add overloading for Path and &str and Url &str\n+* stdin/err/out\n+* print, println, etc.\n+* fsync\n+* relationship with filesystem querying, Directory, File types etc.\n+* Rename Reader/Writer to ByteReader/Writer, make Reader/Writer generic?\n+* Trait for things that are both readers and writers, Stream?\n+* How to handle newline conversion\n+* String conversion\n+* File vs. FileStream? File is shorter but could also be used for getting file info\n+  - maybe File is for general file querying and *also* has a static `open` method\n+* open vs. connect for generic stream opening\n+* Do we need `close` at all? dtors might be good enough\n+* How does I/O relate to the Iterator trait?\n+* std::base64 filters\n+\n+*/\n+\n+use prelude::*;\n+\n+// Reexports\n+pub use self::stdio::stdin;\n+pub use self::stdio::stdout;\n+pub use self::stdio::stderr;\n+pub use self::stdio::print;\n+pub use self::stdio::println;\n+\n+pub use self::file::open_file;\n+pub use self::file::FileStream;\n+pub use self::net::Listener;\n+pub use self::net::ip::IpAddr;\n+pub use self::net::tcp::TcpListener;\n+pub use self::net::tcp::TcpStream;\n+pub use self::net::udp::UdpStream;\n+\n+// Some extension traits that all Readers and Writers get.\n+pub use self::util::ReaderUtil;\n+pub use self::util::ReaderByteConversions;\n+pub use self::util::WriterByteConversions;\n+\n+/// Synchronous, non-blocking file I/O.\n pub mod file;\n \n-// FIXME #5370 Strongly want this to be StreamError(&mut Stream)\n-pub struct StreamError;\n+/// Synchronous, non-blocking network I/O.\n+#[path = \"net/mod.rs\"]\n+pub mod net;\n+\n+/// Readers and Writers for memory buffers and strings.\n+#[cfg(not(stage0))] // XXX Using unsnapshotted features\n+pub mod mem;\n+\n+/// Non-blocking access to stdin, stdout, stderr\n+pub mod stdio;\n+\n+/// Basic stream compression. XXX: Belongs with other flate code\n+#[cfg(not(stage0))] // XXX Using unsnapshotted features\n+pub mod flate;\n+\n+/// Interop between byte streams and pipes. Not sure where it belongs\n+#[cfg(not(stage0))] // XXX \"\n+pub mod comm_adapters;\n+\n+/// Extension traits\n+mod util;\n+\n+/// Non-I/O things needed by the I/O module\n+mod misc;\n+\n+/// Thread-blocking implementations\n+pub mod native {\n+    /// Posix file I/O\n+    pub mod file;\n+    /// # XXX - implement this\n+    pub mod stdio { }\n+    /// Sockets\n+    /// # XXX - implement this\n+    pub mod net {\n+        pub mod tcp { }\n+        pub mod udp { }\n+        #[cfg(unix)]\n+        pub mod unix { }\n+    }\n+}\n+\n+\n+/// The type passed to I/O condition handlers to indicate error\n+///\n+/// # XXX\n+///\n+/// Is something like this sufficient? It's kind of archaic\n+pub struct IoError {\n+    kind: IoErrorKind,\n+    desc: &'static str,\n+    detail: Option<~str>\n+}\n+\n+pub enum IoErrorKind {\n+    FileNotFound,\n+    FilePermission,\n+    ConnectionFailed,\n+    Closed,\n+    OtherIoError\n+}\n \n // XXX: Can't put doc comments on macros\n-// Raised by `Stream` instances on error. Returning `true` from the handler\n-// indicates that the `Stream` should continue, `false` that it should fail.\n+// Raised by `I/O` operations on error.\n condition! {\n-    stream_error: super::StreamError -> bool;\n+    io_error: super::IoError -> ();\n }\n \n-pub trait Stream {\n-    /// Read bytes, up to the length of `buf` and place them in `buf`,\n-    /// returning the number of bytes read or an `IoError`. Reads\n-    /// 0 bytes on EOF.\n+pub trait Reader {\n+    /// Read bytes, up to the length of `buf` and place them in `buf`.\n+    /// Returns the number of bytes read, or `None` on EOF.\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `reader_error` condition on error\n-    fn read(&mut self, buf: &mut [u8]) -> uint;\n+    /// Raises the `io_error` condition on error, then returns `None`.\n+    ///\n+    /// # XXX\n+    ///\n+    /// This doesn't take a `len` argument like the old `read`.\n+    /// Will people often need to slice their vectors to call this\n+    /// and will that be annoying?\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint>;\n \n-    /// Return whether the Reader has reached the end of the stream\n+    /// Return whether the Reader has reached the end of the stream.\n+    ///\n+    /// # Example\n+    ///\n+    ///     let reader = FileStream::new()\n+    ///     while !reader.eof() {\n+    ///         println(reader.read_line());\n+    ///     }\n+    ///\n+    /// # XXX\n+    ///\n+    /// What does this return if the Reader is in an error state?\n     fn eof(&mut self) -> bool;\n+}\n \n+pub trait Writer {\n     /// Write the given buffer\n     ///\n     /// # Failure\n     ///\n-    /// Raises the `writer_error` condition on error\n-    fn write(&mut self, v: &const [u8]);\n+    /// Raises the `io_error` condition on error\n+    fn write(&mut self, buf: &[u8]);\n+\n+    /// Flush output\n+    fn flush(&mut self);\n+}\n+\n+/// I/O types that may be closed\n+///\n+/// Any further operations performed on a closed resource will raise\n+/// on `io_error`\n+pub trait Close {\n+    /// Close the I/O resource\n+    fn close(&mut self);\n+}\n+\n+pub trait Stream: Reader + Writer + Close { }\n+\n+pub enum SeekStyle {\n+    /// Seek from the beginning of the stream\n+    SeekSet,\n+    /// Seek from the end of the stream\n+    SeekEnd,\n+    /// Seek from the current position\n+    SeekCur,\n+}\n+\n+/// # XXX\n+/// * Are `u64` and `i64` the right choices?\n+pub trait Seek {\n+    fn tell(&self) -> u64;\n+    fn seek(&mut self, pos: i64, style: SeekStyle);\n+}\n+\n+/// Common trait for decorator types.\n+///\n+/// Provides accessors to get the inner, 'decorated' values. The I/O library\n+/// uses decorators to add functionality like compression and encryption to I/O\n+/// streams.\n+///\n+/// # XXX\n+///\n+/// Is this worth having a trait for? May be overkill\n+pub trait Decorator<T> {\n+    /// Destroy the decorator and extract the decorated value\n+    ///\n+    /// # XXX\n+    ///\n+    /// Because this takes `self' one could never 'undecorate' a Reader/Writer\n+    /// that has been boxed. Is that ok? This feature is mostly useful for\n+    /// extracting the buffer from MemWriter\n+    fn inner(self) -> T;\n+\n+    /// Take an immutable reference to the decorated value\n+    fn inner_ref<'a>(&'a self) -> &'a T;\n+\n+    /// Take a mutable reference to the decorated value\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut T;\n }"}, {"sha": "e203df815f2f4f6f75b52011bd2862fe05559bdc", "filename": "src/libcore/rt/io/native/file.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnative%2Ffile.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Blocking posix-based file I/O\n+\n+use prelude::*;\n+use super::super::*;\n+use libc::{c_int, FILE};\n+\n+#[allow(non_camel_case_types)]\n+pub type fd_t = c_int;\n+\n+// Make this a newtype so we can't do I/O on arbitrary integers\n+pub struct FileDesc(fd_t);\n+\n+impl FileDesc {\n+    /// Create a `FileDesc` from an open C file descriptor.\n+    ///\n+    /// The `FileDesc` takes ownership of the file descriptor\n+    /// and will close it upon destruction.\n+    pub fn new(_fd: fd_t) -> FileDesc { fail!() }\n+}\n+\n+impl Reader for FileDesc {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for FileDesc {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Close for FileDesc {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+impl Seek for FileDesc {\n+    fn tell(&self) -> u64 { fail!() }\n+\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}\n+\n+pub struct CFile(*FILE);\n+\n+impl CFile {\n+    /// Create a `CFile` from an open `FILE` pointer.\n+    ///\n+    /// The `CFile` takes ownership of the file descriptor\n+    /// and will close it upon destruction.\n+    pub fn new(_file: *FILE) -> CFile { fail!() }\n+}\n+\n+impl Reader for CFile {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for CFile {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Close for CFile {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+impl Seek for CFile {\n+    fn tell(&self) -> u64 { fail!() }\n+    fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n+}"}, {"sha": "c693cfaab678bf2db3f931c18860f7db85343d75", "filename": "src/libcore/rt/io/net/http.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fhttp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fhttp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fhttp.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Simple HTTP client and server\n+\n+// XXX This should not be in core\n+\n+struct HttpServer;\n+\n+#[cfg(test)]\n+mod test {\n+    use unstable::run_in_bare_thread;\n+\n+    #[test] #[ignore]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+        }\n+\n+        do run_in_bare_thread {\n+        }\n+    }\n+}"}, {"sha": "d9b7f4e6e40114bbcca565e5368775327dd63723", "filename": "src/libcore/rt/io/net/ip.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fip.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub enum IpAddr {\n+    Ipv4(u8, u8, u8, u8, u16),\n+    Ipv6\n+}\n+"}, {"sha": "130ff6b38fa82f3f1a8a8a8e06c4d8294e672d18", "filename": "src/libcore/rt/io/net/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fmod.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+pub mod tcp;\n+pub mod udp;\n+pub mod ip;\n+#[cfg(unix)]\n+pub mod unix;\n+pub mod http;\n+\n+/// A listener is a value that listens for connections\n+pub trait Listener<S> {\n+    /// Wait for and accept an incoming connection\n+    ///\n+    /// Returns `None` on timeout.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises `io_error` condition. If the condition is handled,\n+    /// then `accept` returns `None`.\n+    fn accept(&mut self) -> Option<S>;\n+}"}, {"sha": "e3f71dca8c8274224471cdc50153b0ac77a83816", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::*;\n+use super::super::*;\n+use super::ip::IpAddr;\n+\n+pub struct TcpStream;\n+\n+impl TcpStream {\n+    pub fn connect(_addr: IpAddr) -> Result<TcpStream, IoError> {\n+        fail!()\n+    }\n+}\n+\n+impl Reader for TcpStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for TcpStream {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Close for TcpStream {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct TcpListener;\n+\n+impl TcpListener {\n+    pub fn new(_addr: IpAddr) -> TcpListener {\n+        fail!()\n+    }\n+}\n+\n+impl Listener<TcpStream> for TcpListener {\n+    fn accept(&mut self) -> Option<TcpStream> { fail!() }\n+}"}, {"sha": "f76bb58a45eb9a00d95a6bd32a4bf8a950ceec77", "filename": "src/libcore/rt/io/net/udp.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Fudp.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::*;\n+use super::super::*;\n+use super::ip::IpAddr;\n+\n+pub struct UdpStream;\n+\n+impl UdpStream {\n+    pub fn connect(_addr: IpAddr) -> Result<UdpStream, IoError> {\n+        fail!()\n+    }\n+}\n+\n+impl Reader for UdpStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for UdpStream {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Close for UdpStream {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct UdpListener;\n+\n+impl UdpListener {\n+    pub fn new(_addr: IpAddr) -> UdpListener {\n+        fail!()\n+    }\n+}\n+\n+impl Listener<UdpStream> for UdpListener {\n+    fn accept(&mut self) -> Option<UdpStream> { fail!() }\n+}\n+"}, {"sha": "35eabe21b2a6b2632508e41502bb25c15be0e66f", "filename": "src/libcore/rt/io/net/unix.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Funix.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::*;\n+use super::super::*;\n+use super::super::misc::PathLike;\n+\n+pub struct UnixStream;\n+\n+impl UnixStream {\n+    pub fn connect<P: PathLike>(_path: &P) -> Result<UnixStream, IoError> {\n+        fail!()\n+    }\n+}\n+\n+impl Reader for UnixStream {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Writer for UnixStream {\n+    fn write(&mut self, _v: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Close for UnixStream {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct UnixListener;\n+\n+impl UnixListener {\n+    pub fn new<P: PathLike>(_path: &P) -> UnixListener {\n+        fail!()\n+    }\n+}\n+\n+impl Listener<UnixStream> for UnixListener {\n+    fn accept(&mut self) -> Option<UnixStream> { fail!() }\n+}\n+"}, {"sha": "21989f5e873d0202a2d9ae66dce920c7c42b857b", "filename": "src/libcore/rt/io/stdio.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fstdio.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use super::{Reader, Writer, Close};\n+\n+pub fn stdin() -> StdReader { fail!() }\n+\n+pub fn stdout() -> StdWriter { fail!() }\n+\n+pub fn stderr() -> StdReader { fail!() }\n+\n+pub fn print(s: &str) { fail!() }\n+\n+pub fn println(s: &str) { fail!() }\n+\n+pub enum StdStream {\n+    StdIn,\n+    StdOut,\n+    StdErr\n+}\n+\n+pub struct StdReader;\n+\n+impl StdReader {\n+    pub fn new(_stream: StdStream) -> StdReader { fail!() }\n+}\n+\n+impl Reader for StdReader {\n+    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+\n+    fn eof(&mut self) -> bool { fail!() }\n+}\n+\n+impl Close for StdReader {\n+    fn close(&mut self) { fail!() }\n+}\n+\n+pub struct StdWriter;\n+\n+impl StdWriter {\n+    pub fn new(_stream: StdStream) -> StdWriter { fail!() }\n+}\n+\n+impl Writer for StdWriter {\n+    fn write(&mut self, _buf: &[u8]) { fail!() }\n+\n+    fn flush(&mut self) { fail!() }\n+}\n+\n+impl Close for StdWriter {\n+    fn close(&mut self) { fail!() }\n+}"}, {"sha": "cff224a80bee283cd2730af0a8ae5ada5ba0e9d1", "filename": "src/libcore/rt/io/util.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Futil.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -0,0 +1,469 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Utility mixins that apply to all Readers and Writers\n+\n+// XXX: Not sure how this should be structured\n+// XXX: Iteration should probably be considered seperately\n+\n+pub trait ReaderUtil {\n+\n+    /// Reads `len` bytes and gives you back a new vector\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns an empty\n+    /// vector if the condition is handled.\n+    fn read_bytes(&mut self, len: uint) -> ~[u8];\n+\n+    /// Reads all remaining bytes from the stream.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns an empty\n+    /// vector if the condition is handled.\n+    fn read_to_end(&mut self) -> ~[u8];\n+\n+}\n+\n+pub trait ReaderByteConversions {\n+    /// Reads `n` little-endian unsigned integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_uint_n(&mut self, nbytes: uint) -> u64;\n+\n+    /// Reads `n` little-endian signed integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_int_n(&mut self, nbytes: uint) -> i64;\n+\n+    /// Reads `n` big-endian unsigned integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_uint_n(&mut self, nbytes: uint) -> u64;\n+\n+    /// Reads `n` big-endian signed integer bytes.\n+    ///\n+    /// `n` must be between 1 and 8, inclusive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_int_n(&mut self, nbytes: uint) -> i64;\n+\n+    /// Reads a little-endian unsigned integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_uint(&mut self) -> uint;\n+\n+    /// Reads a little-endian integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_int(&mut self) -> int;\n+\n+    /// Reads a big-endian unsigned integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_uint(&mut self) -> uint;\n+\n+    /// Reads a big-endian integer.\n+    ///\n+    /// The number of bytes returned is system-dependant.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_int(&mut self) -> int;\n+\n+    /// Reads a big-endian `u64`.\n+    ///\n+    /// `u64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_u64(&mut self) -> u64;\n+\n+    /// Reads a big-endian `u32`.\n+    ///\n+    /// `u32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_u32(&mut self) -> u32;\n+\n+    /// Reads a big-endian `u16`.\n+    ///\n+    /// `u16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_u16(&mut self) -> u16;\n+\n+    /// Reads a big-endian `i64`.\n+    ///\n+    /// `i64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_i64(&mut self) -> i64;\n+\n+    /// Reads a big-endian `i32`.\n+    ///\n+    /// `i32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_i32(&mut self) -> i32;\n+\n+    /// Reads a big-endian `i16`.\n+    ///\n+    /// `i16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_i16(&mut self) -> i16;\n+\n+    /// Reads a big-endian `f64`.\n+    ///\n+    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_f64(&mut self) -> f64;\n+\n+    /// Reads a big-endian `f32`.\n+    ///\n+    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_be_f32(&mut self) -> f32;\n+\n+    /// Reads a little-endian `u64`.\n+    ///\n+    /// `u64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_u64(&mut self) -> u64;\n+\n+    /// Reads a little-endian `u32`.\n+    ///\n+    /// `u32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_u32(&mut self) -> u32;\n+\n+    /// Reads a little-endian `u16`.\n+    ///\n+    /// `u16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_u16(&mut self) -> u16;\n+\n+    /// Reads a little-endian `i64`.\n+    ///\n+    /// `i64`s are 8 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_i64(&mut self) -> i64;\n+\n+    /// Reads a little-endian `i32`.\n+    ///\n+    /// `i32`s are 4 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_i32(&mut self) -> i32;\n+\n+    /// Reads a little-endian `i16`.\n+    ///\n+    /// `i16`s are 2 bytes long.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_i16(&mut self) -> i16;\n+\n+    /// Reads a little-endian `f64`.\n+    ///\n+    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_f64(&mut self) -> f64;\n+\n+    /// Reads a little-endian `f32`.\n+    ///\n+    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_le_f32(&mut self) -> f32;\n+\n+    /// Read a u8.\n+    ///\n+    /// `u8`s are 1 byte.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_u8(&mut self) -> u8;\n+\n+    /// Read an i8.\n+    ///\n+    /// `i8`s are 1 byte.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error. Returns `0` if\n+    /// the condition is handled.\n+    fn read_i8(&mut self) -> i8;\n+\n+}\n+\n+pub trait WriterByteConversions {\n+    /// Write the result of passing n through `int::to_str_bytes`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_int(&mut self, n: int);\n+\n+    /// Write the result of passing n through `uint::to_str_bytes`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_uint(&mut self, n: uint);\n+\n+    /// Write a little-endian uint (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_uint(&mut self, n: uint);\n+\n+    /// Write a little-endian int (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_int(&mut self, n: int);\n+\n+    /// Write a big-endian uint (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_uint(&mut self, n: uint);\n+\n+    /// Write a big-endian int (number of bytes depends on system).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_int(&mut self, n: int);\n+\n+    /// Write a big-endian u64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_u64(&mut self, n: u64);\n+\n+    /// Write a big-endian u32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_u32(&mut self, n: u32);\n+\n+    /// Write a big-endian u16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_u16(&mut self, n: u16);\n+\n+    /// Write a big-endian i64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_i64(&mut self, n: i64);\n+\n+    /// Write a big-endian i32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_i32(&mut self, n: i32);\n+\n+    /// Write a big-endian i16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_i16(&mut self, n: i16);\n+\n+    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_f64(&mut self, f: f64);\n+\n+    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_be_f32(&mut self, f: f32);\n+\n+    /// Write a little-endian u64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_u64(&mut self, n: u64);\n+\n+    /// Write a little-endian u32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_u32(&mut self, n: u32);\n+\n+    /// Write a little-endian u16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_u16(&mut self, n: u16);\n+\n+    /// Write a little-endian i64 (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_i64(&mut self, n: i64);\n+\n+    /// Write a little-endian i32 (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_i32(&mut self, n: i32);\n+\n+    /// Write a little-endian i16 (2 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_i16(&mut self, n: i16);\n+\n+    /// Write a little-endian IEEE754 double-precision floating-point\n+    /// (8 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_f64(&mut self, f: f64);\n+\n+    /// Write a litten-endian IEEE754 single-precision floating-point\n+    /// (4 bytes).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_le_f32(&mut self, f: f32);\n+\n+    /// Write a u8 (1 byte).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_u8(&mut self, n: u8);\n+\n+    /// Write a i8 (1 byte).\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `io_error` condition on error.\n+    fn write_i8(&mut self, n: i8);\n+}"}, {"sha": "e93e0c6fc6cc98bc97e49b88b2d88a7c7fd3a86d", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -88,3 +88,96 @@ pub fn start(main: *u8, _argc: int, _argv: **c_char, _crate_map: *u8) -> int {\n         fn rust_call_nullary_fn(f: *u8);\n     }\n }\n+\n+/// Possible contexts in which Rust code may be executing.\n+/// Different runtime services are available depending on context.\n+#[deriving(Eq)]\n+pub enum RuntimeContext {\n+    // Only default services, e.g. exchange heap\n+    GlobalContext,\n+    // The scheduler may be accessed\n+    SchedulerContext,\n+    // Full task services, e.g. local heap, unwinding\n+    TaskContext,\n+    // Running in an old-style task\n+    OldTaskContext\n+}\n+\n+pub fn context() -> RuntimeContext {\n+\n+    use task::rt::rust_task;\n+    use self::sched::local_sched;\n+\n+    // XXX: Hitting TLS twice to check if the scheduler exists\n+    // then to check for the task is not good for perf\n+    if unsafe { rust_try_get_task().is_not_null() } {\n+        return OldTaskContext;\n+    } else {\n+        if local_sched::exists() {\n+            let context = ::cell::empty_cell();\n+            do local_sched::borrow |sched| {\n+                if sched.in_task_context() {\n+                    context.put_back(TaskContext);\n+                } else {\n+                    context.put_back(SchedulerContext);\n+                }\n+            }\n+            return context.take();\n+        } else {\n+            return GlobalContext;\n+        }\n+    }\n+\n+    pub extern {\n+        #[rust_stack]\n+        fn rust_try_get_task() -> *rust_task;\n+    }\n+}\n+\n+#[test]\n+fn test_context() {\n+    use unstable::run_in_bare_thread;\n+    use self::sched::{local_sched, Task};\n+    use self::uvio::UvEventLoop;\n+    use cell::Cell;\n+\n+    assert!(context() == OldTaskContext);\n+    do run_in_bare_thread {\n+        assert!(context() == GlobalContext);\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let task = ~do Task::new(&mut sched.stack_pool) {\n+            assert!(context() == TaskContext);\n+            let sched = local_sched::take();\n+            do sched.deschedule_running_task_and_then() |task| {\n+                assert!(context() == SchedulerContext);\n+                let task = Cell(task);\n+                do local_sched::borrow |sched| {\n+                    sched.task_queue.push_back(task.take());\n+                }\n+            }\n+        };\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}\n+\n+// For setting up tests of the new scheduler\n+#[cfg(test)]\n+pub fn run_in_newsched_task(f: ~fn()) {\n+    use cell::Cell;\n+    use unstable::run_in_bare_thread;\n+    use self::sched::Task;\n+    use self::uvio::UvEventLoop;\n+\n+    let f = Cell(Cell(f));\n+\n+    do run_in_bare_thread {\n+        let mut sched = ~UvEventLoop::new_scheduler();\n+        let f = f.take();\n+        let task = ~do Task::new(&mut sched.stack_pool) {\n+            (f.take())();\n+        };\n+        sched.task_queue.push_back(task);\n+        sched.run();\n+    }\n+}"}, {"sha": "66eb79ba6ae4ea2669c166545c64dbac140a7b97", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -11,6 +11,8 @@\n use option::*;\n use result::*;\n \n+use super::io::net::ip::IpAddr;\n+\n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n pub type EventLoopObject = super::uvio::UvEventLoop;\n@@ -43,8 +45,3 @@ pub trait Stream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, ()>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), ()>;\n }\n-\n-pub enum IpAddr {\n-    Ipv4(u8, u8, u8, u8, u16),\n-    Ipv6\n-}"}, {"sha": "2ab50252ac69ec9db54c53cdf41cd416894feb97", "filename": "src/libcore/rt/sched/local_sched.rs", "status": "renamed", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal_sched.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -10,11 +10,13 @@\n \n //! Access to the thread-local Scheduler\n \n+use prelude::*;\n use ptr::mut_null;\n use libc::c_void;\n use cast::transmute;\n \n use super::Scheduler;\n+use super::super::rtio::IoFactoryObject;\n use tls = super::super::thread_local_storage;\n #[cfg(test)] use super::super::uvio::UvEventLoop;\n \n@@ -39,11 +41,31 @@ pub fn take() -> ~Scheduler {\n     }\n }\n \n+/// Check whether there is a thread-local Scheduler attached to the running thread\n+pub fn exists() -> bool {\n+    unsafe {\n+        match maybe_tls_key() {\n+            Some(key) => tls::get(key).is_not_null(),\n+            None => false\n+        }\n+    }\n+}\n+\n+/// Borrow the thread-local scheduler from thread-local storage.\n+/// While the scheduler is borrowed it is not available in TLS.\n+pub fn borrow(f: &fn(&mut Scheduler)) {\n+    let mut sched = take();\n+    f(sched);\n+    put(sched);\n+}\n+\n /// Borrow a mutable reference to the thread-local Scheduler\n+///\n /// # Safety Note\n+///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn borrow() -> &mut Scheduler {\n+pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n     unsafe {\n         let key = tls_key();\n         let mut void_sched: *mut c_void = tls::get(key);\n@@ -59,11 +81,39 @@ pub unsafe fn borrow() -> &mut Scheduler {\n     }\n }\n \n+pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n+    unsafe {\n+        let sched = unsafe_borrow();\n+        return sched.event_loop.io().unwrap();\n+    }\n+}\n+\n fn tls_key() -> tls::Key {\n+    maybe_tls_key().get()\n+}\n+\n+fn maybe_tls_key() -> Option<tls::Key> {\n     unsafe {\n         let key: *mut c_void = rust_get_sched_tls_key();\n         let key: &mut tls::Key = transmute(key);\n-        return *key;\n+        let key = *key;\n+        // Check that the key has been initialized.\n+\n+        // NB: This is a little racy because, while the key is\n+        // initalized under a mutex and it's assumed to be initalized\n+        // in the Scheduler ctor by any thread that needs to use it,\n+        // we are not accessing the key under a mutex.  Threads that\n+        // are not using the new Scheduler but still *want to check*\n+        // whether they are running under a new Scheduler may see a 0\n+        // value here that is in the process of being initialized in\n+        // another thread. I think this is fine since the only action\n+        // they could take if it was initialized would be to check the\n+        // thread-local value and see that it's not set.\n+        if key != 0 {\n+            return Some(key);\n+        } else {\n+            return None;\n+        }\n     }\n }\n \n@@ -93,7 +143,7 @@ fn borrow_smoke_test() {\n     let scheduler = ~UvEventLoop::new_scheduler();\n     put(scheduler);\n     unsafe {\n-        let _scheduler = borrow();\n+        let _scheduler = unsafe_borrow();\n     }\n     let _scheduler = take();\n }", "previous_filename": "src/libcore/rt/sched/local.rs"}, {"sha": "28946281628b199044dfbd9c010298560fc949a7", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 107, "deletions": 145, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -14,15 +14,16 @@ use cast::transmute;\n \n use super::work_queue::WorkQueue;\n use super::stack::{StackPool, StackSegment};\n-use super::rtio::{EventLoop, EventLoopObject, IoFactoryObject};\n+use super::rtio::{EventLoop, EventLoopObject};\n use super::context::Context;\n+use cell::Cell;\n \n #[cfg(test)] use super::uvio::UvEventLoop;\n #[cfg(test)] use unstable::run_in_bare_thread;\n #[cfg(test)] use int;\n-#[cfg(test)] use cell::Cell;\n \n-mod local;\n+// A more convenient name for external callers, e.g. `local_sched::take()`\n+pub mod local_sched;\n \n /// The Scheduler is responsible for coordinating execution of Tasks\n /// on a single thread. When the scheduler is running it is owned by\n@@ -57,13 +58,13 @@ impl ClosureConverter for UnsafeTaskReceiver {\n \n enum CleanupJob {\n     DoNothing,\n-    RescheduleTask(~Task),\n-    RecycleTask(~Task),\n     GiveTask(~Task, UnsafeTaskReceiver)\n }\n \n pub impl Scheduler {\n \n+    fn in_task_context(&self) -> bool { self.current_task.is_some() }\n+\n     fn new(event_loop: ~EventLoopObject) -> Scheduler {\n \n         // Lazily initialize the global state, currently the scheduler TLS key\n@@ -90,47 +91,25 @@ pub impl Scheduler {\n         assert!(!self.in_task_context());\n \n         // Give ownership of the scheduler (self) to the thread\n-        local::put(self);\n-\n-        let scheduler = unsafe { local::borrow() };\n-        fn run_scheduler_once() {\n-            let scheduler = Scheduler::take_local();\n-            if scheduler.resume_task_from_queue() {\n-                // Ok, a task ran. Nice! We'll do it again later\n-                do Scheduler::borrow_local |scheduler| {\n-                    scheduler.event_loop.callback(run_scheduler_once);\n+        local_sched::put(self);\n+\n+        unsafe {\n+            let scheduler = local_sched::unsafe_borrow();\n+            fn run_scheduler_once() {\n+                let scheduler = local_sched::take();\n+                if scheduler.resume_task_from_queue() {\n+                    // Ok, a task ran. Nice! We'll do it again later\n+                    do local_sched::borrow |scheduler| {\n+                        scheduler.event_loop.callback(run_scheduler_once);\n+                    }\n                 }\n             }\n-        }\n-\n-        scheduler.event_loop.callback(run_scheduler_once);\n-        scheduler.event_loop.run();\n \n-        return local::take();\n-    }\n-\n-    /// Get a mutable pointer to the thread-local I/O\n-    /// # Safety Note\n-    /// This allows other mutable aliases to the scheduler, both in the current\n-    /// execution context and other execution contexts.\n-    unsafe fn borrow_local_io() -> &mut IoFactoryObject {\n-        unsafe {\n-            let io = local::borrow().event_loop.io().unwrap();\n-            transmute::<&mut IoFactoryObject, &mut IoFactoryObject>(io)\n+            scheduler.event_loop.callback(run_scheduler_once);\n+            scheduler.event_loop.run();\n         }\n-    }\n-\n-    /// Borrow the thread-local scheduler from thread-local storage.\n-    /// While the scheduler is borrowed it is not available in TLS.\n-    fn borrow_local(f: &fn(&mut Scheduler)) {\n-        let mut sched = local::take();\n-        f(sched);\n-        local::put(sched);\n-    }\n \n-    /// Take ownership of the scheduler from thread local storage\n-    fn take_local() -> ~Scheduler {\n-        local::take()\n+        return local_sched::take();\n     }\n \n     // * Scheduler-context operations\n@@ -146,41 +125,12 @@ pub impl Scheduler {\n             }\n             None => {\n                 rtdebug!(\"no tasks in queue\");\n-                local::put(self);\n+                local_sched::put(self);\n                 return false;\n             }\n         }\n     }\n \n-    fn resume_task_immediately(~self, task: ~Task) {\n-        let mut self = self;\n-        assert!(!self.in_task_context());\n-\n-        rtdebug!(\"scheduling a task\");\n-\n-        // Store the task in the scheduler so it can be grabbed later\n-        self.current_task = Some(task);\n-        self.enqueue_cleanup_job(DoNothing);\n-\n-        local::put(self);\n-\n-        // Take pointers to both the task and scheduler's saved registers.\n-        let sched = unsafe { local::borrow() };\n-        let (sched_context, _, next_task_context) = sched.get_contexts();\n-        let next_task_context = next_task_context.unwrap();\n-        // Context switch to the task, restoring it's registers\n-        // and saving the scheduler's\n-        Context::swap(sched_context, next_task_context);\n-\n-        let sched = unsafe { local::borrow() };\n-        // The running task should have passed ownership elsewhere\n-        assert!(sched.current_task.is_none());\n-\n-        // Running tasks may have asked us to do some cleanup\n-        sched.run_cleanup_job();\n-    }\n-\n-\n     // * Task-context operations\n \n     /// Called by a running task to end execution, after which it will\n@@ -191,17 +141,58 @@ pub impl Scheduler {\n \n         rtdebug!(\"ending running task\");\n \n-        let dead_task = self.current_task.swap_unwrap();\n-        self.enqueue_cleanup_job(RecycleTask(dead_task));\n+        do self.deschedule_running_task_and_then |dead_task| {\n+            let dead_task = Cell(dead_task);\n+            do local_sched::borrow |sched| {\n+                dead_task.take().recycle(&mut sched.stack_pool);\n+            }\n+        }\n \n-        local::put(self);\n+        // Control never reaches here\n+    }\n \n-        let sched = unsafe { local::borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n+    fn schedule_new_task(~self, task: ~Task) {\n+        let mut self = self;\n+        assert!(self.in_task_context());\n \n-        // Control never reaches here\n+        do self.switch_running_tasks_and_then(task) |last_task| {\n+            let last_task = Cell(last_task);\n+            do local_sched::borrow |sched| {\n+                sched.task_queue.push_front(last_task.take());\n+            }\n+        }\n+    }\n+\n+    // Core scheduling ops\n+\n+    fn resume_task_immediately(~self, task: ~Task) {\n+        let mut self = self;\n+        assert!(!self.in_task_context());\n+\n+        rtdebug!(\"scheduling a task\");\n+\n+        // Store the task in the scheduler so it can be grabbed later\n+        self.current_task = Some(task);\n+        self.enqueue_cleanup_job(DoNothing);\n+\n+        local_sched::put(self);\n+\n+        // Take pointers to both the task and scheduler's saved registers.\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (sched_context, _, next_task_context) = sched.get_contexts();\n+            let next_task_context = next_task_context.unwrap();\n+            // Context switch to the task, restoring it's registers\n+            // and saving the scheduler's\n+            Context::swap(sched_context, next_task_context);\n+\n+            let sched = local_sched::unsafe_borrow();\n+            // The running task should have passed ownership elsewhere\n+            assert!(sched.current_task.is_none());\n+\n+            // Running tasks may have asked us to do some cleanup\n+            sched.run_cleanup_job();\n+        }\n     }\n \n     /// Block a running task, context switch to the scheduler, then pass the\n@@ -223,47 +214,51 @@ pub impl Scheduler {\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         self.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n \n-        local::put(self);\n+        local_sched::put(self);\n \n-        let sched = unsafe { local::borrow() };\n+        let sched = unsafe { local_sched::unsafe_borrow() };\n         let (sched_context, last_task_context, _) = sched.get_contexts();\n         let last_task_context = last_task_context.unwrap();\n         Context::swap(last_task_context, sched_context);\n \n         // We could be executing in a different thread now\n-        let sched = unsafe { local::borrow() };\n+        let sched = unsafe { local_sched::unsafe_borrow() };\n         sched.run_cleanup_job();\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn resume_task_from_running_task_direct(~self, next_task: ~Task) {\n+    fn switch_running_tasks_and_then(~self, next_task: ~Task, f: &fn(~Task)) {\n         let mut self = self;\n         assert!(self.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = self.current_task.swap_unwrap();\n-        self.enqueue_cleanup_job(RescheduleTask(old_running_task));\n+        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n+        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n+        self.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         self.current_task = Some(next_task);\n \n-        local::put(self);\n+        local_sched::put(self);\n \n-        let sched = unsafe { local::borrow() };\n-        let (_, last_task_context, next_task_context) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        let next_task_context = next_task_context.unwrap();\n-        Context::swap(last_task_context, next_task_context);\n-\n-        // We could be executing in a different thread now\n-        let sched = unsafe { local::borrow() };\n-        sched.run_cleanup_job();\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (_, last_task_context, next_task_context) = sched.get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            let next_task_context = next_task_context.unwrap();\n+            Context::swap(last_task_context, next_task_context);\n+\n+            // We could be executing in a different thread now\n+            let sched = local_sched::unsafe_borrow();\n+            sched.run_cleanup_job();\n+        }\n     }\n \n-    // * Other stuff\n \n-    fn in_task_context(&self) -> bool { self.current_task.is_some() }\n+\n+    // * Other stuff\n \n     fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n         assert!(self.cleanup_job.is_none());\n@@ -278,11 +273,6 @@ pub impl Scheduler {\n         let cleanup_job = self.cleanup_job.swap_unwrap();\n         match cleanup_job {\n             DoNothing => { }\n-            RescheduleTask(task) => {\n-                // NB: Pushing to the *front* of the queue\n-                self.task_queue.push_front(task);\n-            }\n-            RecycleTask(task) => task.recycle(&mut self.stack_pool),\n             GiveTask(task, f) => (f.to_fn())(task)\n         }\n     }\n@@ -300,8 +290,6 @@ pub impl Scheduler {\n                                           Option<&'a mut Context>,\n                                           Option<&'a mut Context>) {\n         let last_task = match self.cleanup_job {\n-            Some(RescheduleTask(~ref task)) |\n-            Some(RecycleTask(~ref task)) |\n             Some(GiveTask(~ref task, _)) => {\n                 Some(task)\n             }\n@@ -358,12 +346,14 @@ pub impl Task {\n             // This is the first code to execute after the initial\n             // context switch to the task. The previous context may\n             // have asked us to do some cleanup.\n-            let sched = unsafe { local::borrow() };\n-            sched.run_cleanup_job();\n+            unsafe {\n+                let sched = local_sched::unsafe_borrow();\n+                sched.run_cleanup_job();\n+            }\n \n             start();\n \n-            let sched = Scheduler::take_local();\n+            let sched = local_sched::take();\n             sched.terminate_current_task();\n         };\n         return wrapper;\n@@ -415,20 +405,25 @@ fn test_several_tasks() {\n }\n \n #[test]\n-fn test_swap_tasks() {\n+fn test_swap_tasks_then() {\n     do run_in_bare_thread {\n         let mut count = 0;\n         let count_ptr: *mut int = &mut count;\n \n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task1 = ~do Task::new(&mut sched.stack_pool) {\n             unsafe { *count_ptr = *count_ptr + 1; }\n-            let mut sched = Scheduler::take_local();\n+            let mut sched = local_sched::take();\n             let task2 = ~do Task::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n             };\n             // Context switch directly to the new task\n-            sched.resume_task_from_running_task_direct(task2);\n+            do sched.switch_running_tasks_and_then(task2) |task1| {\n+                let task1 = Cell(task1);\n+                do local_sched::borrow |sched| {\n+                    sched.task_queue.push_front(task1.take());\n+                }\n+            }\n             unsafe { *count_ptr = *count_ptr + 1; }\n         };\n         sched.task_queue.push_back(task1);\n@@ -455,7 +450,7 @@ fn test_run_a_lot_of_tasks_queued() {\n         assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n-            do Scheduler::borrow_local |sched| {\n+            do local_sched::borrow |sched| {\n                 let task = ~do Task::new(&mut sched.stack_pool) {\n                     unsafe {\n                         *count_ptr = *count_ptr + 1;\n@@ -470,49 +465,16 @@ fn test_run_a_lot_of_tasks_queued() {\n     }\n }\n \n-#[bench] #[test] #[ignore(reason = \"too much stack allocation\")]\n-fn test_run_a_lot_of_tasks_direct() {\n-    do run_in_bare_thread {\n-        static MAX: int = 100000;\n-        let mut count = 0;\n-        let count_ptr: *mut int = &mut count;\n-\n-        let mut sched = ~UvEventLoop::new_scheduler();\n-\n-        let start_task = ~do Task::new(&mut sched.stack_pool) {\n-            run_task(count_ptr);\n-        };\n-        sched.task_queue.push_back(start_task);\n-        sched.run();\n-\n-        assert!(count == MAX);\n-\n-        fn run_task(count_ptr: *mut int) {\n-            let mut sched = Scheduler::take_local();\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n-                unsafe {\n-                    *count_ptr = *count_ptr + 1;\n-                    if *count_ptr != MAX {\n-                        run_task(count_ptr);\n-                    }\n-                }\n-            };\n-            // Context switch directly to the new task\n-            sched.resume_task_from_running_task_direct(task);\n-        };\n-    }\n-}\n-\n #[test]\n fn test_block_task() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            let sched = Scheduler::take_local();\n+            let sched = local_sched::take();\n             assert!(sched.in_task_context());\n             do sched.deschedule_running_task_and_then() |task| {\n                 let task = Cell(task);\n-                do Scheduler::borrow_local |sched| {\n+                do local_sched::borrow |sched| {\n                     assert!(!sched.in_task_context());\n                     sched.task_queue.push_back(task.take());\n                 }"}, {"sha": "0dc1a4d86cbc95237dc287a3765d4eaefef856ed", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -17,7 +17,7 @@ use super::{Loop, Watcher, Request, UvError, Buf, Callback, NativeHandle, NullCa\n             loop_from_watcher, status_to_maybe_uv_error,\n             install_watcher_data, get_watcher_data, drop_watcher_data,\n             vec_to_uv_buf, vec_from_uv_buf};\n-use super::super::rtio::{IpAddr, Ipv4, Ipv6};\n+use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n \n #[cfg(test)]\n use unstable::run_in_bare_thread;"}, {"sha": "ff5397398354af8c417f0a63b006f79ca6e84b99", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -11,12 +11,13 @@\n use option::*;\n use result::*;\n \n+use super::io::net::ip::{IpAddr, Ipv4};\n use super::uv::*;\n use super::rtio::*;\n use ops::Drop;\n use cell::{Cell, empty_cell};\n use cast::transmute;\n-use super::sched::Scheduler;\n+use super::sched::{Scheduler, local_sched};\n \n #[cfg(test)] use super::sched::Task;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -120,14 +121,14 @@ impl IoFactory for UvIoFactory {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n \n-        let scheduler = Scheduler::take_local();\n+        let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n \n         // Block this task and take ownership, switch to scheduler context\n         do scheduler.deschedule_running_task_and_then |task| {\n \n             rtdebug!(\"connect: entered scheduler context\");\n-            do Scheduler::borrow_local |scheduler| {\n+            do local_sched::borrow |scheduler| {\n                 assert!(!scheduler.in_task_context());\n             }\n             let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n@@ -149,7 +150,7 @@ impl IoFactory for UvIoFactory {\n                 unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n \n                 // Context switch\n-                let scheduler = Scheduler::take_local();\n+                let scheduler = local_sched::take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -194,7 +195,7 @@ impl TcpListener for UvTcpListener {\n \n         let server_tcp_watcher = self.watcher();\n \n-        let scheduler = Scheduler::take_local();\n+        let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n \n         do scheduler.deschedule_running_task_and_then |task| {\n@@ -217,7 +218,7 @@ impl TcpListener for UvTcpListener {\n \n                 rtdebug!(\"resuming task from listen\");\n                 // Context switch\n-                let scheduler = Scheduler::take_local();\n+                let scheduler = local_sched::take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -257,13 +258,13 @@ impl Stream for UvStream {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n \n-        let scheduler = Scheduler::take_local();\n+        let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&mut [u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |task| {\n             rtdebug!(\"read: entered scheduler context\");\n-            do Scheduler::borrow_local |scheduler| {\n+            do local_sched::borrow |scheduler| {\n                 assert!(!scheduler.in_task_context());\n             }\n             let mut watcher = watcher;\n@@ -291,7 +292,7 @@ impl Stream for UvStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Scheduler::take_local();\n+                let scheduler = local_sched::take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -303,7 +304,7 @@ impl Stream for UvStream {\n     fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n-        let scheduler = Scheduler::take_local();\n+        let scheduler = local_sched::take();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n         let buf_ptr: *&[u8] = &buf;\n@@ -322,7 +323,7 @@ impl Stream for UvStream {\n \n                 unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Scheduler::take_local();\n+                let scheduler = local_sched::take();\n                 scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n@@ -338,7 +339,7 @@ fn test_simple_io_no_connect() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { Scheduler::borrow_local_io() };\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n             let addr = Ipv4(127, 0, 0, 1, 2926);\n             let maybe_chan = io.connect(addr);\n             assert!(maybe_chan.is_none());\n@@ -356,25 +357,29 @@ fn test_simple_tcp_server_and_client() {\n         let addr = Ipv4(127, 0, 0, 1, 2929);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { Scheduler::borrow_local_io() };\n-            let mut stream = io.connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = io.connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n         };\n \n         let server_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { Scheduler::borrow_local_io() };\n-            let mut listener = io.bind(addr).unwrap();\n-            let mut stream = listener.listen().unwrap();\n-            let mut buf = [0, .. 2048];\n-            let nread = stream.read(buf).unwrap();\n-            assert!(nread == 8);\n-            for uint::range(0, nread) |i| {\n-                rtdebug!(\"%u\", buf[i] as uint);\n-                assert!(buf[i] == i as u8);\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut listener = io.bind(addr).unwrap();\n+                let mut stream = listener.listen().unwrap();\n+                let mut buf = [0, .. 2048];\n+                let nread = stream.read(buf).unwrap();\n+                assert!(nread == 8);\n+                for uint::range(0, nread) |i| {\n+                    rtdebug!(\"%u\", buf[i] as uint);\n+                    assert!(buf[i] == i as u8);\n+                }\n+                stream.close();\n+                listener.close();\n             }\n-            stream.close();\n-            listener.close();\n         };\n \n         // Start the server first so it listens before the client connects\n@@ -391,7 +396,7 @@ fn test_read_and_block() {\n         let addr = Ipv4(127, 0, 0, 1, 2930);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { Scheduler::borrow_local_io() };\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -401,7 +406,7 @@ fn test_read_and_block() {\n         };\n \n         let server_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { Scheduler::borrow_local_io() };\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut listener = io.bind(addr).unwrap();\n             let mut stream = listener.listen().unwrap();\n             let mut buf = [0, .. 2048];\n@@ -419,13 +424,13 @@ fn test_read_and_block() {\n                 }\n                 reads += 1;\n \n-                let scheduler = Scheduler::take_local();\n+                let scheduler = local_sched::take();\n                 // Yield to the other task in hopes that it\n                 // will trigger a read callback while we are\n                 // not ready for it\n                 do scheduler.deschedule_running_task_and_then |task| {\n                     let task = Cell(task);\n-                    do Scheduler::borrow_local |scheduler| {\n+                    do local_sched::borrow |scheduler| {\n                         scheduler.task_queue.push_back(task.take());\n                     }\n                 }\n@@ -452,7 +457,7 @@ fn test_read_read_read() {\n         let addr = Ipv4(127, 0, 0, 1, 2931);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            let io = unsafe { Scheduler::borrow_local_io() };\n+            let io = unsafe { local_sched::unsafe_borrow_io() };\n             let mut stream = io.connect(addr).unwrap();\n             let mut buf = [0, .. 2048];\n             let mut total_bytes_read = 0;"}, {"sha": "a6c03638713ed580f7fe9a342597de5e14253552", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -175,7 +175,7 @@ pub struct TaskOpts {\n // FIXME (#3724): Replace the 'consumed' bit with move mode on self\n pub struct TaskBuilder {\n     opts: TaskOpts,\n-    gen_body: @fn(v: ~fn()) -> ~fn(),\n+    mut gen_body: Option<~fn(v: ~fn()) -> ~fn()>,\n     can_not_copy: Option<util::NonCopyable>,\n     mut consumed: bool,\n }\n@@ -188,7 +188,7 @@ pub struct TaskBuilder {\n pub fn task() -> TaskBuilder {\n     TaskBuilder {\n         opts: default_task_opts(),\n-        gen_body: |body| body, // Identity function\n+        gen_body: None,\n         can_not_copy: None,\n         mut consumed: false,\n     }\n@@ -201,6 +201,7 @@ priv impl TaskBuilder {\n             fail!(~\"Cannot copy a task_builder\"); // Fake move mode on self\n         }\n         self.consumed = true;\n+        let gen_body = replace(&mut self.gen_body, None);\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n             opts: TaskOpts {\n@@ -209,7 +210,7 @@ priv impl TaskBuilder {\n                 notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n-            gen_body: self.gen_body,\n+            gen_body: gen_body,\n             can_not_copy: None,\n             consumed: false\n         }\n@@ -341,8 +342,23 @@ pub impl TaskBuilder {\n      * generator by applying the task body which results from the\n      * existing body generator to the new body generator.\n      */\n-    fn add_wrapper(&self, wrapper: @fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n-        let prev_gen_body = self.gen_body;\n+    fn add_wrapper(&self, wrapper: ~fn(v: ~fn()) -> ~fn()) -> TaskBuilder {\n+        let prev_gen_body = replace(&mut self.gen_body, None);\n+        let prev_gen_body = match prev_gen_body {\n+            Some(gen) => gen,\n+            None => {\n+                let f: ~fn(~fn()) -> ~fn() = |body| body;\n+                f\n+            }\n+        };\n+        let prev_gen_body = Cell(prev_gen_body);\n+        let next_gen_body = {\n+            let f: ~fn(~fn()) -> ~fn() = |body| {\n+                let prev_gen_body = prev_gen_body.take();\n+                wrapper(prev_gen_body(body))\n+            };\n+            f\n+        };\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n             opts: TaskOpts {\n@@ -351,7 +367,7 @@ pub impl TaskBuilder {\n                 notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n-            gen_body: |body| { wrapper(prev_gen_body(body)) },\n+            gen_body: Some(next_gen_body),\n             can_not_copy: None,\n             .. self.consume()\n         }\n@@ -370,6 +386,7 @@ pub impl TaskBuilder {\n      * must be greater than zero.\n      */\n     fn spawn(&self, f: ~fn()) {\n+        let gen_body = replace(&mut self.gen_body, None);\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n         let opts = TaskOpts {\n@@ -378,7 +395,15 @@ pub impl TaskBuilder {\n             notify_chan: notify_chan,\n             sched: x.opts.sched\n         };\n-        spawn::spawn_raw(opts, (x.gen_body)(f));\n+        let f = match gen_body {\n+            Some(gen) => {\n+                gen(f)\n+            }\n+            None => {\n+                f\n+            }\n+        };\n+        spawn::spawn_raw(opts, f);\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A:Owned>(&self, arg: A, f: ~fn(v: A)) {\n@@ -1201,3 +1226,12 @@ fn test_spawn_thread_on_demand() {\n \n     port.recv();\n }\n+\n+#[test]\n+fn test_simple_newsched_spawn() {\n+    use rt::run_in_newsched_task;\n+\n+    do run_in_newsched_task {\n+        spawn(||())\n+    }\n+}"}, {"sha": "118c4cc23125b35654ae2f017109bad3d5f03644", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -531,6 +531,34 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n }\n \n pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n+    use rt::*;\n+\n+    match context() {\n+        OldTaskContext => {\n+            spawn_raw_oldsched(opts, f)\n+        }\n+        TaskContext => {\n+            spawn_raw_newsched(opts, f)\n+        }\n+        SchedulerContext => {\n+            fail!(~\"can't spawn from scheduler context\")\n+        }\n+        GlobalContext => {\n+            fail!(~\"can't spawn from global context\")\n+        }\n+    }\n+}\n+\n+fn spawn_raw_newsched(opts: TaskOpts, f: ~fn()) {\n+    use rt::sched::*;\n+\n+    let mut sched = local_sched::take();\n+    let task = ~Task::new(&mut sched.stack_pool, f);\n+    sched.schedule_new_task(task);\n+}\n+\n+fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n+\n     let (child_tg, ancestors, is_main) =\n         gen_child_taskgroup(opts.linked, opts.supervised);\n "}, {"sha": "a0db6f64f69fcd349122d9321df5b17ecb4b9284", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -539,6 +539,11 @@ rust_get_task() {\n     return rust_get_current_task();\n }\n \n+extern \"C\" rust_task *\n+rust_try_get_task() {\n+    return rust_try_get_current_task();\n+}\n+\n extern \"C\" CDECL stk_seg *\n rust_get_stack_segment() {\n     return rust_get_current_task()->stk;"}, {"sha": "5a556ed2107dfdc45a82b28ff219ce164b2a2ce5", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6510fd92544467a03df93b5124644976aa79f964/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/6510fd92544467a03df93b5124644976aa79f964/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=6510fd92544467a03df93b5124644976aa79f964", "patch": "@@ -47,6 +47,7 @@ rust_env_pairs\n rust_task_yield\n rust_task_is_unwinding\n rust_get_task\n+rust_try_get_task\n rust_get_stack_segment\n rust_log_str\n start_task"}]}