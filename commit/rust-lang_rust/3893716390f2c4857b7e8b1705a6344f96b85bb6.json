{"sha": "3893716390f2c4857b7e8b1705a6344f96b85bb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OTM3MTYzOTBmMmM0ODU3YjdlOGIxNzA1YTYzNDRmOTZiODViYjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-14T00:26:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:53Z"}, "message": "Finalize the green::Pool type\n\nThe scheduler pool now has a much more simplified interface. There is now a\nclear distinction between creating the pool and then interacting the pool. When\na pool is created, all schedulers are not active, and only later if a spawn is\ndone does activity occur.\n\nThere are four operations that you can do on a pool:\n\n1. Create a new pool. The only argument to this function is the configuration\n   for the scheduler pool. Currently the only configuration parameter is the\n   number of threads to initially spawn.\n\n2. Spawn a task into this pool. This takes a procedure and task configuration\n   options and spawns a new task into the pool of schedulers.\n\n3. Spawn a new scheduler into the pool. This will return a handle on which to\n   communicate with the scheduler in order to do something like a pinned task.\n\n4. Shut down the scheduler pool. This will consume the scheduler pool, request\n   all of the schedulers to shut down, and then wait on all the scheduler\n   threads. Currently this will block the invoking OS thread, but I plan on\n   making 'Thread::join' not a thread-blocking call.\n\nThese operations can be used to encode all current usage of M:N schedulers, as\nwell as providing a simple interface through which a pool can be modified. There\nis currently no way to remove a scheduler from a pool of scheduler, as there's\nno way to guarantee that a scheduler has exited. This may be added in the\nfuture, however (as necessary).", "tree": {"sha": "1a01099d27673c9906267ce82c024b33c61c1f13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a01099d27673c9906267ce82c024b33c61c1f13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3893716390f2c4857b7e8b1705a6344f96b85bb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3893716390f2c4857b7e8b1705a6344f96b85bb6", "html_url": "https://github.com/rust-lang/rust/commit/3893716390f2c4857b7e8b1705a6344f96b85bb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3893716390f2c4857b7e8b1705a6344f96b85bb6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53", "html_url": "https://github.com/rust-lang/rust/commit/afd4e2ad8dc4112b99c8d30996ff0bb5b0516b53"}], "stats": {"total": 435, "additions": 185, "deletions": 250}, "files": [{"sha": "f4903ea38d29a9b4cb78b67bfb6211c19a48099b", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 105, "deletions": 171, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -39,13 +39,15 @@ use std::rt::task::Task;\n use std::rt::rtio;\n use std::sync::deque;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n-use std::task::TaskResult;\n+use std::task::TaskOpts;\n use std::vec;\n use std::util;\n+use stdtask = std::rt::task;\n \n-use sched::{Shutdown, Scheduler, SchedHandle};\n+use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n use sleeper_list::SleeperList;\n-use task::{GreenTask, HomeSched};\n+use stack::StackPool;\n+use task::GreenTask;\n \n mod macros;\n \n@@ -103,234 +105,166 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n /// This function will not return until all schedulers in the associated pool\n /// have returned.\n pub fn run(main: proc()) -> int {\n-    let config = Config {\n-        shutdown_after_main_exits: true,\n-        ..Config::new()\n-    };\n-    Pool::spawn(config, main).wait();\n+    let mut pool = Pool::new(Config::new());\n+    pool.spawn(TaskOpts::new(), main);\n+    unsafe { stdtask::wait_for_completion(); }\n+    pool.shutdown();\n     os::get_exit_status()\n }\n \n /// Configuration of how an M:N pool of schedulers is spawned.\n pub struct Config {\n-    /// If this flag is set, then when schedulers are spawned via the `start`\n-    /// and `run` functions the thread invoking `start` and `run` will have a\n-    /// scheduler spawned on it. This scheduler will be \"special\" in that the\n-    /// main task will be pinned to the scheduler and it will not participate in\n-    /// work stealing.\n-    ///\n-    /// If the `spawn` function is used to create a pool of schedulers, then\n-    /// this option has no effect.\n-    use_main_thread: bool,\n-\n     /// The number of schedulers (OS threads) to spawn into this M:N pool.\n     threads: uint,\n-\n-    /// When the main function exits, this flag will dictate whether a shutdown\n-    /// is requested of all schedulers. If this flag is `true`, this means that\n-    /// schedulers will shut down as soon as possible after the main task exits\n-    /// (but some may stay alive longer for things like I/O or other tasks).\n-    ///\n-    /// If this flag is `false`, then no action is taken when the `main` task\n-    /// exits. The scheduler pool is then shut down via the `wait()` function.\n-    shutdown_after_main_exits: bool,\n }\n \n impl Config {\n     /// Returns the default configuration, as determined the the environment\n     /// variables of this process.\n     pub fn new() -> Config {\n         Config {\n-            use_main_thread: false,\n             threads: rt::default_sched_threads(),\n-            shutdown_after_main_exits: false,\n         }\n     }\n }\n \n /// A structure representing a handle to a pool of schedulers. This handle is\n /// used to keep the pool alive and also reap the status from the pool.\n pub struct Pool {\n+    priv id: uint,\n     priv threads: ~[Thread<()>],\n-    priv handles: Option<~[SchedHandle]>,\n+    priv handles: ~[SchedHandle],\n+    priv stealers: ~[deque::Stealer<~task::GreenTask>],\n+    priv next_friend: uint,\n+    priv stack_pool: StackPool,\n+    priv deque_pool: deque::BufferPool<~task::GreenTask>,\n+    priv sleepers: SleeperList,\n }\n \n impl Pool {\n     /// Execute the main function in a pool of M:N schedulers.\n     ///\n     /// This will configure the pool according to the `config` parameter, and\n     /// initially run `main` inside the pool of schedulers.\n-    pub fn spawn(config: Config, main: proc()) -> Pool {\n+    pub fn new(config: Config) -> Pool {\n         static mut POOL_ID: AtomicUint = INIT_ATOMIC_UINT;\n \n-        let Config {\n-            threads: nscheds,\n-            use_main_thread: use_main_sched,\n-            shutdown_after_main_exits\n-        } = config;\n-\n-        let mut main = Some(main);\n-        let pool_id = unsafe { POOL_ID.fetch_add(1, SeqCst) };\n+        let Config { threads: nscheds } = config;\n+        assert!(nscheds > 0);\n \n-        // The shared list of sleeping schedulers.\n-        let sleepers = SleeperList::new();\n+        // The pool of schedulers that will be returned from this function\n+        let mut pool = Pool {\n+            threads: ~[],\n+            handles: ~[],\n+            stealers: ~[],\n+            id: unsafe { POOL_ID.fetch_add(1, SeqCst) },\n+            sleepers: SleeperList::new(),\n+            stack_pool: StackPool::new(),\n+            deque_pool: deque::BufferPool::new(),\n+            next_friend: 0,\n+        };\n \n         // Create a work queue for each scheduler, ntimes. Create an extra\n         // for the main thread if that flag is set. We won't steal from it.\n-        let mut pool = deque::BufferPool::new();\n-        let arr = vec::from_fn(nscheds, |_| pool.deque());\n+        let arr = vec::from_fn(nscheds, |_| pool.deque_pool.deque());\n         let (workers, stealers) = vec::unzip(arr.move_iter());\n+        pool.stealers = stealers;\n \n-        // The schedulers.\n-        let mut scheds = ~[];\n-        // Handles to the schedulers. When the main task ends these will be\n-        // sent the Shutdown message to terminate the schedulers.\n-        let mut handles = ~[];\n-\n+        // Now that we've got all our work queues, create one scheduler per\n+        // queue, spawn the scheduler into a thread, and be sure to keep a\n+        // handle to the scheduler and the thread to keep them alive.\n         for worker in workers.move_iter() {\n             rtdebug!(\"inserting a regular scheduler\");\n \n-            // Every scheduler is driven by an I/O event loop.\n-            let loop_ = new_event_loop();\n-            let mut sched = ~Scheduler::new(pool_id,\n-                                            loop_,\n+            let mut sched = ~Scheduler::new(pool.id,\n+                                            new_event_loop(),\n                                             worker,\n-                                            stealers.clone(),\n-                                            sleepers.clone());\n-            let handle = sched.make_handle();\n-\n-            scheds.push(sched);\n-            handles.push(handle);\n-        }\n-\n-        // If we need a main-thread task then create a main thread scheduler\n-        // that will reject any task that isn't pinned to it\n-        let main_sched = if use_main_sched {\n-\n-            // Create a friend handle.\n-            let mut friend_sched = scheds.pop();\n-            let friend_handle = friend_sched.make_handle();\n-            scheds.push(friend_sched);\n-\n-            // This scheduler needs a queue that isn't part of the stealee\n-            // set.\n-            let (worker, _) = pool.deque();\n-\n-            let main_loop = new_event_loop();\n-            let mut main_sched = ~Scheduler::new_special(pool_id,\n-                                                         main_loop,\n-                                                         worker,\n-                                                         stealers.clone(),\n-                                                         sleepers.clone(),\n-                                                         false,\n-                                                         Some(friend_handle));\n-            let mut main_handle = main_sched.make_handle();\n-            // Allow the scheduler to exit when the main task exits.\n-            // Note: sending the shutdown message also prevents the scheduler\n-            // from pushing itself to the sleeper list, which is used for\n-            // waking up schedulers for work stealing; since this is a\n-            // non-work-stealing scheduler it should not be adding itself\n-            // to the list.\n-            main_handle.send(Shutdown);\n-            Some(main_sched)\n-        } else {\n-            None\n-        };\n-\n-        // The pool of schedulers that will be returned from this function\n-        let mut pool = Pool { threads: ~[], handles: None };\n-\n-        // When the main task exits, after all the tasks in the main\n-        // task tree, shut down the schedulers and set the exit code.\n-        let mut on_exit = if shutdown_after_main_exits {\n-            let handles = handles;\n-            Some(proc(exit_success: TaskResult) {\n-                let mut handles = handles;\n-                for handle in handles.mut_iter() {\n-                    handle.send(Shutdown);\n-                }\n-                if exit_success.is_err() {\n-                    os::set_exit_status(rt::DEFAULT_ERROR_CODE);\n-                }\n-            })\n-        } else {\n-            pool.handles = Some(handles);\n-            None\n-        };\n-\n-        if !use_main_sched {\n-\n-            // In the case where we do not use a main_thread scheduler we\n-            // run the main task in one of our threads.\n-\n-            let mut main = GreenTask::new(&mut scheds[0].stack_pool, None,\n-                                          main.take_unwrap());\n-            let mut main_task = ~Task::new();\n-            main_task.name = Some(SendStrStatic(\"<main>\"));\n-            main_task.death.on_exit = on_exit.take();\n-            main.put_task(main_task);\n-\n-            let sched = scheds.pop();\n-            let main = main;\n-            let thread = do Thread::start {\n-                sched.bootstrap(main);\n-            };\n-            pool.threads.push(thread);\n-        }\n-\n-        // Run each remaining scheduler in a thread.\n-        for sched in scheds.move_rev_iter() {\n-            rtdebug!(\"creating regular schedulers\");\n-            let thread = do Thread::start {\n+                                            pool.stealers.clone(),\n+                                            pool.sleepers.clone());\n+            pool.handles.push(sched.make_handle());\n+            let sched = sched;\n+            pool.threads.push(do Thread::start {\n                 let mut sched = sched;\n                 let mut task = do GreenTask::new(&mut sched.stack_pool, None) {\n                     rtdebug!(\"boostraping a non-primary scheduler\");\n                 };\n                 task.put_task(~Task::new());\n                 sched.bootstrap(task);\n-            };\n-            pool.threads.push(thread);\n+            });\n         }\n \n-        // If we do have a main thread scheduler, run it now.\n+        return pool;\n+    }\n \n-        if use_main_sched {\n-            rtdebug!(\"about to create the main scheduler task\");\n+    pub fn shutdown(mut self) {\n+        self.stealers = ~[];\n \n-            let mut main_sched = main_sched.unwrap();\n+        for mut handle in util::replace(&mut self.handles, ~[]).move_iter() {\n+            handle.send(Shutdown);\n+        }\n+        for thread in util::replace(&mut self.threads, ~[]).move_iter() {\n+            thread.join();\n+        }\n+    }\n \n-            let home = HomeSched(main_sched.make_handle());\n-            let mut main = GreenTask::new_homed(&mut main_sched.stack_pool, None,\n-                                                home, main.take_unwrap());\n-            let mut main_task = ~Task::new();\n-            main_task.name = Some(SendStrStatic(\"<main>\"));\n-            main_task.death.on_exit = on_exit.take();\n-            main.put_task(main_task);\n-            rtdebug!(\"bootstrapping main_task\");\n+    pub fn spawn(&mut self, opts: TaskOpts, f: proc()) {\n+        let task = GreenTask::configure(&mut self.stack_pool, opts, f);\n \n-            main_sched.bootstrap(main);\n+        // Figure out someone to send this task to\n+        let idx = self.next_friend;\n+        self.next_friend += 1;\n+        if self.next_friend >= self.handles.len() {\n+            self.next_friend = 0;\n         }\n \n-        return pool;\n+        // Jettison the task away!\n+        self.handles[idx].send(TaskFromFriend(task));\n     }\n \n-    /// Waits for the pool of schedulers to exit. If the pool was spawned to\n-    /// shutdown after the main task exits, this will simply wait for all the\n-    /// scheudlers to exit. If the pool was not spawned like that, this function\n-    /// will trigger shutdown of all the active schedulers. The schedulers will\n-    /// exit once all tasks in this pool of schedulers has exited.\n-    pub fn wait(&mut self) {\n-        match self.handles.take() {\n-            Some(mut handles) => {\n-                for handle in handles.mut_iter() {\n-                    handle.send(Shutdown);\n-                }\n-            }\n-            None => {}\n+    /// Spawns a new scheduler into this M:N pool. A handle is returned to the\n+    /// scheduler for use. The scheduler will not exit as long as this handle is\n+    /// active.\n+    ///\n+    /// The scheduler spawned will participate in work stealing with all of the\n+    /// other schedulers currently in the scheduler pool.\n+    pub fn spawn_sched(&mut self) -> SchedHandle {\n+        let (worker, stealer) = self.deque_pool.deque();\n+        self.stealers.push(stealer.clone());\n+\n+        // Tell all existing schedulers about this new scheduler so they can all\n+        // steal work from it\n+        for handle in self.handles.mut_iter() {\n+            handle.send(NewNeighbor(stealer.clone()));\n         }\n \n-        for thread in util::replace(&mut self.threads, ~[]).move_iter() {\n-            thread.join();\n+        // Create the new scheduler, using the same sleeper list as all the\n+        // other schedulers as well as having a stealer handle to all other\n+        // schedulers.\n+        let mut sched = ~Scheduler::new(self.id,\n+                                        new_event_loop(),\n+                                        worker,\n+                                        self.stealers.clone(),\n+                                        self.sleepers.clone());\n+        let ret = sched.make_handle();\n+        self.handles.push(sched.make_handle());\n+        let sched = sched;\n+        self.threads.push(do Thread::start {\n+            let mut sched = sched;\n+            let mut task = do GreenTask::new(&mut sched.stack_pool, None) {\n+                rtdebug!(\"boostraping a non-primary scheduler\");\n+            };\n+            task.put_task(~Task::new());\n+            sched.bootstrap(task);\n+        });\n+\n+        return ret;\n+    }\n+}\n+\n+impl Drop for Pool {\n+    fn drop(&mut self) {\n+        if self.threads.len() > 0 {\n+            fail!(\"dropping a M:N scheduler pool that wasn't shut down\");\n         }\n     }\n }"}, {"sha": "e349ae1e601c42f583c4afcb36f93e0077ba13ea", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -393,6 +393,10 @@ impl Scheduler {\n                 stask.put_with_sched(self);\n                 return None;\n             }\n+            Some(NewNeighbor(neighbor)) => {\n+                self.work_queues.push(neighbor);\n+                return Some((self, stask));\n+            }\n             None => {\n                 return Some((self, stask));\n             }\n@@ -831,6 +835,7 @@ type SchedulingFn = extern \"Rust\" fn (~Scheduler, ~GreenTask, ~GreenTask);\n pub enum SchedMessage {\n     Wake,\n     Shutdown,\n+    NewNeighbor(deque::Stealer<~GreenTask>),\n     PinnedTask(~GreenTask),\n     TaskFromFriend(~GreenTask),\n     RunOnce(~GreenTask),"}, {"sha": "e07d7f2413fb2f5df03252f8e2518dc166f0236b", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 31, "deletions": 17, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -55,12 +55,15 @@ pub enum Home {\n }\n \n impl GreenTask {\n+    /// Creates a new green task which is not homed to any particular scheduler\n+    /// and will not have any contained Task structure.\n     pub fn new(stack_pool: &mut StackPool,\n                stack_size: Option<uint>,\n                start: proc()) -> ~GreenTask {\n         GreenTask::new_homed(stack_pool, stack_size, AnySched, start)\n     }\n \n+    /// Creates a new task (like `new`), but specifies the home for new task.\n     pub fn new_homed(stack_pool: &mut StackPool,\n                      stack_size: Option<uint>,\n                      home: Home,\n@@ -71,6 +74,8 @@ impl GreenTask {\n         return ops;\n     }\n \n+    /// Creates a new green task with the specified coroutine and type, this is\n+    /// useful when creating scheduler tasks.\n     pub fn new_typed(coroutine: Option<Coroutine>,\n                      task_type: TaskType) -> ~GreenTask {\n         ~GreenTask {\n@@ -84,6 +89,31 @@ impl GreenTask {\n         }\n     }\n \n+    /// Creates a new green task with the given configuration options for the\n+    /// contained Task object. The given stack pool is also used to allocate a\n+    /// new stack for this task.\n+    pub fn configure(pool: &mut StackPool,\n+                     opts: TaskOpts,\n+                     f: proc()) -> ~GreenTask {\n+        let TaskOpts {\n+            watched: _watched,\n+            notify_chan, name, stack_size\n+        } = opts;\n+\n+        let mut green = GreenTask::new(pool, stack_size, f);\n+        let mut task = ~Task::new();\n+        task.name = name;\n+        match notify_chan {\n+            Some(chan) => {\n+                let on_exit = proc(task_result) { chan.send(task_result) };\n+                task.death.on_exit = Some(on_exit);\n+            }\n+            None => {}\n+        }\n+        green.put_task(task);\n+        return green;\n+    }\n+\n     /// Just like the `maybe_take_runtime` function, this function should *not*\n     /// exist. Usage of this function is _strongly_ discouraged. This is an\n     /// absolute last resort necessary for converting a libstd task to a green\n@@ -367,30 +397,14 @@ impl Runtime for GreenTask {\n     fn spawn_sibling(mut ~self, cur_task: ~Task, opts: TaskOpts, f: proc()) {\n         self.put_task(cur_task);\n \n-        let TaskOpts {\n-            watched: _watched,\n-            notify_chan, name, stack_size\n-        } = opts;\n-\n         // Spawns a task into the current scheduler. We allocate the new task's\n         // stack from the scheduler's stack pool, and then configure it\n         // accordingly to `opts`. Afterwards we bootstrap it immediately by\n         // switching to it.\n         //\n         // Upon returning, our task is back in TLS and we're good to return.\n         let mut sched = self.sched.take_unwrap();\n-        let mut sibling = GreenTask::new(&mut sched.stack_pool, stack_size, f);\n-        let mut sibling_task = ~Task::new();\n-        sibling_task.name = name;\n-        match notify_chan {\n-            Some(chan) => {\n-                let on_exit = proc(task_result) { chan.send(task_result) };\n-                sibling_task.death.on_exit = Some(on_exit);\n-            }\n-            None => {}\n-        }\n-\n-        sibling.task = Some(sibling_task);\n+        let sibling = GreenTask::configure(&mut sched.stack_pool, opts, f);\n         sched.run_task(self, sibling)\n     }\n "}, {"sha": "b97d9127277f38d840c41fd85c5d77b9e45de1e7", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -32,6 +32,7 @@\n \n use std::os;\n use std::rt;\n+use stdtask = std::rt::task;\n \n pub mod io;\n pub mod task;\n@@ -81,7 +82,9 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n pub fn run(main: proc()) -> int {\n     // Create a task, run the procedure in it, and then wait for everything.\n     task::run(task::new(), main);\n-    task::wait_for_completion();\n+\n+    // Block this OS task waiting for everything to finish.\n+    unsafe { stdtask::wait_for_completion() }\n \n     os::get_exit_status()\n }"}, {"sha": "1aa32bc8a267ba6291230e61e647dc32cba95cb4", "filename": "src/libnative/task.rs", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -21,49 +21,13 @@ use std::rt::rtio;\n use std::rt::task::{Task, BlockedTask};\n use std::rt::thread::Thread;\n use std::rt;\n-use std::sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n-use std::task::{TaskOpts, default_task_opts};\n-use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+use std::task::TaskOpts;\n+use std::unstable::mutex::Mutex;\n use std::unstable::stack;\n \n use io;\n use task;\n \n-static mut THREAD_CNT: AtomicUint = INIT_ATOMIC_UINT;\n-static mut LOCK: Mutex = MUTEX_INIT;\n-\n-/// Waits for all spawned threads to finish completion. This should only be used\n-/// by the main task in order to wait for all other tasks to terminate.\n-///\n-/// This mirrors the same semantics as the green scheduling model.\n-pub fn wait_for_completion() {\n-    static mut someone_waited: bool = false;\n-\n-    unsafe {\n-        LOCK.lock();\n-        assert!(!someone_waited);\n-        someone_waited = true;\n-        while THREAD_CNT.load(SeqCst) > 0 {\n-            LOCK.wait();\n-        }\n-        LOCK.unlock();\n-        LOCK.destroy();\n-    }\n-\n-}\n-\n-// Signal that a thread has finished execution, possibly waking up a blocker\n-// waiting for all threads to have finished.\n-fn signal_done() {\n-    unsafe {\n-        LOCK.lock();\n-        if THREAD_CNT.fetch_sub(1, SeqCst) == 1 {\n-            LOCK.signal();\n-        }\n-        LOCK.unlock();\n-    }\n-}\n-\n /// Creates a new Task which is ready to execute as a 1:1 task.\n pub fn new() -> ~Task {\n     let mut task = ~Task::new();\n@@ -75,15 +39,12 @@ pub fn new() -> ~Task {\n \n /// Spawns a function with the default configuration\n pub fn spawn(f: proc()) {\n-    spawn_opts(default_task_opts(), f)\n+    spawn_opts(TaskOpts::new(), f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n-    // must happen before the spawn, no need to synchronize with a lock.\n-    unsafe { THREAD_CNT.fetch_add(1, SeqCst); }\n-\n     let TaskOpts {\n         watched: _watched,\n         notify_chan, name, stack_size\n@@ -117,7 +78,6 @@ pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n         }\n \n         run(task, f);\n-        signal_done();\n     })\n }\n \n@@ -290,7 +250,7 @@ mod tests {\n \n     #[test]\n     fn smoke_opts() {\n-        let mut opts = task::default_task_opts();\n+        let mut opts = TaskOpts::new();\n         opts.name = Some(SendStrStatic(\"test\"));\n         opts.stack_size = Some(20 * 4096);\n         let (p, c) = Chan::new();\n@@ -301,7 +261,7 @@ mod tests {\n \n     #[test]\n     fn smoke_opts_fail() {\n-        let mut opts = task::default_task_opts();\n+        let mut opts = TaskOpts::new();\n         let (p, c) = Chan::new();\n         opts.notify_chan = Some(c);\n         spawn_opts(opts, proc() { fail!() });"}, {"sha": "91e285b1061edf5a94f2e6b240477d990b747889", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -33,12 +33,16 @@ use rt::rtio::LocalIo;\n use rt::unwind::Unwinder;\n use send_str::SendStr;\n use sync::arc::UnsafeArc;\n-use sync::atomics::{AtomicUint, SeqCst};\n+use sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n use task::{TaskResult, TaskOpts};\n use unstable::finally::Finally;\n+use unstable::mutex::{Mutex, MUTEX_INIT};\n \n #[cfg(stage0)] pub use rt::unwind::begin_unwind;\n \n+static mut TASK_COUNT: AtomicUint = INIT_ATOMIC_UINT;\n+static mut TASK_LOCK: Mutex = MUTEX_INIT;\n+\n // The Task struct represents all state associated with a rust\n // task. There are at this point two primary \"subtypes\" of task,\n // however instead of using a subtype we just have a \"task_type\" field\n@@ -117,6 +121,7 @@ impl Task {\n             *cast::transmute::<&~Task, &*mut Task>(&self)\n         };\n         Local::put(self);\n+        unsafe { TASK_COUNT.fetch_add(1, SeqCst); }\n \n         // The only try/catch block in the world. Attempt to run the task's\n         // client-specified code and catch any failures.\n@@ -180,6 +185,11 @@ impl Task {\n         unsafe {\n             let me: *mut Task = Local::unsafe_borrow();\n             (*me).death.collect_failure((*me).unwinder.result());\n+            if TASK_COUNT.fetch_sub(1, SeqCst) == 1 {\n+                TASK_LOCK.lock();\n+                TASK_LOCK.signal();\n+                TASK_LOCK.unlock();\n+            }\n         }\n         let mut me: ~Task = Local::take();\n         me.destroyed = true;\n@@ -376,6 +386,14 @@ impl Drop for Death {\n     }\n }\n \n+pub unsafe fn wait_for_completion() {\n+    TASK_LOCK.lock();\n+    while TASK_COUNT.load(SeqCst) > 0 {\n+        TASK_LOCK.wait();\n+    }\n+    TASK_LOCK.unlock();\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "836390fb41613bc4997b2f3deccff756334c7a9b", "filename": "src/libstd/task.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3893716390f2c4857b7e8b1705a6344f96b85bb6/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=3893716390f2c4857b7e8b1705a6344f96b85bb6", "patch": "@@ -131,7 +131,7 @@ pub struct TaskBuilder {\n  */\n pub fn task() -> TaskBuilder {\n     TaskBuilder {\n-        opts: default_task_opts(),\n+        opts: TaskOpts::new(),\n         gen_body: None,\n         can_not_copy: None,\n     }\n@@ -301,22 +301,23 @@ impl TaskBuilder {\n     }\n }\n \n-\n /* Task construction */\n \n-pub fn default_task_opts() -> TaskOpts {\n-    /*!\n-     * The default task options\n-     *\n-     * By default all tasks are supervised by their parent, are spawned\n-     * into the same scheduler, and do not post lifecycle notifications.\n-     */\n-\n-    TaskOpts {\n-        watched: true,\n-        notify_chan: None,\n-        name: None,\n-        stack_size: None\n+impl TaskOpts {\n+    pub fn new() -> TaskOpts {\n+        /*!\n+         * The default task options\n+         *\n+         * By default all tasks are supervised by their parent, are spawned\n+         * into the same scheduler, and do not post lifecycle notifications.\n+         */\n+\n+        TaskOpts {\n+            watched: true,\n+            notify_chan: None,\n+            name: None,\n+            stack_size: None\n+        }\n     }\n }\n "}]}