{"sha": "26ecec4e123781c6e99e92cf42ce585e33a861ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZWNlYzRlMTIzNzgxYzZlOTllOTJjZjQyY2U1ODVlMzNhODYxZWY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-16T21:51:32Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-16T21:51:32Z"}, "message": "Update frame logic to be compatible with SysV x86 ABI. Improves diagnostics.", "tree": {"sha": "3da15ea6afe073b2b29e657749f9d53534030e4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3da15ea6afe073b2b29e657749f9d53534030e4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26ecec4e123781c6e99e92cf42ce585e33a861ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26ecec4e123781c6e99e92cf42ce585e33a861ef", "html_url": "https://github.com/rust-lang/rust/commit/26ecec4e123781c6e99e92cf42ce585e33a861ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26ecec4e123781c6e99e92cf42ce585e33a861ef/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44b051f34af7512e8b13a1dfaac03967989a0ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/44b051f34af7512e8b13a1dfaac03967989a0ca4", "html_url": "https://github.com/rust-lang/rust/commit/44b051f34af7512e8b13a1dfaac03967989a0ca4"}], "stats": {"total": 204, "additions": 127, "deletions": 77}, "files": [{"sha": "035d1f058d5349a24c2bc531327e97b874d791a2", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=26ecec4e123781c6e99e92cf42ce585e33a861ef", "patch": "@@ -189,6 +189,7 @@ type abi =\n     abi_tp_cell: Il.cell;\n     abi_implicit_args_sz: int64;\n     abi_frame_base_sz: int64;\n+    abi_callee_saves_sz: int64;\n     abi_frame_info_sz: int64;\n     abi_spill_slot: (Il.spill -> Il.mem);\n   }"}, {"sha": "5d02b2c22face574e8d456d76a379b1a54c7d57b", "filename": "src/boot/be/macho.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fbe%2Fmacho.ml", "raw_url": "https://github.com/rust-lang/rust/raw/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fbe%2Fmacho.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fmacho.ml?ref=26ecec4e123781c6e99e92cf42ce585e33a861ef", "patch": "@@ -987,7 +987,7 @@ let emit_file\n       Il.emit e (Il.umov edx_pointee (X86.ro X86.eax));\n       Il.emit e (Il.Push (X86.ro X86.eax));\n \n-      (* Calculte and store envp. *)\n+      (* Calculate and store envp. *)\n       Il.emit e (Il.binary Il.ADD\n                    (X86.rc X86.eax) (X86.ro X86.eax)\n                    (X86.imm (Asm.IMM 1L)));"}, {"sha": "30b49ed1610965efac0c5ab936fee16132227e99", "filename": "src/boot/be/x86.ml", "status": "modified", "additions": 83, "deletions": 49, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=26ecec4e123781c6e99e92cf42ce585e33a861ef", "patch": "@@ -199,8 +199,14 @@ let reg_str r =\n \n (* This is a basic ABI. You might need to customize it by platform. *)\n let (n_hardregs:int) = 6;;\n-let (n_callee_saves:int) = 4;;\n \n+(* Includes ebx, esi, edi; does *not* include ebp, which has ABI-specified\n+ * rules concerning its location and save/restore sequence.\n+ * \n+ * See http://refspecs.freestandards.org/elf/abi386-4.pdf\n+ * Page 36, Figure 3-15 and friends.\n+ *)\n+let (n_callee_saves:int) = 3;;\n \n let is_ty32 (ty:Il.scalar_ty) : bool =\n   match ty with\n@@ -553,52 +559,61 @@ let wordptr_n (reg:Il.reg) (i:int) : Il.cell =\n \n let get_element_ptr = Il.get_element_ptr word_bits reg_str ;;\n \n-let save_callee_saves (e:Il.emitter) : unit =\n+let establish_frame_base (e:Il.emitter) : unit =\n+    (* Establish i386-ABI-compliant frame base. *)\n     Il.emit e (Il.Push (ro ebp));\n+    Il.emit e (Il.umov (rc ebp) (ro esp));\n+;;\n+\n+let save_callee_saves (e:Il.emitter) : unit =\n     Il.emit e (Il.Push (ro edi));\n     Il.emit e (Il.Push (ro esi));\n     Il.emit e (Il.Push (ro ebx));\n ;;\n \n-\n let restore_callee_saves (e:Il.emitter) : unit =\n     Il.emit e (Il.Pop (rc ebx));\n     Il.emit e (Il.Pop (rc esi));\n     Il.emit e (Il.Pop (rc edi));\n+;;\n+\n+let leave_frame (e:Il.emitter) : unit =\n     Il.emit e (Il.Pop (rc ebp));\n ;;\n \n \n (* restores registers from the frame base without updating esp:\n- *   - sets ebp, edi, esi, ebx to stored values from frame base\n+ *   - restores the callee-saves: edi, esi, ebx\n+ *   - restores ebp to stored values from frame base\n  *   - sets `retpc' register to stored retpc from frame base\n  *   - sets `base' register to current fp\n  *)\n-let restore_frame_base (e:Il.emitter) (base:Il.reg) (retpc:Il.reg) : unit =\n+let restore_frame_regs (e:Il.emitter) (base:Il.reg) (retpc:Il.reg)\n+    : unit =\n   let emit = Il.emit e in\n   let mov dst src = emit (Il.umov dst src) in\n     mov (r base) (ro ebp);\n-    mov (rc ebx) (c (word_at base));\n-    mov (rc esi) (c (word_n base 1));\n-    mov (rc edi) (c (word_n base 2));\n-    mov (rc ebp) (c (word_n base 3));\n-    mov (r retpc) (c (word_n base 4));\n+    mov (rc ebx) (c (word_n base (-3)));\n+    mov (rc esi) (c (word_n base (-2)));\n+    mov (rc edi) (c (word_n base (-1)));\n+    mov (rc ebp) (c (word_at base));\n+    mov (r retpc) (c (word_n base 1));\n ;;\n \n \n (*\n  * Our arrangement on x86 is this:\n  *\n- *   *ebp+20+(4*N) = [argN   ]\n+ *   *ebp+8+(4*N)  = [argN   ]\n  *   ...\n- *   *ebp+28       = [arg2   ] = obj/closure ptr\n- *   *ebp+24       = [arg1   ] = task ptr\n- *   *ebp+20       = [arg0   ] = out ptr\n- *   *ebp+16       = [retpc  ]\n- *   *ebp+12       = [old_ebp]\n- *   *ebp+8        = [old_edi]\n- *   *ebp+4        = [old_esi]\n- *   *ebp          = [old_ebx]\n+ *   *ebp+16       = [arg2   ] = obj/closure ptr\n+ *   *ebp+12       = [arg1   ] = task ptr\n+ *   *ebp+8        = [arg0   ] = out ptr\n+ *   *ebp+4        = [retpc  ]\n+ *   *ebp          = [old_ebp]\n+ *   *ebp-4        = [old_edi]\n+ *   *ebp-8        = [old_esi]\n+ *   *ebp-12       = [old_ebx]\n  *\n  * For x86-cdecl:\n  *\n@@ -607,7 +622,7 @@ let restore_frame_base (e:Il.emitter) (base:Il.reg) (retpc:Il.reg) : unit =\n  *\n  *)\n \n-let frame_base_words = 5 (* eip,ebp,edi,esi,ebx *) ;;\n+let frame_base_words = 2 (* eip,ebp *) ;;\n let frame_base_sz = Int64.mul (Int64.of_int frame_base_words) word_sz;;\n \n let frame_info_words = 2 (* crate ptr, crate-rel frame info disp *) ;;\n@@ -616,6 +631,8 @@ let frame_info_sz = Int64.mul (Int64.of_int frame_info_words) word_sz;;\n let implicit_arg_words = 3 (* task ptr, out ptr, closure ptr *);;\n let implicit_args_sz = Int64.mul (Int64.of_int implicit_arg_words) word_sz;;\n \n+let callee_saves_sz = Int64.mul (Int64.of_int n_callee_saves) word_sz;;\n+\n let out_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words);;\n let task_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words+1);;\n let closure_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words+2);;\n@@ -625,7 +642,8 @@ let ty_param_n i =\n let spill_slot (i:Il.spill) : Il.mem =\n   let imm = (Asm.IMM\n                (Int64.neg\n-                  (Int64.add frame_info_sz\n+                  (Int64.add\n+                     (Int64.add frame_info_sz callee_saves_sz)\n                      (Int64.mul word_sz\n                         (Int64.of_int (i+1))))))\n   in\n@@ -664,6 +682,7 @@ let emit_c_call\n   let emit = Il.emit e in\n   let mov dst src = emit (Il.umov dst src) in\n   let imov dst src = emit (Il.imov dst src) in\n+  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n   let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n \n   (* rust calls get task as arg0  *)\n@@ -735,6 +754,7 @@ let emit_c_call\n           emit (Il.call ret fptr);\n           mov (rc esp) (c (word_n (h ebp) Abi.task_field_rust_sp));\n           mov (rc ebp) (ro esp);\n+          add (rc ebp) (immi callee_saves_sz);\n \n       | _ ->\n           emit (Il.call ret fptr);\n@@ -846,8 +866,10 @@ let crawl_stack_calling_glue\n \n     mark repeat_jmp_fix;\n \n-    mov (rc esi) (c (fp_n (-1)));       (* esi <- crate ptr             *)\n-    mov (rc edi) (c (fp_n (-2)));       (* edi <- frame glue functions. *)\n+    mov (rc esi)                        (* esi <- crate ptr             *)\n+      (c (fp_n ((-1) - n_callee_saves)));\n+    mov (rc edi)                        (* edi <- frame glue functions. *)\n+      (c (fp_n ((-2) - n_callee_saves)));\n     emit (Il.cmp (ro edi) (immi 0L));\n \n     emit\n@@ -874,7 +896,7 @@ let crawl_stack_calling_glue\n     pop (rc eax);\n \n     mark skip_jmp_fix;\n-    mov (rc edi) (c (fp_n 3));          (* load next fp (callee-saves[3]) *)\n+    mov (rc edi) (c (fp_n 0));          (* load next fp (fp[0])           *)\n     emit (Il.cmp (ro edi) (immi 0L));\n     emit (Il.jmp Il.JE\n             (codefix exit_jmp_fix));    (* if nonzero                     *)\n@@ -980,6 +1002,8 @@ let gc_glue\n       (c (edi_n Abi.task_field_rust_sp));\n \n     (* Mark pass. *)\n+\n+    push (ro ebp);\n     save_callee_saves e;\n     push (ro eax);\n     crawl_stack_calling_glue e Abi.frame_glue_fns_field_mark;\n@@ -1005,6 +1029,7 @@ let gc_glue\n \n     pop (rc eax);\n     restore_callee_saves e;\n+    pop (rc ebp);\n     Il.emit e Il.Ret;\n ;;\n \n@@ -1182,11 +1207,12 @@ let rec size_calculation_stack_highwater (size:size) : int =\n         + 1\n ;;\n \n+let minimal_call_sz = Int64.add frame_base_sz callee_saves_sz;;\n let boundary_sz =\n   (Asm.IMM\n      (Int64.add                   (* Extra non-frame room:           *)\n-        frame_base_sz             (* to safely enter the next frame, *)\n-        frame_base_sz))           (* and make a 'grow' upcall there. *)\n+        minimal_call_sz           (* to safely enter the next frame, *)\n+        minimal_call_sz))         (* and make a 'grow' upcall there. *)\n ;;\n \n let stack_growth_check\n@@ -1273,8 +1299,8 @@ let minimal_fn_prologue\n   let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n \n     (* See diagram and explanation in full_fn_prologue, below.    *)\n+    establish_frame_base e;\n     save_callee_saves e;\n-    mov (rc ebp) (ro esp);                 (* Establish frame base.  *)\n     sub (rc esp) (imm call_and_frame_sz);  (* Establish a frame.     *)\n     mov (rc edi) (ro esp);                 (* Zero the frame. *)\n     mov (rc ecx) (imm call_and_frame_sz);\n@@ -1329,9 +1355,9 @@ let full_fn_prologue\n    *  | ...           |\n    *  | caller arg 0  |\n    *  | retpc         | <-- sp we received, top of callee frame\n-   *  | callee save 1 |\n+   *  | callee save 1 | <-- ebp after frame-base setup\n    *  | ...           |\n-   *  | callee save N | <-- ebp and esp after saving callee-saves\n+   *  | callee save N | <-- esp after saving callee-saves\n    *  | ...           |\n    *  | callee frame  |\n    *  | + spill       |\n@@ -1344,19 +1370,20 @@ let full_fn_prologue\n    *  | next save N   | <-- bottom of region we must reserve\n    *  | ...           |\n    *\n-   * A \"frame base\" is the retpc and set of callee-saves.\n+   * A \"frame base\" is the retpc + ebp.\n    *\n-   * We need to reserve room for our frame *and* the next frame-base, because\n-   * we're going to be blindly entering the next frame-base (pushing eip and\n-   * callee-saves) before we perform the next check.\n+   * We need to reserve room for our frame *and* the next frame-base and\n+   * callee-saves, because we're going to be blindly entering the next\n+   * frame-base (pushing eip and callee-saves) before we perform the next\n+   * check.\n    *)\n \n     (* Already have room to save regs on entry. *)\n+    establish_frame_base e;\n     save_callee_saves e;\n \n     let restart_pc = e.Il.emit_pc in\n \n-      mov (rc ebp) (ro esp);             (* Establish frame base.     *)\n       mov (rc esi) (c task_ptr);         (* esi = task                *)\n       mov\n         (rc esi)\n@@ -1444,12 +1471,14 @@ let fn_prologue\n ;;\n \n let fn_epilogue (e:Il.emitter) : unit =\n-\n   (* Tear down existing frame. *)\n   let emit = Il.emit e in\n   let mov dst src = emit (Il.umov dst src) in\n+  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n+    sub (rc ebp) (immi callee_saves_sz);\n     mov (rc esp) (ro ebp);\n     restore_callee_saves e;\n+    leave_frame e;\n     emit Il.Ret;\n ;;\n \n@@ -1543,8 +1572,8 @@ let fn_tail_call\n     end;\n \n     (* edx <- ebp; restore ebp, edi, esi, ebx; ecx <- retpc *)\n-    annotate e \"tail call: restore callee-saves from frame base\";\n-    restore_frame_base e (h edx) (h ecx);\n+    annotate e \"tail call: restore registers from frame base\";\n+    restore_frame_regs e (h edx) (h ecx);\n     (* move edx past frame base and adjust for difference in call sizes *)\n     annotate e \"tail call: adjust temporary fp\";\n     binary Il.ADD (rc edx) (Int64.add frame_base_sz argsz_diff);\n@@ -1637,6 +1666,7 @@ let activate_glue (e:Il.emitter) : unit =\n   let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n \n     mov (rc edx) (c (sp_n 1));            (* edx <- task             *)\n+    establish_frame_base e;\n     save_callee_saves e;\n     mov\n       (edx_n Abi.task_field_runtime_sp)\n@@ -1690,10 +1720,11 @@ let activate_glue (e:Il.emitter) : unit =\n      *)\n \n     binary Il.ADD (edx_n Abi.task_field_rust_sp)\n-      (Int64.mul (Int64.of_int (n_callee_saves + 1)) word_sz);\n+      (Int64.mul (Int64.of_int (n_callee_saves + 2)) word_sz);\n \n     (**** IN TASK STACK ****)\n     restore_callee_saves e;\n+    leave_frame e;\n     emit Il.Ret;\n     (***********************)\n   ()\n@@ -1736,6 +1767,7 @@ let yield_glue (e:Il.emitter) : unit =\n     mov\n       (rc esp)\n       (c (edx_n Abi.task_field_rust_sp));    (* esp <- task->rust_sp    *)\n+    establish_frame_base e;\n     save_callee_saves e;\n     mov                                      (* task->rust_sp <- esp    *)\n       (edx_n Abi.task_field_rust_sp)\n@@ -1746,6 +1778,7 @@ let yield_glue (e:Il.emitter) : unit =\n \n     (**** IN C STACK ****)\n     restore_callee_saves e;\n+    leave_frame e;\n     emit Il.Ret;\n     (***********************)\n   ()\n@@ -1771,30 +1804,30 @@ let objfile_start\n   let mov dst src = emit (Il.umov dst src) in\n   let push_pos32 = push_pos32 e in\n     Il.emit_full e (Some start_fixup) Il.Dead;\n+    establish_frame_base e;\n     save_callee_saves e;\n-    mov (rc ebp) (ro esp);\n \n     (* If we're very lucky, the platform will have left us with\n      * something sensible in the startup stack like so:\n      * \n-     *   *ebp+24       = [arg1   ] = argv\n-     *   *ebp+20       = [arg0   ] = argc\n-     *   *ebp+16       = [retpc  ]\n-     *   *ebp+12       = [old_ebp]\n-     *   *ebp+8        = [old_edi]\n-     *   *ebp+4        = [old_esi]\n-     *   *ebp          = [old_ebx]\n+     *   *ebp+12       = [arg1   ] = argv\n+     *   *ebp+8        = [arg0   ] = argc\n+     *   *ebp+4        = [retpc  ]\n+     *   *ebp          = [old_ebp]\n+     *   *ebp-4        = [old_edi]\n+     *   *ebp-8        = [old_esi]\n+     *   *ebp-12       = [old_ebx]\n      * \n      * This is not the case everywhere, but we start with this\n      * assumption and correct it in the runtime library.\n      *)\n \n     (* Copy argv. *)\n-    mov (rc eax) (c (ebp_n (2 + n_callee_saves)));\n+    mov (rc eax) (c (ebp_n 3));\n     Il.emit e (Il.Push (ro eax));\n \n     (* Copy argc. *)\n-    mov (rc eax) (c (ebp_n (1 + n_callee_saves)));\n+    mov (rc eax) (c (ebp_n 2));\n     Il.emit e (Il.Push (ro eax));\n \n     push_pos32 crate_fixup;\n@@ -1807,8 +1840,8 @@ let objfile_start\n       Il.emit e (Il.Pop (rc ecx));\n       Il.emit e (Il.Pop (rc ecx));\n       Il.emit e (Il.Pop (rc ecx));\n-      Il.emit e (Il.umov (rc esp) (ro ebp));\n       restore_callee_saves e;\n+      leave_frame e;\n       Il.emit e Il.Ret;\n ;;\n \n@@ -1847,6 +1880,7 @@ let (abi:Abi.abi) =\n     Abi.abi_dwarf_fp_reg = dwarf_ebp;\n     Abi.abi_tp_cell = task_ptr;\n     Abi.abi_frame_base_sz = frame_base_sz;\n+    Abi.abi_callee_saves_sz = callee_saves_sz;\n     Abi.abi_frame_info_sz = frame_info_sz;\n     Abi.abi_implicit_args_sz = implicit_args_sz;\n     Abi.abi_spill_slot = spill_slot;"}, {"sha": "977066c016be55dc8aff7c7bf6baccd74aa616bd", "filename": "src/boot/me/layout.ml", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fme%2Flayout.ml", "raw_url": "https://github.com/rust-lang/rust/raw/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fme%2Flayout.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayout.ml?ref=26ecec4e123781c6e99e92cf42ce585e33a861ef", "patch": "@@ -26,27 +26,30 @@ let layout_visitor\n    *     |output ptr (implicit arg)   |\n    *     +----------------------------+ <-- fp + abi_frame_base_sz\n    *     |return pc                   |\n-   *     |callee-save registers       |\n+   *     |old fp                      | <-- fp\n+   *     +----------------------------+\n+   *     |other callee-save registers |\n    *     |...                         |\n-   *     +----------------------------+ <-- fp\n+   *     +----------------------------+ <-- fp - callee_saves\n    *     |crate ptr                   |\n    *     |crate-rel frame info disp   |\n-   *     +----------------------------+ <-- fp - abi_frame_info_sz\n-   *     |spills determined in ra     |\n+   *     +----------------------------+ <-- fp - (callee_saves\n+   *     |spills determined in ra     |           + abi_frame_info_sz)\n    *     |...                         |\n    *     |...                         |\n-   *     +----------------------------+ <-- fp - (abi_frame_info_sz\n-   *     |...                         |            + spillsz)\n-   *     |frame-allocated stuff       |\n+   *     +----------------------------+ <-- fp - (callee_saves\n+   *     |...                         |           + abi_frame_info_sz\n+   *     |frame-allocated stuff       |           + spillsz)\n    *     |determined in resolve       |\n    *     |laid out in layout          |\n    *     |...                         |\n    *     |...                         |\n-   *     +----------------------------+ <-- fp - framesz\n+   *     +----------------------------+ <-- fp - (callee_saves + framesz)\n    *     |call space                  |      == sp + callsz\n    *     |...                         |\n    *     |...                         |\n-   *     +----------------------------+ <-- fp - (framesz + callsz) == sp\n+   *     +----------------------------+ <-- fp - (callee_saves\n+   *                                              + framesz + callsz) == sp\n    *\n    *   - Slot offsets fall into three classes:\n    *\n@@ -246,11 +249,13 @@ let layout_visitor\n     let (frame_id, frame_blocks) = Stack.top frame_stack in\n     let frame_spill = Hashtbl.find cx.ctxt_spill_fixups frame_id in\n     let sz =\n+      (* NB: the \"frame size\" does not include the callee-saves. *)\n       add_sz\n         (add_sz\n            (rty_sz (frame_rty frame_blocks))\n            (SIZE_fixup_mem_sz frame_spill))\n-        (SIZE_fixed cx.ctxt_abi.Abi.abi_frame_info_sz)\n+        (SIZE_fixed\n+           cx.ctxt_abi.Abi.abi_frame_info_sz)\n     in\n     let curr = Hashtbl.find cx.ctxt_frame_sizes frame_id in\n     let sz = max_sz curr sz in\n@@ -354,8 +359,9 @@ let layout_visitor\n     let (frame_id, frame_blocks) = Stack.top frame_stack in\n     let frame_spill = Hashtbl.find cx.ctxt_spill_fixups frame_id in\n     let spill_sz = SIZE_fixup_mem_sz frame_spill in\n+    let callee_saves_sz = SIZE_fixed cx.ctxt_abi.Abi.abi_callee_saves_sz in\n     let info_sz = SIZE_fixed cx.ctxt_abi.Abi.abi_frame_info_sz in\n-    let locals_off = add_sz spill_sz info_sz in\n+    let locals_off = add_sz spill_sz (add_sz info_sz callee_saves_sz) in\n     let off =\n       if Stack.is_empty frame_blocks\n       then locals_off"}, {"sha": "1fdd40ada73ce8331cd78c9a02f21df3875cc5a3", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=26ecec4e123781c6e99e92cf42ce585e33a861ef", "patch": "@@ -142,8 +142,13 @@ let trans_visitor\n   let arg0_disp =\n     Int64.add abi.Abi.abi_frame_base_sz abi.Abi.abi_implicit_args_sz\n   in\n-  let frame_crate_ptr = word_n (-1) in\n-  let frame_fns_disp = word_n (-2) in\n+  let frame_info_disp =\n+    Int64.neg (Int64.add\n+                 abi.Abi.abi_frame_info_sz\n+                 abi.Abi.abi_callee_saves_sz)\n+  in\n+  let frame_fns_disp = Int64.add frame_info_disp (word_n 0) in\n+  let frame_crate_ptr_disp = Int64.add frame_info_disp (word_n 1) in\n \n   let fn_ty (id:node_id) : Ast.ty =\n     Hashtbl.find cx.ctxt_all_item_types id\n@@ -396,7 +401,7 @@ let trans_visitor\n   and cell_cast = Il.cell_cast\n \n   and curr_crate_ptr _ : Il.cell =\n-    word_at (fp_imm frame_crate_ptr)\n+    word_at (fp_imm frame_crate_ptr_disp)\n \n   and crate_rel_to_ptr (rel:Il.operand) (rty:Il.referent_ty) : Il.cell =\n     (in_quad_category \"crate_rel -> ptr\"\n@@ -1645,7 +1650,7 @@ let trans_visitor\n       iflog (fun _ -> annotate \"write frame-info pointers\");\n       Abi.load_fixup_addr (emitter())\n         crate_ptr_reg cx.ctxt_crate_fixup Il.OpaqueTy;\n-      mov (word_at (fp_imm frame_crate_ptr)) (Il.Cell (crate_ptr_cell));\n+      mov (word_at (fp_imm frame_crate_ptr_disp)) (Il.Cell (crate_ptr_cell));\n       imov (word_at (fp_imm frame_fns_disp)) frame_fns\n \n   and check_interrupt_flag _ ="}, {"sha": "680043cc35bb033711f7127bf5cd4efcaa15e0f3", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/26ecec4e123781c6e99e92cf42ce585e33a861ef/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=26ecec4e123781c6e99e92cf42ce585e33a861ef", "patch": "@@ -149,18 +149,22 @@ rust_task::start(uintptr_t exit_task_glue,\n     *spp-- = (uintptr_t) this;       // task\n     *spp-- = (uintptr_t) 0;          // output\n     *spp-- = (uintptr_t) 0;          // retpc\n+\n+    uintptr_t exit_task_frame_base;\n+\n     for (size_t j = 0; j < n_callee_saves; ++j) {\n+\n+        // We want 'frame_base' to point to the old fp in this (exit-task)\n+        // frame, because we're going to inject this frame-pointer into the\n+        // callee-save frame pointer value in the *next* (spawnee) frame. A\n+        // cheap trick, but this means the spawnee frame will restore the\n+        // proper frame pointer of the glue frame as it runs its epilogue.\n+        if (j == callee_save_fp)\n+            exit_task_frame_base = (uintptr_t)spp;\n+\n         *spp-- = 0;\n     }\n \n-    // We want 'frame_base' to point to the last callee-save in this\n-    // (exit-task) frame, because we're going to inject this\n-    // frame-pointer into the callee-save frame pointer value in the\n-    // *next* (spawnee) frame. A cheap trick, but this means the\n-    // spawnee frame will restore the proper frame pointer of the glue\n-    // frame as it runs its epilogue.\n-    uintptr_t frame_base = (uintptr_t) (spp+1);\n-\n     *spp-- = (uintptr_t) dom->root_crate;  // crate ptr\n     *spp-- = (uintptr_t) 0;                // frame_glue_fns\n \n@@ -195,7 +199,7 @@ rust_task::start(uintptr_t exit_task_glue,\n     for (size_t j = 0; j < n_callee_saves; ++j) {\n         // callee-saves to carry in when we activate\n         if (j == callee_save_fp)\n-            *spp-- = frame_base;\n+            *spp-- = exit_task_frame_base;\n         else\n             *spp-- = (uintptr_t)NULL;\n     }\n@@ -432,9 +436,9 @@ rust_task::get_fp() {\n \n uintptr_t\n rust_task::get_previous_fp(uintptr_t fp) {\n-    // fp happens to, coincidentally (!) also point to the last\n-    // callee-save on the task stack.\n-    return get_callee_save_fp((uintptr_t*)fp);\n+    // FIXME: terribly X86-specific.\n+    // *fp == previous_fp.\n+    return *((uintptr_t*)fp);\n }\n \n frame_glue_fns*"}]}