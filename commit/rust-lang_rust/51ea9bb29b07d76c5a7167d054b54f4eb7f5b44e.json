{"sha": "51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "node_id": "C_kwDOAAsO6NoAKDUxZWE5YmIyOWIwN2Q3NmM1YTcxNjdkMDU0YjU0ZjRlYjdmNWI0NGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T18:40:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T18:40:13Z"}, "message": "Auto merge of #96253 - Dylan-DPC:rollup-87hpds5, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #93313 (Check if call return type is visibly uninhabited when building MIR)\n - #96160 (Miri/interpreter debugging tweaks)\n - #96167 (Replace sys/unix/weak AtomicUsize with AtomicPtr)\n - #96168 (Improve AddrParseError description)\n - #96206 (Use sys::unix::locks::futex* on wasm+atomics.)\n - #96234 (remove_dir_all_recursive: treat ELOOP the same as ENOTDIR)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "75e3c6812c9178f1f445e70a97a1d52c2f4292ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75e3c6812c9178f1f445e70a97a1d52c2f4292ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "html_url": "https://github.com/rust-lang/rust/commit/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e69bda8ce0367bfafdda66595a422c7637eb374", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e69bda8ce0367bfafdda66595a422c7637eb374", "html_url": "https://github.com/rust-lang/rust/commit/3e69bda8ce0367bfafdda66595a422c7637eb374"}, {"sha": "2443cf2c6a1b850c19e0de2b6fdc7f1ee250a7d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2443cf2c6a1b850c19e0de2b6fdc7f1ee250a7d0", "html_url": "https://github.com/rust-lang/rust/commit/2443cf2c6a1b850c19e0de2b6fdc7f1ee250a7d0"}], "stats": {"total": 758, "additions": 267, "deletions": 491}, "files": [{"sha": "827959113b90734ce321673ab5c56bbc359469d7", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -679,7 +679,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         return_place: Option<&PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n-        debug!(\"body: {:#?}\", body);\n+        trace!(\"body: {:#?}\", body);\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n@@ -836,7 +836,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n \n-        debug!(\"locals: {:#?}\", frame.locals);\n+        trace!(\"locals: {:#?}\", frame.locals);\n \n         // Cleanup: deallocate all locals that are backed by an allocation.\n         for local in &frame.locals {"}, {"sha": "b1d7ab6a098beccc7954322739b348f6551678d1", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -870,9 +870,17 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n         range: AllocRange,\n         val: ScalarMaybeUninit<Tag>,\n     ) -> InterpResult<'tcx> {\n+        let range = self.range.subrange(range);\n+        debug!(\n+            \"write_scalar in {} at {:#x}, size {}: {:?}\",\n+            self.alloc_id,\n+            range.start.bytes(),\n+            range.size.bytes(),\n+            val\n+        );\n         Ok(self\n             .alloc\n-            .write_scalar(&self.tcx, self.range.subrange(range), val)\n+            .write_scalar(&self.tcx, range, val)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n \n@@ -895,10 +903,19 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRefMut<'a, 'tcx, Tag, Extra> {\n \n impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n     pub fn read_scalar(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-        Ok(self\n+        let range = self.range.subrange(range);\n+        let res = self\n             .alloc\n-            .read_scalar(&self.tcx, self.range.subrange(range))\n-            .map_err(|e| e.to_interp_error(self.alloc_id))?)\n+            .read_scalar(&self.tcx, range)\n+            .map_err(|e| e.to_interp_error(self.alloc_id))?;\n+        debug!(\n+            \"read_scalar in {} at {:#x}, size {}: {:?}\",\n+            self.alloc_id,\n+            range.start.bytes(),\n+            range.size.bytes(),\n+            res\n+        );\n+        Ok(res)\n     }\n \n     pub fn read_ptr_sized(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {"}, {"sha": "c628406064fb63e4703bf503d75519a680c07534", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -515,6 +515,9 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n             if Tag::ERR_ON_PARTIAL_PTR_OVERWRITE {\n                 return Err(AllocError::PartialPointerOverwrite(first));\n             }\n+            warn!(\n+                \"Partial pointer overwrite! De-initializing memory at offsets {first:?}..{start:?}.\"\n+            );\n             self.init_mask.set_range(first, start, false);\n         }\n         if last > end {\n@@ -523,10 +526,15 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n                     last - cx.data_layout().pointer_size,\n                 ));\n             }\n+            warn!(\n+                \"Partial pointer overwrite! De-initializing memory at offsets {end:?}..{last:?}.\"\n+            );\n             self.init_mask.set_range(end, last, false);\n         }\n \n         // Forget all the relocations.\n+        // Since relocations do not overlap, we know that removing until `last` (exclusive) is fine,\n+        // i.e., this will not remove any other relocations just after the ones we care about.\n         self.relocations.0.remove_range(first..last);\n \n         Ok(())"}, {"sha": "cee657e9da244fdc39f5358f463d5cf1f8fa024c", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -255,10 +255,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         func: fun,\n                         args,\n                         cleanup: None,\n-                        // FIXME(varkor): replace this with an uninhabitedness-based check.\n-                        // This requires getting access to the current module to call\n-                        // `tcx.is_ty_uninhabited_from`, which is currently tricky to do.\n-                        destination: if expr.ty.is_never() {\n+                        // The presence or absence of a return edge affects control-flow sensitive\n+                        // MIR checks and ultimately whether code is accepted or not. We can only\n+                        // omit the return edge if a return type is visibly uninhabited to a module\n+                        // that makes the call.\n+                        destination: if this.tcx.is_ty_uninhabited_from(\n+                            this.parent_module,\n+                            expr.ty,\n+                            this.param_env,\n+                        ) {\n                             None\n                         } else {\n                             Some((destination, success))"}, {"sha": "3c51f7918627437bcd9b8f3d479941abed490f4c", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -350,6 +350,7 @@ struct Builder<'a, 'tcx> {\n \n     def_id: DefId,\n     hir_id: hir::HirId,\n+    parent_module: DefId,\n     check_overflow: bool,\n     fn_span: Span,\n     arg_count: usize,\n@@ -807,15 +808,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n \n         let lint_level = LintLevel::Explicit(hir_id);\n+        let param_env = tcx.param_env(def.did);\n         let mut builder = Builder {\n             thir,\n             tcx,\n             infcx,\n             typeck_results: tcx.typeck_opt_const_arg(def),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n-            param_env: tcx.param_env(def.did),\n+            param_env,\n             def_id: def.did.to_def_id(),\n             hir_id,\n+            parent_module: tcx.parent_module(hir_id).to_def_id(),\n             check_overflow,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,"}, {"sha": "fb292ed29a18a5b90d508aaf81df12247fdb6863", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -59,12 +59,12 @@ impl<'a> Parser<'a> {\n \n     /// Run a parser, but fail if the entire input wasn't consumed.\n     /// Doesn't run atomically.\n-    fn parse_with<T, F>(&mut self, inner: F) -> Result<T, AddrParseError>\n+    fn parse_with<T, F>(&mut self, inner: F, kind: AddrKind) -> Result<T, AddrParseError>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n         let result = inner(self);\n-        if self.state.is_empty() { result } else { None }.ok_or(AddrParseError(()))\n+        if self.state.is_empty() { result } else { None }.ok_or(AddrParseError(kind))\n     }\n \n     /// Peek the next character from the input\n@@ -278,7 +278,7 @@ impl<'a> Parser<'a> {\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ip_addr())\n+        Parser::new(s).parse_with(|p| p.read_ip_addr(), AddrKind::Ip)\n     }\n }\n \n@@ -288,9 +288,9 @@ impl FromStr for Ipv4Addr {\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n         // don't try to parse if too long\n         if s.len() > 15 {\n-            Err(AddrParseError(()))\n+            Err(AddrParseError(AddrKind::Ipv4))\n         } else {\n-            Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n+            Parser::new(s).parse_with(|p| p.read_ipv4_addr(), AddrKind::Ipv4)\n         }\n     }\n }\n@@ -299,34 +299,44 @@ impl FromStr for Ipv4Addr {\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_ipv6_addr())\n+        Parser::new(s).parse_with(|p| p.read_ipv6_addr(), AddrKind::Ipv6)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v4())\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v4(), AddrKind::SocketV4)\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr_v6())\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v6(), AddrKind::SocketV6)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        Parser::new(s).parse_with(|p| p.read_socket_addr())\n+        Parser::new(s).parse_with(|p| p.read_socket_addr(), AddrKind::Socket)\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+enum AddrKind {\n+    Ip,\n+    Ipv4,\n+    Ipv6,\n+    Socket,\n+    SocketV4,\n+    SocketV6,\n+}\n+\n /// An error which can be returned when parsing an IP address or a socket address.\n ///\n /// This error is used as the error type for the [`FromStr`] implementation for\n@@ -353,7 +363,7 @@ impl FromStr for SocketAddr {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct AddrParseError(());\n+pub struct AddrParseError(AddrKind);\n \n #[stable(feature = \"addr_parse_error_error\", since = \"1.4.0\")]\n impl fmt::Display for AddrParseError {\n@@ -367,6 +377,13 @@ impl fmt::Display for AddrParseError {\n impl Error for AddrParseError {\n     #[allow(deprecated)]\n     fn description(&self) -> &str {\n-        \"invalid IP address syntax\"\n+        match self.0 {\n+            AddrKind::Ip => \"invalid IP address syntax\",\n+            AddrKind::Ipv4 => \"invalid IPv4 address syntax\",\n+            AddrKind::Ipv6 => \"invalid IPv6 address syntax\",\n+            AddrKind::Socket => \"invalid socket address syntax\",\n+            AddrKind::SocketV4 => \"invalid IPv4 socket address syntax\",\n+            AddrKind::SocketV6 => \"invalid IPv6 socket address syntax\",\n+        }\n     }\n }"}, {"sha": "a60b19976ba4e0d4376ba9396db9229e4f45fdc2", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -1647,8 +1647,9 @@ mod remove_dir_impl {\n     fn remove_dir_all_recursive(parent_fd: Option<RawFd>, path: &CStr) -> io::Result<()> {\n         // try opening as directory\n         let fd = match openat_nofollow_dironly(parent_fd, &path) {\n-            Err(err) if err.raw_os_error() == Some(libc::ENOTDIR) => {\n+            Err(err) if matches!(err.raw_os_error(), Some(libc::ENOTDIR | libc::ELOOP)) => {\n                 // not a directory - don't traverse further\n+                // (for symlinks, older Linux kernels may return ELOOP instead of ENOTDIR)\n                 return match parent_fd {\n                     // unlink...\n                     Some(parent_fd) => {"}, {"sha": "e4ff21b25bd9ce47aea69b7fd0f2eb696c873306", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -25,7 +25,8 @@\n use crate::ffi::CStr;\n use crate::marker::PhantomData;\n use crate::mem;\n-use crate::sync::atomic::{self, AtomicUsize, Ordering};\n+use crate::ptr;\n+use crate::sync::atomic::{self, AtomicPtr, Ordering};\n \n // We can use true weak linkage on ELF targets.\n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n@@ -83,25 +84,25 @@ pub(crate) macro dlsym {\n }\n pub(crate) struct DlsymWeak<F> {\n     name: &'static str,\n-    addr: AtomicUsize,\n+    func: AtomicPtr<libc::c_void>,\n     _marker: PhantomData<F>,\n }\n \n impl<F> DlsymWeak<F> {\n     pub(crate) const fn new(name: &'static str) -> Self {\n-        DlsymWeak { name, addr: AtomicUsize::new(1), _marker: PhantomData }\n+        DlsymWeak { name, func: AtomicPtr::new(ptr::invalid_mut(1)), _marker: PhantomData }\n     }\n \n     #[inline]\n     pub(crate) fn get(&self) -> Option<F> {\n         unsafe {\n             // Relaxed is fine here because we fence before reading through the\n             // pointer (see the comment below).\n-            match self.addr.load(Ordering::Relaxed) {\n-                1 => self.initialize(),\n-                0 => None,\n-                addr => {\n-                    let func = mem::transmute_copy::<usize, F>(&addr);\n+            match self.func.load(Ordering::Relaxed) {\n+                func if func.addr() == 1 => self.initialize(),\n+                func if func.is_null() => None,\n+                func => {\n+                    let func = mem::transmute_copy::<*mut libc::c_void, F>(&func);\n                     // The caller is presumably going to read through this value\n                     // (by calling the function we've dlsymed). This means we'd\n                     // need to have loaded it with at least C11's consume\n@@ -129,25 +130,22 @@ impl<F> DlsymWeak<F> {\n     // Cold because it should only happen during first-time initialization.\n     #[cold]\n     unsafe fn initialize(&self) -> Option<F> {\n-        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n+        assert_eq!(mem::size_of::<F>(), mem::size_of::<*mut libc::c_void>());\n \n         let val = fetch(self.name);\n         // This synchronizes with the acquire fence in `get`.\n-        self.addr.store(val, Ordering::Release);\n+        self.func.store(val, Ordering::Release);\n \n-        match val {\n-            0 => None,\n-            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n-        }\n+        if val.is_null() { None } else { Some(mem::transmute_copy::<*mut libc::c_void, F>(&val)) }\n     }\n }\n \n-unsafe fn fetch(name: &str) -> usize {\n+unsafe fn fetch(name: &str) -> *mut libc::c_void {\n     let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n         Ok(cstr) => cstr,\n-        Err(..) => return 0,\n+        Err(..) => return ptr::null_mut(),\n     };\n-    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n+    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr())\n }\n \n #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]"}, {"sha": "f06c07c54093fc06a63de784d5d6d3d410ca3d8a", "filename": "library/std/src/sys/wasm/atomics/condvar.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3e69bda8ce0367bfafdda66595a422c7637eb374/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e69bda8ce0367bfafdda66595a422c7637eb374/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs?ref=3e69bda8ce0367bfafdda66595a422c7637eb374", "patch": "@@ -1,102 +0,0 @@\n-use crate::arch::wasm32;\n-use crate::cmp;\n-use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-use crate::sys::locks::Mutex;\n-use crate::time::Duration;\n-\n-pub struct Condvar {\n-    cnt: AtomicUsize,\n-}\n-\n-pub type MovableCondvar = Condvar;\n-\n-// Condition variables are implemented with a simple counter internally that is\n-// likely to cause spurious wakeups. Blocking on a condition variable will first\n-// read the value of the internal counter, unlock the given mutex, and then\n-// block if and only if the counter's value is still the same. Notifying a\n-// condition variable will modify the counter (add one for now) and then wake up\n-// a thread waiting on the address of the counter.\n-//\n-// A thread waiting on the condition variable will as a result avoid going to\n-// sleep if it's notified after the lock is unlocked but before it fully goes to\n-// sleep. A sleeping thread is guaranteed to be woken up at some point as it can\n-// only be woken up with a call to `wake`.\n-//\n-// Note that it's possible for 2 or more threads to be woken up by a call to\n-// `notify_one` with this implementation. That can happen where the modification\n-// of `cnt` causes any threads in the middle of `wait` to avoid going to sleep,\n-// and the subsequent `wake` may wake up a thread that's actually blocking. We\n-// consider this a spurious wakeup, though, which all users of condition\n-// variables must already be prepared to handle. As a result, this source of\n-// spurious wakeups is currently though to be ok, although it may be problematic\n-// later on if it causes too many spurious wakeups.\n-\n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        Condvar { cnt: AtomicUsize::new(0) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        // nothing to do\n-    }\n-\n-    pub unsafe fn notify_one(&self) {\n-        self.cnt.fetch_add(1, SeqCst);\n-        // SAFETY: ptr() is always valid\n-        unsafe {\n-            wasm32::memory_atomic_notify(self.ptr(), 1);\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        self.cnt.fetch_add(1, SeqCst);\n-        // SAFETY: ptr() is always valid\n-        unsafe {\n-            wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n-        }\n-    }\n-\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        // \"atomically block and unlock\" implemented by loading our current\n-        // counter's value, unlocking the mutex, and blocking if the counter\n-        // still has the same value.\n-        //\n-        // Notifications happen by incrementing the counter and then waking a\n-        // thread. Incrementing the counter after we unlock the mutex will\n-        // prevent us from sleeping and otherwise the call to `wake` will\n-        // wake us up once we're asleep.\n-        let ticket = self.cnt.load(SeqCst) as i32;\n-        mutex.unlock();\n-        let val = wasm32::memory_atomic_wait32(self.ptr(), ticket, -1);\n-        // 0 == woken, 1 == not equal to `ticket`, 2 == timeout (shouldn't happen)\n-        debug_assert!(val == 0 || val == 1);\n-        mutex.lock();\n-    }\n-\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let ticket = self.cnt.load(SeqCst) as i32;\n-        mutex.unlock();\n-        let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::MAX as u128, nanos);\n-\n-        // If the return value is 2 then a timeout happened, so we return\n-        // `false` as we weren't actually notified.\n-        let ret = wasm32::memory_atomic_wait32(self.ptr(), ticket, nanos as i64) != 2;\n-        mutex.lock();\n-        return ret;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        // nothing to do\n-    }\n-\n-    #[inline]\n-    fn ptr(&self) -> *mut i32 {\n-        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n-        self.cnt.as_mut_ptr() as *mut i32\n-    }\n-}"}, {"sha": "11413ba3bf5642d484b1a3de09f3c0579b18e426", "filename": "library/std/src/sys/wasm/atomics/futex.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Ffutex.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -3,19 +3,33 @@ use crate::convert::TryInto;\n use crate::sync::atomic::AtomicU32;\n use crate::time::Duration;\n \n-pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) {\n+/// Wait for a futex_wake operation to wake us.\n+///\n+/// Returns directly if the futex doesn't hold the expected value.\n+///\n+/// Returns false on timeout, and true in all other cases.\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n     let timeout = timeout.and_then(|t| t.as_nanos().try_into().ok()).unwrap_or(-1);\n     unsafe {\n         wasm32::memory_atomic_wait32(\n             futex as *const AtomicU32 as *mut i32,\n             expected as i32,\n             timeout,\n-        );\n+        ) < 2\n     }\n }\n \n-pub fn futex_wake(futex: &AtomicU32) {\n+/// Wake up one thread that's blocked on futex_wait on this futex.\n+///\n+/// Returns true if this actually woke up such a thread,\n+/// or false if no thread was waiting on this futex.\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n+    unsafe { wasm32::memory_atomic_notify(futex as *const AtomicU32 as *mut i32, 1) > 0 }\n+}\n+\n+/// Wake up all threads that are waiting on futex_wait on this futex.\n+pub fn futex_wake_all(futex: &AtomicU32) {\n     unsafe {\n-        wasm32::memory_atomic_notify(futex as *const AtomicU32 as *mut i32, 1);\n+        wasm32::memory_atomic_notify(futex as *const AtomicU32 as *mut i32, i32::MAX as u32);\n     }\n }"}, {"sha": "1acc8392444c181e7768dd95a5ca22066ce62632", "filename": "library/std/src/sys/wasm/atomics/mutex.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3e69bda8ce0367bfafdda66595a422c7637eb374/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e69bda8ce0367bfafdda66595a422c7637eb374/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs?ref=3e69bda8ce0367bfafdda66595a422c7637eb374", "patch": "@@ -1,64 +0,0 @@\n-use crate::arch::wasm32;\n-use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-\n-pub struct Mutex {\n-    locked: AtomicUsize,\n-}\n-\n-pub type MovableMutex = Mutex;\n-\n-// Mutexes have a pretty simple implementation where they contain an `i32`\n-// internally that is 0 when unlocked and 1 when the mutex is locked.\n-// Acquisition has a fast path where it attempts to cmpxchg the 0 to a 1, and\n-// if it fails it then waits for a notification. Releasing a lock is then done\n-// by swapping in 0 and then notifying any waiters, if present.\n-\n-impl Mutex {\n-    pub const fn new() -> Mutex {\n-        Mutex { locked: AtomicUsize::new(0) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        // nothing to do\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        while !self.try_lock() {\n-            // SAFETY: the caller must uphold the safety contract for `memory_atomic_wait32`.\n-            let val = unsafe {\n-                wasm32::memory_atomic_wait32(\n-                    self.ptr(),\n-                    1,  // we expect our mutex is locked\n-                    -1, // wait infinitely\n-                )\n-            };\n-            // we should have either woke up (0) or got a not-equal due to a\n-            // race (1). We should never time out (2)\n-            debug_assert!(val == 0 || val == 1);\n-        }\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        let prev = self.locked.swap(0, SeqCst);\n-        debug_assert_eq!(prev, 1);\n-        wasm32::memory_atomic_notify(self.ptr(), 1); // wake up one waiter, if any\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok()\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        // nothing to do\n-    }\n-\n-    #[inline]\n-    fn ptr(&self) -> *mut i32 {\n-        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n-        self.locked.as_mut_ptr() as *mut i32\n-    }\n-}"}, {"sha": "690bb155e1a27fea59e59253d524975d007817e1", "filename": "library/std/src/sys/wasm/atomics/rwlock.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/3e69bda8ce0367bfafdda66595a422c7637eb374/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e69bda8ce0367bfafdda66595a422c7637eb374/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs?ref=3e69bda8ce0367bfafdda66595a422c7637eb374", "patch": "@@ -1,145 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sys::locks::{Condvar, Mutex};\n-\n-pub struct RwLock {\n-    lock: Mutex,\n-    cond: Condvar,\n-    state: UnsafeCell<State>,\n-}\n-\n-pub type MovableRwLock = RwLock;\n-\n-enum State {\n-    Unlocked,\n-    Reading(usize),\n-    Writing,\n-}\n-\n-unsafe impl Send for RwLock {}\n-unsafe impl Sync for RwLock {}\n-\n-// This rwlock implementation is a relatively simple implementation which has a\n-// condition variable for readers/writers as well as a mutex protecting the\n-// internal state of the lock. A current downside of the implementation is that\n-// unlocking the lock will notify *all* waiters rather than just readers or just\n-// writers. This can cause lots of \"thundering stampede\" problems. While\n-// hopefully correct this implementation is very likely to want to be changed in\n-// the future.\n-\n-impl RwLock {\n-    pub const fn new() -> RwLock {\n-        RwLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_readers() {\n-            self.cond.wait(&self.lock);\n-        }\n-        self.lock.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_readers();\n-        self.lock.unlock();\n-        return ok;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_writers() {\n-            self.cond.wait(&self.lock);\n-        }\n-        self.lock.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_writers();\n-        self.lock.unlock();\n-        return ok;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        self.lock.lock();\n-        let notify = (*self.state.get()).dec_readers();\n-        self.lock.unlock();\n-        if notify {\n-            // FIXME: should only wake up one of these some of the time\n-            self.cond.notify_all();\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        self.lock.lock();\n-        (*self.state.get()).dec_writers();\n-        self.lock.unlock();\n-        // FIXME: should only wake up one of these some of the time\n-        self.cond.notify_all();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.lock.destroy();\n-        self.cond.destroy();\n-    }\n-}\n-\n-impl State {\n-    fn inc_readers(&mut self) -> bool {\n-        match *self {\n-            State::Unlocked => {\n-                *self = State::Reading(1);\n-                true\n-            }\n-            State::Reading(ref mut cnt) => {\n-                *cnt += 1;\n-                true\n-            }\n-            State::Writing => false,\n-        }\n-    }\n-\n-    fn inc_writers(&mut self) -> bool {\n-        match *self {\n-            State::Unlocked => {\n-                *self = State::Writing;\n-                true\n-            }\n-            State::Reading(_) | State::Writing => false,\n-        }\n-    }\n-\n-    fn dec_readers(&mut self) -> bool {\n-        let zero = match *self {\n-            State::Reading(ref mut cnt) => {\n-                *cnt -= 1;\n-                *cnt == 0\n-            }\n-            State::Unlocked | State::Writing => invalid(),\n-        };\n-        if zero {\n-            *self = State::Unlocked;\n-        }\n-        zero\n-    }\n-\n-    fn dec_writers(&mut self) {\n-        match *self {\n-            State::Writing => {}\n-            State::Unlocked | State::Reading(_) => invalid(),\n-        }\n-        *self = State::Unlocked;\n-    }\n-}\n-\n-fn invalid() -> ! {\n-    panic!(\"inconsistent rwlock\");\n-}"}, {"sha": "714b7049227940bdcd8578cc0f3f609a4478f2d0", "filename": "library/std/src/sys/wasm/atomics/thread.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -53,37 +53,3 @@ pub mod guard {\n         None\n     }\n }\n-\n-// We currently just use our own thread-local to store our\n-// current thread's ID, and then we lazily initialize it to something allocated\n-// from a global counter.\n-pub fn my_id() -> u32 {\n-    use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n-\n-    static NEXT_ID: AtomicU32 = AtomicU32::new(0);\n-\n-    #[thread_local]\n-    static mut MY_ID: u32 = 0;\n-\n-    unsafe {\n-        // If our thread ID isn't set yet then we need to allocate one. Do so\n-        // with with a simple \"atomically add to a global counter\" strategy.\n-        // This strategy doesn't handled what happens when the counter\n-        // overflows, however, so just abort everything once the counter\n-        // overflows and eventually we could have some sort of recycling scheme\n-        // (or maybe this is all totally irrelevant by that point!). In any case\n-        // though we're using a CAS loop instead of a `fetch_add` to ensure that\n-        // the global counter never overflows.\n-        if MY_ID == 0 {\n-            let mut cur = NEXT_ID.load(SeqCst);\n-            MY_ID = loop {\n-                let next = cur.checked_add(1).unwrap_or_else(|| crate::process::abort());\n-                match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n-                    Ok(_) => break next,\n-                    Err(i) => cur = i,\n-                }\n-            };\n-        }\n-        MY_ID\n-    }\n-}"}, {"sha": "9992e44b0e7566b2fb9f8857550dcb2e29999477", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -49,16 +49,13 @@ pub mod time;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_feature = \"atomics\")] {\n-        #[path = \"atomics/condvar.rs\"]\n-        mod condvar;\n-        #[path = \"atomics/mutex.rs\"]\n-        mod mutex;\n-        #[path = \"atomics/rwlock.rs\"]\n-        mod rwlock;\n+        #[path = \"../unix/locks\"]\n         pub mod locks {\n-            pub use super::condvar::*;\n-            pub use super::mutex::*;\n-            pub use super::rwlock::*;\n+            #![allow(unsafe_op_in_unsafe_fn)]\n+            mod futex;\n+            mod futex_rwlock;\n+            pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n+            pub use futex_rwlock::{RwLock, MovableRwLock};\n         }\n         #[path = \"atomics/futex.rs\"]\n         pub mod futex;"}, {"sha": "bccb9e4c7586254462e1164cb29b2d81fe4a5261", "filename": "src/test/codegen/set-discriminant-invalid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fcodegen%2Fset-discriminant-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fcodegen%2Fset-discriminant-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fset-discriminant-invalid.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -28,7 +28,7 @@ impl IntoError<Error> for Api\n     #[no_mangle]\n     fn into_error(self, error: Self::Source) -> Error {\n         Error::Api {\n-            source: (|v| v)(error),\n+            source: error,\n         }\n     }\n }"}, {"sha": "3b890e4be2e290f4ce98f0f44797418eed439191", "filename": "src/test/mir-opt/inline/inline_diverging.h.Inline.diff", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_diverging.h.Inline.diff?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -4,21 +4,22 @@\n   fn h() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/inline-diverging.rs:21:12: 21:12\n       let _1: (!, !);                      // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+     let mut _2: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+     let mut _9: ();                      // in scope 0 at $DIR/inline-diverging.rs:27:13: 27:16\n-+     let mut _10: ();                     // in scope 0 at $DIR/inline-diverging.rs:28:13: 28:16\n++     let mut _2: (!, !);                  // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _3: fn() -> ! {sleep};       // in scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++     let mut _10: ();                     // in scope 0 at $DIR/inline-diverging.rs:27:13: 27:16\n++     let mut _11: ();                     // in scope 0 at $DIR/inline-diverging.rs:28:13: 28:16\n +     scope 1 (inlined call_twice::<!, fn() -> ! {sleep}>) { // at $DIR/inline-diverging.rs:22:5: 22:22\n-+         debug f => _2;                   // in scope 1 at $DIR/inline-diverging.rs:26:36: 26:37\n-+         let _3: !;                       // in scope 1 at $DIR/inline-diverging.rs:27:9: 27:10\n-+         let mut _4: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:27:13: 27:14\n-+         let mut _6: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:28:13: 28:14\n-+         let mut _7: !;                   // in scope 1 at $DIR/inline-diverging.rs:29:6: 29:7\n-+         let mut _8: !;                   // in scope 1 at $DIR/inline-diverging.rs:29:9: 29:10\n++         debug f => _3;                   // in scope 1 at $DIR/inline-diverging.rs:26:36: 26:37\n++         let _4: !;                       // in scope 1 at $DIR/inline-diverging.rs:27:9: 27:10\n++         let mut _5: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:27:13: 27:14\n++         let mut _7: &fn() -> ! {sleep};  // in scope 1 at $DIR/inline-diverging.rs:28:13: 28:14\n++         let mut _8: !;                   // in scope 1 at $DIR/inline-diverging.rs:29:6: 29:7\n++         let mut _9: !;                   // in scope 1 at $DIR/inline-diverging.rs:29:9: 29:10\n +         scope 2 {\n-+             debug a => _3;               // in scope 2 at $DIR/inline-diverging.rs:27:9: 27:10\n-+             let _5: !;                   // in scope 2 at $DIR/inline-diverging.rs:28:9: 28:10\n++             debug a => _4;               // in scope 2 at $DIR/inline-diverging.rs:27:9: 27:10\n++             let _6: !;                   // in scope 2 at $DIR/inline-diverging.rs:28:9: 28:10\n +             scope 3 {\n-+                 debug b => _5;           // in scope 3 at $DIR/inline-diverging.rs:28:9: 28:10\n++                 debug b => _6;           // in scope 3 at $DIR/inline-diverging.rs:28:9: 28:10\n +             }\n +             scope 6 (inlined <fn() -> ! {sleep} as Fn<()>>::call - shim(fn() -> ! {sleep})) { // at $DIR/inline-diverging.rs:28:13: 28:16\n +                 scope 7 (inlined sleep) { // at $SRC_DIR/core/src/ops/function.rs:LL:COL\n@@ -33,27 +34,25 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n--         _1 = call_twice::<!, fn() -> ! {sleep}>(sleep) -> bb1; // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n+-         call_twice::<!, fn() -> ! {sleep}>(sleep); // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n +         StorageLive(_2);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n-+         _2 = sleep;                      // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         StorageLive(_3);                 // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n++         _3 = sleep;                      // scope 0 at $DIR/inline-diverging.rs:22:5: 22:22\n                                            // mir::Constant\n -                                          // + span: $DIR/inline-diverging.rs:22:5: 22:15\n -                                          // + literal: Const { ty: fn(fn() -> ! {sleep}) -> (!, !) {call_twice::<!, fn() -> ! {sleep}>}, val: Value(Scalar(<ZST>)) }\n -                                          // mir::Constant\n                                            // + span: $DIR/inline-diverging.rs:22:16: 22:21\n                                            // + literal: Const { ty: fn() -> ! {sleep}, val: Value(Scalar(<ZST>)) }\n-+         StorageLive(_3);                 // scope 1 at $DIR/inline-diverging.rs:27:9: 27:10\n-+         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:27:13: 27:14\n-+         _4 = &_2;                        // scope 1 at $DIR/inline-diverging.rs:27:13: 27:14\n-+         StorageLive(_9);                 // scope 1 at $DIR/inline-diverging.rs:27:13: 27:16\n-+         _9 = const ();                   // scope 1 at $DIR/inline-diverging.rs:27:13: 27:16\n++         StorageLive(_4);                 // scope 1 at $DIR/inline-diverging.rs:27:9: 27:10\n++         StorageLive(_5);                 // scope 1 at $DIR/inline-diverging.rs:27:13: 27:14\n++         _5 = &_3;                        // scope 1 at $DIR/inline-diverging.rs:27:13: 27:14\n++         StorageLive(_10);                // scope 1 at $DIR/inline-diverging.rs:27:13: 27:16\n++         _10 = const ();                  // scope 1 at $DIR/inline-diverging.rs:27:13: 27:16\n +         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:39:5: 39:12\n-      }\n-  \n-      bb1: {\n--         StorageDead(_1);                 // scope 0 at $DIR/inline-diverging.rs:22:22: 22:23\n--         _0 = const ();                   // scope 0 at $DIR/inline-diverging.rs:21:12: 23:2\n--         return;                          // scope 0 at $DIR/inline-diverging.rs:23:2: 23:2\n++     }\n++ \n++     bb1: {\n +         goto -> bb1;                     // scope 5 at $DIR/inline-diverging.rs:39:5: 39:12\n       }\n   }"}, {"sha": "4aff4445158098efdaa023a3393314f1d9e207d6", "filename": "src/test/mir-opt/issue_72181_1.main.mir_map.0.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fmir-opt%2Fissue_72181_1.main.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fmir-opt%2Fissue_72181_1.main.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_72181_1.main.mir_map.0.mir?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -21,7 +21,7 @@ fn main() -> () {\n         StorageLive(_2);                 // scope 0 at $DIR/issue-72181-1.rs:16:9: 16:10\n         StorageLive(_3);                 // scope 2 at $DIR/issue-72181-1.rs:17:41: 17:43\n         _3 = ();                         // scope 2 at $DIR/issue-72181-1.rs:17:41: 17:43\n-        _2 = transmute::<(), Void>(move _3) -> [return: bb1, unwind: bb4]; // scope 2 at $DIR/issue-72181-1.rs:17:9: 17:44\n+        transmute::<(), Void>(move _3) -> bb4; // scope 2 at $DIR/issue-72181-1.rs:17:9: 17:44\n                                          // mir::Constant\n                                          // + span: $DIR/issue-72181-1.rs:17:9: 17:40\n                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(()) -> Void {transmute::<(), Void>}, val: Value(Scalar(<ZST>)) }"}, {"sha": "b60bac541f4c815fe892d0a02d491a4cf4d72881", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -119,27 +119,17 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n                78 00 00 00 ff ff ff ff                         \u2502 x.......\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:92:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum.rs:92:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:94:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum.rs:94:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-variant(Ok)>.0.1: encountered a value of the never type `!`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error: aborting due to 13 previous errors\n "}, {"sha": "1d81e2b3eed86564cf23f96ad99f702a69577dec", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -119,27 +119,17 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n                78 00 00 00 ff ff ff ff                         \u2502 x.......\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:92:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum.rs:92:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-variant(Ok)>.0.1: encountered a value of uninhabited type Never\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:94:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum.rs:94:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<enum-variant(Ok)>.0.1: encountered a value of the never type `!`\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               00 00 00 00 00 00 00 00                         \u2502 ........\n-           }\n+   |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error: aborting due to 13 previous errors\n "}, {"sha": "86288685303cab71d3d733a3d6cfda0311fead9d", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -90,9 +90,9 @@ const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute\n // All variants are uninhabited but also have data.\n // Use `0` as constant to make behavior endianess-independent.\n const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n-//~^ ERROR is undefined behavior\n+//~^ ERROR evaluation of constant value failed\n const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n-//~^ ERROR is undefined behavior\n+//~^ ERROR evaluation of constant value failed\n \n fn main() {\n }"}, {"sha": "bbb8511a65410ca89b838f36a7d1871415867cf8", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -10,14 +10,11 @@ LL |     unsafe { std::mem::transmute(()) }\n LL | const FOO: [Empty; 3] = [foo(); 3];\n    |                          ----- inside `FOO` at $DIR/validate_uninhabited_zsts.rs:13:26\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_uninhabited_zsts.rs:16:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/validate_uninhabited_zsts.rs:16:35\n    |\n LL | const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at [0]: encountered a value of uninhabited type Empty\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n warning: the type `!` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:4:14"}, {"sha": "bbb8511a65410ca89b838f36a7d1871415867cf8", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -10,14 +10,11 @@ LL |     unsafe { std::mem::transmute(()) }\n LL | const FOO: [Empty; 3] = [foo(); 3];\n    |                          ----- inside `FOO` at $DIR/validate_uninhabited_zsts.rs:13:26\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/validate_uninhabited_zsts.rs:16:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/validate_uninhabited_zsts.rs:16:35\n    |\n LL | const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at [0]: encountered a value of uninhabited type Empty\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n warning: the type `!` does not permit zero-initialization\n   --> $DIR/validate_uninhabited_zsts.rs:4:14"}, {"sha": "990d5a308238ffda3a8baf0ee06805d156a7f43a", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -14,7 +14,7 @@ const FOO: [Empty; 3] = [foo(); 3];\n \n #[warn(const_err)]\n const BAR: [Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n //~| WARN the type `Empty` does not permit zero-initialization\n \n fn main() {"}, {"sha": "92305609c835c6248b50d13477d9fd0c0cec387a", "filename": "src/test/ui/generator/issue-93161.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fgenerator%2Fissue-93161.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fgenerator%2Fissue-93161.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-93161.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -1,5 +1,6 @@\n // edition:2021\n // run-pass\n+// compile-flags: -Zdrop-tracking\n \n #![feature(never_type)]\n \n@@ -32,7 +33,7 @@ fn never() -> Never {\n }\n \n async fn includes_never(crash: bool, x: u32) -> u32 {\n-    let mut result = async { x * x }.await;\n+    let result = async { x * x }.await;\n     if !crash {\n         return result;\n     }"}, {"sha": "f5c6f444317feb7cbc643dbb43b15e1647ec6f8b", "filename": "src/test/ui/statics/uninhabited-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -11,11 +11,11 @@ extern {\n \n static VOID2: Void = unsafe { std::mem::transmute(()) }; //~ ERROR static of uninhabited type\n //~| WARN: previously accepted\n-//~| ERROR undefined behavior to use this value\n+//~| ERROR could not evaluate static initializer\n //~| WARN: type `Void` does not permit zero-initialization\n static NEVER2: Void = unsafe { std::mem::transmute(()) }; //~ ERROR static of uninhabited type\n //~| WARN: previously accepted\n-//~| ERROR undefined behavior to use this value\n+//~| ERROR could not evaluate static initializer\n //~| WARN: type `Void` does not permit zero-initialization\n \n fn main() {}"}, {"sha": "1e0becb7d5aa87662c33250585821911f2962a78", "filename": "src/test/ui/statics/uninhabited-static.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatics%2Funinhabited-static.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -43,23 +43,17 @@ LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n    = note: for more information, see issue #74840 <https://github.com/rust-lang/rust/issues/74840>\n    = note: uninhabited statics cannot be initialized, and any access would be an immediate error\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/uninhabited-static.rs:12:1\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/uninhabited-static.rs:12:31\n    |\n LL | static VOID2: Void = unsafe { std::mem::transmute(()) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Void\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/uninhabited-static.rs:16:1\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/uninhabited-static.rs:16:32\n    |\n LL | static NEVER2: Void = unsafe { std::mem::transmute(()) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of uninhabited type Void\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 0, align: 1) {}\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n warning: the type `Void` does not permit zero-initialization\n   --> $DIR/uninhabited-static.rs:12:31"}, {"sha": "b37ec2696de2f95cbc6dc8980ec9a47e73d40e3f", "filename": "src/test/ui/uninhabited/privately-uninhabited-mir-call.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-mir-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-mir-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-mir-call.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -0,0 +1,29 @@\n+// Verifies that MIR building for a call expression respects\n+// privacy when checking if a call return type is uninhabited.\n+\n+pub mod widget {\n+    enum Unimplemented {}\n+    pub struct Widget(Unimplemented);\n+\n+    impl Widget {\n+        pub fn new() -> Widget {\n+            todo!();\n+        }\n+    }\n+\n+    pub fn f() {\n+        let x: &mut u32;\n+        Widget::new();\n+        // Ok. Widget type returned from new is known to be uninhabited\n+        // and the following code is considered unreachable.\n+        *x = 1;\n+    }\n+}\n+\n+fn main() {\n+    let y: &mut u32;\n+    widget::Widget::new();\n+    // Error. Widget type is not known to be uninhabited here,\n+    // so the following code is considered reachable.\n+    *y = 2; //~ ERROR use of possibly-uninitialized variable\n+}"}, {"sha": "fb1953411685eb0dbdd9171d90a499da4a4a1629", "filename": "src/test/ui/uninhabited/privately-uninhabited-mir-call.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-mir-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-mir-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Fprivately-uninhabited-mir-call.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -0,0 +1,9 @@\n+error[E0381]: use of possibly-uninitialized variable: `y`\n+  --> $DIR/privately-uninhabited-mir-call.rs:28:5\n+   |\n+LL |     *y = 2;\n+   |     ^^^^^^ use of possibly-uninitialized `y`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "e7960960774fcdf54641b50b5c913cc4482f57bc", "filename": "src/test/ui/unsafe/issue-45087-unreachable-unsafe.mir.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.mir.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -1,11 +1,27 @@\n error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n-  --> $DIR/issue-45087-unreachable-unsafe.rs:6:5\n+  --> $DIR/issue-45087-unreachable-unsafe.rs:7:5\n    |\n LL |     *(1 as *mut u32) = 42;\n    |     ^^^^^^^^^^^^^^^^^^^^^ dereference of raw pointer\n    |\n    = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n-error: aborting due to previous error\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n+  --> $DIR/issue-45087-unreachable-unsafe.rs:17:5\n+   |\n+LL |     *a = 1;\n+   |     ^^^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n+  --> $DIR/issue-45087-unreachable-unsafe.rs:29:5\n+   |\n+LL |     *b = 1;\n+   |     ^^^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "3e3da667c0b0883bb0636cc460c6e4dd0e8c4acc", "filename": "src/test/ui/unsafe/issue-45087-unreachable-unsafe.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.rs?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -1,3 +1,4 @@\n+// Verify that unreachable code undergoes unsafety checks.\n // revisions: mir thir\n // [thir]compile-flags: -Z thir-unsafeck\n \n@@ -6,3 +7,25 @@ fn main() {\n     *(1 as *mut u32) = 42;\n     //~^ ERROR dereference of raw pointer is unsafe\n }\n+\n+fn panic() -> ! {\n+    panic!();\n+}\n+\n+fn f(a: *mut u32) {\n+    panic();\n+    *a = 1;\n+    //~^ ERROR dereference of raw pointer is unsafe\n+}\n+\n+enum Void {}\n+\n+fn uninhabited() -> Void {\n+    panic!();\n+}\n+\n+fn g(b: *mut u32) {\n+    uninhabited();\n+    *b = 1;\n+    //~^ ERROR dereference of raw pointer is unsafe\n+}"}, {"sha": "e81adad45075054682737061ac3c3d64999b478a", "filename": "src/test/ui/unsafe/issue-45087-unreachable-unsafe.thir.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Fissue-45087-unreachable-unsafe.thir.stderr?ref=51ea9bb29b07d76c5a7167d054b54f4eb7f5b44e", "patch": "@@ -1,11 +1,27 @@\n error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n-  --> $DIR/issue-45087-unreachable-unsafe.rs:6:5\n+  --> $DIR/issue-45087-unreachable-unsafe.rs:7:5\n    |\n LL |     *(1 as *mut u32) = 42;\n    |     ^^^^^^^^^^^^^^^^ dereference of raw pointer\n    |\n    = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n-error: aborting due to previous error\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n+  --> $DIR/issue-45087-unreachable-unsafe.rs:17:5\n+   |\n+LL |     *a = 1;\n+   |     ^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n+  --> $DIR/issue-45087-unreachable-unsafe.rs:29:5\n+   |\n+LL |     *b = 1;\n+   |     ^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}]}