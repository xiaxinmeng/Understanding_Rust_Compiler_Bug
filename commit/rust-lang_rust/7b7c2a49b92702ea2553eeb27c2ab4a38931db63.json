{"sha": "7b7c2a49b92702ea2553eeb27c2ab4a38931db63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiN2MyYTQ5YjkyNzAyZWEyNTUzZWViMjdjMmFiNGEzODkzMWRiNjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-02T01:42:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-10-02T02:24:48Z"}, "message": "docs: Begin integrating bblum's linked failure blog post", "tree": {"sha": "1507f86d98ddcc5d69050b0b7d629969c505adb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1507f86d98ddcc5d69050b0b7d629969c505adb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b7c2a49b92702ea2553eeb27c2ab4a38931db63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7c2a49b92702ea2553eeb27c2ab4a38931db63", "html_url": "https://github.com/rust-lang/rust/commit/7b7c2a49b92702ea2553eeb27c2ab4a38931db63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b7c2a49b92702ea2553eeb27c2ab4a38931db63/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84d10c68fb893d32f0a2bf4d4f7eb05511023776", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d10c68fb893d32f0a2bf4d4f7eb05511023776", "html_url": "https://github.com/rust-lang/rust/commit/84d10c68fb893d32f0a2bf4d4f7eb05511023776"}], "stats": {"total": 157, "additions": 157, "deletions": 0}, "files": [{"sha": "405f4ac73478afac496a37232bfdf480501e371f", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7b7c2a49b92702ea2553eeb27c2ab4a38931db63/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b7c2a49b92702ea2553eeb27c2ab4a38931db63/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=7b7c2a49b92702ea2553eeb27c2ab4a38931db63", "patch": "@@ -295,6 +295,163 @@ let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n+# TODO\n+\n+# Handling task failure\n+\n+Rust has a built-in mechanism for raising exceptions, written `fail`\n+(or `fail ~\"reason\"`, or sometimes `assert expr`), and it causes the\n+task to unwind its stack, running destructors and freeing memory along\n+the way, and then exit itself. Unlike C++, exceptions in Rust are\n+unrecoverable within a single task - once a task fails there is no way\n+to \"catch\" the exception.\n+\n+All tasks are, by default, _linked_ to each other, meaning their fate\n+is interwined, and if one fails so do all of them.\n+\n+~~~\n+# use task::spawn;\n+# fn do_some_work() { loop { task::yield() } }\n+# do task::try {\n+// Create a child task that fails\n+do spawn { fail }\n+\n+// This will also fail because the task we spawned failed\n+do_some_work();\n+# };\n+~~~\n+\n+While it isn't possible for a task to recover from failure,\n+tasks may be notified when _other_ tasks fail. The simplest way\n+of handling task failure is with the `try` function, which is\n+similar to spawn, but immediately blocks waiting for the child\n+task to finish.\n+\n+~~~\n+# fn some_condition() -> bool { false }\n+# fn calculate_result() -> int { 0 }\n+let result: Result<int, ()> = do task::try {\n+    if some_condition() {\n+        calculate_result()\n+    } else {\n+        fail ~\"oops!\";\n+    }\n+};\n+assert result.is_err();\n+~~~\n+\n+Unlike `spawn`, the function spawned using `try` may return a value,\n+which `try` will dutifully propagate back to the caller in a [`Result`]\n+enum. If the child task terminates successfully, `try` will\n+return an `Ok` result; if the child task fails, `try` will return\n+an `Error` result.\n+\n+[`Result`]: core/result.html\n+\n+> ***Note:*** A failed task does not currently produce a useful error\n+> value (all error results from `try` are equal to `Err(())`). In the\n+> future it may be possible for tasks to intercept the value passed to\n+> `fail`.\n+\n+TODO: Need discussion of `future_result` in order to make failure\n+modes useful.\n+\n+But not all failure is created equal. In some cases you might need to\n+abort the entire program (perhaps you're writing an assert which, if\n+it trips, indicates an unrecoverable logic error); in other cases you\n+might want to contain the failure at a certain boundary (perhaps a\n+small piece of input from the outside world, which you happen to be\n+processing in parallel, is malformed and its processing task can't\n+proceed). Hence the need for different _linked failure modes_.\n+\n+## Failure modes\n+\n+By default, task failure is _bidirectionally linked_, which means if\n+either task dies, it kills the other one.\n+\n+~~~\n+# fn sleep_forever() { loop { task::yield() } }\n+# do task::try {\n+do task::spawn {\n+    do task::spawn {\n+        fail;  // All three tasks will die.\n+    }\n+    sleep_forever();  // Will get woken up by force, then fail\n+}\n+sleep_forever();  // Will get woken up by force, then fail\n+# };\n+~~~\n+\n+If you want parent tasks to kill their children, but not for a child\n+task's failure to kill the parent, you can call\n+`task::spawn_supervised` for _unidirectionally linked_ failure. The\n+function `task::try`, which we saw previously, uses `spawn_supervised`\n+internally, with additional logic to wait for the child task to finish\n+before returning. Hence:\n+\n+~~~\n+# use pipes::{stream, Chan, Port};\n+# use task::{spawn, try};\n+# fn sleep_forever() { loop { task::yield() } }\n+# do task::try {\n+let (sender, receiver): (Chan<int>, Port<int>) = stream();\n+do spawn {  // Bidirectionally linked\n+    // Wait for the supervised child task to exist.\n+    let message = receiver.recv();\n+    // Kill both it and the parent task.\n+    assert message != 42;\n+}\n+do try {  // Unidirectionally linked\n+    sender.send(42);\n+    sleep_forever();  // Will get woken up by force\n+}\n+// Flow never reaches here -- parent task was killed too.\n+# };\n+~~~\n+\n+Supervised failure is useful in any situation where one task manages\n+multiple fallible child tasks, and the parent task can recover\n+if any child files. On the other hand, if the _parent_ (supervisor) fails\n+then there is nothing the children can do to recover, so they should\n+also fail.\n+\n+Supervised task failure propagates across multiple generations even if\n+an intermediate generation has already exited:\n+\n+~~~\n+# fn sleep_forever() { loop { task::yield() } }\n+# fn wait_for_a_while() { for 1000.times { task::yield() } }\n+# do task::try::<int> {\n+do task::spawn_supervised {\n+    do task::spawn_supervised {\n+        sleep_forever();  // Will get woken up by force, then fail\n+    }\n+    // Intermediate task immediately exits\n+}\n+wait_for_a_while();\n+fail;  // Will kill grandchild even if child has already exited\n+# };\n+~~~\n+\n+Finally, tasks can be configured to not propagate failure to each\n+other at all, using `task::spawn_unlinked` for _isolated failure_.\n+\n+~~~\n+# fn random() -> int { 100 }\n+# fn sleep_for(i: int) { for i.times { task::yield() } }\n+# do task::try::<()> {\n+let (time1, time2) = (random(), random());\n+do task::spawn_unlinked {\n+    sleep_for(time2);  // Won't get forced awake\n+    fail;\n+}\n+sleep_for(time1);  // Won't get forced awake\n+fail;\n+// It will take MAX(time1,time2) for the program to finish.\n+# };\n+~~~\n+\n+\n # Unfinished notes\n \n ## Actor patterns"}]}