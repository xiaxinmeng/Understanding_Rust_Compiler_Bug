{"sha": "3244c117f8b17c27203a625c5b9e3b281ea5debf", "node_id": "C_kwDOAAsO6NoAKDMyNDRjMTE3ZjhiMTdjMjcyMDNhNjI1YzViOWUzYjI4MWVhNWRlYmY", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-10-18T05:50:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-10-20T20:19:06Z"}, "message": "add windows one time initialization", "tree": {"sha": "99acfda734507dca4049c3d14edce74b5bb9b58d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99acfda734507dca4049c3d14edce74b5bb9b58d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3244c117f8b17c27203a625c5b9e3b281ea5debf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3244c117f8b17c27203a625c5b9e3b281ea5debf", "html_url": "https://github.com/rust-lang/rust/commit/3244c117f8b17c27203a625c5b9e3b281ea5debf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3244c117f8b17c27203a625c5b9e3b281ea5debf/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4207f9e088dd574827aa35c3273cceee712820a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4207f9e088dd574827aa35c3273cceee712820a9", "html_url": "https://github.com/rust-lang/rust/commit/4207f9e088dd574827aa35c3273cceee712820a9"}], "stats": {"total": 400, "additions": 368, "deletions": 32}, "files": [{"sha": "1892095104978a750d0e7a06575b9b487298ab05", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 197, "deletions": 1, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=3244c117f8b17c27203a625c5b9e3b281ea5debf", "patch": "@@ -7,6 +7,7 @@ use log::trace;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::{Idx, IndexVec};\n \n+use super::thread::MachineCallback;\n use super::vector_clock::VClock;\n use crate::*;\n \n@@ -149,13 +150,68 @@ struct FutexWaiter {\n     bitset: u32,\n }\n \n+declare_id!(InitOnceId);\n+\n+struct InitOnceWaiter<'mir, 'tcx> {\n+    thread: ThreadId,\n+    callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+}\n+\n+impl<'mir, 'tcx> std::fmt::Debug for InitOnceWaiter<'mir, 'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"InitOnce\")\n+            .field(\"thread\", &self.thread)\n+            .field(\"callback\", &\"dyn MachineCallback\")\n+            .finish()\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+/// The current status of a one time initialization.\n+pub enum InitOnceStatus {\n+    Uninitialized,\n+    Begun,\n+    Complete,\n+}\n+\n+impl Default for InitOnceStatus {\n+    fn default() -> Self {\n+        Self::Uninitialized\n+    }\n+}\n+\n+/// The one time initialization state.\n+#[derive(Default, Debug)]\n+struct InitOnce<'mir, 'tcx> {\n+    status: InitOnceStatus,\n+    waiters: VecDeque<InitOnceWaiter<'mir, 'tcx>>,\n+    data_race: VClock,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for InitOnce<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for waiter in self.waiters.iter() {\n+            waiter.callback.visit_tags(visit);\n+        }\n+    }\n+}\n+\n /// The state of all synchronization variables.\n #[derive(Default, Debug)]\n-pub(crate) struct SynchronizationState {\n+pub(crate) struct SynchronizationState<'mir, 'tcx> {\n     mutexes: IndexVec<MutexId, Mutex>,\n     rwlocks: IndexVec<RwLockId, RwLock>,\n     condvars: IndexVec<CondvarId, Condvar>,\n     futexes: FxHashMap<u64, Futex>,\n+    init_onces: IndexVec<InitOnceId, InitOnce<'mir, 'tcx>>,\n+}\n+\n+impl<'mir, 'tcx> VisitTags for SynchronizationState<'mir, 'tcx> {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+        for init_once in self.init_onces.iter() {\n+            init_once.visit_tags(visit);\n+        }\n+    }\n }\n \n // Private extension trait for local helper methods\n@@ -581,4 +637,144 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             futex.waiters.retain(|waiter| waiter.thread != thread);\n         }\n     }\n+\n+    #[inline]\n+    /// Create state for a new one time initialization.\n+    fn init_once_create(&mut self) -> InitOnceId {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.sync.init_onces.push(Default::default())\n+    }\n+\n+    #[inline]\n+    /// Provides the closure with the next InitOnceId. Creates that InitOnce if the closure returns None,\n+    /// otherwise returns the value from the closure\n+    fn init_once_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, InitOnceId>\n+    where\n+        F: FnOnce(\n+            &mut MiriInterpCx<'mir, 'tcx>,\n+            InitOnceId,\n+        ) -> InterpResult<'tcx, Option<InitOnceId>>,\n+    {\n+        let this = self.eval_context_mut();\n+        let next_index = this.machine.threads.sync.init_onces.next_index();\n+        if let Some(old) = existing(this, next_index)? {\n+            Ok(old)\n+        } else {\n+            let new_index = this.machine.threads.sync.init_onces.push(Default::default());\n+            assert_eq!(next_index, new_index);\n+            Ok(new_index)\n+        }\n+    }\n+\n+    #[inline]\n+    fn init_once_status(&mut self, id: InitOnceId) -> InitOnceStatus {\n+        let this = self.eval_context_ref();\n+        this.machine.threads.sync.init_onces[id].status\n+    }\n+\n+    #[inline]\n+    /// Put the thread into the queue waiting for the initialization.\n+    fn init_once_enqueue_and_block(\n+        &mut self,\n+        id: InitOnceId,\n+        thread: ThreadId,\n+        callback: Box<dyn MachineCallback<'mir, 'tcx> + 'tcx>,\n+    ) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_ne!(init_once.status, InitOnceStatus::Complete, \"queueing on complete init once\");\n+        init_once.waiters.push_back(InitOnceWaiter { thread, callback });\n+        this.block_thread(thread);\n+    }\n+\n+    #[inline]\n+    fn init_once_begin(&mut self, id: InitOnceId) {\n+        let this = self.eval_context_mut();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Uninitialized,\n+            \"begining already begun or complete init once\"\n+        );\n+        init_once.status = InitOnceStatus::Begun;\n+    }\n+\n+    #[inline]\n+    fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"completing already complete or uninit init once\"\n+        );\n+\n+        init_once.status = InitOnceStatus::Complete;\n+\n+        // Each complete happens-before the end of the wait\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // need to take the queue to avoid having `this` be borrowed multiple times\n+        for waiter in std::mem::take(&mut init_once.waiters) {\n+            this.unblock_thread(waiter.thread);\n+\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[inline]\n+    fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let current_thread = this.get_active_thread();\n+        let init_once = &mut this.machine.threads.sync.init_onces[id];\n+        assert_eq!(\n+            init_once.status,\n+            InitOnceStatus::Begun,\n+            \"failing already completed or uninit init once\"\n+        );\n+\n+        // Each complete happens-before the end of the wait\n+        if let Some(data_race) = &this.machine.data_race {\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+        }\n+\n+        // the behavior of failing the initialization is left vague by the docs\n+        // it had to be determined experimentally\n+        if let Some(waiter) = init_once.waiters.pop_front() {\n+            // try initializing again on a different thread\n+            init_once.status = InitOnceStatus::Begun;\n+\n+            this.unblock_thread(waiter.thread);\n+\n+            this.set_active_thread(waiter.thread);\n+            waiter.callback.call(this)?;\n+            this.set_active_thread(current_thread);\n+\n+            if let Some(data_race) = &this.machine.data_race {\n+                data_race.validate_lock_acquire(\n+                    &this.machine.threads.sync.init_onces[id].data_race,\n+                    waiter.thread,\n+                );\n+            }\n+        } else {\n+            init_once.status = InitOnceStatus::Uninitialized;\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "3432f10f7a925fc58e3605f5be93dca7f9cc0852", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=3244c117f8b17c27203a625c5b9e3b281ea5debf", "patch": "@@ -30,8 +30,7 @@ pub enum SchedulingAction {\n     Stop,\n }\n \n-/// Timeout callbacks can be created by synchronization primitives to tell the\n-/// scheduler that they should be called once some period of time passes.\n+/// Trait for callbacks that can be executed when some event happens, such as after a timeout.\n pub trait MachineCallback<'mir, 'tcx>: VisitTags {\n     fn call(&self, ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx>;\n }\n@@ -269,7 +268,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n     threads: IndexVec<ThreadId, Thread<'mir, 'tcx>>,\n     /// This field is pub(crate) because the synchronization primitives\n     /// (`crate::sync`) need a way to access it.\n-    pub(crate) sync: SynchronizationState,\n+    pub(crate) sync: SynchronizationState<'mir, 'tcx>,\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n     thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Provenance>>>,\n@@ -303,7 +302,7 @@ impl VisitTags for ThreadManager<'_, '_> {\n             timeout_callbacks,\n             active_thread: _,\n             yield_active_thread: _,\n-            sync: _,\n+            sync,\n         } = self;\n \n         for thread in threads {\n@@ -315,6 +314,7 @@ impl VisitTags for ThreadManager<'_, '_> {\n         for callback in timeout_callbacks.values() {\n             callback.callback.visit_tags(visit);\n         }\n+        sync.visit_tags(visit);\n     }\n }\n "}, {"sha": "f7c22b76f4f6c4573690ad74dc9d4f4e81894339", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=3244c117f8b17c27203a625c5b9e3b281ea5debf", "patch": "@@ -87,7 +87,7 @@ pub use crate::concurrency::{\n         AtomicFenceOrd, AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd,\n         EvalContextExt as DataRaceEvalContextExt,\n     },\n-    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId},\n+    sync::{CondvarId, EvalContextExt as SyncEvalContextExt, InitOnceId, MutexId, RwLockId},\n     thread::{\n         EvalContextExt as ThreadsEvalContextExt, SchedulingAction, ThreadId, ThreadManager,\n         ThreadState, Time,"}, {"sha": "d998bdf420f6c2b8fe0def72193fb9ad724a7aed", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=3244c117f8b17c27203a625c5b9e3b281ea5debf", "patch": "@@ -261,6 +261,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let ret = this.TryAcquireSRWLockShared(ptr)?;\n                 this.write_scalar(ret, dest)?;\n             }\n+            \"InitOnceBeginInitialize\" => {\n+                let [ptr, flags, pending, context] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let result = this.InitOnceBeginInitialize(ptr, flags, pending, context)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"InitOnceComplete\" => {\n+                let [ptr, flags, context] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+                let result = this.InitOnceComplete(ptr, flags, context)?;\n+                this.write_scalar(result, dest)?;\n+            }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {"}, {"sha": "feed90fad163aa792ff8d929bd7b4cc745bf15e2", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 154, "deletions": 26, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3244c117f8b17c27203a625c5b9e3b281ea5debf/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=3244c117f8b17c27203a625c5b9e3b281ea5debf", "patch": "@@ -1,20 +1,24 @@\n+use crate::concurrency::sync::InitOnceStatus;\n+use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n-// Locks are pointer-sized pieces of data, initialized to 0.\n-// We use the first 4 bytes to store the RwLockId.\n-\n-fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    lock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, RwLockId> {\n-    let value_place = ecx.deref_operand_and_offset(lock_op, 0, ecx.machine.layouts.u32)?;\n+impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    // These synchronization structures are pointer-sized pieces of data, initialized to 0.\n+    // We use the first 4 bytes to store the id.\n+    fn get_or_create_id(\n+        &mut self,\n+        next_id: Scalar<Provenance>,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Option<u32>> {\n+        let this = self.eval_context_mut();\n+        let value_place = this.deref_operand_and_offset(lock_op, 0, this.machine.layouts.u32)?;\n \n-    ecx.rwlock_get_or_create(|ecx, next_id| {\n-        let (old, success) = ecx\n+        let (old, success) = this\n             .atomic_compare_exchange_scalar(\n                 &value_place,\n-                &ImmTy::from_uint(0u32, ecx.machine.layouts.u32),\n-                next_id.to_u32_scalar(),\n+                &ImmTy::from_uint(0u32, this.machine.layouts.u32),\n+                next_id,\n                 AtomicRwOrd::Relaxed,\n                 AtomicReadOrd::Relaxed,\n                 false,\n@@ -25,17 +29,38 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n             // Caller of the closure needs to allocate next_id\n             None\n         } else {\n-            Some(RwLockId::from_u32(old.to_u32().expect(\"layout is u32\")))\n+            Some(old.to_u32().expect(\"layout is u32\"))\n+        })\n+    }\n+\n+    fn srwlock_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, RwLockId> {\n+        let this = self.eval_context_mut();\n+        this.rwlock_get_or_create(|ecx, next_id| {\n+            Ok(ecx.get_or_create_id(next_id.to_u32_scalar(), lock_op)?.map(RwLockId::from_u32))\n+        })\n+    }\n+\n+    fn init_once_get_or_create_id(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, InitOnceId> {\n+        let this = self.eval_context_mut();\n+        this.init_once_get_or_create(|ecx, next_id| {\n+            Ok(ecx.get_or_create_id(next_id.to_u32_scalar(), lock_op)?.map(InitOnceId::from_u32))\n         })\n-    })\n+    }\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+\n+#[allow(non_snake_case)]\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    #[allow(non_snake_case)]\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.srwlock_get_or_create_id(lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -54,13 +79,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn TryAcquireSRWLockExclusive(\n         &mut self,\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.srwlock_get_or_create_id(lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -72,10 +96,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[allow(non_snake_case)]\n     fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.srwlock_get_or_create_id(lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_writer_unlock(id, active_thread) {\n@@ -88,10 +111,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.srwlock_get_or_create_id(lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -103,13 +125,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    #[allow(non_snake_case)]\n     fn TryAcquireSRWLockShared(\n         &mut self,\n         lock_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.srwlock_get_or_create_id(lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -120,10 +141,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n-    #[allow(non_snake_case)]\n     fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let id = this.srwlock_get_or_create_id(lock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if !this.rwlock_reader_unlock(id, active_thread) {\n@@ -135,4 +155,112 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn InitOnceBeginInitialize(\n+        &mut self,\n+        init_once_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        pending_op: &OpTy<'tcx, Provenance>,\n+        context_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+        let active_thread = this.get_active_thread();\n+\n+        let id = this.init_once_get_or_create_id(init_once_op)?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+        let pending_place = this.deref_operand(pending_op)?.into();\n+        let context = this.read_pointer(context_op)?;\n+\n+        if flags != 0 {\n+            throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n+        }\n+\n+        if !this.ptr_is_null(context)? {\n+            throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n+        }\n+\n+        struct Callback<'tcx> {\n+            init_once_id: InitOnceId,\n+            pending_place: PlaceTy<'tcx, Provenance>,\n+        }\n+\n+        impl<'tcx> VisitTags for Callback<'tcx> {\n+            fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                let Callback { init_once_id: _, pending_place } = self;\n+                pending_place.visit_tags(visit);\n+            }\n+        }\n+\n+        impl<'mir, 'tcx> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+            fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                let pending = match this.init_once_status(self.init_once_id) {\n+                    InitOnceStatus::Uninitialized =>\n+                        unreachable!(\"status should have either been set to begun or complete\"),\n+                    InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n+                    InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n+                };\n+\n+                this.write_scalar(pending, &self.pending_place)?;\n+\n+                Ok(())\n+            }\n+        }\n+\n+        match this.init_once_status(id) {\n+            InitOnceStatus::Uninitialized => {\n+                this.init_once_begin(id);\n+                this.write_scalar(this.eval_windows(\"c\", \"TRUE\")?, &pending_place)?;\n+            }\n+            InitOnceStatus::Begun =>\n+                this.init_once_enqueue_and_block(\n+                    id,\n+                    active_thread,\n+                    Box::new(Callback { init_once_id: id, pending_place }),\n+                ),\n+            InitOnceStatus::Complete =>\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?,\n+        }\n+\n+        Ok(Scalar::from_i32(1))\n+    }\n+\n+    fn InitOnceComplete(\n+        &mut self,\n+        init_once_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        context_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let id = this.init_once_get_or_create_id(init_once_op)?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+        let context = this.read_pointer(context_op)?;\n+\n+        let success = if flags == 0 {\n+            true\n+        } else if flags == this.eval_windows(\"c\", \"INIT_ONCE_INIT_FAILED\")?.to_u32()? {\n+            false\n+        } else {\n+            throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n+        };\n+\n+        if !this.ptr_is_null(context)? {\n+            throw_unsup_format!(\"non-null `lpContext` in `InitOnceBeginInitialize`\");\n+        }\n+\n+        if this.init_once_status(id) != InitOnceStatus::Begun {\n+            // The docs do not say anything about this case, but it seems better to not allow it.\n+            throw_ub_format!(\n+                \"calling InitOnceComplete on a one time initialization that has not begun or is already completed\"\n+            );\n+        }\n+\n+        if success {\n+            this.init_once_complete(id)?;\n+        } else {\n+            this.init_once_fail(id)?;\n+        }\n+\n+        Ok(Scalar::from_i32(1))\n+    }\n }"}]}