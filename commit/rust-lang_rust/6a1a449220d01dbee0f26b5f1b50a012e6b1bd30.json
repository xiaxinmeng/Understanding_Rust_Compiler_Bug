{"sha": "6a1a449220d01dbee0f26b5f1b50a012e6b1bd30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMWE0NDkyMjBkMDFkYmVlMGYyNmI1ZjFiNTBhMDEyZTZiMWJkMzA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-10T05:36:51Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-22T09:54:31Z"}, "message": "Error only in the case of overlap", "tree": {"sha": "cc4fec84dfe31ebaa84d6357c0c5d9b2ffe31397", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc4fec84dfe31ebaa84d6357c0c5d9b2ffe31397"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a1a449220d01dbee0f26b5f1b50a012e6b1bd30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1a449220d01dbee0f26b5f1b50a012e6b1bd30", "html_url": "https://github.com/rust-lang/rust/commit/6a1a449220d01dbee0f26b5f1b50a012e6b1bd30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a1a449220d01dbee0f26b5f1b50a012e6b1bd30/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d44910ceeb03b053a8ff641395c4aff505caaaa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d44910ceeb03b053a8ff641395c4aff505caaaa6", "html_url": "https://github.com/rust-lang/rust/commit/d44910ceeb03b053a8ff641395c4aff505caaaa6"}], "stats": {"total": 69, "additions": 49, "deletions": 20}, "files": [{"sha": "5a09197fd41945b5f50bc0e6d9b8f3b1dec780a4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6a1a449220d01dbee0f26b5f1b50a012e6b1bd30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a1a449220d01dbee0f26b5f1b50a012e6b1bd30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6a1a449220d01dbee0f26b5f1b50a012e6b1bd30", "patch": "@@ -856,16 +856,16 @@ impl Clean<Attributes> for [ast::Attribute] {\n                 let def = {\n                     let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) =\n-                        [\"struct\", \"enum\", \"type\",\n-                         \"trait\", \"union\"].iter()\n+                        [\"struct@\", \"enum@\", \"type@\",\n+                         \"trait@\", \"union@\"].iter()\n                                           .find(|p| link.starts_with(**p)) {\n                         kind = PathKind::Type;\n-                        link.trim_left_matches(prefix).trim_left_matches('@')\n+                        link.trim_left_matches(prefix)\n                     } else if let Some(prefix) =\n-                        [\"const\", \"static\"].iter()\n+                        [\"const@\", \"static@\"].iter()\n                                            .find(|p| link.starts_with(**p)) {\n                         kind = PathKind::Value;\n-                        link.trim_left_matches(prefix).trim_left_matches('@')\n+                        link.trim_left_matches(prefix)\n                     } else if link.ends_with(\"()\") {\n                         kind = PathKind::Value;\n                         link.trim_right_matches(\"()\")\n@@ -923,24 +923,53 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             // try both!\n                             // It is imperative we search for not-a-value first\n                             // Otherwise we will find struct ctors for when we are looking\n-                            // for structs, etc, and the link won't work.\n+                            // for structs, and the link won't work.\n                             if let Ok(path) = resolve(false) {\n+                                // if there is something in both namespaces\n+                                if let Ok(value_path) = resolve(true) {\n+                                    let kind = match value_path.def {\n+                                        // structs and mods exist in both namespaces. skip them\n+                                        Def::StructCtor(..) | Def::Mod(..) => None,\n+                                        Def::Variant(..) | Def::VariantCtor(..)\n+                                            => Some((\"variant\", format!(\"{}()\", path_str))),\n+                                        Def::Fn(..)\n+                                            => Some((\"function\", format!(\"{}()\", path_str))),\n+                                        Def::Method(..)\n+                                            => Some((\"method\", format!(\"{}()\", path_str))),\n+                                        Def::Const(..)\n+                                            => Some((\"const\", format!(\"const@{}\", path_str))),\n+                                        Def::Static(..)\n+                                            => Some((\"static\", format!(\"static@{}\", path_str))),\n+                                        _ => Some((\"value\", format!(\"static@{}\", path_str))),\n+                                    };\n+                                    if let Some((value_kind, disambig)) = kind {\n+                                        let (type_kind, article) = match path.def {\n+                                            // we can still have non-tuple structs\n+                                            Def::Struct(..) => (\"struct\", \"a\"),\n+                                            Def::Enum(..) => (\"enum\", \"an\"),\n+                                            Def::Trait(..) => (\"trait\", \"a\"),\n+                                            Def::Union(..) => (\"union\", \"a\"),\n+                                            _ => (\"type\", \"a\"),\n+                                        };\n+                                        let sp = attrs.doc_strings.first()\n+                                                      .map_or(DUMMY_SP, |a| a.span());\n+                                        cx.sess()\n+                                          .struct_span_err(sp,\n+                                                           &format!(\"`{}` is both {} {} and a {}\",\n+                                                                    path_str, article, type_kind,\n+                                                                    value_kind))\n+                                          .help(&format!(\"try `{0}` if you want to select the {1}, \\\n+                                                          or `{2}@{3}` if you want to \\\n+                                                          select the {2}\",\n+                                                          disambig, value_kind, type_kind,\n+                                                          path_str))\n+                                                 .emit();\n+                                        continue;\n+                                    }\n+                                }\n                                 path.def\n                             } else if let Ok(path) = resolve(true) {\n-                                let kind = match path.def {\n-                                    Def::Variant(..) | Def::VariantCtor(..) => (\"variant\", format!(\"{}()\", path_str)),\n-                                    Def::Fn(..) => (\"function\", format!(\"{}()\", path_str)),\n-                                    Def::Method(..) => (\"method\", format!(\"{}()\", path_str)),\n-                                    Def::Const(..) => (\"const\", format!(\"const@{}\", path_str)),\n-                                    Def::Static(..) => (\"static\", format!(\"static@{}\", path_str)),\n-                                    _ => (\"value\", format!(\"static@{}\", path_str)),\n-                                };\n-                                let sp = attrs.doc_strings.first().map_or(DUMMY_SP, |a| a.span());\n-                                cx.sess().struct_span_err(sp, &format!(\"could not resolve `{}` as a type, it is a {}\",\n-                                                                       path_str, kind.0))\n-                                         .help(&format!(\"try `{}`\", kind.1))\n-                                         .emit();\n-                                continue;\n+                                path.def\n                             } else {\n                                 // this could just be a normal link\n                                 continue;"}]}