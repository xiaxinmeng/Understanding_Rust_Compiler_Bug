{"sha": "a49ad47e5afa5950f92b77badc6679295101328a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OWFkNDdlNWFmYTU5NTBmOTJiNzdiYWRjNjY3OTI5NTEwMTMyOGE=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-30T09:47:17Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-10-02T18:28:02Z"}, "message": "Support cfg attribute on impl blocks", "tree": {"sha": "dfb48fb37c1db1ecbcfb7bf75f5acf0f9023d29d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb48fb37c1db1ecbcfb7bf75f5acf0f9023d29d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49ad47e5afa5950f92b77badc6679295101328a", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2U7DIACgkQztOS3gxI\nPQBkqhAAmwojrI+nRJ6Un6UPCO9lLLAJOmZNn9+/lC1yURAgc8LPqQdeXr+ZhTmt\nTbTmWB8PUlDL5AhMiZDdYzYPTbG8qqZImNfvMTPNlJKqWV7y1hzxSNxZLUx694k1\npqKLQy6Oj9p+MF0p9d9TlTgOWnTuExBruD5HjsMs7erFbA9zLXfHO2PyCZrqO8R8\nRh0UHBZYkBfYd66qOZtk598hs6SjunPSBIUstO+M2Zk/EhH9Q9Uof9FlJBMzpLyo\nH3i5J9Bmc9LZ5qz95h9mYPWucqKJBl/hsoT0VfCQO3obvHVjyvhj+f4awNLDufjT\nVB/qOp7/B2NOg0E+Y4ZjgM6UXRbNF9SqekTH/ZRevcEGqnIHyCDGkbywef9cV98I\nOh+CmCg2PeD+B6sD9KMpRB0qo1aNYzfWAvgYkFCbnW+204PhadGp1cnfOnOBS63Q\nHm55B5YikFuBmyT1MC0/5PWjjucG3lZQw+v2mo12z7K9yAufUzldmhUCfkJc05E8\nCtEG7cKqZ0pPXccKB2AtfcIUW2kR6tDtYpGNhkEoOf7346BnmSwyn2It5lSVhlrc\nOTUqKCgwNVd86qNsaVe+hlUE5UniZv84fxalzwjIajFM7hNSjzUjjinBMSY+hMza\nglZ/h2ZvdtDIJ9bRZhouVNELVAwDgFYNxYMdrzhDUi5wNmqPtjs=\n=MW4Z\n-----END PGP SIGNATURE-----", "payload": "tree dfb48fb37c1db1ecbcfb7bf75f5acf0f9023d29d\nparent d2ea776b8fbb5286a04dde75a9a8f8b14f12bfe9\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1569836837 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1570040882 +0800\n\nSupport cfg attribute on impl blocks\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49ad47e5afa5950f92b77badc6679295101328a", "html_url": "https://github.com/rust-lang/rust/commit/a49ad47e5afa5950f92b77badc6679295101328a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49ad47e5afa5950f92b77badc6679295101328a/comments", "author": null, "committer": null, "parents": [{"sha": "d2ea776b8fbb5286a04dde75a9a8f8b14f12bfe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2ea776b8fbb5286a04dde75a9a8f8b14f12bfe9", "html_url": "https://github.com/rust-lang/rust/commit/d2ea776b8fbb5286a04dde75a9a8f8b14f12bfe9"}], "stats": {"total": 103, "additions": 90, "deletions": 13}, "files": [{"sha": "84c36b8daa00e2054dab0bda61997fd1f306d9c3", "filename": "crates/ra_hir/src/attr.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fattr.rs?ref=a49ad47e5afa5950f92b77badc6679295101328a", "patch": "@@ -1,11 +1,14 @@\n+use std::sync::Arc;\n+\n use mbe::ast_to_token_tree;\n+use ra_cfg::CfgOptions;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n };\n use tt::Subtree;\n \n-use crate::{db::AstDatabase, path::Path, Source};\n+use crate::{db::AstDatabase, path::Path, HirFileId, Source};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub(crate) struct Attr {\n@@ -40,6 +43,14 @@ impl Attr {\n         Some(Attr { path, input })\n     }\n \n+    pub(crate) fn from_attrs_owner(\n+        file_id: HirFileId,\n+        owner: &impl AttrsOwner,\n+        db: &impl AstDatabase,\n+    ) -> Arc<[Attr]> {\n+        owner.attrs().flat_map(|ast| Attr::from_src(Source { file_id, ast }, db)).collect()\n+    }\n+\n     pub(crate) fn is_simple_atom(&self, name: &str) -> bool {\n         // FIXME: Avoid cloning\n         self.path.as_ident().map_or(false, |s| s.to_string() == name)\n@@ -55,4 +66,8 @@ impl Attr {\n             None\n         }\n     }\n+\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> Option<bool> {\n+        cfg_options.is_cfg_enabled(self.as_cfg()?)\n+    }\n }"}, {"sha": "7877c317165f5b8bb3884079c966fe8f15729678", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=a49ad47e5afa5950f92b77badc6679295101328a", "patch": "@@ -4,12 +4,14 @@ use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n+use ra_cfg::CfgOptions;\n use ra_syntax::{\n     ast::{self, AstNode},\n     AstPtr,\n };\n \n use crate::{\n+    attr::Attr,\n     code_model::{Module, ModuleSource},\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     generics::HasGenericParams,\n@@ -176,6 +178,7 @@ pub struct ModuleImplBlocks {\n impl ModuleImplBlocks {\n     fn collect(\n         db: &(impl DefDatabase + AstDatabase),\n+        cfg_options: &CfgOptions,\n         module: Module,\n         source_map: &mut ImplSourceMap,\n     ) -> Self {\n@@ -188,11 +191,11 @@ impl ModuleImplBlocks {\n         let src = m.module.definition_source(db);\n         match &src.ast {\n             ModuleSource::SourceFile(node) => {\n-                m.collect_from_item_owner(db, source_map, node, src.file_id)\n+                m.collect_from_item_owner(db, cfg_options, source_map, node, src.file_id)\n             }\n             ModuleSource::Module(node) => {\n                 let item_list = node.item_list().expect(\"inline module should have item list\");\n-                m.collect_from_item_owner(db, source_map, &item_list, src.file_id)\n+                m.collect_from_item_owner(db, cfg_options, source_map, &item_list, src.file_id)\n             }\n         };\n         m\n@@ -201,13 +204,19 @@ impl ModuleImplBlocks {\n     fn collect_from_item_owner(\n         &mut self,\n         db: &(impl DefDatabase + AstDatabase),\n+        cfg_options: &CfgOptions,\n         source_map: &mut ImplSourceMap,\n         owner: &dyn ast::ModuleItemOwner,\n         file_id: HirFileId,\n     ) {\n         for item in owner.items_with_macros() {\n             match item {\n                 ast::ItemOrMacro::Item(ast::ModuleItem::ImplBlock(impl_block_ast)) => {\n+                    let attrs = Attr::from_attrs_owner(file_id, &impl_block_ast, db);\n+                    if attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false)) {\n+                        continue;\n+                    }\n+\n                     let impl_block = ImplData::from_ast(db, file_id, self.module, &impl_block_ast);\n                     let id = self.impls.alloc(impl_block);\n                     for &impl_item in &self.impls[id].items {\n@@ -218,6 +227,11 @@ impl ModuleImplBlocks {\n                 }\n                 ast::ItemOrMacro::Item(_) => (),\n                 ast::ItemOrMacro::Macro(macro_call) => {\n+                    let attrs = Attr::from_attrs_owner(file_id, &macro_call, db);\n+                    if attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false)) {\n+                        continue;\n+                    }\n+\n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n                     let ast_id = db.ast_id_map(file_id).ast_id(&macro_call).with_file_id(file_id);\n                     if let Some(path) = macro_call\n@@ -231,7 +245,13 @@ impl ModuleImplBlocks {\n                             if let Some(item_list) =\n                                 db.parse_or_expand(file_id).and_then(ast::MacroItems::cast)\n                             {\n-                                self.collect_from_item_owner(db, source_map, &item_list, file_id)\n+                                self.collect_from_item_owner(\n+                                    db,\n+                                    cfg_options,\n+                                    source_map,\n+                                    &item_list,\n+                                    file_id,\n+                                )\n                             }\n                         }\n                     }\n@@ -246,8 +266,10 @@ pub(crate) fn impls_in_module_with_source_map_query(\n     module: Module,\n ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n     let mut source_map = ImplSourceMap::default();\n+    let crate_graph = db.crate_graph();\n+    let cfg_options = crate_graph.cfg_options(module.krate.crate_id());\n \n-    let result = ModuleImplBlocks::collect(db, module, &mut source_map);\n+    let result = ModuleImplBlocks::collect(db, cfg_options, module, &mut source_map);\n     (Arc::new(result), Arc::new(source_map))\n }\n "}, {"sha": "1d79cbd8c8a5147da47f707496eaf0b46d1c853e", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=a49ad47e5afa5950f92b77badc6679295101328a", "patch": "@@ -716,10 +716,7 @@ where\n     }\n \n     fn is_cfg_enabled(&self, attrs: &[Attr]) -> bool {\n-        attrs\n-            .iter()\n-            .flat_map(|attr| attr.as_cfg())\n-            .all(|cfg| self.def_collector.cfg_options.is_cfg_enabled(cfg).unwrap_or(true))\n+        attrs.iter().all(|attr| attr.is_cfg_enabled(&self.def_collector.cfg_options) != Some(false))\n     }\n }\n "}, {"sha": "f02d4eb7a8ac81794d8cb2e6d1468a27a26c8275", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=a49ad47e5afa5950f92b77badc6679295101328a", "patch": "@@ -411,9 +411,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     }\n \n     fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Arc<[Attr]> {\n-        item.attrs()\n-            .flat_map(|ast| Attr::from_src(Source { ast, file_id: self.file_id }, self.db))\n-            .collect()\n+        Attr::from_attrs_owner(self.file_id, item, self.db)\n     }\n }\n "}, {"sha": "171aead184186070912553bd0c2bc34d65438106", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49ad47e5afa5950f92b77badc6679295101328a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=a49ad47e5afa5950f92b77badc6679295101328a", "patch": "@@ -3,6 +3,7 @@ use std::sync::Arc;\n \n use insta::assert_snapshot;\n \n+use ra_cfg::CfgOptions;\n use ra_db::{salsa::Database, FilePosition, SourceDatabase};\n use ra_syntax::{\n     algo,\n@@ -23,6 +24,50 @@ use crate::{\n mod never_type;\n mod coercion;\n \n+#[test]\n+fn cfg_impl_block() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+use foo::S as T;\n+struct S;\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo1(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo2(&self) -> i32 { 0 }\n+}\n+\n+fn test() {\n+    let t = (S.foo1(), S.foo2(), T.foo3(), T.foo4());\n+    t<|>;\n+}\n+\n+//- /foo.rs\n+struct S;\n+\n+#[cfg(not(test))]\n+impl S {\n+    fn foo3(&self) -> i32 { 0 }\n+}\n+\n+#[cfg(test)]\n+impl S {\n+    fn foo4(&self) -> i32 { 0 }\n+}\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"foo\"], CfgOptions::default().atom(\"test\".into())),\n+        \"foo\": (\"/foo.rs\", []),\n+    });\n+    assert_eq!(\"(i32, {unknown}, i32, {unknown})\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_await() {\n     let (mut db, pos) = MockDatabase::with_position("}]}