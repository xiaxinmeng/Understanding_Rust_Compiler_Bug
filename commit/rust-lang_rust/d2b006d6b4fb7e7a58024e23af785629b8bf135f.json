{"sha": "d2b006d6b4fb7e7a58024e23af785629b8bf135f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyYjAwNmQ2YjRmYjdlN2E1ODAyNGUyM2FmNzg1NjI5YjhiZjEzNWY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-12-10T19:53:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-10T19:53:23Z"}, "message": "Merge pull request #2255 from topecongiro/nested-imports\n\nNested imports", "tree": {"sha": "22f802ca6b001519698e26a4865d906f9f066535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22f802ca6b001519698e26a4865d906f9f066535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2b006d6b4fb7e7a58024e23af785629b8bf135f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaLZCzCRBK7hj4Ov3rIwAAdHIIAKu62G8RuJI34tqhF1U2Nr9i\ngx9LJ+YNOOeV5m9qzeBPCg6msBweurBaf1D5KZroOKG8OPAElZnIhkfqfsOdlFXw\n1TOARHI8RrLhCUHWfH/h33SadYpozfDQjaiVQXe7ehPSBUCGcV14n1ivx6pYUfXL\n4WXDVOiN62e3fSCq3dVxdBemm8Jgs9GUesgQ9IwLg2w9AyIH+YJAuzmy0UBEj38Z\nZ5Gw6+m3F1fwxqa+FsK5C/P+lq/Xd2tPZeG/cXWLsxZgp2vwnsNWx7Ng+U9uuFZl\nAe233P4gtiCtecTDwxhkUsNUC0xGb5b4wYcKIWCxEEIzTZ4vgCxxiR/QxAxqsVM=\n=X82E\n-----END PGP SIGNATURE-----\n", "payload": "tree 22f802ca6b001519698e26a4865d906f9f066535\nparent 68b43b2240fe03edab4d0951a1d4c9bb04b559f4\nparent 234c7da87194a6a5934469d135c15f9d1127ed6c\nauthor Nick Cameron <nrc@ncameron.org> 1512935603 +1300\ncommitter GitHub <noreply@github.com> 1512935603 +1300\n\nMerge pull request #2255 from topecongiro/nested-imports\n\nNested imports"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b006d6b4fb7e7a58024e23af785629b8bf135f", "html_url": "https://github.com/rust-lang/rust/commit/d2b006d6b4fb7e7a58024e23af785629b8bf135f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2b006d6b4fb7e7a58024e23af785629b8bf135f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b43b2240fe03edab4d0951a1d4c9bb04b559f4", "html_url": "https://github.com/rust-lang/rust/commit/68b43b2240fe03edab4d0951a1d4c9bb04b559f4"}, {"sha": "234c7da87194a6a5934469d135c15f9d1127ed6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/234c7da87194a6a5934469d135c15f9d1127ed6c", "html_url": "https://github.com/rust-lang/rust/commit/234c7da87194a6a5934469d135c15f9d1127ed6c"}], "stats": {"total": 179, "additions": 113, "deletions": 66}, "files": [{"sha": "b8a7e3bb6ba36bc1e7a9f01b7e264f9bf1223361", "filename": "src/imports.rs", "status": "modified", "additions": 87, "deletions": 66, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/d2b006d6b4fb7e7a58024e23af785629b8bf135f/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b006d6b4fb7e7a58024e23af785629b8bf135f/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=d2b006d6b4fb7e7a58024e23af785629b8bf135f", "patch": "@@ -53,8 +53,8 @@ fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Orderi\n \n     match (&a.kind, &b.kind) {\n         (&Simple(ident_a), &Simple(ident_b)) => {\n-            let name_a = &*a.prefix.segments.last().unwrap().identifier.name.as_str();\n-            let name_b = &*b.prefix.segments.last().unwrap().identifier.name.as_str();\n+            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n+            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n             let name_ordering = if name_a == \"self\" {\n                 if name_b == \"self\" {\n                     Ordering::Equal\n@@ -121,18 +121,15 @@ fn compare_use_items(context: &RewriteContext, a: &ast::Item, b: &ast::Item) ->\n // imports into a list import.\n \n fn rewrite_prefix(path: &ast::Path, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let path_str = if path.segments.last().unwrap().identifier.to_string() == \"self\"\n-        && path.segments.len() > 1\n-    {\n+    if path.segments.len() > 1 && path_to_imported_ident(path).to_string() == \"self\" {\n         let path = &ast::Path {\n             span: path.span,\n             segments: path.segments[..path.segments.len() - 1].to_owned(),\n         };\n-        rewrite_path(context, PathContext::Import, None, path, shape)?\n+        rewrite_path(context, PathContext::Import, None, path, shape)\n     } else {\n-        rewrite_path(context, PathContext::Import, None, path, shape)?\n-    };\n-    Some(path_str)\n+        rewrite_path(context, PathContext::Import, None, path, shape)\n+    }\n }\n \n impl Rewrite for ast::UseTree {\n@@ -155,10 +152,16 @@ impl Rewrite for ast::UseTree {\n                 let ident_str = ident.to_string();\n \n                 // 4 = \" as \".len()\n-                let prefix_shape = shape.sub_width(ident_str.len() + 4)?;\n-                let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)?;\n+                let is_same_name_bind = path_to_imported_ident(&self.prefix) == ident;\n+                let prefix_shape = if is_same_name_bind {\n+                    shape\n+                } else {\n+                    shape.sub_width(ident_str.len() + 4)?\n+                };\n+                let path_str = rewrite_prefix(&self.prefix, context, prefix_shape)\n+                    .unwrap_or_else(|| context.snippet(self.prefix.span).to_owned());\n \n-                if self.prefix.segments.last().unwrap().identifier == ident {\n+                if is_same_name_bind {\n                     Some(path_str)\n                 } else {\n                     Some(format!(\"{} as {}\", path_str, ident_str))\n@@ -168,6 +171,21 @@ impl Rewrite for ast::UseTree {\n     }\n }\n \n+fn is_unused_import(tree: &ast::UseTree, attrs: &[ast::Attribute]) -> bool {\n+    attrs.is_empty() && is_unused_import_inner(tree)\n+}\n+\n+fn is_unused_import_inner(tree: &ast::UseTree) -> bool {\n+    match tree.kind {\n+        ast::UseTreeKind::Nested(ref items) => match items.len() {\n+            0 => true,\n+            1 => is_unused_import_inner(&items[0].0),\n+            _ => false,\n+        },\n+        _ => false,\n+    }\n+}\n+\n // Rewrite `use foo;` WITHOUT attributes.\n fn rewrite_import(\n     context: &RewriteContext,\n@@ -181,12 +199,13 @@ fn rewrite_import(\n     let rw = shape\n         .offset_left(vis.len() + 4)\n         .and_then(|shape| shape.sub_width(1))\n-        .and_then(|shape| match tree.kind {\n+        .and_then(|shape| {\n             // If we have an empty nested group with no attributes, we erase it\n-            ast::UseTreeKind::Nested(ref items) if items.is_empty() && attrs.is_empty() => {\n+            if is_unused_import(tree, attrs) {\n                 Some(\"\".to_owned())\n+            } else {\n+                tree.rewrite(context, shape)\n             }\n-            _ => tree.rewrite(context, shape),\n         });\n     match rw {\n         Some(ref s) if !s.is_empty() => Some(format!(\"{}use {};\", vis, s)),\n@@ -296,48 +315,45 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-fn rewrite_nested_use_tree_single(path_str: String, tree: &ast::UseTree) -> String {\n-    if let ast::UseTreeKind::Simple(rename) = tree.kind {\n-        let ident = tree.prefix.segments.last().unwrap().identifier;\n-        let mut item_str = ident.name.to_string();\n-        if item_str == \"self\" {\n-            item_str = \"\".to_owned();\n-        }\n+fn rewrite_nested_use_tree_single(\n+    context: &RewriteContext,\n+    path_str: &str,\n+    tree: &ast::UseTree,\n+    shape: Shape,\n+) -> Option<String> {\n+    match tree.kind {\n+        ast::UseTreeKind::Simple(rename) => {\n+            let ident = path_to_imported_ident(&tree.prefix);\n+            let mut item_str = rewrite_prefix(&tree.prefix, context, shape)?;\n+            if item_str == \"self\" {\n+                item_str = \"\".to_owned();\n+            }\n \n-        let path_item_str = if path_str.is_empty() {\n-            if item_str.is_empty() {\n-                \"self\".to_owned()\n+            let path_item_str = if path_str.is_empty() {\n+                if item_str.is_empty() {\n+                    \"self\".to_owned()\n+                } else {\n+                    item_str\n+                }\n+            } else if item_str.is_empty() {\n+                path_str.to_owned()\n             } else {\n-                item_str\n-            }\n-        } else if item_str.is_empty() {\n-            path_str\n-        } else {\n-            format!(\"{}::{}\", path_str, item_str)\n-        };\n+                format!(\"{}::{}\", path_str, item_str)\n+            };\n \n-        if ident == rename {\n-            path_item_str\n-        } else {\n-            format!(\"{} as {}\", path_item_str, rename)\n+            Some(if ident == rename {\n+                path_item_str\n+            } else {\n+                format!(\"{} as {}\", path_item_str, rename)\n+            })\n         }\n-    } else {\n-        unimplemented!(\"`use_nested_groups` is not yet fully supported\");\n-    }\n-}\n-\n-fn rewrite_nested_use_tree_item(tree: &&ast::UseTree) -> Option<String> {\n-    Some(if let ast::UseTreeKind::Simple(rename) = tree.kind {\n-        let ident = tree.prefix.segments.last().unwrap().identifier;\n-\n-        if ident == rename {\n-            ident.name.to_string()\n-        } else {\n-            format!(\"{} as {}\", ident.name.to_string(), rename)\n+        ast::UseTreeKind::Glob | ast::UseTreeKind::Nested(..) => {\n+            // 2 = \"::\"\n+            let nested_shape = shape.offset_left(path_str.len() + 2)?;\n+            tree.rewrite(context, nested_shape)\n+                .map(|item| format!(\"{}::{}\", path_str, item))\n         }\n-    } else {\n-        unimplemented!(\"`use_nested_groups` is not yet fully supported\");\n-    })\n+    }\n }\n \n #[derive(Eq, PartialEq)]\n@@ -426,11 +442,13 @@ fn rewrite_nested_use_tree(\n \n     match trees.len() {\n         0 => {\n+            let shape = shape.offset_left(path_str.len() + 3)?;\n             return rewrite_path(context, PathContext::Import, None, path, shape)\n                 .map(|path_str| format!(\"{}::{{}}\", path_str));\n         }\n-        // TODO: fix this\n-        1 => return Some(rewrite_nested_use_tree_single(path_str, &trees[0].0)),\n+        1 => {\n+            return rewrite_nested_use_tree_single(context, &path_str, &trees[0].0, shape);\n+        }\n         _ => (),\n     }\n \n@@ -442,6 +460,16 @@ fn rewrite_nested_use_tree(\n \n     // 2 = \"{}\"\n     let remaining_width = shape.width.checked_sub(path_str.len() + 2).unwrap_or(0);\n+    let nested_indent = match context.config.imports_indent() {\n+        IndentStyle::Block => shape.indent.block_indent(context.config),\n+        // 1 = `{`\n+        IndentStyle::Visual => shape.visual_indent(path_str.len() + 1).indent,\n+    };\n+\n+    let nested_shape = match context.config.imports_indent() {\n+        IndentStyle::Block => Shape::indented(nested_indent, context.config).sub_width(1)?,\n+        IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n+    };\n \n     let mut items = {\n         // Dummy value, see explanation below.\n@@ -453,7 +481,7 @@ fn rewrite_nested_use_tree(\n             \",\",\n             |tree| tree.span.lo(),\n             |tree| tree.span.hi(),\n-            rewrite_nested_use_tree_item,\n+            |tree| tree.rewrite(context, nested_shape),\n             context.codemap.span_after(span, \"{\"),\n             span.hi(),\n             false,\n@@ -483,17 +511,6 @@ fn rewrite_nested_use_tree(\n         remaining_width,\n     );\n \n-    let nested_indent = match context.config.imports_indent() {\n-        IndentStyle::Block => shape.indent.block_indent(context.config),\n-        // 1 = `{`\n-        IndentStyle::Visual => shape.visual_indent(path_str.len() + 1).indent,\n-    };\n-\n-    let nested_shape = match context.config.imports_indent() {\n-        IndentStyle::Block => Shape::indented(nested_indent, context.config),\n-        IndentStyle::Visual => Shape::legacy(remaining_width, nested_indent),\n-    };\n-\n     let ends_with_newline = context.config.imports_indent() == IndentStyle::Block\n         && tactic != DefinitiveListTactic::Horizontal;\n \n@@ -541,3 +558,7 @@ fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n         None => false,\n     }\n }\n+\n+fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n+    path.segments.last().unwrap().identifier\n+}"}, {"sha": "73d1419f47d2ae66dfaf7bee6ff951ff57bafce2", "filename": "tests/source/imports.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2b006d6b4fb7e7a58024e23af785629b8bf135f/tests%2Fsource%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b006d6b4fb7e7a58024e23af785629b8bf135f/tests%2Fsource%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimports.rs?ref=d2b006d6b4fb7e7a58024e23af785629b8bf135f", "patch": "@@ -76,3 +76,14 @@ use foo::issue_1356:: * ;\n // We shouldn't remove imports which have attributes attached (#1858)\n #[cfg(unix)]\n use self::unix::{};\n+\n+// nested imports\n+use foo::{a, bar::{baz, qux, xxxxxxxxxxx, yyyyyyyyyyyyy, zzzzzzzzzzzzzzzz, foo::{a, b, cxxxxxxxxxxxxx, yyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz}}, b, boo, c,};\n+\n+use fooo::{baar::{foobar::{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz}}, z, bar, bar::*, x, y};\n+\n+// nested imports with a single sub-tree.\n+use a::{b::{c::*}};\n+use a::{b::{c::{}}};\n+use a::{b::{c::d}};\n+use a::{b::{c::{xxx, yyy, zzz}}};"}, {"sha": "2b8255261990dd43764e18d1015641332809a403", "filename": "tests/target/imports.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d2b006d6b4fb7e7a58024e23af785629b8bf135f/tests%2Ftarget%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b006d6b4fb7e7a58024e23af785629b8bf135f/tests%2Ftarget%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimports.rs?ref=d2b006d6b4fb7e7a58024e23af785629b8bf135f", "patch": "@@ -71,3 +71,18 @@ use foo::issue_1356::*;\n // We shouldn't remove imports which have attributes attached (#1858)\n #[cfg(unix)]\n use self::unix::{};\n+\n+// nested imports\n+use foo::{a, b, boo, c,\n+          bar::{baz, qux, xxxxxxxxxxx, yyyyyyyyyyyyy, zzzzzzzzzzzzzzzz,\n+                foo::{a, b, cxxxxxxxxxxxxx, yyyyyyyyyyyyyy, zzzzzzzzzzzzzzzz}}};\n+\n+use fooo::{bar, x, y, z,\n+           baar::foobar::{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+                          zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz},\n+           bar::*};\n+\n+// nested imports with a single sub-tree.\n+use a::b::c::*;\n+use a::b::c::d;\n+use a::b::c::{xxx, yyy, zzz};"}]}