{"sha": "4aae835803037e578baa19e5a4982177f5444c26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYWU4MzU4MDMwMzdlNTc4YmFhMTllNWE0OTgyMTc3ZjU0NDRjMjY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-27T08:00:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-12-28T09:29:20Z"}, "message": "rustc: always print nested nodes where a HIR map is available.", "tree": {"sha": "df7fbfc49fb47139bea211ddf326fb960fd3eb26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df7fbfc49fb47139bea211ddf326fb960fd3eb26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aae835803037e578baa19e5a4982177f5444c26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aae835803037e578baa19e5a4982177f5444c26", "html_url": "https://github.com/rust-lang/rust/commit/4aae835803037e578baa19e5a4982177f5444c26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aae835803037e578baa19e5a4982177f5444c26/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f64e73b6ec130a5323f997b476c2a8a43afb6c94", "url": "https://api.github.com/repos/rust-lang/rust/commits/f64e73b6ec130a5323f997b476c2a8a43afb6c94", "html_url": "https://github.com/rust-lang/rust/commit/f64e73b6ec130a5323f997b476c2a8a43afb6c94"}], "stats": {"total": 623, "additions": 245, "deletions": 378}, "files": [{"sha": "27ebeea9ad91db21f18d477684a6288f5a699365", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 46, "deletions": 25, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::Span;\n \n use hir::*;\n use hir::intravisit::Visitor;\n-use hir::print as pprust;\n+use hir::print::Nested;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n@@ -842,6 +842,10 @@ impl<'ast> Map<'ast> {\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n+\n+    pub fn node_to_pretty_string(&self, id: NodeId) -> String {\n+        print::to_string(self, |s| s.print_node(self.get(id)))\n+    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n@@ -1004,13 +1008,23 @@ pub fn map_decoded_body<'ast>(map: &Map<'ast>,\n     &ii.body\n }\n \n-pub trait NodePrinter {\n-    fn print_node(&mut self, node: &Node) -> io::Result<()>;\n+/// Identical to the `PpAnn` implementation for `hir::Crate`,\n+/// except it avoids creating a dependency on the whole crate.\n+impl<'ast> print::PpAnn for Map<'ast> {\n+    fn nested(&self, state: &mut print::State, nested: print::Nested) -> io::Result<()> {\n+        match nested {\n+            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n+            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n+            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n+            Nested::Body(id) => state.print_expr(&self.body(id).value),\n+            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+        }\n+    }\n }\n \n-impl<'a> NodePrinter for pprust::State<'a> {\n-    fn print_node(&mut self, node: &Node) -> io::Result<()> {\n-        match *node {\n+impl<'a> print::State<'a> {\n+    pub fn print_node(&mut self, node: Node) -> io::Result<()> {\n+        match node {\n             NodeItem(a)        => self.print_item(&a),\n             NodeForeignItem(a) => self.print_foreign_item(&a),\n             NodeTraitItem(a)   => self.print_trait_item(a),\n@@ -1020,16 +1034,24 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodeStmt(a)        => self.print_stmt(&a),\n             NodeTy(a)          => self.print_type(&a),\n             NodeTraitRef(a)    => self.print_trait_ref(&a),\n+            NodeLocal(a)       |\n             NodePat(a)         => self.print_pat(&a),\n-            NodeBlock(a)       => self.print_block(&a),\n+            NodeBlock(a)       => {\n+                use syntax::print::pprust::PrintState;\n+\n+                // containing cbox, will be closed by print-block at }\n+                self.cbox(print::indent_unit)?;\n+                // head-ibox, will be closed by print-block after {\n+                self.ibox(0)?;\n+                self.print_block(&a)\n+            }\n             NodeLifetime(a)    => self.print_lifetime(&a),\n             NodeVisibility(a)  => self.print_visibility(&a),\n             NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n             NodeField(_)       => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n-            NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n         }\n     }\n@@ -1110,33 +1132,32 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     field.name,\n                     path_str(), id_str)\n         }\n-        Some(NodeExpr(ref expr)) => {\n-            format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n+        Some(NodeExpr(_)) => {\n+            format!(\"expr {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeStmt(ref stmt)) => {\n-            format!(\"stmt {}{}\", pprust::stmt_to_string(&stmt), id_str)\n+        Some(NodeStmt(_)) => {\n+            format!(\"stmt {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTy(ref ty)) => {\n-            format!(\"type {}{}\", pprust::ty_to_string(&ty), id_str)\n+        Some(NodeTy(_)) => {\n+            format!(\"type {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeTraitRef(ref tr)) => {\n-            format!(\"trait_ref {}{}\", pprust::path_to_string(&tr.path), id_str)\n+        Some(NodeTraitRef(_)) => {\n+            format!(\"trait_ref {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeLocal(ref pat)) => {\n-            format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n+        Some(NodeLocal(_)) => {\n+            format!(\"local {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodePat(ref pat)) => {\n-            format!(\"pat {}{}\", pprust::pat_to_string(&pat), id_str)\n+        Some(NodePat(_)) => {\n+            format!(\"pat {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n-        Some(NodeBlock(ref block)) => {\n-            format!(\"block {}{}\", pprust::block_to_string(&block), id_str)\n+        Some(NodeBlock(_)) => {\n+            format!(\"block {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", path_str(), id_str)\n         }\n-        Some(NodeLifetime(ref l)) => {\n-            format!(\"lifetime {}{}\",\n-                    pprust::lifetime_to_string(&l), id_str)\n+        Some(NodeLifetime(_)) => {\n+            format!(\"lifetime {}{}\", map.node_to_pretty_string(id), id_str)\n         }\n         Some(NodeTyParam(ref ty_param)) => {\n             format!(\"typaram {:?}{}\", ty_param, id_str)"}, {"sha": "f76c29ea1c9dcce42871a55f50e6b7b1745635e2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -85,7 +85,7 @@ impl fmt::Debug for Lifetime {\n         write!(f,\n                \"lifetime({}: {})\",\n                self.id,\n-               print::lifetime_to_string(self))\n+               print::to_string(print::NO_ANN, |s| s.print_lifetime(self)))\n     }\n }\n \n@@ -117,13 +117,8 @@ impl Path {\n \n impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"path({})\", print::path_to_string(self))\n-    }\n-}\n-\n-impl fmt::Display for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", print::path_to_string(self))\n+        write!(f, \"path({})\",\n+               print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n     }\n }\n \n@@ -510,7 +505,8 @@ pub struct Pat {\n \n impl fmt::Debug for Pat {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"pat({}: {})\", self.id, print::pat_to_string(self))\n+        write!(f, \"pat({}: {})\", self.id,\n+               print::to_string(print::NO_ANN, |s| s.print_pat(self)))\n     }\n }\n \n@@ -762,7 +758,7 @@ impl fmt::Debug for Stmt_ {\n         write!(f,\n                \"stmt({}: {})\",\n                spanned.node.id(),\n-               print::stmt_to_string(&spanned))\n+               print::to_string(print::NO_ANN, |s| s.print_stmt(&spanned)))\n     }\n }\n \n@@ -891,7 +887,8 @@ pub struct Expr {\n \n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"expr({}: {})\", self.id, print::expr_to_string(self))\n+        write!(f, \"expr({}: {})\", self.id,\n+               print::to_string(print::NO_ANN, |s| s.print_expr(self)))\n     }\n }\n \n@@ -1015,12 +1012,6 @@ pub enum QPath {\n     TypeRelative(P<Ty>, P<PathSegment>)\n }\n \n-impl fmt::Display for QPath {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", print::qpath_to_string(self))\n-    }\n-}\n-\n /// Hints at the original code for a `match _ { .. }`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n@@ -1177,7 +1168,8 @@ pub struct Ty {\n \n impl fmt::Debug for Ty {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"type({})\", print::ty_to_string(self))\n+        write!(f, \"type({})\",\n+               print::to_string(print::NO_ANN, |s| s.print_type(self)))\n     }\n }\n "}, {"sha": "18fa6836b510827bfeb4e1c43d5e949bd09af7d7", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 77, "deletions": 240, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -13,18 +13,18 @@ pub use self::AnnNode::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, BytePos};\n use errors;\n \n use hir;\n-use hir::{Crate, PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -37,7 +37,18 @@ pub enum AnnNode<'a> {\n     NodePat(&'a hir::Pat),\n }\n \n+pub enum Nested {\n+    Item(hir::ItemId),\n+    TraitItem(hir::TraitItemId),\n+    ImplItem(hir::ImplItemId),\n+    Body(hir::BodyId),\n+    BodyArgPat(hir::BodyId, usize)\n+}\n+\n pub trait PpAnn {\n+    fn nested(&self, _state: &mut State, _nested: Nested) -> io::Result<()> {\n+        Ok(())\n+    }\n     fn pre(&self, _state: &mut State, _node: AnnNode) -> io::Result<()> {\n         Ok(())\n     }\n@@ -46,14 +57,23 @@ pub trait PpAnn {\n     }\n }\n \n-#[derive(Copy, Clone)]\n pub struct NoAnn;\n-\n impl PpAnn for NoAnn {}\n+pub const NO_ANN: &'static PpAnn = &NoAnn;\n \n+impl PpAnn for hir::Crate {\n+    fn nested(&self, state: &mut State, nested: Nested) -> io::Result<()> {\n+        match nested {\n+            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n+            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n+            Nested::Body(id) => state.print_expr(&self.body(id).value),\n+            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+        }\n+    }\n+}\n \n pub struct State<'a> {\n-    krate: Option<&'a Crate>,\n     pub s: pp::Printer<'a>,\n     cm: Option<&'a CodeMap>,\n     comments: Option<Vec<comments::Comment>>,\n@@ -85,30 +105,6 @@ impl<'a> PrintState<'a> for State<'a> {\n     }\n }\n \n-pub fn rust_printer<'a>(writer: Box<Write + 'a>, krate: Option<&'a Crate>) -> State<'a> {\n-    static NO_ANN: NoAnn = NoAnn;\n-    rust_printer_annotated(writer, &NO_ANN, krate)\n-}\n-\n-pub fn rust_printer_annotated<'a>(writer: Box<Write + 'a>,\n-                                  ann: &'a PpAnn,\n-                                  krate: Option<&'a Crate>)\n-                                  -> State<'a> {\n-    State {\n-        krate: krate,\n-        s: pp::mk_printer(writer, default_columns),\n-        cm: None,\n-        comments: None,\n-        literals: None,\n-        cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n-            cur_cmnt: 0,\n-            cur_lit: 0,\n-        },\n-        boxes: Vec::new(),\n-        ann: ann,\n-    }\n-}\n-\n #[allow(non_upper_case_globals)]\n pub const indent_unit: usize = 4;\n \n@@ -129,7 +125,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        is_expanded: bool)\n                        -> io::Result<()> {\n     let mut s = State::new_from_input(cm, span_diagnostic, filename, input,\n-                                      out, ann, is_expanded, Some(krate));\n+                                      out, ann, is_expanded);\n \n     // When printing the AST, we sometimes need to inject `#[no_std]` here.\n     // Since you can't compile the HIR, it's not necessary.\n@@ -146,8 +142,7 @@ impl<'a> State<'a> {\n                           input: &mut Read,\n                           out: Box<Write + 'a>,\n                           ann: &'a PpAnn,\n-                          is_expanded: bool,\n-                          krate: Option<&'a Crate>)\n+                          is_expanded: bool)\n                           -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(span_diagnostic,\n                                                                    filename,\n@@ -164,19 +159,16 @@ impl<'a> State<'a> {\n                        None\n                    } else {\n                        Some(lits)\n-                   },\n-                   krate)\n+                   })\n     }\n \n     pub fn new(cm: &'a CodeMap,\n                out: Box<Write + 'a>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n-               literals: Option<Vec<comments::Literal>>,\n-               krate: Option<&'a Crate>)\n+               literals: Option<Vec<comments::Literal>>)\n                -> State<'a> {\n         State {\n-            krate: krate,\n             s: pp::mk_printer(out, default_columns),\n             cm: Some(cm),\n             comments: comments.clone(),\n@@ -191,147 +183,36 @@ impl<'a> State<'a> {\n     }\n }\n \n-pub fn to_string<F>(f: F) -> String\n+pub fn to_string<F>(ann: &PpAnn, f: F) -> String\n     where F: FnOnce(&mut State) -> io::Result<()>\n {\n     let mut wr = Vec::new();\n     {\n-        let mut printer = rust_printer(Box::new(&mut wr), None);\n+        let mut printer = State {\n+            s: pp::mk_printer(Box::new(&mut wr), default_columns),\n+            cm: None,\n+            comments: None,\n+            literals: None,\n+            cur_cmnt_and_lit: ast_pp::CurrentCommentAndLiteral {\n+                cur_cmnt: 0,\n+                cur_lit: 0,\n+            },\n+            boxes: Vec::new(),\n+            ann: ann,\n+        };\n         f(&mut printer).unwrap();\n         eof(&mut printer.s).unwrap();\n     }\n     String::from_utf8(wr).unwrap()\n }\n \n-pub fn binop_to_string(op: BinOpToken) -> &'static str {\n-    match op {\n-        token::Plus => \"+\",\n-        token::Minus => \"-\",\n-        token::Star => \"*\",\n-        token::Slash => \"/\",\n-        token::Percent => \"%\",\n-        token::Caret => \"^\",\n-        token::And => \"&\",\n-        token::Or => \"|\",\n-        token::Shl => \"<<\",\n-        token::Shr => \">>\",\n-    }\n-}\n-\n-pub fn ty_to_string(ty: &hir::Ty) -> String {\n-    to_string(|s| s.print_type(ty))\n-}\n-\n-pub fn bounds_to_string(bounds: &[hir::TyParamBound]) -> String {\n-    to_string(|s| s.print_bounds(\"\", bounds))\n-}\n-\n-pub fn pat_to_string(pat: &hir::Pat) -> String {\n-    to_string(|s| s.print_pat(pat))\n-}\n-\n-pub fn arm_to_string(arm: &hir::Arm) -> String {\n-    to_string(|s| s.print_arm(arm))\n-}\n-\n-pub fn expr_to_string(e: &hir::Expr) -> String {\n-    to_string(|s| s.print_expr(e))\n-}\n-\n-pub fn lifetime_to_string(e: &hir::Lifetime) -> String {\n-    to_string(|s| s.print_lifetime(e))\n-}\n-\n-pub fn stmt_to_string(stmt: &hir::Stmt) -> String {\n-    to_string(|s| s.print_stmt(stmt))\n-}\n-\n-pub fn item_to_string(i: &hir::Item) -> String {\n-    to_string(|s| s.print_item(i))\n-}\n-\n-pub fn impl_item_to_string(i: &hir::ImplItem) -> String {\n-    to_string(|s| s.print_impl_item(i))\n-}\n-\n-pub fn trait_item_to_string(i: &hir::TraitItem) -> String {\n-    to_string(|s| s.print_trait_item(i))\n-}\n-\n-pub fn generics_to_string(generics: &hir::Generics) -> String {\n-    to_string(|s| s.print_generics(generics))\n-}\n-\n-pub fn where_clause_to_string(i: &hir::WhereClause) -> String {\n-    to_string(|s| s.print_where_clause(i))\n-}\n-\n-pub fn path_to_string(p: &hir::Path) -> String {\n-    to_string(|s| s.print_path(p, false))\n-}\n-\n-pub fn qpath_to_string(p: &hir::QPath) -> String {\n-    to_string(|s| s.print_qpath(p, false))\n-}\n-\n-pub fn name_to_string(name: ast::Name) -> String {\n-    to_string(|s| s.print_name(name))\n-}\n-\n-pub fn fn_decl_in_crate_to_string(krate: &hir::Crate,\n-                                  decl: &hir::FnDecl,\n-                                  unsafety: hir::Unsafety,\n-                                  constness: hir::Constness,\n-                                  name: ast::Name,\n-                                  generics: &hir::Generics,\n-                                  body_id: hir::BodyId)\n-                                  -> String {\n-\n-    let mut wr = Vec::new();\n-    {\n-        let mut s = rust_printer(Box::new(&mut wr), Some(krate));\n-        (|s: &mut State| {\n-            s.head(\"\")?;\n-            s.print_fn(decl,\n-                       unsafety,\n-                       constness,\n-                       Abi::Rust,\n-                       Some(name),\n-                       generics,\n-                       &hir::Inherited,\n-                       &[],\n-                       Some(body_id))?;\n-            s.end()?; // Close the head box\n-            s.end()?; // Close the outer box\n-            eof(&mut s.s)\n-        })(&mut s).unwrap();\n-    }\n-    String::from_utf8(wr).unwrap()\n-}\n-\n-pub fn block_to_string(blk: &hir::Block) -> String {\n-    to_string(|s| {\n-        // containing cbox, will be closed by print-block at }\n-        s.cbox(indent_unit)?;\n-        // head-ibox, will be closed by print-block after {\n-        s.ibox(0)?;\n-        s.print_block(blk)\n+pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n+    to_string(NO_ANN, |s| {\n+        s.print_visibility(vis)?;\n+        word(&mut s.s, w)\n     })\n }\n \n-pub fn variant_to_string(var: &hir::Variant) -> String {\n-    to_string(|s| s.print_variant(var))\n-}\n-\n-pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n-    match *vis {\n-        hir::Public => format!(\"pub {}\", s),\n-        hir::Visibility::Crate => format!(\"pub(crate) {}\", s),\n-        hir::Visibility::Restricted { ref path, .. } => format!(\"pub({}) {}\", path, s),\n-        hir::Inherited => s.to_string(),\n-    }\n-}\n-\n fn needs_parentheses(expr: &hir::Expr) -> bool {\n     match expr.node {\n         hir::ExprAssign(..) |\n@@ -465,7 +346,7 @@ impl<'a> State<'a> {\n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_inner_attributes(attrs)?;\n         for &item_id in &_mod.item_ids {\n-            self.print_item_id(item_id)?;\n+            self.ann.nested(self, Nested::Item(item_id))?;\n         }\n         Ok(())\n     }\n@@ -551,12 +432,12 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \"[\")?;\n                 self.print_type(&ty)?;\n                 word(&mut self.s, \"; \")?;\n-                self.print_body_id(v)?;\n+                self.ann.nested(self, Nested::Body(v))?;\n                 word(&mut self.s, \"]\")?;\n             }\n             hir::TyTypeof(e) => {\n                 word(&mut self.s, \"typeof(\")?;\n-                self.print_body_id(e)?;\n+                self.ann.nested(self, Nested::Body(e))?;\n                 word(&mut self.s, \")\")?;\n             }\n             hir::TyInfer => {\n@@ -615,7 +496,7 @@ impl<'a> State<'a> {\n         if let Some(expr) = default {\n             space(&mut self.s)?;\n             self.word_space(\"=\")?;\n-            self.print_body_id(expr)?;\n+            self.ann.nested(self, Nested::Body(expr))?;\n         }\n         word(&mut self.s, \";\")\n     }\n@@ -638,26 +519,6 @@ impl<'a> State<'a> {\n         word(&mut self.s, \";\")\n     }\n \n-    pub fn print_item_id(&mut self, item_id: hir::ItemId) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            // skip nested items if krate context was not provided\n-            let item = &krate.items[&item_id.id];\n-            self.print_item(item)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn maybe_body(&mut self, body_id: hir::BodyId) -> Option<&'a hir::Body> {\n-        self.krate.map(|krate| krate.body(body_id))\n-    }\n-\n-    fn print_body_id(&mut self, body_id: hir::BodyId) -> io::Result<()> {\n-        self.maybe_body(body_id).map_or(Ok(()), |body| {\n-            self.print_expr(&body.value)\n-        })\n-    }\n-\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n@@ -714,7 +575,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_body_id(expr)?;\n+                self.ann.nested(self, Nested::Body(expr))?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n@@ -727,7 +588,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_body_id(expr)?;\n+                self.ann.nested(self, Nested::Body(expr))?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n@@ -745,7 +606,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_body_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -839,7 +700,7 @@ impl<'a> State<'a> {\n                 self.bopen()?;\n                 self.print_inner_attributes(&item.attrs)?;\n                 for impl_item in impl_items {\n-                    self.print_impl_item_ref(impl_item)?;\n+                    self.ann.nested(self, Nested::ImplItem(impl_item.id))?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -865,7 +726,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.bopen()?;\n                 for trait_item in trait_items {\n-                    self.print_trait_item_ref(trait_item)?;\n+                    self.ann.nested(self, Nested::TraitItem(trait_item.id))?;\n                 }\n                 self.bclose(item.span)?;\n             }\n@@ -935,8 +796,11 @@ impl<'a> State<'a> {\n         match *vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Visibility::Crate => self.word_nbsp(\"pub(crate)\"),\n-            hir::Visibility::Restricted { ref path, .. } =>\n-                self.word_nbsp(&format!(\"pub({})\", path)),\n+            hir::Visibility::Restricted { ref path, .. } => {\n+                word(&mut self.s, \"pub(\")?;\n+                self.print_path(path, false)?;\n+                self.word_nbsp(\")\")\n+            }\n             hir::Inherited => Ok(()),\n         }\n     }\n@@ -995,7 +859,7 @@ impl<'a> State<'a> {\n         if let Some(d) = v.node.disr_expr {\n             space(&mut self.s)?;\n             self.word_space(\"=\")?;\n-            self.print_body_id(d)?;\n+            self.ann.nested(self, Nested::Body(d))?;\n         }\n         Ok(())\n     }\n@@ -1017,16 +881,6 @@ impl<'a> State<'a> {\n                       body_id)\n     }\n \n-    pub fn print_trait_item_ref(&mut self, item_ref: &hir::TraitItemRef) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            // skip nested items if krate context was not provided\n-            let item = &krate.trait_item(item_ref.id);\n-            self.print_trait_item(item)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ti.id))?;\n         self.hardbreak_if_not_bol()?;\n@@ -1046,7 +900,7 @@ impl<'a> State<'a> {\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_body_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n                 self.print_associated_type(ti.name,\n@@ -1057,16 +911,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n-    pub fn print_impl_item_ref(&mut self, item_ref: &hir::ImplItemRef) -> io::Result<()> {\n-        if let Some(krate) = self.krate {\n-            // skip nested items if krate context was not provided\n-            let item = &krate.impl_item(item_ref.id);\n-            self.print_impl_item(item)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n     pub fn print_impl_item(&mut self, ii: &hir::ImplItem) -> io::Result<()> {\n         self.ann.pre(self, NodeSubItem(ii.id))?;\n         self.hardbreak_if_not_bol()?;\n@@ -1088,7 +932,7 @@ impl<'a> State<'a> {\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_body_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1265,7 +1109,7 @@ impl<'a> State<'a> {\n         word(&mut self.s, \"[\")?;\n         self.print_expr(element)?;\n         self.word_space(\";\")?;\n-        self.print_body_id(count)?;\n+        self.ann.nested(self, Nested::Body(count))?;\n         word(&mut self.s, \"]\")?;\n         self.end()\n     }\n@@ -1455,7 +1299,7 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n-                self.print_body_id(body)?;\n+                self.ann.nested(self, Nested::Body(body))?;\n                 self.end()?; // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall\n@@ -1630,7 +1474,7 @@ impl<'a> State<'a> {\n                 self.end()\n             }\n             hir::DeclItem(item) => {\n-                self.print_item_id(item)\n+                self.ann.nested(self, Nested::Item(item))\n             }\n         }\n     }\n@@ -1651,10 +1495,10 @@ impl<'a> State<'a> {\n         self.print_expr(coll)\n     }\n \n-    fn print_path(&mut self,\n-                  path: &hir::Path,\n-                  colons_before_params: bool)\n-                  -> io::Result<()> {\n+    pub fn print_path(&mut self,\n+                      path: &hir::Path,\n+                      colons_before_params: bool)\n+                      -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n         for (i, segment) in path.segments.iter().enumerate() {\n@@ -1670,10 +1514,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_qpath(&mut self,\n-                   qpath: &hir::QPath,\n-                   colons_before_params: bool)\n-                   -> io::Result<()> {\n+    pub fn print_qpath(&mut self,\n+                       qpath: &hir::QPath,\n+                       colons_before_params: bool)\n+                       -> io::Result<()> {\n         match *qpath {\n             hir::QPath::Resolved(None, ref path) => {\n                 self.print_path(path, colons_before_params)\n@@ -1991,16 +1835,14 @@ impl<'a> State<'a> {\n         let mut i = 0;\n         // Make sure we aren't supplied *both* `arg_names` and `body_id`.\n         assert!(arg_names.is_empty() || body_id.is_none());\n-        let args = body_id.and_then(|body_id| self.maybe_body(body_id))\n-                          .map_or(&[][..], |body| &body.arguments[..]);\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n             if let Some(name) = arg_names.get(i) {\n                 word(&mut s.s, &name.node.as_str())?;\n                 word(&mut s.s, \":\")?;\n                 space(&mut s.s)?;\n-            } else if let Some(arg) = args.get(i) {\n-                s.print_pat(&arg.pat)?;\n+            } else if let Some(body_id) = body_id {\n+                s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n                 word(&mut s.s, \":\")?;\n                 space(&mut s.s)?;\n             }\n@@ -2020,15 +1862,10 @@ impl<'a> State<'a> {\n     fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n         let mut i = 0;\n-        let args = self.maybe_body(body_id).map_or(&[][..], |body| &body.arguments[..]);\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n \n-            if let Some(arg) = args.get(i) {\n-                s.print_pat(&arg.pat)?;\n-            } else {\n-                word(&mut s.s, \"_\")?;\n-            }\n+            s.ann.nested(s, Nested::BodyArgPat(body_id, i))?;\n             i += 1;\n \n             if ty.node != hir::TyInfer {"}, {"sha": "9ff7dcc7d58835beaface33b9cf59205fda0a0b6", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -75,7 +75,6 @@ use std::collections::HashSet;\n \n use hir::map as ast_map;\n use hir;\n-use hir::print as pprust;\n \n use lint;\n use hir::def::Def;\n@@ -1629,13 +1628,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 generics: &hir::Generics,\n                                 span: Span,\n                                 body: hir::BodyId) {\n-        let s = pprust::fn_decl_in_crate_to_string(self.tcx.map.krate(),\n-                                                   decl,\n-                                                   unsafety,\n-                                                   constness,\n-                                                   name,\n-                                                   generics,\n-                                                   body);\n+        let s = hir::print::to_string(&self.tcx.map, |s| {\n+            use syntax::abi::Abi;\n+            use syntax::print::pprust::PrintState;\n+\n+            s.head(\"\")?;\n+            s.print_fn(decl,\n+                       unsafety,\n+                       constness,\n+                       Abi::Rust,\n+                       Some(name),\n+                       generics,\n+                       &hir::Inherited,\n+                       &[],\n+                       Some(body))?;\n+            s.end()?; // Close the head box\n+            s.end()   // Close the outer box\n+        });\n         let msg = format!(\"consider using an explicit lifetime parameter as shown: {}\", s);\n         err.span_help(span, &msg[..]);\n     }"}, {"sha": "dfcb5cb7b79fee81b4c21224ba1c0ed9c77f7c8d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -108,6 +108,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n+    fn nested(&self, state: &mut pprust::State, nested: pprust::Nested) -> io::Result<()> {\n+        pprust::PpAnn::nested(&self.tcx.map, state, nested)\n+    }\n     fn pre(&self,\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n@@ -530,20 +533,11 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n         }\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n-        debug!(\"{}\", {\n-            let mut v = Vec::new();\n-            self.pretty_print_to(box &mut v, body).unwrap();\n-            String::from_utf8(v).unwrap()\n-        });\n-    }\n-\n-    fn pretty_print_to<'b>(&self, wr: Box<io::Write + 'b>,\n-                           body: &hir::Body) -> io::Result<()> {\n-        let mut ps = pprust::rust_printer_annotated(wr, self, None);\n-        ps.cbox(pprust::indent_unit)?;\n-        ps.ibox(0)?;\n-        ps.print_expr(&body.value)?;\n-        pp::eof(&mut ps.s)\n+        debug!(\"{}\", pprust::to_string(self, |s| {\n+            s.cbox(pprust::indent_unit)?;\n+            s.ibox(0)?;\n+            s.print_expr(&body.value)\n+        }));\n     }\n }\n "}, {"sha": "745a94a5ddba31cd6cafc49f1d240872ef5d9511", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -127,7 +127,6 @@ use syntax_pos::Span;\n \n use hir::Expr;\n use hir;\n-use hir::print::{expr_to_string, block_to_string};\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n /// For use with `propagate_through_loop`.\n@@ -819,7 +818,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n \n-        debug!(\"compute: using id for body, {}\", expr_to_string(body));\n+        debug!(\"compute: using id for body, {}\", self.ir.tcx.map.node_to_pretty_string(body.id));\n \n         let exit_ln = self.s.exit_ln;\n         let entry_ln: LiveNode = self.with_loop_nodes(body.id, exit_ln, exit_ln, |this| {\n@@ -912,7 +911,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", expr_to_string(expr));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.map.node_to_pretty_string(expr.id));\n \n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n@@ -931,7 +930,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprClosure(.., blk_id, _) => {\n               debug!(\"{} is an ExprClosure\",\n-                     expr_to_string(expr));\n+                     self.ir.tcx.map.node_to_pretty_string(expr.id));\n \n               /*\n               The next-node for a break is the successor of the entire\n@@ -1307,7 +1306,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, block_to_string(body));\n+               expr.id, self.ir.tcx.map.node_to_pretty_string(body.id));\n \n         let cond_ln = match kind {\n             LoopLoop => ln,"}, {"sha": "c491af972acbce6120f926b2f66b13166d06fd69", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -33,7 +33,6 @@ use util::nodemap::NodeMap;\n \n use rustc_data_structures::fx::FxHashSet;\n use hir;\n-use hir::print::lifetime_to_string;\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n@@ -822,9 +821,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                        probably a bug in syntax::fold\");\n         }\n \n-        debug!(\"lifetime_ref={:?} id={:?} resolved to {:?} span={:?}\",\n-               lifetime_to_string(lifetime_ref),\n-               lifetime_ref.id,\n+        debug!(\"{} resolved to {:?} span={:?}\",\n+               self.hir_map.node_to_string(lifetime_ref.id),\n                def,\n                self.sess.codemap().span_to_string(lifetime_ref.span));\n         self.map.defs.insert(lifetime_ref.id, def);"}, {"sha": "01b19e1f53979d8dd563a9ed60873b47983fe98b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -30,7 +30,6 @@ use rustc_errors::DiagnosticBuilder;\n \n use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n-use rustc::hir::print::pat_to_string;\n use rustc::hir::{self, Pat, PatKind};\n \n use rustc_back::slice;\n@@ -231,7 +230,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 Useful => bug!()\n             };\n \n-            let pattern_string = pat_to_string(witness[0].single_pattern());\n+            let pattern_string = hir::print::to_string(&self.tcx.map, |s| {\n+                s.print_pat(witness[0].single_pattern())\n+            });\n             let mut diag = struct_span_err!(\n                 self.tcx.sess, pat.span, E0005,\n                 \"refutable pattern in {}: `{}` not covered\",\n@@ -382,7 +383,9 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                         },\n                         _ => bug!(),\n                     };\n-                    let pattern_string = pat_to_string(witness);\n+                    let pattern_string = hir::print::to_string(&cx.tcx.map, |s| {\n+                        s.print_pat(witness)\n+                    });\n                     struct_span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n@@ -392,7 +395,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 },\n                 _ => {\n                     let pattern_strings: Vec<_> = witnesses.iter().map(|w| {\n-                        pat_to_string(w)\n+                        hir::print::to_string(&cx.tcx.map, |s| s.print_pat(w))\n                     }).collect();\n                     const LIMIT: usize = 3;\n                     let joined_patterns = match pattern_strings.len() {"}, {"sha": "e8e7a2eb7ede0919fb3c167aa0416312ee0350e5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -1320,7 +1320,8 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n                 if let Def::Local(..) = path.def {\n-                    diag.note(&format!(\"`{}` is a variable\", path));\n+                    diag.note(&format!(\"`{}` is a variable\",\n+                                       tcx.map.node_to_pretty_string(count_expr.id)));\n                 }\n             }\n "}, {"sha": "5103a55fd71e1bd673df5b4e5b3533bbd89db23e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -47,7 +47,7 @@ use std::path::Path;\n use std::str::FromStr;\n \n use rustc::hir::map as hir_map;\n-use rustc::hir::map::{blocks, NodePrinter};\n+use rustc::hir::map::blocks;\n use rustc::hir;\n use rustc::hir::print as pprust_hir;\n \n@@ -320,7 +320,16 @@ impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n }\n \n impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n-impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {}\n+impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {\n+    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+              -> io::Result<()> {\n+        if let Some(ref map) = self.ast_map {\n+            pprust_hir::PpAnn::nested(map, state, nested)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n \n struct IdentifiedAnnotation<'ast> {\n     sess: &'ast Session,\n@@ -393,6 +402,14 @@ impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n }\n \n impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n+    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+              -> io::Result<()> {\n+        if let Some(ref map) = self.ast_map {\n+            pprust_hir::PpAnn::nested(map, state, nested)\n+        } else {\n+            Ok(())\n+        }\n+    }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(_) => s.popen(),\n@@ -488,6 +505,10 @@ impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n }\n \n impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n+    fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n+              -> io::Result<()> {\n+        pprust_hir::PpAnn::nested(&self.tcx.map, state, nested)\n+    }\n     fn pre(&self, s: &mut pprust_hir::State, node: pprust_hir::AnnNode) -> io::Result<()> {\n         match node {\n             pprust_hir::NodeExpr(_) => s.popen(),\n@@ -909,11 +930,10 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                                          &mut rdr,\n                                                                          box out,\n                                                                          annotation.pp_ann(),\n-                                                                         true,\n-                                                                         Some(ast_map.krate()));\n+                                                                         true);\n                     for node_id in uii.all_matching_node_ids(ast_map) {\n                         let node = ast_map.get(node_id);\n-                        pp_state.print_node(&node)?;\n+                        pp_state.print_node(node)?;\n                         pp::space(&mut pp_state.s)?;\n                         let path = annotation.node_path(node_id)\n                             .expect(\"--unpretty missing node paths\");"}, {"sha": "43e3b1dd2b50a9d5e62d225da8f5c777698d5861", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -349,7 +349,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match item.node {\n                         hir::ItemImpl(.., ref ty, _) => {\n                             let mut result = String::from(\"<\");\n-                            result.push_str(&rustc::hir::print::ty_to_string(&ty));\n+                            result.push_str(&self.tcx.map.node_to_pretty_string(ty.id));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut decl_id = None;"}, {"sha": "75c25a605af252cd6a57138c857d4cafe6d3b033", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -53,7 +53,6 @@ use rustc_data_structures::accumulate_vec::AccumulateVec;\n use hir;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -247,7 +246,7 @@ fn report_elision_failure(\n \n         let help_name = if let Some(body) = parent {\n             let arg = &tcx.map.body(body).arguments[index];\n-            format!(\"`{}`\", pprust::pat_to_string(&arg.pat))\n+            format!(\"`{}`\", tcx.map.node_to_pretty_string(arg.pat.id))\n         } else {\n             format!(\"argument {}\", index + 1)\n         };\n@@ -685,7 +684,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             _ => {\n                 span_fatal!(self.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n-                            path);\n+                            self.tcx().map.node_to_pretty_string(trait_ref.ref_id));\n             }\n         }\n     }\n@@ -972,7 +971,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let mut err = struct_span_err!(tcx.sess, ty.span, E0178,\n                                                \"expected a path on the left-hand side \\\n                                                 of `+`, not `{}`\",\n-                                               pprust::ty_to_string(ty));\n+                                               tcx.map.node_to_pretty_string(ty.id));\n                 err.span_label(ty.span, &format!(\"expected a path\"));\n                 let hi = bounds.iter().map(|x| match *x {\n                     hir::TraitTyParamBound(ref tr, _) => tr.span.hi,\n@@ -984,22 +983,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     expn_id: ty.span.expn_id,\n                 });\n                 match (&ty.node, full_span) {\n-                    (&hir::TyRptr(None, ref mut_ty), Some(full_span)) => {\n-                        let mutbl_str = if mut_ty.mutbl == hir::MutMutable { \"mut \" } else { \"\" };\n+                    (&hir::TyRptr(ref lifetime, ref mut_ty), Some(full_span)) => {\n+                        let ty_str = hir::print::to_string(&tcx.map, |s| {\n+                            use syntax::print::pp::word;\n+                            use syntax::print::pprust::PrintState;\n+\n+                            word(&mut s.s, \"&\")?;\n+                            s.print_opt_lifetime(lifetime)?;\n+                            s.print_mutability(mut_ty.mutbl)?;\n+                            s.popen()?;\n+                            s.print_type(&mut_ty.ty)?;\n+                            s.print_bounds(\" +\", bounds)?;\n+                            s.pclose()\n+                        });\n                         err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                            format!(\"&{}({} +{})\",\n-                                                    mutbl_str,\n-                                                    pprust::ty_to_string(&mut_ty.ty),\n-                                                    pprust::bounds_to_string(bounds)));\n-                    }\n-                    (&hir::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n-                        let mutbl_str = if mut_ty.mutbl == hir::MutMutable { \"mut \" } else { \"\" };\n-                        err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                            format!(\"&{} {}({} +{})\",\n-                                                    pprust::lifetime_to_string(lt),\n-                                                    mutbl_str,\n-                                                    pprust::ty_to_string(&mut_ty.ty),\n-                                                    pprust::bounds_to_string(bounds)));\n+                                            ty_str);\n                     }\n \n                     _ => {"}, {"sha": "9b86196b3ece234b91eb760575bd23989362d14d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -527,7 +527,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let report_unexpected_def = |def: Def| {\n             span_err!(tcx.sess, pat.span, E0533,\n                       \"expected unit struct/variant or constant, found {} `{}`\",\n-                      def.kind_name(), qpath);\n+                      def.kind_name(),\n+                      hir::print::to_string(&tcx.map, |s| s.print_qpath(qpath, false)));\n         };\n \n         // Resolve the path and check the definition for errors.\n@@ -568,7 +569,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let report_unexpected_def = |def: Def| {\n             let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              def.kind_name(), qpath);\n+                              def.kind_name(),\n+                              hir::print::to_string(&tcx.map, |s| s.print_qpath(qpath, false)));\n             struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg)\n                 .span_label(pat.span, &format!(\"not a tuple variant or struct\")).emit();\n             on_error();"}, {"sha": "0b9cf38fa073316a3d1adffa112f545029a1a013", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -13,7 +13,6 @@ use super::{DeferredCallResolution, Expectation, FnCtxt, TupleArgumentsFlag};\n use CrateCtxt;\n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use hir::print;\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n use syntax::symbol::Symbol;\n@@ -203,7 +202,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let &ty::TyAdt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                            unit_variant = Some(print::expr_to_string(expr))\n+                            unit_variant = Some(self.tcx.map.node_to_pretty_string(expr.id))\n                         }\n                     }\n                 }"}, {"sha": "04ec9292d1410ee727c3684ffe90b060adcb2df1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -26,7 +26,6 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n-use rustc::hir::print as pprust;\n use rustc::hir;\n use rustc::infer::type_variable::TypeVariableOrigin;\n \n@@ -266,7 +265,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let msg = if let Some(callee) = rcvr_expr {\n                     format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                             msg,\n-                            pprust::expr_to_string(callee))\n+                            self.tcx.map.node_to_pretty_string(callee.id))\n                 } else {\n                     msg\n                 };"}, {"sha": "7275fbd12036b308768b7fc53259bf3c8e28384b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -122,7 +122,6 @@ use syntax_pos::{self, BytePos, Span, DUMMY_SP};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{self, PatKind};\n-use rustc::hir::print as pprust;\n use rustc::middle::lang_items;\n use rustc_back::slice;\n use rustc_const_eval::eval_length;\n@@ -3045,7 +3044,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 ty::TyRawPtr(..) => {\n                     err.note(&format!(\"`{0}` is a native pointer; perhaps you need to deref with \\\n-                                      `(*{0}).{1}`\", pprust::expr_to_string(base), field.node));\n+                                      `(*{0}).{1}`\",\n+                                      self.tcx.map.node_to_pretty_string(base.id),\n+                                      field.node));\n                 }\n                 _ => {}\n             }\n@@ -3459,11 +3460,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of expr({}) {} is...\", expr.id,\n-               pprust::expr_to_string(expr));\n-        debug!(\"... {:?}, expected is {:?}\",\n-               ty,\n-               expected);\n+        debug!(\"type of {} is...\", self.tcx.map.node_to_string(expr.id));\n+        debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         // Add adjustments to !-expressions\n         if ty.is_never() {"}, {"sha": "9a2bfbf715af9785bb6432e24c9264dd63d65459", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -26,7 +26,6 @@ use std::cell::Cell;\n use syntax::ast;\n use syntax_pos::Span;\n \n-use rustc::hir::print::pat_to_string;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n@@ -221,7 +220,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n \n         debug!(\"Type for pattern binding {} (id {}) resolved to {:?}\",\n-               pat_to_string(p),\n+               self.tcx().map.node_to_pretty_string(p.id),\n                p.id,\n                self.tcx().tables().node_id_to_type(p.id));\n "}, {"sha": "bc1ead07c0ea7f77a042135dab3fbff32825a3eb", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -370,7 +370,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                       the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n                                     &format!(\"`{}` trait not defined in this crate\",\n-                                             item_trait_ref.path))\n+                            self.tcx.map.node_to_pretty_string(item_trait_ref.ref_id)))\n                         .emit();\n                     return;\n                 }"}, {"sha": "fd51b38e1b557464becb775ed9503b21ed415853", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -82,7 +82,7 @@ use syntax::{abi, ast, attr};\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n-use rustc::hir::{self, map as hir_map, print as pprust};\n+use rustc::hir::{self, map as hir_map};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -1041,7 +1041,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n                           -> Option<ty::Disr> {\n-        debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n+        debug!(\"disr expr, checking {}\", ccx.tcx.map.node_to_pretty_string(e.id));\n \n         let ty_hint = repr_ty.to_ty(ccx.tcx);\n         let print_err = |cv: ConstVal| {\n@@ -2072,7 +2072,7 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n                 ccx.tcx.sess.struct_span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty)))\n+                                       ccx.tcx.map.node_to_pretty_string(ast_ty.id)))\n                     .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")\n                     .emit();\n             }"}, {"sha": "a1c121ca424c8b2caba9aeda64ba321a932954d1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -17,7 +17,6 @@ use rustc::hir;\n \n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::print as pprust;\n use rustc::ty;\n use rustc::util::nodemap::FxHashSet;\n \n@@ -343,8 +342,8 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n         match item.kind {\n             ty::AssociatedKind::Const => {\n                 let default = if item.defaultness.has_value() {\n-                    Some(pprust::expr_to_string(\n-                        &tcx.sess.cstore.maybe_get_item_body(tcx, item.def_id).unwrap().value))\n+                    Some(hir::print::to_string(&cx.tcx.map, |s| s.print_expr(\n+                        &tcx.sess.cstore.maybe_get_item_body(tcx, item.def_id).unwrap().value)))\n                 } else {\n                     None\n                 };\n@@ -477,8 +476,8 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {\n     clean::Constant {\n         type_: cx.tcx.item_type(did).clean(cx),\n-        expr: pprust::expr_to_string(\n-            &cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap().value)\n+        expr: hir::print::to_string(&cx.tcx.map, |s| s.print_expr(\n+            &cx.tcx.sess.cstore.maybe_get_item_body(cx.tcx, did).unwrap().value))\n     }\n }\n "}, {"sha": "3b8281980696d74db037d65b52d3238ec444a7c0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -32,7 +32,6 @@ use rustc::middle::resolve_lifetime::DefRegion::*;\n use rustc::middle::lang_items;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::print as pprust;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind};\n use rustc::middle::stability;\n@@ -2725,7 +2724,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n }\n \n fn print_const_expr(cx: &DocContext, body: hir::BodyId) -> String {\n-    pprust::expr_to_string(&cx.tcx.map.body(body).value)\n+    cx.tcx.map.node_to_pretty_string(body.node_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "bb61a1dedda5db0205ae14d11b45d929d68ad4fd", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n         let name = if let hir::ItemImpl(.., ref ty, _) = item.node {\n-            hir::print::ty_to_string(ty)\n+            self.map.node_to_pretty_string(ty.id)\n         } else {\n             item.name.to_string()\n         };"}, {"sha": "b0491fe6e27fd44e7a1e01950641dcdfeb96ebaf", "filename": "src/test/run-make/graphviz-flowgraph/f18.dot-expected.dot", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff18.dot-expected.dot?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -1,15 +1,15 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"stmt \"];\n+    N2[label=\"stmt fn inner(x: isize) -> isize { x + x }\"];\n     N3[label=\"expr inner\"];\n     N4[label=\"expr inner\"];\n     N5[label=\"expr 18\"];\n     N6[label=\"expr inner(18)\"];\n     N7[label=\"expr inner(inner(18))\"];\n     N8[label=\"stmt inner(inner(18));\"];\n-    N9[label=\"block { inner(inner(18)); }\"];\n-    N10[label=\"expr { inner(inner(18)); }\"];\n+    N9[label=\"block {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n+    N10[label=\"expr {\\l    fn inner(x: isize) -> isize { x + x }\\l    inner(inner(18));\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}, {"sha": "223978c3d7634f7380960dc81d32f2c8eadda422", "filename": "src/test/run-make/graphviz-flowgraph/f19.dot-expected.dot", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4aae835803037e578baa19e5a4982177f5444c26/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4aae835803037e578baa19e5a4982177f5444c26/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff19.dot-expected.dot?ref=4aae835803037e578baa19e5a4982177f5444c26", "patch": "@@ -1,8 +1,8 @@\n digraph block {\n     N0[label=\"entry\"];\n     N1[label=\"exit\"];\n-    N2[label=\"stmt \"];\n-    N3[label=\"stmt \"];\n+    N2[label=\"stmt struct S19 {\\l    x: isize,\\l}\\l\"];\n+    N3[label=\"stmt impl S19 {\\l    fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l}\\l\"];\n     N4[label=\"expr 19\"];\n     N5[label=\"expr S19{x: 19,}\"];\n     N6[label=\"local s\"];\n@@ -11,8 +11,8 @@ digraph block {\n     N9[label=\"expr s.inner()\"];\n     N10[label=\"expr s.inner().inner()\"];\n     N11[label=\"stmt s.inner().inner();\"];\n-    N12[label=\"block { let s = S19{x: 19,}; s.inner().inner(); }\"];\n-    N13[label=\"expr { let s = S19{x: 19,}; s.inner().inner(); }\"];\n+    N12[label=\"block {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n+    N13[label=\"expr {\\l    struct S19 {\\l        x: isize,\\l    }\\l    impl S19 {\\l        fn inner(self: Self) -> S19 { S19{x: self.x + self.x,} }\\l    }\\l    let s = S19{x: 19,};\\l    s.inner().inner();\\l}\\l\"];\n     N0 -> N2;\n     N2 -> N3;\n     N3 -> N4;"}]}