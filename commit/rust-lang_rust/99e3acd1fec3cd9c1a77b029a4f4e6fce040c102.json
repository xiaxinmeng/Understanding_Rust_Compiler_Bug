{"sha": "99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZTNhY2QxZmVjM2NkOWMxYTc3YjAyOWE0ZjRlNmZjZTA0MGMxMDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-18T06:31:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-18T06:31:24Z"}, "message": "Merge #4934\n\n4934: Remove special casing for library symbols r=matklad a=matklad\n\nWe might as well handle them internally, via queries.\n\nI am not sure, but it looks like the current LibraryData setup might\neven predate salsa? It's not really needed and creates a bunch of\ncomplexity.\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "33d7ac893b83fa7f7dd93c53e69e24a1ab1f4f77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33d7ac893b83fa7f7dd93c53e69e24a1ab1f4f77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe6wo9CRBK7hj4Ov3rIwAAdHIIADzyc/XyIJqP8BAS1M3y316s\n9BU5i1RKMZE6E0aYlW3yalObsQ1vXx52ZsWBqeSDcfWSGeASW6/GrEBmMVJOgAtE\nLLwPF5pxmeHh0zsQaQO5p9btPZVdA9tf2sWxZuKTCagQxz6w0zGGl50iV9bIA1Yy\nCzZxP1UT86WqwJG7ENepD2sQZYAS8YzLCI+4puNHjm6D93C7vk+R4VV7049o5sq0\nThpNoDu7wHM9rjJPK29nEUXP8kOqjJMZvSr/7aRHHbdrPSIl0ogCfOLgav7mnSFM\noP94lriMlMy2SUwdi5F92dCUj5MHmri3QgbvIn6v+EjqVvifdq2yJFcZYKkFw4k=\n=CUgj\n-----END PGP SIGNATURE-----\n", "payload": "tree 33d7ac893b83fa7f7dd93c53e69e24a1ab1f4f77\nparent f5af48dc49dc4066a06e1b565c343de910131f40\nparent d1d0b5a88c666048c21fd225a08170fcc06060e5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1592461884 +0000\ncommitter GitHub <noreply@github.com> 1592461884 +0000\n\nMerge #4934\n\n4934: Remove special casing for library symbols r=matklad a=matklad\n\nWe might as well handle them internally, via queries.\n\nI am not sure, but it looks like the current LibraryData setup might\neven predate salsa? It's not really needed and creates a bunch of\ncomplexity.\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "html_url": "https://github.com/rust-lang/rust/commit/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5af48dc49dc4066a06e1b565c343de910131f40", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5af48dc49dc4066a06e1b565c343de910131f40", "html_url": "https://github.com/rust-lang/rust/commit/f5af48dc49dc4066a06e1b565c343de910131f40"}, {"sha": "d1d0b5a88c666048c21fd225a08170fcc06060e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1d0b5a88c666048c21fd225a08170fcc06060e5", "html_url": "https://github.com/rust-lang/rust/commit/d1d0b5a88c666048c21fd225a08170fcc06060e5"}], "stats": {"total": 281, "additions": 69, "deletions": 212}, "files": [{"sha": "51dc1f041ca51edadfd997253a76d06738594d5b", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "patch": "@@ -82,7 +82,7 @@ pub use ra_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRootId,\n };\n pub use ra_ide_db::{\n-    change::{AnalysisChange, LibraryData},\n+    change::AnalysisChange,\n     line_index::{LineCol, LineIndex},\n     search::SearchScope,\n     source_change::{FileSystemEdit, SourceChange, SourceFileEdit},"}, {"sha": "45411b357c10c0e41cf7e6664bb02b7bfcc6c816", "filename": "crates/ra_ide/src/status.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fstatus.rs?ref=99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "patch": "@@ -16,6 +16,7 @@ use ra_prof::{memory_usage, Bytes};\n use ra_syntax::{ast, Parse, SyntaxNode};\n \n use crate::FileId;\n+use rustc_hash::FxHashMap;\n \n fn syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n     db.query(ra_db::ParseQuery).entries::<SyntaxTreeStats>()\n@@ -123,20 +124,24 @@ struct LibrarySymbolsStats {\n \n impl fmt::Display for LibrarySymbolsStats {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{} ({}) symbols\", self.total, self.size,)\n+        write!(fmt, \"{} ({}) symbols\", self.total, self.size)\n     }\n }\n \n-impl FromIterator<TableEntry<SourceRootId, Arc<SymbolIndex>>> for LibrarySymbolsStats {\n+impl FromIterator<TableEntry<(), Arc<FxHashMap<SourceRootId, SymbolIndex>>>>\n+    for LibrarySymbolsStats\n+{\n     fn from_iter<T>(iter: T) -> LibrarySymbolsStats\n     where\n-        T: IntoIterator<Item = TableEntry<SourceRootId, Arc<SymbolIndex>>>,\n+        T: IntoIterator<Item = TableEntry<(), Arc<FxHashMap<SourceRootId, SymbolIndex>>>>,\n     {\n         let mut res = LibrarySymbolsStats::default();\n         for entry in iter {\n             let value = entry.value.unwrap();\n-            res.total += value.len();\n-            res.size += value.memory_size();\n+            for symbols in value.values() {\n+                res.total += symbols.len();\n+                res.size += symbols.memory_size();\n+            }\n         }\n         res\n     }"}, {"sha": "78ee6a51520e574d77fa5a616ae66e8500321abd", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 5, "deletions": 74, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "patch": "@@ -9,22 +9,15 @@ use ra_db::{\n     SourceRootId,\n };\n use ra_prof::{memory_usage, profile, Bytes};\n-use ra_syntax::SourceFile;\n-#[cfg(not(feature = \"wasm\"))]\n-use rayon::prelude::*;\n use rustc_hash::FxHashMap;\n \n-use crate::{\n-    symbol_index::{SymbolIndex, SymbolsDatabase},\n-    RootDatabase,\n-};\n+use crate::{symbol_index::SymbolsDatabase, RootDatabase};\n \n #[derive(Default)]\n pub struct AnalysisChange {\n     new_roots: Vec<(SourceRootId, bool)>,\n     roots_changed: FxHashMap<SourceRootId, RootChange>,\n     files_changed: Vec<(FileId, Arc<String>)>,\n-    libraries_added: Vec<LibraryData>,\n     crate_graph: Option<CrateGraph>,\n }\n \n@@ -40,9 +33,6 @@ impl fmt::Debug for AnalysisChange {\n         if !self.files_changed.is_empty() {\n             d.field(\"files_changed\", &self.files_changed.len());\n         }\n-        if !self.libraries_added.is_empty() {\n-            d.field(\"libraries_added\", &self.libraries_added.len());\n-        }\n         if self.crate_graph.is_some() {\n             d.field(\"crate_graph\", &self.crate_graph);\n         }\n@@ -79,10 +69,6 @@ impl AnalysisChange {\n         self.roots_changed.entry(root_id).or_default().removed.push(file);\n     }\n \n-    pub fn add_library(&mut self, data: LibraryData) {\n-        self.libraries_added.push(data)\n-    }\n-\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         self.crate_graph = Some(graph);\n     }\n@@ -116,47 +102,6 @@ impl fmt::Debug for RootChange {\n     }\n }\n \n-pub struct LibraryData {\n-    root_id: SourceRootId,\n-    root_change: RootChange,\n-    symbol_index: SymbolIndex,\n-}\n-\n-impl fmt::Debug for LibraryData {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LibraryData\")\n-            .field(\"root_id\", &self.root_id)\n-            .field(\"root_change\", &self.root_change)\n-            .field(\"n_symbols\", &self.symbol_index.len())\n-            .finish()\n-    }\n-}\n-\n-impl LibraryData {\n-    pub fn prepare(\n-        root_id: SourceRootId,\n-        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n-    ) -> LibraryData {\n-        let _p = profile(\"LibraryData::prepare\");\n-\n-        #[cfg(not(feature = \"wasm\"))]\n-        let iter = files.par_iter();\n-        #[cfg(feature = \"wasm\")]\n-        let iter = files.iter();\n-\n-        let symbol_index = SymbolIndex::for_files(iter.map(|(file_id, _, text)| {\n-            let parse = SourceFile::parse(text);\n-            (*file_id, parse)\n-        }));\n-        let mut root_change = RootChange::default();\n-        root_change.added = files\n-            .into_iter()\n-            .map(|(file_id, path, text)| AddFile { file_id, path, text })\n-            .collect();\n-        LibraryData { root_id, root_change, symbol_index }\n-    }\n-}\n-\n const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n \n impl RootDatabase {\n@@ -171,16 +116,20 @@ impl RootDatabase {\n         log::info!(\"apply_change {:?}\", change);\n         if !change.new_roots.is_empty() {\n             let mut local_roots = Vec::clone(&self.local_roots());\n+            let mut libraries = Vec::clone(&self.library_roots());\n             for (root_id, is_local) in change.new_roots {\n                 let root =\n                     if is_local { SourceRoot::new_local() } else { SourceRoot::new_library() };\n                 let durability = durability(&root);\n                 self.set_source_root_with_durability(root_id, Arc::new(root), durability);\n                 if is_local {\n                     local_roots.push(root_id);\n+                } else {\n+                    libraries.push(root_id)\n                 }\n             }\n             self.set_local_roots_with_durability(Arc::new(local_roots), Durability::HIGH);\n+            self.set_library_roots_with_durability(Arc::new(libraries), Durability::HIGH);\n         }\n \n         for (root_id, root_change) in change.roots_changed {\n@@ -192,24 +141,6 @@ impl RootDatabase {\n             let durability = durability(&source_root);\n             self.set_file_text_with_durability(file_id, text, durability)\n         }\n-        if !change.libraries_added.is_empty() {\n-            let mut libraries = Vec::clone(&self.library_roots());\n-            for library in change.libraries_added {\n-                libraries.push(library.root_id);\n-                self.set_source_root_with_durability(\n-                    library.root_id,\n-                    Arc::new(SourceRoot::new_library()),\n-                    Durability::HIGH,\n-                );\n-                self.set_library_symbols_with_durability(\n-                    library.root_id,\n-                    Arc::new(library.symbol_index),\n-                    Durability::HIGH,\n-                );\n-                self.apply_root_change(library.root_id, library.root_change);\n-            }\n-            self.set_library_roots_with_durability(Arc::new(libraries), Durability::HIGH);\n-        }\n         if let Some(crate_graph) = change.crate_graph {\n             self.set_crate_graph_with_durability(Arc::new(crate_graph), Durability::HIGH)\n         }"}, {"sha": "25c99813f26c989b6cb4b9c76e349babbd22deba", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "patch": "@@ -34,14 +34,15 @@ use ra_db::{\n     salsa::{self, ParallelDatabase},\n     CrateId, FileId, SourceDatabaseExt, SourceRootId,\n };\n+use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, NameOwner},\n     match_ast, AstNode, Parse, SmolStr, SourceFile,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxNodePtr, TextRange, WalkEvent,\n };\n-#[cfg(not(feature = \"wasm\"))]\n use rayon::prelude::*;\n+use rustc_hash::FxHashMap;\n \n use crate::RootDatabase;\n \n@@ -86,10 +87,9 @@ impl Query {\n }\n \n #[salsa::query_group(SymbolsDatabaseStorage)]\n-pub trait SymbolsDatabase: hir::db::HirDatabase {\n+pub trait SymbolsDatabase: hir::db::HirDatabase + SourceDatabaseExt + ParallelDatabase {\n     fn file_symbols(&self, file_id: FileId) -> Arc<SymbolIndex>;\n-    #[salsa::input]\n-    fn library_symbols(&self, id: SourceRootId) -> Arc<SymbolIndex>;\n+    fn library_symbols(&self) -> Arc<FxHashMap<SourceRootId, SymbolIndex>>;\n     /// The set of \"local\" (that is, from the current workspace) roots.\n     /// Files in local roots are assumed to change frequently.\n     #[salsa::input]\n@@ -100,6 +100,29 @@ pub trait SymbolsDatabase: hir::db::HirDatabase {\n     fn library_roots(&self) -> Arc<Vec<SourceRootId>>;\n }\n \n+fn library_symbols(\n+    db: &(impl SymbolsDatabase + ParallelDatabase),\n+) -> Arc<FxHashMap<SourceRootId, SymbolIndex>> {\n+    let _p = profile(\"library_symbols\");\n+\n+    let roots = db.library_roots();\n+    let res = roots\n+        .iter()\n+        .map(|&root_id| {\n+            let root = db.source_root(root_id);\n+            let files = root\n+                .walk()\n+                .map(|it| (it, SourceDatabaseExt::file_text(db, it)))\n+                .collect::<Vec<_>>();\n+            let symbol_index = SymbolIndex::for_files(\n+                files.into_par_iter().map(|(file, text)| (file, SourceFile::parse(&text))),\n+            );\n+            (root_id, symbol_index)\n+        })\n+        .collect();\n+    Arc::new(res)\n+}\n+\n fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex> {\n     db.check_canceled();\n     let parse = db.parse(file_id);\n@@ -112,9 +135,9 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n }\n \n /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n-struct Snap(salsa::Snapshot<RootDatabase>);\n-impl Clone for Snap {\n-    fn clone(&self) -> Snap {\n+struct Snap<DB>(DB);\n+impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n+    fn clone(&self) -> Snap<salsa::Snapshot<DB>> {\n         Snap(self.0.snapshot())\n     }\n }\n@@ -143,19 +166,11 @@ impl Clone for Snap {\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     let _p = ra_prof::profile(\"world_symbols\").detail(|| query.query.clone());\n \n-    let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n-        let snap = Snap(db.snapshot());\n-        #[cfg(not(feature = \"wasm\"))]\n-        let buf = db\n-            .library_roots()\n-            .par_iter()\n-            .map_with(snap, |db, &lib_id| db.0.library_symbols(lib_id))\n-            .collect();\n-\n-        #[cfg(feature = \"wasm\")]\n-        let buf = db.library_roots().iter().map(|&lib_id| snap.0.library_symbols(lib_id)).collect();\n-\n-        buf\n+    let tmp1;\n+    let tmp2;\n+    let buf: Vec<&SymbolIndex> = if query.libs {\n+        tmp1 = db.library_symbols();\n+        tmp1.values().collect()\n     } else {\n         let mut files = Vec::new();\n         for &root in db.local_roots().iter() {\n@@ -164,14 +179,11 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n         }\n \n         let snap = Snap(db.snapshot());\n-        #[cfg(not(feature = \"wasm\"))]\n-        let buf =\n-            files.par_iter().map_with(snap, |db, &file_id| db.0.file_symbols(file_id)).collect();\n-\n-        #[cfg(feature = \"wasm\")]\n-        let buf = files.iter().map(|&file_id| snap.0.file_symbols(file_id)).collect();\n-\n-        buf\n+        tmp2 = files\n+            .par_iter()\n+            .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n+            .collect::<Vec<_>>();\n+        tmp2.iter().map(|it| &**it).collect()\n     };\n     query.search(&buf)\n }\n@@ -191,14 +203,11 @@ pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<Fil\n \n     let snap = Snap(db.snapshot());\n \n-    #[cfg(not(feature = \"wasm\"))]\n     let buf = files\n         .par_iter()\n         .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n         .collect::<Vec<_>>();\n-\n-    #[cfg(feature = \"wasm\")]\n-    let buf = files.iter().map(|&file_id| snap.0.file_symbols(file_id)).collect::<Vec<_>>();\n+    let buf = buf.iter().map(|it| &**it).collect::<Vec<_>>();\n \n     query.search(&buf)\n }\n@@ -245,12 +254,8 @@ impl SymbolIndex {\n             lhs_chars.cmp(rhs_chars)\n         }\n \n-        #[cfg(not(feature = \"wasm\"))]\n         symbols.par_sort_by(cmp);\n \n-        #[cfg(feature = \"wasm\")]\n-        symbols.sort_by(cmp);\n-\n         let mut builder = fst::MapBuilder::memory();\n \n         let mut last_batch_start = 0;\n@@ -284,7 +289,6 @@ impl SymbolIndex {\n         self.map.as_fst().size() + self.symbols.len() * mem::size_of::<FileSymbol>()\n     }\n \n-    #[cfg(not(feature = \"wasm\"))]\n     pub(crate) fn for_files(\n         files: impl ParallelIterator<Item = (FileId, Parse<ast::SourceFile>)>,\n     ) -> SymbolIndex {\n@@ -294,16 +298,6 @@ impl SymbolIndex {\n         SymbolIndex::new(symbols)\n     }\n \n-    #[cfg(feature = \"wasm\")]\n-    pub(crate) fn for_files(\n-        files: impl Iterator<Item = (FileId, Parse<ast::SourceFile>)>,\n-    ) -> SymbolIndex {\n-        let symbols = files\n-            .flat_map(|(file_id, file)| source_file_to_file_symbols(&file.tree(), file_id))\n-            .collect::<Vec<_>>();\n-        SymbolIndex::new(symbols)\n-    }\n-\n     fn range_to_map_value(start: usize, end: usize) -> u64 {\n         debug_assert![start <= (std::u32::MAX as usize)];\n         debug_assert![end <= (std::u32::MAX as usize)];\n@@ -319,7 +313,7 @@ impl SymbolIndex {\n }\n \n impl Query {\n-    pub(crate) fn search(self, indices: &[Arc<SymbolIndex>]) -> Vec<FileSymbol> {\n+    pub(crate) fn search(self, indices: &[&SymbolIndex]) -> Vec<FileSymbol> {\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n             let automaton = fst::automaton::Subsequence::new(&self.lowercased);"}, {"sha": "ca95d776af17266b5618d6ab206fecd48c9ffb4a", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 7, "deletions": 30, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "patch": "@@ -12,12 +12,9 @@ use crossbeam_channel::{unbounded, Receiver};\n use lsp_types::Url;\n use parking_lot::RwLock;\n use ra_flycheck::{Flycheck, FlycheckConfig};\n-use ra_ide::{\n-    Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData, SourceRootId,\n-};\n+use ra_ide::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, SourceRootId};\n use ra_project_model::{CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target};\n use ra_vfs::{LineEndings, RootEntry, Vfs, VfsChange, VfsFile, VfsTask, Watch};\n-use relative_path::RelativePathBuf;\n use stdx::format_to;\n \n use crate::{\n@@ -191,32 +188,18 @@ impl GlobalState {\n \n     /// Returns a vec of libraries\n     /// FIXME: better API here\n-    pub fn process_changes(\n-        &mut self,\n-        roots_scanned: &mut usize,\n-    ) -> Option<Vec<(SourceRootId, Vec<(FileId, RelativePathBuf, Arc<String>)>)>> {\n+    pub fn process_changes(&mut self, roots_scanned: &mut usize) -> bool {\n         let changes = self.vfs.write().commit_changes();\n         if changes.is_empty() {\n-            return None;\n+            return false;\n         }\n-        let mut libs = Vec::new();\n         let mut change = AnalysisChange::new();\n         for c in changes {\n             match c {\n                 VfsChange::AddRoot { root, files } => {\n-                    let root_path = self.vfs.read().root2path(root);\n-                    let is_local = self.local_roots.iter().any(|r| root_path.starts_with(r));\n-                    if is_local {\n-                        *roots_scanned += 1;\n-                        for (file, path, text) in files {\n-                            change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n-                        }\n-                    } else {\n-                        let files = files\n-                            .into_iter()\n-                            .map(|(vfsfile, path, text)| (FileId(vfsfile.0), path, text))\n-                            .collect();\n-                        libs.push((SourceRootId(root.0), files));\n+                    *roots_scanned += 1;\n+                    for (file, path, text) in files {\n+                        change.add_file(SourceRootId(root.0), FileId(file.0), path, text);\n                     }\n                 }\n                 VfsChange::AddFile { root, file, path, text } => {\n@@ -231,13 +214,7 @@ impl GlobalState {\n             }\n         }\n         self.analysis_host.apply_change(change);\n-        Some(libs)\n-    }\n-\n-    pub fn add_lib(&mut self, data: LibraryData) {\n-        let mut change = AnalysisChange::new();\n-        change.add_library(data);\n-        self.analysis_host.apply_change(change);\n+        true\n     }\n \n     pub fn snapshot(&self) -> GlobalStateSnapshot {"}, {"sha": "08b0a5a169f74b2823d5baa2e5d936b3e68070fc", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 54, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99e3acd1fec3cd9c1a77b029a4f4e6fce040c102/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=99e3acd1fec3cd9c1a77b029a4f4e6fce040c102", "patch": "@@ -24,11 +24,10 @@ use lsp_types::{\n     WorkDoneProgressReport,\n };\n use ra_flycheck::{CheckTask, Status};\n-use ra_ide::{Canceled, FileId, LibraryData, LineIndex, SourceRootId};\n+use ra_ide::{Canceled, FileId, LineIndex};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n use ra_vfs::{VfsTask, Watch};\n-use relative_path::RelativePathBuf;\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n@@ -174,12 +173,10 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n \n     let pool = ThreadPool::default();\n     let (task_sender, task_receiver) = unbounded::<Task>();\n-    let (libdata_sender, libdata_receiver) = unbounded::<LibraryData>();\n \n     log::info!(\"server initialized, serving requests\");\n     {\n         let task_sender = task_sender;\n-        let libdata_sender = libdata_sender;\n         loop {\n             log::trace!(\"selecting\");\n             let event = select! {\n@@ -192,7 +189,6 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                     Ok(task) => Event::Vfs(task),\n                     Err(RecvError) => return Err(\"vfs died\".into()),\n                 },\n-                recv(libdata_receiver) -> data => Event::Lib(data.unwrap()),\n                 recv(global_state.flycheck.as_ref().map_or(&never(), |it| &it.task_recv)) -> task => match task {\n                     Ok(task) => Event::CheckWatcher(task),\n                     Err(RecvError) => return Err(\"check watcher died\".into()),\n@@ -203,23 +199,14 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n                     break;\n                 };\n             }\n-            loop_turn(\n-                &pool,\n-                &task_sender,\n-                &libdata_sender,\n-                &connection,\n-                &mut global_state,\n-                &mut loop_state,\n-                event,\n-            )?;\n+            loop_turn(&pool, &task_sender, &connection, &mut global_state, &mut loop_state, event)?;\n         }\n     }\n     global_state.analysis_host.request_cancellation();\n     log::info!(\"waiting for tasks to finish...\");\n     task_receiver.into_iter().for_each(|task| {\n         on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut global_state)\n     });\n-    libdata_receiver.into_iter().for_each(drop);\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n     pool.join();\n@@ -243,7 +230,6 @@ enum Event {\n     Msg(Message),\n     Task(Task),\n     Vfs(VfsTask),\n-    Lib(LibraryData),\n     CheckWatcher(CheckTask),\n }\n \n@@ -279,7 +265,6 @@ impl fmt::Debug for Event {\n             Event::Msg(it) => fmt::Debug::fmt(it, f),\n             Event::Task(it) => fmt::Debug::fmt(it, f),\n             Event::Vfs(it) => fmt::Debug::fmt(it, f),\n-            Event::Lib(it) => fmt::Debug::fmt(it, f),\n             Event::CheckWatcher(it) => fmt::Debug::fmt(it, f),\n         }\n     }\n@@ -291,10 +276,6 @@ struct LoopState {\n     pending_responses: FxHashSet<RequestId>,\n     pending_requests: PendingRequests,\n     subscriptions: Subscriptions,\n-    // We try not to index more than MAX_IN_FLIGHT_LIBS libraries at the same\n-    // time to always have a thread ready to react to input.\n-    in_flight_libraries: usize,\n-    pending_libraries: Vec<(SourceRootId, Vec<(FileId, RelativePathBuf, Arc<String>)>)>,\n     workspace_loaded: bool,\n     roots_progress_reported: Option<usize>,\n     roots_scanned: usize,\n@@ -315,7 +296,6 @@ impl LoopState {\n fn loop_turn(\n     pool: &ThreadPool,\n     task_sender: &Sender<Task>,\n-    libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n     global_state: &mut GlobalState,\n     loop_state: &mut LoopState,\n@@ -339,12 +319,6 @@ fn loop_turn(\n         Event::Vfs(task) => {\n             global_state.vfs.write().handle_task(task);\n         }\n-        Event::Lib(lib) => {\n-            global_state.add_lib(lib);\n-            global_state.maybe_collect_garbage();\n-            loop_state.in_flight_libraries -= 1;\n-            loop_state.roots_scanned += 1;\n-        }\n         Event::CheckWatcher(task) => on_check_task(task, global_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n@@ -390,36 +364,12 @@ fn loop_turn(\n         },\n     };\n \n-    let mut state_changed = false;\n-    if let Some(changes) = global_state.process_changes(&mut loop_state.roots_scanned) {\n-        state_changed = true;\n-        loop_state.pending_libraries.extend(changes);\n-    }\n-\n-    let max_in_flight_libs = pool.max_count().saturating_sub(2).max(1);\n-    while loop_state.in_flight_libraries < max_in_flight_libs {\n-        let (root, files) = match loop_state.pending_libraries.pop() {\n-            Some(it) => it,\n-            None => break,\n-        };\n-\n-        loop_state.in_flight_libraries += 1;\n-        let sender = libdata_sender.clone();\n-        pool.execute(move || {\n-            log::info!(\"indexing {:?} ... \", root);\n-            let data = LibraryData::prepare(root, files);\n-            sender.send(data).unwrap();\n-        });\n-    }\n+    let mut state_changed = global_state.process_changes(&mut loop_state.roots_scanned);\n \n     let show_progress =\n         !loop_state.workspace_loaded && global_state.config.client_caps.work_done_progress;\n \n-    if !loop_state.workspace_loaded\n-        && loop_state.roots_scanned == loop_state.roots_total\n-        && loop_state.pending_libraries.is_empty()\n-        && loop_state.in_flight_libraries == 0\n-    {\n+    if !loop_state.workspace_loaded && loop_state.roots_scanned == loop_state.roots_total {\n         state_changed = true;\n         loop_state.workspace_loaded = true;\n         if let Some(flycheck) = &global_state.flycheck {"}]}