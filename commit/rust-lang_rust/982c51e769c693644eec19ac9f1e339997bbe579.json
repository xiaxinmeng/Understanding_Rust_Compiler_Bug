{"sha": "982c51e769c693644eec19ac9f1e339997bbe579", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MmM1MWU3NjljNjkzNjQ0ZWVjMTlhYzlmMWUzMzk5OTdiYmU1Nzk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2019-09-25T19:00:17Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2019-09-25T19:52:16Z"}, "message": "arm.pats -> arm.pat", "tree": {"sha": "6aa7860dc37a2d0809dd5f943f6bed3d20079088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aa7860dc37a2d0809dd5f943f6bed3d20079088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/982c51e769c693644eec19ac9f1e339997bbe579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/982c51e769c693644eec19ac9f1e339997bbe579", "html_url": "https://github.com/rust-lang/rust/commit/982c51e769c693644eec19ac9f1e339997bbe579", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/982c51e769c693644eec19ac9f1e339997bbe579/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68c26b325b35e6984b585d285b17dd5eadb3c860", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c26b325b35e6984b585d285b17dd5eadb3c860", "html_url": "https://github.com/rust-lang/rust/commit/68c26b325b35e6984b585d285b17dd5eadb3c860"}], "stats": {"total": 309, "additions": 137, "deletions": 172}, "files": [{"sha": "33603b27b7a4b9db146f145d2d25fc6cc66e97be", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -112,8 +112,7 @@ impl<'tcx> Visitor<'tcx> for CCHelper {\n         walk_expr(self, e);\n         match e.node {\n             ExprKind::Match(_, ref arms, _) => {\n-                let arms_n: u64 = arms.iter().map(|arm| arm.pats.len() as u64).sum();\n-                if arms_n > 1 {\n+                if arms.len() > 1 {\n                     self.cc += 1;\n                 }\n                 self.cc += arms.iter().filter(|arm| arm.guard.is_some()).count() as u64;"}, {"sha": "bdef21b0e69b43baf2350cb8e65cdcb474eef20f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -193,7 +193,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n             (min_index..=max_index).all(|index| arms[index].guard.is_none()) &&\n                 SpanlessEq::new(cx).eq_expr(&lhs.body, &rhs.body) &&\n                 // all patterns should have the same bindings\n-                same_bindings(cx, &bindings(cx, &lhs.pats[0]), &bindings(cx, &rhs.pats[0]))\n+                same_bindings(cx, &bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n         };\n \n         let indexed_arms: Vec<(usize, &Arm)> = arms.iter().enumerate().collect();\n@@ -213,27 +213,22 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n                     // span for the whole pattern, the suggestion is only shown when there is only\n                     // one pattern. The user should know about `|` if they are already using it\u2026\n \n-                    if i.pats.len() == 1 && j.pats.len() == 1 {\n-                        let lhs = snippet(cx, i.pats[0].span, \"<pat1>\");\n-                        let rhs = snippet(cx, j.pats[0].span, \"<pat2>\");\n-\n-                        if let PatKind::Wild = j.pats[0].node {\n-                            // if the last arm is _, then i could be integrated into _\n-                            // note that i.pats[0] cannot be _, because that would mean that we're\n-                            // hiding all the subsequent arms, and rust won't compile\n-                            db.span_note(\n-                                i.body.span,\n-                                &format!(\n-                                    \"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n-                                    lhs\n-                                ),\n-                            );\n-                        } else {\n-                            db.span_help(\n-                                i.pats[0].span,\n-                                &format!(\"consider refactoring into `{} | {}`\", lhs, rhs),\n-                            );\n-                        }\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.node {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        db.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it`\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        db.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs));\n                     }\n                 },\n             );"}, {"sha": "4f763863ffdeda5c3ad314ce8468a87562d6576c", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -84,9 +84,8 @@ fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arm\n         if let ExprKind::Path(ref qpath) = args[1].node;\n         if let Some(did) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n         if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n-        if arms[0].pats.len() == 1;\n         // check `(arg0,)` in match block\n-        if let PatKind::Tuple(ref pats, None) = arms[0].pats[0].node;\n+        if let PatKind::Tuple(ref pats, None) = arms[0].pat.node;\n         if pats.len() == 1;\n         then {\n             let ty = walk_ptrs_ty(cx.tables.pat_ty(&pats[0]));"}, {"sha": "2ae2e200639946eb0ca709e31f324911e3e31e44", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -47,8 +47,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfallibleDestructingMatch {\n         if_chain! {\n             if let Some(ref expr) = local.init;\n             if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.node;\n-            if arms.len() == 1 && arms[0].pats.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pats[0].node;\n+            if arms.len() == 1 && arms[0].guard.is_none();\n+            if let PatKind::TupleStruct(QPath::Resolved(None, ref variant_name), ref args, _) = arms[0].pat.node;\n             if args.len() == 1;\n             if let Some(arg) = get_arg_name(&args[0]);\n             let body = remove_blocks(&arms[0].body);"}, {"sha": "94328a2b5e3dfc84ecc481a769cb14d07287340d", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -517,9 +517,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n                     match *source {\n                         MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n                             if arms.len() == 2\n-                                && arms[0].pats.len() == 1\n                                 && arms[0].guard.is_none()\n-                                && arms[1].pats.len() == 1\n                                 && arms[1].guard.is_none()\n                                 && is_simple_break_expr(&arms[1].body)\n                             {\n@@ -541,7 +539,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n                                     \"try\",\n                                     format!(\n                                         \"while let {} = {} {{ .. }}\",\n-                                        snippet_with_applicability(cx, arms[0].pats[0].span, \"..\", &mut applicability),\n+                                        snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n                                         snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n                                     ),\n                                     applicability,\n@@ -554,7 +552,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n             }\n         }\n         if let ExprKind::Match(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n-            let pat = &arms[0].pats[0].node;\n+            let pat = &arms[0].pat.node;\n             if let (\n                 &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n                 &ExprKind::MethodCall(ref method_path, _, ref method_args),"}, {"sha": "3d765af21edbc0413a49b0451124a8dd07976c10", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 32, "deletions": 51, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -14,7 +14,6 @@ use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use std::cmp::Ordering;\n use std::collections::Bound;\n-use std::ops::Deref;\n use syntax::ast::LitKind;\n use syntax::source_map::Span;\n \n@@ -255,9 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n \n #[rustfmt::skip]\n fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    if arms.len() == 2 &&\n-      arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-      arms[1].pats.len() == 1 && arms[1].guard.is_none() {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n         let els = remove_blocks(&arms[1].body);\n         let els = if is_unit_expr(els) {\n             None\n@@ -283,7 +280,7 @@ fn check_single_match_single_pattern(\n     expr: &Expr,\n     els: Option<&Expr>,\n ) {\n-    if is_wild(&arms[1].pats[0]) {\n+    if is_wild(&arms[1].pat) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n@@ -308,7 +305,7 @@ fn report_single_match_single_pattern(\n         \"try this\",\n         format!(\n             \"if let {} = {} {}{}\",\n-            snippet(cx, arms[0].pats[0].span, \"..\"),\n+            snippet(cx, arms[0].pat.span, \"..\"),\n             snippet(cx, ex.span, \"..\"),\n             expr_block(cx, &arms[0].body, None, \"..\"),\n             els_str,\n@@ -336,7 +333,7 @@ fn check_single_match_opt_like(\n         (&paths::RESULT, \"Ok\"),\n     ];\n \n-    let path = match arms[1].pats[0].node {\n+    let path = match arms[1].pat.node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n             // Contains any non wildcard patterns (e.g., `Err(err)`)?\n             if !inner.iter().all(is_wild) {\n@@ -365,9 +362,9 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Ex\n             expr.span,\n             \"you seem to be trying to match on a boolean expression\",\n             move |db| {\n-                if arms.len() == 2 && arms[0].pats.len() == 1 {\n+                if arms.len() == 2 {\n                     // no guards\n-                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n+                    let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pat.node {\n                         if let ExprKind::Lit(ref lit) = arm_bool.node {\n                             match lit.node {\n                                 LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n@@ -446,7 +443,7 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n-            if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pats[0].node {\n+            if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pat.node {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n                 if_chain! {\n                     if path_str == \"Err\";\n@@ -457,9 +454,9 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n                         // `Err(_)` arm with `panic!` found\n                         span_note_and_lint(cx,\n                                            MATCH_WILD_ERR_ARM,\n-                                           arm.pats[0].span,\n+                                           arm.pat.span,\n                                            \"Err(_) will match all errors, maybe not a good idea\",\n-                                           arm.pats[0].span,\n+                                           arm.pat.span,\n                                            \"to remove this warning, match each error separately \\\n                                             or use unreachable macro\");\n                     }\n@@ -482,13 +479,11 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     let mut wildcard_span = None;\n     let mut wildcard_ident = None;\n     for arm in arms {\n-        for pat in &arm.pats {\n-            if let PatKind::Wild = pat.node {\n-                wildcard_span = Some(pat.span);\n-            } else if let PatKind::Binding(_, _, ident, None) = pat.node {\n-                wildcard_span = Some(pat.span);\n-                wildcard_ident = Some(ident);\n-            }\n+        if let PatKind::Wild = arm.pat.node {\n+            wildcard_span = Some(arm.pat.span);\n+        } else if let PatKind::Binding(_, _, ident, None) = arm.pat.node {\n+            wildcard_span = Some(arm.pat.span);\n+            wildcard_ident = Some(ident);\n         }\n     }\n \n@@ -510,15 +505,13 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n                 // covered by the set of guards that cover it, but that's really hard to do.\n                 continue;\n             }\n-            for pat in &arm.pats {\n-                if let PatKind::Path(ref path) = pat.deref().node {\n-                    if let QPath::Resolved(_, p) = path {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n-                    }\n-                } else if let PatKind::TupleStruct(ref path, ..) = pat.deref().node {\n-                    if let QPath::Resolved(_, p) = path {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n-                    }\n+            if let PatKind::Path(ref path) = arm.pat.node {\n+                if let QPath::Resolved(_, p) = path {\n+                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n+                }\n+            } else if let PatKind::TupleStruct(ref path, ..) = arm.pat.node {\n+                if let QPath::Resolved(_, p) = path {\n+                    missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                 }\n             }\n         }\n@@ -588,9 +581,9 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n             )\n         };\n \n-        suggs.extend(arms.iter().flat_map(|a| &a.pats).filter_map(|p| {\n-            if let PatKind::Ref(ref refp, _) = p.node {\n-                Some((p.span, snippet(cx, refp.span, \"..\").to_string()))\n+        suggs.extend(arms.iter().filter_map(|a| {\n+            if let PatKind::Ref(ref refp, _) = a.pat.node {\n+                Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n             } else {\n                 None\n             }\n@@ -605,12 +598,7 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n }\n \n fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n-    if arms.len() == 2\n-        && arms[0].pats.len() == 1\n-        && arms[0].guard.is_none()\n-        && arms[1].pats.len() == 1\n-        && arms[1].guard.is_none()\n-    {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n         let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n             is_ref_some_arm(&arms[1])\n         } else if is_none_arm(&arms[1]) {\n@@ -666,14 +654,9 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<Sp\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm {\n-                ref pats, guard: None, ..\n+                ref pat, guard: None, ..\n             } = *arm\n             {\n-                pats.iter()\n-            } else {\n-                [].iter()\n-            }\n-            .filter_map(|pat| {\n                 if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node {\n                     let lhs = constant(cx, cx.tables, lhs)?.0;\n                     let rhs = constant(cx, cx.tables, rhs)?.0;\n@@ -694,9 +677,8 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<Sp\n                         node: (value.clone(), Bound::Included(value)),\n                     });\n                 }\n-\n-                None\n-            })\n+            }\n+            None\n         })\n         .collect()\n }\n@@ -743,7 +725,7 @@ fn is_unit_expr(expr: &Expr) -> bool {\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm) -> bool {\n-    match arm.pats[0].node {\n+    match arm.pat.node {\n         PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n         _ => false,\n     }\n@@ -752,7 +734,7 @@ fn is_none_arm(arm: &Arm) -> bool {\n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pats[0].node;\n+        if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pat.node;\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n         if let PatKind::Binding(rb, .., ident, _) = pats[0].node;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n@@ -772,9 +754,8 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     let mapped = arms\n         .iter()\n-        .flat_map(|a| &a.pats)\n-        .map(|p| {\n-            match p.node {\n+        .map(|a| {\n+            match a.pat.node {\n                 PatKind::Ref(..) => Some(true), // &-patterns\n                 PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n                 _ => None,                      // any other pattern is not fine"}, {"sha": "7105376d5983419f8d58bdab79ce8915dbe04c5e", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n             if let ExprKind::Match(ref op, ref body, ref source) = expr.node; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n             if let ExprKind::MethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n-            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n+            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.node; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n \n             then {"}, {"sha": "b8d1ea3851f662969fb89067e2ff275bf6033ec9", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -57,50 +57,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPatternMatching {\n }\n \n fn find_sugg_for_if_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, op: &P<Expr>, arms: &HirVec<Arm>) {\n-    if arms[0].pats.len() == 1 {\n-        let good_method = match arms[0].pats[0].node {\n-            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n-                if let PatKind::Wild = patterns[0].node {\n-                    if match_qpath(path, &paths::RESULT_OK) {\n-                        \"is_ok()\"\n-                    } else if match_qpath(path, &paths::RESULT_ERR) {\n-                        \"is_err()\"\n-                    } else if match_qpath(path, &paths::OPTION_SOME) {\n-                        \"is_some()\"\n-                    } else {\n-                        return;\n-                    }\n+    let good_method = match arms[0].pat.node {\n+        PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+            if let PatKind::Wild = patterns[0].node {\n+                if match_qpath(path, &paths::RESULT_OK) {\n+                    \"is_ok()\"\n+                } else if match_qpath(path, &paths::RESULT_ERR) {\n+                    \"is_err()\"\n+                } else if match_qpath(path, &paths::OPTION_SOME) {\n+                    \"is_some()\"\n                 } else {\n                     return;\n                 }\n-            },\n+            } else {\n+                return;\n+            }\n+        },\n \n-            PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n+        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n \n-            _ => return,\n-        };\n+        _ => return,\n+    };\n \n-        span_lint_and_then(\n-            cx,\n-            REDUNDANT_PATTERN_MATCHING,\n-            arms[0].pats[0].span,\n-            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-            |db| {\n-                let span = expr.span.to(op.span);\n-                db.span_suggestion(\n-                    span,\n-                    \"try this\",\n-                    format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                    Applicability::MaybeIncorrect, // snippet\n-                );\n-            },\n-        );\n-    }\n+    span_lint_and_then(\n+        cx,\n+        REDUNDANT_PATTERN_MATCHING,\n+        arms[0].pat.span,\n+        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+        |db| {\n+            let span = expr.span.to(op.span);\n+            db.span_suggestion(\n+                span,\n+                \"try this\",\n+                format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                Applicability::MaybeIncorrect, // snippet\n+            );\n+        },\n+    );\n }\n \n fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, op: &P<Expr>, arms: &HirVec<Arm>) {\n     if arms.len() == 2 {\n-        let node_pair = (&arms[0].pats[0].node, &arms[1].pats[0].node);\n+        let node_pair = (&arms[0].pat.node, &arms[1].pat.node);\n \n         let found_good_method = match node_pair {\n             ("}, {"sha": "ebef0449cc98e95cb1e56db0b2dc5fbfab245f7b", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -328,17 +328,15 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n-                for pat in &arm.pats {\n-                    check_pat(cx, pat, Some(&**init), pat.span, bindings);\n-                    // This is ugly, but needed to get the right type\n-                    if let Some(ref guard) = arm.guard {\n-                        match guard {\n-                            Guard::If(if_expr) => check_expr(cx, if_expr, bindings),\n-                        }\n+                check_pat(cx, &arm.pat, Some(&**init), arm.pat.span, bindings);\n+                // This is ugly, but needed to get the right type\n+                if let Some(ref guard) = arm.guard {\n+                    match guard {\n+                        Guard::If(if_expr) => check_expr(cx, if_expr, bindings),\n                     }\n-                    check_expr(cx, &arm.body, bindings);\n-                    bindings.truncate(len);\n                 }\n+                check_expr(cx, &arm.body, bindings);\n+                bindings.truncate(len);\n             }\n         },\n         _ => (),"}, {"sha": "044e9838090a68244b53e9aa658e3bb98f5c58c6", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -354,11 +354,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                             },\n                         }\n                     }\n-                    println!(\"    if {}[{}].pats.len() == {};\", arms_pat, i, arm.pats.len());\n-                    for (j, pat) in arm.pats.iter().enumerate() {\n-                        self.current = format!(\"{}[{}].pats[{}]\", arms_pat, i, j);\n-                        self.visit_pat(pat);\n-                    }\n+                    self.current = format!(\"{}[{}].pat\", arms_pat, i);\n+                    self.visit_pat(&arm.pat);\n                 }\n             },\n             ExprKind::Closure(ref _capture_clause, ref _func, _, _, _) => {"}, {"sha": "deea5823f13936c4e1353d2b344ce0014c885feb", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     && over(la, ra, |l, r| {\n                         self.eq_expr(&l.body, &r.body)\n                             && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                            && over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                            && self.eq_pat(&l.pat, &r.pat)\n                     })\n             },\n             (&ExprKind::MethodCall(ref l_path, _, ref l_args), &ExprKind::MethodCall(ref r_path, _, ref r_args)) => {"}, {"sha": "d70f8bab8f73ac04ae14e7199c2ce2c44743bcea", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -101,9 +101,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n         if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n-        for pat in &arm.pats {\n-            print_pat(cx, pat, 1);\n-        }\n+        print_pat(cx, &arm.pat, 1);\n         if let Some(ref guard) = arm.guard {\n             println!(\"guard:\");\n             print_guard(cx, guard, 1);"}, {"sha": "88229da8c1a68bd8563a9e13fbf72d4c2d1ac6b1", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -909,7 +909,7 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     fn is_ok(arm: &Arm) -> bool {\n         if_chain! {\n-            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n+            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.node;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].node;\n             if let ExprKind::Path(QPath::Resolved(None, ref path)) = arm.body.node;\n@@ -923,7 +923,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     }\n \n     fn is_err(arm: &Arm) -> bool {\n-        if let PatKind::TupleStruct(ref path, _, _) = arm.pats[0].node {\n+        if let PatKind::TupleStruct(ref path, _, _) = arm.pat.node {\n             match_qpath(path, &paths::RESULT_ERR[1..])\n         } else {\n             false\n@@ -938,8 +938,8 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n \n         if_chain! {\n             if arms.len() == 2;\n-            if arms[0].pats.len() == 1 && arms[0].guard.is_none();\n-            if arms[1].pats.len() == 1 && arms[1].guard.is_none();\n+            if arms[0].guard.is_none();\n+            if arms[1].guard.is_none();\n             if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n                 (is_ok(&arms[1]) && is_err(&arms[0]));\n             then {"}, {"sha": "d195c7fdb958a20fe054826b62804dcaa37618d6", "filename": "tests/ui/author/for_loop.stdout", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fauthor%2Ffor_loop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Ffor_loop.stdout?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -31,14 +31,12 @@ if_chain! {\n     if match_qpath(path4, &[\"__next\"]);\n     if let ExprKind::Path(ref path5) = value.node;\n     if match_qpath(path5, &[\"val\"]);\n-    if arms1[0].pats.len() == 1;\n-    if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pats[0].node;\n+    if let PatKind::TupleStruct(ref path6, ref fields1, None) = arms1[0].pat.node;\n     if match_qpath(path6, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"Some\"]);\n     if fields1.len() == 1;\n     // unimplemented: field checks\n     if let ExprKind::Break(ref destination, None) = arms1[1].body.node;\n-    if arms1[1].pats.len() == 1;\n-    if let PatKind::Path(ref path7) = arms1[1].pats[0].node;\n+    if let PatKind::Path(ref path7) = arms1[1].pat.node;\n     if match_qpath(path7, &[\"{{root}}\", \"std\", \"option\", \"Option\", \"None\"]);\n     if let StmtKind::Local(ref local1) = body.stmts[2].node;\n     if let Some(ref init) = local1.init;\n@@ -56,8 +54,7 @@ if_chain! {\n     if match_qpath(path9, &[\"y\"]);\n     if let PatKind::Binding(BindingAnnotation::Unannotated, _, name2, None) = local2.pat.node;\n     if name2.node.as_str() == \"z\";\n-    if arms[0].pats.len() == 1;\n-    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pats[0].node;\n+    if let PatKind::Binding(BindingAnnotation::Mutable, _, name3, None) = arms[0].pat.node;\n     if name3.node.as_str() == \"iter\";\n     then {\n         // report your lint here"}, {"sha": "7a5da67e02665010bb4b70d81af262439ff207e3", "filename": "tests/ui/shadow.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -5,7 +5,12 @@\n     clippy::shadow_reuse,\n     clippy::shadow_unrelated\n )]\n-#![allow(unused_parens, unused_variables, clippy::missing_docs_in_private_items)]\n+#![allow(\n+    unused_parens,\n+    unused_variables,\n+    clippy::missing_docs_in_private_items,\n+    clippy::single_match\n+)]\n \n fn id<T>(x: T) -> T {\n     x"}, {"sha": "184e781ae43dc07e4b9fdb7e6ced77d9a3bb6e27", "filename": "tests/ui/shadow.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.stderr?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -1,135 +1,135 @@\n error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:20:5\n+  --> $DIR/shadow.rs:25:5\n    |\n LL |     let x = &mut x;\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:19:13\n+  --> $DIR/shadow.rs:24:13\n    |\n LL |     let mut x = 1;\n    |             ^\n \n error: `x` is shadowed by itself in `{ x }`\n-  --> $DIR/shadow.rs:21:5\n+  --> $DIR/shadow.rs:26:5\n    |\n LL |     let x = { x };\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:20:9\n+  --> $DIR/shadow.rs:25:9\n    |\n LL |     let x = &mut x;\n    |         ^\n \n error: `x` is shadowed by itself in `(&*x)`\n-  --> $DIR/shadow.rs:22:5\n+  --> $DIR/shadow.rs:27:5\n    |\n LL |     let x = (&*x);\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:21:9\n+  --> $DIR/shadow.rs:26:9\n    |\n LL |     let x = { x };\n    |         ^\n \n error: `x` is shadowed by `{ *x + 1 }` which reuses the original value\n-  --> $DIR/shadow.rs:23:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n    |\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:23:13\n+  --> $DIR/shadow.rs:28:13\n    |\n LL |     let x = { *x + 1 };\n    |             ^^^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:22:9\n+  --> $DIR/shadow.rs:27:9\n    |\n LL |     let x = (&*x);\n    |         ^\n \n error: `x` is shadowed by `id(x)` which reuses the original value\n-  --> $DIR/shadow.rs:24:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = id(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:24:13\n+  --> $DIR/shadow.rs:29:13\n    |\n LL |     let x = id(x);\n    |             ^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:23:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n \n error: `x` is shadowed by `(1, x)` which reuses the original value\n-  --> $DIR/shadow.rs:25:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = (1, x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:25:13\n+  --> $DIR/shadow.rs:30:13\n    |\n LL |     let x = (1, x);\n    |             ^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:24:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = id(x);\n    |         ^\n \n error: `x` is shadowed by `first(x)` which reuses the original value\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = first(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:26:13\n+  --> $DIR/shadow.rs:31:13\n    |\n LL |     let x = first(x);\n    |             ^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:25:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = (1, x);\n    |         ^\n \n error: `x` is shadowed by `y`\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = y;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:28:13\n+  --> $DIR/shadow.rs:33:13\n    |\n LL |     let x = y;\n    |             ^\n note: previous binding is here\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = first(x);\n    |         ^\n \n error: `x` shadows a previous declaration\n-  --> $DIR/shadow.rs:30:5\n+  --> $DIR/shadow.rs:35:5\n    |\n LL |     let x;\n    |     ^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = y;\n    |         ^"}, {"sha": "af67f326f856017682605c69d6def1019e16259e", "filename": "tests/ui/wildcard_enum_match_arm.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fwildcard_enum_match_arm.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.fixed?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::wildcard_enum_match_arm)]\n-#![allow(unreachable_code, unused_variables)]\n+#![allow(unreachable_code, unused_variables, dead_code)]\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Color {"}, {"sha": "049596d342e8e0b57916e8019670f886f83285ff", "filename": "tests/ui/wildcard_enum_match_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fwildcard_enum_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/982c51e769c693644eec19ac9f1e339997bbe579/tests%2Fui%2Fwildcard_enum_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_enum_match_arm.rs?ref=982c51e769c693644eec19ac9f1e339997bbe579", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::wildcard_enum_match_arm)]\n-#![allow(unreachable_code, unused_variables)]\n+#![allow(unreachable_code, unused_variables, dead_code)]\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Color {"}]}