{"sha": "03161e9b12621364d44b7fb85694ddf9901ce50f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMTYxZTliMTI2MjEzNjRkNDRiN2ZiODU2OTRkZGY5OTAxY2U1MGY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-26T16:23:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-13T20:33:50Z"}, "message": "Remove some more dead code from mem categorization", "tree": {"sha": "59b744d03a2a5eb76d2ecfa4ce182f5d37bcd63a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59b744d03a2a5eb76d2ecfa4ce182f5d37bcd63a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03161e9b12621364d44b7fb85694ddf9901ce50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03161e9b12621364d44b7fb85694ddf9901ce50f", "html_url": "https://github.com/rust-lang/rust/commit/03161e9b12621364d44b7fb85694ddf9901ce50f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03161e9b12621364d44b7fb85694ddf9901ce50f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b6c4c08df7f4685daf0fa2cfe127b06216176d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b6c4c08df7f4685daf0fa2cfe127b06216176d6", "html_url": "https://github.com/rust-lang/rust/commit/4b6c4c08df7f4685daf0fa2cfe127b06216176d6"}], "stats": {"total": 98, "additions": 20, "deletions": 78}, "files": [{"sha": "c419f96e8209581973a5965ede579c3f16eac1bc", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 78, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/03161e9b12621364d44b7fb85694ddf9901ce50f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03161e9b12621364d44b7fb85694ddf9901ce50f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=03161e9b12621364d44b7fb85694ddf9901ce50f", "patch": "@@ -67,7 +67,6 @@ pub use self::ElementKind::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n-pub use self::deref_kind::*;\n \n use self::Aliasability::*;\n \n@@ -195,47 +194,6 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n-// We pun on *T to mean both actual deref of a ptr as well\n-// as accessing of components:\n-#[derive(Copy, Clone)]\n-pub enum deref_kind<'tcx> {\n-    deref_ptr(PointerKind<'tcx>),\n-    deref_interior(InteriorKind),\n-}\n-\n-type DerefKindContext = Option<InteriorOffsetKind>;\n-\n-// Categorizes a derefable type.  Note that we include vectors and strings as\n-// derefable (we model an index as the combination of a deref and then a\n-// pointer adjustment).\n-fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n-    match t.sty {\n-        ty::TyBox(_) => {\n-            Ok(deref_ptr(Unique))\n-        }\n-\n-        ty::TyRef(r, mt) => {\n-            let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Ok(deref_ptr(BorrowedPtr(kind, r)))\n-        }\n-\n-        ty::TyRawPtr(ref mt) => {\n-            Ok(deref_ptr(UnsafePtr(mt.mutbl)))\n-        }\n-\n-        ty::TyArray(..) | ty::TySlice(_) => {\n-            // no deref of indexed content without supplying InteriorOffsetKind\n-            if let Some(context) = context {\n-                Ok(deref_interior(InteriorElement(context, ElementKind::VecElement)))\n-            } else {\n-                Err(())\n-            }\n-        }\n-\n-        _ => Err(()),\n-    }\n-}\n-\n pub trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;\n@@ -472,7 +430,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                autoderefs,\n                cmt);\n         for deref in 1..autoderefs + 1 {\n-            cmt = self.cat_deref(expr, cmt, deref, None)?;\n+            cmt = self.cat_deref(expr, cmt, deref)?;\n         }\n         return Ok(cmt);\n     }\n@@ -484,7 +442,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             let base_cmt = self.cat_expr(&e_base)?;\n-            self.cat_deref(expr, base_cmt, 0, None)\n+            self.cat_deref(expr, base_cmt, 0)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n@@ -503,7 +461,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           hir::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n-            let context = InteriorOffsetKind::Index;\n             match self.infcx.node_method_ty(method_call) {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it\n@@ -525,10 +482,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     // is an rvalue. That is what we will be\n                     // dereferencing.\n                     let base_cmt = self.cat_rvalue_node(expr.id(), expr.span(), ret_ty);\n-                    self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n+                    Ok(self.cat_deref_common(expr, base_cmt, 1, elem_ty, true))\n                 }\n                 None => {\n-                    self.cat_index(expr, self.cat_expr(&base)?, context)\n+                    self.cat_index(expr, self.cat_expr(&base)?, InteriorOffsetKind::Index)\n                 }\n             }\n           }\n@@ -903,8 +860,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: usize,\n-                             deref_context: DerefKindContext)\n+                             deref_cnt: usize)\n                              -> McResult<cmt<'tcx>> {\n         let method_call = ty::MethodCall {\n             expr_id: node.id(),\n@@ -926,12 +882,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let base_cmt_ty = base_cmt.ty;\n         match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n             Some(mt) => {\n-                let ret = self.cat_deref_common(node, base_cmt, deref_cnt,\n-                                              mt.ty,\n-                                              deref_context,\n-                                                /* implicit: */ false);\n+                let ret = self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty, false);\n                 debug!(\"cat_deref ret {:?}\", ret);\n-                ret\n+                Ok(ret)\n             }\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {:?}\",\n@@ -946,40 +899,29 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                     base_cmt: cmt<'tcx>,\n                                     deref_cnt: usize,\n                                     deref_ty: Ty<'tcx>,\n-                                    deref_context: DerefKindContext,\n                                     implicit: bool)\n-                                    -> McResult<cmt<'tcx>>\n+                                    -> cmt<'tcx>\n     {\n-        let (m, cat) = match deref_kind(base_cmt.ty, deref_context)? {\n-            deref_ptr(ptr) => {\n-                let ptr = if implicit {\n-                    match ptr {\n-                        BorrowedPtr(bk, r) => Implicit(bk, r),\n-                        _ => span_bug!(node.span(),\n-                            \"Implicit deref of non-borrowed pointer\")\n-                    }\n-                } else {\n-                    ptr\n-                };\n-                // for unique ptrs, we inherit mutability from the\n-                // owning reference.\n-                (MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n-                 Categorization::Deref(base_cmt, deref_cnt, ptr))\n-            }\n-            deref_interior(interior) => {\n-                (base_cmt.mutbl.inherit(), Categorization::Interior(base_cmt, interior))\n+        let ptr = match base_cmt.ty.sty {\n+            ty::TyBox(..) => Unique,\n+            ty::TyRawPtr(ref mt) => UnsafePtr(mt.mutbl),\n+            ty::TyRef(r, mt) => {\n+                let bk = ty::BorrowKind::from_mutbl(mt.mutbl);\n+                if implicit { Implicit(bk, r) } else { BorrowedPtr(bk, r) }\n             }\n+            ref ty => bug!(\"unexpected type in cat_deref_common: {:?}\", ty)\n         };\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n-            cat: cat,\n-            mutbl: m,\n+            // For unique ptrs, we inherit mutability from the owning reference.\n+            mutbl: MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr),\n+            cat: Categorization::Deref(base_cmt, deref_cnt, ptr),\n             ty: deref_ty,\n             note: NoteNone\n         });\n         debug!(\"cat_deref_common ret {:?}\", ret);\n-        Ok(ret)\n+        ret\n     }\n \n     pub fn cat_index<N:ast_node>(&self,\n@@ -1202,7 +1144,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // box p1, &p1, &mut p1.  we can ignore the mutability of\n             // PatKind::Ref since that information is already contained\n             // in the type.\n-            let subcmt = self.cat_deref(pat, cmt, 0, None)?;\n+            let subcmt = self.cat_deref(pat, cmt, 0)?;\n             self.cat_pattern_(subcmt, &subpat, op)?;\n           }\n "}]}