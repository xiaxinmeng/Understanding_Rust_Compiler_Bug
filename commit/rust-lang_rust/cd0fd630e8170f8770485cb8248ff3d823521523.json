{"sha": "cd0fd630e8170f8770485cb8248ff3d823521523", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMGZkNjMwZTgxNzBmODc3MDQ4NWNiODI0OGZmM2Q4MjM1MjE1MjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-02T22:44:04Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-10T21:12:08Z"}, "message": "resolve: Make proc macro stubs less stubby\n\nCreate real working and registered (even if dummy) `SyntaxExtension`s for them.\nThis improves error recovery and allows to avoid all special cases for proc macro stubs (except for the error on use, of course).\n\nThe introduced dummy `SyntaxExtension`s can be used for any other inappropriately resolved macros as well.", "tree": {"sha": "7a8996509f28dada6dbe1b06c328b9aa87903294", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a8996509f28dada6dbe1b06c328b9aa87903294"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd0fd630e8170f8770485cb8248ff3d823521523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd0fd630e8170f8770485cb8248ff3d823521523", "html_url": "https://github.com/rust-lang/rust/commit/cd0fd630e8170f8770485cb8248ff3d823521523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd0fd630e8170f8770485cb8248ff3d823521523/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b392781edc145d1d1592c6d1bba4c33fbc1f51d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b392781edc145d1d1592c6d1bba4c33fbc1f51d5", "html_url": "https://github.com/rust-lang/rust/commit/b392781edc145d1d1592c6d1bba4c33fbc1f51d5"}], "stats": {"total": 213, "additions": 138, "deletions": 75}, "files": [{"sha": "6fdd0c3ff3e4de1d5d1e9bb4d0ce3b83f6e32553", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=cd0fd630e8170f8770485cb8248ff3d823521523", "patch": "@@ -46,20 +46,6 @@ use log::debug;\n \n type Res = def::Res<NodeId>;\n \n-fn proc_macro_stub(item: &Item) -> Option<(Ident, Span)> {\n-    if attr::contains_name(&item.attrs, sym::proc_macro) ||\n-       attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n-        return Some((item.ident, item.span));\n-    } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n-        if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n-            if let Some(ident) = nested_meta.ident() {\n-                return Some((ident, ident.span));\n-            }\n-        }\n-    }\n-    None\n-}\n-\n impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n@@ -470,9 +456,7 @@ impl<'a> Resolver<'a> {\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n-                if let Some((ident, span)) = proc_macro_stub(item) {\n-                    self.define(parent, ident, MacroNS, (res, vis, span, expansion));\n-                }\n+                self.define_macro(item, expansion, &mut LegacyScope::Empty);\n             }\n \n             // These items live in the type namespace."}, {"sha": "b6c26b1a721e1e5b5d845ac1ea25a55371cb98d6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cd0fd630e8170f8770485cb8248ff3d823521523", "patch": "@@ -40,7 +40,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n-use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -1663,10 +1663,13 @@ pub struct Resolver<'a> {\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n+    dummy_ext_bang: Lrc<SyntaxExtension>,\n+    dummy_ext_derive: Lrc<SyntaxExtension>,\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n+    proc_macro_stubs: NodeSet,\n \n     /// Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n@@ -1925,9 +1928,8 @@ impl<'a> Resolver<'a> {\n         macro_defs.insert(Mark::root(), root_def_id);\n \n         let features = session.features_untracked();\n-        let non_macro_attr = |mark_used| Lrc::new(SyntaxExtension::default(\n-            SyntaxExtensionKind::NonMacroAttr { mark_used }, session.edition()\n-        ));\n+        let non_macro_attr =\n+            |mark_used| Lrc::new(SyntaxExtension::non_macro_attr(mark_used, session.edition()));\n \n         Resolver {\n             session,\n@@ -2002,6 +2004,8 @@ impl<'a> Resolver<'a> {\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n+            dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n+            dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocations,\n             macro_defs,\n@@ -2010,6 +2014,7 @@ impl<'a> Resolver<'a> {\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n+            proc_macro_stubs: Default::default(),\n             current_type_ascription: Vec::new(),\n             injected_crate: None,\n             active_features:\n@@ -2027,6 +2032,14 @@ impl<'a> Resolver<'a> {\n         self.non_macro_attrs[mark_used as usize].clone()\n     }\n \n+    fn dummy_ext(&self, macro_kind: MacroKind) -> Lrc<SyntaxExtension> {\n+        match macro_kind {\n+            MacroKind::Bang => self.dummy_ext_bang.clone(),\n+            MacroKind::Derive => self.dummy_ext_derive.clone(),\n+            MacroKind::Attr => self.non_macro_attr(true),\n+        }\n+    }\n+\n     /// Runs the function on each namespace.\n     fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n         f(self, TypeNS);"}, {"sha": "20eb97c15ba736961fe46d20075fd64e240da360", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=cd0fd630e8170f8770485cb8248ff3d823521523", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::DefCollector;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n@@ -127,6 +127,21 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n     }\n }\n \n+fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n+    if attr::contains_name(&item.attrs, sym::proc_macro) {\n+        return Some((MacroKind::Bang, item.ident, item.span));\n+    } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        return Some((MacroKind::Attr, item.ident, item.span));\n+    } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n+        if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n+            if let Some(ident) = nested_meta.ident() {\n+                return Some((MacroKind::Derive, ident, ident.span));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -216,10 +231,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n             Ok((res, ext)) => (res, ext),\n-            // Replace unresolved attributes with used inert attributes for better recovery.\n-            Err(Determinacy::Determined) if kind == MacroKind::Attr =>\n-                (Res::Err, self.non_macro_attr(true)),\n-            Err(determinacy) => return Err(determinacy),\n+            // Return dummy syntax extensions for unresolved macros for better recovery.\n+            Err(Determinacy::Determined) => (Res::Err, self.dummy_ext(kind)),\n+            Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n         };\n \n         let span = invoc.span();\n@@ -305,13 +319,14 @@ impl<'a> Resolver<'a> {\n             Res::Def(DefKind::Macro(_), def_id) => {\n                 if let Some(node_id) = self.definitions.as_local_node_id(def_id) {\n                     self.unused_macros.remove(&node_id);\n+                    if self.proc_macro_stubs.contains(&node_id) {\n+                        self.session.span_err(\n+                            path.span,\n+                            \"can't use a procedural macro from the same crate that defines it\",\n+                        );\n+                    }\n                 }\n             }\n-            Res::Def(DefKind::Fn, _) => {\n-                let msg = \"can't use a procedural macro from the same crate that defines it\";\n-                self.session.span_err(path.span, msg);\n-                return Err(Determinacy::Determined);\n-            }\n             Res::NonMacroAttr(attr_kind) => {\n                 if kind == MacroKind::Attr {\n                     if attr_kind == NonMacroAttrKind::Custom {\n@@ -1100,19 +1115,32 @@ impl<'a> Resolver<'a> {\n                         item: &ast::Item,\n                         expansion: Mark,\n                         current_legacy_scope: &mut LegacyScope<'a>) {\n-        self.local_macro_def_scopes.insert(item.id, self.current_module);\n-        let ident = item.ident;\n+        let (ext, ident, span, is_legacy) = match &item.node {\n+            ItemKind::MacroDef(def) => {\n+                let ext = Lrc::new(macro_rules::compile(\n+                    &self.session.parse_sess,\n+                    &self.session.features_untracked(),\n+                    item,\n+                    self.session.edition(),\n+                ));\n+                (ext, item.ident, item.span, def.legacy)\n+            }\n+            ItemKind::Fn(..) => match proc_macro_stub(item) {\n+                Some((macro_kind, ident, span)) => {\n+                    self.proc_macro_stubs.insert(item.id);\n+                    (self.dummy_ext(macro_kind), ident, span, false)\n+                }\n+                None => return,\n+            }\n+            _ => unreachable!(),\n+        };\n \n         let def_id = self.definitions.local_def_id(item.id);\n-        let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n-                                               &self.session.features_untracked(),\n-                                               item, self.session.edition()));\n-        let macro_kind = ext.macro_kind();\n-        let res = Res::Def(DefKind::Macro(macro_kind), def_id);\n+        let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id);\n         self.macro_map.insert(def_id, ext);\n+        self.local_macro_def_scopes.insert(item.id, self.current_module);\n \n-        let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n-        if def.legacy {\n+        if is_legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n@@ -1121,7 +1149,7 @@ impl<'a> Resolver<'a> {\n             } else {\n                 ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n             };\n-            let binding = (res, vis, item.span, expansion).to_name_binding(self.arenas);\n+            let binding = (res, vis, span, expansion).to_name_binding(self.arenas);\n             self.set_binding_parent_module(binding, self.current_module);\n             let legacy_binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n                 parent_legacy_scope: *current_legacy_scope, binding, ident\n@@ -1131,18 +1159,18 @@ impl<'a> Resolver<'a> {\n             if is_macro_export {\n                 let module = self.graph_root;\n                 self.define(module, ident, MacroNS,\n-                            (res, vis, item.span, expansion, IsMacroExport));\n+                            (res, vis, span, expansion, IsMacroExport));\n             } else {\n                 self.check_reserved_macro_name(ident, res);\n-                self.unused_macros.insert(item.id, item.span);\n+                self.unused_macros.insert(item.id, span);\n             }\n         } else {\n             let module = self.current_module;\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n-                self.unused_macros.insert(item.id, item.span);\n+                self.unused_macros.insert(item.id, span);\n             }\n-            self.define(module, ident, MacroNS, (res, vis, item.span, expansion));\n+            self.define(module, ident, MacroNS, (res, vis, span, expansion));\n         }\n     }\n }"}, {"sha": "82386b78f1dc2a5a62d3240cbcea53e178048b8f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cd0fd630e8170f8770485cb8248ff3d823521523", "patch": "@@ -10,7 +10,7 @@ use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n-use crate::tokenstream::{self, TokenStream};\n+use crate::tokenstream::{self, TokenStream, TokenTree};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n@@ -640,6 +640,26 @@ impl SyntaxExtension {\n         }\n     }\n \n+    pub fn dummy_bang(edition: Edition) -> SyntaxExtension {\n+        fn expander<'cx>(_: &'cx mut ExtCtxt<'_>, span: Span, _: &[TokenTree])\n+                         -> Box<dyn MacResult + 'cx> {\n+            DummyResult::any(span)\n+        }\n+        SyntaxExtension::default(SyntaxExtensionKind::LegacyBang(Box::new(expander)), edition)\n+    }\n+\n+    pub fn dummy_derive(edition: Edition) -> SyntaxExtension {\n+        fn expander(_: &mut ExtCtxt<'_>, _: Span, _: &ast::MetaItem, _: Annotatable)\n+                    -> Vec<Annotatable> {\n+            Vec::new()\n+        }\n+        SyntaxExtension::default(SyntaxExtensionKind::Derive(Box::new(expander)), edition)\n+    }\n+\n+    pub fn non_macro_attr(mark_used: bool, edition: Edition) -> SyntaxExtension {\n+        SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n+    }\n+\n     pub fn expn_info(&self, call_site: Span, descr: Symbol) -> ExpnInfo {\n         ExpnInfo {\n             call_site,"}, {"sha": "c7b092830a243d15f0ecf76742276bdc62e47f62", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.rs?ref=cd0fd630e8170f8770485cb8248ff3d823521523", "patch": "@@ -25,22 +25,24 @@ fn check_bang1() {\n     my_macro!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n }\n fn check_bang2() {\n-    my_macro_attr!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n+    my_macro_attr!(); //~ ERROR cannot find macro `my_macro_attr!` in this scope\n }\n fn check_bang3() {\n-    MyTrait!(); //~ ERROR can't use a procedural macro from the same crate that defines it\n+    MyTrait!(); //~ ERROR cannot find macro `MyTrait!` in this scope\n }\n \n-#[my_macro] //~ ERROR can't use a procedural macro from the same crate that defines it\n+#[my_macro] //~ ERROR attribute `my_macro` is currently unknown\n fn check_attr1() {}\n #[my_macro_attr] //~ ERROR can't use a procedural macro from the same crate that defines it\n fn check_attr2() {}\n #[MyTrait] //~ ERROR can't use a procedural macro from the same crate that defines it\n+           //~| ERROR `MyTrait` is a derive macro\n fn check_attr3() {}\n \n-#[derive(my_macro)] //~ ERROR can't use a procedural macro from the same crate that defines it\n+#[derive(my_macro)] //~ ERROR cannot find derive macro `my_macro` in this scope\n struct CheckDerive1;\n #[derive(my_macro_attr)] //~ ERROR can't use a procedural macro from the same crate that defines it\n+                         //~| ERROR macro `my_macro_attr` may not be used for derive attributes\n struct CheckDerive2;\n #[derive(MyTrait)] //~ ERROR can't use a procedural macro from the same crate that defines it\n struct CheckDerive3;"}, {"sha": "83c77513ec3bfa20208e47c9ba6c0ff6f3a55e27", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd0fd630e8170f8770485cb8248ff3d823521523/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=cd0fd630e8170f8770485cb8248ff3d823521523", "patch": "@@ -4,24 +4,6 @@ error: can't use a procedural macro from the same crate that defines it\n LL |     my_macro!();\n    |     ^^^^^^^^\n \n-error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:28:5\n-   |\n-LL |     my_macro_attr!();\n-   |     ^^^^^^^^^^^^^\n-\n-error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:31:5\n-   |\n-LL |     MyTrait!();\n-   |     ^^^^^^^\n-\n-error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:34:3\n-   |\n-LL | #[my_macro]\n-   |   ^^^^^^^^\n-\n error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:36:3\n    |\n@@ -34,23 +16,57 @@ error: can't use a procedural macro from the same crate that defines it\n LL | #[MyTrait]\n    |   ^^^^^^^\n \n-error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:41:10\n+error: `MyTrait` is a derive macro\n+  --> $DIR/macro-namespace-reserved-2.rs:38:1\n    |\n-LL | #[derive(my_macro)]\n-   |          ^^^^^^^^\n+LL | #[MyTrait]\n+   | ^^^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:43:10\n+  --> $DIR/macro-namespace-reserved-2.rs:44:10\n+   |\n+LL | #[derive(my_macro_attr)]\n+   |          ^^^^^^^^^^^^^\n+\n+error: macro `my_macro_attr` may not be used for derive attributes\n+  --> $DIR/macro-namespace-reserved-2.rs:44:10\n    |\n LL | #[derive(my_macro_attr)]\n    |          ^^^^^^^^^^^^^\n \n error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:45:10\n+  --> $DIR/macro-namespace-reserved-2.rs:47:10\n    |\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error[E0658]: The attribute `my_macro` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/macro-namespace-reserved-2.rs:34:3\n+   |\n+LL | #[my_macro]\n+   |   ^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: cannot find derive macro `my_macro` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:42:10\n+   |\n+LL | #[derive(my_macro)]\n+   |          ^^^^^^^^\n+\n+error: cannot find macro `my_macro_attr!` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:28:5\n+   |\n+LL |     my_macro_attr!();\n+   |     ^^^^^^^^^^^^^\n+\n+error: cannot find macro `MyTrait!` in this scope\n+  --> $DIR/macro-namespace-reserved-2.rs:31:5\n+   |\n+LL |     MyTrait!();\n+   |     ^^^^^^^\n+\n+error: aborting due to 11 previous errors\n \n+For more information about this error, try `rustc --explain E0658`."}]}