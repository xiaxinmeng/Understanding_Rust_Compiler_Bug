{"sha": "53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "node_id": "C_kwDOAAsO6NoAKDUzYWIzYjJlNmU4ZGVkM2U0Y2Y4NDU2ZWE1YTY2ZTcwZDI0YmNiNjk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-03T15:10:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-03T15:10:51Z"}, "message": "Rollup merge of #97415 - cjgillot:is-late-bound-solo, r=estebank\n\nCompute `is_late_bound_map` query separately from lifetime resolution\n\nThis query is actually very simple, and is only useful for functions and method.  It can be computed directly by fetching the HIR, with no need to embed it within the lifetime resolution visitor.\n\nBased on https://github.com/rust-lang/rust/pull/96296", "tree": {"sha": "2dfb14df7efb697c5aca2397d41b447986c4dd63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dfb14df7efb697c5aca2397d41b447986c4dd63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJimiR7CRBK7hj4Ov3rIwAA6KoIALNQV0p8CuDs8xCx2Y9GOdDD\nBgkoV2kcte5m+kPcy4XzOktAe02WJ3cVOXXAWJdiPWoIHNyj5jnBIkuZnY2EWX0o\nmvRH0ZWn2E6p/AhC5LgxtHLk47Uh86j3nIy0HpkTNM+66pEXciQSGvCY4zLGK474\n10ZBSB+K0wU9HOKa79vhcZ4Sk3Qhw41ZKKP7ala80Z4gmWiX5iWNpMhWFZZApBjP\n7GxPuOATrvIXW2pt349BDWAN9aEFblgXJ0kiESR7xNyocFYB1LLlkZYnQd9lW9s3\neNncHrwObVN2lNc1MgQN5QTeDsSX9ctqK1E56J147WGzCG2BOTiSxyAWEJRvK6o=\n=/HUi\n-----END PGP SIGNATURE-----\n", "payload": "tree 2dfb14df7efb697c5aca2397d41b447986c4dd63\nparent 72f7e3144a386c820c188350092d2d93a74889b8\nparent ba40fe99c3624719e8bf7f324f02ecb0d8cb7849\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1654269051 +0200\ncommitter GitHub <noreply@github.com> 1654269051 +0200\n\nRollup merge of #97415 - cjgillot:is-late-bound-solo, r=estebank\n\nCompute `is_late_bound_map` query separately from lifetime resolution\n\nThis query is actually very simple, and is only useful for functions and method.  It can be computed directly by fetching the HIR, with no need to embed it within the lifetime resolution visitor.\n\nBased on https://github.com/rust-lang/rust/pull/96296\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "html_url": "https://github.com/rust-lang/rust/commit/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f7e3144a386c820c188350092d2d93a74889b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f7e3144a386c820c188350092d2d93a74889b8", "html_url": "https://github.com/rust-lang/rust/commit/72f7e3144a386c820c188350092d2d93a74889b8"}, {"sha": "ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849", "html_url": "https://github.com/rust-lang/rust/commit/ba40fe99c3624719e8bf7f324f02ecb0d8cb7849"}], "stats": {"total": 471, "additions": 205, "deletions": 266}, "files": [{"sha": "d1ea76b392223c9b76bf53c918b9c261e11d602d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -672,9 +672,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { .. } => {\n                 (hir::ParamName::Plain(ident), hir::LifetimeParamKind::Explicit)\n             }\n-            LifetimeRes::Fresh { param, .. } => {\n-                (hir::ParamName::Fresh(param), hir::LifetimeParamKind::Elided)\n-            }\n+            LifetimeRes::Fresh { .. } => (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided),\n             LifetimeRes::Static | LifetimeRes::Error => return None,\n             res => panic!(\n                 \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n@@ -1576,10 +1574,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     (hir::ParamName::Plain(ident), LifetimeRes::Param { param, binder: fn_node_id })\n                 }\n                 // Input lifetime like `'1`:\n-                LifetimeRes::Fresh { param, .. } => (\n-                    hir::ParamName::Fresh(outer_def_id),\n-                    LifetimeRes::Fresh { param, binder: fn_node_id },\n-                ),\n+                LifetimeRes::Fresh { param, .. } => {\n+                    (hir::ParamName::Fresh, LifetimeRes::Fresh { param, binder: fn_node_id })\n+                }\n                 LifetimeRes::Static | LifetimeRes::Error => continue,\n                 res => {\n                     panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span)\n@@ -1749,18 +1746,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::Lifetime {\n         debug!(?self.captured_lifetimes);\n         let name = match res {\n-            LifetimeRes::Param { param, binder } => {\n+            LifetimeRes::Param { mut param, binder } => {\n                 debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n                 {\n                     match captures.entry(param) {\n-                        Entry::Occupied(_) => {}\n+                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n                         Entry::Vacant(v) => {\n                             let p_id = self.resolver.next_node_id();\n-                            self.resolver.create_def(\n+                            let p_def_id = self.resolver.create_def(\n                                 *parent_def_id,\n                                 p_id,\n                                 DefPathData::LifetimeNs(p_name.ident().name),\n@@ -1769,10 +1766,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             );\n \n                             v.insert((span, p_id, p_name, res));\n+                            param = p_def_id;\n                         }\n                     }\n                 }\n-                hir::LifetimeName::Param(p_name)\n+                hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { mut param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n@@ -1792,21 +1790,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span.with_parent(None),\n                             );\n \n-                            let p_name = ParamName::Fresh(param);\n-                            v.insert((span, p_id, p_name, res));\n+                            v.insert((span, p_id, ParamName::Fresh, res));\n                             param = p_def_id;\n                         }\n                     }\n                 }\n-                let p_name = ParamName::Fresh(param);\n-                hir::LifetimeName::Param(p_name)\n+                hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Anonymous { binder, elided } => {\n-                let l_name = if elided {\n-                    hir::LifetimeName::Implicit\n-                } else {\n-                    hir::LifetimeName::Underscore\n-                };\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n@@ -1819,18 +1810,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         ExpnId::root(),\n                         span.with_parent(None),\n                     );\n-                    let p_name = ParamName::Fresh(p_def_id);\n-                    captures.insert(p_def_id, (span, p_id, p_name, res));\n-                    hir::LifetimeName::Param(p_name)\n+                    captures.insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n+                    hir::LifetimeName::Param(p_def_id, ParamName::Fresh)\n+                } else if elided {\n+                    hir::LifetimeName::Implicit\n                 } else {\n-                    l_name\n+                    hir::LifetimeName::Underscore\n                 }\n             }\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n         };\n         debug!(?self.captured_lifetimes);\n+        debug!(?name);\n         hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n     }\n "}, {"sha": "fcb6ae438fed9768726737a68858817e8593d9de", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -567,14 +567,14 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let lifetime =\n             self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n-            hir::LifetimeName::Param(hir::ParamName::Plain(_) | hir::ParamName::Error)\n+            hir::LifetimeName::Param(_, hir::ParamName::Plain(_) | hir::ParamName::Error)\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static => {\n                 let lifetime_span = lifetime.span;\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::Param(hir::ParamName::Fresh(_))\n+            hir::LifetimeName::Param(_, hir::ParamName::Fresh)\n             | hir::LifetimeName::ImplicitObjectLifetimeDefault\n             | hir::LifetimeName::Implicit\n             | hir::LifetimeName::Underscore => {"}, {"sha": "c2c093f9f2fc74e685b1589063b809c772f09702", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -830,11 +830,11 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some((owner, late_bounds)) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n+    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n         for &region_def_id in late_bounds.iter() {\n             let name = tcx.item_name(region_def_id.to_def_id());\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: owner.to_def_id(),\n+                scope: fn_def_id,\n                 bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);"}, {"sha": "b98d4341118628544ae65a239477dba0fa74f66a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n use std::fmt;\n \n-#[derive(Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -60,7 +60,7 @@ pub enum ParamName {\n     /// ```\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n-    Fresh(LocalDefId),\n+    Fresh,\n \n     /// Indicates an illegal name was given and an error has been\n     /// reported (so we should squelch other derived errors). Occurs\n@@ -72,9 +72,7 @@ impl ParamName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             ParamName::Plain(ident) => ident,\n-            ParamName::Fresh(_) | ParamName::Error => {\n-                Ident::with_dummy_span(kw::UnderscoreLifetime)\n-            }\n+            ParamName::Fresh | ParamName::Error => Ident::with_dummy_span(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -90,7 +88,7 @@ impl ParamName {\n #[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n-    Param(ParamName),\n+    Param(LocalDefId, ParamName),\n \n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n@@ -127,7 +125,7 @@ impl LifetimeName {\n             | LifetimeName::Error => Ident::empty(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n-            LifetimeName::Param(param_name) => param_name.ident(),\n+            LifetimeName::Param(_, param_name) => param_name.ident(),\n         }\n     }\n \n@@ -136,9 +134,9 @@ impl LifetimeName {\n             LifetimeName::ImplicitObjectLifetimeDefault\n             | LifetimeName::Implicit\n             | LifetimeName::Underscore\n-            | LifetimeName::Param(ParamName::Fresh(_))\n+            | LifetimeName::Param(_, ParamName::Fresh)\n             | LifetimeName::Error => true,\n-            LifetimeName::Static | LifetimeName::Param(_) => false,\n+            LifetimeName::Static | LifetimeName::Param(..) => false,\n         }\n     }\n \n@@ -148,12 +146,12 @@ impl LifetimeName {\n             | LifetimeName::Implicit\n             | LifetimeName::Underscore => true,\n \n-            // It might seem surprising that `Fresh(_)` counts as\n+            // It might seem surprising that `Fresh` counts as\n             // *not* elided -- but this is because, as far as the code\n-            // in the compiler is concerned -- `Fresh(_)` variants act\n+            // in the compiler is concerned -- `Fresh` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            LifetimeName::Error | LifetimeName::Param(_) | LifetimeName::Static => false,\n+            LifetimeName::Error | LifetimeName::Param(..) | LifetimeName::Static => false,\n         }\n     }\n \n@@ -163,8 +161,8 @@ impl LifetimeName {\n \n     pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Param(param_name) => {\n-                LifetimeName::Param(param_name.normalize_to_macros_2_0())\n+            LifetimeName::Param(def_id, param_name) => {\n+                LifetimeName::Param(def_id, param_name.normalize_to_macros_2_0())\n             }\n             lifetime_name => lifetime_name,\n         }\n@@ -177,12 +175,6 @@ impl fmt::Display for Lifetime {\n     }\n }\n \n-impl fmt::Debug for Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"lifetime({}: {})\", self.hir_id, self.name.ident())\n-    }\n-}\n-\n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n         self.name.is_elided()\n@@ -628,6 +620,16 @@ impl<'hir> Generics<'hir> {\n         })\n     }\n \n+    pub fn outlives_for_param(\n+        &self,\n+        param_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &WhereRegionPredicate<'_>> {\n+        self.predicates.iter().filter_map(move |pred| match pred {\n+            WherePredicate::RegionPredicate(rp) if rp.is_param_bound(param_def_id) => Some(rp),\n+            _ => None,\n+        })\n+    }\n+\n     pub fn bounds_span_for_suggestions(&self, param_def_id: LocalDefId) -> Option<Span> {\n         self.bounds_for_param(param_def_id).flat_map(|bp| bp.bounds.iter().rev()).find_map(\n             |bound| {\n@@ -769,6 +771,16 @@ pub struct WhereRegionPredicate<'hir> {\n     pub bounds: GenericBounds<'hir>,\n }\n \n+impl<'hir> WhereRegionPredicate<'hir> {\n+    /// Returns `true` if `param_def_id` matches the `lifetime` of this predicate.\n+    pub fn is_param_bound(&self, param_def_id: LocalDefId) -> bool {\n+        match self.lifetime.name {\n+            LifetimeName::Param(id, _) => id == param_def_id,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {"}, {"sha": "bd8587f1106e9ad708fbf007bbbec54e73d64e1c", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -510,11 +510,11 @@ pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.hir_id);\n     match lifetime.name {\n-        LifetimeName::Param(ParamName::Plain(ident)) => {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n             visitor.visit_ident(ident);\n         }\n-        LifetimeName::Param(ParamName::Fresh(_))\n-        | LifetimeName::Param(ParamName::Error)\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n         | LifetimeName::Implicit\n@@ -879,7 +879,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n     visitor.visit_id(param.hir_id);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n-        ParamName::Error | ParamName::Fresh(_) => {}\n+        ParamName::Error | ParamName::Fresh => {}\n     }\n     match param.kind {\n         GenericParamKind::Lifetime { .. } => {}"}, {"sha": "2c40eab8764afd6d8f326459f41605bcccae7625", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -364,7 +364,11 @@ impl<'hir> Map<'hir> {\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n             OwnerNode::TraitItem(trait_item) => Some(&trait_item.generics),\n-            OwnerNode::Item(Item {\n+            OwnerNode::ForeignItem(ForeignItem {\n+                kind: ForeignItemKind::Fn(_, _, generics),\n+                ..\n+            })\n+            | OwnerNode::Item(Item {\n                 kind:\n                     ItemKind::Fn(_, generics, _)\n                     | ItemKind::TyAlias(_, generics)"}, {"sha": "cdc0d07680193ef54818efa149a235e4d4b8b0db", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::ItemLocalId;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::Symbol;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n@@ -22,12 +21,12 @@ pub enum Region {\n /// so that we can e.g. suggest elided-lifetimes-in-paths of the form <'_, '_> e.g.\n #[derive(Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum LifetimeScopeForPath {\n-    // Contains all lifetime names that are in scope and could possibly be used in generics\n-    // arguments of path.\n-    NonElided(Vec<Symbol>),\n+    /// Contains all lifetime names that are in scope and could possibly be used in generics\n+    /// arguments of path.\n+    NonElided(Vec<LocalDefId>),\n \n-    // Information that allows us to suggest args of the form `<'_>` in case\n-    // no generic arguments were provided for a path.\n+    /// Information that allows us to suggest args of the form `<'_>` in case\n+    /// no generic arguments were provided for a path.\n     Elided,\n }\n "}, {"sha": "899d6c7e490a60416802322c3c208eabbe8cae9c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -1584,7 +1584,7 @@ rustc_queries! {\n         Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n         desc { \"looking up a named region\" }\n     }\n-    query is_late_bound_map(_: LocalDefId) -> Option<(LocalDefId, &'tcx FxHashSet<LocalDefId>)> {\n+    query is_late_bound_map(_: LocalDefId) -> Option<&'tcx FxHashSet<LocalDefId>> {\n         desc { \"testing if a region is late bound\" }\n     }\n     /// For a given item (like a struct), gets the default lifetimes to be used"}, {"sha": "72e2beb372d3ca117e15ca8a56568679286fef34", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -2803,6 +2803,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n+    pub fn is_late_bound(self, id: HirId) -> bool {\n+        self.is_late_bound_map(id.owner).map_or(false, |set| {\n+            let def_id = self.hir().local_def_id(id);\n+            set.contains(&def_id)\n+        })\n+    }\n+\n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n         self.mk_bound_variable_kinds(\n             self.late_bound_vars_map(id.owner)"}, {"sha": "cb39eb5416ba27dbc2822d8529ffb2d32ef6b870", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -13,15 +13,15 @@ use rustc_ast::{\n };\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust::path_segment_to_string;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -2082,7 +2082,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     pub(crate) fn report_elision_failure(\n-        &mut self,\n+        &self,\n         diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n     ) -> bool {\n@@ -2187,10 +2187,27 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         mut spans_with_counts: Vec<(Span, usize)>,\n-        lifetime_names: &FxHashSet<Symbol>,\n-        lifetime_spans: Vec<Span>,\n-        params: &[ElisionFailureInfo],\n+        in_scope_lifetimes: FxIndexSet<LocalDefId>,\n+        params: Option<&[ElisionFailureInfo]>,\n     ) {\n+        let (mut lifetime_names, lifetime_spans): (FxHashSet<_>, Vec<_>) = in_scope_lifetimes\n+            .iter()\n+            .filter_map(|def_id| {\n+                let name = self.tcx.item_name(def_id.to_def_id());\n+                let span = self.tcx.def_ident_span(def_id.to_def_id())?;\n+                Some((name, span))\n+            })\n+            .filter(|&(n, _)| n != kw::UnderscoreLifetime)\n+            .unzip();\n+\n+        if let Some(params) = params {\n+            // If there's no lifetime available, suggest `'static`.\n+            if self.report_elision_failure(err, params) && lifetime_names.is_empty() {\n+                lifetime_names.insert(kw::StaticLifetime);\n+            }\n+        }\n+        let params = params.unwrap_or(&[]);\n+\n         let snippets: Vec<Option<String>> = spans_with_counts\n             .iter()\n             .map(|(span, _)| self.tcx.sess.source_map().span_to_snippet(*span).ok())"}, {"sha": "11f80b314d7702171607eed088358b860c830bce", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 85, "deletions": 148, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -8,19 +8,19 @@\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName};\n-use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet};\n+use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n+use rustc_hir::{GenericParamKind, HirIdMap};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n+use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -33,9 +33,9 @@ use std::mem::take;\n use tracing::{debug, span, Level};\n \n trait RegionExt {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n-    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n@@ -51,22 +51,22 @@ trait RegionExt {\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id()))\n+        (def_id, Region::EarlyBound(i, def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         debug!(\n             \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, def_id,\n         );\n-        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, idx, def_id.to_def_id()))\n+        (def_id, Region::LateBound(depth, idx, def_id.to_def_id()))\n     }\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region {\n@@ -134,11 +134,6 @@ struct NamedRegionMap {\n     // `Region` describing how that region is bound\n     defs: HirIdMap<Region>,\n \n-    // the set of lifetime def ids that are late-bound; a region can\n-    // be late-bound if (a) it does NOT appear in a where-clause and\n-    // (b) it DOES appear in the arguments.\n-    late_bound: HirIdSet,\n-\n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n     // - function pointers\n@@ -178,7 +173,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<hir::ParamName, Region>,\n+        lifetimes: FxIndexMap<LocalDefId, Region>,\n \n         /// if we extend this scope with another scope, what is the next index\n         /// we should use for an early-bound region?\n@@ -402,15 +397,15 @@ fn resolve_lifetimes_trait_definition(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n ) -> ResolveLifetimes {\n-    convert_named_region_map(tcx, do_resolve(tcx, local_def_id, true, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, true, false))\n }\n \n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(tcx, do_resolve(tcx, local_def_id, false, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, false, false))\n }\n \n fn do_resolve(\n@@ -422,7 +417,6 @@ fn do_resolve(\n     let item = tcx.hir().expect_item(local_def_id);\n     let mut named_region_map = NamedRegionMap {\n         defs: Default::default(),\n-        late_bound: Default::default(),\n         late_bound_vars: Default::default(),\n         scope_for_path: with_scope_for_path.then(|| Default::default()),\n     };\n@@ -439,18 +433,13 @@ fn do_resolve(\n     named_region_map\n }\n \n-fn convert_named_region_map(tcx: TyCtxt<'_>, named_region_map: NamedRegionMap) -> ResolveLifetimes {\n+fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for hir_id in named_region_map.late_bound {\n-        let map = rl.late_bound.entry(hir_id.owner).or_default();\n-        let def_id = tcx.hir().local_def_id(hir_id);\n-        map.insert(def_id);\n-    }\n     for (hir_id, v) in named_region_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n@@ -506,28 +495,6 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     item\n }\n \n-fn is_late_bound_map<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-) -> Option<(LocalDefId, &'tcx FxHashSet<LocalDefId>)> {\n-    match tcx.def_kind(def_id) {\n-        DefKind::AnonConst | DefKind::InlineConst => {\n-            let mut def_id = tcx.local_parent(def_id);\n-            // We search for the next outer anon const or fn here\n-            // while skipping closures.\n-            //\n-            // Note that for `AnonConst` we still just recurse until we\n-            // find a function body, but who cares :shrug:\n-            while tcx.is_closure(def_id.to_def_id()) {\n-                def_id = tcx.local_parent(def_id);\n-            }\n-\n-            tcx.is_late_bound_map(def_id)\n-        }\n-        _ => resolve_lifetimes_for(tcx, def_id).late_bound.get(&def_id).map(|lt| (def_id, lt)),\n-    }\n-}\n-\n /// In traits, there is an implicit `Self` type parameter which comes before the generics.\n /// We have to account for this when computing the index of the other generic parameters.\n /// This function returns whether there is such an implicit parameter defined on the given item.\n@@ -554,10 +521,7 @@ fn get_lifetime_scopes_for_path(mut scope: &Scope<'_>) -> LifetimeScopeForPath {\n     loop {\n         match scope {\n             Scope::Binder { lifetimes, s, .. } => {\n-                available_lifetimes.extend(lifetimes.keys().filter_map(|p| match p {\n-                    hir::ParamName::Plain(ident) => Some(ident.name),\n-                    _ => None,\n-                }));\n+                available_lifetimes.extend(lifetimes.keys());\n                 scope = s;\n             }\n             Scope::Body { s, .. } => {\n@@ -690,9 +654,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             _ => {}\n         }\n         match item.kind {\n-            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n+            hir::ItemKind::Fn(_, ref generics, _) => {\n                 self.missing_named_lifetime_spots.push(generics.into());\n-                self.visit_early_late(None, item.hir_id(), &sig.decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n@@ -734,13 +698,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                     self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n                                 });\n                             }\n-                            for (&owner, late_bound) in resolved_lifetimes.late_bound.iter() {\n-                                late_bound.iter().for_each(|&id| {\n-                                    let hir_id = self.tcx.local_def_id_to_hir_id(id);\n-                                    debug_assert_eq!(owner, hir_id.owner);\n-                                    self.map.late_bound.insert(hir_id);\n-                                });\n-                            }\n                             for (&owner, late_bound_vars) in\n                                 resolved_lifetimes.late_bound_vars.iter()\n                             {\n@@ -810,8 +767,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None, item.hir_id(), decl, generics, |this| {\n+            hir::ForeignItemKind::Fn(_, _, ref generics) => {\n+                self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -841,7 +798,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                let (lifetimes, binders): (FxIndexMap<hir::ParamName, Region>, Vec<_>) = c\n+                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n@@ -898,7 +855,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // cc #48468\n                         self.resolve_elided_lifetimes(&[lifetime])\n                     }\n-                    LifetimeName::Param(_) | LifetimeName::Static => {\n+                    LifetimeName::Param(..) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n@@ -1016,17 +973,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             if let hir::ParamName::Plain(Ident {\n                                 name: kw::UnderscoreLifetime,\n                                 ..\n-                            }) = name\n+                            }) = param.name\n                             {\n                                 // Pick the elided lifetime \"definition\" if one exists\n                                 // and use it to make an elision scope.\n                                 elision = Some(reg);\n                             } else {\n-                                lifetimes.insert(name, reg);\n+                                lifetimes.insert(def_id, reg);\n                             }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1088,13 +1045,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n-            Fn(ref sig, _) => {\n+            Fn(_, _) => {\n                 self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n                     trait_item.hir_id(),\n-                    &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n@@ -1156,13 +1112,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n-            Fn(ref sig, _) => {\n+            Fn(..) => {\n                 self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n                     impl_item.hir_id(),\n-                    &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n                 );\n@@ -1174,7 +1129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes: FxIndexMap<hir::ParamName, Region> = generics\n+                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n@@ -1218,15 +1173,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        if lifetime_ref.is_elided() {\n-            self.resolve_elided_lifetimes(&[lifetime_ref]);\n-            return;\n-        }\n-        if lifetime_ref.is_static() {\n-            self.insert_lifetime(lifetime_ref, Region::Static);\n-            return;\n+        match lifetime_ref.name {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit\n+            | hir::LifetimeName::Underscore => self.resolve_elided_lifetimes(&[lifetime_ref]),\n+            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Param(param_def_id, _) => {\n+                self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n+            }\n+            // If we've already reported an error, just ignore `lifetime_ref`.\n+            hir::LifetimeName::Error => {}\n         }\n-        self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n     fn visit_assoc_type_binding(&mut self, type_binding: &'tcx hir::TypeBinding<'_>) {\n@@ -1311,7 +1268,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         ref bound_generic_params,\n                         ..\n                     }) => {\n-                        let (lifetimes, binders): (FxIndexMap<hir::ParamName, Region>, Vec<_>) =\n+                        let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n                             bound_generic_params\n                                 .iter()\n                                 .filter(|param| {\n@@ -1433,7 +1390,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<hir::ParamName, Region> = FxIndexMap::default();\n+        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n         let binders_iter = trait_ref\n             .bound_generic_params\n             .iter()\n@@ -1580,14 +1537,17 @@ fn object_lifetime_defaults_for_item<'tcx>(\n                             .iter()\n                             .filter_map(|param| match param.kind {\n                                 GenericParamKind::Lifetime { .. } => {\n-                                    Some((param.hir_id, hir::LifetimeName::Param(param.name)))\n+                                    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+                                    Some((\n+                                        param_def_id,\n+                                        hir::LifetimeName::Param(param_def_id, param.name),\n+                                    ))\n                                 }\n                                 _ => None,\n                             })\n                             .enumerate()\n                             .find(|&(_, (_, lt_name))| lt_name == name)\n-                            .map_or(Set1::Many, |(i, (id, _))| {\n-                                let def_id = tcx.hir().local_def_id(id);\n+                            .map_or(Set1::Many, |(i, (def_id, _))| {\n                                 Set1::One(Region::EarlyBound(i as u32, def_id.to_def_id()))\n                             })\n                     }\n@@ -1654,14 +1614,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         &mut self,\n         parent_id: Option<LocalDefId>,\n         hir_id: hir::HirId,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        insert_late_bound_lifetimes(self.map, decl, generics);\n-\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut next_early_index = 0;\n         if let Some(parent_id) = parent_id {\n@@ -1680,12 +1637,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<hir::ParamName, Region> = generics\n+        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n-                    if self.map.late_bound.contains(&param.hir_id) {\n+                    if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n                         Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n@@ -1706,7 +1663,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .iter()\n             .filter(|param| {\n                 matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                    && self.map.late_bound.contains(&param.hir_id)\n+                    && self.tcx.is_late_bound(param.hir_id)\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n@@ -1763,14 +1720,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.next_early_index_helper(false)\n     }\n \n-    fn resolve_lifetime_ref(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n-\n-        // If we've already reported an error, just ignore `lifetime_ref`.\n-        if let LifetimeName::Error = lifetime_ref.name {\n-            return;\n-        }\n-\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_lifetime_ref(\n+        &mut self,\n+        region_def_id: LocalDefId,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+    ) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes.\n@@ -1790,14 +1745,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { ref lifetimes, scope_type, s, .. } => {\n-                    match lifetime_ref.name {\n-                        LifetimeName::Param(param_name) => {\n-                            if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n-                            {\n-                                break Some(def.shifted(late_depth));\n-                            }\n-                        }\n-                        _ => bug!(\"expected LifetimeName::Param\"),\n+                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                        break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n@@ -2473,8 +2422,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        let mut lifetime_names = FxHashSet::default();\n-        let mut lifetime_spans = vec![];\n+        let mut in_scope_lifetimes = FxIndexSet::default();\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2484,12 +2432,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n-                    for name in lifetimes.keys() {\n-                        if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(name.name);\n-                            lifetime_spans.push(name.span);\n-                        }\n-                    }\n+                    in_scope_lifetimes.extend(lifetimes.keys().copied());\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n@@ -2524,12 +2467,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         match scope {\n                             Scope::Binder { ref lifetimes, s, .. } => {\n                                 // Collect named lifetimes for suggestions.\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(name.name);\n-                                        lifetime_spans.push(name.span);\n-                                    }\n-                                }\n+                                in_scope_lifetimes.extend(lifetimes.keys().copied());\n                                 scope = s;\n                             }\n                             Scope::ObjectLifetimeDefault { ref s, .. }\n@@ -2574,19 +2512,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n \n-        if let Some(params) = error {\n-            // If there's no lifetime available, suggest `'static`.\n-            if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(kw::StaticLifetime);\n-            }\n-        }\n-\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             spans_with_counts,\n-            &lifetime_names,\n-            lifetime_spans,\n-            error.unwrap_or(&[]),\n+            in_scope_lifetimes,\n+            error,\n         );\n         err.emit();\n     }\n@@ -2638,7 +2568,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n }\n \n /// Detects late-bound lifetimes and inserts them into\n-/// `map.late_bound`.\n+/// `late_bound`.\n ///\n /// A region declared on a fn is **late-bound** if:\n /// - it is constrained by an argument type;\n@@ -2647,12 +2577,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-#[tracing::instrument(level = \"debug\", skip(map))]\n-fn insert_late_bound_lifetimes(\n-    map: &mut NamedRegionMap,\n-    decl: &hir::FnDecl<'_>,\n-    generics: &hir::Generics<'_>,\n-) {\n+fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxHashSet<LocalDefId>> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let decl = tcx.hir().fn_decl_by_hir_id(hir_id)?;\n+    let generics = tcx.hir().get_generics(def_id)?;\n+\n+    let mut late_bound = FxHashSet::default();\n+\n     let mut constrained_by_input = ConstrainedCollector::default();\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n@@ -2683,30 +2614,32 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let lt_name = hir::LifetimeName::Param(param.name.normalize_to_macros_2_0());\n+        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&lt_name) {\n+        if appears_in_where_clause.regions.contains(&param_def_id) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&lt_name)\n-            && appears_in_output.regions.contains(&lt_name)\n+        if !constrained_by_input.regions.contains(&param_def_id)\n+            && appears_in_output.regions.contains(&param_def_id)\n         {\n             continue;\n         }\n \n         debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.hir_id);\n \n-        let inserted = map.late_bound.insert(param.hir_id);\n+        let inserted = late_bound.insert(param_def_id);\n         assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n     }\n \n-    return;\n+    debug!(?late_bound);\n+    return Some(tcx.arena.alloc(late_bound));\n \n     #[derive(Default)]\n     struct ConstrainedCollector {\n-        regions: FxHashSet<hir::LifetimeName>,\n+        regions: FxHashSet<LocalDefId>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -2738,18 +2671,22 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n+            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+                self.regions.insert(def_id);\n+            }\n         }\n     }\n \n     #[derive(Default)]\n     struct AllCollector {\n-        regions: FxHashSet<hir::LifetimeName>,\n+        regions: FxHashSet<LocalDefId>,\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n+            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+                self.regions.insert(def_id);\n+            }\n         }\n     }\n }"}, {"sha": "34d107349e7c70b29527103fa44f20fbc8264bc2", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -1364,7 +1364,6 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n     fn has_late_bound_regions<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        def_id: LocalDefId,\n         generics: &'tcx hir::Generics<'tcx>,\n         decl: &'tcx hir::FnDecl<'tcx>,\n     ) -> Option<Span> {\n@@ -1373,14 +1372,9 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             outer_index: ty::INNERMOST,\n             has_late_bound_regions: None,\n         };\n-        let late_bound_map = tcx.is_late_bound_map(def_id);\n-        let is_late_bound = |id| {\n-            let id = tcx.hir().local_def_id(id);\n-            late_bound_map.map_or(false, |(_, set)| set.contains(&id))\n-        };\n         for param in generics.params {\n             if let GenericParamKind::Lifetime { .. } = param.kind {\n-                if is_late_bound(param.hir_id) {\n+                if tcx.is_late_bound(param.hir_id) {\n                     return Some(param.span);\n                 }\n             }\n@@ -1392,25 +1386,25 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     match node {\n         Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, item.def_id, &item.generics, sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, item.def_id, &item.generics, sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n             hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n-                has_late_bound_regions(tcx, item.def_id, generics, fn_decl)\n+                has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n-                has_late_bound_regions(tcx, item.def_id, generics, sig.decl)\n+                has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,\n         },\n@@ -1671,7 +1665,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         params.push(opt_self);\n     }\n \n-    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n         name: param.name.ident().name,\n         index: own_start + i as u32,\n@@ -2054,23 +2048,10 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n     generics: &'a hir::Generics<'a>,\n ) -> impl Iterator<Item = &'a hir::GenericParam<'a>> + Captures<'tcx> {\n-    let late_bound_map = if generics.params.is_empty() {\n-        // This function may be called on `def_id == CRATE_DEF_ID`,\n-        // which makes `is_late_bound_map` ICE.  Don't even try if there\n-        // is no generic parameter.\n-        None\n-    } else {\n-        tcx.is_late_bound_map(def_id)\n-    };\n-    let is_late_bound = move |hir_id| {\n-        let id = tcx.hir().local_def_id(hir_id);\n-        late_bound_map.map_or(false, |(_, set)| set.contains(&id))\n-    };\n     generics.params.iter().filter(move |param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => !is_late_bound(param.hir_id),\n+        GenericParamKind::Lifetime { .. } => !tcx.is_late_bound(param.hir_id),\n         _ => false,\n     })\n }\n@@ -2255,7 +2236,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // have to be careful to only iterate over early-bound regions.\n     let mut index = parent_count\n         + has_own_self as u32\n-        + early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics).count() as u32;\n+        + early_bound_lifetimes_from_generics(tcx, ast_generics).count() as u32;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`)."}, {"sha": "bc3a3db9fdadb3e7ce35a12f4d6c71f7fd39f738", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -514,7 +514,9 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                             param_names\n                                 .iter()\n                                 .take(num_params_to_take)\n-                                .map(|p| p.as_str())\n+                                .map(|def_id| {\n+                                    self.tcx.item_name(def_id.to_def_id()).to_ident_string()\n+                                })\n                                 .collect::<Vec<_>>()\n                                 .join(\", \")\n                         } else {"}, {"sha": "f3070fb35f1d09bf2354a034809c77990b2b267e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -475,24 +475,14 @@ fn clean_generic_param<'tcx>(\n     generics: Option<&hir::Generics<'tcx>>,\n     param: &hir::GenericParam<'tcx>,\n ) -> GenericParamDef {\n+    let did = cx.tcx.hir().local_def_id(param.hir_id);\n     let (name, kind) = match param.kind {\n         hir::GenericParamKind::Lifetime { .. } => {\n             let outlives = if let Some(generics) = generics {\n                 generics\n-                    .predicates\n-                    .iter()\n-                    .flat_map(|pred| {\n-                        match pred {\n-                            hir::WherePredicate::RegionPredicate(rp)\n-                                if rp.lifetime.name == hir::LifetimeName::Param(param.name)\n-                                    && !rp.in_where_clause =>\n-                            {\n-                                rp.bounds\n-                            }\n-                            _ => &[],\n-                        }\n-                        .iter()\n-                    })\n+                    .outlives_for_param(did)\n+                    .filter(|bp| !bp.in_where_clause)\n+                    .flat_map(|bp| bp.bounds)\n                     .map(|bound| match bound {\n                         hir::GenericBound::Outlives(lt) => lt.clean(cx),\n                         _ => panic!(),\n@@ -504,7 +494,6 @@ fn clean_generic_param<'tcx>(\n             (param.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n         }\n         hir::GenericParamKind::Type { ref default, synthetic } => {\n-            let did = cx.tcx.hir().local_def_id(param.hir_id);\n             let bounds = if let Some(generics) = generics {\n                 generics\n                     .bounds_for_param(did)\n@@ -528,7 +517,7 @@ fn clean_generic_param<'tcx>(\n         hir::GenericParamKind::Const { ty, default } => (\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n-                did: cx.tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                did: did.to_def_id(),\n                 ty: Box::new(ty.clean(cx)),\n                 default: default.map(|ct| {\n                     let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n@@ -1459,7 +1448,7 @@ impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n                 // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n                 // there's no case where it could cause the function to fail to compile.\n                 let elided =\n-                    l.is_elided() || matches!(l.name, LifetimeName::Param(ParamName::Fresh(_)));\n+                    l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n                 let lifetime = if elided { None } else { Some(l.clean(cx)) };\n                 BorrowedRef { lifetime, mutability: m.mutbl, type_: box m.ty.clean(cx) }\n             }"}, {"sha": "070c7e591420d49128fea3160076391425d2c615", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -371,7 +371,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         if let Some(ref lt) = *lifetime {\n             if lt.name == LifetimeName::Static {\n                 self.lts.push(RefLt::Static);\n-            } else if let LifetimeName::Param(ParamName::Fresh(_)) = lt.name {\n+            } else if let LifetimeName::Param(_, ParamName::Fresh) = lt.name {\n                 // Fresh lifetimes generated should be ignored.\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);"}, {"sha": "0b96f6ff6835800aec2f42ec9614c88319c8425a", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -343,7 +343,7 @@ impl fmt::Display for RefPrefix {\n         use fmt::Write;\n         f.write_char('&')?;\n         match self.lt {\n-            LifetimeName::Param(ParamName::Plain(name)) => {\n+            LifetimeName::Param(_, ParamName::Plain(name)) => {\n                 name.fmt(f)?;\n                 f.write_char(' ')?;\n             },"}, {"sha": "fc1a4e1f6025555bb7c472d6c4c0968676bf3a9b", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=53ab3b2e6e8ded3e4cf8456ea5a66e70d24bcb69", "patch": "@@ -902,16 +902,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_lifetime(&mut self, lifetime: Lifetime) {\n         std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n-        if let LifetimeName::Param(ref name) = lifetime.name {\n+        if let LifetimeName::Param(param_id, ref name) = lifetime.name {\n             std::mem::discriminant(name).hash(&mut self.s);\n+            param_id.hash(&mut self.s);\n             match name {\n                 ParamName::Plain(ref ident) => {\n                     ident.name.hash(&mut self.s);\n                 },\n-                ParamName::Fresh(ref size) => {\n-                    size.hash(&mut self.s);\n-                },\n-                ParamName::Error => {},\n+                ParamName::Fresh | ParamName::Error => {},\n             }\n         }\n     }"}]}