{"sha": "213b6d71f502a8568208cf549050a71cc24b1338", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxM2I2ZDcxZjUwMmE4NTY4MjA4Y2Y1NDkwNTBhNzFjYzI0YjEzMzg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-07-22T17:10:18Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-06T11:17:04Z"}, "message": "add variant info to ADTDef, but don't actually use it", "tree": {"sha": "16dbf1460a1b8f4f3fa9892b6ea9590e0eaf8c98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16dbf1460a1b8f4f3fa9892b6ea9590e0eaf8c98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/213b6d71f502a8568208cf549050a71cc24b1338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/213b6d71f502a8568208cf549050a71cc24b1338", "html_url": "https://github.com/rust-lang/rust/commit/213b6d71f502a8568208cf549050a71cc24b1338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/213b6d71f502a8568208cf549050a71cc24b1338/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764310e7bb90ec14a6c6a399e703f6b455ba52d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/764310e7bb90ec14a6c6a399e703f6b455ba52d3", "html_url": "https://github.com/rust-lang/rust/commit/764310e7bb90ec14a6c6a399e703f6b455ba52d3"}], "stats": {"total": 127, "additions": 112, "deletions": 15}, "files": [{"sha": "1a15d98d53150eb6beba317c510ce40b8b54920e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=213b6d71f502a8568208cf549050a71cc24b1338", "patch": "@@ -32,6 +32,7 @@\n #![feature(clone_from_slice)]\n #![feature(collections)]\n #![feature(const_fn)]\n+#![feature(core)]\n #![feature(duration)]\n #![feature(duration_span)]\n #![feature(dynamic_lib)]\n@@ -42,6 +43,7 @@\n #![feature(iter_cmp)]\n #![feature(iter_arith)]\n #![feature(libc)]\n+#![feature(nonzero)]\n #![feature(num_bits_bytes)]\n #![feature(path_ext)]\n #![feature(quote)]\n@@ -65,6 +67,7 @@\n #![allow(trivial_casts)]\n \n extern crate arena;\n+extern crate core;\n extern crate flate;\n extern crate fmt_macros;\n extern crate getopts;"}, {"sha": "9e8c5505c89eb70dda56a264842e911fb693b0b8", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=213b6d71f502a8568208cf549050a71cc24b1338", "patch": "@@ -394,7 +394,8 @@ pub fn get_adt_def<'tcx>(cdata: Cmd,\n                          item_id: ast::NodeId,\n                          tcx: &ty::ctxt<'tcx>) -> &'tcx ty::ADTDef<'tcx>\n {\n-    tcx.intern_adt_def(ast::DefId { krate: cdata.cnum, node: item_id })\n+    tcx.intern_adt_def(ast::DefId { krate: cdata.cnum, node: item_id },\n+                       ty::ADTKind::Enum)\n }\n \n pub fn get_predicates<'tcx>(cdata: Cmd,"}, {"sha": "a491d6e65b7d85cccb2b2f0b7f75ea580eacf34e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 105, "deletions": 12, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=213b6d71f502a8568208cf549050a71cc24b1338", "patch": "@@ -74,12 +74,15 @@ use std::cell::{Cell, RefCell, Ref};\n use std::cmp;\n use std::fmt;\n use std::hash::{Hash, SipHasher, Hasher};\n+use std::marker::PhantomData;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n use std::vec::IntoIter;\n use collections::enum_set::{self, EnumSet, CLike};\n+use core::nonzero::NonZero;\n use std::collections::{HashMap, HashSet};\n+use rustc_data_structures::ivar;\n use syntax::abi;\n use syntax::ast::{CrateNum, DefId, ItemImpl, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n@@ -721,7 +724,7 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     trait_defs: TypedArena<TraitDef<'tcx>>,\n-    adt_defs: TypedArena<ADTDef<'tcx>>,\n+    adt_defs: TypedArena<ADTDef_<'tcx, 'tcx>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -1020,9 +1023,10 @@ impl<'tcx> ctxt<'tcx> {\n         interned\n     }\n \n-    pub fn intern_adt_def(&self, did: DefId) -> &'tcx ADTDef<'tcx> {\n-        let def = ADTDef::new(self, did);\n+    pub fn intern_adt_def(&self, did: DefId, kind: ADTKind) -> &'tcx ADTDef_<'tcx, 'tcx> {\n+        let def = ADTDef_::new(self, did, kind);\n         let interned = self.arenas.adt_defs.alloc(def);\n+        // this will need a transmute when reverse-variance is removed\n         self.adt_defs.borrow_mut().insert(did, interned);\n         interned\n     }\n@@ -1395,6 +1399,61 @@ impl<'tcx> Hash for TyS<'tcx> {\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n+/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n+/// on the lifetime of the IVar. This is required because of variance\n+/// problems: the IVar needs to be variant with respect to 'tcx (so\n+/// it can be referred to from Ty) but can only be modified if its\n+/// lifetime is exactly 'tcx.\n+///\n+/// Safety invariants:\n+///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n+///     (B) no aliases to this value with a 'tcx longer than this\n+///         value's 'lt exist\n+///\n+/// NonZero is used rather than Unique because Unique isn't Copy.\n+pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n+                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n+\n+impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        // Invariant (A) satisfied because the IVar is unfulfilled\n+        // Invariant (B) because 'lt : 'tcx\n+        TyIVar(ivar::Ivar::new(), PhantomData)\n+    }\n+\n+    #[inline]\n+    pub fn get(&self) -> Option<Ty<'tcx>> {\n+        match self.0.get() {\n+            None => None,\n+            // valid because of invariant (A)\n+            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n+        }\n+    }\n+    #[inline]\n+    pub fn unwrap(&self) -> Ty<'tcx> {\n+        self.get().unwrap()\n+    }\n+\n+    pub fn fulfill(&self, value: Ty<'lt>) {\n+        // Invariant (A) is fulfilled, because by (B), every alias\n+        // of this has a 'tcx longer than 'lt.\n+        let value: *const TyS<'lt> = value;\n+        // FIXME(27214): unneeded [as *const ()]\n+        let value = value as *const () as *const TyS<'static>;\n+        self.0.fulfill(unsafe { NonZero::new(value) })\n+    }\n+}\n+\n+impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n+            Some(val) => write!(f, \"TyIVar({:?})\", val),\n+            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n+        }\n+    }\n+}\n+\n /// An entry in the type interner.\n pub struct InternedTy<'tcx> {\n     ty: Ty<'tcx>\n@@ -3210,44 +3269,69 @@ bitflags! {\n         const IS_PHANTOM_DATA     = 1 << 1,\n         const IS_DTORCK           = 1 << 2, // is this a dtorck type?\n         const IS_DTORCK_VALID     = 1 << 3,\n+        const IS_ENUM             = 1 << 4\n     }\n }\n \n-/// The definition of an abstract data type - a struct or enum.\n-pub struct ADTDef<'tcx> {\n+pub type ADTDef<'tcx> = ADTDef_<'tcx, 'static>;\n+\n+pub struct VariantDef<'tcx, 'lt: 'tcx> {\n+    pub did: DefId,\n+    pub name: Name, // struct's name if this is a struct\n+    pub disr_val: Disr,\n+    pub fields: Vec<FieldDef<'tcx, 'lt>>\n+}\n+\n+pub struct FieldDef<'tcx, 'lt: 'tcx> {\n+    pub did: DefId,\n+    pub name: Name, // XXX if tuple-like\n+    pub vis: ast::Visibility,\n+    // TyIVar is used here to allow for\n+    ty: TyIVar<'tcx, 'lt>\n+}\n+\n+/// The definition of an abstract data type - a struct or enum. 'lt\n+/// is here so 'tcx can be variant.\n+pub struct ADTDef_<'tcx, 'lt: 'tcx> {\n     pub did: DefId,\n+    pub variants: Vec<VariantDef<'tcx, 'lt>>,\n     flags: Cell<ADTFlags>,\n-    marker: ::std::marker::PhantomData<&'tcx ()>,\n }\n \n-impl<'tcx> PartialEq for ADTDef<'tcx> {\n+impl<'tcx, 'lt> PartialEq for ADTDef_<'tcx, 'lt> {\n     // ADTDef are always interned and this is part of TyS equality\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n }\n \n-impl<'tcx> Eq for ADTDef<'tcx> {}\n+impl<'tcx, 'lt> Eq for ADTDef_<'tcx, 'lt> {}\n \n-impl<'tcx> Hash for ADTDef<'tcx> {\n+impl<'tcx, 'lt> Hash for ADTDef_<'tcx, 'lt> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n         (self as *const ADTDef).hash(s)\n     }\n }\n \n-impl<'tcx> ADTDef<'tcx> {\n-    fn new(tcx: &ctxt<'tcx>, did: DefId) -> Self {\n+#[derive(Copy, Clone, Debug)]\n+pub enum ADTKind { Struct, Enum }\n+\n+impl<'tcx, 'lt> ADTDef_<'tcx, 'lt> {\n+    fn new(tcx: &ctxt<'tcx>, did: DefId, kind: ADTKind) -> Self {\n         let mut flags = ADTFlags::NO_ADT_FLAGS;\n         if tcx.has_attr(did, \"fundamental\") {\n             flags = flags | ADTFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | ADTFlags::IS_PHANTOM_DATA;\n         }\n+        if let ADTKind::Enum = kind {\n+            flags = flags | ADTFlags::IS_ENUM;\n+        }\n         ADTDef {\n             did: did,\n+            variants: vec![],\n             flags: Cell::new(flags),\n-            marker: ::std::marker::PhantomData\n         }\n     }\n \n@@ -3258,6 +3342,15 @@ impl<'tcx> ADTDef<'tcx> {\n         self.flags.set(self.flags.get() | ADTFlags::IS_DTORCK_VALID)\n     }\n \n+    #[inline]\n+    pub fn adt_kind(&self) -> ADTKind {\n+        if self.flags.get().intersects(ADTFlags::IS_ENUM) {\n+            ADTKind::Enum\n+        } else {\n+            ADTKind::Struct\n+        }\n+    }\n+\n     #[inline]\n     pub fn is_dtorck(&'tcx self, tcx: &ctxt<'tcx>) -> bool {\n         if !self.flags.get().intersects(ADTFlags::IS_DTORCK_VALID) {"}, {"sha": "708825fc95ab0d4fd432ce996141146290f004ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213b6d71f502a8568208cf549050a71cc24b1338/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=213b6d71f502a8568208cf549050a71cc24b1338", "patch": "@@ -1473,14 +1473,14 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             // Create a new generic polytype.\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let def = tcx.intern_adt_def(local_def(it.id));\n+            let def = tcx.intern_adt_def(local_def(it.id), ty::ADTKind::Enum);\n             let t = tcx.mk_enum(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         ast::ItemStruct(_, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics);\n-            let def = tcx.intern_adt_def(local_def(it.id));\n+            let def = tcx.intern_adt_def(local_def(it.id), ty::ADTKind::Struct);\n             let t = tcx.mk_struct(def, tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }"}]}