{"sha": "bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmY2VlNjNlNzVkNmZlYjIxY2FmYmRmMzg4N2UwZWZkNTA4YjZiMmU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T14:52:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-31T14:52:08Z"}, "message": "Work on expressions grammar", "tree": {"sha": "f581a142abd56ff49c84f1b0c3f0b32ef8be5639", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f581a142abd56ff49c84f1b0c3f0b32ef8be5639"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "html_url": "https://github.com/rust-lang/rust/commit/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4d986c7f850e1f535bb4c22e3a7f7fba5483628", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d986c7f850e1f535bb4c22e3a7f7fba5483628", "html_url": "https://github.com/rust-lang/rust/commit/d4d986c7f850e1f535bb4c22e3a7f7fba5483628"}], "stats": {"total": 1683, "additions": 862, "deletions": 821}, "files": [{"sha": "67d7041fc401833be14515227411ca84b332c5fb", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "patch": "@@ -224,9 +224,22 @@ impl ExprCollector<'_> {\n                     self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n                 }\n                 // FIXME: we need to record these effects somewhere...\n-                ast::Effect::Async(_) | ast::Effect::Label(_) => {\n-                    self.collect_block_opt(e.block_expr())\n-                }\n+                ast::Effect::Label(label) => match e.block_expr() {\n+                    Some(block) => {\n+                        let res = self.collect_block(block);\n+                        match &mut self.body.exprs[res] {\n+                            Expr::Block { label: block_label, .. } => {\n+                                *block_label =\n+                                    label.lifetime_token().map(|t| Name::new_lifetime(&t))\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                        res\n+                    }\n+                    None => self.missing_expr(),\n+                },\n+                // FIXME: we need to record these effects somewhere...\n+                ast::Effect::Async(_) => self.collect_block_opt(e.block_expr()),\n             },\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n@@ -618,8 +631,7 @@ impl ExprCollector<'_> {\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n-        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n+        self.alloc_expr(Expr::Block { statements, tail, label: None }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {"}, {"sha": "186db538b810c2c7e71823773f152cf7ff12078e", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 669, "deletions": 659, "changes": 1328, "blob_url": "https://github.com/rust-lang/rust/blob/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "patch": "@@ -349,7 +349,6 @@ pub struct BlockExpr {\n }\n impl ast::AttrsOwner for BlockExpr {}\n impl BlockExpr {\n-    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n     pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n     pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n@@ -468,6 +467,19 @@ impl ExternItemList {\n     pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstParam {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ConstParam {}\n+impl ast::NameOwner for ConstParam {}\n+impl ConstParam {\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LifetimeParam {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -490,19 +502,6 @@ impl TypeParam {\n     pub fn default_type(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ConstParam {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ConstParam {}\n-impl ast::NameOwner for ConstParam {}\n-impl ConstParam {\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn default_val(&self) -> Option<Expr> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WherePred {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -519,6 +518,7 @@ impl WherePred {\n pub struct Literal {\n     pub(crate) syntax: SyntaxNode,\n }\n+impl ast::AttrsOwner for Literal {}\n impl Literal {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TokenTree {\n@@ -533,6 +533,15 @@ impl TokenTree {\n     pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExprStmt {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for ExprStmt {}\n+impl ExprStmt {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LetStmt {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -547,165 +556,196 @@ impl LetStmt {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ExprStmt {\n+pub struct ArrayExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ExprStmt {}\n-impl ExprStmt {\n+impl ast::AttrsOwner for ArrayExpr {}\n+impl ArrayExpr {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ParenType {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ParenType {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TupleType {\n+pub struct AwaitExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl TupleType {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n+impl ast::AttrsOwner for AwaitExpr {}\n+impl AwaitExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct NeverType {\n+pub struct BinExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl NeverType {\n-    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n+impl ast::AttrsOwner for BinExpr {}\n+impl BinExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PathType {\n+pub struct BoxExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl PathType {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for BoxExpr {}\n+impl BoxExpr {\n+    pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PointerType {\n+pub struct BreakExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl PointerType {\n-    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for BreakExpr {}\n+impl BreakExpr {\n+    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ArrayType {\n+pub struct CallExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ArrayType {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+impl ast::AttrsOwner for CallExpr {}\n+impl ast::ArgListOwner for CallExpr {}\n+impl CallExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct SliceType {\n+pub struct CastExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl SliceType {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+impl ast::AttrsOwner for CastExpr {}\n+impl CastExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ReferenceType {\n+pub struct ContinueExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ReferenceType {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+impl ast::AttrsOwner for ContinueExpr {}\n+impl ContinueExpr {\n+    pub fn continue_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![continue])\n+    }\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct InferType {\n+pub struct EffectExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl InferType {\n-    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n+impl ast::AttrsOwner for EffectExpr {}\n+impl EffectExpr {\n+    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n+    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FnPointerType {\n+pub struct FieldExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl FnPointerType {\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n-    pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n-    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }\n-    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n-    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for FieldExpr {}\n+impl FieldExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ForType {\n+pub struct ForExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ForType {\n+impl ast::AttrsOwner for ForExpr {}\n+impl ast::LoopBodyOwner for ForExpr {}\n+impl ForExpr {\n     pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n-    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n+    pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ImplTraitType {\n+pub struct IfExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ImplTraitType {\n-    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n-    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for IfExpr {}\n+impl IfExpr {\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n+    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n+    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n+    pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }\n+    pub fn if_expr(&self) -> Option<IfExpr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct DynTraitType {\n+pub struct IndexExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl DynTraitType {\n-    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n-    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for IndexExpr {}\n+impl IndexExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TypeBound {\n+pub struct Label {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl TypeBound {\n+impl Label {\n     pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n         support::token(&self.syntax, T![lifetime])\n     }\n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n-    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TupleExpr {\n+pub struct LambdaExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for TupleExpr {}\n-impl TupleExpr {\n-    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n-    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n-    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n+impl ast::AttrsOwner for LambdaExpr {}\n+impl LambdaExpr {\n+    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }\n+    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n+    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n+    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ArrayExpr {\n+pub struct LoopExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ArrayExpr {}\n-impl ArrayExpr {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n+impl ast::AttrsOwner for LoopExpr {}\n+impl ast::LoopBodyOwner for LoopExpr {}\n+impl LoopExpr {\n+    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MatchExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for MatchExpr {}\n+impl MatchExpr {\n+    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n+    pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MethodCallExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::AttrsOwner for MethodCallExpr {}\n+impl ast::ArgListOwner for MethodCallExpr {}\n+impl MethodCallExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct ParenExpr {\n@@ -721,82 +761,75 @@ impl ParenExpr {\n pub struct PathExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n+impl ast::AttrsOwner for PathExpr {}\n impl PathExpr {\n     pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LambdaExpr {\n+pub struct PrefixExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for LambdaExpr {}\n-impl LambdaExpr {\n-    pub fn static_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![static]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n-    pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }\n-    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n-    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n-    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for PrefixExpr {}\n+impl PrefixExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct IfExpr {\n+pub struct RangeExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for IfExpr {}\n-impl IfExpr {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for RangeExpr {}\n+impl RangeExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Condition {\n+pub struct RecordExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl Condition {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl RecordExpr {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n+    pub fn record_expr_field_list(&self) -> Option<RecordExprFieldList> {\n+        support::child(&self.syntax)\n+    }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct EffectExpr {\n+pub struct RefExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for EffectExpr {}\n-impl EffectExpr {\n-    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }\n-    pub fn try_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![try]) }\n-    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n-    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n-    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for RefExpr {}\n+impl RefExpr {\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Label {\n+pub struct ReturnExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl Label {\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n+impl ast::AttrsOwner for ReturnExpr {}\n+impl ReturnExpr {\n+    pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct LoopExpr {\n+pub struct TryExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for LoopExpr {}\n-impl ast::LoopBodyOwner for LoopExpr {}\n-impl LoopExpr {\n-    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }\n+impl ast::AttrsOwner for TryExpr {}\n+impl TryExpr {\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ForExpr {\n+pub struct TupleExpr {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ForExpr {}\n-impl ast::LoopBodyOwner for ForExpr {}\n-impl ForExpr {\n-    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }\n-    pub fn iterable(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for TupleExpr {}\n+impl TupleExpr {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhileExpr {\n@@ -809,46 +842,25 @@ impl WhileExpr {\n     pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ContinueExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for ContinueExpr {}\n-impl ContinueExpr {\n-    pub fn continue_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![continue])\n-    }\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BreakExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for BreakExpr {}\n-impl BreakExpr {\n-    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }\n-    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n-        support::token(&self.syntax, T![lifetime])\n-    }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ReturnExpr {\n+pub struct RecordExprFieldList {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for ReturnExpr {}\n-impl ReturnExpr {\n-    pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ast::AttrsOwner for RecordExprFieldList {}\n+impl RecordExprFieldList {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn fields(&self) -> AstChildren<RecordExprField> { support::children(&self.syntax) }\n+    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n+    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct CallExpr {\n+pub struct RecordExprField {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for CallExpr {}\n-impl ast::ArgListOwner for CallExpr {}\n-impl CallExpr {\n+impl ast::AttrsOwner for RecordExprField {}\n+impl RecordExprField {\n+    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n+    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -861,18 +873,6 @@ impl ArgList {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MethodCallExpr {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl ast::AttrsOwner for MethodCallExpr {}\n-impl ast::ArgListOwner for MethodCallExpr {}\n-impl MethodCallExpr {\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }\n-}\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeArgList {\n     pub(crate) syntax: SyntaxNode,\n }\n@@ -886,162 +886,174 @@ impl TypeArgList {\n     pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct FieldExpr {\n+pub struct Condition {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for FieldExpr {}\n-impl FieldExpr {\n+impl Condition {\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct IndexExpr {\n+pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for IndexExpr {}\n-impl IndexExpr {\n-    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n-    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n+impl ast::AttrsOwner for MatchArmList {}\n+impl MatchArmList {\n+    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n+    pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n+    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct AwaitExpr {\n+pub struct MatchArm {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for AwaitExpr {}\n-impl AwaitExpr {\n+impl ast::AttrsOwner for MatchArm {}\n+impl MatchArm {\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n+    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }\n-    pub fn await_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![await]) }\n+    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct TryExpr {\n+pub struct MatchGuard {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for TryExpr {}\n-impl TryExpr {\n+impl MatchGuard {\n+    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct CastExpr {\n+pub struct ArrayType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for CastExpr {}\n-impl CastExpr {\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }\n+impl ArrayType {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RefExpr {\n+pub struct DynTraitType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RefExpr {}\n-impl RefExpr {\n-    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n-    pub fn raw_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![raw]) }\n-    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n-    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl DynTraitType {\n+    pub fn dyn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![dyn]) }\n+    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct PrefixExpr {\n+pub struct FnPointerType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for PrefixExpr {}\n-impl PrefixExpr {\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl FnPointerType {\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn async_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![async]) }\n+    pub fn unsafe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![unsafe]) }\n+    pub fn abi(&self) -> Option<Abi> { support::child(&self.syntax) }\n+    pub fn fn_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fn]) }\n+    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }\n+    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BoxExpr {\n+pub struct ForType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for BoxExpr {}\n-impl BoxExpr {\n-    pub fn box_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![box]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl ForType {\n+    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }\n+    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RangeExpr {\n+pub struct ImplTraitType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RangeExpr {}\n-impl RangeExpr {}\n+impl ImplTraitType {\n+    pub fn impl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![impl]) }\n+    pub fn type_bound_list(&self) -> Option<TypeBoundList> { support::child(&self.syntax) }\n+}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct BinExpr {\n+pub struct InferType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for BinExpr {}\n-impl BinExpr {}\n+impl InferType {\n+    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![_]) }\n+}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchExpr {\n+pub struct NeverType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for MatchExpr {}\n-impl MatchExpr {\n-    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }\n+impl NeverType {\n+    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchArmList {\n+pub struct ParenType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl MatchArmList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+impl ParenType {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchArm {\n+pub struct PathType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for MatchArm {}\n-impl MatchArm {\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }\n-    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl PathType {\n+    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MatchGuard {\n+pub struct PointerType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl MatchGuard {\n-    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl PointerType {\n+    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }\n+    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordExpr {\n+pub struct ReferenceType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RecordExpr {\n-    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }\n-    pub fn record_expr_field_list(&self) -> Option<RecordExprFieldList> {\n-        support::child(&self.syntax)\n+impl ReferenceType {\n+    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n     }\n+    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct SliceType {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl SliceType {\n+    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n+    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordExprFieldList {\n+pub struct TupleType {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl RecordExprFieldList {\n-    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }\n-    pub fn fields(&self) -> AstChildren<RecordExprField> { support::children(&self.syntax) }\n-    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }\n-    pub fn spread(&self) -> Option<Expr> { support::child(&self.syntax) }\n-    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }\n+impl TupleType {\n+    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }\n+    pub fn fields(&self) -> AstChildren<Type> { support::children(&self.syntax) }\n+    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct RecordExprField {\n+pub struct TypeBound {\n     pub(crate) syntax: SyntaxNode,\n }\n-impl ast::AttrsOwner for RecordExprField {}\n-impl RecordExprField {\n-    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+impl TypeBound {\n+    pub fn lifetime_token(&self) -> Option<SyntaxToken> {\n+        support::token(&self.syntax, T![lifetime])\n+    }\n+    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }\n+    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct OrPat {\n@@ -1285,19 +1297,19 @@ pub enum Item {\n impl ast::AttrsOwner for Item {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Type {\n-    ParenType(ParenType),\n-    TupleType(TupleType),\n-    NeverType(NeverType),\n-    PathType(PathType),\n-    PointerType(PointerType),\n     ArrayType(ArrayType),\n-    SliceType(SliceType),\n-    ReferenceType(ReferenceType),\n-    InferType(InferType),\n+    DynTraitType(DynTraitType),\n     FnPointerType(FnPointerType),\n     ForType(ForType),\n     ImplTraitType(ImplTraitType),\n-    DynTraitType(DynTraitType),\n+    InferType(InferType),\n+    NeverType(NeverType),\n+    ParenType(ParenType),\n+    PathType(PathType),\n+    PointerType(PointerType),\n+    ReferenceType(ReferenceType),\n+    SliceType(SliceType),\n+    TupleType(TupleType),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Pat {\n@@ -1324,42 +1336,42 @@ pub enum FieldList {\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Expr {\n-    TupleExpr(TupleExpr),\n     ArrayExpr(ArrayExpr),\n-    ParenExpr(ParenExpr),\n-    PathExpr(PathExpr),\n-    LambdaExpr(LambdaExpr),\n-    IfExpr(IfExpr),\n-    LoopExpr(LoopExpr),\n-    ForExpr(ForExpr),\n-    WhileExpr(WhileExpr),\n-    ContinueExpr(ContinueExpr),\n-    BreakExpr(BreakExpr),\n-    Label(Label),\n+    AwaitExpr(AwaitExpr),\n+    BinExpr(BinExpr),\n     BlockExpr(BlockExpr),\n-    ReturnExpr(ReturnExpr),\n-    MatchExpr(MatchExpr),\n-    RecordExpr(RecordExpr),\n+    BoxExpr(BoxExpr),\n+    BreakExpr(BreakExpr),\n     CallExpr(CallExpr),\n+    CastExpr(CastExpr),\n+    ContinueExpr(ContinueExpr),\n+    EffectExpr(EffectExpr),\n+    FieldExpr(FieldExpr),\n+    ForExpr(ForExpr),\n+    IfExpr(IfExpr),\n     IndexExpr(IndexExpr),\n+    Label(Label),\n+    LambdaExpr(LambdaExpr),\n+    Literal(Literal),\n+    LoopExpr(LoopExpr),\n+    MacroCall(MacroCall),\n+    MatchExpr(MatchExpr),\n     MethodCallExpr(MethodCallExpr),\n-    FieldExpr(FieldExpr),\n-    AwaitExpr(AwaitExpr),\n-    TryExpr(TryExpr),\n-    EffectExpr(EffectExpr),\n-    CastExpr(CastExpr),\n-    RefExpr(RefExpr),\n+    ParenExpr(ParenExpr),\n+    PathExpr(PathExpr),\n     PrefixExpr(PrefixExpr),\n     RangeExpr(RangeExpr),\n-    BinExpr(BinExpr),\n-    Literal(Literal),\n-    MacroCall(MacroCall),\n-    BoxExpr(BoxExpr),\n+    RecordExpr(RecordExpr),\n+    RefExpr(RefExpr),\n+    ReturnExpr(ReturnExpr),\n+    TryExpr(TryExpr),\n+    TupleExpr(TupleExpr),\n+    WhileExpr(WhileExpr),\n }\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AdtDef {\n-    Struct(Struct),\n     Enum(Enum),\n+    Struct(Struct),\n     Union(Union),\n }\n impl ast::AttrsOwner for AdtDef {}\n@@ -1368,10 +1380,10 @@ impl ast::NameOwner for AdtDef {}\n impl ast::VisibilityOwner for AdtDef {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum AssocItem {\n-    Fn(Fn),\n-    TypeAlias(TypeAlias),\n     Const(Const),\n+    Fn(Fn),\n     MacroCall(MacroCall),\n+    TypeAlias(TypeAlias),\n }\n impl ast::AttrsOwner for AssocItem {}\n impl ast::NameOwner for AssocItem {}\n@@ -1385,16 +1397,16 @@ impl ast::AttrsOwner for ExternItem {}\n impl ast::NameOwner for ExternItem {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericParam {\n+    ConstParam(ConstParam),\n     LifetimeParam(LifetimeParam),\n     TypeParam(TypeParam),\n-    ConstParam(ConstParam),\n }\n impl ast::AttrsOwner for GenericParam {}\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum Stmt {\n-    LetStmt(LetStmt),\n     ExprStmt(ExprStmt),\n     Item(Item),\n+    LetStmt(LetStmt),\n }\n impl AstNode for SourceFile {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }\n@@ -1847,8 +1859,8 @@ impl AstNode for ExternItemList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LifetimeParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_PARAM }\n+impl AstNode for ConstParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1858,8 +1870,8 @@ impl AstNode for LifetimeParam {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }\n+impl AstNode for LifetimeParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1869,8 +1881,8 @@ impl AstNode for TypeParam {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ConstParam {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_PARAM }\n+impl AstNode for TypeParam {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1913,8 +1925,8 @@ impl AstNode for TokenTree {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LetStmt {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }\n+impl AstNode for ExprStmt {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1924,8 +1936,8 @@ impl AstNode for LetStmt {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ExprStmt {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }\n+impl AstNode for LetStmt {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1935,8 +1947,8 @@ impl AstNode for ExprStmt {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ParenType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }\n+impl AstNode for ArrayExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1946,8 +1958,8 @@ impl AstNode for ParenType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }\n+impl AstNode for AwaitExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1957,8 +1969,8 @@ impl AstNode for TupleType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for NeverType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == NEVER_TYPE }\n+impl AstNode for BinExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1968,8 +1980,8 @@ impl AstNode for NeverType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }\n+impl AstNode for BoxExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BOX_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1979,8 +1991,8 @@ impl AstNode for PathType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PointerType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == POINTER_TYPE }\n+impl AstNode for BreakExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -1990,8 +2002,8 @@ impl AstNode for PointerType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ArrayType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_TYPE }\n+impl AstNode for CallExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2001,8 +2013,8 @@ impl AstNode for ArrayType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for SliceType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_TYPE }\n+impl AstNode for CastExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CAST_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2012,8 +2024,8 @@ impl AstNode for SliceType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ReferenceType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == REFERENCE_TYPE }\n+impl AstNode for ContinueExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2023,8 +2035,8 @@ impl AstNode for ReferenceType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for InferType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == INFER_TYPE }\n+impl AstNode for EffectExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EFFECT_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2034,8 +2046,8 @@ impl AstNode for InferType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for FnPointerType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_POINTER_TYPE }\n+impl AstNode for FieldExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FIELD_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2045,8 +2057,8 @@ impl AstNode for FnPointerType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ForType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_TYPE }\n+impl AstNode for ForExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2056,8 +2068,8 @@ impl AstNode for ForType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ImplTraitType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_TRAIT_TYPE }\n+impl AstNode for IfExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2067,8 +2079,8 @@ impl AstNode for ImplTraitType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for DynTraitType {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == DYN_TRAIT_TYPE }\n+impl AstNode for IndexExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2078,8 +2090,8 @@ impl AstNode for DynTraitType {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeBound {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }\n+impl AstNode for Label {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LABEL }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2089,8 +2101,8 @@ impl AstNode for TypeBound {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TupleExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_EXPR }\n+impl AstNode for LambdaExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2100,8 +2112,8 @@ impl AstNode for TupleExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ArrayExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_EXPR }\n+impl AstNode for LoopExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2111,8 +2123,8 @@ impl AstNode for ArrayExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ParenExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }\n+impl AstNode for MatchExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2122,8 +2134,8 @@ impl AstNode for ParenExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PathExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }\n+impl AstNode for MethodCallExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2133,8 +2145,8 @@ impl AstNode for PathExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LambdaExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_EXPR }\n+impl AstNode for ParenExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2144,8 +2156,8 @@ impl AstNode for LambdaExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for IfExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_EXPR }\n+impl AstNode for PathExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2155,8 +2167,8 @@ impl AstNode for IfExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Condition {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }\n+impl AstNode for PrefixExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2166,8 +2178,8 @@ impl AstNode for Condition {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for EffectExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == EFFECT_EXPR }\n+impl AstNode for RangeExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2177,8 +2189,8 @@ impl AstNode for EffectExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Label {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LABEL }\n+impl AstNode for RecordExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2188,8 +2200,8 @@ impl AstNode for Label {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for LoopExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_EXPR }\n+impl AstNode for RefExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2199,8 +2211,8 @@ impl AstNode for LoopExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ForExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }\n+impl AstNode for ReturnExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2210,8 +2222,8 @@ impl AstNode for ForExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for WhileExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_EXPR }\n+impl AstNode for TryExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2221,8 +2233,8 @@ impl AstNode for WhileExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ContinueExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_EXPR }\n+impl AstNode for TupleExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2232,8 +2244,8 @@ impl AstNode for ContinueExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BreakExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_EXPR }\n+impl AstNode for WhileExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_EXPR }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2243,8 +2255,8 @@ impl AstNode for BreakExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for ReturnExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_EXPR }\n+impl AstNode for RecordExprFieldList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2254,8 +2266,8 @@ impl AstNode for ReturnExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for CallExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }\n+impl AstNode for RecordExprField {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2276,8 +2288,8 @@ impl AstNode for ArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MethodCallExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_EXPR }\n+impl AstNode for TypeArgList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2287,8 +2299,8 @@ impl AstNode for MethodCallExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TypeArgList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }\n+impl AstNode for Condition {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2298,8 +2310,8 @@ impl AstNode for TypeArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for FieldExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == FIELD_EXPR }\n+impl AstNode for MatchArmList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2309,8 +2321,8 @@ impl AstNode for FieldExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for IndexExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_EXPR }\n+impl AstNode for MatchArm {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2320,8 +2332,8 @@ impl AstNode for IndexExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for AwaitExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_EXPR }\n+impl AstNode for MatchGuard {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_GUARD }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2331,8 +2343,8 @@ impl AstNode for AwaitExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for TryExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_EXPR }\n+impl AstNode for ArrayType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2342,8 +2354,8 @@ impl AstNode for TryExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for CastExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CAST_EXPR }\n+impl AstNode for DynTraitType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DYN_TRAIT_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2353,8 +2365,8 @@ impl AstNode for CastExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RefExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_EXPR }\n+impl AstNode for FnPointerType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_POINTER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2364,8 +2376,8 @@ impl AstNode for RefExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for PrefixExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }\n+impl AstNode for ForType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2375,8 +2387,8 @@ impl AstNode for PrefixExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BoxExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BOX_EXPR }\n+impl AstNode for ImplTraitType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_TRAIT_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2386,8 +2398,8 @@ impl AstNode for BoxExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RangeExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_EXPR }\n+impl AstNode for InferType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == INFER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2397,8 +2409,8 @@ impl AstNode for RangeExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for BinExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }\n+impl AstNode for NeverType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NEVER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2408,8 +2420,8 @@ impl AstNode for BinExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_EXPR }\n+impl AstNode for ParenType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2419,8 +2431,8 @@ impl AstNode for MatchExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchArmList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }\n+impl AstNode for PathType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2430,8 +2442,8 @@ impl AstNode for MatchArmList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchArm {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM }\n+impl AstNode for PointerType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == POINTER_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2441,8 +2453,8 @@ impl AstNode for MatchArm {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for MatchGuard {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_GUARD }\n+impl AstNode for ReferenceType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REFERENCE_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2452,8 +2464,8 @@ impl AstNode for MatchGuard {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordExpr {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR }\n+impl AstNode for SliceType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLICE_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2463,8 +2475,8 @@ impl AstNode for RecordExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordExprFieldList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD_LIST }\n+impl AstNode for TupleType {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2474,8 +2486,8 @@ impl AstNode for RecordExprFieldList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for RecordExprField {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == RECORD_EXPR_FIELD }\n+impl AstNode for TypeBound {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         if Self::can_cast(syntax.kind()) {\n             Some(Self { syntax })\n@@ -2849,88 +2861,88 @@ impl AstNode for Item {\n         }\n     }\n }\n-impl From<ParenType> for Type {\n-    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n+impl From<ArrayType> for Type {\n+    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n }\n-impl From<TupleType> for Type {\n-    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n+impl From<DynTraitType> for Type {\n+    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n+}\n+impl From<FnPointerType> for Type {\n+    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n+}\n+impl From<ForType> for Type {\n+    fn from(node: ForType) -> Type { Type::ForType(node) }\n+}\n+impl From<ImplTraitType> for Type {\n+    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n+}\n+impl From<InferType> for Type {\n+    fn from(node: InferType) -> Type { Type::InferType(node) }\n }\n impl From<NeverType> for Type {\n     fn from(node: NeverType) -> Type { Type::NeverType(node) }\n }\n+impl From<ParenType> for Type {\n+    fn from(node: ParenType) -> Type { Type::ParenType(node) }\n+}\n impl From<PathType> for Type {\n     fn from(node: PathType) -> Type { Type::PathType(node) }\n }\n impl From<PointerType> for Type {\n     fn from(node: PointerType) -> Type { Type::PointerType(node) }\n }\n-impl From<ArrayType> for Type {\n-    fn from(node: ArrayType) -> Type { Type::ArrayType(node) }\n-}\n-impl From<SliceType> for Type {\n-    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n-}\n impl From<ReferenceType> for Type {\n     fn from(node: ReferenceType) -> Type { Type::ReferenceType(node) }\n }\n-impl From<InferType> for Type {\n-    fn from(node: InferType) -> Type { Type::InferType(node) }\n-}\n-impl From<FnPointerType> for Type {\n-    fn from(node: FnPointerType) -> Type { Type::FnPointerType(node) }\n-}\n-impl From<ForType> for Type {\n-    fn from(node: ForType) -> Type { Type::ForType(node) }\n-}\n-impl From<ImplTraitType> for Type {\n-    fn from(node: ImplTraitType) -> Type { Type::ImplTraitType(node) }\n+impl From<SliceType> for Type {\n+    fn from(node: SliceType) -> Type { Type::SliceType(node) }\n }\n-impl From<DynTraitType> for Type {\n-    fn from(node: DynTraitType) -> Type { Type::DynTraitType(node) }\n+impl From<TupleType> for Type {\n+    fn from(node: TupleType) -> Type { Type::TupleType(node) }\n }\n impl AstNode for Type {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            PAREN_TYPE | TUPLE_TYPE | NEVER_TYPE | PATH_TYPE | POINTER_TYPE | ARRAY_TYPE\n-            | SLICE_TYPE | REFERENCE_TYPE | INFER_TYPE | FN_POINTER_TYPE | FOR_TYPE\n-            | IMPL_TRAIT_TYPE | DYN_TRAIT_TYPE => true,\n+            ARRAY_TYPE | DYN_TRAIT_TYPE | FN_POINTER_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE\n+            | INFER_TYPE | NEVER_TYPE | PAREN_TYPE | PATH_TYPE | POINTER_TYPE | REFERENCE_TYPE\n+            | SLICE_TYPE | TUPLE_TYPE => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n-            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n-            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n-            PATH_TYPE => Type::PathType(PathType { syntax }),\n-            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n             ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),\n-            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n-            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n-            INFER_TYPE => Type::InferType(InferType { syntax }),\n+            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n             FN_POINTER_TYPE => Type::FnPointerType(FnPointerType { syntax }),\n             FOR_TYPE => Type::ForType(ForType { syntax }),\n             IMPL_TRAIT_TYPE => Type::ImplTraitType(ImplTraitType { syntax }),\n-            DYN_TRAIT_TYPE => Type::DynTraitType(DynTraitType { syntax }),\n+            INFER_TYPE => Type::InferType(InferType { syntax }),\n+            NEVER_TYPE => Type::NeverType(NeverType { syntax }),\n+            PAREN_TYPE => Type::ParenType(ParenType { syntax }),\n+            PATH_TYPE => Type::PathType(PathType { syntax }),\n+            POINTER_TYPE => Type::PointerType(PointerType { syntax }),\n+            REFERENCE_TYPE => Type::ReferenceType(ReferenceType { syntax }),\n+            SLICE_TYPE => Type::SliceType(SliceType { syntax }),\n+            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            Type::ParenType(it) => &it.syntax,\n-            Type::TupleType(it) => &it.syntax,\n-            Type::NeverType(it) => &it.syntax,\n-            Type::PathType(it) => &it.syntax,\n-            Type::PointerType(it) => &it.syntax,\n             Type::ArrayType(it) => &it.syntax,\n-            Type::SliceType(it) => &it.syntax,\n-            Type::ReferenceType(it) => &it.syntax,\n-            Type::InferType(it) => &it.syntax,\n+            Type::DynTraitType(it) => &it.syntax,\n             Type::FnPointerType(it) => &it.syntax,\n             Type::ForType(it) => &it.syntax,\n             Type::ImplTraitType(it) => &it.syntax,\n-            Type::DynTraitType(it) => &it.syntax,\n+            Type::InferType(it) => &it.syntax,\n+            Type::NeverType(it) => &it.syntax,\n+            Type::ParenType(it) => &it.syntax,\n+            Type::PathType(it) => &it.syntax,\n+            Type::PointerType(it) => &it.syntax,\n+            Type::ReferenceType(it) => &it.syntax,\n+            Type::SliceType(it) => &it.syntax,\n+            Type::TupleType(it) => &it.syntax,\n         }\n     }\n }\n@@ -3057,253 +3069,251 @@ impl AstNode for FieldList {\n         }\n     }\n }\n-impl From<TupleExpr> for Expr {\n-    fn from(node: TupleExpr) -> Expr { Expr::TupleExpr(node) }\n-}\n impl From<ArrayExpr> for Expr {\n     fn from(node: ArrayExpr) -> Expr { Expr::ArrayExpr(node) }\n }\n-impl From<ParenExpr> for Expr {\n-    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }\n+impl From<AwaitExpr> for Expr {\n+    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }\n }\n-impl From<PathExpr> for Expr {\n-    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }\n+impl From<BinExpr> for Expr {\n+    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }\n }\n-impl From<LambdaExpr> for Expr {\n-    fn from(node: LambdaExpr) -> Expr { Expr::LambdaExpr(node) }\n+impl From<BlockExpr> for Expr {\n+    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }\n }\n-impl From<IfExpr> for Expr {\n-    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }\n+impl From<BoxExpr> for Expr {\n+    fn from(node: BoxExpr) -> Expr { Expr::BoxExpr(node) }\n }\n-impl From<LoopExpr> for Expr {\n-    fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }\n+impl From<BreakExpr> for Expr {\n+    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }\n }\n-impl From<ForExpr> for Expr {\n-    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }\n+impl From<CallExpr> for Expr {\n+    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }\n }\n-impl From<WhileExpr> for Expr {\n-    fn from(node: WhileExpr) -> Expr { Expr::WhileExpr(node) }\n+impl From<CastExpr> for Expr {\n+    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n }\n impl From<ContinueExpr> for Expr {\n     fn from(node: ContinueExpr) -> Expr { Expr::ContinueExpr(node) }\n }\n-impl From<BreakExpr> for Expr {\n-    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }\n-}\n-impl From<Label> for Expr {\n-    fn from(node: Label) -> Expr { Expr::Label(node) }\n-}\n-impl From<BlockExpr> for Expr {\n-    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }\n-}\n-impl From<ReturnExpr> for Expr {\n-    fn from(node: ReturnExpr) -> Expr { Expr::ReturnExpr(node) }\n+impl From<EffectExpr> for Expr {\n+    fn from(node: EffectExpr) -> Expr { Expr::EffectExpr(node) }\n }\n-impl From<MatchExpr> for Expr {\n-    fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n+impl From<FieldExpr> for Expr {\n+    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }\n }\n-impl From<RecordExpr> for Expr {\n-    fn from(node: RecordExpr) -> Expr { Expr::RecordExpr(node) }\n+impl From<ForExpr> for Expr {\n+    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }\n }\n-impl From<CallExpr> for Expr {\n-    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }\n+impl From<IfExpr> for Expr {\n+    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }\n }\n impl From<IndexExpr> for Expr {\n     fn from(node: IndexExpr) -> Expr { Expr::IndexExpr(node) }\n }\n-impl From<MethodCallExpr> for Expr {\n-    fn from(node: MethodCallExpr) -> Expr { Expr::MethodCallExpr(node) }\n+impl From<Label> for Expr {\n+    fn from(node: Label) -> Expr { Expr::Label(node) }\n }\n-impl From<FieldExpr> for Expr {\n-    fn from(node: FieldExpr) -> Expr { Expr::FieldExpr(node) }\n+impl From<LambdaExpr> for Expr {\n+    fn from(node: LambdaExpr) -> Expr { Expr::LambdaExpr(node) }\n }\n-impl From<AwaitExpr> for Expr {\n-    fn from(node: AwaitExpr) -> Expr { Expr::AwaitExpr(node) }\n+impl From<Literal> for Expr {\n+    fn from(node: Literal) -> Expr { Expr::Literal(node) }\n }\n-impl From<TryExpr> for Expr {\n-    fn from(node: TryExpr) -> Expr { Expr::TryExpr(node) }\n+impl From<LoopExpr> for Expr {\n+    fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }\n }\n-impl From<EffectExpr> for Expr {\n-    fn from(node: EffectExpr) -> Expr { Expr::EffectExpr(node) }\n+impl From<MacroCall> for Expr {\n+    fn from(node: MacroCall) -> Expr { Expr::MacroCall(node) }\n }\n-impl From<CastExpr> for Expr {\n-    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }\n+impl From<MatchExpr> for Expr {\n+    fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n }\n-impl From<RefExpr> for Expr {\n-    fn from(node: RefExpr) -> Expr { Expr::RefExpr(node) }\n+impl From<MethodCallExpr> for Expr {\n+    fn from(node: MethodCallExpr) -> Expr { Expr::MethodCallExpr(node) }\n+}\n+impl From<ParenExpr> for Expr {\n+    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }\n+}\n+impl From<PathExpr> for Expr {\n+    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }\n }\n impl From<PrefixExpr> for Expr {\n     fn from(node: PrefixExpr) -> Expr { Expr::PrefixExpr(node) }\n }\n impl From<RangeExpr> for Expr {\n     fn from(node: RangeExpr) -> Expr { Expr::RangeExpr(node) }\n }\n-impl From<BinExpr> for Expr {\n-    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }\n+impl From<RecordExpr> for Expr {\n+    fn from(node: RecordExpr) -> Expr { Expr::RecordExpr(node) }\n }\n-impl From<Literal> for Expr {\n-    fn from(node: Literal) -> Expr { Expr::Literal(node) }\n+impl From<RefExpr> for Expr {\n+    fn from(node: RefExpr) -> Expr { Expr::RefExpr(node) }\n }\n-impl From<MacroCall> for Expr {\n-    fn from(node: MacroCall) -> Expr { Expr::MacroCall(node) }\n+impl From<ReturnExpr> for Expr {\n+    fn from(node: ReturnExpr) -> Expr { Expr::ReturnExpr(node) }\n+}\n+impl From<TryExpr> for Expr {\n+    fn from(node: TryExpr) -> Expr { Expr::TryExpr(node) }\n+}\n+impl From<TupleExpr> for Expr {\n+    fn from(node: TupleExpr) -> Expr { Expr::TupleExpr(node) }\n }\n-impl From<BoxExpr> for Expr {\n-    fn from(node: BoxExpr) -> Expr { Expr::BoxExpr(node) }\n+impl From<WhileExpr> for Expr {\n+    fn from(node: WhileExpr) -> Expr { Expr::WhileExpr(node) }\n }\n impl AstNode for Expr {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            TUPLE_EXPR | ARRAY_EXPR | PAREN_EXPR | PATH_EXPR | LAMBDA_EXPR | IF_EXPR\n-            | LOOP_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | LABEL\n-            | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | RECORD_EXPR | CALL_EXPR | INDEX_EXPR\n-            | METHOD_CALL_EXPR | FIELD_EXPR | AWAIT_EXPR | TRY_EXPR | EFFECT_EXPR | CAST_EXPR\n-            | REF_EXPR | PREFIX_EXPR | RANGE_EXPR | BIN_EXPR | LITERAL | MACRO_CALL | BOX_EXPR => {\n-                true\n-            }\n+            ARRAY_EXPR | AWAIT_EXPR | BIN_EXPR | BLOCK_EXPR | BOX_EXPR | BREAK_EXPR | CALL_EXPR\n+            | CAST_EXPR | CONTINUE_EXPR | EFFECT_EXPR | FIELD_EXPR | FOR_EXPR | IF_EXPR\n+            | INDEX_EXPR | LABEL | LAMBDA_EXPR | LITERAL | LOOP_EXPR | MACRO_CALL | MATCH_EXPR\n+            | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR | RANGE_EXPR\n+            | RECORD_EXPR | REF_EXPR | RETURN_EXPR | TRY_EXPR | TUPLE_EXPR | WHILE_EXPR => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n             ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),\n-            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n-            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),\n-            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),\n-            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),\n-            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n-            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),\n-            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n-            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),\n-            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),\n-            LABEL => Expr::Label(Label { syntax }),\n+            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n+            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),\n             BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),\n-            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),\n-            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n-            RECORD_EXPR => Expr::RecordExpr(RecordExpr { syntax }),\n+            BOX_EXPR => Expr::BoxExpr(BoxExpr { syntax }),\n+            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),\n             CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),\n+            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n+            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),\n+            EFFECT_EXPR => Expr::EffectExpr(EffectExpr { syntax }),\n+            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n+            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),\n+            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),\n             INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),\n+            LABEL => Expr::Label(Label { syntax }),\n+            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),\n+            LITERAL => Expr::Literal(Literal { syntax }),\n+            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n+            MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n+            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n             METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n-            FIELD_EXPR => Expr::FieldExpr(FieldExpr { syntax }),\n-            AWAIT_EXPR => Expr::AwaitExpr(AwaitExpr { syntax }),\n-            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n-            EFFECT_EXPR => Expr::EffectExpr(EffectExpr { syntax }),\n-            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),\n-            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n+            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n+            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),\n             PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),\n             RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),\n-            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),\n-            LITERAL => Expr::Literal(Literal { syntax }),\n-            MACRO_CALL => Expr::MacroCall(MacroCall { syntax }),\n-            BOX_EXPR => Expr::BoxExpr(BoxExpr { syntax }),\n+            RECORD_EXPR => Expr::RecordExpr(RecordExpr { syntax }),\n+            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),\n+            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),\n+            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),\n+            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n+            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            Expr::TupleExpr(it) => &it.syntax,\n             Expr::ArrayExpr(it) => &it.syntax,\n-            Expr::ParenExpr(it) => &it.syntax,\n-            Expr::PathExpr(it) => &it.syntax,\n-            Expr::LambdaExpr(it) => &it.syntax,\n-            Expr::IfExpr(it) => &it.syntax,\n-            Expr::LoopExpr(it) => &it.syntax,\n-            Expr::ForExpr(it) => &it.syntax,\n-            Expr::WhileExpr(it) => &it.syntax,\n-            Expr::ContinueExpr(it) => &it.syntax,\n-            Expr::BreakExpr(it) => &it.syntax,\n-            Expr::Label(it) => &it.syntax,\n+            Expr::AwaitExpr(it) => &it.syntax,\n+            Expr::BinExpr(it) => &it.syntax,\n             Expr::BlockExpr(it) => &it.syntax,\n-            Expr::ReturnExpr(it) => &it.syntax,\n-            Expr::MatchExpr(it) => &it.syntax,\n-            Expr::RecordExpr(it) => &it.syntax,\n+            Expr::BoxExpr(it) => &it.syntax,\n+            Expr::BreakExpr(it) => &it.syntax,\n             Expr::CallExpr(it) => &it.syntax,\n+            Expr::CastExpr(it) => &it.syntax,\n+            Expr::ContinueExpr(it) => &it.syntax,\n+            Expr::EffectExpr(it) => &it.syntax,\n+            Expr::FieldExpr(it) => &it.syntax,\n+            Expr::ForExpr(it) => &it.syntax,\n+            Expr::IfExpr(it) => &it.syntax,\n             Expr::IndexExpr(it) => &it.syntax,\n+            Expr::Label(it) => &it.syntax,\n+            Expr::LambdaExpr(it) => &it.syntax,\n+            Expr::Literal(it) => &it.syntax,\n+            Expr::LoopExpr(it) => &it.syntax,\n+            Expr::MacroCall(it) => &it.syntax,\n+            Expr::MatchExpr(it) => &it.syntax,\n             Expr::MethodCallExpr(it) => &it.syntax,\n-            Expr::FieldExpr(it) => &it.syntax,\n-            Expr::AwaitExpr(it) => &it.syntax,\n-            Expr::TryExpr(it) => &it.syntax,\n-            Expr::EffectExpr(it) => &it.syntax,\n-            Expr::CastExpr(it) => &it.syntax,\n-            Expr::RefExpr(it) => &it.syntax,\n+            Expr::ParenExpr(it) => &it.syntax,\n+            Expr::PathExpr(it) => &it.syntax,\n             Expr::PrefixExpr(it) => &it.syntax,\n             Expr::RangeExpr(it) => &it.syntax,\n-            Expr::BinExpr(it) => &it.syntax,\n-            Expr::Literal(it) => &it.syntax,\n-            Expr::MacroCall(it) => &it.syntax,\n-            Expr::BoxExpr(it) => &it.syntax,\n+            Expr::RecordExpr(it) => &it.syntax,\n+            Expr::RefExpr(it) => &it.syntax,\n+            Expr::ReturnExpr(it) => &it.syntax,\n+            Expr::TryExpr(it) => &it.syntax,\n+            Expr::TupleExpr(it) => &it.syntax,\n+            Expr::WhileExpr(it) => &it.syntax,\n         }\n     }\n }\n-impl From<Struct> for AdtDef {\n-    fn from(node: Struct) -> AdtDef { AdtDef::Struct(node) }\n-}\n impl From<Enum> for AdtDef {\n     fn from(node: Enum) -> AdtDef { AdtDef::Enum(node) }\n }\n+impl From<Struct> for AdtDef {\n+    fn from(node: Struct) -> AdtDef { AdtDef::Struct(node) }\n+}\n impl From<Union> for AdtDef {\n     fn from(node: Union) -> AdtDef { AdtDef::Union(node) }\n }\n impl AstNode for AdtDef {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            STRUCT | ENUM | UNION => true,\n+            ENUM | STRUCT | UNION => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            STRUCT => AdtDef::Struct(Struct { syntax }),\n             ENUM => AdtDef::Enum(Enum { syntax }),\n+            STRUCT => AdtDef::Struct(Struct { syntax }),\n             UNION => AdtDef::Union(Union { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            AdtDef::Struct(it) => &it.syntax,\n             AdtDef::Enum(it) => &it.syntax,\n+            AdtDef::Struct(it) => &it.syntax,\n             AdtDef::Union(it) => &it.syntax,\n         }\n     }\n }\n-impl From<Fn> for AssocItem {\n-    fn from(node: Fn) -> AssocItem { AssocItem::Fn(node) }\n-}\n-impl From<TypeAlias> for AssocItem {\n-    fn from(node: TypeAlias) -> AssocItem { AssocItem::TypeAlias(node) }\n-}\n impl From<Const> for AssocItem {\n     fn from(node: Const) -> AssocItem { AssocItem::Const(node) }\n }\n+impl From<Fn> for AssocItem {\n+    fn from(node: Fn) -> AssocItem { AssocItem::Fn(node) }\n+}\n impl From<MacroCall> for AssocItem {\n     fn from(node: MacroCall) -> AssocItem { AssocItem::MacroCall(node) }\n }\n+impl From<TypeAlias> for AssocItem {\n+    fn from(node: TypeAlias) -> AssocItem { AssocItem::TypeAlias(node) }\n+}\n impl AstNode for AssocItem {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            FN | TYPE_ALIAS | CONST | MACRO_CALL => true,\n+            CONST | FN | MACRO_CALL | TYPE_ALIAS => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n-            FN => AssocItem::Fn(Fn { syntax }),\n-            TYPE_ALIAS => AssocItem::TypeAlias(TypeAlias { syntax }),\n             CONST => AssocItem::Const(Const { syntax }),\n+            FN => AssocItem::Fn(Fn { syntax }),\n             MACRO_CALL => AssocItem::MacroCall(MacroCall { syntax }),\n+            TYPE_ALIAS => AssocItem::TypeAlias(TypeAlias { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n-            AssocItem::Fn(it) => &it.syntax,\n-            AssocItem::TypeAlias(it) => &it.syntax,\n             AssocItem::Const(it) => &it.syntax,\n+            AssocItem::Fn(it) => &it.syntax,\n             AssocItem::MacroCall(it) => &it.syntax,\n+            AssocItem::TypeAlias(it) => &it.syntax,\n         }\n     }\n }\n@@ -3340,48 +3350,48 @@ impl AstNode for ExternItem {\n         }\n     }\n }\n+impl From<ConstParam> for GenericParam {\n+    fn from(node: ConstParam) -> GenericParam { GenericParam::ConstParam(node) }\n+}\n impl From<LifetimeParam> for GenericParam {\n     fn from(node: LifetimeParam) -> GenericParam { GenericParam::LifetimeParam(node) }\n }\n impl From<TypeParam> for GenericParam {\n     fn from(node: TypeParam) -> GenericParam { GenericParam::TypeParam(node) }\n }\n-impl From<ConstParam> for GenericParam {\n-    fn from(node: ConstParam) -> GenericParam { GenericParam::ConstParam(node) }\n-}\n impl AstNode for GenericParam {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n-            LIFETIME_PARAM | TYPE_PARAM | CONST_PARAM => true,\n+            CONST_PARAM | LIFETIME_PARAM | TYPE_PARAM => true,\n             _ => false,\n         }\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n+            CONST_PARAM => GenericParam::ConstParam(ConstParam { syntax }),\n             LIFETIME_PARAM => GenericParam::LifetimeParam(LifetimeParam { syntax }),\n             TYPE_PARAM => GenericParam::TypeParam(TypeParam { syntax }),\n-            CONST_PARAM => GenericParam::ConstParam(ConstParam { syntax }),\n             _ => return None,\n         };\n         Some(res)\n     }\n     fn syntax(&self) -> &SyntaxNode {\n         match self {\n+            GenericParam::ConstParam(it) => &it.syntax,\n             GenericParam::LifetimeParam(it) => &it.syntax,\n             GenericParam::TypeParam(it) => &it.syntax,\n-            GenericParam::ConstParam(it) => &it.syntax,\n         }\n     }\n }\n-impl From<LetStmt> for Stmt {\n-    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n-}\n impl From<ExprStmt> for Stmt {\n     fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }\n }\n impl From<Item> for Stmt {\n     fn from(node: Item) -> Stmt { Stmt::Item(node) }\n }\n+impl From<LetStmt> for Stmt {\n+    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }\n+}\n impl std::fmt::Display for Item {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -3637,17 +3647,17 @@ impl std::fmt::Display for ExternItemList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LifetimeParam {\n+impl std::fmt::Display for ConstParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeParam {\n+impl std::fmt::Display for LifetimeParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ConstParam {\n+impl std::fmt::Display for TypeParam {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3667,162 +3677,162 @@ impl std::fmt::Display for TokenTree {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LetStmt {\n+impl std::fmt::Display for ExprStmt {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ExprStmt {\n+impl std::fmt::Display for LetStmt {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParenType {\n+impl std::fmt::Display for ArrayExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleType {\n+impl std::fmt::Display for AwaitExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for NeverType {\n+impl std::fmt::Display for BinExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathType {\n+impl std::fmt::Display for BoxExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PointerType {\n+impl std::fmt::Display for BreakExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ArrayType {\n+impl std::fmt::Display for CallExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for SliceType {\n+impl std::fmt::Display for CastExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ReferenceType {\n+impl std::fmt::Display for ContinueExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for InferType {\n+impl std::fmt::Display for EffectExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for FnPointerType {\n+impl std::fmt::Display for FieldExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ForType {\n+impl std::fmt::Display for ForExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ImplTraitType {\n+impl std::fmt::Display for IfExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for DynTraitType {\n+impl std::fmt::Display for IndexExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeBound {\n+impl std::fmt::Display for Label {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TupleExpr {\n+impl std::fmt::Display for LambdaExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ArrayExpr {\n+impl std::fmt::Display for LoopExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ParenExpr {\n+impl std::fmt::Display for MatchExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PathExpr {\n+impl std::fmt::Display for MethodCallExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LambdaExpr {\n+impl std::fmt::Display for ParenExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for IfExpr {\n+impl std::fmt::Display for PathExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Condition {\n+impl std::fmt::Display for PrefixExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for EffectExpr {\n+impl std::fmt::Display for RangeExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Label {\n+impl std::fmt::Display for RecordExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for LoopExpr {\n+impl std::fmt::Display for RefExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ForExpr {\n+impl std::fmt::Display for ReturnExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for WhileExpr {\n+impl std::fmt::Display for TryExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ContinueExpr {\n+impl std::fmt::Display for TupleExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BreakExpr {\n+impl std::fmt::Display for WhileExpr {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for ReturnExpr {\n+impl std::fmt::Display for RecordExprFieldList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for CallExpr {\n+impl std::fmt::Display for RecordExprField {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n@@ -3832,97 +3842,97 @@ impl std::fmt::Display for ArgList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MethodCallExpr {\n+impl std::fmt::Display for TypeArgList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TypeArgList {\n+impl std::fmt::Display for Condition {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for FieldExpr {\n+impl std::fmt::Display for MatchArmList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for IndexExpr {\n+impl std::fmt::Display for MatchArm {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for AwaitExpr {\n+impl std::fmt::Display for MatchGuard {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for TryExpr {\n+impl std::fmt::Display for ArrayType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for CastExpr {\n+impl std::fmt::Display for DynTraitType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RefExpr {\n+impl std::fmt::Display for FnPointerType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for PrefixExpr {\n+impl std::fmt::Display for ForType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BoxExpr {\n+impl std::fmt::Display for ImplTraitType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RangeExpr {\n+impl std::fmt::Display for InferType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for BinExpr {\n+impl std::fmt::Display for NeverType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchExpr {\n+impl std::fmt::Display for ParenType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchArmList {\n+impl std::fmt::Display for PathType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchArm {\n+impl std::fmt::Display for PointerType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for MatchGuard {\n+impl std::fmt::Display for ReferenceType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordExpr {\n+impl std::fmt::Display for SliceType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordExprFieldList {\n+impl std::fmt::Display for TupleType {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for RecordExprField {\n+impl std::fmt::Display for TypeBound {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }"}, {"sha": "90f746e96ea0af4d23109f1788e533f9d2f8d2db", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "patch": "@@ -579,6 +579,9 @@ fn lower_rule(acc: &mut Vec<Field>, grammar: &Grammar, label: Option<&String>, r\n         }\n         Rule::Labeled { label: l, rule } => {\n             assert!(label.is_none());\n+            if l == \"op\" {\n+                return;\n+            }\n             lower_rule(acc, grammar, Some(l), rule);\n         }\n         Rule::Seq(rules) | Rule::Alt(rules) => {"}, {"sha": "93195befea6338d7c07632c56197184cbcd41a08", "filename": "xtask/src/codegen/rust.ungram", "status": "modified", "additions": 173, "deletions": 157, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/bfcee63e75d6feb21cafbdf3887e0efd508b6b2e/xtask%2Fsrc%2Fcodegen%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Frust.ungram?ref=bfcee63e75d6feb21cafbdf3887e0efd508b6b2e", "patch": "@@ -115,8 +115,8 @@ Union =\n   RecordFieldList\n \n AdtDef =\n-  Struct\n-| Enum\n+  Enum\n+| Struct\n | Union\n \n Const =\n@@ -136,10 +136,10 @@ AssocItemList =\n   '{' Attr* AssocItem* '}'\n \n AssocItem =\n-  Fn\n-| TypeAlias\n-| Const\n+  Const\n+| Fn\n | MacroCall\n+| TypeAlias\n \n Impl =\n  Attr* Visibility?\n@@ -162,9 +162,9 @@ GenericParamList =\n   '<' (GenericParam (',' GenericParam)* ','?)? '>'\n \n GenericParam =\n-  LifetimeParam\n+  ConstParam\n+| LifetimeParam\n | TypeParam\n-| ConstParam\n \n TypeParam =\n   Attr* Name (':' TypeBoundList?)?\n@@ -195,9 +195,9 @@ Attr =\n   '#' '!'? '[' Path ('=' Literal | TokenTree)? ']'\n \n Stmt =\n-  LetStmt\n-| ExprStmt\n+  ExprStmt\n | Item\n+| LetStmt\n \n LetStmt =\n   Attr* 'let' Pat (':' Type)?\n@@ -206,189 +206,238 @@ LetStmt =\n ExprStmt =\n   Attr* Expr ';'?\n \n-Type =\n-  ParenType\n-| TupleType\n-| NeverType\n-| PathType\n-| PointerType\n-| ArrayType\n-| SliceType\n-| ReferenceType\n-| InferType\n-| FnPointerType\n-| ForType\n-| ImplTraitType\n-| DynTraitType\n+Expr =\n+  ArrayExpr\n+| AwaitExpr\n+| BinExpr\n+| BlockExpr\n+| BoxExpr\n+| BreakExpr\n+| CallExpr\n+| CastExpr\n+| ContinueExpr\n+| EffectExpr\n+| FieldExpr\n+| ForExpr\n+| IfExpr\n+| IndexExpr\n+| Label\n+| LambdaExpr\n+| Literal\n+| LoopExpr\n+| MacroCall\n+| MatchExpr\n+| MethodCallExpr\n+| ParenExpr\n+| PathExpr\n+| PrefixExpr\n+| RangeExpr\n+| RecordExpr\n+| RefExpr\n+| ReturnExpr\n+| TryExpr\n+| TupleExpr\n+| WhileExpr\n \n-ParenType =\n-  '(' Type ')'\n+Literal =\n+  Attr* 'int_number'\n \n-NeverType =\n-  '!'\n+PathExpr =\n+  Attr* Path\n \n-PathType =\n-  Path\n+BlockExpr =\n+  '{'\n+    Attr*\n+    statements:Stmt*\n+    Expr?\n+  '}'\n \n-TupleType =\n-  '(' fields:(Type (',' Type)* ','?)? ')'\n+RefExpr =\n+  Attr* '&' ('raw' |'mut' | 'const') Expr\n \n-PointerType =\n-  '*' ('const' | 'mut') Type\n+TryExpr =\n+  Attr* Expr '?'\n \n-ReferenceType =\n-  '&' 'lifetime'? 'mut'? Type\n+EffectExpr =\n+  Attr* Label? ('try' | 'unsafe' | 'async') BlockExpr\n \n-ArrayType =\n-  '[' Type ';' Expr ']'\n+PrefixExpr =\n+  Attr* op:('-' | '!' | '*') Expr\n \n-SliceType =\n-  '[' Type ']'\n+BinExpr =\n+  Attr*\n+  Expr\n+  op:(\n+    '||' | '&&'\n+    | '==' | '!=' | '<=' | '>=' | '<' | '>'\n+    | '+' | '*' | '-' | '/' | '%' | '<<' | '>>' | '^' | '|' | '&'\n+    | '=' | '+=' | '/=' | '*=' | '%=' | '>>=' | '<<=' | '-=' | '|=' | '&=' | '^='\n+  )\n+  Expr\n \n-InferType =\n-   '_'\n+CastExpr =\n+  Attr* Expr 'as' Type\n \n-FnPointerType =\n-   'const'? 'async'? 'unsafe'? Abi? 'fn' ParamList RetType?\n+ParenExpr =\n+  Attr* '(' Attr* Expr ')'\n \n-ForType =\n-   'for' GenericParamList Type\n+ArrayExpr =\n+  Attr* '[' Attr* (\n+    (Expr (',' Expr)* ','?)?\n+  | Expr ';' Expr\n+  ) ']'\n \n-ImplTraitType =\n-  'impl' TypeBoundList\n+IndexExpr =\n+  Attr* Expr '[' Expr ']'\n \n-DynTraitType =\n-  'dyn' TypeBoundList\n+TupleExpr =\n+  Attr* '(' Attr* (Expr (',' Expr)* ','?)? ')'\n \n-TypeBoundList =\n-   bounds:(TypeBound ('+' TypeBound)* '+'?)\n+RecordExpr =\n+  Path RecordExprFieldList\n \n-TypeBound =\n-  'lifetime'\n-| '?'? Type\n+RecordExprFieldList =\n+  '{'\n+    Attr*\n+    fields:(RecordExprField (',' RecordExprField)* ','?)\n+    ('..' spread:Expr)?\n+  '}'\n \n-TupleExpr =\n-  Attr* '(' Expr* ')'\n+RecordExprField =\n+  Attr* NameRef (':' Expr)?\n \n-ArrayExpr =\n-  Attr* '[' (Expr* | Expr ';' Expr) ']'\n+CallExpr =\n+  Attr* Expr ArgList\n \n-ParenExpr =\n-  Attr* '(' Expr ')'\n+ArgList =\n+  '(' args:(Expr (',' Expr)* ','?)? ')'\n \n-PathExpr =\n-  Path\n+MethodCallExpr =\n+  Attr* Expr '.' NameRef TypeArgList? ArgList\n+\n+FieldExpr =\n+  Attr* Expr '.' NameRef\n \n LambdaExpr =\n   Attr* 'static'? 'async'? 'move'?  ParamList RetType?\n   body:Expr\n \n IfExpr =\n-  Attr* 'if' Condition\n+  Attr* 'if' Condition BlockExpr\n+  ('else' (IfExpr | BlockExpr))?\n \n Condition =\n   'let' Pat '=' Expr\n | Expr\n \n-EffectExpr =\n-  Attr* Label? ('try' | 'unsafe' | 'async') BlockExpr\n-\n LoopExpr =\n   Attr* Label? 'loop'\n-  loop_body:BlockExpr?\n+  loop_body:BlockExpr\n \n ForExpr =\n   Attr* Label? 'for' Pat 'in' iterable:Expr\n-  loop_body:BlockExpr?\n+  loop_body:BlockExpr\n \n WhileExpr =\n   Attr* Label? 'while' Condition\n   loop_body:BlockExpr?\n \n-ContinueExpr =\n-  Attr* 'continue' 'lifetime'?\n+Label =\n+  'lifetime'\n \n BreakExpr =\n   Attr* 'break' 'lifetime'? Expr?\n \n-Label =\n-  'lifetime'\n-\n-BlockExpr =\n-  Attr* Label\n-  '{'\n-    statements:Stmt*\n-    Expr?\n-  '}'\n+ContinueExpr =\n+  Attr* 'continue' 'lifetime'?\n \n-ReturnExpr =\n-  Attr* 'return' Expr\n+RangeExpr =\n+  Attr* Expr? op:('..' | '..=') Expr?\n \n-CallExpr =\n-  Attr* Expr ArgList\n+MatchExpr =\n+  Attr* 'match' Expr MatchArmList\n \n-MethodCallExpr =\n-  Attr* Expr '.' NameRef TypeArgList? ArgList\n+MatchArmList =\n+  '{'\n+    Attr*\n+    arms:MatchArm*\n+  '}'\n \n-ArgList =\n-  '(' args:Expr* ')'\n+MatchArm =\n+  Attr* Pat guard:MatchGuard? '=>' Expr ','?\n \n-FieldExpr =\n-  Attr* Expr '.' NameRef\n+MatchGuard =\n+  'if' Expr\n \n-IndexExpr =\n-  Attr* '[' ']'\n+ReturnExpr =\n+  Attr* 'return' Expr?\n \n AwaitExpr =\n   Attr* Expr '.' 'await'\n \n-TryExpr =\n-  Attr* Expr '?'\n+BoxExpr =\n+  Attr* 'box' Expr\n \n-CastExpr =\n-  Attr* Expr 'as' Type\n+Type =\n+  ArrayType\n+| DynTraitType\n+| FnPointerType\n+| ForType\n+| ImplTraitType\n+| InferType\n+| NeverType\n+| ParenType\n+| PathType\n+| PointerType\n+| ReferenceType\n+| SliceType\n+| TupleType\n \n-RefExpr =\n-  Attr* '&' ('raw' | 'mut' | 'const') Expr\n+ParenType =\n+  '(' Type ')'\n \n-PrefixExpr =\n-  Attr* Expr\n+NeverType =\n+  '!'\n \n-BoxExpr =\n-  Attr* 'box' Expr\n+PathType =\n+  Path\n \n-RangeExpr =\n-  Attr*\n+TupleType =\n+  '(' fields:(Type (',' Type)* ','?)? ')'\n \n-BinExpr =\n-  Attr*\n+PointerType =\n+  '*' ('const' | 'mut') Type\n \n-Literal =\n-  'int_number'\n+ReferenceType =\n+  '&' 'lifetime'? 'mut'? Type\n \n-MatchExpr =\n-  Attr* 'match' Expr MatchArmList\n+ArrayType =\n+  '[' Type ';' Expr ']'\n \n-MatchArmList =\n-  '{' arms:MatchArm* '}'\n+SliceType =\n+  '[' Type ']'\n \n-MatchArm =\n-  Attr* Pat guard:MatchGuard? '=>' Expr\n+InferType =\n+   '_'\n \n-MatchGuard =\n-  'if' Expr\n+FnPointerType =\n+   'const'? 'async'? 'unsafe'? Abi? 'fn' ParamList RetType?\n \n-RecordExpr =\n- Path RecordExprFieldList\n+ForType =\n+   'for' GenericParamList Type\n \n-RecordExprFieldList =\n-  '{'\n-    fields:RecordExprField*\n-    ('..' spread:Expr)?\n-  '}'\n+ImplTraitType =\n+  'impl' TypeBoundList\n \n-RecordExprField =\n-  Attr* NameRef (':' Expr)?\n+DynTraitType =\n+  'dyn' TypeBoundList\n+\n+TypeBoundList =\n+   bounds:(TypeBound ('+' TypeBound)* '+'?)\n+\n+TypeBound =\n+  'lifetime'\n+| '?'? Type\n \n OrPat =\n   Pat*\n@@ -510,36 +559,3 @@ Pat =\n | RangePat\n | LiteralPat\n | MacroPat\n-\n-Expr =\n-  TupleExpr\n-| ArrayExpr\n-| ParenExpr\n-| PathExpr\n-| LambdaExpr\n-| IfExpr\n-| LoopExpr\n-| ForExpr\n-| WhileExpr\n-| ContinueExpr\n-| BreakExpr\n-| Label\n-| BlockExpr\n-| ReturnExpr\n-| MatchExpr\n-| RecordExpr\n-| CallExpr\n-| IndexExpr\n-| MethodCallExpr\n-| FieldExpr\n-| AwaitExpr\n-| TryExpr\n-| EffectExpr\n-| CastExpr\n-| RefExpr\n-| PrefixExpr\n-| RangeExpr\n-| BinExpr\n-| Literal\n-| MacroCall\n-| BoxExpr"}]}