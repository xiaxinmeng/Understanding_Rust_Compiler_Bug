{"sha": "68f327bcc112ffb4261980c04e58d333b5d97b6e", "node_id": "C_kwDOAAsO6NoAKDY4ZjMyN2JjYzExMmZmYjQyNjE5ODBjMDRlNThkMzMzYjVkOTdiNmU", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-11T21:03:45Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-14T09:30:52Z"}, "message": "Merge HTML elements in highlighting when they can be merged together", "tree": {"sha": "b8703d7a311f8689ecd5cc466216dd1903dbe936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8703d7a311f8689ecd5cc466216dd1903dbe936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68f327bcc112ffb4261980c04e58d333b5d97b6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68f327bcc112ffb4261980c04e58d333b5d97b6e", "html_url": "https://github.com/rust-lang/rust/commit/68f327bcc112ffb4261980c04e58d333b5d97b6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68f327bcc112ffb4261980c04e58d333b5d97b6e/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fbc08e2ce64dee45a29cb6133da6b32366268aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbc08e2ce64dee45a29cb6133da6b32366268aa", "html_url": "https://github.com/rust-lang/rust/commit/2fbc08e2ce64dee45a29cb6133da6b32366268aa"}], "stats": {"total": 163, "additions": 155, "deletions": 8}, "files": [{"sha": "517f441e6479873b2aa869ab175bff2c98179b0e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 155, "deletions": 8, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/68f327bcc112ffb4261980c04e58d333b5d97b6e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68f327bcc112ffb4261980c04e58d333b5d97b6e/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=68f327bcc112ffb4261980c04e58d333b5d97b6e", "patch": "@@ -111,6 +111,69 @@ fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>) {\n     write!(out, \"<code>\");\n }\n \n+/// Write all the pending elements sharing a same (or at mergeable) `Class`.\n+///\n+/// If there is a \"parent\" (if a `EnterSpan` event was encountered) and the parent can be merged\n+/// with the elements' class, then we simply write the elements since the `ExitSpan` event will\n+/// close the tag.\n+///\n+/// Otherwise, if there is only one pending element, we let the `string` function handle both\n+/// opening and closing the tag, otherwise we do it into this function.\n+fn write_pending_elems(\n+    out: &mut Buffer,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    pending_elems: &mut Vec<(&str, Option<Class>)>,\n+    current_class: &mut Option<Class>,\n+    closing_tags: &[(&str, Class)],\n+) {\n+    if pending_elems.is_empty() {\n+        return;\n+    }\n+    let mut done = false;\n+    if let Some((_, parent_class)) = closing_tags.last() {\n+        if can_merge(*current_class, Some(*parent_class), \"\") {\n+            for (text, class) in pending_elems.iter() {\n+                string(out, Escape(text), *class, &href_context, false);\n+            }\n+            done = true;\n+        }\n+    }\n+    if !done {\n+        // We only want to \"open\" the tag ourselves if we have more than one pending and if the current\n+        // parent tag is not the same as our pending content.\n+        let open_tag_ourselves = pending_elems.len() > 1;\n+        let close_tag = if open_tag_ourselves {\n+            enter_span(out, current_class.unwrap(), &href_context)\n+        } else {\n+            \"\"\n+        };\n+        for (text, class) in pending_elems.iter() {\n+            string(out, Escape(text), *class, &href_context, !open_tag_ourselves);\n+        }\n+        if open_tag_ourselves {\n+            exit_span(out, close_tag);\n+        }\n+    }\n+    pending_elems.clear();\n+    *current_class = None;\n+}\n+\n+/// Check if two `Class` can be merged together. In the following rules, \"unclassified\" means `None`\n+/// basically (since it's `Option<Class>`). The following rules apply:\n+///\n+/// * If two `Class` have the same variant, then they can be merged.\n+/// * If the other `Class` is unclassified and only contains white characters (backline,\n+///   whitespace, etc), it can be merged.\n+/// * If `Class` is `Ident`, then it can be merged with all unclassified elements.\n+fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n+    match (class1, class2) {\n+        (Some(c1), Some(c2)) => c1.is_equal_to(c2),\n+        (Some(Class::Ident(_)), None) | (None, Some(Class::Ident(_))) => true,\n+        (Some(_), None) | (None, Some(_)) => text.trim().is_empty(),\n+        _ => false,\n+    }\n+}\n+\n /// Convert the given `src` source code into HTML by adding classes for highlighting.\n ///\n /// This code is used to render code blocks (in the documentation) as well as the source code pages.\n@@ -130,23 +193,64 @@ fn write_code(\n ) {\n     // This replace allows to fix how the code source with DOS backline characters is displayed.\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n-    let mut closing_tags: Vec<&'static str> = Vec::new();\n+    // It contains the closing tag and the associated `Class`.\n+    let mut closing_tags: Vec<(&'static str, Class)> = Vec::new();\n+    // The following two variables are used to group HTML elements with same `class` attributes\n+    // to reduce the DOM size.\n+    let mut current_class: Option<Class> = None;\n+    // We need to keep the `Class` for each element because it could contain a `Span` which is\n+    // used to generate links.\n+    let mut pending_elems: Vec<(&str, Option<Class>)> = Vec::new();\n+\n     Classifier::new(\n         &src,\n         href_context.as_ref().map(|c| c.file_span).unwrap_or(DUMMY_SP),\n         decoration_info,\n     )\n     .highlight(&mut |highlight| {\n         match highlight {\n-            Highlight::Token { text, class } => string(out, Escape(text), class, &href_context),\n+            Highlight::Token { text, class } => {\n+                // If the two `Class` are different, time to flush the current content and start\n+                // a new one.\n+                if !can_merge(current_class, class, text) {\n+                    write_pending_elems(\n+                        out,\n+                        &href_context,\n+                        &mut pending_elems,\n+                        &mut current_class,\n+                        &closing_tags,\n+                    );\n+                    current_class = class.map(Class::dummy);\n+                } else if current_class.is_none() {\n+                    current_class = class.map(Class::dummy);\n+                }\n+                pending_elems.push((text, class));\n+            }\n             Highlight::EnterSpan { class } => {\n-                closing_tags.push(enter_span(out, class, &href_context))\n+                // We flush everything just in case...\n+                write_pending_elems(\n+                    out,\n+                    &href_context,\n+                    &mut pending_elems,\n+                    &mut current_class,\n+                    &closing_tags,\n+                );\n+                closing_tags.push((enter_span(out, class, &href_context), class))\n             }\n             Highlight::ExitSpan => {\n-                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\"))\n+                // We flush everything just in case...\n+                write_pending_elems(\n+                    out,\n+                    &href_context,\n+                    &mut pending_elems,\n+                    &mut current_class,\n+                    &closing_tags,\n+                );\n+                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0)\n             }\n         };\n     });\n+    write_pending_elems(out, &href_context, &mut pending_elems, &mut current_class, &closing_tags);\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n@@ -177,6 +281,31 @@ enum Class {\n }\n \n impl Class {\n+    /// It is only looking at the variant, not the variant content.\n+    ///\n+    /// It is used mostly to group multiple similar HTML elements into one `<span>` instead of\n+    /// multiple ones.\n+    fn is_equal_to(self, other: Self) -> bool {\n+        match (self, other) {\n+            (Self::Self_(_), Self::Self_(_))\n+            | (Self::Macro(_), Self::Macro(_))\n+            | (Self::Ident(_), Self::Ident(_))\n+            | (Self::Decoration(_), Self::Decoration(_)) => true,\n+            (x, y) => x == y,\n+        }\n+    }\n+\n+    /// If `self` contains a `Span`, it'll be replaced with `DUMMY_SP` to prevent creating links\n+    /// on \"empty content\" (because of the attributes merge).\n+    fn dummy(self) -> Self {\n+        match self {\n+            Self::Self_(_) => Self::Self_(DUMMY_SP),\n+            Self::Macro(_) => Self::Macro(DUMMY_SP),\n+            Self::Ident(_) => Self::Ident(DUMMY_SP),\n+            s => s,\n+        }\n+    }\n+\n     /// Returns the css class expected by rustdoc for each `Class`.\n     fn as_html(self) -> &'static str {\n         match self {\n@@ -630,7 +759,7 @@ impl<'a> Classifier<'a> {\n             TokenKind::CloseBracket => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    sink(Highlight::Token { text: \"]\", class: None });\n+                    sink(Highlight::Token { text: \"]\", class: Some(Class::Attribute) });\n                     sink(Highlight::ExitSpan);\n                     return;\n                 }\n@@ -701,7 +830,7 @@ fn enter_span(\n     klass: Class,\n     href_context: &Option<HrefContext<'_, '_, '_>>,\n ) -> &'static str {\n-    string_without_closing_tag(out, \"\", Some(klass), href_context).expect(\n+    string_without_closing_tag(out, \"\", Some(klass), href_context, true).expect(\n         \"internal error: enter_span was called with Some(klass) but did not return a \\\n             closing HTML tag\",\n     )\n@@ -733,8 +862,10 @@ fn string<T: Display>(\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_, '_>>,\n+    open_tag: bool,\n ) {\n-    if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context) {\n+    if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n+    {\n         out.write_str(closing_tag);\n     }\n }\n@@ -753,6 +884,7 @@ fn string_without_closing_tag<T: Display>(\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_, '_>>,\n+    open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n     else {\n@@ -761,6 +893,10 @@ fn string_without_closing_tag<T: Display>(\n     };\n     let Some(def_span) = klass.get_span()\n     else {\n+        if !open_tag {\n+            write!(out, \"{}\", text);\n+            return None;\n+        }\n         write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n         return Some(\"</span>\");\n     };\n@@ -784,6 +920,7 @@ fn string_without_closing_tag<T: Display>(\n             path\n         });\n     }\n+    // We don't want to generate links on empty text.\n     if let Some(href_context) = href_context {\n         if let Some(href) =\n             href_context.context.shared.span_correspondance_map.get(&def_span).and_then(|href| {\n@@ -812,10 +949,20 @@ fn string_without_closing_tag<T: Display>(\n                 }\n             })\n         {\n-            write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass.as_html(), href, text_s);\n+            if !open_tag {\n+                // We're already inside an element which has the same klass, no need to give it\n+                // again.\n+                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+            } else {\n+                write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass.as_html(), href, text_s);\n+            }\n             return Some(\"</a>\");\n         }\n     }\n+    if !open_tag {\n+        write!(out, \"{}\", text_s);\n+        return None;\n+    }\n     write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text_s);\n     Some(\"</span>\")\n }"}]}