{"sha": "e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NzYyMGFmYzRhNWIyMjk2MGE1ZjFiMDU2Y2JjNGI4NzhiZWIyZTg=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-07-06T01:06:06Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2019-08-12T22:03:44Z"}, "message": "Reduce the genericity of closures in the iterator traits\n\nBy default, closures inherit the generic parameters of their scope,\nincluding `Self`. However, in most cases, the closures used to implement\niterators don't need to be generic on the iterator type, only its `Item`\ntype. We can reduce this genericity by redirecting such closures through\nlocal functions.\n\nThis does make the closures more cumbersome to write, but it will\nhopefully reduce duplication in their monomorphizations, as well as\ntheir related type lengths.", "tree": {"sha": "a02ebb807188b0cdd044eb2ddd1964fd92d73396", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a02ebb807188b0cdd044eb2ddd1964fd92d73396"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "html_url": "https://github.com/rust-lang/rust/commit/e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60960a260f7b5c695fd0717311d72ce62dd4eb43", "url": "https://api.github.com/repos/rust-lang/rust/commits/60960a260f7b5c695fd0717311d72ce62dd4eb43", "html_url": "https://github.com/rust-lang/rust/commit/60960a260f7b5c695fd0717311d72ce62dd4eb43"}], "stats": {"total": 274, "additions": 194, "deletions": 80}, "files": [{"sha": "818f03303298f7b250d50486ca144b629f0a9954", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "patch": "@@ -85,28 +85,28 @@ macro_rules! float_sum_product {\n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Sum for $a {\n             fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl Product for $a {\n             fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Sum<&'a $a> for $a {\n             fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + *b)\n+                iter.fold(0.0, Add::add)\n             }\n         }\n \n         #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n         impl<'a> Product<&'a $a> for $a {\n             fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * *b)\n+                iter.fold(1.0, Mul::mul)\n             }\n         }\n     )*)"}, {"sha": "8e5bc9b664cf0d705949c6df99a0336b921b4aea", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "patch": "@@ -219,12 +219,17 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    fn rfold<B, F>(mut self, accum: B, f: F) -> B\n     where\n         Self: Sized,\n         F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(accum, ok(f)).unwrap()\n     }\n \n     /// Searches for an element of an iterator from the back that satisfies a predicate.\n@@ -271,15 +276,21 @@ pub trait DoubleEndedIterator: Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n     where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool\n     {\n-        self.try_rfold((), move |(), x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(&T) -> bool,\n+        ) -> impl FnMut((), T) -> LoopState<(), T> {\n+            move |(), x| {\n+                if predicate(&x) { LoopState::Break(x) } else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_rfold((), check(predicate)).break_value()\n     }\n }\n "}, {"sha": "9028103cb97170ecf7ae420f635091567ea04a93", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 172, "deletions": 69, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e67620afc4a5b22960a5f1b056cbc4b878beb2e8/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=e67620afc4a5b22960a5f1b056cbc4b878beb2e8", "patch": "@@ -234,11 +234,16 @@ pub trait Iterator {\n     /// assert_eq!(a.iter().count(), 5);\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize where Self: Sized {\n         // Might overflow.\n-        self.fold(0, |cnt, _| cnt + 1)\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        fn add1<T>(count: usize, _: T) -> usize {\n+            count + 1\n+        }\n+\n+        self.fold(0, add1)\n     }\n \n     /// Consumes the iterator, returning the last element.\n@@ -596,10 +601,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_for_each\", since = \"1.21.0\")]\n-    fn for_each<F>(self, mut f: F) where\n+    fn for_each<F>(self, f: F) where\n         Self: Sized, F: FnMut(Self::Item),\n     {\n-        self.fold((), move |(), item| f(item));\n+        #[inline]\n+        fn call<T>(mut f: impl FnMut(T)) -> impl FnMut((), T) {\n+            move |(), item| f(item)\n+        }\n+\n+        self.fold((), call(f));\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element\n@@ -1490,21 +1500,30 @@ pub trait Iterator {\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn partition<B, F>(self, mut f: F) -> (B, B) where\n+    fn partition<B, F>(self, f: F) -> (B, B) where\n         Self: Sized,\n         B: Default + Extend<Self::Item>,\n         F: FnMut(&Self::Item) -> bool\n     {\n+        #[inline]\n+        fn extend<'a, T, B: Extend<T>>(\n+            mut f: impl FnMut(&T) -> bool + 'a,\n+            left: &'a mut B,\n+            right: &'a mut B,\n+        ) -> impl FnMut(T) + 'a {\n+            move |x| {\n+                if f(&x) {\n+                    left.extend(Some(x));\n+                } else {\n+                    right.extend(Some(x));\n+                }\n+            }\n+        }\n+\n         let mut left: B = Default::default();\n         let mut right: B = Default::default();\n \n-        self.for_each(|x| {\n-            if f(&x) {\n-                left.extend(Some(x))\n-            } else {\n-                right.extend(Some(x))\n-            }\n-        });\n+        self.for_each(extend(f, &mut left, &mut right));\n \n         (left, right)\n     }\n@@ -1702,10 +1721,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_for_each<F, R>(&mut self, mut f: F) -> R where\n+    fn try_for_each<F, R>(&mut self, f: F) -> R where\n         Self: Sized, F: FnMut(Self::Item) -> R, R: Try<Ok=()>\n     {\n-        self.try_fold((), move |(), x| f(x))\n+        #[inline]\n+        fn call<T, R>(mut f: impl FnMut(T) -> R) -> impl FnMut((), T) -> R {\n+            move |(), x| f(x)\n+        }\n+\n+        self.try_fold((), call(f))\n     }\n \n     /// An iterator method that applies a function, producing a single, final value.\n@@ -1777,10 +1801,15 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n+    fn fold<B, F>(mut self, init: B, f: F) -> B where\n         Self: Sized, F: FnMut(B, Self::Item) -> B,\n     {\n-        self.try_fold(init, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(f)).unwrap()\n     }\n \n     /// Tests if every element of the iterator matches a predicate.\n@@ -1822,13 +1851,18 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn all<F>(&mut self, mut f: F) -> bool where\n+    fn all<F>(&mut self, f: F) -> bool where\n         Self: Sized, F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Continue(()) }\n-            else { LoopState::Break(()) }\n-        }) == LoopState::Continue(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Continue(()) }\n+                else { LoopState::Break(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Continue(())\n     }\n \n     /// Tests if any element of the iterator matches a predicate.\n@@ -1870,14 +1904,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn any<F>(&mut self, mut f: F) -> bool where\n+    fn any<F>(&mut self, f: F) -> bool where\n         Self: Sized,\n         F: FnMut(Self::Item) -> bool\n     {\n-        self.try_for_each(move |x| {\n-            if f(x) { LoopState::Break(()) }\n-            else { LoopState::Continue(()) }\n-        }) == LoopState::Break(())\n+        #[inline]\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut(T) -> LoopState<(), ()> {\n+            move |x| {\n+                if f(x) { LoopState::Break(()) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(f)) == LoopState::Break(())\n     }\n \n     /// Searches for an element of an iterator that satisfies a predicate.\n@@ -1924,14 +1963,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item> where\n         Self: Sized,\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        self.try_for_each(move |x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n+        #[inline]\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> LoopState<(), T> {\n+            move |x| {\n+                if predicate(&x) { LoopState::Break(x) }\n+                else { LoopState::Continue(()) }\n+            }\n+        }\n+\n+        self.try_for_each(check(predicate)).break_value()\n     }\n \n     /// Applies function to the elements of iterator and returns\n@@ -1951,16 +1995,19 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iterator_find_map\", since = \"1.30.0\")]\n-    fn find_map<B, F>(&mut self, mut f: F) -> Option<B> where\n+    fn find_map<B, F>(&mut self, f: F) -> Option<B> where\n         Self: Sized,\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n-        self.try_for_each(move |x| {\n-            match f(x) {\n+        #[inline]\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut(T) -> LoopState<(), B> {\n+            move |x| match f(x) {\n                 Some(x) => LoopState::Break(x),\n                 None => LoopState::Continue(()),\n             }\n-        }).break_value()\n+        }\n+\n+        self.try_for_each(check(f)).break_value()\n     }\n \n     /// Searches for an element in an iterator, returning its index.\n@@ -2018,17 +2065,24 @@ pub trait Iterator {\n     ///\n     /// ```\n     #[inline]\n-    #[rustc_inherit_overflow_checks]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn position<P>(&mut self, predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n         // The addition might panic on overflow\n-        self.try_fold(0, move |i, x| {\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i + 1) }\n-        }).break_value()\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            move |i, x| {\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(i + 1) }\n+            }\n+        }\n+\n+        self.try_fold(0, check(predicate)).break_value()\n     }\n \n     /// Searches for an element in an iterator from the right, returning its\n@@ -2071,18 +2125,25 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n         P: FnMut(Self::Item) -> bool,\n         Self: Sized + ExactSizeIterator + DoubleEndedIterator\n     {\n         // No need for an overflow check here, because `ExactSizeIterator`\n         // implies that the number of elements fits into a `usize`.\n+        #[inline]\n+        fn check<T>(\n+            mut predicate: impl FnMut(T) -> bool,\n+        ) -> impl FnMut(usize, T) -> LoopState<usize, usize> {\n+            move |i, x| {\n+                let i = i - 1;\n+                if predicate(x) { LoopState::Break(i) }\n+                else { LoopState::Continue(i) }\n+            }\n+        }\n+\n         let n = self.len();\n-        self.try_rfold(n, move |i, x| {\n-            let i = i - 1;\n-            if predicate(x) { LoopState::Break(i) }\n-            else { LoopState::Continue(i) }\n-        }).break_value()\n+        self.try_rfold(n, check(predicate)).break_value()\n     }\n \n     /// Returns the maximum element of an iterator.\n@@ -2151,11 +2212,22 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p <= y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2174,11 +2246,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_max_by\", since = \"1.15.0\")]\n-    fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn max_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // switch to y even if it is only equal, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) != Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2195,12 +2272,24 @@ pub trait Iterator {\n     /// let a = [-3_i32, 0, 1, 5, -10];\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n+    #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n+        #[inline]\n+        fn key<T, B>(mut f: impl FnMut(&T) -> B) -> impl FnMut(T) -> (B, T) {\n+            move |x| (f(&x), x)\n+        }\n+\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n+        #[inline]\n+        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n+            x_p > y_p\n+        }\n+\n+        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        Some(x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2219,11 +2308,16 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_min_by\", since = \"1.15.0\")]\n-    fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n+    fn min_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n         // only switch to y if it is strictly smaller, to preserve stability.\n-        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n+        #[inline]\n+        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n+            move |x, y| compare(x, y) == Ordering::Greater\n+        }\n+\n+        select_fold1(self, select(compare))\n     }\n \n \n@@ -2284,13 +2378,20 @@ pub trait Iterator {\n         FromB: Default + Extend<B>,\n         Self: Sized + Iterator<Item=(A, B)>,\n     {\n+        fn extend<'a, A, B>(\n+            ts: &'a mut impl Extend<A>,\n+            us: &'a mut impl Extend<B>,\n+        ) -> impl FnMut((A, B)) + 'a {\n+            move |(t, u)| {\n+                ts.extend(Some(t));\n+                us.extend(Some(u));\n+            }\n+        }\n+\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        self.for_each(|(t, u)| {\n-            ts.extend(Some(t));\n-            us.extend(Some(u));\n-        });\n+        self.for_each(extend(&mut ts, &mut us));\n \n         (ts, us)\n     }\n@@ -2617,7 +2718,7 @@ pub trait Iterator {\n         Self: Sized,\n         Self::Item: PartialOrd,\n     {\n-        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+        self.is_sorted_by(PartialOrd::partial_cmp)\n     }\n \n     /// Checks if the elements of this iterator are sorted using the given comparator function.\n@@ -2639,11 +2740,9 @@ pub trait Iterator {\n         };\n \n         while let Some(curr) = self.next() {\n-            if compare(&last, &curr)\n-                .map(|o| o == Ordering::Greater)\n-                .unwrap_or(true)\n-            {\n-                return false;\n+            match compare(&last, &curr) {\n+                Some(Ordering::Greater) | None => return false,\n+                _ => {}\n             }\n             last = curr;\n         }\n@@ -2687,17 +2786,21 @@ pub trait Iterator {\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+fn select_fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n     where\n         I: Iterator,\n         F: FnMut(&I::Item, &I::Item) -> bool,\n {\n+    #[inline]\n+    fn select<T>(mut f: impl FnMut(&T, &T) -> bool) -> impl FnMut(T, T) -> T {\n+        move |sel, x| if f(&sel, &x) { x } else { sel }\n+    }\n+\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n-    it.next().map(|first| {\n-        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n-    })\n+    let first = it.next()?;\n+    Some(it.fold(first, select(f)))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}