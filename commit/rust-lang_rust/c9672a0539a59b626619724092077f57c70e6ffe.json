{"sha": "c9672a0539a59b626619724092077f57c70e6ffe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NjcyYTA1MzlhNTliNjI2NjE5NzI0MDkyMDc3ZjU3YzcwZTZmZmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-16T16:34:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-16T16:34:22Z"}, "message": "Merge #7657\n\n7657: utf8 r=matklad a=matklad\n\n- Prepare for utf-8 offsets\r\n- reduce code duplication in tests\r\n- Make utf8 default, implement utf16 in terms of it\r\n- Make it easy to add additional context for offset conversion\r\n- Implement utf8 offsets\r\n\r\ncloses #7453\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "77097454dc598a5e0a0b1d98b8c9645b9e213289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77097454dc598a5e0a0b1d98b8c9645b9e213289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9672a0539a59b626619724092077f57c70e6ffe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgK/QOCRBK7hj4Ov3rIwAAdHIIAAPaB8/LcKB9y0i06+OmpjfY\ndVAg14CLt6nMzFDK+PS9uiEwHHlpd5nzfwAmZ3Zzf09zwk9ehaubhvt6UgdHoJxG\nnvpinGuuynjYhULp2yHKqUPXup4Xf8De49CkIGzGSnr4Y3PHZSItyd7eyrk72pv3\n3IRFvDtDrh8icw7SErpOT0p/+EiyQ94Th2tLdybkyZgegKrqFJMwEVzWbEE+vmXh\nSWDFcd8aQ2QTsZvr1r2ZvF60n94YBXrlbjDENEstd9aNMO0+/UZzuXIpj2yStY7x\n1ZOhahTegaKlS4YBOplMDzeoQZN+fgpC0+VPZL7qzRwZaFD/RUn/V6X3vZWQuDE=\n=xctU\n-----END PGP SIGNATURE-----\n", "payload": "tree 77097454dc598a5e0a0b1d98b8c9645b9e213289\nparent f7b7a09f752caba21f2b21ccb8f74421a599d2c6\nparent 3f09e3fba62839f26da2f27ce27a2335b1dca7ef\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1613493262 +0000\ncommitter GitHub <noreply@github.com> 1613493262 +0000\n\nMerge #7657\n\n7657: utf8 r=matklad a=matklad\n\n- Prepare for utf-8 offsets\r\n- reduce code duplication in tests\r\n- Make utf8 default, implement utf16 in terms of it\r\n- Make it easy to add additional context for offset conversion\r\n- Implement utf8 offsets\r\n\r\ncloses #7453\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9672a0539a59b626619724092077f57c70e6ffe", "html_url": "https://github.com/rust-lang/rust/commit/c9672a0539a59b626619724092077f57c70e6ffe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9672a0539a59b626619724092077f57c70e6ffe/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7b7a09f752caba21f2b21ccb8f74421a599d2c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7b7a09f752caba21f2b21ccb8f74421a599d2c6", "html_url": "https://github.com/rust-lang/rust/commit/f7b7a09f752caba21f2b21ccb8f74421a599d2c6"}, {"sha": "3f09e3fba62839f26da2f27ce27a2335b1dca7ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f09e3fba62839f26da2f27ce27a2335b1dca7ef", "html_url": "https://github.com/rust-lang/rust/commit/3f09e3fba62839f26da2f27ce27a2335b1dca7ef"}], "stats": {"total": 367, "additions": 221, "deletions": 146}, "files": [{"sha": "a2c8db505d8ec89302db4532f26ab0037d6f90d4", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -95,7 +95,7 @@ pub use ide_db::{\n     },\n     call_info::CallInfo,\n     label::Label,\n-    line_index::{LineCol, LineIndex},\n+    line_index::{LineCol, LineColUtf16, LineIndex},\n     search::{ReferenceAccess, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,"}, {"sha": "8e9d8cca233db9f09f75f422d950d6dd9089bcff", "filename": "crates/ide_db/src/line_index.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Fide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Fide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fline_index.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -15,11 +15,19 @@ pub struct LineIndex {\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineCol {\n+pub struct LineColUtf16 {\n     /// Zero-based\n     pub line: u32,\n     /// Zero-based\n-    pub col_utf16: u32,\n+    pub col: u32,\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct LineCol {\n+    /// Zero-based\n+    pub line: u32,\n+    /// Zero-based utf8 offset\n+    pub col: u32,\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n@@ -92,14 +100,21 @@ impl LineIndex {\n         let line = partition_point(&self.newlines, |&it| it <= offset) - 1;\n         let line_start_offset = self.newlines[line];\n         let col = offset - line_start_offset;\n-\n-        LineCol { line: line as u32, col_utf16: self.utf8_to_utf16_col(line as u32, col) as u32 }\n+        LineCol { line: line as u32, col: col.into() }\n     }\n \n     pub fn offset(&self, line_col: LineCol) -> TextSize {\n-        //FIXME: return Result\n-        let col = self.utf16_to_utf8_col(line_col.line, line_col.col_utf16);\n-        self.newlines[line_col.line as usize] + col\n+        self.newlines[line_col.line as usize] + TextSize::from(line_col.col)\n+    }\n+\n+    pub fn to_utf16(&self, line_col: LineCol) -> LineColUtf16 {\n+        let col = self.utf8_to_utf16_col(line_col.line, line_col.col.into());\n+        LineColUtf16 { line: line_col.line, col: col as u32 }\n+    }\n+\n+    pub fn to_utf8(&self, line_col: LineColUtf16) -> LineCol {\n+        let col = self.utf16_to_utf8_col(line_col.line, line_col.col);\n+        LineCol { line: line_col.line, col: col.into() }\n     }\n \n     pub fn lines(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {"}, {"sha": "09f3bca626c2e860bdccaaddcfb216a2e8b1af80", "filename": "crates/ide_db/src/line_index/tests.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Fide_db%2Fsrc%2Fline_index%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Fide_db%2Fsrc%2Fline_index%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fline_index%2Ftests.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -3,24 +3,29 @@ use super::*;\n #[test]\n fn test_line_index() {\n     let text = \"hello\\nworld\";\n+    let table = [\n+        (00, 0, 0),\n+        (01, 0, 1),\n+        (05, 0, 5),\n+        (06, 1, 0),\n+        (07, 1, 1),\n+        (08, 1, 2),\n+        (10, 1, 4),\n+        (11, 1, 5),\n+        (12, 1, 6),\n+    ];\n+\n     let index = LineIndex::new(text);\n-    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n-    assert_eq!(index.line_col(1.into()), LineCol { line: 0, col_utf16: 1 });\n-    assert_eq!(index.line_col(5.into()), LineCol { line: 0, col_utf16: 5 });\n-    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 0 });\n-    assert_eq!(index.line_col(7.into()), LineCol { line: 1, col_utf16: 1 });\n-    assert_eq!(index.line_col(8.into()), LineCol { line: 1, col_utf16: 2 });\n-    assert_eq!(index.line_col(10.into()), LineCol { line: 1, col_utf16: 4 });\n-    assert_eq!(index.line_col(11.into()), LineCol { line: 1, col_utf16: 5 });\n-    assert_eq!(index.line_col(12.into()), LineCol { line: 1, col_utf16: 6 });\n+    for &(offset, line, col) in &table {\n+        assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n+    }\n \n     let text = \"\\nhello\\nworld\";\n+    let table = [(0, 0, 0), (1, 1, 0), (2, 1, 1), (6, 1, 5), (7, 2, 0)];\n     let index = LineIndex::new(text);\n-    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col_utf16: 0 });\n-    assert_eq!(index.line_col(1.into()), LineCol { line: 1, col_utf16: 0 });\n-    assert_eq!(index.line_col(2.into()), LineCol { line: 1, col_utf16: 1 });\n-    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col_utf16: 5 });\n-    assert_eq!(index.line_col(7.into()), LineCol { line: 2, col_utf16: 0 });\n+    for &(offset, line, col) in &table {\n+        assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n+    }\n }\n \n #[test]"}, {"sha": "89482b95266b09c4769d50757cfc11b8d98b4576", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -8,7 +8,7 @@ use std::{convert::TryFrom, env, fs, path::PathBuf, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n-use rust_analyzer::{cli, config::Config, from_json, Result};\n+use rust_analyzer::{cli, config::Config, from_json, lsp_ext::supports_utf8, Result};\n use vfs::AbsPathBuf;\n \n #[cfg(all(feature = \"mimalloc\"))]\n@@ -127,7 +127,11 @@ fn run_server() -> Result<()> {\n             name: String::from(\"rust-analyzer\"),\n             version: Some(String::from(env!(\"REV\"))),\n         }),\n-        offset_encoding: None,\n+        offset_encoding: if supports_utf8(&initialize_params.capabilities) {\n+            Some(\"utf-8\".to_string())\n+        } else {\n+            None\n+        },\n     };\n \n     let initialize_result = serde_json::to_value(initialize_result).unwrap();"}, {"sha": "877abd12b08ac9b5f3f0d054dd444830ffad57c4", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -97,7 +97,7 @@ impl BenchCmd {\n                 let offset = host\n                     .analysis()\n                     .file_line_index(file_id)?\n-                    .offset(LineCol { line: pos.line - 1, col_utf16: pos.column });\n+                    .offset(LineCol { line: pos.line - 1, col: pos.column });\n                 let file_position = FilePosition { file_id, offset };\n \n                 if is_completion {"}, {"sha": "6d6f398f482633372e276a88a374cda970d38130", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -218,9 +218,9 @@ impl AnalysisStatsCmd {\n                         bar.println(format!(\n                             \"{}:{}-{}:{}: {}\",\n                             start.line + 1,\n-                            start.col_utf16,\n+                            start.col,\n                             end.line + 1,\n-                            end.col_utf16,\n+                            end.col,\n                             ty.display(db)\n                         ));\n                     } else {\n@@ -250,9 +250,9 @@ impl AnalysisStatsCmd {\n                                 \"{} {}:{}-{}:{}: Expected {}, got {}\",\n                                 path,\n                                 start.line + 1,\n-                                start.col_utf16,\n+                                start.col,\n                                 end.line + 1,\n-                                end.col_utf16,\n+                                end.col,\n                                 mismatch.expected.display(db),\n                                 mismatch.actual.display(db)\n                             ));"}, {"sha": "556fc2eeb6e235c38e806d54969a8de6909bbcc3", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -23,7 +23,10 @@ use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Deserialize};\n use vfs::AbsPathBuf;\n \n-use crate::{caps::completion_item_edit_resolve, diagnostics::DiagnosticsMapConfig};\n+use crate::{\n+    caps::completion_item_edit_resolve, diagnostics::DiagnosticsMapConfig,\n+    line_index::OffsetEncoding, lsp_ext::supports_utf8,\n+};\n \n config_data! {\n     struct ConfigData {\n@@ -415,6 +418,13 @@ impl Config {\n             false\n         )\n     }\n+    pub fn offset_encoding(&self) -> OffsetEncoding {\n+        if supports_utf8(&self.caps) {\n+            OffsetEncoding::Utf8\n+        } else {\n+            OffsetEncoding::Utf16\n+        }\n+    }\n \n     fn experimental(&self, index: &'static str) -> bool {\n         try_or!(self.caps.experimental.as_ref()?.get(index)?.as_bool()?, false)"}, {"sha": "5b02b2598d39d397c9b141ac681da9bea2717055", "filename": "crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -1,12 +1,17 @@\n //! Conversion lsp_types types to rust-analyzer specific ones.\n use std::convert::TryFrom;\n \n-use ide::{Annotation, AnnotationKind, AssistKind, LineCol, LineIndex};\n+use ide::{Annotation, AnnotationKind, AssistKind, LineCol, LineColUtf16};\n use ide_db::base_db::{FileId, FilePosition, FileRange};\n use syntax::{TextRange, TextSize};\n use vfs::AbsPathBuf;\n \n-use crate::{from_json, global_state::GlobalStateSnapshot, lsp_ext, Result};\n+use crate::{\n+    from_json,\n+    global_state::GlobalStateSnapshot,\n+    line_index::{LineIndex, OffsetEncoding},\n+    lsp_ext, Result,\n+};\n \n pub(crate) fn abs_path(url: &lsp_types::Url) -> Result<AbsPathBuf> {\n     let path = url.to_file_path().map_err(|()| \"url is not a file\")?;\n@@ -18,8 +23,17 @@ pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n }\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> TextSize {\n-    let line_col = LineCol { line: position.line as u32, col_utf16: position.character as u32 };\n-    line_index.offset(line_col)\n+    let line_col = match line_index.encoding {\n+        OffsetEncoding::Utf8 => {\n+            LineCol { line: position.line as u32, col: position.character as u32 }\n+        }\n+        OffsetEncoding::Utf16 => {\n+            let line_col =\n+                LineColUtf16 { line: position.line as u32, col: position.character as u32 };\n+            line_index.index.to_utf8(line_col)\n+        }\n+    };\n+    line_index.index.offset(line_col)\n }\n \n pub(crate) fn text_range(line_index: &LineIndex, range: lsp_types::Range) -> TextRange {\n@@ -37,8 +51,8 @@ pub(crate) fn file_position(\n     tdpp: lsp_types::TextDocumentPositionParams,\n ) -> Result<FilePosition> {\n     let file_id = file_id(world, &tdpp.text_document.uri)?;\n-    let line_index = world.analysis.file_line_index(file_id)?;\n-    let offset = offset(&*line_index, tdpp.position);\n+    let line_index = world.file_line_index(file_id)?;\n+    let offset = offset(&line_index, tdpp.position);\n     Ok(FilePosition { file_id, offset })\n }\n \n@@ -48,7 +62,7 @@ pub(crate) fn file_range(\n     range: lsp_types::Range,\n ) -> Result<FileRange> {\n     let file_id = file_id(world, &text_document_identifier.uri)?;\n-    let line_index = world.analysis.file_line_index(file_id)?;\n+    let line_index = world.file_line_index(file_id)?;\n     let range = text_range(&line_index, range);\n     Ok(FileRange { file_id, range })\n }\n@@ -78,7 +92,7 @@ pub(crate) fn annotation(\n         lsp_ext::CodeLensResolveData::Impls(params) => {\n             let file_id =\n                 world.url_to_file_id(&params.text_document_position_params.text_document.uri)?;\n-            let line_index = world.analysis.file_line_index(file_id)?;\n+            let line_index = world.file_line_index(file_id)?;\n \n             Ok(Annotation {\n                 range: text_range(&line_index, code_lens.range),\n@@ -90,7 +104,7 @@ pub(crate) fn annotation(\n         }\n         lsp_ext::CodeLensResolveData::References(params) => {\n             let file_id = world.url_to_file_id(&params.text_document.uri)?;\n-            let line_index = world.analysis.file_line_index(file_id)?;\n+            let line_index = world.file_line_index(file_id)?;\n \n             Ok(Annotation {\n                 range: text_range(&line_index, code_lens.range),"}, {"sha": "52c2497137f570c74a005cb7905038ab435e8ab1", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -7,7 +7,7 @@ use std::{sync::Arc, time::Instant};\n \n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n-use ide::{Analysis, AnalysisHost, Change, FileId};\n+use ide::{Analysis, AnalysisHost, Cancelable, Change, FileId};\n use ide_db::base_db::{CrateId, VfsPath};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n@@ -22,7 +22,7 @@ use crate::{\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     document::DocumentData,\n     from_proto,\n-    line_endings::LineEndings,\n+    line_index::{LineEndings, LineIndex},\n     main_loop::Task,\n     op_queue::OpQueue,\n     reload::SourceRootConfig,\n@@ -271,8 +271,11 @@ impl GlobalStateSnapshot {\n         file_id_to_url(&self.vfs.read().0, id)\n     }\n \n-    pub(crate) fn file_line_endings(&self, id: FileId) -> LineEndings {\n-        self.vfs.read().1[&id]\n+    pub(crate) fn file_line_index(&self, file_id: FileId) -> Cancelable<LineIndex> {\n+        let endings = self.vfs.read().1[&file_id];\n+        let index = self.analysis.file_line_index(file_id)?;\n+        let res = LineIndex { index, endings, encoding: self.config.offset_encoding() };\n+        Ok(res)\n     }\n \n     pub(crate) fn url_file_version(&self, url: &Url) -> Option<i32> {"}, {"sha": "4f6f250d6c6ad57317be43b4e5debc36cbb99e86", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 38, "deletions": 53, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -5,12 +5,11 @@\n use std::{\n     io::Write as _,\n     process::{self, Stdio},\n-    sync::Arc,\n };\n \n use ide::{\n-    AnnotationConfig, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, LineIndex,\n-    Query, RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange, TextEdit,\n+    AnnotationConfig, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, Query,\n+    RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n@@ -37,7 +36,7 @@ use crate::{\n     diff::diff,\n     from_proto,\n     global_state::{GlobalState, GlobalStateSnapshot},\n-    line_endings::LineEndings,\n+    line_index::{LineEndings, LineIndex},\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n     lsp_utils::all_edits_are_disjoint,\n     to_proto, LspError, Result,\n@@ -100,7 +99,7 @@ pub(crate) fn handle_syntax_tree(\n ) -> Result<String> {\n     let _p = profile::span(\"handle_syntax_tree\");\n     let id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(id)?;\n+    let line_index = snap.file_line_index(id)?;\n     let text_range = params.range.map(|r| from_proto::text_range(&line_index, r));\n     let res = snap.analysis.syntax_tree(id, text_range)?;\n     Ok(res)\n@@ -122,7 +121,7 @@ pub(crate) fn handle_expand_macro(\n ) -> Result<Option<lsp_ext::ExpandedMacro>> {\n     let _p = profile::span(\"handle_expand_macro\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let offset = from_proto::offset(&line_index, params.position);\n \n     let res = snap.analysis.expand_macro(FilePosition { file_id, offset })?;\n@@ -135,7 +134,7 @@ pub(crate) fn handle_selection_range(\n ) -> Result<Option<Vec<lsp_types::SelectionRange>>> {\n     let _p = profile::span(\"handle_selection_range\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let res: Result<Vec<lsp_types::SelectionRange>> = params\n         .positions\n         .into_iter()\n@@ -178,7 +177,7 @@ pub(crate) fn handle_matching_brace(\n ) -> Result<Vec<Position>> {\n     let _p = profile::span(\"handle_matching_brace\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let res = params\n         .positions\n         .into_iter()\n@@ -200,8 +199,7 @@ pub(crate) fn handle_join_lines(\n ) -> Result<Vec<lsp_types::TextEdit>> {\n     let _p = profile::span(\"handle_join_lines\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n-    let line_endings = snap.file_line_endings(file_id);\n+    let line_index = snap.file_line_index(file_id)?;\n     let mut res = TextEdit::default();\n     for range in params.ranges {\n         let range = from_proto::text_range(&line_index, range);\n@@ -213,7 +211,7 @@ pub(crate) fn handle_join_lines(\n             }\n         }\n     }\n-    let res = to_proto::text_edit_vec(&line_index, line_endings, res);\n+    let res = to_proto::text_edit_vec(&line_index, res);\n     Ok(res)\n }\n \n@@ -227,9 +225,8 @@ pub(crate) fn handle_on_enter(\n         None => return Ok(None),\n         Some(it) => it,\n     };\n-    let line_index = snap.analysis.file_line_index(position.file_id)?;\n-    let line_endings = snap.file_line_endings(position.file_id);\n-    let edit = to_proto::snippet_text_edit_vec(&line_index, line_endings, true, edit);\n+    let line_index = snap.file_line_index(position.file_id)?;\n+    let edit = to_proto::snippet_text_edit_vec(&line_index, true, edit);\n     Ok(Some(edit))\n }\n \n@@ -240,8 +237,7 @@ pub(crate) fn handle_on_type_formatting(\n ) -> Result<Option<Vec<lsp_types::TextEdit>>> {\n     let _p = profile::span(\"handle_on_type_formatting\");\n     let mut position = from_proto::file_position(&snap, params.text_document_position)?;\n-    let line_index = snap.analysis.file_line_index(position.file_id)?;\n-    let line_endings = snap.file_line_endings(position.file_id);\n+    let line_index = snap.file_line_index(position.file_id)?;\n \n     // in `ide`, the `on_type` invariant is that\n     // `text.char_at(position) == typed_char`.\n@@ -269,7 +265,7 @@ pub(crate) fn handle_on_type_formatting(\n     // This should be a single-file edit\n     let (_, edit) = edit.source_file_edits.into_iter().next().unwrap();\n \n-    let change = to_proto::text_edit_vec(&line_index, line_endings, edit);\n+    let change = to_proto::text_edit_vec(&line_index, edit);\n     Ok(Some(change))\n }\n \n@@ -279,7 +275,7 @@ pub(crate) fn handle_document_symbol(\n ) -> Result<Option<lsp_types::DocumentSymbolResponse>> {\n     let _p = profile::span(\"handle_document_symbol\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n \n     let mut parents: Vec<(lsp_types::DocumentSymbol, Option<usize>)> = Vec::new();\n \n@@ -535,7 +531,7 @@ pub(crate) fn handle_runnables(\n ) -> Result<Vec<lsp_ext::Runnable>> {\n     let _p = profile::span(\"handle_runnables\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let offset = params.position.map(|it| from_proto::offset(&line_index, it));\n     let cargo_spec = CargoTargetSpec::for_file(&snap, file_id)?;\n \n@@ -645,14 +641,12 @@ pub(crate) fn handle_completion(\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let line_index = snap.analysis.file_line_index(position.file_id)?;\n-    let line_endings = snap.file_line_endings(position.file_id);\n+    let line_index = snap.file_line_index(position.file_id)?;\n \n     let items: Vec<CompletionItem> = items\n         .into_iter()\n         .flat_map(|item| {\n-            let mut new_completion_items =\n-                to_proto::completion_item(&line_index, line_endings, item.clone());\n+            let mut new_completion_items = to_proto::completion_item(&line_index, item.clone());\n \n             if completion_config.enable_imports_on_the_fly {\n                 for new_item in &mut new_completion_items {\n@@ -693,8 +687,7 @@ pub(crate) fn handle_completion_resolve(\n     };\n \n     let file_id = from_proto::file_id(&snap, &resolve_data.position.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n-    let line_endings = snap.file_line_endings(file_id);\n+    let line_index = snap.file_line_index(file_id)?;\n     let offset = from_proto::offset(&line_index, resolve_data.position.position);\n \n     let additional_edits = snap\n@@ -707,9 +700,7 @@ pub(crate) fn handle_completion_resolve(\n             resolve_data.import_for_trait_assoc_item,\n         )?\n         .into_iter()\n-        .flat_map(|edit| {\n-            edit.into_iter().map(|indel| to_proto::text_edit(&line_index, line_endings, indel))\n-        })\n+        .flat_map(|edit| edit.into_iter().map(|indel| to_proto::text_edit(&line_index, indel)))\n         .collect_vec();\n \n     if !all_edits_are_disjoint(&original_completion, &additional_edits) {\n@@ -738,7 +729,7 @@ pub(crate) fn handle_folding_range(\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n     let folds = snap.analysis.folding_ranges(file_id)?;\n     let text = snap.analysis.file_text(file_id)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let line_folding_only = snap.config.line_folding_only();\n     let res = folds\n         .into_iter()\n@@ -775,7 +766,7 @@ pub(crate) fn handle_hover(\n             None => return Ok(None),\n             Some(info) => info,\n         };\n-    let line_index = snap.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, info.range);\n     let hover = lsp_ext::Hover {\n         hover: lsp_types::Hover {\n@@ -797,7 +788,7 @@ pub(crate) fn handle_prepare_rename(\n \n     let change = snap.analysis.prepare_rename(position)?.map_err(to_proto::rename_error)?;\n \n-    let line_index = snap.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, change.range);\n     Ok(Some(PrepareRenameResponse::Range(range)))\n }\n@@ -857,8 +848,7 @@ pub(crate) fn handle_formatting(\n     let file = snap.analysis.file_text(file_id)?;\n     let crate_ids = snap.analysis.crate_for(file_id)?;\n \n-    let file_line_index = snap.analysis.file_line_index(file_id)?;\n-    let file_line_endings = snap.file_line_endings(file_id);\n+    let line_index = snap.file_line_index(file_id)?;\n \n     let mut rustfmt = match snap.config.rustfmt() {\n         RustfmtConfig::Rustfmt { extra_args } => {\n@@ -935,24 +925,19 @@ pub(crate) fn handle_formatting(\n \n     let (new_text, new_line_endings) = LineEndings::normalize(captured_stdout);\n \n-    if file_line_endings != new_line_endings {\n+    if line_index.endings != new_line_endings {\n         // If line endings are different, send the entire file.\n         // Diffing would not work here, as the line endings might be the only\n         // difference.\n         Ok(Some(to_proto::text_edit_vec(\n-            &file_line_index,\n-            new_line_endings,\n+            &line_index,\n             TextEdit::replace(TextRange::up_to(TextSize::of(&*file)), new_text),\n         )))\n     } else if *file == new_text {\n         // The document is already formatted correctly -- no edits needed.\n         Ok(None)\n     } else {\n-        Ok(Some(to_proto::text_edit_vec(\n-            &file_line_index,\n-            file_line_endings,\n-            diff(&file, &new_text),\n-        )))\n+        Ok(Some(to_proto::text_edit_vec(&line_index, diff(&file, &new_text))))\n     }\n }\n \n@@ -969,7 +954,7 @@ pub(crate) fn handle_code_action(\n     }\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.range);\n     let frange = FileRange { file_id, range };\n \n@@ -1010,7 +995,7 @@ pub(crate) fn handle_code_action(\n fn add_quick_fixes(\n     snap: &GlobalStateSnapshot,\n     frange: FileRange,\n-    line_index: &Arc<LineIndex>,\n+    line_index: &LineIndex,\n     acc: &mut Vec<lsp_ext::CodeAction>,\n ) -> Result<()> {\n     let diagnostics = snap.analysis.diagnostics(&snap.config.diagnostics(), frange.file_id)?;\n@@ -1052,7 +1037,7 @@ pub(crate) fn handle_code_action_resolve(\n     };\n \n     let file_id = from_proto::file_id(&snap, &params.code_action_params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     let range = from_proto::text_range(&line_index, params.code_action_params.range);\n     let frange = FileRange { file_id, range };\n \n@@ -1131,7 +1116,7 @@ pub(crate) fn handle_document_highlight(\n ) -> Result<Option<Vec<DocumentHighlight>>> {\n     let _p = profile::span(\"handle_document_highlight\");\n     let position = from_proto::file_position(&snap, params.text_document_position_params)?;\n-    let line_index = snap.analysis.file_line_index(position.file_id)?;\n+    let line_index = snap.file_line_index(position.file_id)?;\n \n     let refs = match snap\n         .analysis\n@@ -1192,7 +1177,7 @@ pub(crate) fn publish_diagnostics(\n     file_id: FileId,\n ) -> Result<Vec<Diagnostic>> {\n     let _p = profile::span(\"publish_diagnostics\");\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n \n     let diagnostics: Vec<Diagnostic> = snap\n         .analysis\n@@ -1226,7 +1211,7 @@ pub(crate) fn handle_inlay_hints(\n ) -> Result<Vec<InlayHint>> {\n     let _p = profile::span(\"handle_inlay_hints\");\n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n     Ok(snap\n         .analysis\n         .inlay_hints(file_id, &snap.config.inlay_hints())?\n@@ -1277,7 +1262,7 @@ pub(crate) fn handle_call_hierarchy_incoming(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id;\n-        let line_index = snap.analysis.file_line_index(file_id)?;\n+        let line_index = snap.file_line_index(file_id)?;\n         let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyIncomingCall {\n             from: item,\n@@ -1312,7 +1297,7 @@ pub(crate) fn handle_call_hierarchy_outgoing(\n \n     for call_item in call_items.into_iter() {\n         let file_id = call_item.target.file_id;\n-        let line_index = snap.analysis.file_line_index(file_id)?;\n+        let line_index = snap.file_line_index(file_id)?;\n         let item = to_proto::call_hierarchy_item(&snap, call_item.target)?;\n         res.push(CallHierarchyOutgoingCall {\n             to: item,\n@@ -1335,7 +1320,7 @@ pub(crate) fn handle_semantic_tokens_full(\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n     let text = snap.analysis.file_text(file_id)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n \n     let highlights = snap.analysis.highlight(file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n@@ -1354,7 +1339,7 @@ pub(crate) fn handle_semantic_tokens_full_delta(\n \n     let file_id = from_proto::file_id(&snap, &params.text_document.uri)?;\n     let text = snap.analysis.file_text(file_id)?;\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n+    let line_index = snap.file_line_index(file_id)?;\n \n     let highlights = snap.analysis.highlight(file_id)?;\n \n@@ -1384,7 +1369,7 @@ pub(crate) fn handle_semantic_tokens_range(\n \n     let frange = from_proto::file_range(&snap, params.text_document, params.range)?;\n     let text = snap.analysis.file_text(frange.file_id)?;\n-    let line_index = snap.analysis.file_line_index(frange.file_id)?;\n+    let line_index = snap.file_line_index(frange.file_id)?;\n \n     let highlights = snap.analysis.highlight_range(frange)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n@@ -1432,7 +1417,7 @@ fn show_impl_command_link(\n     if snap.config.hover().implementations {\n         if let Some(nav_data) = snap.analysis.goto_implementation(*position).unwrap_or(None) {\n             let uri = to_proto::url(snap, position.file_id);\n-            let line_index = snap.analysis.file_line_index(position.file_id).ok()?;\n+            let line_index = snap.file_line_index(position.file_id).ok()?;\n             let position = to_proto::position(&line_index, position.offset);\n             let locations: Vec<_> = nav_data\n                 .info"}, {"sha": "8b874239c77851b9cda649e0735cfdc2dfbcde4b", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -29,7 +29,7 @@ mod from_proto;\n mod semantic_tokens;\n mod markdown;\n mod diagnostics;\n-mod line_endings;\n+mod line_index;\n mod request_metrics;\n mod lsp_utils;\n mod thread_pool;"}, {"sha": "c116414da01df110b7e20b21d0ebb4aa248b8d5a", "filename": "crates/rust-analyzer/src/line_index.rs", "status": "renamed", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -1,7 +1,23 @@\n+//! Enhances `ide::LineIndex` with additional info required to convert offsets\n+//! into lsp positions.\n+//!\n //! We maintain invariant that all internal strings use `\\n` as line separator.\n //! This module does line ending conversion and detection (so that we can\n //! convert back to `\\r\\n` on the way out).\n \n+use std::sync::Arc;\n+\n+pub enum OffsetEncoding {\n+    Utf8,\n+    Utf16,\n+}\n+\n+pub(crate) struct LineIndex {\n+    pub(crate) index: Arc<ide::LineIndex>,\n+    pub(crate) endings: LineEndings,\n+    pub(crate) encoding: OffsetEncoding,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(crate) enum LineEndings {\n     Unix,", "previous_filename": "crates/rust-analyzer/src/line_endings.rs"}, {"sha": "0d2c8f7ffbb23bf4ac83b04aaf17ab69d027d927", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -385,3 +385,7 @@ pub(crate) enum CodeLensResolveData {\n     Impls(lsp_types::request::GotoImplementationParams),\n     References(lsp_types::TextDocumentPositionParams),\n }\n+\n+pub fn supports_utf8(caps: &lsp_types::ClientCapabilities) -> bool {\n+    caps.offset_encoding.as_deref().unwrap_or_default().iter().any(|it| it == \"utf-8\")\n+}"}, {"sha": "84f78b5b842cd44f56cd163873b7d997679d6a23", "filename": "crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -1,11 +1,14 @@\n //! Utilities for LSP-related boilerplate code.\n-use std::{error::Error, ops::Range};\n+use std::{error::Error, ops::Range, sync::Arc};\n \n-use ide::LineIndex;\n use ide_db::base_db::Canceled;\n use lsp_server::Notification;\n \n-use crate::{from_proto, global_state::GlobalState};\n+use crate::{\n+    from_proto,\n+    global_state::GlobalState,\n+    line_index::{LineEndings, LineIndex, OffsetEncoding},\n+};\n \n pub(crate) fn is_canceled(e: &(dyn Error + 'static)) -> bool {\n     e.downcast_ref::<Canceled>().is_some()\n@@ -90,7 +93,13 @@ pub(crate) fn apply_document_changes(\n     old_text: &mut String,\n     content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n ) {\n-    let mut line_index = LineIndex::new(old_text);\n+    let mut line_index = LineIndex {\n+        index: Arc::new(ide::LineIndex::new(old_text)),\n+        // We don't care about line endings or offset encoding here.\n+        endings: LineEndings::Unix,\n+        encoding: OffsetEncoding::Utf16,\n+    };\n+\n     // The changes we got must be applied sequentially, but can cross lines so we\n     // have to keep our line index updated.\n     // Some clients (e.g. Code) sort the ranges in reverse. As an optimization, we\n@@ -115,7 +124,7 @@ pub(crate) fn apply_document_changes(\n         match change.range {\n             Some(range) => {\n                 if !index_valid.covers(range.end.line) {\n-                    line_index = LineIndex::new(&old_text);\n+                    line_index.index = Arc::new(ide::LineIndex::new(&old_text));\n                 }\n                 index_valid = IndexValid::UpToLineExclusive(range.start.line);\n                 let range = from_proto::text_range(&line_index, range);"}, {"sha": "70cb7fbab5c6820fdb27947e689fc79b7d680975", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -7,22 +7,29 @@ use std::{\n use ide::{\n     Annotation, AnnotationKind, Assist, AssistKind, CallInfo, CompletionItem, CompletionItemKind,\n     Documentation, FileId, FileRange, FileSystemEdit, Fold, FoldKind, Highlight, HlMod, HlPunct,\n-    HlRange, HlTag, Indel, InlayHint, InlayKind, InsertTextFormat, LineIndex, Markup,\n-    NavigationTarget, ReferenceAccess, RenameError, Runnable, Severity, SourceChange, TextEdit,\n-    TextRange, TextSize,\n+    HlRange, HlTag, Indel, InlayHint, InlayKind, InsertTextFormat, Markup, NavigationTarget,\n+    ReferenceAccess, RenameError, Runnable, Severity, SourceChange, TextEdit, TextRange, TextSize,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n use serde_json::to_value;\n \n use crate::{\n-    cargo_target_spec::CargoTargetSpec, global_state::GlobalStateSnapshot,\n-    line_endings::LineEndings, lsp_ext, semantic_tokens, Result,\n+    cargo_target_spec::CargoTargetSpec,\n+    global_state::GlobalStateSnapshot,\n+    line_index::{LineEndings, LineIndex, OffsetEncoding},\n+    lsp_ext, semantic_tokens, Result,\n };\n \n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n-    let line_col = line_index.line_col(offset);\n-    lsp_types::Position::new(line_col.line, line_col.col_utf16)\n+    let line_col = line_index.index.line_col(offset);\n+    match line_index.encoding {\n+        OffsetEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n+        OffsetEncoding::Utf16 => {\n+            let line_col = line_index.index.to_utf16(line_col);\n+            lsp_types::Position::new(line_col.line, line_col.col)\n+        }\n+    }\n }\n \n pub(crate) fn range(line_index: &LineIndex, range: TextRange) -> lsp_types::Range {\n@@ -122,13 +129,9 @@ pub(crate) fn completion_item_kind(\n     }\n }\n \n-pub(crate) fn text_edit(\n-    line_index: &LineIndex,\n-    line_endings: LineEndings,\n-    indel: Indel,\n-) -> lsp_types::TextEdit {\n+pub(crate) fn text_edit(line_index: &LineIndex, indel: Indel) -> lsp_types::TextEdit {\n     let range = range(line_index, indel.delete);\n-    let new_text = match line_endings {\n+    let new_text = match line_index.endings {\n         LineEndings::Unix => indel.insert,\n         LineEndings::Dos => indel.insert.replace('\\n', \"\\r\\n\"),\n     };\n@@ -137,11 +140,10 @@ pub(crate) fn text_edit(\n \n pub(crate) fn snippet_text_edit(\n     line_index: &LineIndex,\n-    line_endings: LineEndings,\n     is_snippet: bool,\n     indel: Indel,\n ) -> lsp_ext::SnippetTextEdit {\n-    let text_edit = text_edit(line_index, line_endings, indel);\n+    let text_edit = text_edit(line_index, indel);\n     let insert_text_format =\n         if is_snippet { Some(lsp_types::InsertTextFormat::Snippet) } else { None };\n     lsp_ext::SnippetTextEdit {\n@@ -153,27 +155,24 @@ pub(crate) fn snippet_text_edit(\n \n pub(crate) fn text_edit_vec(\n     line_index: &LineIndex,\n-    line_endings: LineEndings,\n     text_edit: TextEdit,\n ) -> Vec<lsp_types::TextEdit> {\n-    text_edit.into_iter().map(|indel| self::text_edit(line_index, line_endings, indel)).collect()\n+    text_edit.into_iter().map(|indel| self::text_edit(line_index, indel)).collect()\n }\n \n pub(crate) fn snippet_text_edit_vec(\n     line_index: &LineIndex,\n-    line_endings: LineEndings,\n     is_snippet: bool,\n     text_edit: TextEdit,\n ) -> Vec<lsp_ext::SnippetTextEdit> {\n     text_edit\n         .into_iter()\n-        .map(|indel| self::snippet_text_edit(line_index, line_endings, is_snippet, indel))\n+        .map(|indel| self::snippet_text_edit(line_index, is_snippet, indel))\n         .collect()\n }\n \n pub(crate) fn completion_item(\n     line_index: &LineIndex,\n-    line_endings: LineEndings,\n     completion_item: CompletionItem,\n ) -> Vec<lsp_types::CompletionItem> {\n     fn set_score(res: &mut lsp_types::CompletionItem, label: &str) {\n@@ -190,19 +189,19 @@ pub(crate) fn completion_item(\n     for indel in completion_item.text_edit().iter() {\n         if indel.delete.contains_range(source_range) {\n             text_edit = Some(if indel.delete == source_range {\n-                self::text_edit(line_index, line_endings, indel.clone())\n+                self::text_edit(line_index, indel.clone())\n             } else {\n                 assert!(source_range.end() == indel.delete.end());\n                 let range1 = TextRange::new(indel.delete.start(), source_range.start());\n                 let range2 = source_range;\n                 let indel1 = Indel::replace(range1, String::new());\n                 let indel2 = Indel::replace(range2, indel.insert.clone());\n-                additional_text_edits.push(self::text_edit(line_index, line_endings, indel1));\n-                self::text_edit(line_index, line_endings, indel2)\n+                additional_text_edits.push(self::text_edit(line_index, indel1));\n+                self::text_edit(line_index, indel2)\n             })\n         } else {\n             assert!(source_range.intersect(indel.delete).is_none());\n-            let text_edit = self::text_edit(line_index, line_endings, indel.clone());\n+            let text_edit = self::text_edit(line_index, indel.clone());\n             additional_text_edits.push(text_edit);\n         }\n     }\n@@ -358,7 +357,7 @@ pub(crate) fn semantic_tokens(\n         let token_index = semantic_tokens::type_index(type_);\n         let modifier_bitset = mods.0;\n \n-        for mut text_range in line_index.lines(highlight_range.range) {\n+        for mut text_range in line_index.index.lines(highlight_range.range) {\n             if text[text_range].ends_with('\\n') {\n                 text_range =\n                     TextRange::new(text_range.start(), text_range.end() - TextSize::of('\\n'));\n@@ -565,7 +564,7 @@ pub(crate) fn location(\n     frange: FileRange,\n ) -> Result<lsp_types::Location> {\n     let url = url(snap, frange.file_id);\n-    let line_index = snap.analysis.file_line_index(frange.file_id)?;\n+    let line_index = snap.file_line_index(frange.file_id)?;\n     let range = range(&line_index, frange.range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n@@ -577,7 +576,7 @@ pub(crate) fn location_from_nav(\n     nav: NavigationTarget,\n ) -> Result<lsp_types::Location> {\n     let url = url(snap, nav.file_id);\n-    let line_index = snap.analysis.file_line_index(nav.file_id)?;\n+    let line_index = snap.file_line_index(nav.file_id)?;\n     let range = range(&line_index, nav.full_range);\n     let loc = lsp_types::Location::new(url, range);\n     Ok(loc)\n@@ -590,7 +589,7 @@ pub(crate) fn location_link(\n ) -> Result<lsp_types::LocationLink> {\n     let origin_selection_range = match src {\n         Some(src) => {\n-            let line_index = snap.analysis.file_line_index(src.file_id)?;\n+            let line_index = snap.file_line_index(src.file_id)?;\n             let range = range(&line_index, src.range);\n             Some(range)\n         }\n@@ -610,7 +609,7 @@ fn location_info(\n     snap: &GlobalStateSnapshot,\n     target: NavigationTarget,\n ) -> Result<(lsp_types::Url, lsp_types::Range, lsp_types::Range)> {\n-    let line_index = snap.analysis.file_line_index(target.file_id)?;\n+    let line_index = snap.file_line_index(target.file_id)?;\n \n     let target_uri = url(snap, target.file_id);\n     let target_range = range(&line_index, target.full_range);\n@@ -648,12 +647,8 @@ pub(crate) fn snippet_text_document_edit(\n     edit: TextEdit,\n ) -> Result<lsp_ext::SnippetTextDocumentEdit> {\n     let text_document = optional_versioned_text_document_identifier(snap, file_id);\n-    let line_index = snap.analysis.file_line_index(file_id)?;\n-    let line_endings = snap.file_line_endings(file_id);\n-    let edits = edit\n-        .into_iter()\n-        .map(|it| snippet_text_edit(&line_index, line_endings, is_snippet, it))\n-        .collect();\n+    let line_index = snap.file_line_index(file_id)?;\n+    let edits = edit.into_iter().map(|it| snippet_text_edit(&line_index, is_snippet, it)).collect();\n     Ok(lsp_ext::SnippetTextDocumentEdit { text_document, edits })\n }\n \n@@ -674,9 +669,8 @@ pub(crate) fn snippet_text_document_ops(\n             if !initial_contents.is_empty() {\n                 let text_document =\n                     lsp_types::OptionalVersionedTextDocumentIdentifier { uri, version: None };\n-                let range = range(&LineIndex::new(\"\"), TextRange::empty(TextSize::from(0)));\n                 let text_edit = lsp_ext::SnippetTextEdit {\n-                    range,\n+                    range: lsp_types::Range::default(),\n                     new_text: initial_contents,\n                     insert_text_format: Some(lsp_types::InsertTextFormat::PlainText),\n                 };\n@@ -867,7 +861,7 @@ pub(crate) fn code_lens(\n ) -> Result<lsp_types::CodeLens> {\n     match annotation.kind {\n         AnnotationKind::Runnable { debug, runnable: run } => {\n-            let line_index = snap.analysis.file_line_index(run.nav.file_id)?;\n+            let line_index = snap.file_line_index(run.nav.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n \n             let action = run.action();\n@@ -883,7 +877,7 @@ pub(crate) fn code_lens(\n             Ok(lsp_types::CodeLens { range: annotation_range, command: Some(command), data: None })\n         }\n         AnnotationKind::HasImpls { position: file_position, data } => {\n-            let line_index = snap.analysis.file_line_index(file_position.file_id)?;\n+            let line_index = snap.file_line_index(file_position.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n             let url = url(snap, file_position.file_id);\n \n@@ -926,7 +920,7 @@ pub(crate) fn code_lens(\n             })\n         }\n         AnnotationKind::HasReferences { position: file_position, data } => {\n-            let line_index = snap.analysis.file_line_index(file_position.file_id)?;\n+            let line_index = snap.file_line_index(file_position.file_id)?;\n             let annotation_range = range(&line_index, annotation.range);\n             let url = url(snap, file_position.file_id);\n \n@@ -1060,6 +1054,8 @@ pub(crate) fn rename_error(err: RenameError) -> crate::LspError {\n \n #[cfg(test)]\n mod tests {\n+    use std::sync::Arc;\n+\n     use hir::PrefixKind;\n     use ide::Analysis;\n     use ide_db::helpers::{insert_use::InsertUseConfig, SnippetCap};\n@@ -1077,7 +1073,11 @@ mod tests {\n         }\"#;\n \n         let (offset, text) = test_utils::extract_offset(fixture);\n-        let line_index = LineIndex::new(&text);\n+        let line_index = LineIndex {\n+            index: Arc::new(ide::LineIndex::new(&text)),\n+            endings: LineEndings::Unix,\n+            encoding: OffsetEncoding::Utf16,\n+        };\n         let (analysis, file_id) = Analysis::from_single_file(text);\n         let completions: Vec<(String, Option<String>)> = analysis\n             .completions(\n@@ -1095,7 +1095,7 @@ mod tests {\n             .unwrap()\n             .into_iter()\n             .filter(|c| c.label().ends_with(\"arg\"))\n-            .map(|c| completion_item(&line_index, LineEndings::Unix, c))\n+            .map(|c| completion_item(&line_index, c))\n             .flat_map(|comps| comps.into_iter().map(|c| (c.label, c.sort_text)))\n             .collect();\n         expect_test::expect![[r#\"\n@@ -1133,7 +1133,11 @@ fn main() {\n         let folds = analysis.folding_ranges(file_id).unwrap();\n         assert_eq!(folds.len(), 4);\n \n-        let line_index = LineIndex::new(&text);\n+        let line_index = LineIndex {\n+            index: Arc::new(ide::LineIndex::new(&text)),\n+            endings: LineEndings::Unix,\n+            encoding: OffsetEncoding::Utf16,\n+        };\n         let converted: Vec<lsp_types::FoldingRange> =\n             folds.into_iter().map(|it| folding_range(&text, &line_index, true, it)).collect();\n "}, {"sha": "164c8482e2e3d8eac9e6aac403e1350c64e7b701", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9672a0539a59b626619724092077f57c70e6ffe/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9672a0539a59b626619724092077f57c70e6ffe/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=c9672a0539a59b626619724092077f57c70e6ffe", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 34aec6bfeaeb97a\n+lsp_ext.rs hash: d279d971d4f62cd7\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this  issue:\n@@ -19,6 +19,12 @@ Requests, which are likely to always remain specific to `rust-analyzer` are unde\n \n If you want to be notified about the changes to this document, subscribe to [#4604](https://github.com/rust-analyzer/rust-analyzer/issues/4604).\n \n+## UTF-8 offsets\n+\n+rust-analyzer supports clangd's extension for opting into UTF-8 as the coordinate space for offsets (by default, LSP uses UTF-16 offsets).\n+\n+https://clangd.llvm.org/extensions.html#utf-8-offsets\n+\n ## `initializationOptions`\n \n For `initializationOptions`, `rust-analyzer` expects `\"rust-analyzer\"` section of the configuration."}]}