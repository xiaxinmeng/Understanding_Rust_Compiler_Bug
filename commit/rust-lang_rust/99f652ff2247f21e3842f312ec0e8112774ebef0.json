{"sha": "99f652ff2247f21e3842f312ec0e8112774ebef0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZjY1MmZmMjI0N2YyMWUzODQyZjMxMmVjMGU4MTEyNzc0ZWJlZjA=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-06-20T00:22:14Z"}, "committer": {"name": "Jeremy Fitzhardinge", "email": "jsgf@fb.com", "date": "2021-06-22T00:22:35Z"}, "message": "Only hash OutputTypes keys in non-crate-hash mode\n\nThis effectively turns OutputTypes into a hybrid where keys (OutputType)\nare TRACKED and the values (optional paths) are TRACKED_NO_CRATE_HASH.", "tree": {"sha": "1726a2cab9783c4a6909e2c61a86f0efc5a05c84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1726a2cab9783c4a6909e2c61a86f0efc5a05c84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99f652ff2247f21e3842f312ec0e8112774ebef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99f652ff2247f21e3842f312ec0e8112774ebef0", "html_url": "https://github.com/rust-lang/rust/commit/99f652ff2247f21e3842f312ec0e8112774ebef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99f652ff2247f21e3842f312ec0e8112774ebef0/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsgf", "id": 147966, "node_id": "MDQ6VXNlcjE0Nzk2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/147966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsgf", "html_url": "https://github.com/jsgf", "followers_url": "https://api.github.com/users/jsgf/followers", "following_url": "https://api.github.com/users/jsgf/following{/other_user}", "gists_url": "https://api.github.com/users/jsgf/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsgf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsgf/subscriptions", "organizations_url": "https://api.github.com/users/jsgf/orgs", "repos_url": "https://api.github.com/users/jsgf/repos", "events_url": "https://api.github.com/users/jsgf/events{/privacy}", "received_events_url": "https://api.github.com/users/jsgf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f7f2f508b78defcf9f22f1c35342c27765a1f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f7f2f508b78defcf9f22f1c35342c27765a1f0", "html_url": "https://github.com/rust-lang/rust/commit/f1f7f2f508b78defcf9f22f1c35342c27765a1f0"}], "stats": {"total": 114, "additions": 77, "deletions": 37}, "files": [{"sha": "52b3076a443962007d7316d491e2aa73d555f83e", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99f652ff2247f21e3842f312ec0e8112774ebef0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f652ff2247f21e3842f312ec0e8112774ebef0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=99f652ff2247f21e3842f312ec0e8112774ebef0", "patch": "@@ -160,9 +160,9 @@ fn test_output_types_tracking_hash_different_paths() {\n     v2.output_types = OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n     v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n \n-    assert_same_hash(&v1, &v2);\n-    assert_same_hash(&v1, &v3);\n-    assert_same_hash(&v2, &v3);\n+    assert_non_crate_hash_different(&v1, &v2);\n+    assert_non_crate_hash_different(&v1, &v3);\n+    assert_non_crate_hash_different(&v2, &v3);\n }\n \n #[test]"}, {"sha": "88eaa7fe329246a857dec29b79639bb4811acf0c", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/99f652ff2247f21e3842f312ec0e8112774ebef0/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f652ff2247f21e3842f312ec0e8112774ebef0/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=99f652ff2247f21e3842f312ec0e8112774ebef0", "patch": "@@ -31,7 +31,7 @@ use std::collections::btree_map::{\n };\n use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n use std::iter::{self, FromIterator};\n use std::path::{Path, PathBuf};\n use std::str::{self, FromStr};\n@@ -328,19 +328,9 @@ impl Default for TrimmedDefPaths {\n /// *Do not* switch `BTreeMap` out for an unsorted container type! That would break\n /// dependency tracking for command-line arguments. Also only hash keys, since tracking\n /// should only depend on the output types, not the paths they're written to.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Hash)]\n pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n \n-impl Hash for OutputTypes {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        for k in self.keys() {\n-            k.hash(hasher);\n-        }\n-    }\n-}\n-\n-impl_stable_hash_via_hash!(OutputTypes);\n-\n impl OutputTypes {\n     pub fn new(entries: &[(OutputType, Option<PathBuf>)]) -> OutputTypes {\n         OutputTypes(BTreeMap::from_iter(entries.iter().map(|&(k, ref v)| (k, v.clone()))))\n@@ -2436,8 +2426,8 @@ crate mod dep_tracking {\n     use super::LdImpl;\n     use super::{\n         CFGuard, CrateType, DebugInfo, ErrorOutputType, InstrumentCoverage, LinkerPluginLto,\n-        LtoCli, OptLevel, OutputTypes, Passes, SourceFileHashAlgorithm, SwitchWithOptPath,\n-        SymbolManglingVersion, TrimmedDefPaths,\n+        LtoCli, OptLevel, OutputType, OutputTypes, Passes, SourceFileHashAlgorithm,\n+        SwitchWithOptPath, SymbolManglingVersion, TrimmedDefPaths,\n     };\n     use crate::lint;\n     use crate::options::WasiExecModel;\n@@ -2453,25 +2443,35 @@ crate mod dep_tracking {\n     use std::path::PathBuf;\n \n     pub trait DepTrackingHash {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType);\n+        fn hash(\n+            &self,\n+            hasher: &mut DefaultHasher,\n+            error_format: ErrorOutputType,\n+            for_crate_hash: bool,\n+        );\n     }\n \n     macro_rules! impl_dep_tracking_hash_via_hash {\n         ($($t:ty),+ $(,)?) => {$(\n             impl DepTrackingHash for $t {\n-                fn hash(&self, hasher: &mut DefaultHasher, _: ErrorOutputType) {\n+                fn hash(&self, hasher: &mut DefaultHasher, _: ErrorOutputType, _for_crate_hash: bool) {\n                     Hash::hash(self, hasher);\n                 }\n             }\n         )+};\n     }\n \n     impl<T: DepTrackingHash> DepTrackingHash for Option<T> {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+        fn hash(\n+            &self,\n+            hasher: &mut DefaultHasher,\n+            error_format: ErrorOutputType,\n+            for_crate_hash: bool,\n+        ) {\n             match self {\n                 Some(x) => {\n                     Hash::hash(&1, hasher);\n-                    DepTrackingHash::hash(x, hasher, error_format);\n+                    DepTrackingHash::hash(x, hasher, error_format, for_crate_hash);\n                 }\n                 None => Hash::hash(&0, hasher),\n             }\n@@ -2501,7 +2501,6 @@ crate mod dep_tracking {\n         LtoCli,\n         DebugInfo,\n         UnstableFeatures,\n-        OutputTypes,\n         NativeLib,\n         NativeLibKind,\n         SanitizerSet,\n@@ -2515,18 +2514,24 @@ crate mod dep_tracking {\n         SourceFileHashAlgorithm,\n         TrimmedDefPaths,\n         Option<LdImpl>,\n+        OutputType,\n     );\n \n     impl<T1, T2> DepTrackingHash for (T1, T2)\n     where\n         T1: DepTrackingHash,\n         T2: DepTrackingHash,\n     {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+        fn hash(\n+            &self,\n+            hasher: &mut DefaultHasher,\n+            error_format: ErrorOutputType,\n+            for_crate_hash: bool,\n+        ) {\n             Hash::hash(&0, hasher);\n-            DepTrackingHash::hash(&self.0, hasher, error_format);\n+            DepTrackingHash::hash(&self.0, hasher, error_format, for_crate_hash);\n             Hash::hash(&1, hasher);\n-            DepTrackingHash::hash(&self.1, hasher, error_format);\n+            DepTrackingHash::hash(&self.1, hasher, error_format, for_crate_hash);\n         }\n     }\n \n@@ -2536,22 +2541,49 @@ crate mod dep_tracking {\n         T2: DepTrackingHash,\n         T3: DepTrackingHash,\n     {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+        fn hash(\n+            &self,\n+            hasher: &mut DefaultHasher,\n+            error_format: ErrorOutputType,\n+            for_crate_hash: bool,\n+        ) {\n             Hash::hash(&0, hasher);\n-            DepTrackingHash::hash(&self.0, hasher, error_format);\n+            DepTrackingHash::hash(&self.0, hasher, error_format, for_crate_hash);\n             Hash::hash(&1, hasher);\n-            DepTrackingHash::hash(&self.1, hasher, error_format);\n+            DepTrackingHash::hash(&self.1, hasher, error_format, for_crate_hash);\n             Hash::hash(&2, hasher);\n-            DepTrackingHash::hash(&self.2, hasher, error_format);\n+            DepTrackingHash::hash(&self.2, hasher, error_format, for_crate_hash);\n         }\n     }\n \n     impl<T: DepTrackingHash> DepTrackingHash for Vec<T> {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+        fn hash(\n+            &self,\n+            hasher: &mut DefaultHasher,\n+            error_format: ErrorOutputType,\n+            for_crate_hash: bool,\n+        ) {\n             Hash::hash(&self.len(), hasher);\n             for (index, elem) in self.iter().enumerate() {\n                 Hash::hash(&index, hasher);\n-                DepTrackingHash::hash(elem, hasher, error_format);\n+                DepTrackingHash::hash(elem, hasher, error_format, for_crate_hash);\n+            }\n+        }\n+    }\n+\n+    impl DepTrackingHash for OutputTypes {\n+        fn hash(\n+            &self,\n+            hasher: &mut DefaultHasher,\n+            error_format: ErrorOutputType,\n+            for_crate_hash: bool,\n+        ) {\n+            Hash::hash(&self.0.len(), hasher);\n+            for (key, val) in &self.0 {\n+                DepTrackingHash::hash(key, hasher, error_format, for_crate_hash);\n+                if !for_crate_hash {\n+                    DepTrackingHash::hash(val, hasher, error_format, for_crate_hash);\n+                }\n             }\n         }\n     }\n@@ -2561,13 +2593,14 @@ crate mod dep_tracking {\n         sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n         hasher: &mut DefaultHasher,\n         error_format: ErrorOutputType,\n+        for_crate_hash: bool,\n     ) {\n         for (key, sub_hash) in sub_hashes {\n             // Using Hash::hash() instead of DepTrackingHash::hash() is fine for\n             // the keys, as they are just plain strings\n             Hash::hash(&key.len(), hasher);\n             Hash::hash(key, hasher);\n-            sub_hash.hash(hasher, error_format);\n+            sub_hash.hash(hasher, error_format, for_crate_hash);\n         }\n     }\n }"}, {"sha": "f5dd8992c29f98c9b884b8df6a9c204ec4fb2c52", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/99f652ff2247f21e3842f312ec0e8112774ebef0/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f652ff2247f21e3842f312ec0e8112774ebef0/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=99f652ff2247f21e3842f312ec0e8112774ebef0", "patch": "@@ -48,7 +48,11 @@ macro_rules! hash_substruct {\n     ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [TRACKED_NO_CRATE_HASH]) => {{}};\n     ($opt_name:ident, $opt_expr:expr, $error_format:expr, $for_crate_hash:expr, $hasher:expr, [SUBSTRUCT]) => {\n         use crate::config::dep_tracking::DepTrackingHash;\n-        $opt_expr.dep_tracking_hash($for_crate_hash, $error_format).hash($hasher, $error_format);\n+        $opt_expr.dep_tracking_hash($for_crate_hash, $error_format).hash(\n+            $hasher,\n+            $error_format,\n+            $for_crate_hash,\n+        );\n     };\n }\n \n@@ -79,7 +83,8 @@ macro_rules! top_level_options {\n                 let mut hasher = DefaultHasher::new();\n                 dep_tracking::stable_hash(sub_hashes,\n                                           &mut hasher,\n-                                          self.error_format);\n+                                          self.error_format,\n+                                          for_crate_hash);\n                 $({\n                     hash_substruct!($opt,\n                         &self.$opt,\n@@ -236,19 +241,21 @@ macro_rules! options {\n             build_options(matches, $stat, $prefix, $outputname, error_format)\n         }\n \n-        fn dep_tracking_hash(&self, _for_crate_hash: bool, error_format: ErrorOutputType) -> u64 {\n+        fn dep_tracking_hash(&self, for_crate_hash: bool, error_format: ErrorOutputType) -> u64 {\n             let mut sub_hashes = BTreeMap::new();\n             $({\n                 hash_opt!($opt,\n                             &self.$opt,\n                             &mut sub_hashes,\n-                            _for_crate_hash,\n+                            for_crate_hash,\n                             [$dep_tracking_marker]);\n             })*\n             let mut hasher = DefaultHasher::new();\n             dep_tracking::stable_hash(sub_hashes,\n                                         &mut hasher,\n-                                        error_format);\n+                                        error_format,\n+                                        for_crate_hash\n+                                        );\n             hasher.finish()\n         }\n     }"}]}