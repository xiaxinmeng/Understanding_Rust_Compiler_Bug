{"sha": "fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhN2Y5ZDY5NmY1ODYzZGJmMjhiM2QwZWYxNGMxYmM5MTQzYjJkMjE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-13T10:58:41Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-19T15:02:06Z"}, "message": "Make Module impl methods crate-private, update some comments", "tree": {"sha": "6dbf221c3ccb3474fd37ff241961359169abae71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dbf221c3ccb3474fd37ff241961359169abae71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "html_url": "https://github.com/rust-lang/rust/commit/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5862542dedd5aca9bbdcba19c5f8cd895591005d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5862542dedd5aca9bbdcba19c5f8cd895591005d", "html_url": "https://github.com/rust-lang/rust/commit/5862542dedd5aca9bbdcba19c5f8cd895591005d"}], "stats": {"total": 31, "additions": 23, "deletions": 8}, "files": [{"sha": "73c212de8c343a101a8b6eb8e5e394d90f3ba3f0", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "patch": "@@ -95,15 +95,15 @@ impl Module {\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n+    pub(crate) fn child_impl(&self, db: &impl HirDatabase, name: &Name) -> Option<Module> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n         let child_id = loc.module_id.child(&module_tree, name)?;\n         Some(Module::from_module_id(db, loc.source_root_id, child_id))\n     }\n \n     /// Iterates over all child modules.\n-    pub fn children_impl(&self, db: &impl HirDatabase) -> impl Iterator<Item = Module> {\n+    pub(crate) fn children_impl(&self, db: &impl HirDatabase) -> impl Iterator<Item = Module> {\n         // FIXME this should be implementable without collecting into a vec, but\n         // it's kind of hard since the iterator needs to keep a reference to the\n         // module tree.\n@@ -117,21 +117,21 @@ impl Module {\n         children.into_iter()\n     }\n \n-    pub fn parent_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n+    pub(crate) fn parent_impl(&self, db: &impl HirDatabase) -> Option<Module> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n         let parent_id = loc.module_id.parent(&module_tree)?;\n         Some(Module::from_module_id(db, loc.source_root_id, parent_id))\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n+    pub(crate) fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n         let loc = self.def_id.loc(db);\n         let item_map = db.item_map(loc.source_root_id);\n         item_map.per_module[&loc.module_id].clone()\n     }\n \n-    pub fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n+    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<DefId> {\n         let mut curr_per_ns = PerNs::types(\n             match path.kind {\n                 PathKind::Crate => self.crate_root(db),\n@@ -191,7 +191,10 @@ impl Module {\n         curr_per_ns\n     }\n \n-    pub fn problems_impl(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n+    pub(crate) fn problems_impl(\n+        &self,\n+        db: &impl HirDatabase,\n+    ) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         let loc = self.def_id.loc(db);\n         let module_tree = db.module_tree(loc.source_root_id);\n         loc.module_id.problems(&module_tree, db)"}, {"sha": "c5408e277e8a913d6dbfaca3e780df99afa394d0", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "patch": "@@ -151,6 +151,15 @@ pub(crate) enum DefKind {\n     Type,\n     Item,\n \n+    /// The constructor of a struct. E.g. if we have `struct Foo(usize)`, the\n+    /// name `Foo` needs to resolve to different types depending on whether we\n+    /// are in the types or values namespace: As a type, `Foo` of course refers\n+    /// to the struct `Foo`; as a value, `Foo` is a callable type with signature\n+    /// `(usize) -> Foo`. The cleanest approach to handle this seems to be to\n+    /// have different defs in the two namespaces.\n+    ///\n+    /// rustc does the same; note that it even creates a struct constructor if\n+    /// the struct isn't a tuple struct (see `CtorKind::Fictive` in rustc).\n     StructCtor,\n }\n "}, {"sha": "8e93a445789ac833ec624d960056bd10b732d6bd", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=fa7f9d696f5863dbf28b3d0ef14c1bc9143b2d21", "patch": "@@ -242,7 +242,8 @@ pub enum Ty {\n     // Opaque(DefId, Substs),\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param {\n-        /// The index of the parameter.\n+        /// The index of the parameter (starting with parameters from the\n+        /// surrounding impl, then the current function).\n         idx: u32,\n         /// The name of the parameter, for displaying.\n         name: Name,\n@@ -440,7 +441,9 @@ impl Ty {\n                 if (idx as usize) < substs.0.len() {\n                     substs.0[idx as usize].clone()\n                 } else {\n-                    // TODO it's yet unclear to me whether we need to shift the indices here\n+                    // TODO: does this indicate a bug? i.e. should we always\n+                    // have substs for all type params? (they might contain the\n+                    // params themselves again...)\n                     Ty::Param { idx, name }\n                 }\n             }"}]}