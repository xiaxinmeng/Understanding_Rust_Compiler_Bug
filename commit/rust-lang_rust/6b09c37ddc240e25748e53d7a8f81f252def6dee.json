{"sha": "6b09c37ddc240e25748e53d7a8f81f252def6dee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiMDljMzdkZGMyNDBlMjU3NDhlNTNkN2E4ZjgxZjI1MmRlZjZkZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-30T14:36:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-30T14:36:41Z"}, "message": "Auto merge of #73990 - jumbatm:clashing-extern-decl, r=nagisa\n\nFix incorrect clashing_extern_declarations warnings.\n\nFixes #73735, fixes #73872.\n\nFix clashing_extern_declarations warning for `#[repr(transparent)]` structs and safely-FFI-convertible enums, and not warning for clashes of struct members of different types, but the same size.\n\nr? @nagisa", "tree": {"sha": "cf776af8e0a57ff674b2828f93a0ceb5bdc002f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf776af8e0a57ff674b2828f93a0ceb5bdc002f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b09c37ddc240e25748e53d7a8f81f252def6dee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b09c37ddc240e25748e53d7a8f81f252def6dee", "html_url": "https://github.com/rust-lang/rust/commit/6b09c37ddc240e25748e53d7a8f81f252def6dee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b09c37ddc240e25748e53d7a8f81f252def6dee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21867225a74d3b07c2b65e32c67f45197db36896", "url": "https://api.github.com/repos/rust-lang/rust/commits/21867225a74d3b07c2b65e32c67f45197db36896", "html_url": "https://github.com/rust-lang/rust/commit/21867225a74d3b07c2b65e32c67f45197db36896"}, {"sha": "0bd292dea1a8f6e60ac8957ac0fcd0d237034918", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd292dea1a8f6e60ac8957ac0fcd0d237034918", "html_url": "https://github.com/rust-lang/rust/commit/0bd292dea1a8f6e60ac8957ac0fcd0d237034918"}], "stats": {"total": 617, "additions": 456, "deletions": 161}, "files": [{"sha": "06e7c2b6f36256b460cc714241ba38716195240d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6b09c37ddc240e25748e53d7a8f81f252def6dee", "patch": "@@ -20,7 +20,9 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n-use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{\n+    types::CItemKind, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n+};\n use rustc_ast::ast::{self, Expr};\n use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -36,14 +38,14 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n use rustc_hir::{HirId, HirIdSet, Node};\n use rustc_middle::lint::LintDiagnosticBuilder;\n-use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{LayoutOf, VariantIdx};\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n@@ -2144,7 +2146,13 @@ impl ClashingExternDeclarations {\n     /// Checks whether two types are structurally the same enough that the declarations shouldn't\n     /// clash. We need this so we don't emit a lint when two modules both declare an extern struct,\n     /// with the same members (as the declarations shouldn't clash).\n-    fn structurally_same_type<'tcx>(cx: &LateContext<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    fn structurally_same_type<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        ckind: CItemKind,\n+    ) -> bool {\n+        debug!(\"structurally_same_type(cx, a = {:?}, b = {:?})\", a, b);\n         let tcx = cx.tcx;\n         if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n             // All nominally-same types are structurally same, too.\n@@ -2155,47 +2163,77 @@ impl ClashingExternDeclarations {\n             let a_kind = &a.kind;\n             let b_kind = &b.kind;\n \n+            let compare_layouts = |a, b| -> bool {\n+                let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n+                let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n+                debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n+                a_layout == b_layout\n+            };\n+\n+            #[allow(rustc::usage_of_ty_tykind)]\n+            let is_primitive_or_pointer =\n+                |kind: &ty::TyKind<'_>| kind.is_primitive() || matches!(kind, RawPtr(..));\n+\n             match (a_kind, b_kind) {\n-                (Adt(..), Adt(..)) => {\n-                    // Adts are pretty straightforward: just compare the layouts.\n-                    use rustc_target::abi::LayoutOf;\n-                    let a_layout = cx.layout_of(a).unwrap().layout;\n-                    let b_layout = cx.layout_of(b).unwrap().layout;\n-                    a_layout == b_layout\n+                (Adt(_, a_substs), Adt(_, b_substs)) => {\n+                    let a = a.subst(cx.tcx, a_substs);\n+                    let b = b.subst(cx.tcx, b_substs);\n+                    debug!(\"Comparing {:?} and {:?}\", a, b);\n+\n+                    if let (Adt(a_def, ..), Adt(b_def, ..)) = (&a.kind, &b.kind) {\n+                        // Grab a flattened representation of all fields.\n+                        let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n+                        let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                        compare_layouts(a, b)\n+                            && a_fields.eq_by(\n+                                b_fields,\n+                                |&ty::FieldDef { did: a_did, .. },\n+                                 &ty::FieldDef { did: b_did, .. }| {\n+                                    Self::structurally_same_type(\n+                                        cx,\n+                                        tcx.type_of(a_did),\n+                                        tcx.type_of(b_did),\n+                                        ckind,\n+                                    )\n+                                },\n+                            )\n+                    } else {\n+                        unreachable!()\n+                    }\n                 }\n                 (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n                     // For arrays, we also check the constness of the type.\n                     a_const.val == b_const.val\n-                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty)\n-                        && Self::structurally_same_type(cx, a_ty, b_ty)\n+                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty, ckind)\n+                        && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                 }\n-                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty),\n+                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty, ckind),\n                 (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n                     a_tymut.mutbl == a_tymut.mutbl\n-                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty)\n+                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty, ckind)\n                 }\n                 (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n                     // For structural sameness, we don't need the region to be same.\n-                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty)\n+                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                 }\n                 (FnDef(..), FnDef(..)) => {\n-                    // As we don't compare regions, skip_binder is fine.\n                     let a_poly_sig = a.fn_sig(tcx);\n                     let b_poly_sig = b.fn_sig(tcx);\n \n+                    // As we don't compare regions, skip_binder is fine.\n                     let a_sig = a_poly_sig.skip_binder();\n                     let b_sig = b_poly_sig.skip_binder();\n \n                     (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n                         == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n                         && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                            Self::structurally_same_type(cx, a, b)\n+                            Self::structurally_same_type(cx, a, b, ckind)\n                         })\n-                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output())\n+                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output(), ckind)\n                 }\n                 (Tuple(a_substs), Tuple(b_substs)) => {\n                     a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n-                        Self::structurally_same_type(cx, a_ty, b_ty)\n+                        Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                     })\n                 }\n                 // For these, it's not quite as easy to define structural-sameness quite so easily.\n@@ -2208,9 +2246,27 @@ impl ClashingExternDeclarations {\n                 | (GeneratorWitness(..), GeneratorWitness(..))\n                 | (Projection(..), Projection(..))\n                 | (Opaque(..), Opaque(..)) => false,\n+\n                 // These definitely should have been caught above.\n                 (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n-                _ => false,\n+\n+                // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n+                // non-null field.\n+                (Adt(..), other_kind) | (other_kind, Adt(..))\n+                    if is_primitive_or_pointer(other_kind) =>\n+                {\n+                    let (primitive, adt) =\n+                        if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                    if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                        ty == primitive\n+                    } else {\n+                        compare_layouts(a, b)\n+                    }\n+                }\n+                // Otherwise, just compare the layouts. This may fail to lint for some\n+                // incompatible types, but at the very least, will stop reads into\n+                // uninitialised memory.\n+                _ => compare_layouts(a, b),\n             }\n         }\n     }\n@@ -2231,7 +2287,12 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     existing_hid, existing_decl_ty, this_fi.hir_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n-                if !Self::structurally_same_type(cx, existing_decl_ty, this_decl_ty) {\n+                if !Self::structurally_same_type(\n+                    cx,\n+                    existing_decl_ty,\n+                    this_decl_ty,\n+                    CItemKind::Declaration,\n+                ) {\n                     let orig_fi = tcx.hir().expect_foreign_item(existing_hid);\n                     let orig = Self::name_of_extern_decl(tcx, orig_fi);\n "}, {"sha": "de750010ed1e6e1af3a4557d615508191e424809", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 128, "deletions": 74, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=6b09c37ddc240e25748e53d7a8f81f252def6dee", "patch": "@@ -15,8 +15,9 @@ use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi::Abi;\n use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::abi::Abi as SpecAbi;\n \n use log::debug;\n use std::cmp;\n@@ -509,14 +510,15 @@ declare_lint! {\n \n declare_lint_pass!(ImproperCTypesDefinitions => [IMPROPER_CTYPES_DEFINITIONS]);\n \n-enum ImproperCTypesMode {\n-    Declarations,\n-    Definitions,\n+#[derive(Clone, Copy)]\n+crate enum CItemKind {\n+    Declaration,\n+    Definition,\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    mode: ImproperCTypesMode,\n+    mode: CItemKind,\n }\n \n enum FfiResult<'tcx> {\n@@ -525,54 +527,94 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    /// Is type known to be non-null?\n-    fn ty_is_known_nonnull(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.kind {\n-            ty::FnPtr(_) => true,\n-            ty::Ref(..) => true,\n-            ty::Adt(def, _)\n-                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n-                true\n-            }\n-            ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n-                let guaranteed_nonnull_optimization = self\n-                    .cx\n-                    .tcx\n-                    .get_attrs(def.did)\n-                    .iter()\n-                    .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n-\n-                if guaranteed_nonnull_optimization {\n-                    return true;\n-                }\n+/// Is type known to be non-null?\n+fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n+    let tcx = cx.tcx;\n+    match ty.kind {\n+        ty::FnPtr(_) => true,\n+        ty::Ref(..) => true,\n+        ty::Adt(def, _) if def.is_box() && matches!(mode, CItemKind::Definition) => true,\n+        ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n+            let guaranteed_nonnull_optimization = tcx\n+                .get_attrs(def.did)\n+                .iter()\n+                .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n \n-                for variant in &def.variants {\n-                    if let Some(field) = variant.transparent_newtype_field(self.cx.tcx) {\n-                        if self.ty_is_known_nonnull(field.ty(self.cx.tcx, substs)) {\n-                            return true;\n-                        }\n+            if guaranteed_nonnull_optimization {\n+                return true;\n+            }\n+            for variant in &def.variants {\n+                if let Some(field) = variant.transparent_newtype_field(tcx) {\n+                    if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {\n+                        return true;\n                     }\n                 }\n-\n-                false\n             }\n-            _ => false,\n+\n+            false\n         }\n+        _ => false,\n     }\n+}\n+/// Given a non-null scalar (or transparent) type `ty`, return the nullable version of that type.\n+/// If the type passed in was not scalar, returns None.\n+fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    let tcx = cx.tcx;\n+    Some(match ty.kind {\n+        ty::Adt(field_def, field_substs) => {\n+            let inner_field_ty = {\n+                let first_non_zst_ty =\n+                    field_def.variants.iter().filter_map(|v| v.transparent_newtype_field(tcx));\n+                debug_assert_eq!(\n+                    first_non_zst_ty.clone().count(),\n+                    1,\n+                    \"Wrong number of fields for transparent type\"\n+                );\n+                first_non_zst_ty\n+                    .last()\n+                    .expect(\"No non-zst fields in transparent type.\")\n+                    .ty(tcx, field_substs)\n+            };\n+            return get_nullable_type(cx, inner_field_ty);\n+        }\n+        ty::Int(ty) => tcx.mk_mach_int(ty),\n+        ty::Uint(ty) => tcx.mk_mach_uint(ty),\n+        ty::RawPtr(ty_mut) => tcx.mk_ptr(ty_mut),\n+        // As these types are always non-null, the nullable equivalent of\n+        // Option<T> of these types are their raw pointer counterparts.\n+        ty::Ref(_region, ty, mutbl) => tcx.mk_ptr(ty::TypeAndMut { ty, mutbl }),\n+        ty::FnPtr(..) => {\n+            // There is no nullable equivalent for Rust's function pointers -- you\n+            // must use an Option<fn(..) -> _> to represent it.\n+            ty\n+        }\n \n-    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\".\n-    /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n-    /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n-    fn is_repr_nullable_ptr(\n-        &self,\n-        ty: Ty<'tcx>,\n-        ty_def: &'tcx ty::AdtDef,\n-        substs: SubstsRef<'tcx>,\n-    ) -> bool {\n+        // We should only ever reach this case if ty_is_known_nonnull is extended\n+        // to other types.\n+        ref unhandled => {\n+            debug!(\n+                \"get_nullable_type: Unhandled scalar kind: {:?} while checking {:?}\",\n+                unhandled, ty\n+            );\n+            return None;\n+        }\n+    })\n+}\n+\n+/// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If it\n+/// can, return the the type that `ty` can be safely converted to, otherwise return `None`.\n+/// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n+/// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n+/// FIXME: This duplicates code in codegen.\n+crate fn repr_nullable_ptr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    ckind: CItemKind,\n+) -> Option<Ty<'tcx>> {\n+    debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n+    if let ty::Adt(ty_def, substs) = ty.kind {\n         if ty_def.variants.len() != 2 {\n-            return false;\n+            return None;\n         }\n \n         let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n@@ -582,30 +624,42 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         } else if variant_fields[1].is_empty() {\n             &variant_fields[0]\n         } else {\n-            return false;\n+            return None;\n         };\n \n         if fields.len() != 1 {\n-            return false;\n+            return None;\n         }\n \n-        let field_ty = fields[0].ty(self.cx.tcx, substs);\n-        if !self.ty_is_known_nonnull(field_ty) {\n-            return false;\n+        let field_ty = fields[0].ty(cx.tcx, substs);\n+        if !ty_is_known_nonnull(cx, field_ty, ckind) {\n+            return None;\n         }\n \n-        // At this point, the field's type is known to be nonnull and the parent enum is\n-        // Option-like. If the computed size for the field and the enum are different, the non-null\n-        // optimization isn't being applied (and we've got a problem somewhere).\n-        let compute_size_skeleton =\n-            |t| SizeSkeleton::compute(t, self.cx.tcx, self.cx.param_env).unwrap();\n+        // At this point, the field's type is known to be nonnull and the parent enum is Option-like.\n+        // If the computed size for the field and the enum are different, the nonnull optimization isn't\n+        // being applied (and we've got a problem somewhere).\n+        let compute_size_skeleton = |t| SizeSkeleton::compute(t, cx.tcx, cx.param_env).unwrap();\n         if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n             bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n         }\n \n-        true\n+        // Return the nullable type this Option-like enum can be safely represented with.\n+        let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n+        if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n+            match (field_ty_scalar.valid_range.start(), field_ty_scalar.valid_range.end()) {\n+                (0, _) => unreachable!(\"Non-null optimisation extended to a non-zero value.\"),\n+                (1, _) => {\n+                    return Some(get_nullable_type(cx, field_ty).unwrap());\n+                }\n+                (start, end) => unreachable!(\"Unhandled start and end range: ({}, {})\", start, end),\n+            };\n+        }\n     }\n+    None\n+}\n \n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the type is array and emit an unsafe type lint.\n     fn check_for_array_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         if let ty::Array(..) = ty.kind {\n@@ -686,7 +740,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult<'tcx> {\n         use FfiResult::*;\n \n-        let cx = self.cx.tcx;\n+        let tcx = self.cx.tcx;\n \n         // Protect against infinite recursion, for example\n         // `struct S(*mut S);`.\n@@ -697,9 +751,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.kind {\n-            ty::Adt(def, _)\n-                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n+            ty::Adt(def, _) if def.is_box() && matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n \n@@ -753,7 +805,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if !self.is_repr_nullable_ptr(ty, def, substs) {\n+                            if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n                                     reason: \"enum has no representation hint\".into(),\n@@ -836,7 +888,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n                 if {\n-                    matches!(self.mode, ImproperCTypesMode::Definitions)\n+                    matches!(self.mode, CItemKind::Definition)\n                         && ty.is_sized(self.cx.tcx.at(DUMMY_SP), self.cx.param_env)\n                 } =>\n             {\n@@ -862,7 +914,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     };\n                 }\n \n-                let sig = cx.erase_late_bound_regions(&sig);\n+                let sig = tcx.erase_late_bound_regions(&sig);\n                 if !sig.output().is_unit() {\n                     let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {\n@@ -894,9 +946,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Projection(..)\n-                if matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n+            ty::Param(..) | ty::Projection(..) if matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n \n@@ -921,14 +971,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         help: Option<&str>,\n     ) {\n         let lint = match self.mode {\n-            ImproperCTypesMode::Declarations => IMPROPER_CTYPES,\n-            ImproperCTypesMode::Definitions => IMPROPER_CTYPES_DEFINITIONS,\n+            CItemKind::Declaration => IMPROPER_CTYPES,\n+            CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n \n         self.cx.struct_span_lint(lint, sp, |lint| {\n             let item_description = match self.mode {\n-                ImproperCTypesMode::Declarations => \"block\",\n-                ImproperCTypesMode::Definitions => \"fn\",\n+                CItemKind::Declaration => \"block\",\n+                CItemKind::Definition => \"fn\",\n             };\n             let mut diag = lint.build(&format!(\n                 \"`extern` {} uses type `{}`, which is not FFI-safe\",\n@@ -1052,8 +1102,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n \n-    fn is_internal_abi(&self, abi: Abi) -> bool {\n-        if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n+    fn is_internal_abi(&self, abi: SpecAbi) -> bool {\n+        if let SpecAbi::Rust\n+        | SpecAbi::RustCall\n+        | SpecAbi::RustIntrinsic\n+        | SpecAbi::PlatformIntrinsic = abi\n+        {\n             true\n         } else {\n             false\n@@ -1063,7 +1117,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, it: &hir::ForeignItem<'_>) {\n-        let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Declarations };\n+        let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Declaration };\n         let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n \n         if !vis.is_internal_abi(abi) {\n@@ -1098,7 +1152,7 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {\n             _ => return,\n         };\n \n-        let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Definitions };\n+        let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Definition };\n         if !vis.is_internal_abi(abi) {\n             vis.check_foreign_fn(hir_id, decl);\n         }"}, {"sha": "310ab4f7235ebf8e57fc4d5b8603619b62e6c81a", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=6b09c37ddc240e25748e53d7a8f81f252def6dee", "patch": "@@ -202,6 +202,16 @@ pub enum TyKind<'tcx> {\n     Error(DelaySpanBugEmitted),\n }\n \n+impl TyKind<'tcx> {\n+    #[inline]\n+    pub fn is_primitive(&self) -> bool {\n+        match self {\n+            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n /// except through `tcx.err*()`.\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -1766,10 +1776,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n-        match self.kind {\n-            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n-            _ => false,\n-        }\n+        self.kind.is_primitive()\n     }\n \n     #[inline]"}, {"sha": "c2a8cadc6b5f8615e726842be5f35821b4a9e42c", "filename": "src/test/ui/lint/auxiliary/external_extern_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fexternal_extern_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fexternal_extern_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fexternal_extern_fn.rs?ref=6b09c37ddc240e25748e53d7a8f81f252def6dee", "patch": "@@ -1,3 +1,3 @@\n-extern {\n+extern \"C\" {\n     pub fn extern_fn(x: u8);\n }"}, {"sha": "d6ac7ccccc77b1c6b111ac80855efa81d0d5eb16", "filename": "src/test/ui/lint/clashing-extern-fn.rs", "status": "modified", "additions": 137, "deletions": 36, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=6b09c37ddc240e25748e53d7a8f81f252def6dee", "patch": "@@ -3,52 +3,40 @@\n #![crate_type = \"lib\"]\n #![warn(clashing_extern_declarations)]\n \n-extern crate external_extern_fn;\n-\n-extern \"C\" {\n-    fn clash(x: u8);\n-    fn no_clash(x: u8);\n-}\n-\n-fn redeclared_different_signature() {\n-    extern \"C\" {\n-        fn clash(x: u64); //~ WARN `clash` redeclared with a different signature\n+mod redeclared_different_signature {\n+    mod a {\n+        extern \"C\" {\n+            fn clash(x: u8);\n+        }\n     }\n-\n-    unsafe {\n-        clash(123);\n-        no_clash(123);\n+    mod b {\n+        extern \"C\" {\n+            fn clash(x: u64); //~ WARN `clash` redeclared with a different signature\n+        }\n     }\n }\n \n-fn redeclared_same_signature() {\n-    extern \"C\" {\n-        fn no_clash(x: u8);\n+mod redeclared_same_signature {\n+    mod a {\n+        extern \"C\" {\n+            fn no_clash(x: u8);\n+        }\n     }\n-    unsafe {\n-        no_clash(123);\n+    mod b {\n+        extern \"C\" {\n+            fn no_clash(x: u8);\n+        }\n     }\n }\n \n-extern \"C\" {\n-    fn extern_fn(x: u64);\n-}\n-\n-fn extern_clash() {\n+extern crate external_extern_fn;\n+mod extern_no_clash {\n+    // Should not clash with external_extern_fn::extern_fn.\n     extern \"C\" {\n-        fn extern_fn(x: u32); //~ WARN `extern_fn` redeclared with a different signature\n-    }\n-    unsafe {\n-        extern_fn(123);\n+        fn extern_fn(x: u8);\n     }\n }\n \n-fn extern_no_clash() {\n-    unsafe {\n-        external_extern_fn::extern_fn(123);\n-        crate::extern_fn(123);\n-    }\n-}\n extern \"C\" {\n     fn some_other_new_name(x: i16);\n \n@@ -134,9 +122,9 @@ mod banana {\n             weight: u32,\n             length: u16,\n         } // note: distinct type\n-        extern \"C\" {\n           // This should not trigger the lint because two::Banana is structurally equivalent to\n           // one::Banana.\n+        extern \"C\" {\n             fn weigh_banana(count: *const Banana) -> u64;\n         }\n     }\n@@ -180,7 +168,120 @@ mod sameish_members {\n         // always be the case, for every architecture and situation. This is also a really odd\n         // thing to do anyway.\n         extern \"C\" {\n-            fn draw_point(p: Point); //~ WARN `draw_point` redeclared with a different\n+            fn draw_point(p: Point);\n+            //~^ WARN `draw_point` redeclared with a different signature\n+        }\n+    }\n+}\n+\n+mod same_sized_members_clash {\n+    mod a {\n+        #[repr(C)]\n+        struct Point3 {\n+            x: f32,\n+            y: f32,\n+            z: f32,\n+        }\n+        extern \"C\" { fn origin() -> Point3; }\n+    }\n+    mod b {\n+        #[repr(C)]\n+        struct Point3 {\n+            x: i32,\n+            y: i32,\n+            z: i32, // NOTE: Incorrectly redeclared as i32\n+        }\n+        extern \"C\" { fn origin() -> Point3; }\n+        //~^ WARN `origin` redeclared with a different signature\n+    }\n+}\n+\n+mod transparent {\n+    #[repr(transparent)]\n+    struct T(usize);\n+    mod a {\n+        use super::T;\n+        extern \"C\" {\n+            fn transparent() -> T;\n+            fn transparent_incorrect() -> T;\n+        }\n+    }\n+\n+    mod b {\n+        extern \"C\" {\n+            // Shouldn't warn here, because repr(transparent) guarantees that T's layout is the\n+            // same as just the usize.\n+            fn transparent() -> usize;\n+\n+            // Should warn, because there's a signedness conversion here:\n+            fn transparent_incorrect() -> isize;\n+            //~^ WARN `transparent_incorrect` redeclared with a different signature\n+        }\n+    }\n+}\n+\n+mod missing_return_type {\n+    mod a {\n+        extern \"C\" {\n+            fn missing_return_type() -> usize;\n+        }\n+    }\n+\n+    mod b {\n+        extern \"C\" {\n+            // This should output a warning because we can't assume that the first declaration is\n+            // the correct one -- if this one is the correct one, then calling the usize-returning\n+            // version would allow reads into uninitialised memory.\n+            fn missing_return_type();\n+            //~^ WARN `missing_return_type` redeclared with a different signature\n+        }\n+    }\n+}\n+\n+mod non_zero_and_non_null {\n+    mod a {\n+        extern \"C\" {\n+            fn non_zero_usize() -> core::num::NonZeroUsize;\n+            fn non_null_ptr() -> core::ptr::NonNull<usize>;\n+        }\n+    }\n+    mod b {\n+        extern \"C\" {\n+            // If there's a clash in either of these cases you're either gaining an incorrect\n+            // invariant that the value is non-zero, or you're missing out on that invariant. Both\n+            // cases are warning for, from both a caller-convenience and optimisation perspective.\n+            fn non_zero_usize() -> usize;\n+            //~^ WARN `non_zero_usize` redeclared with a different signature\n+            fn non_null_ptr() -> *const usize;\n+            //~^ WARN `non_null_ptr` redeclared with a different signature\n+        }\n+    }\n+}\n+\n+mod null_optimised_enums {\n+    mod a {\n+        extern \"C\" {\n+            fn option_non_zero_usize() -> usize;\n+            fn option_non_zero_isize() -> isize;\n+            fn option_non_null_ptr() -> *const usize;\n+\n+            fn option_non_zero_usize_incorrect() -> usize;\n+            fn option_non_null_ptr_incorrect() -> *const usize;\n+        }\n+    }\n+    mod b {\n+        extern \"C\" {\n+            // This should be allowed, because these conversions are guaranteed to be FFI-safe (see\n+            // #60300)\n+            fn option_non_zero_usize() -> Option<core::num::NonZeroUsize>;\n+            fn option_non_zero_isize() -> Option<core::num::NonZeroIsize>;\n+            fn option_non_null_ptr() -> Option<core::ptr::NonNull<usize>>;\n+\n+            // However, these should be incorrect (note isize instead of usize)\n+            fn option_non_zero_usize_incorrect() -> isize;\n+            //~^ WARN `option_non_zero_usize_incorrect` redeclared with a different signature\n+            fn option_non_null_ptr_incorrect() -> *const isize;\n+            //~^ WARN `option_non_null_ptr_incorrect` redeclared with a different signature\n         }\n     }\n }"}, {"sha": "cca0c4c59eb197166f08f901e65b006c604281da", "filename": "src/test/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 97, "deletions": 25, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b09c37ddc240e25748e53d7a8f81f252def6dee/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=6b09c37ddc240e25748e53d7a8f81f252def6dee", "patch": "@@ -1,11 +1,11 @@\n warning: `clash` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:15:9\n+  --> $DIR/clashing-extern-fn.rs:14:13\n    |\n-LL |     fn clash(x: u8);\n-   |     ---------------- `clash` previously declared here\n+LL |             fn clash(x: u8);\n+   |             ---------------- `clash` previously declared here\n ...\n-LL |         fn clash(x: u64);\n-   |         ^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+LL |             fn clash(x: u64);\n+   |             ^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n    |\n note: the lint level is defined here\n   --> $DIR/clashing-extern-fn.rs:4:9\n@@ -15,20 +15,8 @@ LL | #![warn(clashing_extern_declarations)]\n    = note: expected `unsafe extern \"C\" fn(u8)`\n               found `unsafe extern \"C\" fn(u64)`\n \n-warning: `extern_fn` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:39:9\n-   |\n-LL |     fn extern_fn(x: u64);\n-   |     --------------------- `extern_fn` previously declared here\n-...\n-LL |         fn extern_fn(x: u32);\n-   |         ^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n-   |\n-   = note: expected `unsafe extern \"C\" fn(u64)`\n-              found `unsafe extern \"C\" fn(u32)`\n-\n warning: `extern_link_name` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:64:9\n+  --> $DIR/clashing-extern-fn.rs:52:9\n    |\n LL | /     #[link_name = \"extern_link_name\"]\n LL | |     fn some_new_name(x: i16);\n@@ -41,7 +29,7 @@ LL |           fn extern_link_name(x: u32);\n               found `unsafe extern \"C\" fn(u32)`\n \n warning: `some_other_extern_link_name` redeclares `some_other_new_name` with a different signature\n-  --> $DIR/clashing-extern-fn.rs:67:9\n+  --> $DIR/clashing-extern-fn.rs:55:9\n    |\n LL |       fn some_other_new_name(x: i16);\n    |       ------------------------------- `some_other_new_name` previously declared here\n@@ -55,7 +43,7 @@ LL | |         fn some_other_extern_link_name(x: u32);\n               found `unsafe extern \"C\" fn(u32)`\n \n warning: `other_both_names_different` redeclares `link_name_same` with a different signature\n-  --> $DIR/clashing-extern-fn.rs:71:9\n+  --> $DIR/clashing-extern-fn.rs:59:9\n    |\n LL | /     #[link_name = \"link_name_same\"]\n LL | |     fn both_names_different(x: i16);\n@@ -70,7 +58,7 @@ LL | |         fn other_both_names_different(x: u32);\n               found `unsafe extern \"C\" fn(u32)`\n \n warning: `different_mod` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:84:9\n+  --> $DIR/clashing-extern-fn.rs:72:9\n    |\n LL |         fn different_mod(x: u8);\n    |         ------------------------ `different_mod` previously declared here\n@@ -82,7 +70,7 @@ LL |         fn different_mod(x: u64);\n               found `unsafe extern \"C\" fn(u64)`\n \n warning: `variadic_decl` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:94:9\n+  --> $DIR/clashing-extern-fn.rs:82:9\n    |\n LL |     fn variadic_decl(x: u8, ...);\n    |     ----------------------------- `variadic_decl` previously declared here\n@@ -94,7 +82,7 @@ LL |         fn variadic_decl(x: u8);\n               found `unsafe extern \"C\" fn(u8)`\n \n warning: `weigh_banana` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:154:13\n+  --> $DIR/clashing-extern-fn.rs:142:13\n    |\n LL |             fn weigh_banana(count: *const Banana) -> u64;\n    |             --------------------------------------------- `weigh_banana` previously declared here\n@@ -106,7 +94,7 @@ LL |             fn weigh_banana(count: *const Banana) -> u64;\n               found `unsafe extern \"C\" fn(*const banana::three::Banana) -> u64`\n \n warning: `draw_point` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:183:13\n+  --> $DIR/clashing-extern-fn.rs:171:13\n    |\n LL |             fn draw_point(p: Point);\n    |             ------------------------ `draw_point` previously declared here\n@@ -117,5 +105,89 @@ LL |             fn draw_point(p: Point);\n    = note: expected `unsafe extern \"C\" fn(sameish_members::a::Point)`\n               found `unsafe extern \"C\" fn(sameish_members::b::Point)`\n \n-warning: 9 warnings emitted\n+warning: `origin` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:194:22\n+   |\n+LL |         extern \"C\" { fn origin() -> Point3; }\n+   |                      ---------------------- `origin` previously declared here\n+...\n+LL |         extern \"C\" { fn origin() -> Point3; }\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> same_sized_members_clash::a::Point3`\n+              found `unsafe extern \"C\" fn() -> same_sized_members_clash::b::Point3`\n+\n+warning: `transparent_incorrect` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:217:13\n+   |\n+LL |             fn transparent_incorrect() -> T;\n+   |             -------------------------------- `transparent_incorrect` previously declared here\n+...\n+LL |             fn transparent_incorrect() -> isize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> transparent::T`\n+              found `unsafe extern \"C\" fn() -> isize`\n+\n+warning: `missing_return_type` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:235:13\n+   |\n+LL |             fn missing_return_type() -> usize;\n+   |             ---------------------------------- `missing_return_type` previously declared here\n+...\n+LL |             fn missing_return_type();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> usize`\n+              found `unsafe extern \"C\" fn()`\n+\n+warning: `non_zero_usize` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:253:13\n+   |\n+LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n+   |             ----------------------------------------------- `non_zero_usize` previously declared here\n+...\n+LL |             fn non_zero_usize() -> usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> std::num::NonZeroUsize`\n+              found `unsafe extern \"C\" fn() -> usize`\n+\n+warning: `non_null_ptr` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:255:13\n+   |\n+LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n+   |             ----------------------------------------------- `non_null_ptr` previously declared here\n+...\n+LL |             fn non_null_ptr() -> *const usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> std::ptr::NonNull<usize>`\n+              found `unsafe extern \"C\" fn() -> *const usize`\n+\n+warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:281:13\n+   |\n+LL |             fn option_non_zero_usize_incorrect() -> usize;\n+   |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n+...\n+LL |             fn option_non_zero_usize_incorrect() -> isize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> usize`\n+              found `unsafe extern \"C\" fn() -> isize`\n+\n+warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:283:13\n+   |\n+LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n+   |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here\n+...\n+LL |             fn option_non_null_ptr_incorrect() -> *const isize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> *const usize`\n+              found `unsafe extern \"C\" fn() -> *const isize`\n+\n+warning: 15 warnings emitted\n "}]}