{"sha": "ae8b3e8fc6e95a0f68fc49338f394d670e233883", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlOGIzZThmYzZlOTVhMGY2OGZjNDkzMzhmMzk0ZDY3MGUyMzM4ODM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-23T02:45:21Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-23T15:50:06Z"}, "message": "Introduce a diagnostic stashing API.", "tree": {"sha": "1bf3feee7671515ce6921ea2c1bf041eb3e96e93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bf3feee7671515ce6921ea2c1bf041eb3e96e93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae8b3e8fc6e95a0f68fc49338f394d670e233883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae8b3e8fc6e95a0f68fc49338f394d670e233883", "html_url": "https://github.com/rust-lang/rust/commit/ae8b3e8fc6e95a0f68fc49338f394d670e233883", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae8b3e8fc6e95a0f68fc49338f394d670e233883/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66bf391c3aabfc77f5f7139fc9e6944f995d574e", "url": "https://api.github.com/repos/rust-lang/rust/commits/66bf391c3aabfc77f5f7139fc9e6944f995d574e", "html_url": "https://github.com/rust-lang/rust/commit/66bf391c3aabfc77f5f7139fc9e6944f995d574e"}], "stats": {"total": 129, "additions": 102, "deletions": 27}, "files": [{"sha": "49342d95fdb0359727a9d557a26341cf53762f39", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ae8b3e8fc6e95a0f68fc49338f394d670e233883", "patch": "@@ -321,6 +321,7 @@ impl Session {\n     }\n     pub fn compile_status(&self) -> Result<(), ErrorReported> {\n         if self.has_errors() {\n+            self.diagnostic().emit_stashed_diagnostics();\n             Err(ErrorReported)\n         } else {\n             Ok(())"}, {"sha": "4a8681367410e3cd76c66feb5244df6dd922d013", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ae8b3e8fc6e95a0f68fc49338f394d670e233883", "patch": "@@ -296,7 +296,6 @@ pub fn run_compiler(\n                     );\n                     Ok(())\n                 })?;\n-                return sess.compile_status();\n             } else {\n                 let mut krate = compiler.parse()?.take();\n                 pretty::visit_crate(sess, &mut krate, ppm);\n@@ -307,8 +306,8 @@ pub fn run_compiler(\n                     ppm,\n                     compiler.output_file().as_ref().map(|p| &**p),\n                 );\n-                return sess.compile_status();\n             }\n+            return sess.compile_status();\n         }\n \n         if callbacks.after_parsing(compiler) == Compilation::Stop {"}, {"sha": "cc60bf89c7ecac3dd3104d89577a7ab6c07d5234", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=ae8b3e8fc6e95a0f68fc49338f394d670e233883", "patch": "@@ -1,10 +1,6 @@\n-use crate::Diagnostic;\n-use crate::DiagnosticId;\n-use crate::DiagnosticStyledString;\n-use crate::Applicability;\n+use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString};\n+use crate::{Applicability, Level, Handler, StashKey};\n \n-use crate::Level;\n-use crate::Handler;\n use std::fmt::{self, Debug};\n use std::ops::{Deref, DerefMut};\n use std::thread::panicking;\n@@ -117,18 +113,30 @@ impl<'a> DiagnosticBuilder<'a> {\n         }\n     }\n \n-    /// Buffers the diagnostic for later emission, unless handler\n-    /// has disabled such buffering.\n-    pub fn buffer(mut self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+    /// Stashes diagnostic for possible later improvement in a different,\n+    /// later stage of the compiler. The diagnostic can be accessed with\n+    /// the provided `span` and `key` through `.steal_diagnostic` on `Handler`.\n+    ///\n+    /// As with `buffer`, this is unless the handler has disabled such buffering.\n+    pub fn stash(self, span: Span, key: StashKey) {\n+        if let Some((diag, handler)) = self.into_diagnostic() {\n+            handler.stash_diagnostic(span, key, diag);\n+        }\n+    }\n+\n+    /// Converts the builder to a `Diagnostic` for later emission,\n+    /// unless handler has disabled such buffering.\n+    pub fn into_diagnostic(mut self) -> Option<(Diagnostic, &'a Handler)> {\n         if self.0.handler.flags.dont_buffer_diagnostics ||\n             self.0.handler.flags.treat_err_as_bug.is_some()\n         {\n             self.emit();\n-            return;\n+            return None;\n         }\n \n-        // We need to use `ptr::read` because `DiagnosticBuilder`\n-        // implements `Drop`.\n+        let handler = self.0.handler;\n+\n+        // We need to use `ptr::read` because `DiagnosticBuilder` implements `Drop`.\n         let diagnostic;\n         unsafe {\n             diagnostic = std::ptr::read(&self.0.diagnostic);\n@@ -137,7 +145,14 @@ impl<'a> DiagnosticBuilder<'a> {\n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n         debug!(\"buffer: diagnostic={:?}\", diagnostic);\n-        buffered_diagnostics.push(diagnostic);\n+\n+        Some((diagnostic, handler))\n+    }\n+\n+    /// Buffers the diagnostic for later emission,\n+    /// unless handler has disabled such buffering.\n+    pub fn buffer(self, buffered_diagnostics: &mut Vec<Diagnostic>) {\n+        buffered_diagnostics.extend(self.into_diagnostic().map(|(diag, _)| diag));\n     }\n \n     /// Convenience function for internal use, clients should use one of the"}, {"sha": "40f63ae1eee331d03140078f2491ebfcdac93b10", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 72, "deletions": 12, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae8b3e8fc6e95a0f68fc49338f394d670e233883/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=ae8b3e8fc6e95a0f68fc49338f394d670e233883", "patch": "@@ -17,7 +17,7 @@ use emitter::{Emitter, EmitterWriter};\n use registry::Registry;\n \n use rustc_data_structures::sync::{self, Lrc, Lock};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n \n use std::borrow::Cow;\n@@ -326,6 +326,18 @@ struct HandlerInner {\n     /// this handler. These hashes is used to avoid emitting the same error\n     /// twice.\n     emitted_diagnostics: FxHashSet<u128>,\n+\n+    /// Stashed diagnostics emitted in one stage of the compiler that may be\n+    /// stolen by other stages (e.g. to improve them and add more information).\n+    /// The stashed diagnostics count towards the total error count.\n+    /// When `.abort_if_errors()` is called, these are also emitted.\n+    stashed_diagnostics: FxIndexMap<(Span, StashKey), Diagnostic>,\n+}\n+\n+/// A key denoting where from a diagnostic was stashed.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum StashKey {\n+    ItemNoType,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -354,7 +366,9 @@ pub struct HandlerFlags {\n \n impl Drop for HandlerInner {\n     fn drop(&mut self) {\n-        if self.err_count == 0 {\n+        self.emit_stashed_diagnostics();\n+\n+        if !self.has_errors() {\n             let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n             let has_bugs = !bugs.is_empty();\n             for bug in bugs {\n@@ -419,6 +433,7 @@ impl Handler {\n                 taught_diagnostics: Default::default(),\n                 emitted_diagnostic_codes: Default::default(),\n                 emitted_diagnostics: Default::default(),\n+                stashed_diagnostics: Default::default(),\n             }),\n         }\n     }\n@@ -445,6 +460,31 @@ impl Handler {\n         inner.emitted_diagnostics = Default::default();\n         inner.deduplicated_err_count = 0;\n         inner.err_count = 0;\n+        inner.stashed_diagnostics.clear();\n+    }\n+\n+    /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n+    /// If the diagnostic with this `(span, key)` already exists, this will result in an ICE.\n+    pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n+        if let Some(old) = self.inner.borrow_mut().stashed_diagnostics.insert((span, key), diag) {\n+            // We are removing a previously stashed diagnostic which should not happen.\n+            // Create a builder and drop it on the floor to get an ICE.\n+            drop(DiagnosticBuilder::new_diagnostic(self, old));\n+        }\n+    }\n+\n+    /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n+    pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_>> {\n+        self.inner\n+            .borrow_mut()\n+            .stashed_diagnostics\n+            .remove(&(span, key))\n+            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+    }\n+\n+    /// Emit all stashed diagnostics.\n+    pub fn emit_stashed_diagnostics(&self) {\n+        self.inner.borrow_mut().emit_stashed_diagnostics();\n     }\n \n     pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n@@ -617,23 +657,23 @@ impl Handler {\n     }\n \n     pub fn err_count(&self) -> usize {\n-        self.inner.borrow().err_count\n+        self.inner.borrow().err_count()\n     }\n \n     pub fn has_errors(&self) -> bool {\n-        self.err_count() > 0\n+        self.inner.borrow().has_errors()\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n         self.inner.borrow_mut().print_error_count(registry)\n     }\n \n     pub fn abort_if_errors(&self) {\n-        self.inner.borrow().abort_if_errors()\n+        self.inner.borrow_mut().abort_if_errors()\n     }\n \n     pub fn abort_if_errors_and_should_abort(&self) {\n-        self.inner.borrow().abort_if_errors_and_should_abort()\n+        self.inner.borrow_mut().abort_if_errors_and_should_abort()\n     }\n \n     pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n@@ -671,6 +711,12 @@ impl HandlerInner {\n         self.emitter.emit_diagnostic(&db);\n     }\n \n+    /// Emit all stashed diagnostics.\n+    fn emit_stashed_diagnostics(&mut self) {\n+        let diags = self.stashed_diagnostics.drain(..).map(|x| x.1).collect::<Vec<_>>();\n+        diags.iter().for_each(|diag| self.emit_diagnostic(diag));\n+    }\n+\n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n         if diagnostic.cancelled() {\n             return;\n@@ -713,10 +759,12 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map(|c| self.err_count >= c).unwrap_or(false)\n+        self.flags.treat_err_as_bug.map(|c| self.err_count() >= c).unwrap_or(false)\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n+        self.emit_stashed_diagnostics();\n+\n         let s = match self.deduplicated_err_count {\n             0 => return,\n             1 => \"aborting due to previous error\".to_string(),\n@@ -760,14 +808,26 @@ impl HandlerInner {\n         }\n     }\n \n-    fn abort_if_errors_and_should_abort(&self) {\n-        if self.err_count > 0 && !self.continue_after_error {\n+    fn err_count(&self) -> usize {\n+        self.err_count + self.stashed_diagnostics.len()\n+    }\n+\n+    fn has_errors(&self) -> bool {\n+        self.err_count() > 0\n+    }\n+\n+    fn abort_if_errors_and_should_abort(&mut self) {\n+        self.emit_stashed_diagnostics();\n+\n+        if self.has_errors() && !self.continue_after_error {\n             FatalError.raise();\n         }\n     }\n \n-    fn abort_if_errors(&self) {\n-        if self.err_count > 0 {\n+    fn abort_if_errors(&mut self) {\n+        self.emit_stashed_diagnostics();\n+\n+        if self.has_errors() {\n             FatalError.raise();\n         }\n     }\n@@ -826,7 +886,7 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            let s = match (self.err_count, self.flags.treat_err_as_bug.unwrap_or(0)) {\n+            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n                 (0, _) => return,\n                 (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n                 (1, _) => return,"}]}