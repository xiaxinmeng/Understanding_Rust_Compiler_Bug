{"sha": "0477319afb369d0e2bdb29b813ef10660a6594f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NzczMTlhZmIzNjlkMGUyYmRiMjliODEzZWYxMDY2MGE2NTk0ZjU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-20T23:50:04Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-28T02:11:09Z"}, "message": "rustc_mir: move storage_dead_or_drop_error_reported logic to access_lvalue.", "tree": {"sha": "ff557e3f3b617c08dba8c2a081488de89ee09124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff557e3f3b617c08dba8c2a081488de89ee09124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0477319afb369d0e2bdb29b813ef10660a6594f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0477319afb369d0e2bdb29b813ef10660a6594f5", "html_url": "https://github.com/rust-lang/rust/commit/0477319afb369d0e2bdb29b813ef10660a6594f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0477319afb369d0e2bdb29b813ef10660a6594f5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b087a991fca51c365ce46ad470d85b99f7c9005a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b087a991fca51c365ce46ad470d85b99f7c9005a", "html_url": "https://github.com/rust-lang/rust/commit/b087a991fca51c365ce46ad470d85b99f7c9005a"}], "stats": {"total": 82, "additions": 36, "deletions": 46}, "files": [{"sha": "ef41621c4114346e8e05d4183e0b360584f15f0e", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 36, "deletions": 46, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0477319afb369d0e2bdb29b813ef10660a6594f5/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0477319afb369d0e2bdb29b813ef10660a6594f5/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=0477319afb369d0e2bdb29b813ef10660a6594f5", "patch": "@@ -140,7 +140,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n         node_id: id,\n         move_data: &mdpe.move_data,\n         param_env: param_env,\n-        storage_drop_or_dead_error_reported: FxHashSet(),\n+        storage_dead_or_drop_error_reported: FxHashSet(),\n     };\n \n     let mut state = InProgress::new(flow_borrows,\n@@ -159,10 +159,10 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     node_id: ast::NodeId,\n     move_data: &'cx MoveData<'tcx>,\n     param_env: ParamEnv<'gcx>,\n-    /// This field keeps track of when storage drop or dead errors are reported\n+    /// This field keeps track of when storage dead or drop errors are reported\n     /// in order to stop duplicate error reporting and identify the conditions required\n     /// for a \"temporary value dropped here while still borrowed\" error. See #45360.\n-    storage_drop_or_dead_error_reported: FxHashSet<Local>,\n+    storage_dead_or_drop_error_reported: FxHashSet<Local>,\n }\n \n // (forced to be `pub` due to its use as an associated type below.)\n@@ -296,15 +296,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n \n             StatementKind::StorageDead(local) => {\n-                if !self.storage_drop_or_dead_error_reported.contains(&local) {\n-                    let error_reported = self.access_lvalue(ContextKind::StorageDead.new(location),\n-                        (&Lvalue::Local(local), span),\n-                        (Shallow(None), Write(WriteKind::StorageDeadOrDrop)), flow_state);\n-\n-                    if error_reported {\n-                        self.storage_drop_or_dead_error_reported.insert(local);\n-                    }\n-                }\n+                self.access_lvalue(ContextKind::StorageDead.new(location),\n+                    (&Lvalue::Local(local), span),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)), flow_state);\n             }\n         }\n     }\n@@ -523,9 +517,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                      context: Context,\n                      lvalue_span: (&Lvalue<'tcx>, Span),\n                      kind: (ShallowOrDeep, ReadOrWrite),\n-                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) -> bool {\n+                     flow_state: &InProgress<'cx, 'gcx, 'tcx>) {\n         let (sd, rw) = kind;\n \n+        let storage_dead_or_drop_local = match (lvalue_span.0, rw) {\n+            (&Lvalue::Local(local), Write(WriteKind::StorageDeadOrDrop)) => Some(local),\n+            _ => None\n+        };\n+\n+        // Check if error has already been reported to stop duplicate reporting.\n+        if let Some(local) = storage_dead_or_drop_local {\n+            if self.storage_dead_or_drop_error_reported.contains(&local) {\n+                return;\n+            }\n+        }\n+\n         // Check permissions\n         self.check_access_permissions(lvalue_span, rw);\n \n@@ -590,7 +596,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n             });\n-        error_reported\n+\n+        if error_reported {\n+            if let Some(local) = storage_dead_or_drop_local {\n+                self.storage_dead_or_drop_error_reported.insert(local);\n+            }\n+        }\n     }\n \n     fn mutate_lvalue(&mut self,\n@@ -708,39 +719,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let erased_ty = gcx.lift(&self.tcx.erase_regions(&ty)).unwrap();\n         let moves_by_default = erased_ty.moves_by_default(gcx, self.param_env, DUMMY_SP);\n \n-        // Check if error has already been reported to stop duplicate reporting.\n-        let has_storage_drop_or_dead_error_reported = match *lvalue {\n-            Lvalue::Local(local) => self.storage_drop_or_dead_error_reported.contains(&local),\n-            _ => false,\n-        };\n-\n-        // If the error has been reported already, then we don't need the access_lvalue call.\n-        if !has_storage_drop_or_dead_error_reported || consume_via_drop != ConsumeKind::Drop {\n-            let error_reported;\n-\n-            if moves_by_default {\n-                let kind = match consume_via_drop {\n-                    ConsumeKind::Drop => WriteKind::StorageDeadOrDrop,\n-                    _ => WriteKind::Move,\n-                };\n-\n-                // move of lvalue: check if this is move of already borrowed path\n-                error_reported = self.access_lvalue(context, lvalue_span,\n-                                                    (Deep, Write(kind)), flow_state);\n-            } else {\n-                // copy of lvalue: check if this is \"copy of frozen path\"\n-                // (FIXME: see check_loans.rs)\n-                error_reported = self.access_lvalue(context, lvalue_span,\n-                                                    (Deep, Read(ReadKind::Copy)), flow_state);\n-            }\n+        if moves_by_default {\n+            let kind = match consume_via_drop {\n+                ConsumeKind::Drop => WriteKind::StorageDeadOrDrop,\n+                _ => WriteKind::Move,\n+            };\n \n-            // If there was an error, then we keep track of it so as to deduplicate it.\n-            // We only do this on ConsumeKind::Drop.\n-            if error_reported && consume_via_drop == ConsumeKind::Drop {\n-                if let Lvalue::Local(local) = *lvalue {\n-                    self.storage_drop_or_dead_error_reported.insert(local);\n-                }\n-            }\n+            // move of lvalue: check if this is move of already borrowed path\n+            self.access_lvalue(context, lvalue_span, (Deep, Write(kind)), flow_state);\n+        } else {\n+            // copy of lvalue: check if this is \"copy of frozen path\"\n+            // (FIXME: see check_loans.rs)\n+            self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)), flow_state);\n         }\n \n         // Finally, check if path was already moved."}]}