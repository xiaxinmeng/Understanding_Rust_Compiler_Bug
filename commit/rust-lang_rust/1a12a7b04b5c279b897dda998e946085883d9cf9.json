{"sha": "1a12a7b04b5c279b897dda998e946085883d9cf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMTJhN2IwNGI1YzI3OWI4OTdkZGE5OThlOTQ2MDg1ODgzZDljZjk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T11:34:59Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T11:34:59Z"}, "message": "Make module indices hold a list of items\n\nThis way, they can support having both a type and a value\nof the same name.", "tree": {"sha": "d8d95db5c171f41cbbdcc3871a1c2c38bc7d71d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8d95db5c171f41cbbdcc3871a1c2c38bc7d71d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a12a7b04b5c279b897dda998e946085883d9cf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a12a7b04b5c279b897dda998e946085883d9cf9", "html_url": "https://github.com/rust-lang/rust/commit/1a12a7b04b5c279b897dda998e946085883d9cf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a12a7b04b5c279b897dda998e946085883d9cf9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58ec5d1654f367d7f3459ebee2b5f4c89e0f3aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/58ec5d1654f367d7f3459ebee2b5f4c89e0f3aa1", "html_url": "https://github.com/rust-lang/rust/commit/58ec5d1654f367d7f3459ebee2b5f4c89e0f3aa1"}], "stats": {"total": 142, "additions": 100, "deletions": 42}, "files": [{"sha": "93ce248ba4c6378f3dab9c66f698ba5727206bb9", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 87, "deletions": 42, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1a12a7b04b5c279b897dda998e946085883d9cf9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a12a7b04b5c279b897dda998e946085883d9cf9/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=1a12a7b04b5c279b897dda998e946085883d9cf9", "patch": "@@ -64,14 +64,14 @@ tag mod_index_entry {\n     mie_item(@ast::item);\n     mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n }\n-type mod_index = hashmap[ident,mod_index_entry];\n+type mod_index = hashmap[ident,list[mod_index_entry]];\n type indexed_mod = rec(ast::_mod m, mod_index index);\n \n-tag native_mod_index_entry {\n+tag nmod_index_entry {\n     nmie_view_item(@ast::view_item);\n     nmie_item(@ast::native_item);\n }\n-type nmod_index = hashmap[ident,native_mod_index_entry];\n+type nmod_index = hashmap[ident,list[nmod_index_entry]];\n type indexed_nmod = rec(ast::native_mod m, nmod_index index);\n \n type def_map = hashmap[uint,def];\n@@ -340,9 +340,9 @@ fn resolve_import(&env e, &@ast::view_item it, &list[scope] sc) {\n         }\n     }\n \n-    fn register(&env e, def_id defid, &span sp, ident id,\n-                option::t[def] val, option::t[def] typ) {\n-        if (val == none[def] && typ == none[def]) {\n+    fn register(&env e, def_id defid, &span sp, &ident id,\n+                &option::t[def] val, &option::t[def] typ) {\n+        if (option::is_none(val) && option::is_none(typ)) {\n             unresolved(e, sp, id, \"import\");\n         }\n         e.imports.insert(defid._1, resolved(val, typ));\n@@ -366,7 +366,7 @@ fn ns_name(namespace ns) -> str {\n     }\n }\n \n-fn unresolved(&env e, &span sp, ident id, str kind) {\n+fn unresolved(&env e, &span sp, &ident id, &str kind) {\n     e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n }\n \n@@ -392,7 +392,7 @@ fn lookup_path_strict(&env e, &list[scope] sc, &span sp, vec[ident] idents,\n     ret dcur;\n }\n                       \n-fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, ident id,\n+fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, &ident id,\n                         namespace ns) -> def {\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n         case (none[def]) {\n@@ -433,9 +433,9 @@ fn def_is_obj_field(&def d) -> bool {\n     };\n }\n \n-fn lookup_in_scope(&env e, list[scope] sc, &span sp, ident id, namespace ns)\n+fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n     -> option::t[def] {\n-    fn in_scope(&env e, ident id, &scope s, namespace ns)\n+    fn in_scope(&env e, &ident id, &scope s, namespace ns)\n         -> option::t[def] {\n         alt (s) {\n             case (scope_crate(?c)) {\n@@ -513,8 +513,8 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, ident id, namespace ns)\n                     auto df = option::get(fnd);\n                     if ((left_fn && def_is_local(df)) ||\n                         (left_fn_level2 && def_is_obj_field(df))) {\n-                        e.sess.span_err(sp, \"attempted dynamic \" + \n-                                        \"environment-capture\");\n+                        e.sess.span_err\n+                            (sp, \"attempted dynamic environment-capture\");\n                     }\n                     ret fnd;\n                 }\n@@ -528,7 +528,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, ident id, namespace ns)\n     }\n }\n \n-fn lookup_in_ty_params(ident id, &vec[ast::ty_param] ty_params)\n+fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n     -> option::t[def] {\n     auto i = 0u;\n     for (ast::ty_param tp in ty_params) {\n@@ -540,7 +540,7 @@ fn lookup_in_ty_params(ident id, &vec[ast::ty_param] ty_params)\n     ret none[def];\n }\n \n-fn lookup_in_pat(ident id, &ast::pat pat) -> option::t[def] {\n+fn lookup_in_pat(&ident id, &ast::pat pat) -> option::t[def] {\n     alt (pat.node) {\n         case (ast::pat_bind(?name, ?defid, _)) {\n             if (_str::eq(name, id)) { ret some(ast::def_binding(defid)); }\n@@ -558,7 +558,7 @@ fn lookup_in_pat(ident id, &ast::pat pat) -> option::t[def] {\n }\n \n \n-fn lookup_in_fn(ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n+fn lookup_in_fn(&ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n                 namespace ns) -> option::t[def] {\n     if (ns == ns_value) {\n         for (ast::arg a in decl.inputs) {\n@@ -572,7 +572,7 @@ fn lookup_in_fn(ident id, &ast::fn_decl decl, &vec[ast::ty_param] ty_params,\n     }\n }\n \n-fn lookup_in_obj(ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n+fn lookup_in_obj(&ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n                  namespace ns) -> option::t[def] {\n     if (ns == ns_value) {\n         for (ast::obj_field f in ob.fields) {\n@@ -586,7 +586,7 @@ fn lookup_in_obj(ident id, &ast::_obj ob, &vec[ast::ty_param] ty_params,\n     }\n }\n \n-fn lookup_in_block(ident id, &ast::block_ b, namespace ns)\n+fn lookup_in_block(&ident id, &ast::block_ b, namespace ns)\n     -> option::t[def] {\n     for (@ast::stmt st in b.stmts) {\n         alt (st.node) {\n@@ -659,7 +659,7 @@ fn found_def_item(@ast::item i, namespace ns) -> option::t[def] {\n     ret none[def];\n }\n \n-fn lookup_in_mod_strict(&env e, def m, &span sp, ident id,\n+fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n                         namespace ns, dir dr) -> def {\n     alt (lookup_in_mod(e, m, id, ns, dr)) {\n         case (none[def]) {\n@@ -672,7 +672,7 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, ident id,\n     }\n }\n \n-fn lookup_in_mod(&env e, def m, ident id, namespace ns, dir dr)\n+fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n     -> option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n     if (defid._0 != ast::local_crate) { // Not in this crate\n@@ -728,15 +728,32 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n     }\n }\n \n-fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n+fn lookup_in_regular_mod(&env e, def_id defid, &ident id, namespace ns, dir dr)\n     -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n     auto found = info.index.find(id);\n-    if (found == none[mod_index_entry] || \n+    if (option::is_none(found) || \n         (dr == outside && !ast::is_exported(id, info.m))) {\n         ret none[def];\n     }\n-    alt (option::get(found)) {\n+    auto lst = option::get(found);\n+    while (true) {\n+        alt (lst) {\n+            case (nil[mod_index_entry]) {\n+                ret none[def];\n+            }\n+            case (cons[mod_index_entry](?hd, ?tl)) {\n+                auto found = lookup_in_mie(e, hd, ns);\n+                if (!option::is_none(found)) { ret found; }\n+                lst = *tl;\n+            }\n+        }\n+    }\n+}\n+\n+fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n+    -> option::t[def] {\n+    alt (mie) {\n         case (mie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n@@ -754,18 +771,35 @@ fn lookup_in_regular_mod(&env e, def_id defid, ident id, namespace ns, dir dr)\n                     }\n                 }\n             }\n-        }            \n+        }\n     }\n }\n \n-fn lookup_in_native_mod(&env e, def_id defid, ident id, namespace ns)\n+fn lookup_in_native_mod(&env e, def_id defid, &ident id, namespace ns)\n     -> option::t[def] {\n     auto info = e.nmod_map.get(defid._1);\n     auto found = info.index.find(id);\n-    if (found == none[native_mod_index_entry]) {\n+    if (option::is_none(found)) {\n         ret none[def];\n     }\n-    alt (option::get(found)) {\n+    auto lst = option::get(found);\n+    while (true) {\n+        alt (lst) {\n+            case (nil[nmod_index_entry]) {\n+                ret none[def];\n+            }\n+            case (cons[nmod_index_entry](?hd, ?tl)) {\n+                auto found = lookup_in_nmie(e, hd, ns);\n+                if (!option::is_none(found)) { ret found; }\n+                lst = *tl;\n+            }\n+        }\n+    }\n+}\n+    \n+fn lookup_in_nmie(&env e, &nmod_index_entry nmie, namespace ns)\n+    -> option::t[def] {\n+    alt (nmie) {\n         case (nmie_view_item(?view_item)) {\n             ret found_view_item(e, view_item, ns);\n         }\n@@ -790,16 +824,27 @@ fn lookup_in_native_mod(&env e, def_id defid, ident id, namespace ns)\n \n // Module indexing\n \n+fn add_to_index[T](&hashmap[ident,list[T]] index, &ident id, &T ent) {\n+    alt (index.find(id)) {\n+        case (none[list[T]]) {\n+            index.insert(id, cons(ent, @nil[T]));\n+        }\n+        case (some[list[T]](?prev)) {\n+            index.insert(id, cons(ent, @prev));\n+        }\n+    }\n+}\n+\n fn index_mod(&ast::_mod md) -> mod_index {\n-    auto index = new_str_hash[mod_index_entry]();\n+    auto index = new_str_hash[list[mod_index_entry]]();\n \n     for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n             case(ast::view_item_use(?id, _, _, _)) {\n-                index.insert(id, mie_view_item(it));\n+                add_to_index(index, id, mie_view_item(it));\n             }\n             case(ast::view_item_import(?def_ident,_,_)) {\n-                index.insert(def_ident, mie_view_item(it));\n+                add_to_index(index, def_ident, mie_view_item(it));\n             }\n             case(ast::view_item_export(_)) {}\n         }\n@@ -808,31 +853,31 @@ fn index_mod(&ast::_mod md) -> mod_index {\n     for (@ast::item it in md.items) {\n         alt (it.node) {\n             case (ast::item_const(?id, _, _, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n             }\n             case (ast::item_fn(?id, _, _, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n             }\n             case (ast::item_mod(?id, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n             }\n             case (ast::item_native_mod(?id, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n             }\n             case (ast::item_ty(?id, _, _, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n             }\n             case (ast::item_tag(?id, ?variants, _, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n                 let uint variant_idx = 0u;\n                 for (ast::variant v in variants) {\n-                    index.insert(v.node.name,\n-                                 mie_tag_variant(it, variant_idx));\n+                    add_to_index(index, v.node.name,\n+                                     mie_tag_variant(it, variant_idx));\n                     variant_idx += 1u;\n                 }\n             }\n             case (ast::item_obj(?id, _, _, _, _)) {\n-                index.insert(id, mie_item(it));\n+                add_to_index(index, id, mie_item(it));\n             }\n         }\n     }\n@@ -841,12 +886,12 @@ fn index_mod(&ast::_mod md) -> mod_index {\n }\n \n fn index_nmod(&ast::native_mod md) -> nmod_index {\n-    auto index = new_str_hash[native_mod_index_entry]();\n+    auto index = new_str_hash[list[nmod_index_entry]]();\n \n     for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n             case(ast::view_item_import(?def_ident,_,_)) {\n-                index.insert(def_ident, nmie_view_item(it));\n+                add_to_index(index, def_ident, nmie_view_item(it));\n             }\n             case(ast::view_item_export(_)) {}\n         }\n@@ -855,10 +900,10 @@ fn index_nmod(&ast::native_mod md) -> nmod_index {\n     for (@ast::native_item it in md.items) {\n         alt (it.node) {\n             case (ast::native_item_ty(?id, _)) {\n-                index.insert(id, nmie_item(it));\n+                add_to_index(index, id, nmie_item(it));\n             }\n             case (ast::native_item_fn(?id, _, _, _, _, _)) {\n-                index.insert(id, nmie_item(it));\n+                add_to_index(index, id, nmie_item(it));\n             }\n         }\n     }"}, {"sha": "5038ae13894f6d2010ac14880ff2d8c44ff93656", "filename": "src/test/run-pass/type-namespace.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1a12a7b04b5c279b897dda998e946085883d9cf9/src%2Ftest%2Frun-pass%2Ftype-namespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a12a7b04b5c279b897dda998e946085883d9cf9/src%2Ftest%2Frun-pass%2Ftype-namespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-namespace.rs?ref=1a12a7b04b5c279b897dda998e946085883d9cf9", "patch": "@@ -0,0 +1,13 @@\n+// xfail-boot\n+// xfail-stage0\n+\n+type a = rec(int a);\n+\n+fn a(a a) -> int {\n+    ret a.a;\n+}\n+\n+fn main() {\n+    let a x = rec(a=1);\n+    assert(a(x) == 1);\n+}"}]}