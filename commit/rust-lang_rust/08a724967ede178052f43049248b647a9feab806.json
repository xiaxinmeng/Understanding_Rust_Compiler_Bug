{"sha": "08a724967ede178052f43049248b647a9feab806", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YTcyNDk2N2VkZTE3ODA1MmY0MzA0OTI0OGI2NDdhOWZlYWI4MDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-03T01:00:24Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-03T01:00:24Z"}, "message": "get_fn_like_arguments: avoid .unwrap", "tree": {"sha": "e7285a90f83e95a08bb6c76c1ec240f9273447c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7285a90f83e95a08bb6c76c1ec240f9273447c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a724967ede178052f43049248b647a9feab806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a724967ede178052f43049248b647a9feab806", "html_url": "https://github.com/rust-lang/rust/commit/08a724967ede178052f43049248b647a9feab806", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a724967ede178052f43049248b647a9feab806/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c0826902f0f8c479d1622d63abadcfe4f64e86e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c0826902f0f8c479d1622d63abadcfe4f64e86e", "html_url": "https://github.com/rust-lang/rust/commit/9c0826902f0f8c479d1622d63abadcfe4f64e86e"}], "stats": {"total": 70, "additions": 33, "deletions": 37}, "files": [{"sha": "5a9a96887f66a31f41a4b737d677d2d4b24c006e", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/08a724967ede178052f43049248b647a9feab806/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a724967ede178052f43049248b647a9feab806/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=08a724967ede178052f43049248b647a9feab806", "patch": "@@ -65,7 +65,7 @@ pub trait InferCtxtExt<'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>);\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)>;\n \n     /// Reports an error when the number of arguments needed by a\n     /// trait match doesn't match the number that the expression\n@@ -611,10 +611,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     )\n                 } else {\n                     let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir().get_if_local(did))\n-                        .map(|node| {\n-                            let (found_span, found) = self.get_fn_like_arguments(node);\n-                            (Some(found_span), found)\n+                        .and_then(|did| {\n+                            let node = self.tcx.hir().get_if_local(did)?;\n+                            let (found_span, found) = self.get_fn_like_arguments(node)?;\n+                            Some((Some(found_span), found))\n                         })\n                         .unwrap_or((found_span, found));\n \n@@ -672,43 +672,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n-        match node {\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> Option<(Span, Vec<ArgKind>)> {\n+        let sm = self.tcx.sess.source_map();\n+        let hir = self.tcx.hir();\n+        Some(match node {\n             Node::Expr(&hir::Expr {\n                 kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().guess_head_span(span),\n-                self.tcx\n-                    .hir()\n-                    .body(id)\n+                sm.guess_head_span(span),\n+                hir.body(id)\n                     .params\n                     .iter()\n                     .map(|arg| {\n                         if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n                             *arg.pat\n                         {\n-                            ArgKind::Tuple(\n+                            Some(ArgKind::Tuple(\n                                 Some(span),\n                                 args.iter()\n                                     .map(|pat| {\n-                                        let snippet = self\n-                                            .tcx\n-                                            .sess\n-                                            .source_map()\n-                                            .span_to_snippet(pat.span)\n-                                            .unwrap();\n-                                        (snippet, \"_\".to_owned())\n+                                        sm.span_to_snippet(pat.span)\n+                                            .ok()\n+                                            .map(|snippet| (snippet, \"_\".to_owned()))\n                                     })\n-                                    .collect::<Vec<_>>(),\n-                            )\n+                                    .collect::<Option<Vec<_>>>()?,\n+                            ))\n                         } else {\n-                            let name =\n-                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n-                            ArgKind::Arg(name, \"_\".to_owned())\n+                            let name = sm.span_to_snippet(arg.pat.span).ok()?;\n+                            Some(ArgKind::Arg(name, \"_\".to_owned()))\n                         }\n                     })\n-                    .collect::<Vec<ArgKind>>(),\n+                    .collect::<Option<Vec<ArgKind>>>()?,\n             ),\n             Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n             | Node::ImplItem(&hir::ImplItem {\n@@ -721,7 +716,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 kind: hir::TraitItemKind::Fn(ref sig, _),\n                 ..\n             }) => (\n-                self.tcx.sess.source_map().guess_head_span(span),\n+                sm.guess_head_span(span),\n                 sig.decl\n                     .inputs\n                     .iter()\n@@ -735,16 +730,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .collect::<Vec<ArgKind>>(),\n             ),\n             Node::Ctor(ref variant_data) => {\n-                let span = variant_data\n-                    .ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span(hir_id))\n-                    .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().guess_head_span(span);\n-\n+                let span = variant_data.ctor_hir_id().map(|id| hir.span(id)).unwrap_or(DUMMY_SP);\n+                let span = sm.guess_head_span(span);\n                 (span, vec![ArgKind::empty(); variant_data.fields().len()])\n             }\n             _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        }\n+        })\n     }\n \n     /// Reports an error when the number of arguments needed by a"}, {"sha": "2ccf7890c3042327dc23048edfd04990605d907a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08a724967ede178052f43049248b647a9feab806/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a724967ede178052f43049248b647a9feab806/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=08a724967ede178052f43049248b647a9feab806", "patch": "@@ -432,18 +432,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         body: &hir::Body<'_>,\n         expected_sig: ExpectedSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let expr_map_node = self.tcx.hir().get_if_local(expr_def_id).unwrap();\n+        let hir = self.tcx.hir();\n+        let expr_map_node = hir.get_if_local(expr_def_id).unwrap();\n         let expected_args: Vec<_> = expected_sig\n             .sig\n             .inputs()\n             .iter()\n             .map(|ty| ArgKind::from_expected_ty(ty, None))\n             .collect();\n-        let (closure_span, found_args) = self.get_fn_like_arguments(expr_map_node);\n-        let expected_span = expected_sig.cause_span.unwrap_or(closure_span);\n+        let (closure_span, found_args) = match self.get_fn_like_arguments(expr_map_node) {\n+            Some((sp, args)) => (Some(sp), args),\n+            None => (None, Vec::new()),\n+        };\n+        let expected_span =\n+            expected_sig.cause_span.unwrap_or_else(|| hir.span_if_local(expr_def_id).unwrap());\n         self.report_arg_count_mismatch(\n             expected_span,\n-            Some(closure_span),\n+            closure_span,\n             expected_args,\n             found_args,\n             true,"}]}