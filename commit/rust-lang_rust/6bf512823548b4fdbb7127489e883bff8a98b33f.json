{"sha": "6bf512823548b4fdbb7127489e883bff8a98b33f", "node_id": "C_kwDOAAsO6NoAKDZiZjUxMjgyMzU0OGI0ZmRiYjcxMjc0ODllODgzYmZmOGE5OGIzM2Y", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-08-01T04:34:58Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-08-01T04:34:58Z"}, "message": "Simplify interleave/deinterleave and fix for odd-length vectors.", "tree": {"sha": "4212864db533ba3a5644c85520abeff1d30c7d89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4212864db533ba3a5644c85520abeff1d30c7d89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf512823548b4fdbb7127489e883bff8a98b33f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf512823548b4fdbb7127489e883bff8a98b33f", "html_url": "https://github.com/rust-lang/rust/commit/6bf512823548b4fdbb7127489e883bff8a98b33f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf512823548b4fdbb7127489e883bff8a98b33f/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3183afb6b5fcbf688bb90cf1db3f635406f868dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3183afb6b5fcbf688bb90cf1db3f635406f868dc", "html_url": "https://github.com/rust-lang/rust/commit/3183afb6b5fcbf688bb90cf1db3f635406f868dc"}], "stats": {"total": 74, "additions": 26, "deletions": 48}, "files": [{"sha": "0b66b8a0ae03b2be666a0d429ffd755e3898e8d6", "filename": "crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 26, "deletions": 48, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6bf512823548b4fdbb7127489e883bff8a98b33f/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf512823548b4fdbb7127489e883bff8a98b33f/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=6bf512823548b4fdbb7127489e883bff8a98b33f", "patch": "@@ -265,13 +265,10 @@ where\n \n     /// Interleave two vectors.\n     ///\n-    /// Produces two vectors with lanes taken alternately from `self` and `other`.\n+    /// The resulting vectors contain lanes taken alternatively from `self` and `other`, first\n+    /// filling the first result, and then the second.\n     ///\n-    /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n-    /// alternating, starting with the first lane of `self`.\n-    ///\n-    /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n-    /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n+    /// The reverse of this operation is [`Simd::deinterleave`].\n     ///\n     /// ```\n     /// #![feature(portable_simd)]\n@@ -285,29 +282,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn interleave(self, other: Self) -> (Self, Self) {\n-        const fn lo<const LANES: usize>() -> [Which; LANES] {\n-            let mut idx = [Which::First(0); LANES];\n-            let mut i = 0;\n-            while i < LANES {\n-                let offset = i / 2;\n-                idx[i] = if i % 2 == 0 {\n-                    Which::First(offset)\n-                } else {\n-                    Which::Second(offset)\n-                };\n-                i += 1;\n-            }\n-            idx\n-        }\n-        const fn hi<const LANES: usize>() -> [Which; LANES] {\n+        const fn interleave<const LANES: usize>(high: bool) -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n             let mut i = 0;\n             while i < LANES {\n-                let offset = (LANES + i) / 2;\n-                idx[i] = if i % 2 == 0 {\n-                    Which::First(offset)\n+                // Treat the source as a concatenated vector\n+                let dst_index = if high { i + LANES } else { i };\n+                let src_index = dst_index / 2 + (dst_index % 2) * LANES;\n+                idx[i] = if src_index < LANES {\n+                    Which::First(src_index)\n                 } else {\n-                    Which::Second(offset)\n+                    Which::Second(src_index % LANES)\n                 };\n                 i += 1;\n             }\n@@ -318,18 +303,14 @@ where\n         struct Hi;\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Lo {\n-            const INDEX: [Which; LANES] = lo::<LANES>();\n+            const INDEX: [Which; LANES] = interleave::<LANES>(false);\n         }\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Hi {\n-            const INDEX: [Which; LANES] = hi::<LANES>();\n+            const INDEX: [Which; LANES] = interleave::<LANES>(true);\n         }\n \n-        if LANES == 1 {\n-            (self, other)\n-        } else {\n-            (Lo::swizzle2(self, other), Hi::swizzle2(self, other))\n-        }\n+        (Lo::swizzle2(self, other), Hi::swizzle2(self, other))\n     }\n \n     /// Deinterleave two vectors.\n@@ -340,6 +321,8 @@ where\n     /// The second result takes every other lane of `self` and then `other`, starting with\n     /// the second lane.\n     ///\n+    /// The reverse of this operation is [`Simd::interleave`].\n+    ///\n     /// ```\n     /// #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n@@ -352,22 +335,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn deinterleave(self, other: Self) -> (Self, Self) {\n-        const fn even<const LANES: usize>() -> [Which; LANES] {\n-            let mut idx = [Which::First(0); LANES];\n-            let mut i = 0;\n-            while i < LANES / 2 {\n-                idx[i] = Which::First(2 * i);\n-                idx[i + LANES / 2] = Which::Second(2 * i);\n-                i += 1;\n-            }\n-            idx\n-        }\n-        const fn odd<const LANES: usize>() -> [Which; LANES] {\n+        const fn deinterleave<const LANES: usize>(second: bool) -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n             let mut i = 0;\n-            while i < LANES / 2 {\n-                idx[i] = Which::First(2 * i + 1);\n-                idx[i + LANES / 2] = Which::Second(2 * i + 1);\n+            while i < LANES {\n+                // Treat the source as a concatenated vector\n+                let src_index = i * 2 + if second { 1 } else { 0 };\n+                idx[i] = if src_index < LANES {\n+                    Which::First(src_index)\n+                } else {\n+                    Which::Second(src_index % LANES)\n+                };\n                 i += 1;\n             }\n             idx\n@@ -377,11 +355,11 @@ where\n         struct Odd;\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Even {\n-            const INDEX: [Which; LANES] = even::<LANES>();\n+            const INDEX: [Which; LANES] = deinterleave::<LANES>(false);\n         }\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Odd {\n-            const INDEX: [Which; LANES] = odd::<LANES>();\n+            const INDEX: [Which; LANES] = deinterleave::<LANES>(true);\n         }\n \n         if LANES == 1 {"}]}