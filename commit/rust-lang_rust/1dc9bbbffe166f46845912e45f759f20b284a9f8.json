{"sha": "1dc9bbbffe166f46845912e45f759f20b284a9f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYzliYmJmZmUxNjZmNDY4NDU5MTJlNDVmNzU5ZjIwYjI4NGE5Zjg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-28T09:49:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-28T09:49:08Z"}, "message": "Rollup merge of #61247 - spastorino:eval-place-iterate, r=wesleywiser\n\nMake eval_place iterate instead of recurse\n\nr? @oli-obk", "tree": {"sha": "6f9a546e1cd5dc6ee9f14d354e1b9a1a27720b0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f9a546e1cd5dc6ee9f14d354e1b9a1a27720b0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc9bbbffe166f46845912e45f759f20b284a9f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc7QQUCRBK7hj4Ov3rIwAAdHIIADb4v/BHe7VO9I60rujbF0bq\npl0VnxdLtE6QYYZ2bRy3qQRfkLmTClbgPy064kYcwg8PWzDKlPMSTqCCnQo/sOYA\nJcDFF8Wf+4CQSr0p/6ToMF79qYgzSK0Ymissncc8+ZTel0gSF0Ass3fdH0JpiCBB\nAg9pfjdBSGeDsa3BRZ6clgDoIZBPm3NCWf/FbVbAeZR222Oai+lralEwRaEcAR2o\n/rtMldJSAyMJTh17G0tEt1p3Vwhf9tHE1onZ5cNqR5eq/XkR1QhfTDl5xcz7nNLe\nagj02IYplkoVD5spJZE+OPtkNkVEdFcxfeUQLQQguqbbCX0GB/gu674nn75ARWw=\n=kYUI\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f9a546e1cd5dc6ee9f14d354e1b9a1a27720b0d\nparent ffb4ceb27f9584211ac76ed4ef37511c70f20457\nparent c3e71f210ed105dc8ef9d104ff6ddec39baa2258\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559036948 +0200\ncommitter GitHub <noreply@github.com> 1559036948 +0200\n\nRollup merge of #61247 - spastorino:eval-place-iterate, r=wesleywiser\n\nMake eval_place iterate instead of recurse\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc9bbbffe166f46845912e45f759f20b284a9f8", "html_url": "https://github.com/rust-lang/rust/commit/1dc9bbbffe166f46845912e45f759f20b284a9f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc9bbbffe166f46845912e45f759f20b284a9f8/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffb4ceb27f9584211ac76ed4ef37511c70f20457", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb4ceb27f9584211ac76ed4ef37511c70f20457", "html_url": "https://github.com/rust-lang/rust/commit/ffb4ceb27f9584211ac76ed4ef37511c70f20457"}, {"sha": "c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e71f210ed105dc8ef9d104ff6ddec39baa2258", "html_url": "https://github.com/rust-lang/rust/commit/c3e71f210ed105dc8ef9d104ff6ddec39baa2258"}], "stats": {"total": 79, "additions": 41, "deletions": 38}, "files": [{"sha": "11022be097cfd9e68799ee720d02d1007fc575e8", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/1dc9bbbffe166f46845912e45f759f20b284a9f8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc9bbbffe166f46845912e45f759f20b284a9f8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1dc9bbbffe166f46845912e45f759f20b284a9f8", "patch": "@@ -296,47 +296,50 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        match *place {\n-            Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n-            Place::Projection(ref proj) => match proj.elem {\n-                ProjectionElem::Field(field, _) => {\n-                    trace!(\"field proj on {:?}\", proj.base);\n-                    let base = self.eval_place(&proj.base, source_info)?;\n+        place.iterate(|place_base, place_projection| {\n+            let mut eval = match place_base {\n+                PlaceBase::Local(loc) => self.places[*loc].clone()?,\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..}) => {\n+                    let generics = self.tcx.generics_of(self.source.def_id());\n+                    if generics.requires_monomorphization(self.tcx) {\n+                        // FIXME: can't handle code with generics\n+                        return None;\n+                    }\n+                    let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                    let instance = Instance::new(self.source.def_id(), substs);\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: Some(*promoted),\n+                    };\n+                    // cannot use `const_eval` here, because that would require having the MIR\n+                    // for the current function available, but we're producing said MIR right now\n                     let res = self.use_ecx(source_info, |this| {\n-                        this.ecx.operand_field(base, field.index() as u64)\n+                        let mir = &this.promoted[*promoted];\n+                        eval_promoted(this.tcx, cid, mir, this.param_env)\n                     })?;\n-                    Some(res)\n-                },\n-                // We could get more projections by using e.g., `operand_projection`,\n-                // but we do not even have the stack frame set up properly so\n-                // an `Index` projection would throw us off-track.\n-                _ => None,\n-            },\n-            Place::Base(\n-                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..})\n-            ) => {\n-                let generics = self.tcx.generics_of(self.source.def_id());\n-                if generics.requires_monomorphization(self.tcx) {\n-                    // FIXME: can't handle code with generics\n-                    return None;\n+                    trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                    res.into()\n                 }\n-                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                let instance = Instance::new(self.source.def_id(), substs);\n-                let cid = GlobalId {\n-                    instance,\n-                    promoted: Some(promoted),\n-                };\n-                // cannot use `const_eval` here, because that would require having the MIR\n-                // for the current function available, but we're producing said MIR right now\n-                let res = self.use_ecx(source_info, |this| {\n-                    let mir = &this.promoted[promoted];\n-                    eval_promoted(this.tcx, cid, mir, this.param_env)\n-                })?;\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some(res.into())\n-            },\n-            _ => None,\n-        }\n+                _ => return None,\n+            };\n+\n+            for proj in place_projection {\n+                match proj.elem {\n+                    ProjectionElem::Field(field, _) => {\n+                        trace!(\"field proj on {:?}\", proj.base);\n+                        eval = self.use_ecx(source_info, |this| {\n+                            this.ecx.operand_field(eval, field.index() as u64)\n+                        })?;\n+                    },\n+                    // We could get more projections by using e.g., `operand_projection`,\n+                    // but we do not even have the stack frame set up properly so\n+                    // an `Index` projection would throw us off-track.\n+                    _ => return None,\n+                }\n+            }\n+\n+            Some(eval)\n+        })\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {"}]}