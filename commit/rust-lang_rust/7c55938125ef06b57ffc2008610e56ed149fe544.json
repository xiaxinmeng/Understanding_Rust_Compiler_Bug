{"sha": "7c55938125ef06b57ffc2008610e56ed149fe544", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNTU5MzgxMjVlZjA2YjU3ZmZjMjAwODYxMGU1NmVkMTQ5ZmU1NDQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-12T19:06:20Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-12T19:48:46Z"}, "message": "Make glue always pass-by-alias and rename \"scalar_or_boxed\" concept to \"immediate\"", "tree": {"sha": "dc4a932de6ecb36e042007f2971975d67e249c2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc4a932de6ecb36e042007f2971975d67e249c2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c55938125ef06b57ffc2008610e56ed149fe544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c55938125ef06b57ffc2008610e56ed149fe544", "html_url": "https://github.com/rust-lang/rust/commit/7c55938125ef06b57ffc2008610e56ed149fe544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c55938125ef06b57ffc2008610e56ed149fe544/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f374fa44b6a1581a9723b9c91d76b5518fbea2e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f374fa44b6a1581a9723b9c91d76b5518fbea2e8", "html_url": "https://github.com/rust-lang/rust/commit/f374fa44b6a1581a9723b9c91d76b5518fbea2e8"}], "stats": {"total": 121, "additions": 73, "deletions": 48}, "files": [{"sha": "2ea11e469e7fc2437a389f7c1023e35a78a8ee8f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 73, "deletions": 48, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/7c55938125ef06b57ffc2008610e56ed149fe544/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c55938125ef06b57ffc2008610e56ed149fe544/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7c55938125ef06b57ffc2008610e56ed149fe544", "patch": "@@ -1594,7 +1594,7 @@ fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n     }\n \n     auto glue_fn_ty = T_ptr(T_glue_fn(cx.tn));\n- \n+\n     auto name = sanitize(cx.names.next(\"tydesc_\" + ty.ty_to_str(t)));\n     auto gvar = llvm.LLVMAddGlobal(cx.llmod, T_tydesc(cx.tn),\n                                    _str.buf(name));\n@@ -1655,13 +1655,17 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n \n     auto re;\n     if (!ty.type_is_scalar(t)) {\n+\n+        // Any nontrivial glue is with values passed *by alias*; this is a\n+        // requirement since in many contexts glue is invoked indirectly and\n+        // the caller has no idea if it's dealing with something that can be\n+        // passed by value.\n+\n         auto llty;\n         if (ty.type_has_dynamic_size(t)) {\n             llty = T_ptr(T_i8());\n-        } else if (ty.type_is_structural(t)) {\n-            llty = T_ptr(type_of(cx, t));\n         } else {\n-            llty = type_of(cx, t);\n+            llty = T_ptr(type_of(cx, t));\n         }\n \n         auto lltyparams = llvm.LLVMGetParam(llfn, 3u);\n@@ -1690,8 +1694,9 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n }\n \n fn make_take_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n+    // NB: v is an *alias* of type t here, not a direct value.\n     if (ty.type_is_boxed(t)) {\n-        ret incr_refcnt_of_boxed(cx, v);\n+        ret incr_refcnt_of_boxed(cx, cx.build.Load(v));\n \n     } else if (ty.type_is_structural(t)) {\n         ret iter_structural_ty(cx, v, t,\n@@ -1719,9 +1724,11 @@ fn incr_refcnt_of_boxed(@block_ctxt cx, ValueRef box_ptr) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n+fn make_drop_glue(@block_ctxt cx, ValueRef v0, @ty.t t) -> result {\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n     alt (t.struct) {\n         case (ty.ty_str) {\n+            auto v = cx.build.Load(v0);\n             ret decr_refcnt_and_if_zero\n                 (cx, v, bind trans_non_gc_free(_, v),\n                  \"free string\",\n@@ -1736,6 +1743,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 // FIXME: switch gc/non-gc on layer of the type.\n                 ret trans_non_gc_free(res.bcx, v);\n             }\n+            auto v = cx.build.Load(v0);\n             ret decr_refcnt_and_if_zero(cx, v,\n                                         bind hit_zero(_, v, t),\n                                         \"free vector\",\n@@ -1749,11 +1757,12 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n \n-                auto body_val = load_scalar_or_boxed(cx, body, body_ty);\n+                auto body_val = load_if_immediate(cx, body, body_ty);\n                 auto res = drop_ty(cx, body_val, body_ty);\n                 // FIXME: switch gc/non-gc on layer of the type.\n                 ret trans_non_gc_free(res.bcx, v);\n             }\n+            auto v = cx.build.Load(v0);\n             ret decr_refcnt_and_if_zero(cx, v,\n                                         bind hit_zero(_, v, body_mt.ty),\n                                         \"free box\",\n@@ -1765,6 +1774,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 ret trans_upcall(cx, \"upcall_del_port\",\n                                  vec(vp2i(cx, v)));\n             }\n+            auto v = cx.build.Load(v0);\n             ret decr_refcnt_and_if_zero(cx, v,\n                                         bind hit_zero(_, v),\n                                         \"free port\",\n@@ -1776,6 +1786,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 ret trans_upcall(cx, \"upcall_del_chan\",\n                                  vec(vp2i(cx, v)));\n             }\n+            auto v = cx.build.Load(v0);\n             ret decr_refcnt_and_if_zero(cx, v,\n                                         bind hit_zero(_, v),\n                                         \"free chan\",\n@@ -1804,7 +1815,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 ret trans_non_gc_free(cx, v);\n             }\n             auto box_cell =\n-                cx.build.GEP(v,\n+                cx.build.GEP(v0,\n                              vec(C_int(0),\n                                  C_int(abi.obj_field_box)));\n \n@@ -1843,7 +1854,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 ret trans_non_gc_free(cx, v);\n             }\n             auto box_cell =\n-                cx.build.GEP(v,\n+                cx.build.GEP(v0,\n                              vec(C_int(0),\n                                  C_int(abi.fn_field_box)));\n \n@@ -1857,7 +1868,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n \n         case (_) {\n             if (ty.type_is_structural(t)) {\n-                ret iter_structural_ty(cx, v, t,\n+                ret iter_structural_ty(cx, v0, t,\n                                        bind drop_ty(_, _, _));\n \n             } else if (ty.type_is_scalar(t) ||\n@@ -2039,8 +2050,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 r = GEP_tup_like(r.bcx, t, bv, vec(0, i));\n                 auto elt_b = r.val;\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, elt_a, arg.ty),\n-                      load_scalar_or_boxed(r.bcx, elt_b, arg.ty),\n+                      load_if_immediate(r.bcx, elt_a, arg.ty),\n+                      load_if_immediate(r.bcx, elt_b, arg.ty),\n                       arg.ty);\n                 i += 1;\n             }\n@@ -2053,8 +2064,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 r = GEP_tup_like(r.bcx, t, bv, vec(0, i));\n                 auto llfld_b = r.val;\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, llfld_a, fld.mt.ty),\n-                      load_scalar_or_boxed(r.bcx, llfld_b, fld.mt.ty),\n+                      load_if_immediate(r.bcx, llfld_a, fld.mt.ty),\n+                      load_if_immediate(r.bcx, llfld_b, fld.mt.ty),\n                       fld.mt.ty);\n                 i += 1;\n             }\n@@ -2126,12 +2137,12 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                     ty_params, tps, a.ty);\n \n                                 auto llfld_a =\n-                                    load_scalar_or_boxed(variant_cx,\n+                                    load_if_immediate(variant_cx,\n                                                          llfldp_a,\n                                                          ty_subst);\n \n                                 auto llfld_b =\n-                                    load_scalar_or_boxed(variant_cx,\n+                                    load_if_immediate(variant_cx,\n                                                          llfldp_b,\n                                                          ty_subst);\n \n@@ -2252,7 +2263,7 @@ fn iter_sequence_inner(@block_ctxt cx,\n         }\n \n         auto p = cx.build.PointerCast(src, llptrty);\n-        ret f(cx, load_scalar_or_boxed(cx, p, elt_ty), elt_ty);\n+        ret f(cx, load_if_immediate(cx, p, elt_ty), elt_ty);\n     }\n \n     auto elt_sz = size_of(cx, elt_ty);\n@@ -2333,12 +2344,12 @@ fn call_tydesc_glue_full(@block_ctxt cx, ValueRef v,\n \n fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n     auto td = get_tydesc(cx, t);\n-    call_tydesc_glue_full(td.bcx, v, td.val, field);\n+    call_tydesc_glue_full(td.bcx,\n+                          spill_if_immediate(td.bcx, v, t),\n+                          td.val, field);\n }\n \n-fn take_ty(@block_ctxt cx,\n-                    ValueRef v,\n-                    @ty.t t) -> result {\n+fn take_ty(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     if (!ty.type_is_scalar(t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n     }\n@@ -2348,7 +2359,7 @@ fn take_ty(@block_ctxt cx,\n fn drop_slot(@block_ctxt cx,\n              ValueRef slot,\n              @ty.t t) -> result {\n-    auto llptr = load_scalar_or_boxed(cx, slot, t);\n+    auto llptr = load_if_immediate(cx, slot, t);\n     auto re = drop_ty(cx, llptr, t);\n \n     auto llty = val_ty(slot);\n@@ -2692,8 +2703,8 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n             auto av = av0;\n             auto bv = bv0;\n             if (load_inner) {\n-                av = load_scalar_or_boxed(cx, av, t);\n-                bv = load_scalar_or_boxed(cx, bv, t);\n+                av = load_if_immediate(cx, av, t);\n+                bv = load_if_immediate(cx, bv, t);\n             }\n \n             // First 'eq' comparison: if so, continue to next elts.\n@@ -2839,7 +2850,7 @@ fn trans_vec_add(@block_ctxt cx, @ty.t t,\n     auto tmp = r.val;\n     r = copy_ty(r.bcx, INIT, tmp, lhs, t);\n     auto bcx = trans_vec_append(r.bcx, t, tmp, rhs).bcx;\n-    tmp = load_scalar_or_boxed(bcx, tmp, t);\n+    tmp = load_if_immediate(bcx, tmp, t);\n     find_scope_cx(cx).cleanups +=\n         vec(clean(bind drop_ty(_, tmp, t)));\n     ret res(bcx, tmp);\n@@ -2946,7 +2957,7 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                     v1 = body;\n                 }\n \n-                v1 = load_scalar_or_boxed(cx, v1, t1);\n+                v1 = load_if_immediate(cx, v1, t1);\n             }\n             case (_) {\n                 ret res(cx, v1);\n@@ -3495,7 +3506,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n                     auto llsubvalptr = rslt.val;\n                     matched_cx = rslt.bcx;\n \n-                    auto llsubval = load_scalar_or_boxed(matched_cx,\n+                    auto llsubval = load_if_immediate(matched_cx,\n                                                          llsubvalptr,\n                                                          pat_ty(subpat));\n                     auto subpat_res = trans_pat_match(matched_cx, subpat,\n@@ -3550,7 +3561,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n                 this_cx = rslt.bcx;\n                 auto llsubvalptr = rslt.val;\n \n-                auto llsubval = load_scalar_or_boxed(this_cx, llsubvalptr,\n+                auto llsubval = load_if_immediate(this_cx, llsubvalptr,\n                                                      pat_ty(subpat));\n                 auto subpat_res = trans_pat_binding(this_cx, subpat,\n                                                     llsubval);\n@@ -4417,10 +4428,7 @@ fn trans_args(@block_ctxt cx,\n             } else {\n                 // Non-mem but we're trying to alias; synthesize an\n                 // alloca, spill to it and pass its address.\n-                auto llty = val_ty(lv.res.val);\n-                auto llptr = alloca(lv.res.bcx, llty);\n-                lv.res.bcx.build.Store(lv.res.val, llptr);\n-                val = llptr;\n+                val = do_spill(lv.res.bcx, lv.res.val);\n             }\n \n         } else {\n@@ -4496,7 +4504,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n             // self-call\n             fn_ty = meth;\n         }\n-        \n+\n         case (_) {\n             fn_ty = ty.expr_ty(f);\n \n@@ -4527,7 +4535,7 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     auto retval = C_nil();\n \n     if (!ty.type_is_nil(ret_ty)) {\n-        retval = load_scalar_or_boxed(bcx, llretslot, ret_ty);\n+        retval = load_if_immediate(bcx, llretslot, ret_ty);\n         // Retval doesn't correspond to anything really tangible in the frame,\n         // but it's a ref all the same, so we put a note here to drop it when\n         // we're done in this scope.\n@@ -4680,7 +4688,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n         if (!expr_provided) {\n             src_res = GEP_tup_like(bcx, t, base_val, vec(0, i));\n             src_res = res(src_res.bcx,\n-                          load_scalar_or_boxed(bcx, src_res.val, e_ty));\n+                          load_if_immediate(bcx, src_res.val, e_ty));\n         }\n \n         bcx = src_res.bcx;\n@@ -4757,7 +4765,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto t = node_ann_type(cx.fcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n             check (lhs_res.is_mem);\n-            auto lhs_val = load_scalar_or_boxed(lhs_res.res.bcx,\n+            auto lhs_val = load_if_immediate(lhs_res.res.bcx,\n                                                 lhs_res.res.val, t);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto v = trans_eager_binop(rhs_res.bcx, op, t,\n@@ -4853,21 +4861,38 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n     auto t = ty.expr_ty(e);\n     auto sub = trans_lval(cx, e);\n-    ret res(sub.res.bcx, load_scalar_or_boxed(sub.res.bcx, sub.res.val, t));\n+    ret res(sub.res.bcx, load_if_immediate(sub.res.bcx, sub.res.val, t));\n }\n \n // We pass structural values around the compiler \"by pointer\" and\n-// non-structural values (scalars and boxes) \"by value\". This function selects\n-// whether to load a pointer or pass it.\n+// non-structural values (scalars, boxes, pointers) \"by value\". We call the\n+// latter group \"immediates\" and, in some circumstances when we know we have a\n+// pointer (or need one), perform load/store operations based on the\n+// immediate-ness of the type.\n+\n+fn type_is_immediate(@ty.t t) -> bool {\n+    ret ty.type_is_scalar(t) || ty.type_is_boxed(t) || ty.type_is_native(t);\n+}\n+\n+fn do_spill(@block_ctxt cx, ValueRef v) -> ValueRef {\n+    // We have a value but we have to spill it to pass by alias.\n+    auto llptr = alloca(cx, val_ty(v));\n+    cx.build.Store(v, llptr);\n+    ret llptr;\n+}\n \n-fn load_scalar_or_boxed(@block_ctxt cx,\n-                        ValueRef v,\n-                        @ty.t t) -> ValueRef {\n-    if (ty.type_is_scalar(t) || ty.type_is_boxed(t) || ty.type_is_native(t)) {\n+fn spill_if_immediate(@block_ctxt cx, ValueRef v, @ty.t t) -> ValueRef {\n+    if (type_is_immediate(t)) {\n+        ret do_spill(cx, v);\n+    }\n+    ret v;\n+}\n+\n+fn load_if_immediate(@block_ctxt cx, ValueRef v, @ty.t t) -> ValueRef {\n+    if (type_is_immediate(t)) {\n         ret cx.build.Load(v);\n-    } else {\n-        ret v;\n     }\n+    ret v;\n }\n \n fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n@@ -5180,7 +5205,7 @@ fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n                                 vp2i(bcx, prt.val)));\n     bcx = sub.bcx;\n \n-    auto data_load = load_scalar_or_boxed(bcx, lhs, unit_ty);\n+    auto data_load = load_if_immediate(bcx, lhs, unit_ty);\n     auto cp = copy_ty(bcx, action, lhs, data_load, unit_ty);\n     bcx = cp.bcx;\n \n@@ -5437,7 +5462,7 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n                     fn drop_hoisted_ty(@block_ctxt cx,\n                                        ValueRef alloca_val,\n                                        @ty.t t) -> result {\n-                        auto reg_val = load_scalar_or_boxed(cx,\n+                        auto reg_val = load_if_immediate(cx,\n                                                             alloca_val, t);\n                         ret drop_ty(cx, reg_val, t);\n                     }\n@@ -5881,7 +5906,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         i = 0;\n         for (ast.obj_field f in ob.fields) {\n             auto arg = bcx.fcx.llargs.get(f.id);\n-            arg = load_scalar_or_boxed(bcx, arg, arg_tys.(i).ty);\n+            arg = load_if_immediate(bcx, arg, arg_tys.(i).ty);\n             auto field = GEP_tup_like(bcx, fields_ty, body_fields.val,\n                                       vec(0, i));\n             bcx = field.bcx;"}]}