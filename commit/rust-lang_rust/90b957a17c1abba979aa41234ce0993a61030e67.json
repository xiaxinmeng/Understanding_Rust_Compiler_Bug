{"sha": "90b957a17c1abba979aa41234ce0993a61030e67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYjk1N2ExN2MxYWJiYTk3OWFhNDEyMzRjZTA5OTNhNjEwMzBlNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T12:29:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-11T12:29:35Z"}, "message": "Auto merge of #66821 - eddyb:global-trait-caching, r=nikomatsakis\n\nrustc: allow non-empty ParamEnv's in global trait select/eval caches.\n\n*Based on #66963*\n\nThis appears to alleviate the symptoms of #65510 locally (without fixing WF directly), and is potentially easier to validate as sound (since it's a more ad-hoc version of queries we already have).\n\nI'm opening this PR primarily to test the effects on perf.\n\nr? @nikomatsakis cc @rust-lang/wg-traits", "tree": {"sha": "9cb626311e03c5fe3d1d140739b6f2ba0a70fc90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cb626311e03c5fe3d1d140739b6f2ba0a70fc90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90b957a17c1abba979aa41234ce0993a61030e67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90b957a17c1abba979aa41234ce0993a61030e67", "html_url": "https://github.com/rust-lang/rust/commit/90b957a17c1abba979aa41234ce0993a61030e67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90b957a17c1abba979aa41234ce0993a61030e67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "033662dfbca088937b9cdfd3d9584015b5e375b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/033662dfbca088937b9cdfd3d9584015b5e375b2", "html_url": "https://github.com/rust-lang/rust/commit/033662dfbca088937b9cdfd3d9584015b5e375b2"}, {"sha": "a266ea0bd03508724341a2382b5ba8a22aa6e667", "url": "https://api.github.com/repos/rust-lang/rust/commits/a266ea0bd03508724341a2382b5ba8a22aa6e667", "html_url": "https://github.com/rust-lang/rust/commit/a266ea0bd03508724341a2382b5ba8a22aa6e667"}], "stats": {"total": 62, "additions": 36, "deletions": 26}, "files": [{"sha": "1fdec5f0152512c73a3bd1fcd38a2b22bd74eaf1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90b957a17c1abba979aa41234ce0993a61030e67/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90b957a17c1abba979aa41234ce0993a61030e67/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=90b957a17c1abba979aa41234ce0993a61030e67", "patch": "@@ -1079,12 +1079,10 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 if !is_default {\n                     true\n                 } else if obligation.param_env.reveal == Reveal::All {\n-                    debug_assert!(!poly_trait_ref.needs_infer());\n-                    if !poly_trait_ref.needs_subst() {\n-                        true\n-                    } else {\n-                        false\n-                    }\n+                    // NOTE(eddyb) inference variables can resolve to parameters, so\n+                    // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n+                    let poly_trait_ref = selcx.infcx().resolve_vars_if_possible(&poly_trait_ref);\n+                    !poly_trait_ref.needs_infer() && !poly_trait_ref.needs_subst()\n                 } else {\n                     false\n                 }"}, {"sha": "94a77c553e53a9affa863ab135cf0bdca421f819", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/90b957a17c1abba979aa41234ce0993a61030e67/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90b957a17c1abba979aa41234ce0993a61030e67/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=90b957a17c1abba979aa41234ce0993a61030e67", "patch": "@@ -204,7 +204,10 @@ struct TraitObligationStack<'prev, 'tcx> {\n #[derive(Clone, Default)]\n pub struct SelectionCache<'tcx> {\n     hashmap: Lock<\n-        FxHashMap<ty::TraitRef<'tcx>, WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+        FxHashMap<\n+            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n+        >,\n     >,\n }\n \n@@ -490,7 +493,9 @@ impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n \n #[derive(Clone, Default)]\n pub struct EvaluationCache<'tcx> {\n-    hashmap: Lock<FxHashMap<ty::PolyTraitRef<'tcx>, WithDepNode<EvaluationResult>>>,\n+    hashmap: Lock<\n+        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n+    >,\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n@@ -1143,15 +1148,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n             let cache = tcx.evaluation_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&trait_ref) {\n+            if let Some(cached) = cache.get(&param_env.and(trait_ref)) {\n                 return Some(cached.get(tcx));\n             }\n         }\n         self.infcx\n             .evaluation_cache\n             .hashmap\n             .borrow()\n-            .get(&trait_ref)\n+            .get(&param_env.and(trait_ref))\n             .map(|v| v.get(tcx))\n     }\n \n@@ -1182,7 +1187,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .evaluation_cache\n                     .hashmap\n                     .borrow_mut()\n-                    .insert(trait_ref, WithDepNode::new(dep_node, result));\n+                    .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n                 return;\n             }\n         }\n@@ -1195,7 +1200,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .evaluation_cache\n             .hashmap\n             .borrow_mut()\n-            .insert(trait_ref, WithDepNode::new(dep_node, result));\n+            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n     }\n \n     /// For various reasons, it's possible for a subobligation\n@@ -1567,14 +1572,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Do note that if the type itself is not in the\n     /// global tcx, the local caches will be used.\n     fn can_use_global_caches(&self, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        // If there are any where-clauses in scope, then we always use\n-        // a cache local to this particular scope. Otherwise, we\n-        // switch to a global cache. We used to try and draw\n-        // finer-grained distinctions, but that led to a serious of\n-        // annoying and weird bugs like #22019 and #18290. This simple\n-        // rule seems to be pretty clearly safe and also still retains\n-        // a very high hit rate (~95% when compiling rustc).\n-        if !param_env.caller_bounds.is_empty() {\n+        // If there are any e.g. inference variables in the `ParamEnv`, then we\n+        // always use a cache local to this particular scope. Otherwise, we\n+        // switch to a global cache.\n+        if param_env.has_local_value() {\n             return false;\n         }\n \n@@ -1602,15 +1603,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n             let cache = tcx.selection_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&trait_ref) {\n+            if let Some(cached) = cache.get(&param_env.and(*trait_ref)) {\n                 return Some(cached.get(tcx));\n             }\n         }\n         self.infcx\n             .selection_cache\n             .hashmap\n             .borrow()\n-            .get(trait_ref)\n+            .get(&param_env.and(*trait_ref))\n             .map(|v| v.get(tcx))\n     }\n \n@@ -1671,7 +1672,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     tcx.selection_cache\n                         .hashmap\n                         .borrow_mut()\n-                        .insert(trait_ref, WithDepNode::new(dep_node, candidate));\n+                        .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n                     return;\n                 }\n             }\n@@ -1685,7 +1686,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .selection_cache\n             .hashmap\n             .borrow_mut()\n-            .insert(trait_ref, WithDepNode::new(dep_node, candidate));\n+            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n     }\n \n     fn assemble_candidates<'o>("}, {"sha": "1becb1e83a5acafae49e8a1e42a9c4907e32b070", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90b957a17c1abba979aa41234ce0993a61030e67/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90b957a17c1abba979aa41234ce0993a61030e67/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=90b957a17c1abba979aa41234ce0993a61030e67", "patch": "@@ -9,6 +9,7 @@ trait TraitWithAssoc {\n \n type Foo<V> = impl Trait<V>;\n //~^ ERROR could not find defining uses\n+//~| ERROR the trait bound `T: TraitWithAssoc` is not satisfied\n \n trait Trait<U> {}\n "}, {"sha": "1eb4cf2a8025570056529636870c9df4d5de23aa", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90b957a17c1abba979aa41234ce0993a61030e67/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90b957a17c1abba979aa41234ce0993a61030e67/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=90b957a17c1abba979aa41234ce0993a61030e67", "patch": "@@ -1,5 +1,14 @@\n+error[E0277]: the trait bound `T: TraitWithAssoc` is not satisfied\n+  --> $DIR/bound_reduction2.rs:10:1\n+   |\n+LL | type Foo<V> = impl Trait<V>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `TraitWithAssoc` is not implemented for `T`\n+...\n+LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+   |                  -- help: consider further restricting this bound: `T: TraitWithAssoc +`\n+\n error: defining opaque type use does not fully define opaque type: generic parameter `V` is specified as concrete type `<T as TraitWithAssoc>::Assoc`\n-  --> $DIR/bound_reduction2.rs:17:1\n+  --> $DIR/bound_reduction2.rs:18:1\n    |\n LL | / fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n LL | |     ()\n@@ -12,5 +21,6 @@ error: could not find defining uses\n LL | type Foo<V> = impl Trait<V>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}]}