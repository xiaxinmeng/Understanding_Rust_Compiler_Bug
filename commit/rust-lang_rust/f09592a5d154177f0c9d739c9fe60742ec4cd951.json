{"sha": "f09592a5d154177f0c9d739c9fe60742ec4cd951", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwOTU5MmE1ZDE1NDE3N2YwYzlkNzM5YzlmZTYwNzQyZWM0Y2Q5NTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-05T23:58:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-14T00:27:42Z"}, "message": "io: Implement process wait timeouts\n\nThis implements set_timeout() for std::io::Process which will affect wait()\noperations on the process. This follows the same pattern as the rest of the\ntimeouts emerging in std::io::net.\n\nThe implementation was super easy for everything except libnative on unix\n(backwards from usual!), which required a good bit of signal handling. There's a\ndoc comment explaining the strategy in libnative. Internally, this also required\nrefactoring the \"helper thread\" implementation used by libnative to allow for an\nextra helper thread (not just the timer).\n\nThis is a breaking change in terms of the io::Process API. It is now possible\nfor wait() to fail, and subsequently wait_with_output(). These two functions now\nreturn IoResult<T> due to the fact that they can time out.\n\nAdditionally, the wait_with_output() function has moved from taking `&mut self`\nto taking `self`. If a timeout occurs while waiting with output, the semantics\nare undesirable in almost all cases if attempting to re-wait on the process.\nEquivalent functionality can still be achieved by dealing with the output\nhandles manually.\n\n[breaking-change]\n\ncc #13523", "tree": {"sha": "79540b4f5f7e125a260b9ca00f25e796241425f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79540b4f5f7e125a260b9ca00f25e796241425f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f09592a5d154177f0c9d739c9fe60742ec4cd951", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f09592a5d154177f0c9d739c9fe60742ec4cd951", "html_url": "https://github.com/rust-lang/rust/commit/f09592a5d154177f0c9d739c9fe60742ec4cd951", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f09592a5d154177f0c9d739c9fe60742ec4cd951/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f7caed2024268f6de16f99b6696d191f3ca3228", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f7caed2024268f6de16f99b6696d191f3ca3228", "html_url": "https://github.com/rust-lang/rust/commit/9f7caed2024268f6de16f99b6696d191f3ca3228"}], "stats": {"total": 1202, "additions": 876, "deletions": 326}, "files": [{"sha": "d3642a939db049a30c9c42a9ea561fe30b33a79c", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -68,19 +68,20 @@ pub fn run(lib_path: &str,\n            input: Option<~str>) -> Option<Result> {\n \n     let env = env.clone().append(target_env(lib_path, prog).as_slice());\n-    let mut opt_process = Process::configure(ProcessConfig {\n+    let opt_process = Process::configure(ProcessConfig {\n         program: prog,\n         args: args,\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     });\n \n     match opt_process {\n-        Ok(ref mut process) => {\n+        Ok(mut process) => {\n             for input in input.iter() {\n                 process.stdin.get_mut_ref().write(input.as_bytes()).unwrap();\n             }\n-            let ProcessOutput { status, output, error } = process.wait_with_output();\n+            let ProcessOutput { status, output, error } =\n+                process.wait_with_output().unwrap();\n \n             Some(Result {\n                 status: status,"}, {"sha": "d18f1370a9f4769f1e8026d8a42bb29cc4b26ebb", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -502,16 +502,17 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         let args = &[lldb_batchmode_script, test_executable_str, debugger_script_str];\n         let env = &[(\"PYTHONPATH\".to_owned(), config.lldb_python_dir.clone().unwrap())];\n \n-        let mut opt_process = Process::configure(ProcessConfig {\n+        let opt_process = Process::configure(ProcessConfig {\n             program: \"python\",\n             args: args,\n             env: Some(env),\n             .. ProcessConfig::new()\n         });\n \n         let (status, out, err) = match opt_process {\n-            Ok(ref mut process) => {\n-                let ProcessOutput { status, output, error } = process.wait_with_output();\n+            Ok(process) => {\n+                let ProcessOutput { status, output, error } =\n+                    process.wait_with_output().unwrap();\n \n                 (status,\n                  str::from_utf8(output.as_slice()).unwrap().to_owned(),"}, {"sha": "1481759297868a8be3095241f6c34783f75277ae", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -1725,6 +1725,7 @@ impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n+        if index > self.len() { return false; }\n         let b = self[index];\n         return b < 128u8 || b >= 192u8;\n     }"}, {"sha": "1edd99c1d7dcc98f4fc1b0934bd35b177368ae4c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -173,7 +173,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(unix)] pub use consts::os::posix88::{EADDRINUSE, ENOENT, EISDIR, EAGAIN, EWOULDBLOCK};\n #[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT, EINPROGRESS};\n #[cfg(unix)] pub use consts::os::posix88::{SIGTERM, SIGKILL, SIGPIPE, PROT_NONE};\n-#[cfg(unix)] pub use consts::os::posix01::{SIG_IGN, WNOHANG};\n+#[cfg(unix)] pub use consts::os::posix01::{SIG_IGN};\n #[cfg(unix)] pub use consts::os::bsd44::{AF_UNIX};\n \n #[cfg(unix)] pub use types::os::common::posix01::{pthread_t, timespec, timezone};\n@@ -2473,8 +2473,6 @@ pub mod consts {\n \n             pub static CLOCK_REALTIME: c_int = 0;\n             pub static CLOCK_MONOTONIC: c_int = 1;\n-\n-            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -2924,8 +2922,6 @@ pub mod consts {\n \n             pub static CLOCK_REALTIME: c_int = 0;\n             pub static CLOCK_MONOTONIC: c_int = 4;\n-\n-            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -3313,8 +3309,6 @@ pub mod consts {\n             pub static PTHREAD_CREATE_JOINABLE: c_int = 1;\n             pub static PTHREAD_CREATE_DETACHED: c_int = 2;\n             pub static PTHREAD_STACK_MIN: size_t = 8192;\n-\n-            pub static WNOHANG: c_int = 1;\n         }\n         pub mod posix08 {\n         }\n@@ -3980,16 +3974,6 @@ pub mod funcs {\n             }\n         }\n \n-        pub mod wait {\n-            use types::os::arch::c95::{c_int};\n-            use types::os::arch::posix88::{pid_t};\n-\n-            extern {\n-                pub fn waitpid(pid: pid_t, status: *mut c_int, options: c_int)\n-                               -> pid_t;\n-            }\n-        }\n-\n         pub mod glob {\n             use types::os::arch::c95::{c_char, c_int};\n             use types::os::common::posix01::{glob_t};"}, {"sha": "767090a10cda222e4584f9880f9973e29dddc8fc", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -10,7 +10,12 @@\n \n //! C definitions used by libnative that don't belong in liblibc\n \n+#![allow(dead_code)]\n+\n pub use self::select::fd_set;\n+pub use self::signal::{sigaction, siginfo, sigset_t};\n+pub use self::signal::{SA_ONSTACK, SA_RESTART, SA_RESETHAND, SA_NOCLDSTOP};\n+pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};\n \n use libc;\n \n@@ -34,6 +39,8 @@ pub static MSG_DONTWAIT: libc::c_int = 0x80;\n #[cfg(target_os = \"android\")]\n pub static MSG_DONTWAIT: libc::c_int = 0x40;\n \n+pub static WNOHANG: libc::c_int = 1;\n+\n extern {\n     pub fn gettimeofday(timeval: *mut libc::timeval,\n                         tzp: *libc::c_void) -> libc::c_int;\n@@ -49,6 +56,17 @@ extern {\n                       optlen: *mut libc::socklen_t) -> libc::c_int;\n     pub fn ioctl(fd: libc::c_int, req: libc::c_ulong, ...) -> libc::c_int;\n \n+\n+    pub fn waitpid(pid: libc::pid_t, status: *mut libc::c_int,\n+                   options: libc::c_int) -> libc::pid_t;\n+\n+    pub fn sigaction(signum: libc::c_int,\n+                     act: *sigaction,\n+                     oldact: *mut sigaction) -> libc::c_int;\n+\n+    pub fn sigaddset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n+    pub fn sigdelset(set: *mut sigset_t, signum: libc::c_int) -> libc::c_int;\n+    pub fn sigemptyset(set: *mut sigset_t) -> libc::c_int;\n }\n \n #[cfg(target_os = \"macos\")]\n@@ -81,3 +99,94 @@ mod select {\n         set.fds_bits[fd / uint::BITS] |= 1 << (fd % uint::BITS);\n     }\n }\n+\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"android\")]\n+mod signal {\n+    use libc;\n+\n+    pub static SA_NOCLDSTOP: libc::c_ulong = 0x00000001;\n+    pub static SA_NOCLDWAIT: libc::c_ulong = 0x00000002;\n+    pub static SA_NODEFER: libc::c_ulong = 0x40000000;\n+    pub static SA_ONSTACK: libc::c_ulong = 0x08000000;\n+    pub static SA_RESETHAND: libc::c_ulong = 0x80000000;\n+    pub static SA_RESTART: libc::c_ulong = 0x10000000;\n+    pub static SA_SIGINFO: libc::c_ulong = 0x00000004;\n+    pub static SIGCHLD: libc::c_int = 17;\n+\n+    // This definition is not as accurate as it could be, {pid, uid, status} is\n+    // actually a giant union. Currently we're only interested in these fields,\n+    // however.\n+    pub struct siginfo {\n+        si_signo: libc::c_int,\n+        si_errno: libc::c_int,\n+        si_code: libc::c_int,\n+        pub pid: libc::pid_t,\n+        pub uid: libc::uid_t,\n+        pub status: libc::c_int,\n+    }\n+\n+    pub struct sigaction {\n+        pub sa_handler: extern fn(libc::c_int),\n+        pub sa_mask: sigset_t,\n+        pub sa_flags: libc::c_ulong,\n+        sa_restorer: *mut libc::c_void,\n+    }\n+\n+    #[cfg(target_word_size = \"32\")]\n+    pub struct sigset_t {\n+        __val: [libc::c_ulong, ..32],\n+    }\n+    #[cfg(target_word_size = \"64\")]\n+    pub struct sigset_t {\n+        __val: [libc::c_ulong, ..16],\n+    }\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+mod signal {\n+    use libc;\n+\n+    pub static SA_ONSTACK: libc::c_int = 0x0001;\n+    pub static SA_RESTART: libc::c_int = 0x0002;\n+    pub static SA_RESETHAND: libc::c_int = 0x0004;\n+    pub static SA_NOCLDSTOP: libc::c_int = 0x0008;\n+    pub static SA_NODEFER: libc::c_int = 0x0010;\n+    pub static SA_NOCLDWAIT: libc::c_int = 0x0020;\n+    pub static SA_SIGINFO: libc::c_int = 0x0040;\n+    pub static SIGCHLD: libc::c_int = 20;\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub type sigset_t = u32;\n+    #[cfg(target_os = \"freebsd\")]\n+    pub struct sigset_t {\n+        bits: [u32, ..4],\n+    }\n+\n+    // This structure has more fields, but we're not all that interested in\n+    // them.\n+    pub struct siginfo {\n+        pub si_signo: libc::c_int,\n+        pub si_errno: libc::c_int,\n+        pub si_code: libc::c_int,\n+        pub pid: libc::pid_t,\n+        pub uid: libc::uid_t,\n+        pub status: libc::c_int,\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub struct sigaction {\n+        pub sa_handler: extern fn(libc::c_int),\n+        sa_tramp: *mut libc::c_void,\n+        pub sa_mask: sigset_t,\n+        pub sa_flags: libc::c_int,\n+    }\n+\n+    #[cfg(target_os = \"freebsd\")]\n+    pub struct sigaction {\n+        pub sa_handler: extern fn(libc::c_int),\n+        pub sa_flags: libc::c_int,\n+        pub sa_mask: sigset_t,\n+    }\n+}"}, {"sha": "2260d74e1617705c3b3fcfc423f47b0f37d661ec", "filename": "src/libnative/io/helper_thread.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -0,0 +1,205 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the helper thread for the timer module\n+//!\n+//! This module contains the management necessary for the timer worker thread.\n+//! This thread is responsible for performing the send()s on channels for timers\n+//! that are using channels instead of a blocking call.\n+//!\n+//! The timer thread is lazily initialized, and it's shut down via the\n+//! `shutdown` function provided. It must be maintained as an invariant that\n+//! `shutdown` is only called when the entire program is finished. No new timers\n+//! can be created in the future and there must be no active timers at that\n+//! time.\n+\n+#![macro_escape]\n+\n+use std::mem;\n+use std::rt::bookkeeping;\n+use std::rt;\n+use std::ty::Unsafe;\n+use std::unstable::mutex::StaticNativeMutex;\n+\n+use task;\n+\n+/// A structure for management of a helper thread.\n+///\n+/// This is generally a static structure which tracks the lifetime of a helper\n+/// thread.\n+///\n+/// The fields of this helper are all public, but they should not be used, this\n+/// is for static initialization.\n+pub struct Helper<M> {\n+    /// Internal lock which protects the remaining fields\n+    pub lock: StaticNativeMutex,\n+\n+    // You'll notice that the remaining fields are Unsafe<T>, and this is\n+    // because all helper thread operations are done through &self, but we need\n+    // these to be mutable (once `lock` is held).\n+\n+    /// Lazily allocated channel to send messages to the helper thread.\n+    pub chan: Unsafe<*mut Sender<M>>,\n+\n+    /// OS handle used to wake up a blocked helper thread\n+    pub signal: Unsafe<uint>,\n+\n+    /// Flag if this helper thread has booted and been initialized yet.\n+    pub initialized: Unsafe<bool>,\n+}\n+\n+macro_rules! helper_init( (static mut $name:ident: Helper<$m:ty>) => (\n+    static mut $name: Helper<$m> = Helper {\n+        lock: ::std::unstable::mutex::NATIVE_MUTEX_INIT,\n+        chan: ::std::ty::Unsafe {\n+            value: 0 as *mut Sender<$m>,\n+            marker1: ::std::kinds::marker::InvariantType,\n+        },\n+        signal: ::std::ty::Unsafe {\n+            value: 0,\n+            marker1: ::std::kinds::marker::InvariantType,\n+        },\n+        initialized: ::std::ty::Unsafe {\n+            value: false,\n+            marker1: ::std::kinds::marker::InvariantType,\n+        },\n+    };\n+) )\n+\n+impl<M: Send> Helper<M> {\n+    /// Lazily boots a helper thread, becoming a no-op if the helper has already\n+    /// been spawned.\n+    ///\n+    /// This function will check to see if the thread has been initialized, and\n+    /// if it has it returns quickly. If initialization has not happened yet,\n+    /// the closure `f` will be run (inside of the initialization lock) and\n+    /// passed to the helper thread in a separate task.\n+    ///\n+    /// This function is safe to be called many times.\n+    pub fn boot<T: Send>(&'static self,\n+                         f: || -> T,\n+                         helper: fn(imp::signal, Receiver<M>, T)) {\n+        unsafe {\n+            let _guard = self.lock.lock();\n+            if !*self.initialized.get() {\n+                let (tx, rx) = channel();\n+                *self.chan.get() = mem::transmute(box tx);\n+                let (receive, send) = imp::new();\n+                *self.signal.get() = send as uint;\n+\n+                let t = f();\n+                task::spawn(proc() {\n+                    bookkeeping::decrement();\n+                    helper(receive, rx, t);\n+                    self.lock.lock().signal()\n+                });\n+\n+                rt::at_exit(proc() { self.shutdown() });\n+                *self.initialized.get() = true;\n+            }\n+        }\n+    }\n+\n+    /// Sends a message to a spawned worker thread.\n+    ///\n+    /// This is only valid if the worker thread has previously booted\n+    pub fn send(&'static self, msg: M) {\n+        unsafe {\n+            let _guard = self.lock.lock();\n+\n+            // Must send and *then* signal to ensure that the child receives the\n+            // message. Otherwise it could wake up and go to sleep before we\n+            // send the message.\n+            assert!(!self.chan.get().is_null());\n+            (**self.chan.get()).send(msg);\n+            imp::signal(*self.signal.get() as imp::signal);\n+        }\n+    }\n+\n+    fn shutdown(&'static self) {\n+        unsafe {\n+            // Shut down, but make sure this is done inside our lock to ensure\n+            // that we'll always receive the exit signal when the thread\n+            // returns.\n+            let guard = self.lock.lock();\n+\n+            // Close the channel by destroying it\n+            let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n+            *self.chan.get() = 0 as *mut Sender<M>;\n+            drop(chan);\n+            imp::signal(*self.signal.get() as imp::signal);\n+\n+            // Wait for the child to exit\n+            guard.wait();\n+            drop(guard);\n+\n+            // Clean up after ourselves\n+            self.lock.destroy();\n+            imp::close(*self.signal.get() as imp::signal);\n+            *self.signal.get() = 0;\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+mod imp {\n+    use libc;\n+    use std::os;\n+\n+    use io::file::FileDesc;\n+\n+    pub type signal = libc::c_int;\n+\n+    pub fn new() -> (signal, signal) {\n+        let pipe = os::pipe();\n+        (pipe.input, pipe.out)\n+    }\n+\n+    pub fn signal(fd: libc::c_int) {\n+        FileDesc::new(fd, false).inner_write([0]).unwrap();\n+    }\n+\n+    pub fn close(fd: libc::c_int) {\n+        let _fd = FileDesc::new(fd, true);\n+    }\n+}\n+\n+#[cfg(windows)]\n+mod imp {\n+    use libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n+    use std::ptr;\n+    use libc;\n+\n+    pub type signal = HANDLE;\n+\n+    pub fn new() -> (HANDLE, HANDLE) {\n+        unsafe {\n+            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n+                                      ptr::null());\n+            (handle, handle)\n+        }\n+    }\n+\n+    pub fn signal(handle: HANDLE) {\n+        assert!(unsafe { SetEvent(handle) != 0 });\n+    }\n+\n+    pub fn close(handle: HANDLE) {\n+        assert!(unsafe { CloseHandle(handle) != 0 });\n+    }\n+\n+    extern \"system\" {\n+        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n+                        bManualReset: BOOL,\n+                        bInitialState: BOOL,\n+                        lpName: LPCSTR) -> HANDLE;\n+        fn SetEvent(hEvent: HANDLE) -> BOOL;\n+    }\n+}"}, {"sha": "a9aca656319efa7a4263131246c4f3412023c0ad", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -40,6 +40,8 @@ use ai = std::io::net::addrinfo;\n pub use self::file::FileDesc;\n pub use self::process::Process;\n \n+mod helper_thread;\n+\n // Native I/O implementations\n pub mod addrinfo;\n pub mod net;\n@@ -75,8 +77,6 @@ pub mod pipe;\n #[cfg(unix)]    #[path = \"c_unix.rs\"]  mod c;\n #[cfg(windows)] #[path = \"c_win32.rs\"] mod c;\n \n-mod timer_helper;\n-\n pub type IoResult<T> = Result<T, IoError>;\n \n fn unimpl() -> IoError {"}, {"sha": "799db64e6889775878386af1bf26ceb6b5913662", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 311, "deletions": 52, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -8,20 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n+use std::io;\n+use std::mem;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n use p = std::io::process;\n \n+\n use super::IoResult;\n use super::file;\n+use super::util;\n \n-#[cfg(windows)] use std::mem;\n #[cfg(windows)] use std::strbuf::StrBuf;\n-#[cfg(not(windows))] use super::retry;\n+#[cfg(unix)] use super::c;\n+#[cfg(unix)] use super::retry;\n+#[cfg(unix)] use io::helper_thread::Helper;\n+\n+#[cfg(unix)]\n+helper_init!(static mut HELPER: Helper<Req>)\n \n /**\n  * A value representing a child process.\n@@ -44,6 +51,14 @@ pub struct Process {\n \n     /// Manually delivered signal\n     exit_signal: Option<int>,\n+\n+    /// Deadline after which wait() will return\n+    deadline: u64,\n+}\n+\n+#[cfg(unix)]\n+enum Req {\n+    NewChild(libc::pid_t, Sender<p::ProcessExit>, u64),\n }\n \n impl Process {\n@@ -116,6 +131,7 @@ impl Process {\n                         handle: res.handle,\n                         exit_code: None,\n                         exit_signal: None,\n+                        deadline: 0,\n                     },\n                     ret_io))\n             }\n@@ -131,11 +147,15 @@ impl Process {\n impl rtio::RtioProcess for Process {\n     fn id(&self) -> pid_t { self.pid }\n \n-    fn wait(&mut self) -> p::ProcessExit {\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n+    }\n+\n+    fn wait(&mut self) -> IoResult<p::ProcessExit> {\n         match self.exit_code {\n-            Some(code) => code,\n+            Some(code) => Ok(code),\n             None => {\n-                let code = waitpid(self.pid);\n+                let code = try!(waitpid(self.pid, self.deadline));\n                 // On windows, waitpid will never return a signal. If a signal\n                 // was successfully delivered to the process, however, we can\n                 // consider it as having died via a signal.\n@@ -145,7 +165,7 @@ impl rtio::RtioProcess for Process {\n                     Some(..) => code,\n                 };\n                 self.exit_code = Some(code);\n-                code\n+                Ok(code)\n             }\n         }\n     }\n@@ -762,61 +782,301 @@ fn translate_status(status: c_int) -> p::ProcessExit {\n  * operate on a none-existent process or, even worse, on a newer process\n  * with the same id.\n  */\n-fn waitpid(pid: pid_t) -> p::ProcessExit {\n-    return waitpid_os(pid);\n-\n-    #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n-            SYNCHRONIZE,\n-            PROCESS_QUERY_INFORMATION,\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_FAILED\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            OpenProcess,\n-            GetExitCodeProcess,\n-            CloseHandle,\n-            WaitForSingleObject\n-        };\n+#[cfg(windows)]\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+    use libc::types::os::arch::extra::DWORD;\n+    use libc::consts::os::extra::{\n+        SYNCHRONIZE,\n+        PROCESS_QUERY_INFORMATION,\n+        FALSE,\n+        STILL_ACTIVE,\n+        INFINITE,\n+        WAIT_TIMEOUT,\n+        WAIT_OBJECT_0,\n+    };\n+    use libc::funcs::extra::kernel32::{\n+        OpenProcess,\n+        GetExitCodeProcess,\n+        CloseHandle,\n+        WaitForSingleObject,\n+    };\n \n-        unsafe {\n+    unsafe {\n+        let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n+                                  FALSE,\n+                                  pid as DWORD);\n+        if process.is_null() {\n+            return Err(super::last_error())\n+        }\n \n-            let process = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION,\n-                                      FALSE,\n-                                      pid as DWORD);\n-            if process.is_null() {\n-                fail!(\"failure in OpenProcess: {}\", os::last_os_error());\n+        loop {\n+            let mut status = 0;\n+            if GetExitCodeProcess(process, &mut status) == FALSE {\n+                let err = Err(super::last_error());\n+                assert!(CloseHandle(process) != 0);\n+                return err;\n             }\n-\n-            loop {\n-                let mut status = 0;\n-                if GetExitCodeProcess(process, &mut status) == FALSE {\n-                    assert!(CloseHandle(process) != 0);\n-                    fail!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n-                }\n-                if status != STILL_ACTIVE {\n+            if status != STILL_ACTIVE {\n+                assert!(CloseHandle(process) != 0);\n+                return Ok(p::ExitStatus(status as int));\n+            }\n+            let interval = if deadline == 0 {\n+                INFINITE\n+            } else {\n+                let now = ::io::timer::now();\n+                if deadline < now {0} else {(deadline - now) as u32}\n+            };\n+            match WaitForSingleObject(process, interval) {\n+                WAIT_OBJECT_0 => {}\n+                WAIT_TIMEOUT => {\n                     assert!(CloseHandle(process) != 0);\n-                    return p::ExitStatus(status as int);\n+                    return Err(util::timeout(\"process wait timed out\"))\n                 }\n-                if WaitForSingleObject(process, INFINITE) == WAIT_FAILED {\n+                _ => {\n+                    let err = Err(super::last_error());\n                     assert!(CloseHandle(process) != 0);\n-                    fail!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n+                    return err\n                 }\n             }\n         }\n     }\n+}\n \n-    #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> p::ProcessExit {\n-        use libc::funcs::posix01::wait;\n-        let mut status = 0 as c_int;\n-        match retry(|| unsafe { wait::waitpid(pid, &mut status, 0) }) {\n+#[cfg(unix)]\n+fn waitpid(pid: pid_t, deadline: u64) -> IoResult<p::ProcessExit> {\n+    use std::cmp;\n+    use std::comm;\n+\n+    static mut WRITE_FD: libc::c_int = 0;\n+\n+    let mut status = 0 as c_int;\n+    if deadline == 0 {\n+        return match retry(|| unsafe { c::waitpid(pid, &mut status, 0) }) {\n             -1 => fail!(\"unknown waitpid error: {}\", super::last_error()),\n-            _ => translate_status(status),\n+            _ => Ok(translate_status(status)),\n+        }\n+    }\n+\n+    // On unix, wait() and its friends have no timeout parameters, so there is\n+    // no way to time out a thread in wait(). From some googling and some\n+    // thinking, it appears that there are a few ways to handle timeouts in\n+    // wait(), but the only real reasonable one for a multi-threaded program is\n+    // to listen for SIGCHLD.\n+    //\n+    // With this in mind, the waiting mechanism with a timeout barely uses\n+    // waitpid() at all. There are a few times that waitpid() is invoked with\n+    // WNOHANG, but otherwise all the necessary blocking is done by waiting for\n+    // a SIGCHLD to arrive (and that blocking has a timeout). Note, however,\n+    // that waitpid() is still used to actually reap the child.\n+    //\n+    // Signal handling is super tricky in general, and this is no exception. Due\n+    // to the async nature of SIGCHLD, we use the self-pipe trick to transmit\n+    // data out of the signal handler to the rest of the application. The first\n+    // idea would be to have each thread waiting with a timeout to read this\n+    // output file descriptor, but a write() is akin to a signal(), not a\n+    // broadcast(), so it would only wake up one thread, and possibly the wrong\n+    // thread. Hence a helper thread is used.\n+    //\n+    // The helper thread here is responsible for farming requests for a\n+    // waitpid() with a timeout, and then processing all of the wait requests.\n+    // By guaranteeing that only this helper thread is reading half of the\n+    // self-pipe, we're sure that we'll never lose a SIGCHLD. This helper thread\n+    // is also responsible for select() to wait for incoming messages or\n+    // incoming SIGCHLD messages, along with passing an appropriate timeout to\n+    // select() to wake things up as necessary.\n+    //\n+    // The ordering of the following statements is also very purposeful. First,\n+    // we must be guaranteed that the helper thread is booted and available to\n+    // receive SIGCHLD signals, and then we must also ensure that we do a\n+    // nonblocking waitpid() at least once before we go ask the sigchld helper.\n+    // This prevents the race where the child exits, we boot the helper, and\n+    // then we ask for the child's exit status (never seeing a sigchld).\n+    //\n+    // The actual communication between the helper thread and this thread is\n+    // quite simple, just a channel moving data around.\n+\n+    unsafe { HELPER.boot(register_sigchld, waitpid_helper) }\n+\n+    match waitpid_nowait(pid) {\n+        Some(ret) => return Ok(ret),\n+        None => {}\n+    }\n+\n+    let (tx, rx) = channel();\n+    unsafe { HELPER.send(NewChild(pid, tx, deadline)); }\n+    return match rx.recv_opt() {\n+        Ok(e) => Ok(e),\n+        Err(()) => Err(util::timeout(\"wait timed out\")),\n+    };\n+\n+    // Register a new SIGCHLD handler, returning the reading half of the\n+    // self-pipe plus the old handler registered (return value of sigaction).\n+    fn register_sigchld() -> (libc::c_int, c::sigaction) {\n+        unsafe {\n+            let mut old: c::sigaction = mem::init();\n+            let mut new: c::sigaction = mem::init();\n+            new.sa_handler = sigchld_handler;\n+            new.sa_flags = c::SA_NOCLDSTOP;\n+            assert_eq!(c::sigaction(c::SIGCHLD, &new, &mut old), 0);\n+\n+            let mut pipes = [0, ..2];\n+            assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n+            util::set_nonblocking(pipes[0], true).unwrap();\n+            util::set_nonblocking(pipes[1], true).unwrap();\n+            WRITE_FD = pipes[1];\n+            (pipes[0], old)\n+        }\n+    }\n+\n+    // Helper thread for processing SIGCHLD messages\n+    fn waitpid_helper(input: libc::c_int,\n+                      messages: Receiver<Req>,\n+                      (read_fd, old): (libc::c_int, c::sigaction)) {\n+        util::set_nonblocking(input, true).unwrap();\n+        let mut set: c::fd_set = unsafe { mem::init() };\n+        let mut tv: libc::timeval;\n+        let mut active = Vec::<(libc::pid_t, Sender<p::ProcessExit>, u64)>::new();\n+        let max = cmp::max(input, read_fd) + 1;\n+\n+        'outer: loop {\n+            // Figure out the timeout of our syscall-to-happen. If we're waiting\n+            // for some processes, then they'll have a timeout, otherwise we\n+            // wait indefinitely for a message to arrive.\n+            //\n+            // FIXME: sure would be nice to not have to scan the entire array\n+            let min = active.iter().map(|a| *a.ref2()).enumerate().min_by(|p| {\n+                p.val1()\n+            });\n+            let (p, idx) = match min {\n+                Some((idx, deadline)) => {\n+                    let now = ::io::timer::now();\n+                    let ms = if now < deadline {deadline - now} else {0};\n+                    tv = util::ms_to_timeval(ms);\n+                    (&tv as *_, idx)\n+                }\n+                None => (ptr::null(), -1),\n+            };\n+\n+            // Wait for something to happen\n+            c::fd_set(&mut set, input);\n+            c::fd_set(&mut set, read_fd);\n+            match unsafe { c::select(max, &set, ptr::null(), ptr::null(), p) } {\n+                // interrupted, retry\n+                -1 if os::errno() == libc::EINTR as int => continue,\n+\n+                // We read something, break out and process\n+                1 | 2 => {}\n+\n+                // Timeout, the pending request is removed\n+                0 => {\n+                    drop(active.remove(idx));\n+                    continue\n+                }\n+\n+                n => fail!(\"error in select {} ({})\", os::errno(), n),\n+            }\n+\n+            // Process any pending messages\n+            if drain(input) {\n+                loop {\n+                    match messages.try_recv() {\n+                        Ok(NewChild(pid, tx, deadline)) => {\n+                            active.push((pid, tx, deadline));\n+                        }\n+                        Err(comm::Disconnected) => {\n+                            assert!(active.len() == 0);\n+                            break 'outer;\n+                        }\n+                        Err(comm::Empty) => break,\n+                    }\n+                }\n+            }\n+\n+            // If a child exited (somehow received SIGCHLD), then poll all\n+            // children to see if any of them exited.\n+            //\n+            // We also attempt to be responsible netizens when dealing with\n+            // SIGCHLD by invoking any previous SIGCHLD handler instead of just\n+            // ignoring any previous SIGCHLD handler. Note that we don't provide\n+            // a 1:1 mapping of our handler invocations to the previous handler\n+            // invocations because we drain the `read_fd` entirely. This is\n+            // probably OK because the kernel is already allowed to coalesce\n+            // simultaneous signals, we're just doing some extra coalescing.\n+            //\n+            // Another point of note is that this likely runs the signal handler\n+            // on a different thread than the one that received the signal. I\n+            // *think* this is ok at this time.\n+            //\n+            // The main reason for doing this is to allow stdtest to run native\n+            // tests as well. Both libgreen and libnative are running around\n+            // with process timeouts, but libgreen should get there first\n+            // (currently libuv doesn't handle old signal handlers).\n+            if drain(read_fd) {\n+                let i: uint = unsafe { mem::transmute(old.sa_handler) };\n+                if i != 0 {\n+                    assert!(old.sa_flags & c::SA_SIGINFO == 0);\n+                    (old.sa_handler)(c::SIGCHLD);\n+                }\n+\n+                // FIXME: sure would be nice to not have to scan the entire\n+                //        array...\n+                active.retain(|&(pid, ref tx, _)| {\n+                    match waitpid_nowait(pid) {\n+                        Some(msg) => { tx.send(msg); false }\n+                        None => true,\n+                    }\n+                });\n+            }\n+        }\n+\n+        // Once this helper thread is done, we re-register the old sigchld\n+        // handler and close our intermediate file descriptors.\n+        unsafe {\n+            assert_eq!(c::sigaction(c::SIGCHLD, &old, ptr::mut_null()), 0);\n+            let _ = libc::close(read_fd);\n+            let _ = libc::close(WRITE_FD);\n+            WRITE_FD = -1;\n+        }\n+    }\n+\n+    // Drain all pending data from the file descriptor, returning if any data\n+    // could be drained. This requires that the file descriptor is in\n+    // nonblocking mode.\n+    fn drain(fd: libc::c_int) -> bool {\n+        let mut ret = false;\n+        loop {\n+            let mut buf = [0u8, ..1];\n+            match unsafe {\n+                libc::read(fd, buf.as_mut_ptr() as *mut libc::c_void,\n+                           buf.len() as libc::size_t)\n+            } {\n+                n if n > 0 => { ret = true; }\n+                0 => return true,\n+                -1 if util::wouldblock() => return ret,\n+                n => fail!(\"bad read {} ({})\", os::last_os_error(), n),\n+            }\n+        }\n+    }\n+\n+    // Signal handler for SIGCHLD signals, must be async-signal-safe!\n+    //\n+    // This function will write to the writing half of the \"self pipe\" to wake\n+    // up the helper thread if it's waiting. Note that this write must be\n+    // nonblocking because if it blocks and the reader is the thread we\n+    // interrupted, then we'll deadlock.\n+    //\n+    // When writing, if the write returns EWOULDBLOCK then we choose to ignore\n+    // it. At that point we're guaranteed that there's something in the pipe\n+    // which will wake up the other end at some point, so we just allow this\n+    // signal to be coalesced with the pending signals on the pipe.\n+    extern fn sigchld_handler(_signum: libc::c_int) {\n+        let mut msg = 1;\n+        match unsafe {\n+            libc::write(WRITE_FD, &mut msg as *mut _ as *libc::c_void, 1)\n+        } {\n+            1 => {}\n+            -1 if util::wouldblock() => {} // see above comments\n+            n => fail!(\"bad error on write fd: {} {}\", n, os::errno()),\n         }\n     }\n }\n@@ -830,10 +1090,9 @@ fn waitpid_nowait(pid: pid_t) -> Option<p::ProcessExit> {\n \n     #[cfg(unix)]\n     fn waitpid_os(pid: pid_t) -> Option<p::ProcessExit> {\n-        use libc::funcs::posix01::wait;\n         let mut status = 0 as c_int;\n         match retry(|| unsafe {\n-            wait::waitpid(pid, &mut status, libc::WNOHANG)\n+            c::waitpid(pid, &mut status, c::WNOHANG)\n         }) {\n             n if n == pid => Some(translate_status(status)),\n             0 => None,"}, {"sha": "95b2620f3c7987e1989bc03c0921bbbe21e6d870", "filename": "src/libnative/io/timer_helper.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/9f7caed2024268f6de16f99b6696d191f3ca3228/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7caed2024268f6de16f99b6696d191f3ca3228/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=9f7caed2024268f6de16f99b6696d191f3ca3228", "patch": "@@ -1,149 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of the helper thread for the timer module\n-//!\n-//! This module contains the management necessary for the timer worker thread.\n-//! This thread is responsible for performing the send()s on channels for timers\n-//! that are using channels instead of a blocking call.\n-//!\n-//! The timer thread is lazily initialized, and it's shut down via the\n-//! `shutdown` function provided. It must be maintained as an invariant that\n-//! `shutdown` is only called when the entire program is finished. No new timers\n-//! can be created in the future and there must be no active timers at that\n-//! time.\n-\n-use std::mem;\n-use std::rt::bookkeeping;\n-use std::rt;\n-use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-\n-use io::timer::{Req, Shutdown};\n-use task;\n-\n-// You'll note that these variables are *not* protected by a lock. These\n-// variables are initialized with a Once before any Timer is created and are\n-// only torn down after everything else has exited. This means that these\n-// variables are read-only during use (after initialization) and both of which\n-// are safe to use concurrently.\n-static mut HELPER_CHAN: *mut Sender<Req> = 0 as *mut Sender<Req>;\n-static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n-\n-static mut TIMER_HELPER_EXIT: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-pub fn boot(helper: fn(imp::signal, Receiver<Req>)) {\n-    static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-    static mut INITIALIZED: bool = false;\n-\n-    unsafe {\n-        let mut _guard = LOCK.lock();\n-        if !INITIALIZED {\n-            let (tx, rx) = channel();\n-            // promote this to a shared channel\n-            drop(tx.clone());\n-            HELPER_CHAN = mem::transmute(box tx);\n-            let (receive, send) = imp::new();\n-            HELPER_SIGNAL = send;\n-\n-            task::spawn(proc() {\n-                bookkeeping::decrement();\n-                helper(receive, rx);\n-                TIMER_HELPER_EXIT.lock().signal()\n-            });\n-\n-            rt::at_exit(proc() { shutdown() });\n-            INITIALIZED = true;\n-        }\n-    }\n-}\n-\n-pub fn send(req: Req) {\n-    unsafe {\n-        assert!(!HELPER_CHAN.is_null());\n-        (*HELPER_CHAN).send(req);\n-        imp::signal(HELPER_SIGNAL);\n-    }\n-}\n-\n-fn shutdown() {\n-    // Request a shutdown, and then wait for the task to exit\n-    unsafe {\n-        let guard = TIMER_HELPER_EXIT.lock();\n-        send(Shutdown);\n-        guard.wait();\n-        drop(guard);\n-        TIMER_HELPER_EXIT.destroy();\n-    }\n-\n-\n-    // Clean up after ther helper thread\n-    unsafe {\n-        imp::close(HELPER_SIGNAL);\n-        let _chan: Box<Sender<Req>> = mem::transmute(HELPER_CHAN);\n-        HELPER_CHAN = 0 as *mut Sender<Req>;\n-        HELPER_SIGNAL = 0 as imp::signal;\n-    }\n-}\n-\n-#[cfg(unix)]\n-mod imp {\n-    use libc;\n-    use std::os;\n-\n-    use io::file::FileDesc;\n-\n-    pub type signal = libc::c_int;\n-\n-    pub fn new() -> (signal, signal) {\n-        let pipe = os::pipe();\n-        (pipe.input, pipe.out)\n-    }\n-\n-    pub fn signal(fd: libc::c_int) {\n-        FileDesc::new(fd, false).inner_write([0]).unwrap();\n-    }\n-\n-    pub fn close(fd: libc::c_int) {\n-        let _fd = FileDesc::new(fd, true);\n-    }\n-}\n-\n-#[cfg(windows)]\n-mod imp {\n-    use libc::{BOOL, LPCSTR, HANDLE, LPSECURITY_ATTRIBUTES, CloseHandle};\n-    use std::ptr;\n-    use libc;\n-\n-    pub type signal = HANDLE;\n-\n-    pub fn new() -> (HANDLE, HANDLE) {\n-        unsafe {\n-            let handle = CreateEventA(ptr::mut_null(), libc::FALSE, libc::FALSE,\n-                                      ptr::null());\n-            (handle, handle)\n-        }\n-    }\n-\n-    pub fn signal(handle: HANDLE) {\n-        assert!(unsafe { SetEvent(handle) != 0 });\n-    }\n-\n-    pub fn close(handle: HANDLE) {\n-        assert!(unsafe { CloseHandle(handle) != 0 });\n-    }\n-\n-    extern \"system\" {\n-        fn CreateEventA(lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                        bManualReset: BOOL,\n-                        bInitialState: BOOL,\n-                        lpName: LPCSTR) -> HANDLE;\n-        fn SetEvent(hEvent: HANDLE) -> BOOL;\n-    }\n-}"}, {"sha": "2c5b798482777657c11770ffb002ea608d2f6210", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -52,11 +52,14 @@ use std::os;\n use std::ptr;\n use std::rt::rtio;\n use std::sync::atomics;\n+use std::comm;\n \n use io::IoResult;\n use io::c;\n use io::file::FileDesc;\n-use io::timer_helper;\n+use io::helper_thread::Helper;\n+\n+helper_init!(static mut HELPER: Helper<Req>)\n \n pub struct Timer {\n     id: uint,\n@@ -79,9 +82,6 @@ pub enum Req {\n     // Remove a timer based on its id and then send it back on the channel\n     // provided\n     RemoveTimer(uint, Sender<Box<Inner>>),\n-\n-    // Shut down the loop and then ACK this channel once it's shut down\n-    Shutdown,\n }\n \n // returns the current time (in milliseconds)\n@@ -93,7 +93,7 @@ pub fn now() -> u64 {\n     }\n }\n \n-fn helper(input: libc::c_int, messages: Receiver<Req>) {\n+fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     let mut set: c::fd_set = unsafe { mem::init() };\n \n     let mut fd = FileDesc::new(input, true);\n@@ -163,7 +163,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n             1 => {\n                 loop {\n                     match messages.try_recv() {\n-                        Ok(Shutdown) => {\n+                        Err(comm::Disconnected) => {\n                             assert!(active.len() == 0);\n                             break 'outer;\n                         }\n@@ -202,7 +202,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>) {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        timer_helper::boot(helper);\n+        unsafe { HELPER.boot(|| {}, helper); }\n \n         static mut ID: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n         let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };\n@@ -235,7 +235,7 @@ impl Timer {\n             Some(i) => i,\n             None => {\n                 let (tx, rx) = channel();\n-                timer_helper::send(RemoveTimer(self.id, tx));\n+                unsafe { HELPER.send(RemoveTimer(self.id, tx)); }\n                 rx.recv()\n             }\n         }\n@@ -261,7 +261,7 @@ impl rtio::RtioTimer for Timer {\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n-        timer_helper::send(NewTimer(inner));\n+        unsafe { HELPER.send(NewTimer(inner)); }\n         return rx;\n     }\n \n@@ -275,7 +275,7 @@ impl rtio::RtioTimer for Timer {\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n-        timer_helper::send(NewTimer(inner));\n+        unsafe { HELPER.send(NewTimer(inner)); }\n         return rx;\n     }\n }"}, {"sha": "e7130de05c26d3ffd2027b6e8af5858ff21a4f14", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -23,10 +23,13 @@\n use libc;\n use std::ptr;\n use std::rt::rtio;\n+use std::comm;\n \n-use io::timer_helper;\n+use io::helper_thread::Helper;\n use io::IoResult;\n \n+helper_init!(static mut HELPER: Helper<Req>)\n+\n pub struct Timer {\n     obj: libc::HANDLE,\n     on_worker: bool,\n@@ -35,10 +38,9 @@ pub struct Timer {\n pub enum Req {\n     NewTimer(libc::HANDLE, Sender<()>, bool),\n     RemoveTimer(libc::HANDLE, Sender<()>),\n-    Shutdown,\n }\n \n-fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n+fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n     let mut objs = vec![input];\n     let mut chans = vec![];\n \n@@ -67,12 +69,12 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n                             None => {}\n                         }\n                     }\n-                    Ok(Shutdown) => {\n+                    Err(comm::Disconnected) => {\n                         assert_eq!(objs.len(), 1);\n                         assert_eq!(chans.len(), 0);\n                         break 'outer;\n                     }\n-                    _ => break\n+                    Err(..) => break\n                 }\n             }\n         } else {\n@@ -102,7 +104,7 @@ pub fn now() -> u64 {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        timer_helper::boot(helper);\n+        unsafe { HELPER.boot(|| {}, helper) }\n \n         let obj = unsafe {\n             imp::CreateWaitableTimerA(ptr::mut_null(), 0, ptr::null())\n@@ -124,7 +126,7 @@ impl Timer {\n         if !self.on_worker { return }\n \n         let (tx, rx) = channel();\n-        timer_helper::send(RemoveTimer(self.obj, tx));\n+        unsafe { HELPER.send(RemoveTimer(self.obj, tx)) }\n         rx.recv();\n \n         self.on_worker = false;\n@@ -157,7 +159,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        timer_helper::send(NewTimer(self.obj, tx, true));\n+        unsafe { HELPER.send(NewTimer(self.obj, tx, true)) }\n         self.on_worker = true;\n         return rx;\n     }\n@@ -173,7 +175,7 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null(), ptr::mut_null(), 0)\n         }, 1);\n \n-        timer_helper::send(NewTimer(self.obj, tx, false));\n+        unsafe { HELPER.send(NewTimer(self.obj, tx, false)) }\n         self.on_worker = true;\n \n         return rx;"}, {"sha": "8ba06133369245a13d950b838df1d71d150303b7", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -55,6 +55,7 @@\n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the\n //    answer is that you don't need them)\n+#![feature(macro_rules)]\n \n extern crate libc;\n "}, {"sha": "04ce4f88831f4d0cd823b8d1c924bf5f54a10c51", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -54,8 +54,8 @@ fn run_ar(sess: &Session, args: &str, cwd: Option<&Path>,\n         cwd: cwd.map(|a| &*a),\n         .. ProcessConfig::new()\n     }) {\n-        Ok(mut prog) => {\n-            let o = prog.wait_with_output();\n+        Ok(prog) => {\n+            let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n                 sess.err(format!(\"{} {} failed with: {}\", ar, args.connect(\" \"),\n                                  o.status));"}, {"sha": "7afac6801519b652fe9453886c004164ced706f9", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -19,7 +19,8 @@ use std::rt::task::BlockedTask;\n use homing::{HomingIO, HomeHandle};\n use pipe::PipeWatcher;\n use super::{UvHandle, UvError, uv_error_to_io_error,\n-            wait_until_woken_after, wakeup};\n+            wait_until_woken_after, wakeup, Loop};\n+use timer::TimerWatcher;\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -32,6 +33,16 @@ pub struct Process {\n \n     /// Collected from the exit_cb\n     exit_status: Option<process::ProcessExit>,\n+\n+    /// Lazily initialized timeout timer\n+    timer: Option<Box<TimerWatcher>>,\n+    timeout_state: TimeoutState,\n+}\n+\n+enum TimeoutState {\n+    NoTimeout,\n+    TimeoutPending,\n+    TimeoutElapsed,\n }\n \n impl Process {\n@@ -92,6 +103,8 @@ impl Process {\n                     home: io_loop.make_handle(),\n                     to_wake: None,\n                     exit_status: None,\n+                    timer: None,\n+                    timeout_state: NoTimeout,\n                 };\n                 match unsafe {\n                     uvll::uv_spawn(io_loop.uv_loop(), handle, &options)\n@@ -223,21 +236,71 @@ impl RtioProcess for Process {\n         }\n     }\n \n-    fn wait(&mut self) -> process::ProcessExit {\n+    fn wait(&mut self) -> Result<process::ProcessExit, IoError> {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {\n-            Some(..) => {}\n-            None => {\n-                // If there's no exit code previously listed, then the\n-                // process's exit callback has yet to be invoked. We just\n-                // need to deschedule ourselves and wait to be reawoken.\n+            Some(status) => return Ok(status),\n+            None => {}\n+        }\n+\n+        // If there's no exit code previously listed, then the process's exit\n+        // callback has yet to be invoked. We just need to deschedule ourselves\n+        // and wait to be reawoken.\n+        match self.timeout_state {\n+            NoTimeout | TimeoutPending => {\n                 wait_until_woken_after(&mut self.to_wake, &self.uv_loop(), || {});\n-                assert!(self.exit_status.is_some());\n             }\n+            TimeoutElapsed => {}\n+        }\n+\n+        // If there's still no exit status listed, then we timed out, and we\n+        // need to return.\n+        match self.exit_status {\n+            Some(status) => Ok(status),\n+            None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+        }\n+    }\n+\n+    fn set_timeout(&mut self, timeout: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        self.timeout_state = NoTimeout;\n+        let ms = match timeout {\n+            Some(ms) => ms,\n+            None => {\n+                match self.timer {\n+                    Some(ref mut timer) => timer.stop(),\n+                    None => {}\n+                }\n+                return\n+            }\n+        };\n+        if self.timer.is_none() {\n+            let loop_ = Loop::wrap(unsafe {\n+                uvll::get_loop_for_uv_handle(self.uv_handle())\n+            });\n+            let mut timer = box TimerWatcher::new_home(&loop_, self.home().clone());\n+            unsafe {\n+                timer.set_data(self as *mut _ as *Process);\n+            }\n+            self.timer = Some(timer);\n         }\n \n-        self.exit_status.unwrap()\n+        let timer = self.timer.get_mut_ref();\n+        timer.stop();\n+        timer.start(timer_cb, ms, 0);\n+        self.timeout_state = TimeoutPending;\n+\n+        extern fn timer_cb(timer: *uvll::uv_timer_t) {\n+            let p: &mut Process = unsafe {\n+                &mut *(uvll::get_data_for_uv_handle(timer) as *mut Process)\n+            };\n+            p.timeout_state = TimeoutElapsed;\n+            match p.to_wake.take() {\n+                Some(task) => { let _t = task.wake().map(|t| t.reawaken()); }\n+                None => {}\n+            }\n+        }\n     }\n }\n "}, {"sha": "349cac723ff5b3303d487accbcb7283c6fd14599", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 131, "deletions": 59, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -10,6 +10,8 @@\n \n //! Bindings for executing child processes\n \n+#![allow(experimental)]\n+\n use prelude::*;\n \n use fmt;\n@@ -50,7 +52,7 @@ use rt::rtio::{RtioProcess, IoFactory, LocalIo};\n /// };\n ///\n /// let contents = child.stdout.get_mut_ref().read_to_end();\n-/// assert!(child.wait().success());\n+/// assert!(child.wait().unwrap().success());\n /// ```\n pub struct Process {\n     handle: Box<RtioProcess:Send>,\n@@ -284,7 +286,7 @@ impl Process {\n     /// println!(\"stderr: {}\", str::from_utf8_lossy(output.error.as_slice()));\n     /// ```\n     pub fn output(prog: &str, args: &[~str]) -> IoResult<ProcessOutput> {\n-        Process::new(prog, args).map(|mut p| p.wait_with_output())\n+        Process::new(prog, args).and_then(|p| p.wait_with_output())\n     }\n \n     /// Executes a child process and collects its exit status. This will block\n@@ -303,7 +305,7 @@ impl Process {\n     /// println!(\"process exited with: {}\", status);\n     /// ```\n     pub fn status(prog: &str, args: &[~str]) -> IoResult<ProcessExit> {\n-        Process::new(prog, args).map(|mut p| p.wait())\n+        Process::new(prog, args).and_then(|mut p| p.wait())\n     }\n \n     /// Creates a new process with the specified configuration.\n@@ -378,17 +380,72 @@ impl Process {\n     /// after it has been called at least once.\n     ///\n     /// The stdin handle to the child process will be closed before waiting.\n-    pub fn wait(&mut self) -> ProcessExit {\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function can fail if a timeout was previously specified via\n+    /// `set_timeout` and the timeout expires before the child exits.\n+    pub fn wait(&mut self) -> IoResult<ProcessExit> {\n         drop(self.stdin.take());\n         self.handle.wait()\n     }\n \n+    /// Sets a timeout, in milliseconds, for future calls to wait().\n+    ///\n+    /// The argument specified is a relative distance into the future, in\n+    /// milliseconds, after which any call to wait() will return immediately\n+    /// with a timeout error, and all future calls to wait() will not block.\n+    ///\n+    /// A value of `None` will clear any previous timeout, and a value of `Some`\n+    /// will override any previously set timeout.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(experimental)]\n+    /// use std::io::process::{Process, ProcessExit};\n+    /// use std::io::IoResult;\n+    ///\n+    /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n+    ///     let mut p = try!(Process::new(\"long-running-process\", []));\n+    ///\n+    ///     // give the process 10 seconds to finish completely\n+    ///     p.set_timeout(Some(10_000));\n+    ///     match p.wait() {\n+    ///         Ok(status) => return Ok(status),\n+    ///         Err(..) => {}\n+    ///     }\n+    ///\n+    ///     // Attempt to exit gracefully, but don't wait for it too long\n+    ///     try!(p.signal_exit());\n+    ///     p.set_timeout(Some(1_000));\n+    ///     match p.wait() {\n+    ///         Ok(status) => return Ok(status),\n+    ///         Err(..) => {}\n+    ///     }\n+    ///\n+    ///     // Well, we did our best, forcefully kill the process\n+    ///     try!(p.signal_kill());\n+    ///     p.set_timeout(None);\n+    ///     p.wait()\n+    /// }\n+    /// ```\n+    #[experimental = \"the type of the timeout is likely to change\"]\n+    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n+        self.handle.set_timeout(timeout_ms)\n+    }\n+\n     /// Simultaneously wait for the child to exit and collect all remaining\n     /// output on the stdout/stderr handles, returning a `ProcessOutput`\n     /// instance.\n     ///\n     /// The stdin handle to the child is closed before waiting.\n-    pub fn wait_with_output(&mut self) -> ProcessOutput {\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function can fail for any of the same reasons that `wait()` can\n+    /// fail.\n+    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> {\n         drop(self.stdin.take());\n         fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n@@ -404,11 +461,13 @@ impl Process {\n         let stdout = read(self.stdout.take());\n         let stderr = read(self.stderr.take());\n \n-        let status = self.wait();\n+        let status = try!(self.wait());\n \n-        ProcessOutput { status: status,\n-                        output: stdout.recv().ok().unwrap_or(Vec::new()),\n-                        error:  stderr.recv().ok().unwrap_or(Vec::new()) }\n+        Ok(ProcessOutput {\n+            status: status,\n+            output: stdout.recv().ok().unwrap_or(Vec::new()),\n+            error:  stderr.recv().ok().unwrap_or(Vec::new()),\n+        })\n     }\n }\n \n@@ -421,7 +480,8 @@ impl Drop for Process {\n         drop(self.stderr.take());\n         drop(mem::replace(&mut self.extra_io, Vec::new()));\n \n-        self.wait();\n+        self.set_timeout(None);\n+        let _ = self.wait().unwrap();\n     }\n }\n \n@@ -441,7 +501,7 @@ mod tests {\n         let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n@@ -465,7 +525,7 @@ mod tests {\n         let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        assert!(p.wait().matches_exit_status(1));\n+        assert!(p.wait().unwrap().matches_exit_status(1));\n         drop(p.wait().clone());\n     })\n \n@@ -479,7 +539,7 @@ mod tests {\n         let p = Process::configure(args);\n         assert!(p.is_ok());\n         let mut p = p.unwrap();\n-        match p.wait() {\n+        match p.wait().unwrap() {\n             process::ExitSignal(1) => {},\n             result => fail!(\"not terminated by signal 1 (instead, {})\", result),\n         }\n@@ -495,7 +555,7 @@ mod tests {\n         let mut p = p.unwrap();\n         assert!(p.stdout.is_some());\n         let ret = read_all(p.stdout.get_mut_ref() as &mut Reader);\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n         return ret;\n     }\n \n@@ -536,7 +596,7 @@ mod tests {\n         p.stdin.get_mut_ref().write(\"foobar\".as_bytes()).unwrap();\n         drop(p.stdin.take());\n         let out = read_all(p.stdout.get_mut_ref() as &mut Reader);\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n         assert_eq!(out, \"foobar\\n\".to_owned());\n     })\n \n@@ -548,7 +608,7 @@ mod tests {\n             .. ProcessConfig::new()\n         };\n         let mut p = Process::configure(args).unwrap();\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(windows)]\n@@ -572,7 +632,7 @@ mod tests {\n             .. ProcessConfig::new()\n         };\n         let mut p = Process::configure(args).unwrap();\n-        assert!(p.wait().success());\n+        assert!(p.wait().unwrap().success());\n     })\n \n     #[cfg(unix, not(target_os=\"android\"))]\n@@ -635,21 +695,21 @@ mod tests {\n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_finish_once() {\n         let mut prog = Process::new(\"false\", []).unwrap();\n-        assert!(prog.wait().matches_exit_status(1));\n+        assert!(prog.wait().unwrap().matches_exit_status(1));\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_finish_twice() {\n         let mut prog = Process::new(\"false\", []).unwrap();\n-        assert!(prog.wait().matches_exit_status(1));\n-        assert!(prog.wait().matches_exit_status(1));\n+        assert!(prog.wait().unwrap().matches_exit_status(1));\n+        assert!(prog.wait().unwrap().matches_exit_status(1));\n     })\n \n     #[cfg(not(target_os=\"android\"))]\n     iotest!(fn test_wait_with_output_once() {\n \n-        let mut prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n-        let ProcessOutput {status, output, error} = prog.wait_with_output();\n+        let prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n+        let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n         let output_str = str::from_utf8(output.as_slice()).unwrap();\n \n         assert!(status.success());\n@@ -660,30 +720,6 @@ mod tests {\n         }\n     })\n \n-    #[cfg(not(target_os=\"android\"))]\n-    iotest!(fn test_wait_with_output_twice() {\n-        let mut prog = Process::new(\"echo\", [\"hello\".to_owned()]).unwrap();\n-        let ProcessOutput {status, output, error} = prog.wait_with_output();\n-\n-        let output_str = str::from_utf8(output.as_slice()).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_owned(), \"hello\".to_owned());\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-\n-        let ProcessOutput {status, output, error} = prog.wait_with_output();\n-\n-        assert!(status.success());\n-        assert_eq!(output, Vec::new());\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-    })\n-\n     #[cfg(unix,not(target_os=\"android\"))]\n     pub fn run_pwd(dir: Option<&Path>) -> Process {\n         Process::configure(ProcessConfig {\n@@ -714,9 +750,10 @@ mod tests {\n \n     iotest!(fn test_keep_current_working_dir() {\n         use os;\n-        let mut prog = run_pwd(None);\n+        let prog = run_pwd(None);\n \n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let output = str::from_utf8(prog.wait_with_output().unwrap()\n+                                        .output.as_slice()).unwrap().to_owned();\n         let parent_dir = os::getcwd();\n         let child_dir = Path::new(output.trim());\n \n@@ -732,9 +769,10 @@ mod tests {\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n         let parent_dir = os::getcwd().dir_path();\n-        let mut prog = run_pwd(Some(&parent_dir));\n+        let prog = run_pwd(Some(&parent_dir));\n \n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let output = str::from_utf8(prog.wait_with_output().unwrap()\n+                                        .output.as_slice()).unwrap().to_owned();\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -777,8 +815,9 @@ mod tests {\n         use os;\n         if running_on_valgrind() { return; }\n \n-        let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let prog = run_env(None);\n+        let output = str::from_utf8(prog.wait_with_output().unwrap()\n+                                        .output.as_slice()).unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -791,8 +830,10 @@ mod tests {\n         use os;\n         if running_on_valgrind() { return; }\n \n-        let mut prog = run_env(None);\n-        let output = str::from_utf8(prog.wait_with_output().output.as_slice()).unwrap().to_owned();\n+        let prog = run_env(None);\n+        let output = str::from_utf8(prog.wait_with_output()\n+                                        .unwrap().output.as_slice())\n+                                   .unwrap().to_owned();\n \n         let r = os::env();\n         for &(ref k, ref v) in r.iter() {\n@@ -807,8 +848,8 @@ mod tests {\n     iotest!(fn test_add_to_env() {\n         let new_env = box [(\"RUN_TEST_NEW_ENV\".to_owned(), \"123\".to_owned())];\n \n-        let mut prog = run_env(Some(new_env));\n-        let result = prog.wait_with_output();\n+        let prog = run_env(Some(new_env));\n+        let result = prog.wait_with_output().unwrap();\n         let output = str::from_utf8_lossy(result.output.as_slice()).into_owned();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n@@ -830,26 +871,57 @@ mod tests {\n     iotest!(fn test_kill() {\n         let mut p = sleeper();\n         Process::kill(p.id(), PleaseExitSignal).unwrap();\n-        assert!(!p.wait().success());\n+        assert!(!p.wait().unwrap().success());\n     })\n \n     iotest!(fn test_exists() {\n         let mut p = sleeper();\n         assert!(Process::kill(p.id(), 0).is_ok());\n         p.signal_kill().unwrap();\n-        assert!(!p.wait().success());\n+        assert!(!p.wait().unwrap().success());\n     })\n \n     iotest!(fn test_zero() {\n         let mut p = sleeper();\n         p.signal_kill().unwrap();\n         for _ in range(0, 20) {\n             if p.signal(0).is_err() {\n-                assert!(!p.wait().success());\n+                assert!(!p.wait().unwrap().success());\n                 return\n             }\n             timer::sleep(100);\n         }\n         fail!(\"never saw the child go away\");\n     })\n+\n+    iotest!(fn wait_timeout() {\n+        let mut p = sleeper();\n+        p.set_timeout(Some(10));\n+        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+        p.signal_kill().unwrap();\n+        p.set_timeout(None);\n+        assert!(p.wait().is_ok());\n+    })\n+\n+    iotest!(fn wait_timeout2() {\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+        spawn(proc() {\n+            let mut p = sleeper();\n+            p.set_timeout(Some(10));\n+            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+            p.signal_kill().unwrap();\n+            tx.send(());\n+        });\n+        spawn(proc() {\n+            let mut p = sleeper();\n+            p.set_timeout(Some(10));\n+            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n+            p.signal_kill().unwrap();\n+            tx2.send(());\n+        });\n+        rx.recv();\n+        rx.recv();\n+    })\n }"}, {"sha": "90f97e59caadad6a4d0960d95fcc2f9d4b2355ee", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -275,7 +275,8 @@ pub trait RtioFileStream {\n pub trait RtioProcess {\n     fn id(&self) -> libc::pid_t;\n     fn kill(&mut self, signal: int) -> IoResult<()>;\n-    fn wait(&mut self) -> ProcessExit;\n+    fn wait(&mut self) -> IoResult<ProcessExit>;\n+    fn set_timeout(&mut self, timeout: Option<u64>);\n }\n \n pub trait RtioPipe {"}, {"sha": "53fe91cff3745ee9302ae20f29ada0fb0a79dab6", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -50,7 +50,7 @@ fn runtest(me: &str) {\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"foo::h\"),\n@@ -62,7 +62,7 @@ fn runtest(me: &str) {\n         args: [\"fail\".to_owned()],\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(!s.contains(\"stack backtrace\") && !s.contains(\"foo::h\"),\n@@ -74,7 +74,7 @@ fn runtest(me: &str) {\n         args: [\"double-fail\".to_owned()],\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     assert!(s.contains(\"stack backtrace\") && s.contains(\"double::h\"),\n@@ -87,7 +87,7 @@ fn runtest(me: &str) {\n         env: Some(env.as_slice()),\n         .. ProcessConfig::new()\n     }).unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     let mut i = 0;"}, {"sha": "01a71d862b4ff9396a89b363277e5947e18ad85c", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -120,7 +120,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n             () = rx1.recv() => {}\n         }\n     });\n-    match p.wait() {\n+    match p.wait().unwrap() {\n         ExitStatus(..) => fail!(\"expected a signal\"),\n         ExitSignal(..) => tx.send(()),\n     }"}, {"sha": "fc1825d22cd94f8b6f99e7fd82a2e19eab49c729", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -52,7 +52,7 @@ fn parent(flavor: ~str) {\n     let args = args.as_slice();\n     let mut p = io::Process::new(args[0].as_slice(), [\"child\".to_owned(), flavor]).unwrap();\n     p.stdin.get_mut_ref().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n-    let out = p.wait_with_output();\n+    let out = p.wait_with_output().unwrap();\n     assert!(out.status.success());\n     let s = str::from_utf8(out.output.as_slice()).unwrap();\n     assert_eq!(s, \"test1\\n\\ntest2\\n\\ntest3\\n\");"}, {"sha": "f87c22bdb57c3d0bf2089514cba17bce176d601e", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -36,7 +36,7 @@ fn main() {\n         env: Some(env.as_slice()),\n         ..ProcessConfig::new()\n     };\n-    let p = Process::configure(config).unwrap().wait_with_output();\n+    let p = Process::configure(config).unwrap().wait_with_output().unwrap();\n     assert!(p.status.success());\n     let mut lines = str::from_utf8(p.error.as_slice()).unwrap().lines();\n     assert!(lines.next().unwrap().contains(\"foo\"));"}, {"sha": "f41f2619032bc99b60c7d83aaae841b8e0bcafbd", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -54,7 +54,7 @@ fn main() {\n     // Wait for the child process to die (terminate it's stdin and the read\n     // should fail).\n     drop(p.stdin.take());\n-    match p.wait() {\n+    match p.wait().unwrap() {\n         process::ExitStatus(..) => {}\n         process::ExitSignal(..) => fail!()\n     }"}, {"sha": "45af7d5de3481e6b4be3a24b880e1bf5908a4bed", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -62,7 +62,7 @@ fn main() {\n             cwd: Some(&cwd),\n             env: Some(my_env.append_one(env).as_slice()),\n             .. ProcessConfig::new()\n-        }).unwrap().wait_with_output();\n+        }).unwrap().wait_with_output().unwrap();\n \n         // display the output\n         assert!(io::stdout().write(p.output.as_slice()).is_ok());"}, {"sha": "2b42e3ada542879fa083edf961c3e66ea55f0820", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f09592a5d154177f0c9d739c9fe60742ec4cd951/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=f09592a5d154177f0c9d739c9fe60742ec4cd951", "patch": "@@ -31,5 +31,5 @@ fn main() {\n     }\n \n     let mut p = Process::new(args[0], [\"test\".to_owned()]).unwrap();\n-    assert!(p.wait().success());\n+    assert!(p.wait().unwrap().success());\n }"}]}