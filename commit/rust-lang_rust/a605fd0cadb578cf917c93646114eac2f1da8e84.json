{"sha": "a605fd0cadb578cf917c93646114eac2f1da8e84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MDVmZDBjYWRiNTc4Y2Y5MTdjOTM2NDYxMTRlYWMyZjFkYThlODQ=", "commit": {"author": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2012-08-11T14:08:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-29T01:52:44Z"}, "message": "CamelCasify lots of std", "tree": {"sha": "b36d1ff6c5ed38c0785177e4d1f54d672146967d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b36d1ff6c5ed38c0785177e4d1f54d672146967d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a605fd0cadb578cf917c93646114eac2f1da8e84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a605fd0cadb578cf917c93646114eac2f1da8e84", "html_url": "https://github.com/rust-lang/rust/commit/a605fd0cadb578cf917c93646114eac2f1da8e84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a605fd0cadb578cf917c93646114eac2f1da8e84/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecb646477b422de89996acce0c2ba08ce082349a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecb646477b422de89996acce0c2ba08ce082349a", "html_url": "https://github.com/rust-lang/rust/commit/ecb646477b422de89996acce0c2ba08ce082349a"}], "stats": {"total": 1546, "additions": 783, "deletions": 763}, "files": [{"sha": "e2eca08374ea0c3dd587ce1158c7452f25fbb6e2", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -74,7 +74,7 @@ type options = {\n \n enum mode { system_mode, user_mode, local_mode }\n \n-fn opts() -> ~[getopts::opt] {\n+fn opts() -> ~[getopts::Opt] {\n     ~[optflag(~\"g\"), optflag(~\"G\"), optflag(~\"test\"),\n      optflag(~\"h\"), optflag(~\"help\")]\n }\n@@ -387,27 +387,27 @@ fn valid_pkg_name(s: ~str) -> bool {\n     s.all(is_valid_digit)\n }\n \n-fn parse_source(name: ~str, j: json::json) -> source {\n+fn parse_source(name: ~str, j: json::Json) -> source {\n     if !valid_pkg_name(name) {\n         fail fmt!(\"'%s' is an invalid source name\", name);\n     }\n \n     match j {\n-        json::dict(j) => {\n+        json::Dict(j) => {\n             let mut url = match j.find(~\"url\") {\n-                Some(json::string(u)) => *u,\n+                Some(json::String(u)) => *u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n             let method = match j.find(~\"method\") {\n-                Some(json::string(u)) => *u,\n+                Some(json::String(u)) => *u,\n                 _ => assume_source_method(url)\n             };\n             let key = match j.find(~\"key\") {\n-                Some(json::string(u)) => Some(*u),\n+                Some(json::String(u)) => Some(*u),\n                 _ => None\n             };\n             let keyfp = match j.find(~\"keyfp\") {\n-                Some(json::string(u)) => Some(*u),\n+                Some(json::String(u)) => Some(*u),\n                 _ => None\n             };\n             if method == ~\"file\" {\n@@ -429,7 +429,7 @@ fn try_parse_sources(filename: &Path, sources: map::hashmap<~str, source>) {\n     if !os::path_exists(filename)  { return; }\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(result::get(c)) {\n-        Ok(json::dict(j)) => {\n+        Ok(json::Dict(j)) => {\n           for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n                 debug!(\"source: %s\", k);\n@@ -440,9 +440,9 @@ fn try_parse_sources(filename: &Path, sources: map::hashmap<~str, source>) {\n     }\n }\n \n-fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n+fn load_one_source_package(src: source, p: map::hashmap<~str, json::Json>) {\n     let name = match p.find(~\"name\") {\n-        Some(json::string(n)) => {\n+        Some(json::String(n)) => {\n             if !valid_pkg_name(*n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n@@ -459,7 +459,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     let uuid = match p.find(~\"uuid\") {\n-        Some(json::string(n)) => {\n+        Some(json::String(n)) => {\n             if !is_uuid(*n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + *n + ~\"'\"+\n@@ -475,15 +475,15 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     let url = match p.find(~\"url\") {\n-        Some(json::string(n)) => *n,\n+        Some(json::String(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n     let method = match p.find(~\"method\") {\n-        Some(json::string(n)) => *n,\n+        Some(json::String(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n@@ -492,16 +492,16 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     };\n \n     let reference = match p.find(~\"ref\") {\n-        Some(json::string(n)) => Some(*n),\n+        Some(json::String(n)) => Some(*n),\n         _ => None\n     };\n \n     let mut tags = ~[];\n     match p.find(~\"tags\") {\n-        Some(json::list(js)) => {\n+        Some(json::List(js)) => {\n           for (*js).each |j| {\n                 match j {\n-                    json::string(j) => vec::grow(tags, 1u, *j),\n+                    json::String(j) => vec::grow(tags, 1u, *j),\n                     _ => ()\n                 }\n             }\n@@ -510,7 +510,7 @@ fn load_one_source_package(src: source, p: map::hashmap<~str, json::json>) {\n     }\n \n     let description = match p.find(~\"description\") {\n-        Some(json::string(n)) => *n,\n+        Some(json::String(n)) => *n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");\n@@ -548,8 +548,8 @@ fn load_source_info(c: cargo, src: source) {\n     if !os::path_exists(&srcfile) { return; }\n     let srcstr = io::read_whole_file_str(&srcfile);\n     match json::from_str(result::get(srcstr)) {\n-        Ok(json::dict(s)) => {\n-            let o = parse_source(src.name, json::dict(s));\n+        Ok(json::Dict(s)) => {\n+            let o = parse_source(src.name, json::Dict(s));\n \n             src.key = o.key;\n             src.keyfp = o.keyfp;\n@@ -570,10 +570,10 @@ fn load_source_packages(c: cargo, src: source) {\n     if !os::path_exists(&pkgfile) { return; }\n     let pkgstr = io::read_whole_file_str(&pkgfile);\n     match json::from_str(result::get(pkgstr)) {\n-        Ok(json::list(js)) => {\n+        Ok(json::List(js)) => {\n           for (*js).each |j| {\n                 match j {\n-                    json::dict(p) => {\n+                    json::Dict(p) => {\n                         load_one_source_package(src, p);\n                     }\n                     _ => {\n@@ -1551,7 +1551,7 @@ fn dump_cache(c: cargo) {\n     need_dir(&c.root);\n \n     let out = c.root.push(\"cache.json\");\n-    let _root = json::dict(map::str_hash());\n+    let _root = json::Dict(map::str_hash());\n \n     if os::path_exists(&out) {\n         copy_warn(&out, &c.root.push(\"cache.json.old\"));\n@@ -1573,24 +1573,24 @@ fn dump_sources(c: cargo) {\n     match io::buffered_file_writer(&out) {\n         result::Ok(writer) => {\n             let hash = map::str_hash();\n-            let root = json::dict(hash);\n+            let root = json::Dict(hash);\n \n           for c.sources.each |k, v| {\n                 let chash = map::str_hash();\n-                let child = json::dict(chash);\n+                let child = json::Dict(chash);\n \n-                chash.insert(~\"url\", json::string(@v.url));\n-                chash.insert(~\"method\", json::string(@v.method));\n+                chash.insert(~\"url\", json::String(@v.url));\n+                chash.insert(~\"method\", json::String(@v.method));\n \n                 match copy v.key {\n                     Some(key) => {\n-                        chash.insert(~\"key\", json::string(@key));\n+                        chash.insert(~\"key\", json::String(@key));\n                     }\n                     _ => ()\n                 }\n                 match copy v.keyfp {\n                     Some(keyfp) => {\n-                        chash.insert(~\"keyfp\", json::string(@keyfp));\n+                        chash.insert(~\"keyfp\", json::String(@keyfp));\n                     }\n                     _ => ()\n                 }"}, {"sha": "b1d4e899ced472664d89526688c55520cef68db2", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -42,7 +42,7 @@ fn parse_config(args: ~[~str]) -> config {\n           Err(f) => fail getopts::fail_str(f)\n         };\n \n-    fn opt_path(m: getopts::matches, nm: ~str) -> Path {\n+    fn opt_path(m: getopts::Matches, nm: ~str) -> Path {\n         Path(getopts::opt_str(m, nm))\n     }\n "}, {"sha": "7609fa704546de3ff272b008c9e2f3bac298b8f7", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,4 +1,5 @@\n // Dynamic arenas.\n+#[warn(non_camel_case_types)];\n \n // Arenas are used to quickly allocate objects that share a\n // lifetime. The arena uses ~[u8] vectors as a backing store to\n@@ -22,7 +23,7 @@\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n \n-export arena, arena_with_size;\n+export Arena, arena_with_size;\n \n import list;\n import list::{list, cons, nil};\n@@ -46,15 +47,15 @@ const tydesc_drop_glue_index: size_t = 3 as size_t;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-type chunk = {data: @[u8], mut fill: uint, is_pod: bool};\n+type Chunk = {data: @[u8], mut fill: uint, is_pod: bool};\n \n-struct arena {\n+struct Arena {\n     // The head is seperated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n-    priv mut head: chunk;\n-    priv mut pod_head: chunk;\n-    priv mut chunks: @list<chunk>;\n+    priv mut head: Chunk;\n+    priv mut pod_head: Chunk;\n+    priv mut chunks: @list<Chunk>;\n     drop {\n         unsafe {\n             destroy_chunk(self.head);\n@@ -65,19 +66,19 @@ struct arena {\n     }\n }\n \n-fn chunk(size: uint, is_pod: bool) -> chunk {\n+fn chunk(size: uint, is_pod: bool) -> Chunk {\n     let mut v = @[];\n     unsafe { at_vec::unsafe::reserve(v, size); }\n     { data: v, mut fill: 0u, is_pod: is_pod }\n }\n \n-fn arena_with_size(initial_size: uint) -> arena {\n-    return arena {mut head: chunk(initial_size, false),\n+fn arena_with_size(initial_size: uint) -> Arena {\n+    return Arena {mut head: chunk(initial_size, false),\n                   mut pod_head: chunk(initial_size, true),\n                   mut chunks: @nil};\n }\n \n-fn arena() -> arena {\n+fn Arena() -> Arena {\n     arena_with_size(32u)\n }\n \n@@ -88,7 +89,7 @@ fn round_up_to(base: uint, align: uint) -> uint {\n \n // Walk down a chunk, running the destructors for any objects stored\n // in it.\n-unsafe fn destroy_chunk(chunk: chunk) {\n+unsafe fn destroy_chunk(chunk: Chunk) {\n     let mut idx = 0;\n     let buf = vec::unsafe::to_ptr_slice(chunk.data);\n     let fill = chunk.fill;\n@@ -129,7 +130,7 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n }\n \n // The duplication between the POD and non-POD functions is annoying.\n-impl &arena {\n+impl &Arena {\n     // Functions for the POD part of the arena\n     fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n@@ -238,7 +239,7 @@ impl &arena {\n \n #[test]\n fn test_arena_destructors() {\n-    let arena = arena::arena();\n+    let arena = arena::Arena();\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n@@ -251,7 +252,7 @@ fn test_arena_destructors() {\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_arena_destructors_fail() {\n-    let arena = arena::arena();\n+    let arena = arena::Arena();\n     // Put some stuff in the arena.\n     for uint::range(0, 10) |i| {\n         // Arena allocate something with drop glue to make sure it"}, {"sha": "1dd8454976d1bcf1c69f686d874b1d3dba379e92", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,10 +1,11 @@\n+#[deny(non_camel_case_types)];\n import io::Reader;\n \n-trait to_base64 {\n+trait ToBase64 {\n     fn to_base64() -> ~str;\n }\n \n-impl ~[u8]: to_base64 {\n+impl ~[u8]: ToBase64 {\n     fn to_base64() -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n@@ -55,17 +56,17 @@ impl ~[u8]: to_base64 {\n     }\n }\n \n-impl ~str: to_base64 {\n+impl ~str: ToBase64 {\n     fn to_base64() -> ~str {\n         str::to_bytes(self).to_base64()\n     }\n }\n \n-trait from_base64 {\n+trait FromBase64 {\n     fn from_base64() -> ~[u8];\n }\n \n-impl ~[u8]: from_base64 {\n+impl ~[u8]: FromBase64 {\n     fn from_base64() -> ~[u8] {\n         if self.len() % 4u != 0u { fail ~\"invalid base64 length\"; }\n \n@@ -127,7 +128,7 @@ impl ~[u8]: from_base64 {\n     }\n }\n \n-impl ~str: from_base64 {\n+impl ~str: FromBase64 {\n     fn from_base64() -> ~[u8] {\n         str::to_bytes(self).from_base64()\n     }"}, {"sha": "40066a1144ccb8cd5b47aec4bc8da1e72b4a708d", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 107, "deletions": 102, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,16 +1,21 @@\n+#[deny(non_camel_case_types)];\n import vec::{to_mut, from_elem};\n \n-export bitv;\n+export Bitv;\n export union;\n+export Union;\n export intersect;\n+export Intersect;\n export assign;\n+export Assign;\n+export difference;\n+export Difference;\n export clone;\n export get;\n export equal;\n export clear;\n export set_all;\n export invert;\n-export difference;\n export set;\n export is_true;\n export is_false;\n@@ -25,7 +30,7 @@ fn small_mask(nbits: uint) -> u32 {\n     (1 << nbits) - 1\n }\n \n-struct small_bitv {\n+struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n     let mut bits: u32;\n     new(bits: u32) { self.bits = bits; }\n@@ -41,19 +46,19 @@ struct small_bitv {\n         }\n     }\n     #[inline(always)]\n-    fn union(s: &small_bitv, nbits: uint) -> bool {\n+    fn union(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n     #[inline(always)]\n-    fn intersect(s: &small_bitv, nbits: uint) -> bool {\n+    fn intersect(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n     #[inline(always)]\n-    fn become(s: &small_bitv, nbits: uint) -> bool {\n+    fn become(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n     #[inline(always)]\n-    fn difference(s: &small_bitv, nbits: uint) -> bool {\n+    fn difference(s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 ^ u2)\n     }\n     #[inline(always)]\n@@ -70,7 +75,7 @@ struct small_bitv {\n         }\n     }\n     #[inline(always)]\n-    fn equals(b: &small_bitv, nbits: uint) -> bool {\n+    fn equals(b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n@@ -106,15 +111,15 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n     }\n }\n \n-struct big_bitv {\n+struct BigBitv {\n     // only mut b/c of clone and lack of other constructor\n     let mut storage: ~[mut uint];\n     new(-storage: ~[mut uint]) {\n         self.storage <- storage;\n     }\n     priv {\n         #[inline(always)]\n-        fn process(b: &big_bitv, nbits: uint, op: fn(uint, uint) -> uint)\n+        fn process(b: &BigBitv, nbits: uint, op: fn(uint, uint) -> uint)\n                                                                      -> bool {\n             let len = b.storage.len();\n             assert (self.storage.len() == len);\n@@ -145,19 +150,19 @@ struct big_bitv {\n     #[inline(always)]\n     fn invert() { for self.each_storage() |w| { w = !w } }\n     #[inline(always)]\n-    fn union(b: &big_bitv, nbits: uint) -> bool {\n+    fn union(b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, lor)\n     }\n     #[inline(always)]\n-    fn intersect(b: &big_bitv, nbits: uint) -> bool {\n+    fn intersect(b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, land)\n     }\n     #[inline(always)]\n-    fn become(b: &big_bitv, nbits: uint) -> bool {\n+    fn become(b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, right)\n     }\n     #[inline(always)]\n-    fn difference(b: &big_bitv, nbits: uint) -> bool {\n+    fn difference(b: &BigBitv, nbits: uint) -> bool {\n         self.invert();\n         let b = self.intersect(b, nbits);\n         self.invert();\n@@ -179,7 +184,7 @@ struct big_bitv {\n                  else { self.storage[w] & !flag };\n     }\n     #[inline(always)]\n-    fn equals(b: &big_bitv, nbits: uint) -> bool {\n+    fn equals(b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -190,26 +195,26 @@ struct big_bitv {\n     }\n }\n \n-enum a_bitv { big(~big_bitv), small(~small_bitv) }\n+enum BitvVariant { Big(~BigBitv), Small(~SmallBitv) }\n \n-enum op {union, intersect, assign, difference}\n+enum Op {Union, Intersect, Assign, Difference}\n \n // The bitvector type\n-struct bitv {\n-    let rep: a_bitv;\n+struct Bitv {\n+    let rep: BitvVariant;\n     let nbits: uint;\n \n     new(nbits: uint, init: bool) {\n         self.nbits = nbits;\n         if nbits <= 32 {\n-          self.rep = small(~small_bitv(if init {!0} else {0}));\n+          self.rep = Small(~SmallBitv(if init {!0} else {0}));\n         }\n         else {\n           let nelems = nbits/uint_bits +\n                        if nbits % uint_bits == 0 {0} else {1};\n           let elem = if init {!0} else {0};\n           let s = to_mut(from_elem(nelems, elem));\n-          self.rep = big(~big_bitv(s));\n+          self.rep = Big(~BigBitv(s));\n         };\n     }\n \n@@ -219,27 +224,27 @@ struct bitv {\n                   different sizes\";\n         }\n         #[inline(always)]\n-        fn do_op(op: op, other: &bitv) -> bool {\n+        fn do_op(op: Op, other: &Bitv) -> bool {\n             if self.nbits != other.nbits {\n                 self.die();\n             }\n             match self.rep {\n-              small(s) => match other.rep {\n-                small(s1) => match op {\n-                  union      => s.union(s1,      self.nbits),\n-                  intersect  => s.intersect(s1,  self.nbits),\n-                  assign     => s.become(s1,     self.nbits),\n-                  difference => s.difference(s1, self.nbits)\n+              Small(s) => match other.rep {\n+                Small(s1) => match op {\n+                  Union      => s.union(s1,      self.nbits),\n+                  Intersect  => s.intersect(s1,  self.nbits),\n+                  Assign     => s.become(s1,     self.nbits),\n+                  Difference => s.difference(s1, self.nbits)\n                 },\n-                big(_) => self.die()\n+                Big(_) => self.die()\n               },\n-              big(s) => match other.rep {\n-                small(_) => self.die(),\n-                big(s1) => match op {\n-                  union      => s.union(s1,      self.nbits),\n-                  intersect  => s.intersect(s1,  self.nbits),\n-                  assign     => s.become(s1,     self.nbits),\n-                  difference => s.difference(s1, self.nbits)\n+              Big(s) => match other.rep {\n+                Small(_) => self.die(),\n+                Big(s1) => match op {\n+                  Union      => s.union(s1,      self.nbits),\n+                  Intersect  => s.intersect(s1,  self.nbits),\n+                  Assign     => s.become(s1,     self.nbits),\n+                  Difference => s.difference(s1, self.nbits)\n                 }\n               }\n             }\n@@ -253,7 +258,7 @@ struct bitv {\n  * the same length. Returns 'true' if `self` changed.\n */\n     #[inline(always)]\n-    fn union(v1: &bitv) -> bool { self.do_op(union, v1) }\n+    fn union(v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n /**\n  * Calculates the intersection of two bitvectors\n@@ -262,7 +267,7 @@ struct bitv {\n  * the same length. Returns 'true' if `self` changed.\n */\n     #[inline(always)]\n-    fn intersect(v1: &bitv) -> bool { self.do_op(intersect, v1) }\n+    fn intersect(v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n \n /**\n  * Assigns the value of `v1` to `self`\n@@ -271,20 +276,20 @@ struct bitv {\n  * changed\n  */\n     #[inline(always)]\n-    fn assign(v: &bitv) -> bool { self.do_op(assign, v) }\n+    fn assign(v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Makes a copy of a bitvector\n     #[inline(always)]\n-    fn clone() -> ~bitv {\n+    fn clone() -> ~Bitv {\n         ~match self.rep {\n-          small(b) => {\n-            bitv{nbits: self.nbits, rep: small(~small_bitv{bits: b.bits})}\n+          Small(b) => {\n+            Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n-          big(b) => {\n+          Big(b) => {\n             let st = to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n-            bitv{nbits: self.nbits, rep: big(~big_bitv{storage: st})}\n+            Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n           }\n         }\n     }\n@@ -294,8 +299,8 @@ struct bitv {\n     pure fn get(i: uint) -> bool {\n        assert (i < self.nbits);\n        match self.rep {\n-         big(b)   => b.get(i),\n-         small(s) => s.get(i)\n+         Big(b)   => b.get(i),\n+         Small(s) => s.get(i)\n        }\n     }\n \n@@ -308,8 +313,8 @@ struct bitv {\n     fn set(i: uint, x: bool) {\n       assert (i < self.nbits);\n       match self.rep {\n-        big(b)   => b.set(i, x),\n-        small(s) => s.set(i, x)\n+        Big(b)   => b.set(i, x),\n+        Small(s) => s.set(i, x)\n       }\n     }\n \n@@ -320,16 +325,16 @@ struct bitv {\n  * contain identical elements.\n  */\n     #[inline(always)]\n-    fn equal(v1: bitv) -> bool {\n+    fn equal(v1: Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n-        small(b) => match v1.rep {\n-          small(b1) => b.equals(b1, self.nbits),\n+        Small(b) => match v1.rep {\n+          Small(b1) => b.equals(b1, self.nbits),\n           _ => false\n         },\n-        big(s) => match v1.rep {\n-          big(s1) => s.equals(s1, self.nbits),\n-          small(_) => return false\n+        Big(s) => match v1.rep {\n+          Big(s1) => s.equals(s1, self.nbits),\n+          Small(_) => return false\n         }\n       }\n     }\n@@ -338,25 +343,25 @@ struct bitv {\n     #[inline(always)]\n     fn clear() {\n         match self.rep {\n-          small(b) => b.clear(),\n-          big(s) => for s.each_storage() |w| { w = 0u }\n+          Small(b) => b.clear(),\n+          Big(s) => for s.each_storage() |w| { w = 0u }\n         }\n     }\n \n     /// Set all bits to 1\n     #[inline(always)]\n     fn set_all() {\n       match self.rep {\n-        small(b) => b.set_all(),\n-        big(s) => for s.each_storage() |w| { w = !0u } }\n+        Small(b) => b.set_all(),\n+        Big(s) => for s.each_storage() |w| { w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n     fn invert() {\n       match self.rep {\n-        small(b) => b.invert(),\n-        big(s) => for s.each_storage() |w| { w = !w } }\n+        Small(b) => b.invert(),\n+        Big(s) => for s.each_storage() |w| { w = !w } }\n     }\n \n /**\n@@ -368,13 +373,13 @@ struct bitv {\n  * Returns `true` if `v0` was changed.\n  */\n    #[inline(always)]\n-    fn difference(v: ~bitv) -> bool { self.do_op(difference, v) }\n+    fn difference(v: ~Bitv) -> bool { self.do_op(Difference, v) }\n \n         /// Returns true if all bits are 1\n     #[inline(always)]\n     fn is_true() -> bool {\n       match self.rep {\n-        small(b) => b.is_true(self.nbits),\n+        Small(b) => b.is_true(self.nbits),\n         _ => {\n           for self.each() |i| { if !i { return false; } }\n           true\n@@ -395,8 +400,8 @@ struct bitv {\n \n     fn is_false() -> bool {\n       match self.rep {\n-        small(b) => b.is_false(self.nbits),\n-        big(_) => {\n+        Small(b) => b.is_false(self.nbits),\n+        Big(_) => {\n           for self.each() |i| { if i { return false; } }\n           true\n         }\n@@ -465,7 +470,7 @@ pure fn land(w0: uint, w1: uint) -> uint { return w0 & w1; }\n \n pure fn right(_w0: uint, w1: uint) -> uint { return w1; }\n \n-impl bitv: ops::index<uint,bool> {\n+impl Bitv: ops::index<uint,bool> {\n     pure fn index(&&i: uint) -> bool {\n         self.get(i)\n     }\n@@ -475,34 +480,34 @@ impl bitv: ops::index<uint,bool> {\n mod tests {\n     #[test]\n     fn test_to_str() {\n-        let zerolen = bitv(0u, false);\n+        let zerolen = Bitv(0u, false);\n         assert zerolen.to_str() == ~\"\";\n \n-        let eightbits = bitv(8u, false);\n+        let eightbits = Bitv(8u, false);\n         assert eightbits.to_str() == ~\"00000000\";\n     }\n \n     #[test]\n     fn test_0_elements() {\n         let mut act;\n         let mut exp;\n-        act = bitv(0u, false);\n+        act = Bitv(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n         assert act.eq_vec(exp);\n     }\n \n     #[test]\n     fn test_1_element() {\n         let mut act;\n-        act = bitv(1u, false);\n+        act = Bitv(1u, false);\n         assert act.eq_vec(~[0u]);\n-        act = bitv(1u, true);\n+        act = Bitv(1u, true);\n         assert act.eq_vec(~[1u]);\n     }\n \n     #[test]\n     fn test_2_elements() {\n-        let b = bitv::bitv(2, false);\n+        let b = bitv::Bitv(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert b.to_str() == ~\"10\";\n@@ -513,15 +518,15 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = bitv(10u, false);\n+        act = Bitv(10u, false);\n         assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = bitv(10u, true);\n+        act = Bitv(10u, true);\n         assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(10u, false);\n+        act = Bitv(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -530,7 +535,7 @@ mod tests {\n         assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(10u, false);\n+        act = Bitv(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n@@ -539,7 +544,7 @@ mod tests {\n         assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(10u, false);\n+        act = Bitv(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n@@ -552,21 +557,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = bitv(31u, false);\n+        act = Bitv(31u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = bitv(31u, true);\n+        act = Bitv(31u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(31u, false);\n+        act = Bitv(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -581,7 +586,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(31u, false);\n+        act = Bitv(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -596,7 +601,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(31u, false);\n+        act = Bitv(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -610,7 +615,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(31u, false);\n+        act = Bitv(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -625,21 +630,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = bitv(32u, false);\n+        act = Bitv(32u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = bitv(32u, true);\n+        act = Bitv(32u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(32u, false);\n+        act = Bitv(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -654,7 +659,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(32u, false);\n+        act = Bitv(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -669,7 +674,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(32u, false);\n+        act = Bitv(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -684,7 +689,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(32u, false);\n+        act = Bitv(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -700,21 +705,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = bitv(33u, false);\n+        act = Bitv(33u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = bitv(33u, true);\n+        act = Bitv(33u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = bitv(33u, false);\n+        act = Bitv(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -729,7 +734,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(33u, false);\n+        act = Bitv(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -744,7 +749,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = bitv(33u, false);\n+        act = Bitv(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -759,7 +764,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n         // mixed\n \n-        act = bitv(33u, false);\n+        act = Bitv(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -773,37 +778,37 @@ mod tests {\n \n     #[test]\n     fn test_equal_differing_sizes() {\n-        let v0 = bitv(10u, false);\n-        let v1 = bitv(11u, false);\n+        let v0 = Bitv(10u, false);\n+        let v1 = Bitv(11u, false);\n         assert !v0.equal(v1);\n     }\n \n     #[test]\n     fn test_equal_greatly_differing_sizes() {\n-        let v0 = bitv(10u, false);\n-        let v1 = bitv(110u, false);\n+        let v0 = Bitv(10u, false);\n+        let v1 = Bitv(110u, false);\n         assert !v0.equal(v1);\n     }\n \n     #[test]\n     fn test_equal_sneaky_small() {\n-        let a = bitv::bitv(1, false);\n+        let a = bitv::Bitv(1, false);\n         a.set(0, true);\n \n-        let b = bitv::bitv(1, true);\n+        let b = bitv::Bitv(1, true);\n         b.set(0, true);\n \n         assert a.equal(b);\n     }\n \n     #[test]\n     fn test_equal_sneaky_big() {\n-        let a = bitv::bitv(100, false);\n+        let a = bitv::Bitv(100, false);\n         for uint::range(0, 100) |i| {\n             a.set(i, true);\n         }\n \n-        let b = bitv::bitv(100, true);\n+        let b = bitv::Bitv(100, true);\n         for uint::range(0, 100) |i| {\n             b.set(i, true);\n         }"}, {"sha": "afbc9826134fd24366b2711c90cef7c38db53752", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,3 +1,4 @@\n+#[deny(non_camel_case_types)];\n /*!\n  * Library to interface with chunks of memory allocated in C.\n  *\n@@ -19,14 +20,14 @@\n  * obvious reason (they act on a pointer that cannot be checked inside the\n  * method), but the elimination form is somewhat more subtle in its unsafety.\n  * By using a pointer taken from a c_vec::t without keeping a reference to the\n- * c_vec::t itself around, the c_vec could be garbage collected, and the\n+ * c_vec::t itself around, the CVec could be garbage collected, and the\n  * memory within could be destroyed.  There are legitimate uses for the\n  * pointer elimination form -- for instance, to pass memory back into C -- but\n  * great care must be taken to ensure that a reference to the c_vec::t is\n  * still held if needed.\n  */\n \n-export c_vec;\n+export CVec;\n export c_vec, c_vec_with_dtor;\n export get, set;\n export len;\n@@ -38,11 +39,11 @@ export ptr;\n  * Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n  * truly opaque types, this should be revisited.\n  */\n-enum c_vec<T> {\n-    c_vec_({ base: *mut T, len: uint, rsrc: @dtor_res})\n+enum CVec<T> {\n+    CVecCtor({ base: *mut T, len: uint, rsrc: @DtorRes})\n }\n \n-struct dtor_res {\n+struct DtorRes {\n   let dtor: Option<fn@()>;\n   new(dtor: Option<fn@()>) { self.dtor = dtor; }\n   drop {\n@@ -58,23 +59,23 @@ struct dtor_res {\n  */\n \n /**\n- * Create a `c_vec` from a foreign buffer with a given length.\n+ * Create a `CVec` from a foreign buffer with a given length.\n  *\n  * # Arguments\n  *\n  * * base - A foreign pointer to a buffer\n  * * len - The number of elements in the buffer\n  */\n-unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n-    return c_vec_({\n+unsafe fn c_vec<T>(base: *mut T, len: uint) -> CVec<T> {\n+    return CVecCtor({\n         base: base,\n         len: len,\n-        rsrc: @dtor_res(option::None)\n+        rsrc: @DtorRes(option::None)\n     });\n }\n \n /**\n- * Create a `c_vec` from a foreign buffer, with a given length,\n+ * Create a `CVec` from a foreign buffer, with a given length,\n  * and a function to run upon destruction.\n  *\n  * # Arguments\n@@ -85,11 +86,11 @@ unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n  *          for freeing the buffer, etc.\n  */\n unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n-  -> c_vec<T> {\n-    return c_vec_({\n+  -> CVec<T> {\n+    return CVecCtor({\n         base: base,\n         len: len,\n-        rsrc: @dtor_res(option::Some(dtor))\n+        rsrc: @DtorRes(option::Some(dtor))\n     });\n }\n \n@@ -102,7 +103,7 @@ unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-fn get<T: copy>(t: c_vec<T>, ofs: uint) -> T {\n+fn get<T: copy>(t: CVec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n     return unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n@@ -112,7 +113,7 @@ fn get<T: copy>(t: c_vec<T>, ofs: uint) -> T {\n  *\n  * Fails if `ofs` is greater or equal to the length of the vector\n  */\n-fn set<T: copy>(t: c_vec<T>, ofs: uint, v: T) {\n+fn set<T: copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }\n@@ -122,20 +123,20 @@ fn set<T: copy>(t: c_vec<T>, ofs: uint, v: T) {\n  */\n \n /// Returns the length of the vector\n-fn len<T>(t: c_vec<T>) -> uint {\n+fn len<T>(t: CVec<T>) -> uint {\n     return (*t).len;\n }\n \n /// Returns a pointer to the first element of the vector\n-unsafe fn ptr<T>(t: c_vec<T>) -> *mut T {\n+unsafe fn ptr<T>(t: CVec<T>) -> *mut T {\n     return (*t).base;\n }\n \n #[cfg(test)]\n mod tests {\n     import libc::*;\n \n-    fn malloc(n: size_t) -> c_vec<u8> {\n+    fn malloc(n: size_t) -> CVec<u8> {\n         let mem = libc::malloc(n);\n \n         assert mem as int != 0;"}, {"sha": "fb42c690246245577126fb24648367c9d76f6964", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,24 +1,25 @@\n+#[deny(non_camel_case_types)];\n /// Additional general-purpose comparison functionality.\n \n const fuzzy_epsilon: float = 1.0e-6;\n \n-trait fuzzy_eq {\n+trait FuzzyEq {\n     pure fn fuzzy_eq(&&other: self) -> bool;\n }\n \n-impl float: fuzzy_eq {\n+impl float: FuzzyEq {\n     pure fn fuzzy_eq(&&other: float) -> bool {\n         return float::abs(self - other) < fuzzy_epsilon;\n     }\n }\n \n-impl f32: fuzzy_eq {\n+impl f32: FuzzyEq {\n     pure fn fuzzy_eq(&&other: f32) -> bool {\n         return f32::abs(self - other) < (fuzzy_epsilon as f32);\n     }\n }\n \n-impl f64: fuzzy_eq {\n+impl f64: FuzzyEq {\n     pure fn fuzzy_eq(&&other: f64) -> bool {\n         return f64::abs(self - other) < (fuzzy_epsilon as f64);\n     }"}, {"sha": "5ae16759b2fa8536642260af5cb94ab3b9c092ac", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,3 +1,4 @@\n+#[deny(non_camel_case_types)];\n //! Unsafe debugging functions for inspecting values.\n \n import unsafe::reinterpret_cast;"}, {"sha": "8a8b778d83a0eca6a82f33508a2fe191457a5856", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 53, "deletions": 51, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,9 +1,11 @@\n+#[deny(non_camel_case_types)];\n+\n //! A deque. Untested as of yet. Likely buggy\n \n import option::{Some, None};\n import dvec::DVec;\n \n-trait t<T> {\n+trait Deque<T> {\n     fn size() -> uint;\n     fn add_front(T);\n     fn add_back(T);\n@@ -16,16 +18,16 @@ trait t<T> {\n \n // FIXME (#2343) eventually, a proper datatype plus an exported impl would\n // be preferrable.\n-fn create<T: copy>() -> t<T> {\n-    type cell<T> = Option<T>;\n+fn create<T: copy>() -> Deque<T> {\n+    type Cell<T> = Option<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n      /**\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: copy>(nelts: uint, lo: uint, -elts: ~[mut cell<T>]) ->\n-       ~[mut cell<T>] {\n+    fn grow<T: copy>(nelts: uint, lo: uint, -elts: ~[mut Cell<T>]) ->\n+       ~[mut Cell<T>] {\n         assert (nelts == vec::len(elts));\n         let mut rv = ~[mut];\n \n@@ -40,16 +42,16 @@ fn create<T: copy>() -> t<T> {\n \n         return rv;\n     }\n-    fn get<T: copy>(elts: DVec<cell<T>>, i: uint) -> T {\n+    fn get<T: copy>(elts: DVec<Cell<T>>, i: uint) -> T {\n         match elts.get_elt(i) { Some(t) => t, _ => fail }\n     }\n \n-    type repr<T> = {mut nelts: uint,\n+    type Repr<T> = {mut nelts: uint,\n                     mut lo: uint,\n                     mut hi: uint,\n-                    elts: DVec<cell<T>>};\n+                    elts: DVec<Cell<T>>};\n \n-    impl <T: copy> repr<T>: t<T> {\n+    impl <T: copy> Repr<T>: Deque<T> {\n         fn size() -> uint { return self.nelts; }\n         fn add_front(t: T) {\n             let oldlo: uint = self.lo;\n@@ -102,7 +104,7 @@ fn create<T: copy>() -> t<T> {\n         }\n     }\n \n-    let repr: repr<T> = {\n+    let repr: Repr<T> = {\n         mut nelts: 0u,\n         mut lo: 0u,\n         mut hi: 0u,\n@@ -111,14 +113,14 @@ fn create<T: copy>() -> t<T> {\n                 vec::to_mut(\n                     vec::from_elem(initial_capacity, None)))\n     };\n-    repr as t::<T>\n+    repr as Deque::<T>\n }\n \n #[cfg(test)]\n mod tests {\n     #[test]\n     fn test_simple() {\n-        let d: deque::t<int> = deque::create::<int>();\n+        let d: deque::Deque<int> = deque::create::<int>();\n         assert (d.size() == 0u);\n         d.add_front(17);\n         d.add_front(42);\n@@ -162,7 +164,7 @@ mod tests {\n     }\n \n     fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n-        let deq: deque::t<@int> = deque::create::<@int>();\n+        let deq: deque::Deque<@int> = deque::create::<@int>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);\n         deq.add_front(b);\n@@ -191,12 +193,12 @@ mod tests {\n         assert (deq.get(3) == d);\n     }\n \n-    type eqfn<T> = fn@(T, T) -> bool;\n+    type EqFn<T> = fn@(T, T) -> bool;\n \n     fn test_parameterized<T: copy owned>(\n-        e: eqfn<T>, a: T, b: T, c: T, d: T) {\n+        e: EqFn<T>, a: T, b: T, c: T, d: T) {\n \n-        let deq: deque::t<T> = deque::create::<T>();\n+        let deq: deque::Deque<T> = deque::create::<T>();\n         assert (deq.size() == 0u);\n         deq.add_front(a);\n         deq.add_front(b);\n@@ -225,85 +227,85 @@ mod tests {\n         assert (e(deq.get(3), d));\n     }\n \n-    enum taggy { one(int), two(int, int), three(int, int, int), }\n+    enum Taggy { One(int), Two(int, int), Three(int, int, int), }\n \n-    enum taggypar<T> {\n-        onepar(int), twopar(int, int), threepar(int, int, int),\n+    enum Taggypar<T> {\n+        Onepar(int), Twopar(int, int), Threepar(int, int, int),\n     }\n \n-    type reccy = {x: int, y: int, t: taggy};\n+    type RecCy = {x: int, y: int, t: Taggy};\n \n     #[test]\n     fn test() {\n         fn inteq(&&a: int, &&b: int) -> bool { return a == b; }\n         fn intboxeq(&&a: @int, &&b: @int) -> bool { return a == b; }\n-        fn taggyeq(a: taggy, b: taggy) -> bool {\n+        fn taggyeq(a: Taggy, b: Taggy) -> bool {\n             match a {\n-              one(a1) => match b {\n-                one(b1) => return a1 == b1,\n+              One(a1) => match b {\n+                One(b1) => return a1 == b1,\n                 _ => return false\n               },\n-              two(a1, a2) => match b {\n-                two(b1, b2) => return a1 == b1 && a2 == b2,\n+              Two(a1, a2) => match b {\n+                Two(b1, b2) => return a1 == b1 && a2 == b2,\n                 _ => return false\n               },\n-              three(a1, a2, a3) => match b {\n-                three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n+              Three(a1, a2, a3) => match b {\n+                Three(b1, b2, b3) => return a1 == b1 && a2 == b2 && a3 == b3,\n                 _ => return false\n               }\n             }\n         }\n-        fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n+        fn taggypareq<T>(a: Taggypar<T>, b: Taggypar<T>) -> bool {\n             match a {\n-              onepar::<T>(a1) => match b {\n-                onepar::<T>(b1) => return a1 == b1,\n+              Onepar::<T>(a1) => match b {\n+                Onepar::<T>(b1) => return a1 == b1,\n                 _ => return false\n               },\n-              twopar::<T>(a1, a2) => match b {\n-                twopar::<T>(b1, b2) => return a1 == b1 && a2 == b2,\n+              Twopar::<T>(a1, a2) => match b {\n+                Twopar::<T>(b1, b2) => return a1 == b1 && a2 == b2,\n                 _ => return false\n               },\n-              threepar::<T>(a1, a2, a3) => match b {\n-                threepar::<T>(b1, b2, b3) => {\n+              Threepar::<T>(a1, a2, a3) => match b {\n+                Threepar::<T>(b1, b2, b3) => {\n                     return a1 == b1 && a2 == b2 && a3 == b3\n                 }\n                 _ => return false\n               }\n             }\n         }\n-        fn reccyeq(a: reccy, b: reccy) -> bool {\n+        fn reccyeq(a: RecCy, b: RecCy) -> bool {\n             return a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n         }\n         debug!(\"*** test boxes\");\n         test_boxes(@5, @72, @64, @175);\n         debug!(\"*** end test boxes\");\n         debug!(\"test parameterized: int\");\n-        let eq1: eqfn<int> = inteq;\n+        let eq1: EqFn<int> = inteq;\n         test_parameterized::<int>(eq1, 5, 72, 64, 175);\n         debug!(\"*** test parameterized: @int\");\n-        let eq2: eqfn<@int> = intboxeq;\n+        let eq2: EqFn<@int> = intboxeq;\n         test_parameterized::<@int>(eq2, @5, @72, @64, @175);\n         debug!(\"*** end test parameterized @int\");\n         debug!(\"test parameterized: taggy\");\n-        let eq3: eqfn<taggy> = taggyeq;\n-        test_parameterized::<taggy>(eq3, one(1), two(1, 2), three(1, 2, 3),\n-                                    two(17, 42));\n+        let eq3: EqFn<Taggy> = taggyeq;\n+        test_parameterized::<Taggy>(eq3, One(1), Two(1, 2), Three(1, 2, 3),\n+                                    Two(17, 42));\n \n         debug!(\"*** test parameterized: taggypar<int>\");\n-        let eq4: eqfn<taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n-        test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n-                                            twopar::<int>(1, 2),\n-                                            threepar::<int>(1, 2, 3),\n-                                            twopar::<int>(17, 42));\n+        let eq4: EqFn<Taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n+        test_parameterized::<Taggypar<int>>(eq4, Onepar::<int>(1),\n+                                            Twopar::<int>(1, 2),\n+                                            Threepar::<int>(1, 2, 3),\n+                                            Twopar::<int>(17, 42));\n         debug!(\"*** end test parameterized: taggypar::<int>\");\n \n         debug!(\"*** test parameterized: reccy\");\n-        let reccy1: reccy = {x: 1, y: 2, t: one(1)};\n-        let reccy2: reccy = {x: 345, y: 2, t: two(1, 2)};\n-        let reccy3: reccy = {x: 1, y: 777, t: three(1, 2, 3)};\n-        let reccy4: reccy = {x: 19, y: 252, t: two(17, 42)};\n-        let eq5: eqfn<reccy> = reccyeq;\n-        test_parameterized::<reccy>(eq5, reccy1, reccy2, reccy3, reccy4);\n+        let reccy1: RecCy = {x: 1, y: 2, t: One(1)};\n+        let reccy2: RecCy = {x: 345, y: 2, t: Two(1, 2)};\n+        let reccy3: RecCy = {x: 1, y: 777, t: Three(1, 2, 3)};\n+        let reccy4: RecCy = {x: 19, y: 252, t: Two(17, 42)};\n+        let eq5: EqFn<RecCy> = reccyeq;\n+        test_parameterized::<RecCy>(eq5, reccy1, reccy2, reccy3, reccy4);\n         debug!(\"*** end test parameterized: reccy\");\n         debug!(\"*** done\");\n     }"}, {"sha": "5b7f7553ddd93f0057c36ded6bedf738e9d13280", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 98, "deletions": 96, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,4 +1,4 @@\n-\n+#[deny(non_camel_case_types)];\n \n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n@@ -7,6 +7,7 @@ import core::Option;\n import option::{Some, None};\n \n export doc;\n+export Doc;\n export doc_at;\n export maybe_get_doc;\n export get_doc;\n@@ -22,28 +23,29 @@ export doc_as_i8;\n export doc_as_i16;\n export doc_as_i32;\n export doc_as_i64;\n-export writer;\n+export Writer;\n export serializer;\n export ebml_deserializer;\n+export EbmlDeserializer;\n export deserializer;\n export with_doc_data;\n export get_doc;\n export extensions;\n \n-type ebml_tag = {id: uint, size: uint};\n+type EbmlTag = {id: uint, size: uint};\n \n-type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n+type EbmlState = {ebml_tag: EbmlTag, tag_pos: uint, data_pos: uint};\n \n // FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n // separate modules within this file.\n \n // ebml reading\n-type doc = {data: @~[u8], start: uint, end: uint};\n+type Doc = {data: @~[u8], start: uint, end: uint};\n \n-type tagged_doc = {tag: uint, doc: doc};\n+type TaggedDoc = {tag: uint, doc: Doc};\n \n-impl doc: ops::index<uint,doc> {\n-    pure fn index(&&tag: uint) -> doc {\n+impl Doc: ops::index<uint,Doc> {\n+    pure fn index(&&tag: uint) -> Doc {\n         unchecked {\n             get_doc(self, tag)\n         }\n@@ -73,36 +75,36 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     } else { error!(\"vint too big\"); fail; }\n }\n \n-fn doc(data: @~[u8]) -> doc {\n+fn doc(data: @~[u8]) -> Doc {\n     return {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n-fn doc_at(data: @~[u8], start: uint) -> tagged_doc {\n+fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n     let elt_tag = vuint_at(*data, start);\n     let elt_size = vuint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n     return {tag: elt_tag.val,\n          doc: {data: data, start: elt_size.next, end: end}};\n }\n \n-fn maybe_get_doc(d: doc, tg: uint) -> Option<doc> {\n+fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n         let elt_size = vuint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            return Some::<doc>({\n+            return Some::<Doc>({\n                 data: d.data,\n                 start: elt_size.next,\n                 end: pos\n             });\n         }\n     }\n-    return None::<doc>;\n+    return None::<Doc>;\n }\n \n-fn get_doc(d: doc, tg: uint) -> doc {\n+fn get_doc(d: Doc, tg: uint) -> Doc {\n     match maybe_get_doc(d, tg) {\n       Some(d) => return d,\n       None => {\n@@ -112,7 +114,7 @@ fn get_doc(d: doc, tg: uint) -> doc {\n     }\n }\n \n-fn docs(d: doc, it: fn(uint, doc) -> bool) {\n+fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -124,7 +126,7 @@ fn docs(d: doc, it: fn(uint, doc) -> bool) {\n     }\n }\n \n-fn tagged_docs(d: doc, tg: uint, it: fn(doc) -> bool) {\n+fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n     let mut pos = d.start;\n     while pos < d.end {\n         let elt_tag = vuint_at(*d.data, pos);\n@@ -138,44 +140,44 @@ fn tagged_docs(d: doc, tg: uint, it: fn(doc) -> bool) {\n     }\n }\n \n-fn doc_data(d: doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n+fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n \n-fn with_doc_data<T>(d: doc, f: fn(x: &[u8]) -> T) -> T {\n+fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n     return f(vec::view(*d.data, d.start, d.end));\n }\n \n-fn doc_as_str(d: doc) -> ~str { return str::from_bytes(doc_data(d)); }\n+fn doc_as_str(d: Doc) -> ~str { return str::from_bytes(doc_data(d)); }\n \n-fn doc_as_u8(d: doc) -> u8 {\n+fn doc_as_u8(d: Doc) -> u8 {\n     assert d.end == d.start + 1u;\n     return (*d.data)[d.start];\n }\n \n-fn doc_as_u16(d: doc) -> u16 {\n+fn doc_as_u16(d: Doc) -> u16 {\n     assert d.end == d.start + 2u;\n     return io::u64_from_be_bytes(*d.data, d.start, 2u) as u16;\n }\n \n-fn doc_as_u32(d: doc) -> u32 {\n+fn doc_as_u32(d: Doc) -> u32 {\n     assert d.end == d.start + 4u;\n     return io::u64_from_be_bytes(*d.data, d.start, 4u) as u32;\n }\n \n-fn doc_as_u64(d: doc) -> u64 {\n+fn doc_as_u64(d: Doc) -> u64 {\n     assert d.end == d.start + 8u;\n     return io::u64_from_be_bytes(*d.data, d.start, 8u);\n }\n \n-fn doc_as_i8(d: doc) -> i8 { doc_as_u8(d) as i8 }\n-fn doc_as_i16(d: doc) -> i16 { doc_as_u16(d) as i16 }\n-fn doc_as_i32(d: doc) -> i32 { doc_as_u32(d) as i32 }\n-fn doc_as_i64(d: doc) -> i64 { doc_as_u64(d) as i64 }\n+fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n // ebml writing\n-type writer_ = {writer: io::Writer, mut size_positions: ~[uint]};\n+type Writer_ = {writer: io::Writer, mut size_positions: ~[uint]};\n \n-enum writer {\n-    writer_(writer_)\n+enum Writer {\n+    Writer_(Writer_)\n }\n \n fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n@@ -198,13 +200,13 @@ fn write_vuint(w: io::Writer, n: uint) {\n     fail fmt!(\"vint to write too big: %?\", n);\n }\n \n-fn writer(w: io::Writer) -> writer {\n+fn Writer(w: io::Writer) -> Writer {\n     let size_positions: ~[uint] = ~[];\n-    return writer_({writer: w, mut size_positions: size_positions});\n+    return Writer_({writer: w, mut size_positions: size_positions});\n }\n \n // FIXME (#2741): Provide a function to write the standard ebml header.\n-impl writer {\n+impl Writer {\n     fn start_tag(tag_id: uint) {\n         debug!(\"Start tag %u\", tag_id);\n \n@@ -306,26 +308,26 @@ impl writer {\n // Totally lame approach.\n const debug: bool = false;\n \n-enum ebml_serializer_tag {\n-    es_uint, es_u64, es_u32, es_u16, es_u8,\n-    es_int, es_i64, es_i32, es_i16, es_i8,\n-    es_bool,\n-    es_str,\n-    es_f64, es_f32, es_float,\n-    es_enum, es_enum_vid, es_enum_body,\n-    es_vec, es_vec_len, es_vec_elt,\n+enum EbmlSerializerTag {\n+    EsUint, EsU64, EsU32, EsU16, EsU8,\n+    EsInt, EsI64, EsI32, EsI16, EsI8,\n+    EsBool,\n+    EsStr,\n+    EsF64, EsF32, EsFloat,\n+    EsEnum, EsEnumVid, EsEnumBody,\n+    EsVec, EsVecLen, EsVecElt,\n \n-    es_label // Used only when debugging\n+    EsLabel // Used only when debugging\n }\n \n-trait serializer_priv {\n-    fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint);\n+trait SerializerPriv {\n+    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint);\n     fn _emit_label(label: &str);\n }\n \n-impl ebml::writer: serializer_priv {\n+impl ebml::Writer: SerializerPriv {\n     // used internally to emit things like the vector length and so on\n-    fn _emit_tagged_uint(t: ebml_serializer_tag, v: uint) {\n+    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n         assert v <= 0xFFFF_FFFF_u;\n         self.wr_tagged_u32(t as uint, v as u32);\n     }\n@@ -337,53 +339,53 @@ impl ebml::writer: serializer_priv {\n         // efficiency.  When debugging, though, we can emit such\n         // labels and then they will be checked by deserializer to\n         // try and check failures more quickly.\n-        if debug { self.wr_tagged_str(es_label as uint, label) }\n+        if debug { self.wr_tagged_str(EsLabel as uint, label) }\n     }\n }\n \n-impl ebml::writer: serialization::serializer {\n+impl ebml::Writer: serialization::serializer {\n     fn emit_nil() {}\n \n-    fn emit_uint(v: uint) { self.wr_tagged_u64(es_uint as uint, v as u64); }\n-    fn emit_u64(v: u64) { self.wr_tagged_u64(es_u64 as uint, v); }\n-    fn emit_u32(v: u32) { self.wr_tagged_u32(es_u32 as uint, v); }\n-    fn emit_u16(v: u16) { self.wr_tagged_u16(es_u16 as uint, v); }\n-    fn emit_u8(v: u8)   { self.wr_tagged_u8 (es_u8  as uint, v); }\n+    fn emit_uint(v: uint) { self.wr_tagged_u64(EsUint as uint, v as u64); }\n+    fn emit_u64(v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n+    fn emit_u32(v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n+    fn emit_u16(v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n+    fn emit_u8(v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n \n-    fn emit_int(v: int) { self.wr_tagged_i64(es_int as uint, v as i64); }\n-    fn emit_i64(v: i64) { self.wr_tagged_i64(es_i64 as uint, v); }\n-    fn emit_i32(v: i32) { self.wr_tagged_i32(es_i32 as uint, v); }\n-    fn emit_i16(v: i16) { self.wr_tagged_i16(es_i16 as uint, v); }\n-    fn emit_i8(v: i8)   { self.wr_tagged_i8 (es_i8  as uint, v); }\n+    fn emit_int(v: int) { self.wr_tagged_i64(EsInt as uint, v as i64); }\n+    fn emit_i64(v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n+    fn emit_i32(v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n+    fn emit_i16(v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n+    fn emit_i8(v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n \n-    fn emit_bool(v: bool) { self.wr_tagged_u8(es_bool as uint, v as u8) }\n+    fn emit_bool(v: bool) { self.wr_tagged_u8(EsBool as uint, v as u8) }\n \n     // FIXME (#2742): implement these\n     fn emit_f64(_v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n     fn emit_f32(_v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n     fn emit_float(_v: float) { fail ~\"Unimplemented: serializing a float\"; }\n \n-    fn emit_str(v: &str) { self.wr_tagged_str(es_str as uint, v) }\n+    fn emit_str(v: &str) { self.wr_tagged_str(EsStr as uint, v) }\n \n     fn emit_enum(name: &str, f: fn()) {\n         self._emit_label(name);\n-        self.wr_tag(es_enum as uint, f)\n+        self.wr_tag(EsEnum as uint, f)\n     }\n     fn emit_enum_variant(_v_name: &str, v_id: uint, _cnt: uint, f: fn()) {\n-        self._emit_tagged_uint(es_enum_vid, v_id);\n-        self.wr_tag(es_enum_body as uint, f)\n+        self._emit_tagged_uint(EsEnumVid, v_id);\n+        self.wr_tag(EsEnumBody as uint, f)\n     }\n     fn emit_enum_variant_arg(_idx: uint, f: fn()) { f() }\n \n     fn emit_vec(len: uint, f: fn()) {\n-        do self.wr_tag(es_vec as uint) {\n-            self._emit_tagged_uint(es_vec_len, len);\n+        do self.wr_tag(EsVec as uint) {\n+            self._emit_tagged_uint(EsVecLen, len);\n             f()\n         }\n     }\n \n     fn emit_vec_elt(_idx: uint, f: fn()) {\n-        self.wr_tag(es_vec_elt as uint, f)\n+        self.wr_tag(EsVecElt as uint, f)\n     }\n \n     fn emit_box(f: fn()) { f() }\n@@ -397,23 +399,23 @@ impl ebml::writer: serialization::serializer {\n     fn emit_tup_elt(_idx: uint, f: fn()) { f() }\n }\n \n-type ebml_deserializer_ = {mut parent: ebml::doc,\n+type EbmlDeserializer_ = {mut parent: ebml::Doc,\n                            mut pos: uint};\n \n-enum ebml_deserializer {\n-    ebml_deserializer_(ebml_deserializer_)\n+enum EbmlDeserializer {\n+    EbmlDeserializer_(EbmlDeserializer_)\n }\n \n-fn ebml_deserializer(d: ebml::doc) -> ebml_deserializer {\n-    ebml_deserializer_({mut parent: d, mut pos: d.start})\n+fn ebml_deserializer(d: ebml::Doc) -> EbmlDeserializer {\n+    EbmlDeserializer_({mut parent: d, mut pos: d.start})\n }\n \n-priv impl ebml_deserializer {\n+priv impl EbmlDeserializer {\n     fn _check_label(lbl: ~str) {\n         if self.pos < self.parent.end {\n             let {tag: r_tag, doc: r_doc} =\n                 ebml::doc_at(self.parent.data, self.pos);\n-            if r_tag == (es_label as uint) {\n+            if r_tag == (EsLabel as uint) {\n                 self.pos = r_doc.end;\n                 let str = ebml::doc_as_str(r_doc);\n                 if lbl != str {\n@@ -423,7 +425,7 @@ priv impl ebml_deserializer {\n         }\n     }\n \n-    fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n+    fn next_doc(exp_tag: EbmlSerializerTag) -> ebml::Doc {\n         debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n         if self.pos >= self.parent.end {\n             fail ~\"no more documents in current node!\";\n@@ -445,7 +447,7 @@ priv impl ebml_deserializer {\n         return r_doc;\n     }\n \n-    fn push_doc<T>(d: ebml::doc, f: fn() -> T) -> T{\n+    fn push_doc<T>(d: ebml::Doc, f: fn() -> T) -> T{\n         let old_parent = self.parent;\n         let old_pos = self.pos;\n         self.parent = d;\n@@ -456,60 +458,60 @@ priv impl ebml_deserializer {\n         return r;\n     }\n \n-    fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n+    fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n         let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n         debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n         return r as uint;\n     }\n }\n \n-impl ebml_deserializer: serialization::deserializer {\n+impl EbmlDeserializer: serialization::deserializer {\n     fn read_nil() -> () { () }\n \n-    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(es_u64)) }\n-    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(es_u32)) }\n-    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(es_u16)) }\n-    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(es_u8 )) }\n+    fn read_u64() -> u64 { ebml::doc_as_u64(self.next_doc(EsU64)) }\n+    fn read_u32() -> u32 { ebml::doc_as_u32(self.next_doc(EsU32)) }\n+    fn read_u16() -> u16 { ebml::doc_as_u16(self.next_doc(EsU16)) }\n+    fn read_u8 () -> u8  { ebml::doc_as_u8 (self.next_doc(EsU8 )) }\n     fn read_uint() -> uint {\n-        let v = ebml::doc_as_u64(self.next_doc(es_uint));\n+        let v = ebml::doc_as_u64(self.next_doc(EsUint));\n         if v > (core::uint::max_value as u64) {\n             fail fmt!(\"uint %? too large for this architecture\", v);\n         }\n         return v as uint;\n     }\n \n-    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(es_i64)) as i64 }\n-    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(es_i32)) as i32 }\n-    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(es_i16)) as i16 }\n-    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(es_i8 )) as i8  }\n+    fn read_i64() -> i64 { ebml::doc_as_u64(self.next_doc(EsI64)) as i64 }\n+    fn read_i32() -> i32 { ebml::doc_as_u32(self.next_doc(EsI32)) as i32 }\n+    fn read_i16() -> i16 { ebml::doc_as_u16(self.next_doc(EsI16)) as i16 }\n+    fn read_i8 () -> i8  { ebml::doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n     fn read_int() -> int {\n-        let v = ebml::doc_as_u64(self.next_doc(es_int)) as i64;\n+        let v = ebml::doc_as_u64(self.next_doc(EsInt)) as i64;\n         if v > (int::max_value as i64) || v < (int::min_value as i64) {\n             fail fmt!(\"int %? out of range for this architecture\", v);\n         }\n         return v as int;\n     }\n \n-    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(es_bool)) as bool }\n+    fn read_bool() -> bool { ebml::doc_as_u8(self.next_doc(EsBool)) as bool }\n \n     fn read_f64() -> f64 { fail ~\"read_f64()\"; }\n     fn read_f32() -> f32 { fail ~\"read_f32()\"; }\n     fn read_float() -> float { fail ~\"read_float()\"; }\n \n-    fn read_str() -> ~str { ebml::doc_as_str(self.next_doc(es_str)) }\n+    fn read_str() -> ~str { ebml::doc_as_str(self.next_doc(EsStr)) }\n \n     // Compound types:\n     fn read_enum<T>(name: ~str, f: fn() -> T) -> T {\n         debug!(\"read_enum(%s)\", name);\n         self._check_label(name);\n-        self.push_doc(self.next_doc(es_enum), f)\n+        self.push_doc(self.next_doc(EsEnum), f)\n     }\n \n     fn read_enum_variant<T>(f: fn(uint) -> T) -> T {\n         debug!(\"read_enum_variant()\");\n-        let idx = self._next_uint(es_enum_vid);\n+        let idx = self._next_uint(EsEnumVid);\n         debug!(\"  idx=%u\", idx);\n-        do self.push_doc(self.next_doc(es_enum_body)) {\n+        do self.push_doc(self.next_doc(EsEnumBody)) {\n             f(idx)\n         }\n     }\n@@ -521,16 +523,16 @@ impl ebml_deserializer: serialization::deserializer {\n \n     fn read_vec<T>(f: fn(uint) -> T) -> T {\n         debug!(\"read_vec()\");\n-        do self.push_doc(self.next_doc(es_vec)) {\n-            let len = self._next_uint(es_vec_len);\n+        do self.push_doc(self.next_doc(EsVec)) {\n+            let len = self._next_uint(EsVecLen);\n             debug!(\"  len=%u\", len);\n             f(len)\n         }\n     }\n \n     fn read_vec_elt<T>(idx: uint, f: fn() -> T) -> T {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n-        self.push_doc(self.next_doc(es_vec_elt), f)\n+        self.push_doc(self.next_doc(EsVecElt), f)\n     }\n \n     fn read_box<T>(f: fn() -> T) -> T {\n@@ -615,7 +617,7 @@ fn test_option_int() {\n     fn test_v(v: Option<int>) {\n         debug!(\"v == %?\", v);\n         let mbuf = io::mem_buffer();\n-        let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n+        let ebml_w = ebml::Writer(io::mem_buffer_writer(mbuf));\n         serialize_0(ebml_w, v);\n         let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n         let deser = ebml_deserializer(ebml_doc);"}, {"sha": "59131eea566a6065d486f824f094fc1ca4990e81", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,3 +1,5 @@\n+#[deny(non_camel_case_types)];\n+\n /*!\n  * A functional key,value store that works on anything.\n  *\n@@ -12,41 +14,41 @@\n import option::{Some, None};\n import option = option;\n \n-export treemap;\n+export Treemap;\n export init;\n export insert;\n export find;\n export traverse;\n \n-type treemap<K, V> = @tree_node<K, V>;\n+type Treemap<K, V> = @TreeNode<K, V>;\n \n-enum tree_node<K, V> {\n-    empty,\n-    node(@K, @V, @tree_node<K, V>, @tree_node<K, V>)\n+enum TreeNode<K, V> {\n+    Empty,\n+    Node(@K, @V, @TreeNode<K, V>, @TreeNode<K, V>)\n }\n \n /// Create a treemap\n-fn init<K, V>() -> treemap<K, V> { @empty }\n+fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n+fn insert<K: copy, V: copy>(m: Treemap<K, V>, k: K, v: V) -> Treemap<K, V> {\n     @match m {\n-       @empty => node(@k, @v, @empty, @empty),\n-       @node(@kk, vv, left, right) => {\n+       @Empty => Node(@k, @v, @Empty, @Empty),\n+       @Node(@kk, vv, left, right) => {\n          if k < kk {\n-             node(@kk, vv, insert(left, k, v), right)\n+             Node(@kk, vv, insert(left, k, v), right)\n          } else if k == kk {\n-             node(@kk, @v, left, right)\n-         } else { node(@kk, vv, left, insert(right, k, v)) }\n+             Node(@kk, @v, left, right)\n+         } else { Node(@kk, vv, left, insert(right, k, v)) }\n        }\n      }\n }\n \n /// Find a value based on the key\n-fn find<K, V: copy>(m: treemap<K, V>, k: K) -> Option<V> {\n+fn find<K, V: copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n     match *m {\n-      empty => None,\n-      node(@kk, @v, left, right) => {\n+      Empty => None,\n+      Node(@kk, @v, left, right) => {\n         if k == kk {\n             Some(v)\n         } else if k < kk { find(left, k) } else { find(right, k) }\n@@ -55,15 +57,15 @@ fn find<K, V: copy>(m: treemap<K, V>, k: K) -> Option<V> {\n }\n \n /// Visit all pairs in the map in order.\n-fn traverse<K, V: copy>(m: treemap<K, V>, f: fn(K, V)) {\n+fn traverse<K, V: copy>(m: Treemap<K, V>, f: fn(K, V)) {\n     match *m {\n-      empty => (),\n+      Empty => (),\n       /*\n         Previously, this had what looked like redundant\n         matches to me, so I changed it. but that may be a\n         de-optimization -- tjc\n        */\n-      node(@k, @v, left, right) => {\n+      Node(@k, @v, left, right) => {\n         // copy v to make aliases work out\n         let v1 = v;\n         traverse(left, f);"}, {"sha": "f85687f1d8c1398fb12c8fbcc9094850d42cc454", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 117, "deletions": 115, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,3 +1,5 @@\n+#[deny(non_camel_case_types)];\n+\n /*!\n  * Simple getopt alternative.\n  *\n@@ -68,15 +70,15 @@\n import core::result::{Err, Ok};\n import core::option;\n import core::option::{Some, None};\n-export opt;\n+export Opt;\n export reqopt;\n export optopt;\n export optflag;\n export optflagopt;\n export optmulti;\n export getopts;\n-export matches;\n-export fail_;\n+export Matches;\n+export Fail_;\n export fail_str;\n export opt_present;\n export opts_present;\n@@ -85,116 +87,116 @@ export opts_str;\n export opt_strs;\n export opt_maybe_str;\n export opt_default;\n-export result; //NDM\n+export Result; //NDM\n \n-enum name { long(~str), short(char), }\n+enum Name { Long(~str), Short(char), }\n \n-enum hasarg { yes, no, maybe, }\n+enum HasArg { Yes, No, Maybe, }\n \n-enum occur { req, optional, multi, }\n+enum Occur { Req, Optional, Multi, }\n \n /// A description of a possible option\n-type opt = {name: name, hasarg: hasarg, occur: occur};\n+type Opt = {name: Name, hasarg: HasArg, occur: Occur};\n \n-fn mkname(nm: &str) -> name {\n+fn mkname(nm: &str) -> Name {\n     let unm = str::from_slice(nm);\n     return if str::len(nm) == 1u {\n-            short(str::char_at(unm, 0u))\n-        } else { long(unm) };\n+            Short(str::char_at(unm, 0u))\n+        } else { Long(unm) };\n }\n \n /// Create an option that is required and takes an argument\n-fn reqopt(name: &str) -> opt {\n-    return {name: mkname(name), hasarg: yes, occur: req};\n+fn reqopt(name: &str) -> Opt {\n+    return {name: mkname(name), hasarg: Yes, occur: Req};\n }\n \n /// Create an option that is optional and takes an argument\n-fn optopt(name: &str) -> opt {\n-    return {name: mkname(name), hasarg: yes, occur: optional};\n+fn optopt(name: &str) -> Opt {\n+    return {name: mkname(name), hasarg: Yes, occur: Optional};\n }\n \n /// Create an option that is optional and does not take an argument\n-fn optflag(name: &str) -> opt {\n-    return {name: mkname(name), hasarg: no, occur: optional};\n+fn optflag(name: &str) -> Opt {\n+    return {name: mkname(name), hasarg: No, occur: Optional};\n }\n \n /// Create an option that is optional and takes an optional argument\n-fn optflagopt(name: &str) -> opt {\n-    return {name: mkname(name), hasarg: maybe, occur: optional};\n+fn optflagopt(name: &str) -> Opt {\n+    return {name: mkname(name), hasarg: Maybe, occur: Optional};\n }\n \n /**\n  * Create an option that is optional, takes an argument, and may occur\n  * multiple times\n  */\n-fn optmulti(name: &str) -> opt {\n-    return {name: mkname(name), hasarg: yes, occur: multi};\n+fn optmulti(name: &str) -> Opt {\n+    return {name: mkname(name), hasarg: Yes, occur: Multi};\n }\n \n-enum optval { val(~str), given, }\n+enum Optval { Val(~str), Given, }\n \n /**\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n-type matches = {opts: ~[opt], vals: ~[~[optval]], free: ~[~str]};\n+type Matches = {opts: ~[Opt], vals: ~[~[Optval]], free: ~[~str]};\n \n fn is_arg(arg: &str) -> bool {\n     return str::len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: &name) -> ~str {\n+fn name_str(nm: &Name) -> ~str {\n     return match *nm {\n-      short(ch) => str::from_char(ch),\n-      long(s) => s\n+      Short(ch) => str::from_char(ch),\n+      Long(s) => s\n     };\n }\n \n-fn find_opt(opts: &[opt], +nm: name) -> Option<uint> {\n+fn find_opt(opts: &[Opt], +nm: Name) -> Option<uint> {\n     vec::position(opts, |opt| opt.name == nm)\n }\n \n /**\n  * The type returned when the command line does not conform to the\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n-enum fail_ {\n-    argument_missing(~str),\n-    unrecognized_option(~str),\n-    option_missing(~str),\n-    option_duplicated(~str),\n-    unexpected_argument(~str),\n+enum Fail_ {\n+    ArgumentMissing(~str),\n+    UnrecognizedOption(~str),\n+    OptionMissing(~str),\n+    OptionDuplicated(~str),\n+    UnexpectedArgument(~str),\n }\n \n /// Convert a `fail_` enum into an error string\n-fn fail_str(+f: fail_) -> ~str {\n+fn fail_str(+f: Fail_) -> ~str {\n     return match f {\n-      argument_missing(nm) => ~\"Argument to option '\" + nm + ~\"' missing.\",\n-      unrecognized_option(nm) => ~\"Unrecognized option: '\" + nm + ~\"'.\",\n-      option_missing(nm) => ~\"Required option '\" + nm + ~\"' missing.\",\n-      option_duplicated(nm) => ~\"Option '\" + nm + ~\"' given more than once.\",\n-      unexpected_argument(nm) => {\n+      ArgumentMissing(nm) => ~\"Argument to option '\" + nm + ~\"' missing.\",\n+      UnrecognizedOption(nm) => ~\"Unrecognized option: '\" + nm + ~\"'.\",\n+      OptionMissing(nm) => ~\"Required option '\" + nm + ~\"' missing.\",\n+      OptionDuplicated(nm) => ~\"Option '\" + nm + ~\"' given more than once.\",\n+      UnexpectedArgument(nm) => {\n         ~\"Option \" + nm + ~\" does not take an argument.\"\n       }\n     };\n }\n \n /**\n  * The result of parsing a command line with a set of options\n- * (result::t<matches, fail_>)\n+ * (result::t<Matches, Fail_>)\n  */\n-type result = result::Result<matches, fail_>;\n+type Result = result::Result<Matches, Fail_>;\n \n /**\n  * Parse command line arguments according to the provided options\n  *\n- * On success returns `ok(opt)`. Use functions such as `opt_present`\n- * `opt_str`, etc. to interrogate results.  Returns `err(fail_)` on failure.\n+ * On success returns `ok(Opt)`. Use functions such as `opt_present`\n+ * `opt_str`, etc. to interrogate results.  Returns `err(Fail_)` on failure.\n  * Use <fail_str> to get an error message.\n  */\n-fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n-    let n_opts = vec::len::<opt>(opts);\n-    fn f(_x: uint) -> ~[optval] { return ~[]; }\n+fn getopts(args: &[~str], opts: &[Opt]) -> Result unsafe {\n+    let n_opts = vec::len::<Opt>(opts);\n+    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n     let vals = vec::to_mut(vec::from_fn(n_opts, f));\n     let mut free: ~[~str] = ~[];\n     let l = vec::len(args);\n@@ -215,10 +217,10 @@ fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let tail_eq = str::splitn_char(tail, '=', 1u);\n                 if vec::len(tail_eq) <= 1u {\n-                    names = ~[long(tail)];\n+                    names = ~[Long(tail)];\n                 } else {\n                     names =\n-                        ~[long(tail_eq[0])];\n+                        ~[Long(tail_eq[0])];\n                     i_arg =\n                         option::Some::<~str>(tail_eq[1]);\n                 }\n@@ -228,7 +230,7 @@ fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n                 names = ~[];\n                 while j < curlen {\n                     let range = str::char_range_at(cur, j);\n-                    let opt = short(range.ch);\n+                    let opt = Short(range.ch);\n \n                     /* In a series of potential options (eg. -aheJ), if we see\n                        one which takes an argument, we assume all subsequent\n@@ -245,8 +247,8 @@ fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n                             match opts[option::get(last_valid_opt_id)]\n                               .hasarg {\n \n-                              yes | maybe => true,\n-                              no => false\n+                              Yes | Maybe => true,\n+                              No => false\n                             };\n                         if arg_follows && j + 1 < curlen {\n                             i_arg = option::Some(str::slice(cur, j, curlen));\n@@ -265,30 +267,30 @@ fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n                 name_pos += 1u;\n                 let optid = match find_opt(opts, nm) {\n                   Some(id) => id,\n-                  None => return Err(unrecognized_option(name_str(&nm)))\n+                  None => return Err(UnrecognizedOption(name_str(&nm)))\n                 };\n                 match opts[optid].hasarg {\n-                  no => {\n+                  No => {\n                     if !option::is_none::<~str>(i_arg) {\n-                        return Err(unexpected_argument(name_str(&nm)));\n+                        return Err(UnexpectedArgument(name_str(&nm)));\n                     }\n-                    vec::push(vals[optid], given);\n+                    vec::push(vals[optid], Given);\n                   }\n-                  maybe => {\n+                  Maybe => {\n                     if !option::is_none::<~str>(i_arg) {\n-                        vec::push(vals[optid], val(option::get(i_arg)));\n-                    } else if name_pos < vec::len::<name>(names) ||\n+                        vec::push(vals[optid], Val(option::get(i_arg)));\n+                    } else if name_pos < vec::len::<Name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n-                        vec::push(vals[optid], given);\n-                    } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n+                        vec::push(vals[optid], Given);\n+                    } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n                   }\n-                  yes => {\n+                  Yes => {\n                     if !option::is_none::<~str>(i_arg) {\n                         vec::push(vals[optid],\n-                                  val(option::get::<~str>(i_arg)));\n+                                  Val(option::get::<~str>(i_arg)));\n                     } else if i + 1u == l {\n-                        return Err(argument_missing(name_str(&nm)));\n-                    } else { i += 1u; vec::push(vals[optid], val(args[i])); }\n+                        return Err(ArgumentMissing(name_str(&nm)));\n+                    } else { i += 1u; vec::push(vals[optid], Val(args[i])); }\n                   }\n                 }\n             }\n@@ -297,16 +299,16 @@ fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = vec::len::<optval>(vals[i]);\n+        let n = vec::len::<Optval>(vals[i]);\n         let occ = opts[i].occur;\n-        if occ == req {\n+        if occ == Req {\n             if n == 0u {\n-                return Err(option_missing(name_str(&(opts[i].name))));\n+                return Err(OptionMissing(name_str(&(opts[i].name))));\n             }\n         }\n-        if occ != multi {\n+        if occ != Multi {\n             if n > 1u {\n-                return Err(option_duplicated(name_str(&(opts[i].name))));\n+                return Err(OptionDuplicated(name_str(&(opts[i].name))));\n             }\n         }\n         i += 1u;\n@@ -316,7 +318,7 @@ fn getopts(args: &[~str], opts: &[opt]) -> result unsafe {\n                free: free});\n }\n \n-fn opt_vals(+mm: matches, nm: &str) -> ~[optval] {\n+fn opt_vals(+mm: Matches, nm: &str) -> ~[Optval] {\n     return match find_opt(mm.opts, mkname(nm)) {\n       Some(id) => mm.vals[id],\n       None => {\n@@ -326,15 +328,15 @@ fn opt_vals(+mm: matches, nm: &str) -> ~[optval] {\n     };\n }\n \n-fn opt_val(+mm: matches, nm: &str) -> optval { return opt_vals(mm, nm)[0]; }\n+fn opt_val(+mm: Matches, nm: &str) -> Optval { return opt_vals(mm, nm)[0]; }\n \n /// Returns true if an option was matched\n-fn opt_present(+mm: matches, nm: &str) -> bool {\n-    return vec::len::<optval>(opt_vals(mm, nm)) > 0u;\n+fn opt_present(+mm: Matches, nm: &str) -> bool {\n+    return vec::len::<Optval>(opt_vals(mm, nm)) > 0u;\n }\n \n /// Returns true if any of several options were matched\n-fn opts_present(+mm: matches, names: &[~str]) -> bool {\n+fn opts_present(+mm: Matches, names: &[~str]) -> bool {\n     for vec::each(names) |nm| {\n         match find_opt(mm.opts, mkname(nm)) {\n           Some(_) => return true,\n@@ -351,8 +353,8 @@ fn opts_present(+mm: matches, names: &[~str]) -> bool {\n  * Fails if the option was not matched or if the match did not take an\n  * argument\n  */\n-fn opt_str(+mm: matches, nm: &str) -> ~str {\n-    return match opt_val(mm, nm) { val(s) => s, _ => fail };\n+fn opt_str(+mm: Matches, nm: &str) -> ~str {\n+    return match opt_val(mm, nm) { Val(s) => s, _ => fail };\n }\n \n /**\n@@ -361,10 +363,10 @@ fn opt_str(+mm: matches, nm: &str) -> ~str {\n  * Fails if the no option was provided from the given list, or if the no such\n  * option took an argument\n  */\n-fn opts_str(+mm: matches, names: &[~str]) -> ~str {\n+fn opts_str(+mm: Matches, names: &[~str]) -> ~str {\n     for vec::each(names) |nm| {\n         match opt_val(mm, nm) {\n-          val(s) => return s,\n+          Val(s) => return s,\n           _ => ()\n         }\n     }\n@@ -378,19 +380,19 @@ fn opts_str(+mm: matches, names: &[~str]) -> ~str {\n  *\n  * Used when an option accepts multiple values.\n  */\n-fn opt_strs(+mm: matches, nm: &str) -> ~[~str] {\n+fn opt_strs(+mm: Matches, nm: &str) -> ~[~str] {\n     let mut acc: ~[~str] = ~[];\n     for vec::each(opt_vals(mm, nm)) |v| {\n-        match v { val(s) => vec::push(acc, s), _ => () }\n+        match v { Val(s) => vec::push(acc, s), _ => () }\n     }\n     return acc;\n }\n \n /// Returns the string argument supplied to a matching option or none\n-fn opt_maybe_str(+mm: matches, nm: &str) -> Option<~str> {\n+fn opt_maybe_str(+mm: Matches, nm: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n-    if vec::len::<optval>(vals) == 0u { return None::<~str>; }\n-    return match vals[0] { val(s) => Some::<~str>(s), _ => None::<~str> };\n+    if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n+    return match vals[0] { Val(s) => Some::<~str>(s), _ => None::<~str> };\n }\n \n \n@@ -401,10 +403,10 @@ fn opt_maybe_str(+mm: matches, nm: &str) -> Option<~str> {\n  * present but no argument was provided, and the argument if the option was\n  * present and an argument was provided.\n  */\n-fn opt_default(+mm: matches, nm: &str, def: &str) -> Option<~str> {\n+fn opt_default(+mm: Matches, nm: &str, def: &str) -> Option<~str> {\n     let vals = opt_vals(mm, nm);\n-    if vec::len::<optval>(vals) == 0u { return None::<~str>; }\n-    return match vals[0] { val(s) => Some::<~str>(s),\n+    if vec::len::<Optval>(vals) == 0u { return None::<~str>; }\n+    return match vals[0] { Val(s) => Some::<~str>(s),\n                            _      => Some::<~str>(str::from_slice(def)) }\n }\n \n@@ -413,21 +415,21 @@ mod tests {\n     import opt = getopts;\n     import result::{Err, Ok};\n \n-    enum fail_type {\n-        argument_missing_,\n-        unrecognized_option_,\n-        option_missing_,\n-        option_duplicated_,\n-        unexpected_argument_,\n+    enum FailType {\n+        ArgumentMissing_,\n+        UnrecognizedOption_,\n+        OptionMissing_,\n+        OptionDuplicated_,\n+        UnexpectedArgument_,\n     }\n \n-    fn check_fail_type(+f: fail_, ft: fail_type) {\n+    fn check_fail_type(+f: Fail_, ft: FailType) {\n         match f {\n-          argument_missing(_) => assert ft == argument_missing_,\n-          unrecognized_option(_) => assert ft == unrecognized_option_,\n-          option_missing(_) => assert ft == option_missing_,\n-          option_duplicated(_) => assert ft == option_duplicated_,\n-          unexpected_argument(_) => assert ft == unexpected_argument_\n+          ArgumentMissing(_) => assert ft == ArgumentMissing_,\n+          UnrecognizedOption(_) => assert ft == UnrecognizedOption_,\n+          OptionMissing(_) => assert ft == OptionMissing_,\n+          OptionDuplicated(_) => assert ft == OptionDuplicated_,\n+          UnexpectedArgument(_) => assert ft == UnexpectedArgument_\n         }\n     }\n \n@@ -453,7 +455,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_missing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail\n         }\n     }\n@@ -464,7 +466,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail\n         }\n     }\n@@ -475,7 +477,7 @@ mod tests {\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail\n         }\n     }\n@@ -500,7 +502,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_missing_),\n+          Err(f) => check_fail_type(f, OptionMissing_),\n           _ => fail\n         }\n     }\n@@ -511,7 +513,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail\n         }\n     }\n@@ -522,7 +524,7 @@ mod tests {\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail\n         }\n     }\n@@ -560,7 +562,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail\n         }\n     }\n@@ -571,7 +573,7 @@ mod tests {\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail\n         }\n     }\n@@ -607,7 +609,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail\n         }\n     }\n@@ -618,7 +620,7 @@ mod tests {\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail\n         }\n     }\n@@ -655,7 +657,7 @@ mod tests {\n         match rs {\n           Err(f) => {\n             log(error, fail_str(f));\n-            check_fail_type(f, unexpected_argument_);\n+            check_fail_type(f, UnexpectedArgument_);\n           }\n           _ => fail\n         }\n@@ -667,7 +669,7 @@ mod tests {\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail\n         }\n     }\n@@ -715,7 +717,7 @@ mod tests {\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, option_duplicated_),\n+          Err(f) => check_fail_type(f, OptionDuplicated_),\n           _ => fail\n         }\n     }\n@@ -753,7 +755,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail\n         }\n     }\n@@ -805,7 +807,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, argument_missing_),\n+          Err(f) => check_fail_type(f, ArgumentMissing_),\n           _ => fail\n         }\n     }\n@@ -832,7 +834,7 @@ mod tests {\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, unrecognized_option_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail\n         }\n     }\n@@ -843,7 +845,7 @@ mod tests {\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Err(f) => check_fail_type(f, unrecognized_option_),\n+          Err(f) => check_fail_type(f, UnrecognizedOption_),\n           _ => fail\n         }\n     }"}, {"sha": "b8fe2ec267aa05fb6c9059982e051e76278f86f3", "filename": "src/libstd/json.rs", "status": "modified", "additions": 180, "deletions": 178, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,3 +1,5 @@\n+#[deny(non_camel_case_types)];\n+\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n \n@@ -10,45 +12,45 @@ import map;\n import map::hashmap;\n import map::map;\n \n-export json;\n-export error;\n+export Json;\n+export Error;\n export to_writer;\n export to_str;\n export from_reader;\n export from_str;\n export eq;\n-export to_json;\n+export ToJson;\n \n-export num;\n-export string;\n-export boolean;\n-export list;\n-export dict;\n-export null;\n+export Num;\n+export String;\n+export Boolean;\n+export List;\n+export Dict;\n+export Null;\n \n /// Represents a json value\n-enum json {\n-    num(float),\n-    string(@~str),\n-    boolean(bool),\n-    list(@~[json]),\n-    dict(map::hashmap<~str, json>),\n-    null,\n+enum Json {\n+    Num(float),\n+    String(@~str),\n+    Boolean(bool),\n+    List(@~[Json]),\n+    Dict(map::hashmap<~str, Json>),\n+    Null,\n }\n \n-type error = {\n+type Error = {\n     line: uint,\n     col: uint,\n     msg: @~str,\n };\n \n /// Serializes a json value into a io::writer\n-fn to_writer(wr: io::Writer, j: json) {\n+fn to_writer(wr: io::Writer, j: Json) {\n     match j {\n-      num(n) => wr.write_str(float::to_str(n, 6u)),\n-      string(s) => wr.write_str(escape_str(*s)),\n-      boolean(b) => wr.write_str(if b { ~\"true\" } else { ~\"false\" }),\n-      list(v) => {\n+      Num(n) => wr.write_str(float::to_str(n, 6u)),\n+      String(s) => wr.write_str(escape_str(*s)),\n+      Boolean(b) => wr.write_str(if b { ~\"true\" } else { ~\"false\" }),\n+      List(v) => {\n         wr.write_char('[');\n         let mut first = true;\n         for (*v).each |item| {\n@@ -60,7 +62,7 @@ fn to_writer(wr: io::Writer, j: json) {\n         };\n         wr.write_char(']');\n       }\n-      dict(d) => {\n+      Dict(d) => {\n         if d.size() == 0u {\n             wr.write_str(~\"{}\");\n             return;\n@@ -79,7 +81,7 @@ fn to_writer(wr: io::Writer, j: json) {\n         };\n         wr.write_str(~\" }\");\n       }\n-      null => wr.write_str(~\"null\")\n+      Null => wr.write_str(~\"null\")\n     }\n }\n \n@@ -104,22 +106,22 @@ fn escape_str(s: ~str) -> ~str {\n }\n \n /// Serializes a json value into a string\n-fn to_str(j: json) -> ~str {\n+fn to_str(j: Json) -> ~str {\n     io::with_str_writer(|wr| to_writer(wr, j))\n }\n \n-type parser_ = {\n+type Parser_ = {\n     rdr: io::Reader,\n     mut ch: char,\n     mut line: uint,\n     mut col: uint,\n };\n \n-enum parser {\n-    parser_(parser_)\n+enum Parser {\n+    Parser_(Parser_)\n }\n \n-impl parser {\n+impl Parser {\n     fn eof() -> bool { self.ch == -1 as char }\n \n     fn bump() {\n@@ -138,11 +140,11 @@ impl parser {\n         self.ch\n     }\n \n-    fn error<T>(+msg: ~str) -> Result<T, error> {\n+    fn error<T>(+msg: ~str) -> Result<T, Error> {\n         Err({ line: self.line, col: self.col, msg: @msg })\n     }\n \n-    fn parse() -> Result<json, error> {\n+    fn parse() -> Result<Json, Error> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -158,18 +160,18 @@ impl parser {\n         }\n     }\n \n-    fn parse_value() -> Result<json, error> {\n+    fn parse_value() -> Result<Json, Error> {\n         self.parse_whitespace();\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n         match self.ch {\n-          'n' => self.parse_ident(~\"ull\", null),\n-          't' => self.parse_ident(~\"rue\", boolean(true)),\n-          'f' => self.parse_ident(~\"alse\", boolean(false)),\n+          'n' => self.parse_ident(~\"ull\", Null),\n+          't' => self.parse_ident(~\"rue\", Boolean(true)),\n+          'f' => self.parse_ident(~\"alse\", Boolean(false)),\n           '0' to '9' | '-' => self.parse_number(),\n           '\"' => match self.parse_str() {\n-            Ok(s) => Ok(string(s)),\n+            Ok(s) => Ok(String(s)),\n             Err(e) => Err(e)\n           },\n           '[' => self.parse_list(),\n@@ -182,7 +184,7 @@ impl parser {\n         while char::is_whitespace(self.ch) { self.bump(); }\n     }\n \n-    fn parse_ident(ident: ~str, value: json) -> Result<json, error> {\n+    fn parse_ident(ident: ~str, value: Json) -> Result<Json, Error> {\n         if str::all(ident, |c| c == self.next_char()) {\n             self.bump();\n             Ok(value)\n@@ -191,7 +193,7 @@ impl parser {\n         }\n     }\n \n-    fn parse_number() -> Result<json, error> {\n+    fn parse_number() -> Result<Json, Error> {\n         let mut neg = 1f;\n \n         if self.ch == '-' {\n@@ -218,10 +220,10 @@ impl parser {\n             }\n         }\n \n-        Ok(num(neg * res))\n+        Ok(Num(neg * res))\n     }\n \n-    fn parse_integer() -> Result<float, error> {\n+    fn parse_integer() -> Result<float, Error> {\n         let mut res = 0f;\n \n         match self.ch {\n@@ -253,7 +255,7 @@ impl parser {\n         Ok(res)\n     }\n \n-    fn parse_decimal(res: float) -> Result<float, error> {\n+    fn parse_decimal(res: float) -> Result<float, Error> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -279,7 +281,7 @@ impl parser {\n         Ok(res)\n     }\n \n-    fn parse_exponent(res: float) -> Result<float, error> {\n+    fn parse_exponent(res: float) -> Result<float, Error> {\n         self.bump();\n \n         let mut res = res;\n@@ -320,7 +322,7 @@ impl parser {\n         Ok(res)\n     }\n \n-    fn parse_str() -> Result<@~str, error> {\n+    fn parse_str() -> Result<@~str, Error> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -376,15 +378,15 @@ impl parser {\n         self.error(~\"EOF while parsing string\")\n     }\n \n-    fn parse_list() -> Result<json, error> {\n+    fn parse_list() -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n         let mut values = ~[];\n \n         if self.ch == ']' {\n             self.bump();\n-            return Ok(list(@values));\n+            return Ok(List(@values));\n         }\n \n         loop {\n@@ -400,21 +402,21 @@ impl parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              ']' => { self.bump(); return Ok(list(@values)); }\n+              ']' => { self.bump(); return Ok(List(@values)); }\n               _ => return self.error(~\"expected `,` or `]`\")\n             }\n         };\n     }\n \n-    fn parse_object() -> Result<json, error> {\n+    fn parse_object() -> Result<Json, Error> {\n         self.bump();\n         self.parse_whitespace();\n \n         let values = map::str_hash();\n \n         if self.ch == '}' {\n           self.bump();\n-          return Ok(dict(values));\n+          return Ok(Dict(values));\n         }\n \n         while !self.eof() {\n@@ -445,7 +447,7 @@ impl parser {\n \n             match self.ch {\n               ',' => self.bump(),\n-              '}' => { self.bump(); return Ok(dict(values)); }\n+              '}' => { self.bump(); return Ok(Dict(values)); }\n               _ => {\n                   if self.eof() { break; }\n                   return self.error(~\"expected `,` or `}`\");\n@@ -458,8 +460,8 @@ impl parser {\n }\n \n /// Deserializes a json value from an io::reader\n-fn from_reader(rdr: io::Reader) -> Result<json, error> {\n-    let parser = parser_({\n+fn from_reader(rdr: io::Reader) -> Result<Json, Error> {\n+    let parser = Parser_({\n         rdr: rdr,\n         mut ch: rdr.read_char(),\n         mut line: 1u,\n@@ -470,18 +472,18 @@ fn from_reader(rdr: io::Reader) -> Result<json, error> {\n }\n \n /// Deserializes a json value from a string\n-fn from_str(s: ~str) -> Result<json, error> {\n+fn from_str(s: ~str) -> Result<Json, Error> {\n     io::with_str_reader(s, from_reader)\n }\n \n /// Test if two json values are equal\n-fn eq(value0: json, value1: json) -> bool {\n+fn eq(value0: Json, value1: Json) -> bool {\n     match (value0, value1) {\n-      (num(f0), num(f1)) => f0 == f1,\n-      (string(s0), string(s1)) => s0 == s1,\n-      (boolean(b0), boolean(b1)) => b0 == b1,\n-      (list(l0), list(l1)) => vec::all2(*l0, *l1, eq),\n-      (dict(d0), dict(d1)) => {\n+      (Num(f0), Num(f1)) => f0 == f1,\n+      (String(s0), String(s1)) => s0 == s1,\n+      (Boolean(b0), Boolean(b1)) => b0 == b1,\n+      (List(l0), List(l1)) => vec::all2(*l0, *l1, eq),\n+      (Dict(d0), Dict(d1)) => {\n           if d0.size() == d1.size() {\n               let mut equal = true;\n               for d0.each |k, v0| {\n@@ -495,202 +497,202 @@ fn eq(value0: json, value1: json) -> bool {\n               false\n           }\n       }\n-      (null, null) => true,\n+      (Null, Null) => true,\n       _ => false\n     }\n }\n \n-trait to_json { fn to_json() -> json; }\n+trait ToJson { fn to_json() -> Json; }\n \n-impl json: to_json {\n-    fn to_json() -> json { self }\n+impl Json: ToJson {\n+    fn to_json() -> Json { self }\n }\n \n-impl @json: to_json {\n-    fn to_json() -> json { *self }\n+impl @Json: ToJson {\n+    fn to_json() -> Json { *self }\n }\n \n-impl int: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl int: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl i8: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl i8: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl i16: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl i16: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl i32: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl i32: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl i64: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl i64: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl uint: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl uint: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl u8: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl u8: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl u16: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl u16: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl u32: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl u32: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl u64: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl u64: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl float: to_json {\n-    fn to_json() -> json { num(self) }\n+impl float: ToJson {\n+    fn to_json() -> Json { Num(self) }\n }\n \n-impl f32: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl f32: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl f64: to_json {\n-    fn to_json() -> json { num(self as float) }\n+impl f64: ToJson {\n+    fn to_json() -> Json { Num(self as float) }\n }\n \n-impl (): to_json {\n-    fn to_json() -> json { null }\n+impl (): ToJson {\n+    fn to_json() -> Json { Null }\n }\n \n-impl bool: to_json {\n-    fn to_json() -> json { boolean(self) }\n+impl bool: ToJson {\n+    fn to_json() -> Json { Boolean(self) }\n }\n \n-impl ~str: to_json {\n-    fn to_json() -> json { string(@copy self) }\n+impl ~str: ToJson {\n+    fn to_json() -> Json { String(@copy self) }\n }\n \n-impl @~str: to_json {\n-    fn to_json() -> json { string(self) }\n+impl @~str: ToJson {\n+    fn to_json() -> Json { String(self) }\n }\n \n-impl <A: to_json, B: to_json> (A, B): to_json {\n-    fn to_json() -> json {\n+impl <A: ToJson, B: ToJson> (A, B): ToJson {\n+    fn to_json() -> Json {\n         match self {\n           (a, b) => {\n-            list(@~[a.to_json(), b.to_json()])\n+            List(@~[a.to_json(), b.to_json()])\n           }\n         }\n     }\n }\n \n-impl <A: to_json, B: to_json, C: to_json> (A, B, C): to_json {\n+impl <A: ToJson, B: ToJson, C: ToJson> (A, B, C): ToJson {\n \n-    fn to_json() -> json {\n+    fn to_json() -> Json {\n         match self {\n           (a, b, c) => {\n-            list(@~[a.to_json(), b.to_json(), c.to_json()])\n+            List(@~[a.to_json(), b.to_json(), c.to_json()])\n           }\n         }\n     }\n }\n \n-impl <A: to_json> ~[A]: to_json {\n-    fn to_json() -> json { list(@self.map(|elt| elt.to_json())) }\n+impl <A: ToJson> ~[A]: ToJson {\n+    fn to_json() -> Json { List(@self.map(|elt| elt.to_json())) }\n }\n \n-impl <A: to_json copy> hashmap<~str, A>: to_json {\n-    fn to_json() -> json {\n+impl <A: ToJson copy> hashmap<~str, A>: ToJson {\n+    fn to_json() -> Json {\n         let d = map::str_hash();\n         for self.each() |key, value| {\n             d.insert(copy key, value.to_json());\n         }\n-        dict(d)\n+        Dict(d)\n     }\n }\n \n-impl <A: to_json> Option<A>: to_json {\n-    fn to_json() -> json {\n+impl <A: ToJson> Option<A>: ToJson {\n+    fn to_json() -> Json {\n         match self {\n-          None => null,\n+          None => Null,\n           Some(value) => value.to_json()\n         }\n     }\n }\n \n-impl json: to_str::ToStr {\n+impl Json: to_str::ToStr {\n     fn to_str() -> ~str { to_str(self) }\n }\n \n-impl error: to_str::ToStr {\n+impl Error: to_str::ToStr {\n     fn to_str() -> ~str {\n         fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    fn mk_dict(items: ~[(~str, json)]) -> json {\n+    fn mk_dict(items: ~[(~str, Json)]) -> Json {\n         let d = map::str_hash();\n \n         do vec::iter(items) |item| {\n             let (key, value) = copy item;\n             d.insert(key, value);\n         };\n \n-        dict(d)\n+        Dict(d)\n     }\n \n     #[test]\n     fn test_write_null() {\n-        assert to_str(null) == ~\"null\";\n+        assert to_str(Null) == ~\"null\";\n     }\n \n     #[test]\n     fn test_write_num() {\n-        assert to_str(num(3f)) == ~\"3\";\n-        assert to_str(num(3.1f)) == ~\"3.1\";\n-        assert to_str(num(-1.5f)) == ~\"-1.5\";\n-        assert to_str(num(0.5f)) == ~\"0.5\";\n+        assert to_str(Num(3f)) == ~\"3\";\n+        assert to_str(Num(3.1f)) == ~\"3.1\";\n+        assert to_str(Num(-1.5f)) == ~\"-1.5\";\n+        assert to_str(Num(0.5f)) == ~\"0.5\";\n     }\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(string(@~\"\")) == ~\"\\\"\\\"\";\n-        assert to_str(string(@~\"foo\")) == ~\"\\\"foo\\\"\";\n+        assert to_str(String(@~\"\")) == ~\"\\\"\\\"\";\n+        assert to_str(String(@~\"foo\")) == ~\"\\\"foo\\\"\";\n     }\n \n     #[test]\n     fn test_write_bool() {\n-        assert to_str(boolean(true)) == ~\"true\";\n-        assert to_str(boolean(false)) == ~\"false\";\n+        assert to_str(Boolean(true)) == ~\"true\";\n+        assert to_str(Boolean(false)) == ~\"false\";\n     }\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(list(@~[])) == ~\"[]\";\n-        assert to_str(list(@~[boolean(true)])) == ~\"[true]\";\n-        assert to_str(list(@~[\n-            boolean(false),\n-            null,\n-            list(@~[string(@~\"foo\\nbar\"), num(3.5f)])\n+        assert to_str(List(@~[])) == ~\"[]\";\n+        assert to_str(List(@~[Boolean(true)])) == ~\"[true]\";\n+        assert to_str(List(@~[\n+            Boolean(false),\n+            Null,\n+            List(@~[String(@~\"foo\\nbar\"), Num(3.5f)])\n         ])) == ~\"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n     }\n \n     #[test]\n     fn test_write_dict() {\n         assert to_str(mk_dict(~[])) == ~\"{}\";\n-        assert to_str(mk_dict(~[(~\"a\", boolean(true))]))\n+        assert to_str(mk_dict(~[(~\"a\", Boolean(true))]))\n             == ~\"{ \\\"a\\\": true }\";\n         assert to_str(mk_dict(~[\n-            (~\"a\", boolean(true)),\n-            (~\"b\", list(@~[\n-                mk_dict(~[(~\"c\", string(@~\"\\x0c\\r\"))]),\n-                mk_dict(~[(~\"d\", string(@~\"\"))])\n+            (~\"a\", Boolean(true)),\n+            (~\"b\", List(@~[\n+                mk_dict(~[(~\"c\", String(@~\"\\x0c\\r\"))]),\n+                mk_dict(~[(~\"d\", String(@~\"\"))])\n             ]))\n         ])) ==\n             ~\"{ \" +\n@@ -735,12 +737,12 @@ mod tests {\n         assert from_str(~\"faz\") ==\n             Err({line: 1u, col: 3u, msg: @~\"invalid syntax\"});\n \n-        assert from_str(~\"null\") == Ok(null);\n-        assert from_str(~\"true\") == Ok(boolean(true));\n-        assert from_str(~\"false\") == Ok(boolean(false));\n-        assert from_str(~\" null \") == Ok(null);\n-        assert from_str(~\" true \") == Ok(boolean(true));\n-        assert from_str(~\" false \") == Ok(boolean(false));\n+        assert from_str(~\"null\") == Ok(Null);\n+        assert from_str(~\"true\") == Ok(Boolean(true));\n+        assert from_str(~\"false\") == Ok(Boolean(false));\n+        assert from_str(~\" null \") == Ok(Null);\n+        assert from_str(~\" true \") == Ok(Boolean(true));\n+        assert from_str(~\" false \") == Ok(Boolean(false));\n     }\n \n     #[test]\n@@ -761,14 +763,14 @@ mod tests {\n         assert from_str(~\"1e+\") ==\n             Err({line: 1u, col: 4u, msg: @~\"invalid number\"});\n \n-        assert from_str(~\"3\") == Ok(num(3f));\n-        assert from_str(~\"3.1\") == Ok(num(3.1f));\n-        assert from_str(~\"-1.2\") == Ok(num(-1.2f));\n-        assert from_str(~\"0.4\") == Ok(num(0.4f));\n-        assert from_str(~\"0.4e5\") == Ok(num(0.4e5f));\n-        assert from_str(~\"0.4e+15\") == Ok(num(0.4e15f));\n-        assert from_str(~\"0.4e-01\") == Ok(num(0.4e-01f));\n-        assert from_str(~\" 3 \") == Ok(num(3f));\n+        assert from_str(~\"3\") == Ok(Num(3f));\n+        assert from_str(~\"3.1\") == Ok(Num(3.1f));\n+        assert from_str(~\"-1.2\") == Ok(Num(-1.2f));\n+        assert from_str(~\"0.4\") == Ok(Num(0.4f));\n+        assert from_str(~\"0.4e5\") == Ok(Num(0.4e5f));\n+        assert from_str(~\"0.4e+15\") == Ok(Num(0.4e15f));\n+        assert from_str(~\"0.4e-01\") == Ok(Num(0.4e-01f));\n+        assert from_str(~\" 3 \") == Ok(Num(3f));\n     }\n \n     #[test]\n@@ -778,14 +780,14 @@ mod tests {\n         assert from_str(~\"\\\"lol\") ==\n             Err({line: 1u, col: 5u, msg: @~\"EOF while parsing string\"});\n \n-        assert from_str(~\"\\\"\\\"\") == Ok(string(@~\"\"));\n-        assert from_str(~\"\\\"foo\\\"\") == Ok(string(@~\"foo\"));\n-        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(string(@~\"\\\"\"));\n-        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(string(@~\"\\x08\"));\n-        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(string(@~\"\\n\"));\n-        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(string(@~\"\\r\"));\n-        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(string(@~\"\\t\"));\n-        assert from_str(~\" \\\"foo\\\" \") == Ok(string(@~\"foo\"));\n+        assert from_str(~\"\\\"\\\"\") == Ok(String(@~\"\"));\n+        assert from_str(~\"\\\"foo\\\"\") == Ok(String(@~\"foo\"));\n+        assert from_str(~\"\\\"\\\\\\\"\\\"\") == Ok(String(@~\"\\\"\"));\n+        assert from_str(~\"\\\"\\\\b\\\"\") == Ok(String(@~\"\\x08\"));\n+        assert from_str(~\"\\\"\\\\n\\\"\") == Ok(String(@~\"\\n\"));\n+        assert from_str(~\"\\\"\\\\r\\\"\") == Ok(String(@~\"\\r\"));\n+        assert from_str(~\"\\\"\\\\t\\\"\") == Ok(String(@~\"\\t\"));\n+        assert from_str(~\" \\\"foo\\\" \") == Ok(String(@~\"foo\"));\n     }\n \n     #[test]\n@@ -801,15 +803,15 @@ mod tests {\n         assert from_str(~\"[6 7]\") ==\n             Err({line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"});\n \n-        assert from_str(~\"[]\") == Ok(list(@~[]));\n-        assert from_str(~\"[ ]\") == Ok(list(@~[]));\n-        assert from_str(~\"[true]\") == Ok(list(@~[boolean(true)]));\n-        assert from_str(~\"[ false ]\") == Ok(list(@~[boolean(false)]));\n-        assert from_str(~\"[null]\") == Ok(list(@~[null]));\n-        assert from_str(~\"[3, 1]\") == Ok(list(@~[num(3f), num(1f)]));\n-        assert from_str(~\"\\n[3, 2]\\n\") == Ok(list(@~[num(3f), num(2f)]));\n+        assert from_str(~\"[]\") == Ok(List(@~[]));\n+        assert from_str(~\"[ ]\") == Ok(List(@~[]));\n+        assert from_str(~\"[true]\") == Ok(List(@~[Boolean(true)]));\n+        assert from_str(~\"[ false ]\") == Ok(List(@~[Boolean(false)]));\n+        assert from_str(~\"[null]\") == Ok(List(@~[Null]));\n+        assert from_str(~\"[3, 1]\") == Ok(List(@~[Num(3f), Num(1f)]));\n+        assert from_str(~\"\\n[3, 2]\\n\") == Ok(List(@~[Num(3f), Num(2f)]));\n         assert from_str(~\"[2, [4, 1]]\") ==\n-               Ok(list(@~[num(2f), list(@~[num(4f), num(1f)])]));\n+               Ok(List(@~[Num(2f), List(@~[Num(4f), Num(1f)])]));\n     }\n \n     #[test]\n@@ -840,20 +842,20 @@ mod tests {\n \n         assert eq(result::get(from_str(~\"{}\")), mk_dict(~[]));\n         assert eq(result::get(from_str(~\"{\\\"a\\\": 3}\")),\n-                  mk_dict(~[(~\"a\", num(3.0f))]));\n+                  mk_dict(~[(~\"a\", Num(3.0f))]));\n \n         assert eq(result::get(from_str(~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n                   mk_dict(~[\n-                      (~\"a\", null),\n-                      (~\"b\", boolean(true))]));\n+                      (~\"a\", Null),\n+                      (~\"b\", Boolean(true))]));\n         assert eq(result::get(from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n                   mk_dict(~[\n-                      (~\"a\", null),\n-                      (~\"b\", boolean(true))]));\n+                      (~\"a\", Null),\n+                      (~\"b\", Boolean(true))]));\n         assert eq(result::get(from_str(~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n                   mk_dict(~[\n-                      (~\"a\", num(1.0)),\n-                      (~\"b\", list(@~[boolean(true)]))\n+                      (~\"a\", Num(1.0)),\n+                      (~\"b\", List(@~[Boolean(true)]))\n                   ]));\n         assert eq(result::get(from_str(\n                       ~\"{\" +\n@@ -865,12 +867,12 @@ mod tests {\n                           ~\"]\" +\n                       ~\"}\")),\n                   mk_dict(~[\n-                      (~\"a\", num(1.0f)),\n-                      (~\"b\", list(@~[\n-                          boolean(true),\n-                          string(@~\"foo\\nbar\"),\n+                      (~\"a\", Num(1.0f)),\n+                      (~\"b\", List(@~[\n+                          Boolean(true),\n+                          String(@~\"foo\\nbar\"),\n                           mk_dict(~[\n-                              (~\"c\", mk_dict(~[(~\"d\", null)]))\n+                              (~\"c\", mk_dict(~[(~\"d\", Null)]))\n                           ])\n                       ]))\n                   ]));"}, {"sha": "2003e51f6f9456b039da94fedae66c0cce84bbb1", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -27,15 +27,15 @@ updating the states using rule (2) until there are no changes.\n \n */\n \n-import std::bitv::{bitv};\n+import std::bitv::{Bitv};\n \n import ast_builder::empty_span;\n \n fn analyze(proto: protocol, _cx: ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let colive = do (copy proto.states).map_to_vec |state| {\n-        let bv = ~bitv(num_states, false);\n+        let bv = ~Bitv(num_states, false);\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }\n@@ -88,4 +88,4 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n         debug!(\"protocol %s is bounded. yay!\", proto.name);\n         proto.bounded = Some(true);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "9d92a452b672a60b4094bfd80a4249f2b65435cb", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -421,7 +421,7 @@ fn host_triple() -> ~str {\n         };\n }\n \n-fn build_session_options(matches: getopts::matches,\n+fn build_session_options(matches: getopts::Matches,\n                          demitter: diagnostic::emitter) -> @session::options {\n     let crate_type = if opt_present(matches, ~\"lib\") {\n         session::lib_crate\n@@ -605,7 +605,7 @@ fn parse_pretty(sess: session, &&name: ~str) -> pp_mode {\n     }\n }\n \n-fn opts() -> ~[getopts::opt] {\n+fn opts() -> ~[getopts::Opt] {\n     return ~[optflag(~\"h\"), optflag(~\"help\"),\n              optflag(~\"v\"), optflag(~\"version\"),\n           optflag(~\"emit-llvm\"), optflagopt(~\"pretty\"),"}, {"sha": "18ad56b4ab226df9356b66dc637e841039af37db", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -63,8 +63,8 @@ export translate_def_id;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n-   Option<ebml::doc> {\n+fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n+   Option<ebml::Doc> {\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n@@ -81,7 +81,7 @@ fn lookup_hash(d: ebml::doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n     None\n }\n \n-fn maybe_find_item(item_id: int, items: ebml::doc) -> Option<ebml::doc> {\n+fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(vec::view(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n@@ -91,13 +91,13 @@ fn maybe_find_item(item_id: int, items: ebml::doc) -> Option<ebml::doc> {\n                 hash_node_id(item_id))\n }\n \n-fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n+fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n     return option::get(maybe_find_item(item_id, items));\n }\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n+fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n        None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n@@ -129,7 +129,7 @@ enum Family {\n     InheritedField         // N\n }\n \n-fn item_family(item: ebml::doc) -> Family {\n+fn item_family(item: ebml::Doc) -> Family {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);\n     match ebml::doc_as_u8(fam) as char {\n       'c' => Const,\n@@ -157,33 +157,33 @@ fn item_family(item: ebml::doc) -> Family {\n     }\n }\n \n-fn item_symbol(item: ebml::doc) -> ~str {\n+fn item_symbol(item: ebml::Doc) -> ~str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n     return str::from_bytes(ebml::doc_data(sym));\n }\n \n-fn item_parent_item(d: ebml::doc) -> Option<ast::def_id> {\n+fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n     for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n         return Some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n     }\n     None\n }\n \n-fn item_def_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n+fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n     let tagdoc = ebml::get_doc(d, tag_def_id);\n     return translate_def_id(cdata, ebml::with_doc_data(tagdoc,\n                                                     |d| parse_def_id(d)));\n }\n \n-fn each_reexport(d: ebml::doc, f: fn(ebml::doc) -> bool) {\n+fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n     for ebml::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n     }\n }\n \n-fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n+fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n         ebml::maybe_get_doc(d, tag_class_mut),\n@@ -196,36 +196,36 @@ fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n         })\n }\n \n-fn variant_disr_val(d: ebml::doc) -> Option<int> {\n+fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n     do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n         int::parse_buf(ebml::doc_data(val_doc), 10u)\n     }\n }\n \n-fn doc_type(doc: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = ebml::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n         translate_def_id(cdata, did)\n     })\n }\n \n-fn item_type(item_id: ast::def_id, item: ebml::doc,\n+fn item_type(item_id: ast::def_id, item: ebml::Doc,\n              tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n     if family_names_type(item_family(item)) {\n         ty::mk_with_id(tcx, t, item_id)\n     } else { t }\n }\n \n-fn item_impl_traits(item: ebml::doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n+fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n     for ebml::tagged_docs(item, tag_impl_trait) |ity| {\n         vec::push(results, doc_type(ity, tcx, cdata));\n     };\n     results\n }\n \n-fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n+fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n     for ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n@@ -237,21 +237,21 @@ fn item_ty_param_bounds(item: ebml::doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::doc) -> Option<ty::region_variance> {\n+fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n     ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n         let d = ebml::ebml_deserializer(doc);\n         ty::deserialize_region_variance(d)\n     })\n }\n \n-fn item_ty_param_count(item: ebml::doc) -> uint {\n+fn item_ty_param_count(item: ebml::Doc) -> uint {\n     let mut n = 0u;\n     ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n                       |_p| { n += 1u; true } );\n     n\n }\n \n-fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n+fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n     for ebml::tagged_docs(item, v) |p| {\n@@ -261,7 +261,7 @@ fn enum_variant_ids(item: ebml::doc, cdata: cmd) -> ~[ast::def_id] {\n     return ids;\n }\n \n-fn item_path(intr: ident_interner, item_doc: ebml::doc) -> ast_map::path {\n+fn item_path(intr: ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     let path_doc = ebml::get_doc(item_doc, tag_path);\n \n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n@@ -285,12 +285,12 @@ fn item_path(intr: ident_interner, item_doc: ebml::doc) -> ast_map::path {\n     return result;\n }\n \n-fn item_name(intr: ident_interner, item: ebml::doc) -> ast::ident {\n+fn item_name(intr: ident_interner, item: ebml::Doc) -> ast::ident {\n     let name = ebml::get_doc(item, tag_paths_data_name);\n     intr.intern(@str::from_bytes(ebml::doc_data(name)))\n }\n \n-fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n+fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n     let fam = item_family(item);\n     match fam {\n@@ -533,7 +533,7 @@ type decode_inlined_item = fn(\n     cdata: cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,\n-    par_doc: ebml::doc) -> Option<ast::inlined_item>;\n+    par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n \n fn maybe_get_item_ast(intr: ident_interner, cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n@@ -602,7 +602,7 @@ type method_info = {\n \n type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n \n-fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n+fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n             'i' => { ast::m_imm }\n@@ -631,7 +631,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n     }\n }\n \n-fn item_impl_methods(intr: ident_interner, cdata: cmd, item: ebml::doc,\n+fn item_impl_methods(intr: ident_interner, cdata: cmd, item: ebml::Doc,\n                      base_tps: uint) -> ~[@method_info] {\n     let mut rslt = ~[];\n     for ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n@@ -780,15 +780,15 @@ fn family_names_type(fam: Family) -> bool {\n     match fam { Type | Mod | Trait => true, _ => false }\n }\n \n-fn read_path(d: ebml::doc) -> {path: ~str, pos: uint} {\n+fn read_path(d: ebml::Doc) -> {path: ~str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n     return {path: path, pos: pos};\n }\n \n-fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n+fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n@@ -823,7 +823,7 @@ fn item_family_to_str(fam: Family) -> ~str {\n     }\n }\n \n-fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n+fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n     for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n@@ -848,7 +848,7 @@ fn get_meta_items(md: ebml::doc) -> ~[@ast::meta_item] {\n     return items;\n }\n \n-fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n+fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n     match ebml::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n@@ -870,13 +870,13 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n }\n \n fn list_meta_items(intr: ident_interner,\n-                   meta_items: ebml::doc, out: io::Writer) {\n+                   meta_items: ebml::Doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(mi, intr)));\n     }\n }\n \n-fn list_crate_attributes(intr: ident_interner, md: ebml::doc, hash: ~str,\n+fn list_crate_attributes(intr: ident_interner, md: ebml::Doc, hash: ~str,\n                          out: io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n@@ -899,7 +899,7 @@ fn get_crate_deps(intr: ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let cratedoc = ebml::doc(data);\n     let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::doc, tag_: uint) -> ~str {\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n         str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n     }\n     for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {"}, {"sha": "1b360b7f78255b567a6e1e72239448ec58dd0b17", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -5,7 +5,7 @@ import util::ppaux::ty_to_str;\n import std::{ebml, map};\n import std::map::hashmap;\n import io::WriterUtil;\n-import ebml::writer;\n+import ebml::Writer;\n import syntax::ast::*;\n import syntax::print::pprust;\n import syntax::{ast_util, visit};\n@@ -37,7 +37,7 @@ export encode_def_id;\n type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n type encode_inlined_item = fn@(ecx: @encode_ctxt,\n-                               ebml_w: ebml::writer,\n+                               ebml_w: ebml::Writer,\n                                path: ast_map::path,\n                                ii: ast::inlined_item);\n \n@@ -86,15 +86,15 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: ebml::writer, name: ident) {\n+fn encode_name(ecx: @encode_ctxt, ebml_w: ebml::Writer, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n+fn encode_def_id(ebml_w: ebml::Writer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n@@ -104,7 +104,7 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     }\n }\n \n-fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n+fn encode_mutability(ebml_w: ebml::Writer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n           class_immutable => 'a',\n@@ -116,7 +116,7 @@ fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::writer, path: &[ident],\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: &[ident],\n                 &index: ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     vec::push_all(full_path, path);\n@@ -127,23 +127,23 @@ fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::writer, path: &[ident],\n                pos: ebml_w.writer.tell()});\n }\n \n-fn encode_trait_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @trait_ref) {\n+fn encode_trait_ref(ebml_w: ebml::Writer, ecx: @encode_ctxt, t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n     ebml_w.end_tag();\n }\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: ebml::writer, c: char) {\n+fn encode_family(ebml_w: ebml::Writer, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: ebml::Writer, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n@@ -157,21 +157,21 @@ fn encode_ty_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: ebml::Writer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n \n-fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n+fn encode_variant_id(ebml_w: ebml::Writer, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n+fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -181,13 +181,13 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::Writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n       Some(x) => x,\n@@ -200,25 +200,25 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::Writer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::writer, disr_val: int) {\n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::Writer, disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: ebml::writer, id: def_id) {\n+fn encode_parent_item(ebml_w: ebml::Writer, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                             id: node_id, variants: ~[variant],\n                             path: ast_map::path, index: @mut ~[entry<int>],\n                             ty_params: ~[ty_param]) {\n@@ -255,9 +255,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::writer, path: ast_map::path,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: ast_map::path,\n                name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -274,7 +274,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::writer, path: ast_map::path,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::Writer, md: _mod,\n                        id: node_id, path: ast_map::path, name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -332,15 +332,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     ebml_w.end_tag();\n }\n \n-fn encode_visibility(ebml_w: ebml::writer, visibility: visibility) {\n+fn encode_visibility(ebml_w: ebml::Writer, visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n-fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: ebml::Writer, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -373,7 +373,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                          id: node_id, path: ast_map::path,\n                          class_tps: ~[ty_param],\n                          fields: ~[@struct_field],\n@@ -429,7 +429,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                         id: node_id, ident: ident, path: ast_map::path,\n                         item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -454,7 +454,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n@@ -504,7 +504,7 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n                         index: @mut ~[entry<int>], path: ast_map::path) {\n \n     let tcx = ecx.tcx;\n@@ -516,7 +516,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: ebml::writer,\n+    fn add_to_index_(item: @item, ebml_w: ebml::Writer,\n                      index: @mut ~[entry<int>]) {\n         vec::push(*index, {val: item.id, pos: ebml_w.writer.tell()});\n     }\n@@ -795,7 +795,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n@@ -829,7 +829,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n@@ -884,7 +884,7 @@ fn create_index<T: copy>(index: ~[entry<T>], hash_fn: fn@(T) -> uint) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: ebml::writer, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: ebml::Writer, buckets: ~[@~[entry<T>]],\n                    write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -919,7 +919,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n+fn encode_meta_item(ebml_w: ebml::Writer, mi: meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -956,7 +956,7 @@ fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: ebml::writer, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: ebml::Writer, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1018,7 +1018,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                      cstore: cstore::cstore) {\n \n     fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::cstore)\n@@ -1064,7 +1064,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1079,7 +1079,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::writer,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: ebml::writer, hash: ~str) {\n+fn encode_hash(ebml_w: ebml::Writer, hash: ~str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1113,7 +1113,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n      });\n \n     let buf_w = io::mem_buffer_writer(buf);\n-    let ebml_w = ebml::writer(buf_w);\n+    let ebml_w = ebml::Writer(buf_w);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "5daed725d244b8c1d92d11cd917540dd05747eef", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -8,7 +8,7 @@ import syntax::ast_map;\n import syntax::ast_util;\n import syntax::codemap::span;\n import std::ebml;\n-import std::ebml::writer;\n+import std::ebml::Writer;\n import std::ebml::get_doc;\n import std::map::hashmap;\n import std::serialization::serializer;\n@@ -78,7 +78,7 @@ trait tr {\n // Top-level methods.\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: ebml::writer,\n+                       ebml_w: ebml::Writer,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n@@ -104,7 +104,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        tcx: ty::ctxt,\n                        maps: maps,\n                        path: ast_map::path,\n-                       par_doc: ebml::doc) -> Option<ast::inlined_item> {\n+                       par_doc: ebml::Doc) -> Option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n@@ -222,7 +222,7 @@ impl<D: deserializer> D: def_id_deserializer_helpers {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: ebml::Writer, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         ast::serialize_inlined_item(ebml_w, item)\n     }\n@@ -282,7 +282,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     }\n }\n \n-fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n+fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n     let d = ebml::ebml_deserializer(chi_doc);\n     ast::deserialize_inlined_item(d)\n@@ -336,11 +336,11 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: ebml::writer, def: ast::def) {\n+fn encode_def(ebml_w: ebml::Writer, def: ast::def) {\n     ast::serialize_def(ebml_w, def)\n }\n \n-fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n+fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n     let dsr = ebml::ebml_deserializer(doc);\n     let def = ast::deserialize_def(dsr);\n     def.tr(xcx)\n@@ -388,15 +388,15 @@ impl ast::def: tr {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: ebml::writer, fv: freevar_entry) {\n+fn encode_freevar_entry(ebml_w: ebml::Writer, fv: freevar_entry) {\n     serialize_freevar_entry(ebml_w, fv)\n }\n \n trait ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n }\n \n-impl ebml::ebml_deserializer: ebml_deserializer_helper {\n+impl ebml::EbmlDeserializer: ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n         let fv = deserialize_freevar_entry(self);\n         fv.tr(xcx)\n@@ -416,7 +416,7 @@ trait read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry;\n }\n \n-impl ebml::ebml_deserializer: read_method_map_entry_helper {\n+impl ebml::EbmlDeserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         let mme = deserialize_method_map_entry(self);\n         {derefs: mme.derefs,\n@@ -445,7 +445,7 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                   ebml_w: ebml::writer,\n+                   ebml_w: ebml::Writer,\n                    dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n@@ -457,7 +457,7 @@ fn encode_vtable_res(ecx: @e::encode_ctxt,\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: ebml::writer,\n+                      ebml_w: ebml::Writer,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         match vtable_origin {\n@@ -504,7 +504,7 @@ trait vtable_deserialization_helpers {\n     fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n }\n \n-impl ebml::ebml_deserializer: vtable_deserialization_helpers {\n+impl ebml::EbmlDeserializer: vtable_deserialization_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -579,7 +579,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl ebml::writer: ebml_writer_helpers {\n+impl ebml::Writer: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         e::write_type(ecx, self, ty)\n     }\n@@ -618,7 +618,7 @@ trait write_tag_and_id {\n     fn id(id: ast::node_id);\n }\n \n-impl ebml::writer: write_tag_and_id {\n+impl ebml::Writer: write_tag_and_id {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -630,7 +630,7 @@ impl ebml::writer: write_tag_and_id {\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml::writer,\n+                             ebml_w: ebml::Writer,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n         ast_util::visit_ids_for_inlined_item(\n@@ -646,7 +646,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml::writer,\n+                             ebml_w: ebml::Writer,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -771,12 +771,12 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n trait doc_decoder_helpers {\n     fn as_int() -> int;\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml::doc>;\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc>;\n }\n \n-impl ebml::doc: doc_decoder_helpers {\n+impl ebml::Doc: doc_decoder_helpers {\n     fn as_int() -> int { ebml::doc_as_u64(self) as int }\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml::doc> {\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc> {\n         ebml::maybe_get_doc(self, tag as uint)\n     }\n }\n@@ -789,7 +789,7 @@ trait ebml_deserializer_decoder_helpers {\n                                 -> ty::ty_param_bounds_and_ty;\n }\n \n-impl ebml::ebml_deserializer: ebml_deserializer_decoder_helpers {\n+impl ebml::EbmlDeserializer: ebml_deserializer_decoder_helpers {\n \n     fn read_ty(xcx: extended_decode_ctxt) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n@@ -831,7 +831,7 @@ impl ebml::ebml_deserializer: ebml_deserializer_decoder_helpers {\n }\n \n fn decode_side_tables(xcx: extended_decode_ctxt,\n-                      ast_doc: ebml::doc) {\n+                      ast_doc: ebml::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table as uint];\n     for ebml::docs(tbl_doc) |tag, entry_doc| {\n@@ -901,14 +901,14 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: ebml::writer, item: @ast::item) {\n+fn encode_item_ast(ebml_w: ebml::Writer, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n         ast::serialize_item(ebml_w, *item);\n     }\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::doc) -> @ast::item {\n+fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n     let d = ebml::ebml_deserializer(chi_doc);\n     @ast::deserialize_item(d)\n@@ -937,7 +937,7 @@ fn mk_ctxt() -> fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n     let mbuf = io::mem_buffer();\n-    let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n+    let ebml_w = ebml::Writer(io::mem_buffer_writer(mbuf));\n     encode_item_ast(ebml_w, in_item);\n     let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n     let out_item = decode_item_ast(ebml_doc);"}, {"sha": "9abdc889fceb0a1cb78a546cc884b8d6fa37f9f4", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -41,7 +41,7 @@ fn opt_output_style() -> ~str { ~\"output-style\" }\n fn opt_pandoc_cmd() -> ~str { ~\"pandoc-cmd\" }\n fn opt_help() -> ~str { ~\"h\" }\n \n-fn opts() -> ~[(getopts::opt, ~str)] {\n+fn opts() -> ~[(getopts::Opt, ~str)] {\n     ~[\n         (getopts::optopt(opt_output_dir()),\n          ~\"--output-dir <val>     put documents here\"),\n@@ -119,7 +119,7 @@ fn parse_config_(\n \n fn config_from_opts(\n     input_crate: &Path,\n-    matches: getopts::matches,\n+    matches: getopts::Matches,\n     program_output: program_output\n ) -> Result<config, ~str> {\n "}, {"sha": "70c4bf20f75fdd19e3830046e062c045ea0ef22c", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -11,7 +11,7 @@ import std::map;\n import std::map::map;\n import std::map::hashmap;\n import std::deque;\n-import std::deque::t;\n+import std::deque::Deque;\n import std::par;\n import io::WriterUtil;\n import comm::*;"}, {"sha": "0630d9e5c8a25e95c2f636cb46f2ac2478563d9f", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,6 +1,6 @@\n use std;\n import std::arena;\n-import methods = std::arena::arena;\n+import methods = std::arena::Arena;\n \n enum tree/& { nil, node(&tree, &tree, int), }\n \n@@ -13,7 +13,7 @@ fn item_check(t: &tree) -> int {\n     }\n }\n \n-fn bottom_up_tree(arena: &r/arena::arena,\n+fn bottom_up_tree(arena: &r/arena::Arena,\n                   item: int,\n                   depth: int) -> &r/tree {\n     if depth > 0 {\n@@ -43,15 +43,15 @@ fn main(args: ~[~str]) {\n         max_depth = n;\n     }\n \n-    let stretch_arena = arena::arena();\n+    let stretch_arena = arena::Arena();\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(&stretch_arena, 0, stretch_depth);\n \n     io::println(fmt!(\"stretch tree of depth %d\\t check: %d\",\n                           stretch_depth,\n                           item_check(stretch_tree)));\n \n-    let long_lived_arena = arena::arena();\n+    let long_lived_arena = arena::Arena();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n     let mut depth = min_depth;\n     while depth <= max_depth {"}, {"sha": "8f9878a6d116705badb2cdc9d0ceb417208def12", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -50,7 +50,7 @@ fn solve_grid(g: grid_t) {\n     fn next_color(g: grid, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n-            let avail = bitv::bitv(10u, false);\n+            let avail = bitv::Bitv(10u, false);\n             for u8::range(start_color, 10u8) |color| {\n                 avail.set(color as uint, true);\n             }\n@@ -71,8 +71,8 @@ fn solve_grid(g: grid_t) {\n     }\n \n     // find colors available in neighbourhood of (row, col)\n-    fn drop_colors(g: grid, avail: bitv::bitv, row: u8, col: u8) {\n-        fn drop_color(g: grid, colors: bitv::bitv, row: u8, col: u8) {\n+    fn drop_colors(g: grid, avail: bitv::Bitv, row: u8, col: u8) {\n+        fn drop_color(g: grid, colors: bitv::Bitv, row: u8, col: u8) {\n             let color = g[row][col];\n             if color != 0u8 { colors.set(color as uint, false); }\n         }"}, {"sha": "c2fdd5a8fdb3a8f549c5ae3a73746de3674578bf", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -6,7 +6,7 @@ import std::bitv;\n type fn_info = {vars: hashmap<uint, var_info>};\n type var_info = {a: uint, b: uint};\n \n-fn bitv_to_str(enclosing: fn_info, v: ~bitv::bitv) -> str {\n+fn bitv_to_str(enclosing: fn_info, v: ~bitv::Bitv) -> str {\n     let s = \"\";\n \n     // error is that the value type in the hash map is var_info, not a box"}, {"sha": "d2d675577aa0663dd77c3de8b70f3b32e0e45102", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -9,8 +9,8 @@ import std::serialization::{serialize_uint, deserialize_uint};\n \n fn test_ser_and_deser<A>(a1: A,\n                          expected: ~str,\n-                         ebml_ser_fn: fn(ebml::writer, A),\n-                         ebml_deser_fn: fn(ebml::ebml_deserializer) -> A,\n+                         ebml_ser_fn: fn(ebml::Writer, A),\n+                         ebml_deser_fn: fn(ebml::EbmlDeserializer) -> A,\n                          io_ser_fn: fn(io::Writer, A)) {\n \n     // check the pretty printer:\n@@ -21,7 +21,7 @@ fn test_ser_and_deser<A>(a1: A,\n \n     // check the EBML serializer:\n     let buf = io::mem_buffer();\n-    let w = ebml::writer(buf as io::Writer);\n+    let w = ebml::Writer(buf as io::Writer);\n     ebml_ser_fn(w, a1);\n     let d = ebml::doc(@io::mem_buffer_buf(buf));\n     let a2 = ebml_deser_fn(ebml::ebml_deserializer(d));"}, {"sha": "5782049109154f680ab6df224a8c2c1d2536174f", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -2,12 +2,12 @@ use std;\n import std::bitv::*;\n \n fn bitv_test() -> bool {\n-    let v1 = ~bitv(31, false);\n-    let v2 = ~bitv(31, true);\n+    let v1 = ~Bitv(31, false);\n+    let v2 = ~Bitv(31, true);\n     v1.union(v2);\n     true\n }\n \n fn main() {\n     do iter::repeat(10000) || {bitv_test()};\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f97e4539a831365059375f0d2207f8bc1ee97b85", "filename": "src/test/run-pass/issue-2101.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fissue-2101.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fissue-2101.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2101.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,16 +1,16 @@\n // xfail-test\n use std;\n import std::arena;\n-import std::arena::arena;\n+import std::arena::Arena;\n \n enum hold { s(str) }\n \n-fn init(ar: &a.arena::arena, str: str) -> &a.hold {\n+fn init(ar: &a.arena::Arena, str: str) -> &a.hold {\n     new(*ar) s(str)\n }\n \n fn main(args: ~[str]) {\n-    let ar = arena::arena();\n+    let ar = arena::Arena();\n     let leak = init(&ar, args[0]);\n     match *leak {\n         s(astr) {"}, {"sha": "81c61dd1e64c405f6073a1d5e5eaf3e7c462a535", "filename": "src/test/run-pass/issue-2383.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fissue-2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2383.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,6 +1,6 @@\n use std;\n import std::deque;\n-import std::deque::t;\n+import std::deque::Deque;\n \n fn main() {\n     let Q = deque::create();"}, {"sha": "b0547d66e966543fd9268298c8817508cb5f2000", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -9,11 +9,11 @@ enum object\n     int_value(i64),\n }\n \n-fn lookup(table: std::map::hashmap<~str, std::json::json>, key: ~str, default: ~str) -> ~str\n+fn lookup(table: std::map::hashmap<~str, std::json::Json>, key: ~str, default: ~str) -> ~str\n {\n     match table.find(key)\n     {\n-        option::Some(std::json::string(s)) =>\n+        option::Some(std::json::String(s)) =>\n         {\n             *s\n         }\n@@ -29,11 +29,11 @@ fn lookup(table: std::map::hashmap<~str, std::json::json>, key: ~str, default: ~\n     }\n }\n \n-fn add_interface(store: int, managed_ip: ~str, data: std::json::json) -> (~str, object)\n+fn add_interface(store: int, managed_ip: ~str, data: std::json::Json) -> (~str, object)\n {\n     match data\n     {\n-        std::json::dict(interface) =>\n+        std::json::Dict(interface) =>\n         {\n             let name = lookup(interface, ~\"ifDescr\", ~\"\");\n             let label = fmt!(\"%s-%s\", managed_ip, name);\n@@ -48,11 +48,11 @@ fn add_interface(store: int, managed_ip: ~str, data: std::json::json) -> (~str,\n     }\n }\n \n-fn add_interfaces(store: int, managed_ip: ~str, device: std::map::hashmap<~str, std::json::json>) -> ~[(~str, object)]\n+fn add_interfaces(store: int, managed_ip: ~str, device: std::map::hashmap<~str, std::json::Json>) -> ~[(~str, object)]\n {\n     match device[~\"interfaces\"]\n     {\n-        std::json::list(interfaces) =>\n+        std::json::List(interfaces) =>\n         {\n           do vec::map(*interfaces) |interface| {\n                 add_interface(store, managed_ip, interface)"}, {"sha": "eb3aad2c2c97ff85dc85a6ff2c91258c253fece5", "filename": "src/test/run-pass/placement-new-arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-new-arena.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,8 +1,8 @@\n use std;\n-import std::arena::arena;\n+import std::arena;\n \n fn main() {\n-    let p = &arena();\n+    let p = &arena::Arena();\n     let x = p.alloc(|| 4u);\n     io::print(fmt!(\"%u\", *x));\n     assert *x == 4u;"}, {"sha": "9a800eb0d25b0f06d96b0ad3567a88835356f28c", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a605fd0cadb578cf917c93646114eac2f1da8e84/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=a605fd0cadb578cf917c93646114eac2f1da8e84", "patch": "@@ -1,13 +1,13 @@\n use std;\n import libc, sys, unsafe;\n-import std::arena::arena;\n+import std::arena::Arena;\n \n type bcx = {\n     fcx: &fcx\n };\n \n type fcx = {\n-    arena: &arena,\n+    arena: &Arena,\n     ccx: &ccx\n };\n \n@@ -25,7 +25,7 @@ fn g(fcx : &fcx) {\n }\n \n fn f(ccx : &ccx) {\n-    let a = arena();\n+    let a = Arena();\n     let fcx = &{ arena: &a, ccx: ccx };\n     return g(fcx);\n }"}]}