{"sha": "4686ed1a1d6e85d2c17fd67fdf4be597c701d141", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ODZlZDFhMWQ2ZTg1ZDJjMTdmZDY3ZmRmNGJlNTk3YzcwMWQxNDE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-14T03:37:47Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-16T00:50:28Z"}, "message": "std: continue improving the comparison trait impls for str.\n\nThis moves them all into the traits submodule, and delegates Ord\nto the TotalOrd instance. It also deletes the stand-alone lt, gt,\nge and le functions.", "tree": {"sha": "c168f5bde66b10d3c3eb4b2539d3192ffaf45e8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c168f5bde66b10d3c3eb4b2539d3192ffaf45e8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4686ed1a1d6e85d2c17fd67fdf4be597c701d141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4686ed1a1d6e85d2c17fd67fdf4be597c701d141", "html_url": "https://github.com/rust-lang/rust/commit/4686ed1a1d6e85d2c17fd67fdf4be597c701d141", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4686ed1a1d6e85d2c17fd67fdf4be597c701d141/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42974d3bc4ee091c6d6c586ff3c8568231290cd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/42974d3bc4ee091c6d6c586ff3c8568231290cd8", "html_url": "https://github.com/rust-lang/rust/commit/42974d3bc4ee091c6d6c586ff3c8568231290cd8"}], "stats": {"total": 297, "additions": 129, "deletions": 168}, "files": [{"sha": "7050fe7046331bb9d8ae71e1e240a0c0f8b89e48", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4686ed1a1d6e85d2c17fd67fdf4be597c701d141/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4686ed1a1d6e85d2c17fd67fdf4be597c701d141/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=4686ed1a1d6e85d2c17fd67fdf4be597c701d141", "patch": "@@ -26,7 +26,6 @@ use core::either;\n use core::io;\n use core::option;\n use core::result;\n-use core::str;\n use core::task;\n use core::to_str::ToStr;\n use core::uint;\n@@ -542,7 +541,7 @@ pub fn filter_tests(\n \n     // Sort the tests alphabetically\n     fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n-        str::le(t1.desc.name.to_str(), t2.desc.name.to_str())\n+        t1.desc.name.to_str() < t2.desc.name.to_str()\n     }\n     sort::quick_sort(filtered, lteq);\n "}, {"sha": "89d497177dc431440c2322b29a8943c8a4598a51", "filename": "src/libstd/str.rs", "status": "modified", "additions": 128, "deletions": 166, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/4686ed1a1d6e85d2c17fd67fdf4be597c701d141/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4686ed1a1d6e85d2c17fd67fdf4be597c701d141/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4686ed1a1d6e85d2c17fd67fdf4be597c701d141", "patch": "@@ -23,7 +23,6 @@ use cast;\n use char;\n use char::Char;\n use clone::Clone;\n-use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n use iterator::{Iterator, IteratorUtil, FilterIterator, AdditiveIterator, MapIterator};\n@@ -37,8 +36,6 @@ use uint;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector};\n \n-#[cfg(not(test))] use cmp::{Eq, Ord, Equiv, TotalEq};\n-\n /*\n Section: Conditions\n */\n@@ -530,165 +527,6 @@ pub fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n-#[cfg(not(test))]\n-impl<'self> TotalOrd for &'self str {\n-    #[inline]\n-    fn cmp(&self, other: & &'self str) -> Ordering {\n-        for self.bytes_iter().zip(other.bytes_iter()).advance |(s_b, o_b)| {\n-            match s_b.cmp(&o_b) {\n-                Greater => return Greater,\n-                Less => return Less,\n-                Equal => ()\n-            }\n-        }\n-\n-        self.len().cmp(&other.len())\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for ~str {\n-    #[inline]\n-    fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalOrd for @str {\n-    #[inline]\n-    fn cmp(&self, other: &@str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-}\n-\n-/// Bytewise slice less than\n-#[inline]\n-fn lt(a: &str, b: &str) -> bool {\n-    a.cmp(& b) == Less\n-}\n-\n-/// Bytewise less than or equal\n-#[inline]\n-pub fn le(a: &str, b: &str) -> bool {\n-    !lt(b, a)\n-}\n-\n-/// Bytewise greater than or equal\n-#[inline]\n-fn ge(a: &str, b: &str) -> bool {\n-    !lt(a, b)\n-}\n-\n-/// Bytewise greater than\n-#[inline]\n-fn gt(a: &str, b: &str) -> bool {\n-    !le(a, b)\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> Eq for &'self str {\n-    #[inline(always)]\n-    fn eq(&self, other: & &'self str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for ~str {\n-    #[inline(always)]\n-    fn eq(&self, other: &~str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl Eq for @str {\n-    #[inline(always)]\n-    fn eq(&self, other: &@str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> TotalEq for &'self str {\n-    #[inline(always)]\n-    fn equals(&self, other: & &'self str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for ~str {\n-    #[inline(always)]\n-    fn equals(&self, other: &~str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl TotalEq for @str {\n-    #[inline(always)]\n-    fn equals(&self, other: &@str) -> bool {\n-        eq_slice((*self), (*other))\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for ~str {\n-    #[inline(always)]\n-    fn lt(&self, other: &~str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: &~str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &~str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: &~str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self> Ord for &'self str {\n-    #[inline(always)]\n-    fn lt(&self, other: & &'self str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: & &'self str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: & &'self str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: & &'self str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl Ord for @str {\n-    #[inline(always)]\n-    fn lt(&self, other: &@str) -> bool { lt((*self), (*other)) }\n-    #[inline(always)]\n-    fn le(&self, other: &@str) -> bool { le((*self), (*other)) }\n-    #[inline(always)]\n-    fn ge(&self, other: &@str) -> bool { ge((*self), (*other)) }\n-    #[inline(always)]\n-    fn gt(&self, other: &@str) -> bool { gt((*self), (*other)) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for &'self str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for @str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-\n-#[cfg(not(test))]\n-impl<'self, S: Str> Equiv<S> for ~str {\n-    #[inline(always)]\n-    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-}\n-\n /*\n Section: Searching\n */\n@@ -1072,12 +910,136 @@ pub mod raw {\n #[cfg(not(test))]\n pub mod traits {\n     use ops::Add;\n+    use cmp::{TotalOrd, Ordering, Less, Equal, Greater, Eq, Ord, Equiv, TotalEq};\n+    use super::{Str, eq_slice};\n+\n     impl<'self> Add<&'self str,~str> for ~str {\n         #[inline(always)]\n         fn add(&self, rhs: & &'self str) -> ~str {\n             self.append((*rhs))\n         }\n     }\n+\n+    impl<'self> TotalOrd for &'self str {\n+        #[inline]\n+        fn cmp(&self, other: & &'self str) -> Ordering {\n+            for self.bytes_iter().zip(other.bytes_iter()).advance |(s_b, o_b)| {\n+                match s_b.cmp(&o_b) {\n+                    Greater => return Greater,\n+                    Less => return Less,\n+                    Equal => ()\n+                }\n+            }\n+\n+            self.len().cmp(&other.len())\n+        }\n+    }\n+\n+    impl TotalOrd for ~str {\n+        #[inline]\n+        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl TotalOrd for @str {\n+        #[inline]\n+        fn cmp(&self, other: &@str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'self> Eq for &'self str {\n+        #[inline(always)]\n+        fn eq(&self, other: & &'self str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline(always)]\n+        fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for ~str {\n+        #[inline(always)]\n+        fn eq(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline(always)]\n+        fn ne(&self, other: &~str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl Eq for @str {\n+        #[inline(always)]\n+        fn eq(&self, other: &@str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+        #[inline(always)]\n+        fn ne(&self, other: &@str) -> bool { !(*self).eq(other) }\n+    }\n+\n+    impl<'self> TotalEq for &'self str {\n+        #[inline(always)]\n+        fn equals(&self, other: & &'self str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl TotalEq for ~str {\n+        #[inline(always)]\n+        fn equals(&self, other: &~str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl TotalEq for @str {\n+        #[inline(always)]\n+        fn equals(&self, other: &@str) -> bool {\n+            eq_slice((*self), (*other))\n+        }\n+    }\n+\n+    impl<'self> Ord for &'self str {\n+        #[inline(always)]\n+        fn lt(&self, other: & &'self str) -> bool { self.cmp(other) == Less }\n+        #[inline(always)]\n+        fn le(&self, other: & &'self str) -> bool { self.cmp(other) != Greater }\n+        #[inline(always)]\n+        fn ge(&self, other: & &'self str) -> bool { self.cmp(other) != Less }\n+        #[inline(always)]\n+        fn gt(&self, other: & &'self str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl Ord for ~str {\n+        #[inline(always)]\n+        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n+        #[inline(always)]\n+        fn le(&self, other: &~str) -> bool { self.cmp(other) != Greater }\n+        #[inline(always)]\n+        fn ge(&self, other: &~str) -> bool { self.cmp(other) != Less }\n+        #[inline(always)]\n+        fn gt(&self, other: &~str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl Ord for @str {\n+        #[inline(always)]\n+        fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n+        #[inline(always)]\n+        fn le(&self, other: &@str) -> bool { self.cmp(other) != Greater }\n+        #[inline(always)]\n+        fn ge(&self, other: &@str) -> bool { self.cmp(other) != Less }\n+        #[inline(always)]\n+        fn gt(&self, other: &@str) -> bool { self.cmp(other) == Greater }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for &'self str {\n+        #[inline(always)]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for @str {\n+        #[inline(always)]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n+\n+    impl<'self, S: Str> Equiv<S> for ~str {\n+        #[inline(always)]\n+        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+    }\n }\n \n #[cfg(test)]\n@@ -2267,10 +2229,10 @@ mod tests {\n \n     #[test]\n     fn test_le() {\n-        assert!((le(&\"\", &\"\")));\n-        assert!((le(&\"\", &\"foo\")));\n-        assert!((le(&\"foo\", &\"foo\")));\n-        assert!((!eq(&~\"foo\", &~\"bar\")));\n+        assert!(\"\" <= \"\");\n+        assert!(\"\" <= \"foo\");\n+        assert!(\"foo\" <= \"foo\");\n+        assert!(\"foo\" != ~\"bar\");\n     }\n \n     #[test]"}]}