{"sha": "0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "node_id": "C_kwDOAAsO6NoAKDA0MzYwNjcyMTBjYjEyZDA4Y2ZlMGUzYzA2YTE4YmJkNGVlNzY4ZDA", "commit": {"author": {"name": "Dan Vail", "email": "46790194+thedanvail@users.noreply.github.com", "date": "2022-08-09T17:52:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-09T17:52:11Z"}, "message": "Merge branch 'rust-lang:master' into issue-98861-fix", "tree": {"sha": "90b619d1e6c32615bd73c629696ab6e40e804373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90b619d1e6c32615bd73c629696ab6e40e804373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8p7LCRBK7hj4Ov3rIwAAPysIAGAu487k/dI/dmJ5cX/ah8x/\nN4EkAMZbMFtJeIjNpQdXWbjyu6ehGTOyEQM7qsC0ssi+FP1vVRPAiIxtp/RVZyUl\ngfxps/O9l44Hg2XWqmezA46tq7q7wHgYrd6g+afAxIWGVl3IupN1Ye0Icrv9rN2n\nvdMQ/baHpKyQkmrpzOi9XdzbMFiXwMxh2OlxBgBvyT+200a/LNfOL3jAgo4pQ7Nh\n+9r7SvSi1opqSzaySkjDrOH9+RZUQruSzSq8EFRn04cqdehyXSXSeiJcRztrjcWJ\nfY1Dj3RC8fsgeQ9qK5GPyw+8+dvd6Lu6FsYD0e/o/o4RlxiV2QDKzbFNpSoClO4=\n=pJif\n-----END PGP SIGNATURE-----\n", "payload": "tree 90b619d1e6c32615bd73c629696ab6e40e804373\nparent cc8259e4b6b1c8c390969ad24ce09ca502b55f69\nparent 6d3f1beae1720055e5a30f4dbe7a9e7fb810c65e\nauthor Dan Vail <46790194+thedanvail@users.noreply.github.com> 1660067531 -0500\ncommitter GitHub <noreply@github.com> 1660067531 -0500\n\nMerge branch 'rust-lang:master' into issue-98861-fix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "html_url": "https://github.com/rust-lang/rust/commit/0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/comments", "author": {"login": "thedanvail", "id": 46790194, "node_id": "MDQ6VXNlcjQ2NzkwMTk0", "avatar_url": "https://avatars.githubusercontent.com/u/46790194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thedanvail", "html_url": "https://github.com/thedanvail", "followers_url": "https://api.github.com/users/thedanvail/followers", "following_url": "https://api.github.com/users/thedanvail/following{/other_user}", "gists_url": "https://api.github.com/users/thedanvail/gists{/gist_id}", "starred_url": "https://api.github.com/users/thedanvail/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thedanvail/subscriptions", "organizations_url": "https://api.github.com/users/thedanvail/orgs", "repos_url": "https://api.github.com/users/thedanvail/repos", "events_url": "https://api.github.com/users/thedanvail/events{/privacy}", "received_events_url": "https://api.github.com/users/thedanvail/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc8259e4b6b1c8c390969ad24ce09ca502b55f69", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8259e4b6b1c8c390969ad24ce09ca502b55f69", "html_url": "https://github.com/rust-lang/rust/commit/cc8259e4b6b1c8c390969ad24ce09ca502b55f69"}, {"sha": "6d3f1beae1720055e5a30f4dbe7a9e7fb810c65e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3f1beae1720055e5a30f4dbe7a9e7fb810c65e", "html_url": "https://github.com/rust-lang/rust/commit/6d3f1beae1720055e5a30f4dbe7a9e7fb810c65e"}], "stats": {"total": 4088, "additions": 3118, "deletions": 970}, "files": [{"sha": "ededa7c2ecfb74c8be877bab297d29fdd522d512", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -4626,6 +4626,7 @@ dependencies = [\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_feature\",\n  \"rustc_graphviz\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\","}, {"sha": "97eee56f948076d3379c7439c4094a1824f0eaaa", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -417,6 +417,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 || attr.has_name(sym::stable)\n                 || attr.has_name(sym::rustc_const_unstable)\n                 || attr.has_name(sym::rustc_const_stable)\n+                || attr.has_name(sym::rustc_default_body_unstable)\n             {\n                 struct_span_err!(\n                     self.sess,"}, {"sha": "62ccd734fe7206a09e255a5358cb145d7ac6253e", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -131,6 +131,14 @@ impl ConstStability {\n     }\n }\n \n+/// Represents the `#[rustc_default_body_unstable]` attribute.\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(HashStable_Generic)]\n+pub struct DefaultBodyStability {\n+    pub level: StabilityLevel,\n+    pub feature: Symbol,\n+}\n+\n /// The available stability levels.\n #[derive(Encodable, Decodable, PartialEq, Copy, Clone, Debug, Eq, Hash)]\n #[derive(HashStable_Generic)]\n@@ -214,22 +222,24 @@ pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>) {\n+) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n+{\n     find_stability_generic(sess, attrs.iter(), item_sp)\n }\n \n fn find_stability_generic<'a, I>(\n     sess: &Session,\n     attrs_iter: I,\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>)\n+) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n where\n     I: Iterator<Item = &'a Attribute>,\n {\n     use StabilityLevel::*;\n \n     let mut stab: Option<(Stability, Span)> = None;\n     let mut const_stab: Option<(ConstStability, Span)> = None;\n+    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n     let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n@@ -243,6 +253,7 @@ where\n             sym::stable,\n             sym::rustc_promotable,\n             sym::rustc_allowed_through_unstable_modules,\n+            sym::rustc_default_body_unstable,\n         ]\n         .iter()\n         .any(|&s| attr.has_name(s))\n@@ -280,7 +291,7 @@ where\n \n             let meta_name = meta.name_or_empty();\n             match meta_name {\n-                sym::rustc_const_unstable | sym::unstable => {\n+                sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n                     if meta_name == sym::unstable && stab.is_some() {\n                         handle_errors(\n                             &sess.parse_sess,\n@@ -295,6 +306,13 @@ where\n                             AttrError::MultipleStabilityLevels,\n                         );\n                         break;\n+                    } else if meta_name == sym::rustc_default_body_unstable && body_stab.is_some() {\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n+                        break;\n                     }\n \n                     let mut feature = None;\n@@ -405,11 +423,16 @@ where\n                             };\n                             if sym::unstable == meta_name {\n                                 stab = Some((Stability { level, feature }, attr.span));\n-                            } else {\n+                            } else if sym::rustc_const_unstable == meta_name {\n                                 const_stab = Some((\n                                     ConstStability { level, feature, promotable: false },\n                                     attr.span,\n                                 ));\n+                            } else if sym::rustc_default_body_unstable == meta_name {\n+                                body_stab =\n+                                    Some((DefaultBodyStability { level, feature }, attr.span));\n+                            } else {\n+                                unreachable!(\"Unknown stability attribute {meta_name}\");\n                             }\n                         }\n                         (None, _, _) => {\n@@ -542,7 +565,7 @@ where\n         }\n     }\n \n-    (stab, const_stab)\n+    (stab, const_stab, body_stab)\n }\n \n pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {"}, {"sha": "75528d6140ce5da524076c5de688394326687cde", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -520,6 +520,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n+    ///\n+    /// You almost certainly want to use `get_ptr_alloc`/`get_ptr_alloc_mut` instead.\n     fn get_alloc_raw(\n         &self,\n         id: AllocId,\n@@ -589,6 +591,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(&self.get_alloc_raw(id)?.extra)\n     }\n \n+    /// Return the `mutability` field of the given allocation.\n+    pub fn get_alloc_mutability<'a>(&'a self, id: AllocId) -> InterpResult<'tcx, Mutability> {\n+        Ok(self.get_alloc_raw(id)?.mutability)\n+    }\n+\n     /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///"}, {"sha": "852ea806b20ff51c64139e3b5a2b293f7496b877", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -772,7 +772,7 @@ impl SyntaxExtension {\n                 )\n             })\n             .unwrap_or_else(|| (None, helper_attrs));\n-        let (stability, const_stability) = attr::find_stability(&sess, attrs, span);\n+        let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n             sess.parse_sess\n                 .span_diagnostic\n@@ -784,6 +784,17 @@ impl SyntaxExtension {\n                 )\n                 .emit();\n         }\n+        if let Some((_, sp)) = body_stability {\n+            sess.parse_sess\n+                .span_diagnostic\n+                .struct_span_err(sp, \"macros cannot have body stability attributes\")\n+                .span_label(sp, \"invalid body stability attribute\")\n+                .span_label(\n+                    sess.source_map().guess_head_span(span),\n+                    \"body stability attribute affects this macro\",\n+                )\n+                .emit();\n+        }\n \n         SyntaxExtension {\n             kind,"}, {"sha": "ee46a364546a92fa94cf3786bfc57698e94abddf", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -499,6 +499,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n     ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n+    ungated!(\n+        rustc_default_body_unstable, Normal,\n+        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk\n+    ),\n     gated!(\n         allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"), DuplicatesOk,\n         \"allow_internal_unstable side-steps feature gating and stability checks\","}, {"sha": "61f16be1d6b24016c21c851a9dad358bd69cb72f", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -207,6 +207,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     def_ident_span => { table }\n     lookup_stability => { table }\n     lookup_const_stability => { table }\n+    lookup_default_body_stability => { table }\n     lookup_deprecation_entry => { table }\n     visibility => { table }\n     unused_generic_params => { table }"}, {"sha": "f68005c0526350192a1d19c4a9e3d27c5df9ab3c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1029,6 +1029,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if should_encode_stability(def_kind) {\n                 self.encode_stability(def_id);\n                 self.encode_const_stability(def_id);\n+                self.encode_default_body_stability(def_id);\n                 self.encode_deprecation(def_id);\n             }\n             if should_encode_variances(def_kind) {\n@@ -1385,6 +1386,18 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn encode_default_body_stability(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_default_body_stability({:?})\", def_id);\n+\n+        // The query lookup can take a measurable amount of time in crates with many items. Check if\n+        // the stability attributes are even enabled before using their queries.\n+        if self.feat.staged_api || self.tcx.sess.opts.unstable_opts.force_unstable_if_unmarked {\n+            if let Some(stab) = self.tcx.lookup_default_body_stability(def_id) {\n+                record!(self.tables.lookup_default_body_stability[def_id] <- stab)\n+            }\n+        }\n+    }\n+\n     fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         if let Some(depr) = self.tcx.lookup_deprecation(def_id) {"}, {"sha": "8efe5051b01cb928031bcffde1ed85dfb2667508", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -343,6 +343,7 @@ define_tables! {\n     def_ident_span: Table<DefIndex, LazyValue<Span>>,\n     lookup_stability: Table<DefIndex, LazyValue<attr::Stability>>,\n     lookup_const_stability: Table<DefIndex, LazyValue<attr::ConstStability>>,\n+    lookup_default_body_stability: Table<DefIndex, LazyValue<attr::DefaultBodyStability>>,\n     lookup_deprecation_entry: Table<DefIndex, LazyValue<attr::Deprecation>>,\n     // As an optimization, a missing entry indicates an empty `&[]`.\n     explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,"}, {"sha": "7a9ad44d1d9ae86cec2b46303159c13950e95674", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -5,7 +5,7 @@ pub use self::StabilityLevel::*;\n \n use crate::ty::{self, DefIdTree, TyCtxt};\n use rustc_ast::NodeId;\n-use rustc_attr::{self as attr, ConstStability, Deprecation, Stability};\n+use rustc_attr::{self as attr, ConstStability, DefaultBodyStability, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_feature::GateIssue;\n@@ -61,6 +61,7 @@ pub struct Index {\n     /// are filled by the annotator.\n     pub stab_map: FxHashMap<LocalDefId, Stability>,\n     pub const_stab_map: FxHashMap<LocalDefId, ConstStability>,\n+    pub default_body_stab_map: FxHashMap<LocalDefId, DefaultBodyStability>,\n     pub depr_map: FxHashMap<LocalDefId, DeprecationEntry>,\n     /// Mapping from feature name to feature name based on the `implied_by` field of `#[unstable]`\n     /// attributes. If a `#[unstable(feature = \"implier\", implied_by = \"impliee\")]` attribute\n@@ -86,6 +87,10 @@ impl Index {\n         self.const_stab_map.get(&def_id).copied()\n     }\n \n+    pub fn local_default_body_stability(&self, def_id: LocalDefId) -> Option<DefaultBodyStability> {\n+        self.default_body_stab_map.get(&def_id).copied()\n+    }\n+\n     pub fn local_deprecation_entry(&self, def_id: LocalDefId) -> Option<DeprecationEntry> {\n         self.depr_map.get(&def_id).cloned()\n     }\n@@ -416,19 +421,19 @@ impl<'tcx> TyCtxt<'tcx> {\n             return EvalResult::Allow;\n         }\n \n+        // Only the cross-crate scenario matters when checking unstable APIs\n+        let cross_crate = !def_id.is_local();\n+        if !cross_crate {\n+            return EvalResult::Allow;\n+        }\n+\n         let stability = self.lookup_stability(def_id);\n         debug!(\n             \"stability: \\\n                 inspecting def_id={:?} span={:?} of stability={:?}\",\n             def_id, span, stability\n         );\n \n-        // Only the cross-crate scenario matters when checking unstable APIs\n-        let cross_crate = !def_id.is_local();\n-        if !cross_crate {\n-            return EvalResult::Allow;\n-        }\n-\n         // Issue #38412: private items lack stability markers.\n         if skip_stability_check_due_to_privacy(self, def_id) {\n             return EvalResult::Allow;\n@@ -492,6 +497,62 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Evaluates the default-impl stability of an item.\n+    ///\n+    /// Returns `EvalResult::Allow` if the item's default implementation is stable, or unstable but the corresponding\n+    /// `#![feature]` has been provided. Returns `EvalResult::Deny` which describes the offending\n+    /// unstable feature otherwise.\n+    pub fn eval_default_body_stability(self, def_id: DefId, span: Span) -> EvalResult {\n+        let is_staged_api = self.lookup_stability(def_id.krate.as_def_id()).is_some();\n+        if !is_staged_api {\n+            return EvalResult::Allow;\n+        }\n+\n+        // Only the cross-crate scenario matters when checking unstable APIs\n+        let cross_crate = !def_id.is_local();\n+        if !cross_crate {\n+            return EvalResult::Allow;\n+        }\n+\n+        let stability = self.lookup_default_body_stability(def_id);\n+        debug!(\n+            \"body stability: inspecting def_id={def_id:?} span={span:?} of stability={stability:?}\"\n+        );\n+\n+        // Issue #38412: private items lack stability markers.\n+        if skip_stability_check_due_to_privacy(self, def_id) {\n+            return EvalResult::Allow;\n+        }\n+\n+        match stability {\n+            Some(DefaultBodyStability {\n+                level: attr::Unstable { reason, issue, is_soft, .. },\n+                feature,\n+            }) => {\n+                if span.allows_unstable(feature) {\n+                    debug!(\"body stability: skipping span={:?} since it is internal\", span);\n+                    return EvalResult::Allow;\n+                }\n+                if self.features().active(feature) {\n+                    return EvalResult::Allow;\n+                }\n+\n+                EvalResult::Deny {\n+                    feature,\n+                    reason: reason.to_opt_reason(),\n+                    issue,\n+                    suggestion: None,\n+                    is_soft,\n+                }\n+            }\n+            Some(_) => {\n+                // Stable APIs are always ok to call\n+                EvalResult::Allow\n+            }\n+            None => EvalResult::Unmarked,\n+        }\n+    }\n+\n     /// Checks if an item is stable or error out.\n     ///\n     /// If the item defined by `def_id` is unstable and the corresponding `#![feature]` does not"}, {"sha": "4a85defb1ed84518d20c48c301375235c2ba93c8", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 92, "deletions": 63, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -80,6 +80,8 @@ macro_rules! make_mir_visitor {\n                 self.super_body(body);\n             }\n \n+            extra_body_methods!($($mutability)?);\n+\n             fn visit_basic_block_data(\n                 &mut self,\n                 block: BasicBlock,\n@@ -287,63 +289,7 @@ macro_rules! make_mir_visitor {\n                 &mut self,\n                 body: &$($mutability)? Body<'tcx>,\n             ) {\n-                let span = body.span;\n-                if let Some(gen) = &$($mutability)? body.generator {\n-                    if let Some(yield_ty) = $(& $mutability)? gen.yield_ty {\n-                        self.visit_ty(\n-                            yield_ty,\n-                            TyContext::YieldTy(SourceInfo::outermost(span))\n-                        );\n-                    }\n-                }\n-\n-                // for best performance, we want to use an iterator rather\n-                // than a for-loop, to avoid calling `body::Body::invalidate` for\n-                // each basic block.\n-                #[allow(unused_macro_rules)]\n-                macro_rules! basic_blocks {\n-                    (mut) => (body.basic_blocks_mut().iter_enumerated_mut());\n-                    () => (body.basic_blocks().iter_enumerated());\n-                }\n-                for (bb, data) in basic_blocks!($($mutability)?) {\n-                    self.visit_basic_block_data(bb, data);\n-                }\n-\n-                for scope in &$($mutability)? body.source_scopes {\n-                    self.visit_source_scope_data(scope);\n-                }\n-\n-                self.visit_ty(\n-                    $(& $mutability)? body.return_ty(),\n-                    TyContext::ReturnTy(SourceInfo::outermost(body.span))\n-                );\n-\n-                for local in body.local_decls.indices() {\n-                    self.visit_local_decl(local, & $($mutability)? body.local_decls[local]);\n-                }\n-\n-                #[allow(unused_macro_rules)]\n-                macro_rules! type_annotations {\n-                    (mut) => (body.user_type_annotations.iter_enumerated_mut());\n-                    () => (body.user_type_annotations.iter_enumerated());\n-                }\n-\n-                for (index, annotation) in type_annotations!($($mutability)?) {\n-                    self.visit_user_type_annotation(\n-                        index, annotation\n-                    );\n-                }\n-\n-                for var_debug_info in &$($mutability)? body.var_debug_info {\n-                    self.visit_var_debug_info(var_debug_info);\n-                }\n-\n-                self.visit_span($(& $mutability)? body.span);\n-\n-                for const_ in &$($mutability)? body.required_consts {\n-                    let location = START_BLOCK.start_location();\n-                    self.visit_constant(const_, location);\n-                }\n+                super_body!(self, body, $($mutability, true)?);\n             }\n \n             fn super_basic_block_data(&mut self,\n@@ -982,12 +928,7 @@ macro_rules! make_mir_visitor {\n                 body: &$($mutability)? Body<'tcx>,\n                 location: Location\n             ) {\n-                #[allow(unused_macro_rules)]\n-                macro_rules! basic_blocks {\n-                    (mut) => (body.basic_blocks_mut());\n-                    () => (body.basic_blocks());\n-                }\n-                let basic_block = & $($mutability)? basic_blocks!($($mutability)?)[location.block];\n+                let basic_block = & $($mutability)? basic_blocks!(body, $($mutability, true)?)[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(terminator, location)\n@@ -1002,6 +943,94 @@ macro_rules! make_mir_visitor {\n     }\n }\n \n+macro_rules! basic_blocks {\n+    ($body:ident, mut, true) => {\n+        $body.basic_blocks.as_mut()\n+    };\n+    ($body:ident, mut, false) => {\n+        $body.basic_blocks.as_mut_preserves_cfg()\n+    };\n+    ($body:ident,) => {\n+        $body.basic_blocks()\n+    };\n+}\n+\n+macro_rules! basic_blocks_iter {\n+    ($body:ident, mut, $invalidate:tt) => {\n+        basic_blocks!($body, mut, $invalidate).iter_enumerated_mut()\n+    };\n+    ($body:ident,) => {\n+        basic_blocks!($body,).iter_enumerated()\n+    };\n+}\n+\n+macro_rules! extra_body_methods {\n+    (mut) => {\n+        fn visit_body_preserves_cfg(&mut self, body: &mut Body<'tcx>) {\n+            self.super_body_preserves_cfg(body);\n+        }\n+\n+        fn super_body_preserves_cfg(&mut self, body: &mut Body<'tcx>) {\n+            super_body!(self, body, mut, false);\n+        }\n+    };\n+    () => {};\n+}\n+\n+macro_rules! super_body {\n+    ($self:ident, $body:ident, $($mutability:ident, $invalidate:tt)?) => {\n+        let span = $body.span;\n+        if let Some(gen) = &$($mutability)? $body.generator {\n+            if let Some(yield_ty) = $(& $mutability)? gen.yield_ty {\n+                $self.visit_ty(\n+                    yield_ty,\n+                    TyContext::YieldTy(SourceInfo::outermost(span))\n+                );\n+            }\n+        }\n+\n+        for (bb, data) in basic_blocks_iter!($body, $($mutability, $invalidate)?) {\n+            $self.visit_basic_block_data(bb, data);\n+        }\n+\n+        for scope in &$($mutability)? $body.source_scopes {\n+            $self.visit_source_scope_data(scope);\n+        }\n+\n+        $self.visit_ty(\n+            $(& $mutability)? $body.return_ty(),\n+            TyContext::ReturnTy(SourceInfo::outermost($body.span))\n+        );\n+\n+        for local in $body.local_decls.indices() {\n+            $self.visit_local_decl(local, & $($mutability)? $body.local_decls[local]);\n+        }\n+\n+        #[allow(unused_macro_rules)]\n+        macro_rules! type_annotations {\n+            (mut) => ($body.user_type_annotations.iter_enumerated_mut());\n+            () => ($body.user_type_annotations.iter_enumerated());\n+        }\n+\n+        for (index, annotation) in type_annotations!($($mutability)?) {\n+            $self.visit_user_type_annotation(\n+                index, annotation\n+            );\n+        }\n+\n+        for var_debug_info in &$($mutability)? $body.var_debug_info {\n+            $self.visit_var_debug_info(var_debug_info);\n+        }\n+\n+        $self.visit_span($(& $mutability)? $body.span);\n+\n+        for const_ in &$($mutability)? $body.required_consts {\n+            let location = START_BLOCK.start_location();\n+            $self.visit_constant(const_, location);\n+        }\n+    }\n+}\n+\n macro_rules! visit_place_fns {\n     (mut) => {\n         fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;"}, {"sha": "cfc75f673c8f5bb047a051662ef550d5b52edf0c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1094,6 +1094,11 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query lookup_default_body_stability(def_id: DefId) -> Option<attr::DefaultBodyStability> {\n+        desc { |tcx| \"looking up default body stability of `{}`\", tcx.def_path_str(def_id) }\n+        separate_provide_extern\n+    }\n+\n     query should_inherit_track_caller(def_id: DefId) -> bool {\n         desc { |tcx| \"computing should_inherit_track_caller of `{}`\", tcx.def_path_str(def_id) }\n     }\n@@ -1951,6 +1956,14 @@ rustc_queries! {\n         }\n     }\n \n+    query is_impossible_method(key: (DefId, DefId)) -> bool {\n+        desc { |tcx|\n+            \"checking if {} is impossible to call within {}\",\n+            tcx.def_path_str(key.1),\n+            tcx.def_path_str(key.0),\n+        }\n+    }\n+\n     query method_autoderef_steps(\n         goal: CanonicalTyGoal<'tcx>\n     ) -> MethodAutoderefStepsResult<'tcx> {"}, {"sha": "ae6e2eecbffb5f46516c54904a487f75c2d8ca9b", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -64,6 +64,7 @@ trivially_parameterized_over_tcx! {\n     rustc_ast::Attribute,\n     rustc_ast::MacArgs,\n     rustc_attr::ConstStability,\n+    rustc_attr::DefaultBodyStability,\n     rustc_attr::Deprecation,\n     rustc_attr::Stability,\n     rustc_hir::Constness,"}, {"sha": "69a8c98b27a3d76b72ef1c8e5bfb647b923c0279", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -849,22 +849,22 @@ fn non_exhaustive_match<'p, 'tcx>(\n             ));\n         }\n         [.., prev, last] if prev.span.eq_ctxt(last.span) => {\n-            if let Ok(snippet) = sm.span_to_snippet(prev.span.between(last.span)) {\n-                let comma = if matches!(last.body.kind, hir::ExprKind::Block(..))\n-                    && last.span.eq_ctxt(last.body.span)\n-                {\n-                    \"\"\n-                } else {\n-                    \",\"\n-                };\n+            let comma = if matches!(last.body.kind, hir::ExprKind::Block(..))\n+                && last.span.eq_ctxt(last.body.span)\n+            {\n+                \"\"\n+            } else {\n+                \",\"\n+            };\n+            let spacing = if sm.is_multiline(prev.span.between(last.span)) {\n+                sm.indentation_before(last.span).map(|indent| format!(\"\\n{indent}\"))\n+            } else {\n+                Some(\" \".to_string())\n+            };\n+            if let Some(spacing) = spacing {\n                 suggestion = Some((\n                     last.span.shrink_to_hi(),\n-                    format!(\n-                        \"{}{}{} => todo!()\",\n-                        comma,\n-                        snippet.strip_prefix(',').unwrap_or(&snippet),\n-                        pattern\n-                    ),\n+                    format!(\"{}{}{} => todo!()\", comma, spacing, pattern),\n                 ));\n             }\n         }"}, {"sha": "3378923c22c367c1a9396ab54e07d0ba3279e282", "filename": "compiler/rustc_mir_transform/src/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcleanup_post_borrowck.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -33,7 +33,7 @@ pub struct DeleteNonCodegenStatements<'tcx> {\n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements { tcx };\n-        delete.visit_body(body);\n+        delete.visit_body_preserves_cfg(body);\n         body.user_type_annotations.raw.clear();\n \n         for decl in &mut body.local_decls {"}, {"sha": "98016659a05f7bc268938bbfc0d7a66fc98ed218", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -951,7 +951,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     }\n \n     fn visit_body(&mut self, body: &mut Body<'tcx>) {\n-        for (bb, data) in body.basic_blocks_mut().iter_enumerated_mut() {\n+        for (bb, data) in body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut() {\n             self.visit_basic_block_data(bb, data);\n         }\n     }"}, {"sha": "87d7b664015a9cc939309be93584b7a2af9dcd8e", "filename": "compiler/rustc_mir_transform/src/deref_separator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fderef_separator.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -90,7 +90,7 @@ pub fn deref_finder<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let patch = MirPatch::new(body);\n     let mut checker = DerefChecker { tcx, patcher: patch, local_decls: body.local_decls.clone() };\n \n-    for (bb, data) in body.basic_blocks_mut().iter_enumerated_mut() {\n+    for (bb, data) in body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut() {\n         checker.visit_basic_block_data(bb, data);\n     }\n "}, {"sha": "76b4cdd2ecd3cce3f20e628d6e4fce10d185ff24", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n                 ElaborateBoxDerefVisitor { tcx, unique_did, nonnull_did, local_decls, patch };\n \n             for (block, BasicBlockData { statements, terminator, .. }) in\n-                body.basic_blocks.as_mut().iter_enumerated_mut()\n+                body.basic_blocks.as_mut_preserves_cfg().iter_enumerated_mut()\n             {\n                 let mut index = 0;\n                 for statement in statements {"}, {"sha": "42d732730ecccf0b38966919a1b7e16dd6512d20", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -53,10 +53,10 @@ impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n             def_id, returned_local\n         );\n \n-        RenameToReturnPlace { tcx, to_rename: returned_local }.visit_body(body);\n+        RenameToReturnPlace { tcx, to_rename: returned_local }.visit_body_preserves_cfg(body);\n \n         // Clean up the `NOP`s we inserted for statements made useless by our renaming.\n-        for block_data in body.basic_blocks_mut() {\n+        for block_data in body.basic_blocks.as_mut_preserves_cfg() {\n             block_data.statements.retain(|stmt| stmt.kind != mir::StatementKind::Nop);\n         }\n "}, {"sha": "abe6cb285f50591be8776c03c25319eada650ead", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -19,7 +19,7 @@ impl<'tcx> MirPass<'tcx> for RevealAll {\n         }\n \n         let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n-        RevealAllVisitor { tcx, param_env }.visit_body(body);\n+        RevealAllVisitor { tcx, param_env }.visit_body_preserves_cfg(body);\n     }\n }\n "}, {"sha": "7a6ca917d0ffd5ca2aac703c6fd31a56967d6320", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -412,7 +412,7 @@ pub fn simplify_locals<'tcx>(body: &mut Body<'tcx>, tcx: TyCtxt<'tcx>) {\n     if map.iter().any(Option::is_none) {\n         // Update references to all vars and tmps now\n         let mut updater = LocalUpdater { map, tcx };\n-        updater.visit_body(body);\n+        updater.visit_body_preserves_cfg(body);\n \n         body.local_decls.shrink_to_fit();\n     }\n@@ -548,7 +548,7 @@ fn remove_unused_definitions(used_locals: &mut UsedLocals, body: &mut Body<'_>)\n     while modified {\n         modified = false;\n \n-        for data in body.basic_blocks_mut() {\n+        for data in body.basic_blocks.as_mut_preserves_cfg() {\n             // Remove unnecessary StorageLive and StorageDead annotations.\n             data.statements.retain(|statement| {\n                 let keep = match &statement.kind {"}, {"sha": "868887c66cdec7a95e1bc723a460718c5d365c0d", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -29,11 +29,16 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n     }\n \n     fn extract(&self, attr: &Attribute) -> Option<(Symbol, Option<Symbol>, Span)> {\n-        let stab_attrs =\n-            [sym::stable, sym::unstable, sym::rustc_const_stable, sym::rustc_const_unstable];\n+        let stab_attrs = [\n+            sym::stable,\n+            sym::unstable,\n+            sym::rustc_const_stable,\n+            sym::rustc_const_unstable,\n+            sym::rustc_default_body_unstable,\n+        ];\n \n         // Find a stability attribute: one of #[stable(\u2026)], #[unstable(\u2026)],\n-        // #[rustc_const_stable(\u2026)], or #[rustc_const_unstable(\u2026)].\n+        // #[rustc_const_stable(\u2026)], #[rustc_const_unstable(\u2026)] or #[rustc_default_body_unstable].\n         if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.has_name(**stab_attr)) {\n             let meta_kind = attr.meta_kind();\n             if let Some(MetaItemKind::List(ref metas)) = meta_kind {\n@@ -53,8 +58,12 @@ impl<'tcx> LibFeatureCollector<'tcx> {\n                     // This additional check for stability is to make sure we\n                     // don't emit additional, irrelevant errors for malformed\n                     // attributes.\n-                    let is_unstable =\n-                        matches!(*stab_attr, sym::unstable | sym::rustc_const_unstable);\n+                    let is_unstable = matches!(\n+                        *stab_attr,\n+                        sym::unstable\n+                            | sym::rustc_const_unstable\n+                            | sym::rustc_default_body_unstable\n+                    );\n                     if since.is_some() || is_unstable {\n                         return Some((feature, since, attr.span));\n                     }"}, {"sha": "296b6ed5d99a69b5e5153a134d578d9218f12a47", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,83 +1,71 @@\n //! Checks validity of naked functions.\n \n-use rustc_ast::{Attribute, InlineAsmOptions};\n+use rustc_ast::InlineAsmOptions;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n-use rustc_hir::{ExprKind, HirId, InlineAsmOperand, StmtKind};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{ExprKind, InlineAsmOperand, StmtKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::UNDEFINED_NAKED_FUNCTION_ABI;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n-fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckNakedFunctions { tcx });\n-}\n-\n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n \n-struct CheckNakedFunctions<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for CheckNakedFunctions<'tcx> {\n-    fn visit_fn(\n-        &mut self,\n-        fk: FnKind<'_>,\n-        _fd: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        span: Span,\n-        hir_id: HirId,\n-    ) {\n-        let ident_span;\n-        let fn_header;\n-\n-        match fk {\n-            FnKind::Closure => {\n-                // Closures with a naked attribute are rejected during attribute\n-                // check. Don't validate them any further.\n-                return;\n-            }\n-            FnKind::ItemFn(ident, _, ref header, ..) => {\n-                ident_span = ident.span;\n-                fn_header = header;\n-            }\n-\n-            FnKind::Method(ident, ref sig, ..) => {\n-                ident_span = ident.span;\n-                fn_header = &sig.header;\n-            }\n+fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n+    let items = tcx.hir_module_items(module_def_id);\n+    for def_id in items.definitions() {\n+        if !matches!(tcx.def_kind(def_id), DefKind::Fn | DefKind::AssocFn) {\n+            continue;\n         }\n \n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        let naked = attrs.iter().any(|attr| attr.has_name(sym::naked));\n-        if naked {\n-            let body = self.tcx.hir().body(body_id);\n-            check_abi(self.tcx, hir_id, fn_header.abi, ident_span);\n-            check_no_patterns(self.tcx, body.params);\n-            check_no_parameters_use(self.tcx, body);\n-            check_asm(self.tcx, body, span);\n-            check_inline(self.tcx, attrs);\n+        let naked = tcx.has_attr(def_id.to_def_id(), sym::naked);\n+        if !naked {\n+            continue;\n         }\n+\n+        let (fn_header, body_id) = match tcx.hir().get_by_def_id(def_id) {\n+            hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. })\n+            | hir::Node::TraitItem(hir::TraitItem {\n+                kind: hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)),\n+                ..\n+            })\n+            | hir::Node::ImplItem(hir::ImplItem {\n+                kind: hir::ImplItemKind::Fn(sig, body_id),\n+                ..\n+            }) => (sig.header, *body_id),\n+            _ => continue,\n+        };\n+\n+        let body = tcx.hir().body(body_id);\n+        check_abi(tcx, def_id, fn_header.abi);\n+        check_no_patterns(tcx, body.params);\n+        check_no_parameters_use(tcx, body);\n+        check_asm(tcx, def_id, body);\n+        check_inline(tcx, def_id);\n     }\n }\n \n /// Check that the function isn't inlined.\n-fn check_inline(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n-    for attr in attrs.iter().filter(|attr| attr.has_name(sym::inline)) {\n+fn check_inline(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let attrs = tcx.get_attrs(def_id.to_def_id(), sym::inline);\n+    for attr in attrs {\n         tcx.sess.struct_span_err(attr.span, \"naked functions cannot be inlined\").emit();\n     }\n }\n \n /// Checks that function uses non-Rust ABI.\n-fn check_abi(tcx: TyCtxt<'_>, hir_id: HirId, abi: Abi, fn_ident_span: Span) {\n+fn check_abi(tcx: TyCtxt<'_>, def_id: LocalDefId, abi: Abi) {\n     if abi == Abi::Rust {\n-        tcx.struct_span_lint_hir(UNDEFINED_NAKED_FUNCTION_ABI, hir_id, fn_ident_span, |lint| {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let span = tcx.def_span(def_id);\n+        tcx.struct_span_lint_hir(UNDEFINED_NAKED_FUNCTION_ABI, hir_id, span, |lint| {\n             lint.build(\"Rust ABI is unsupported in naked functions\").emit();\n         });\n     }\n@@ -141,15 +129,15 @@ impl<'tcx> Visitor<'tcx> for CheckParameters<'tcx> {\n }\n \n /// Checks that function body contains a single inline assembly block.\n-fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, body: &'tcx hir::Body<'tcx>, fn_span: Span) {\n+fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<'tcx>) {\n     let mut this = CheckInlineAssembly { tcx, items: Vec::new() };\n     this.visit_body(body);\n     if let [(ItemKind::Asm | ItemKind::Err, _)] = this.items[..] {\n         // Ok.\n     } else {\n         let mut diag = struct_span_err!(\n             tcx.sess,\n-            fn_span,\n+            tcx.def_span(def_id),\n             E0787,\n             \"naked functions must contain a single asm block\"\n         );"}, {"sha": "be920601ee43f2c19d6b9cd43731a6ae4ec0c098", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,8 +1,9 @@\n //! A pass that annotates every item and method with its stability level,\n //! propagating default levels lexically from parent to children ast nodes.\n \n-use attr::StabilityLevel;\n-use rustc_attr::{self as attr, ConstStability, Stability, Unstable, UnstableReason};\n+use rustc_attr::{\n+    self as attr, ConstStability, Stability, StabilityLevel, Unstable, UnstableReason,\n+};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n@@ -161,7 +162,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let (stab, const_stab, body_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n         let mut const_span = None;\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n@@ -209,6 +210,13 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n         }\n \n+        if let Some((body_stab, _span)) = body_stab {\n+            // FIXME: check that this item can have body stability\n+\n+            self.index.default_body_stab_map.insert(def_id, body_stab);\n+            debug!(?self.index.default_body_stab_map);\n+        }\n+\n         let stab = stab.map(|(stab, span)| {\n             // Error if prohibited, or can't inherit anything from a container.\n             if kind == AnnotationKind::Prohibited\n@@ -613,6 +621,7 @@ fn stability_index(tcx: TyCtxt<'_>, (): ()) -> Index {\n     let mut index = Index {\n         stab_map: Default::default(),\n         const_stab_map: Default::default(),\n+        default_body_stab_map: Default::default(),\n         depr_map: Default::default(),\n         implications: Default::default(),\n     };\n@@ -673,6 +682,9 @@ pub(crate) fn provide(providers: &mut Providers) {\n         stability_implications: |tcx, _| tcx.stability().implications.clone(),\n         lookup_stability: |tcx, id| tcx.stability().local_stability(id.expect_local()),\n         lookup_const_stability: |tcx, id| tcx.stability().local_const_stability(id.expect_local()),\n+        lookup_default_body_stability: |tcx, id| {\n+            tcx.stability().local_default_body_stability(id.expect_local())\n+        },\n         lookup_deprecation_entry: |tcx, id| {\n             tcx.stability().local_deprecation_entry(id.expect_local())\n         },\n@@ -723,7 +735,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 let features = self.tcx.features();\n                 if features.staged_api {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n-                    let (stab, const_stab) = attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let (stab, const_stab, _) =\n+                        attr::find_stability(&self.tcx.sess, attrs, item.span);\n \n                     // If this impl block has an #[unstable] attribute, give an\n                     // error if all involved types and traits are stable, because"}, {"sha": "325b0458638af1712904cc1e05edaf0c2259bfc4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -2544,12 +2544,15 @@ fn show_candidates(\n                 Applicability::MaybeIncorrect,\n             );\n             if let [first, .., last] = &path[..] {\n-                err.span_suggestion_verbose(\n-                    first.ident.span.until(last.ident.span),\n-                    &format!(\"if you import `{}`, refer to it directly\", last.ident),\n-                    \"\",\n-                    Applicability::Unspecified,\n-                );\n+                let sp = first.ident.span.until(last.ident.span);\n+                if sp.can_be_used_for_suggestions() {\n+                    err.span_suggestion_verbose(\n+                        sp,\n+                        &format!(\"if you import `{}`, refer to it directly\", last.ident),\n+                        \"\",\n+                        Applicability::Unspecified,\n+                    );\n+                }\n             }\n         } else {\n             msg.push(':');"}, {"sha": "2f3519e3edd778b88cb08f09c14c18158bfe7f52", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1218,6 +1218,7 @@ symbols! {\n         rustc_conversion_suggestion,\n         rustc_deallocator,\n         rustc_def_path,\n+        rustc_default_body_unstable,\n         rustc_diagnostic_item,\n         rustc_diagnostic_macros,\n         rustc_dirty,"}, {"sha": "e4f918b4b0eaebce14bb850d5da16da1115b5fde", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1315,6 +1315,13 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n         error: &MismatchedProjectionTypes<'tcx>,\n     );\n \n+    fn maybe_detailed_projection_msg(\n+        &self,\n+        pred: ty::ProjectionPredicate<'tcx>,\n+        normalized_ty: ty::Term<'tcx>,\n+        expected_ty: ty::Term<'tcx>,\n+    ) -> Option<String>;\n+\n     fn fuzzy_match_tys(\n         &self,\n         a: Ty<'tcx>,\n@@ -1542,23 +1549,19 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     normalized_ty,\n                     data.term,\n                 ) {\n-                    values = Some(infer::ValuePairs::Terms(ExpectedFound::new(\n-                        is_normalized_ty_expected,\n-                        normalized_ty,\n-                        data.term,\n-                    )));\n+                    values = Some((data, is_normalized_ty_expected, normalized_ty, data.term));\n                     err_buf = error;\n                     err = &err_buf;\n                 }\n             }\n \n-            let mut diag = struct_span_err!(\n-                self.tcx.sess,\n-                obligation.cause.span,\n-                E0271,\n-                \"type mismatch resolving `{}`\",\n-                predicate\n-            );\n+            let msg = values\n+                .and_then(|(predicate, _, normalized_ty, expected_ty)| {\n+                    self.maybe_detailed_projection_msg(predicate, normalized_ty, expected_ty)\n+                })\n+                .unwrap_or_else(|| format!(\"type mismatch resolving `{}`\", predicate));\n+            let mut diag = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271, \"{msg}\");\n+\n             let secondary_span = match predicate.kind().skip_binder() {\n                 ty::PredicateKind::Projection(proj) => self\n                     .tcx\n@@ -1596,7 +1599,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 &mut diag,\n                 &obligation.cause,\n                 secondary_span,\n-                values,\n+                values.map(|(_, is_normalized_ty_expected, normalized_ty, term)| {\n+                    infer::ValuePairs::Terms(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        term,\n+                    ))\n+                }),\n                 err,\n                 true,\n                 false,\n@@ -1606,6 +1615,33 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         });\n     }\n \n+    fn maybe_detailed_projection_msg(\n+        &self,\n+        pred: ty::ProjectionPredicate<'tcx>,\n+        normalized_ty: ty::Term<'tcx>,\n+        expected_ty: ty::Term<'tcx>,\n+    ) -> Option<String> {\n+        let trait_def_id = pred.projection_ty.trait_def_id(self.tcx);\n+        let self_ty = pred.projection_ty.self_ty();\n+\n+        if Some(pred.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output() {\n+            Some(format!(\n+                \"expected `{self_ty}` to be a {fn_kind} that returns `{expected_ty}`, but it returns `{normalized_ty}`\",\n+                fn_kind = self_ty.prefix_string(self.tcx)\n+            ))\n+        } else if Some(trait_def_id) == self.tcx.lang_items().future_trait() {\n+            Some(format!(\n+                \"expected `{self_ty}` to be a future that resolves to `{expected_ty}`, but it resolves to `{normalized_ty}`\"\n+            ))\n+        } else if Some(trait_def_id) == self.tcx.get_diagnostic_item(sym::Iterator) {\n+            Some(format!(\n+                \"expected `{self_ty}` to be an iterator that yields `{expected_ty}`, but it yields `{normalized_ty}`\"\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn fuzzy_match_tys(\n         &self,\n         mut a: Ty<'tcx>,"}, {"sha": "b6d6df1eec6a12a56d3bd570f4a61eb04a25793d", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -34,7 +34,10 @@ use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n+use rustc_middle::ty::{\n+    self, DefIdTree, GenericParamDefKind, Subst, ToPredicate, Ty, TyCtxt, TypeSuperVisitable,\n+    VtblEntry,\n+};\n use rustc_span::{sym, Span};\n use smallvec::SmallVec;\n \n@@ -503,6 +506,77 @@ fn subst_and_check_impossible_predicates<'tcx>(\n     result\n }\n \n+/// Checks whether a trait's method is impossible to call on a given impl.\n+///\n+/// This only considers predicates that reference the impl's generics, and not\n+/// those that reference the method's generics.\n+fn is_impossible_method<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (impl_def_id, trait_item_def_id): (DefId, DefId),\n+) -> bool {\n+    struct ReferencesOnlyParentGenerics<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        generics: &'tcx ty::Generics,\n+        trait_item_def_id: DefId,\n+    }\n+    impl<'tcx> ty::TypeVisitor<'tcx> for ReferencesOnlyParentGenerics<'tcx> {\n+        type BreakTy = ();\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            // If this is a parameter from the trait item's own generics, then bail\n+            if let ty::Param(param) = t.kind()\n+                && let param_def_id = self.generics.type_param(param, self.tcx).def_id\n+                && self.tcx.parent(param_def_id) == self.trait_item_def_id\n+            {\n+                return ControlFlow::BREAK;\n+            }\n+            t.super_visit_with(self)\n+        }\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::ReEarlyBound(param) = r.kind()\n+                && let param_def_id = self.generics.region_param(&param, self.tcx).def_id\n+                && self.tcx.parent(param_def_id) == self.trait_item_def_id\n+            {\n+                return ControlFlow::BREAK;\n+            }\n+            r.super_visit_with(self)\n+        }\n+        fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::ConstKind::Param(param) = ct.kind()\n+                && let param_def_id = self.generics.const_param(&param, self.tcx).def_id\n+                && self.tcx.parent(param_def_id) == self.trait_item_def_id\n+            {\n+                return ControlFlow::BREAK;\n+            }\n+            ct.super_visit_with(self)\n+        }\n+    }\n+\n+    let generics = tcx.generics_of(trait_item_def_id);\n+    let predicates = tcx.predicates_of(trait_item_def_id);\n+    let impl_trait_ref =\n+        tcx.impl_trait_ref(impl_def_id).expect(\"expected impl to correspond to trait\");\n+    let param_env = tcx.param_env(impl_def_id);\n+\n+    let mut visitor = ReferencesOnlyParentGenerics { tcx, generics, trait_item_def_id };\n+    let predicates_for_trait = predicates.predicates.iter().filter_map(|(pred, span)| {\n+        if pred.visit_with(&mut visitor).is_continue() {\n+            Some(Obligation::new(\n+                ObligationCause::dummy_with_span(*span),\n+                param_env,\n+                ty::EarlyBinder(*pred).subst(tcx, impl_trait_ref.substs),\n+            ))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    tcx.infer_ctxt().ignoring_regions().enter(|ref infcx| {\n+        let mut fulfill_ctxt = <dyn TraitEngine<'_>>::new(tcx);\n+        fulfill_ctxt.register_predicate_obligations(infcx, predicates_for_trait);\n+        !fulfill_ctxt.select_all_or_error(infcx).is_empty()\n+    })\n+}\n+\n #[derive(Clone, Debug)]\n enum VtblSegment<'tcx> {\n     MetadataDSA,\n@@ -883,6 +957,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n+        is_impossible_method,\n         try_unify_abstract_consts: |tcx, param_env_and| {\n             let (param_env, (a, b)) = param_env_and.into_parts();\n             const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)"}, {"sha": "cae29c1d3c5f938a2b103d103a962c2b790d77ca", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -30,3 +30,4 @@ rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n+rustc_feature = { path = \"../rustc_feature\" }"}, {"sha": "6e3ef15f88433ebf4e6f83c35fb67b27aafc3f36", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 117, "deletions": 68, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -18,6 +18,7 @@ use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n@@ -32,7 +33,6 @@ use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n use rustc_ty_utils::representability::{self, Representability};\n \n-use std::iter;\n use std::ops::ControlFlow;\n \n pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Abi) {\n@@ -1104,12 +1104,28 @@ fn check_impl_items_against_trait<'tcx>(\n                 missing_items.push(tcx.associated_item(trait_item_id));\n             }\n \n-            if let Some(required_items) = &must_implement_one_of {\n-                // true if this item is specifically implemented in this impl\n-                let is_implemented_here = ancestors\n-                    .leaf_def(tcx, trait_item_id)\n-                    .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n+            // true if this item is specifically implemented in this impl\n+            let is_implemented_here = ancestors\n+                .leaf_def(tcx, trait_item_id)\n+                .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n+\n+            if !is_implemented_here {\n+                match tcx.eval_default_body_stability(trait_item_id, full_impl_span) {\n+                    EvalResult::Deny { feature, reason, issue, .. } => default_body_is_unstable(\n+                        tcx,\n+                        full_impl_span,\n+                        trait_item_id,\n+                        feature,\n+                        reason,\n+                        issue,\n+                    ),\n \n+                    // Unmarked default bodies are considered stable (at least for now).\n+                    EvalResult::Allow | EvalResult::Unmarked => {}\n+                }\n+            }\n+\n+            if let Some(required_items) = &must_implement_one_of {\n                 if is_implemented_here {\n                     let trait_item = tcx.associated_item(trait_item_id);\n                     if required_items.contains(&trait_item.ident(tcx)) {\n@@ -1494,76 +1510,109 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n         }\n     }\n \n-    let mut disr_vals: Vec<Discr<'tcx>> = Vec::with_capacity(vs.len());\n-    // This tracks the previous variant span (in the loop) incase we need it for diagnostics\n-    let mut prev_variant_span: Span = DUMMY_SP;\n-    for ((_, discr), v) in iter::zip(def.discriminants(tcx), vs) {\n-        // Check for duplicate discriminant values\n-        if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_did = def.variant(VariantIdx::new(i)).def_id;\n-            let variant_i_hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.expect_local());\n-            let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n-            let i_span = match variant_i.disr_expr {\n-                Some(ref expr) => tcx.hir().span(expr.hir_id),\n-                None => tcx.def_span(variant_did),\n-            };\n-            let span = match v.disr_expr {\n-                Some(ref expr) => tcx.hir().span(expr.hir_id),\n-                None => v.span,\n-            };\n-            let display_discr = format_discriminant_overflow(tcx, v, discr);\n-            let display_discr_i = format_discriminant_overflow(tcx, variant_i, disr_vals[i]);\n-            let no_disr = v.disr_expr.is_none();\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                sp,\n-                E0081,\n-                \"discriminant value `{}` assigned more than once\",\n-                discr,\n-            );\n-\n-            err.span_label(i_span, format!(\"first assignment of {display_discr_i}\"));\n-            err.span_label(span, format!(\"second assignment of {display_discr}\"));\n-\n-            if no_disr {\n-                err.span_label(\n-                    prev_variant_span,\n-                    format!(\n-                        \"assigned discriminant for `{}` was incremented from this discriminant\",\n-                        v.ident\n-                    ),\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        disr_vals.push(discr);\n-        prev_variant_span = v.span;\n-    }\n+    detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n \n     check_representable(tcx, sp, def_id);\n     check_transparent(tcx, sp, def);\n }\n \n-/// In the case that a discriminant is both a duplicate and an overflowing literal,\n-/// we insert both the assigned discriminant and the literal it overflowed from into the formatted\n-/// output. Otherwise we format the discriminant normally.\n-fn format_discriminant_overflow<'tcx>(\n+/// Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal\n+fn detect_discriminant_duplicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    variant: &hir::Variant<'_>,\n-    dis: Discr<'tcx>,\n-) -> String {\n-    if let Some(expr) = &variant.disr_expr {\n-        let body = &tcx.hir().body(expr.body).value;\n-        if let hir::ExprKind::Lit(lit) = &body.kind\n-            && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n-            && dis.val != *lit_value\n-        {\n-                    return format!(\"`{dis}` (overflowed from `{lit_value}`)\");\n+    mut discrs: Vec<(VariantIdx, Discr<'tcx>)>,\n+    vs: &'tcx [hir::Variant<'tcx>],\n+    self_span: Span,\n+) {\n+    // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n+    // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n+    let report = |dis: Discr<'tcx>,\n+                  idx: usize,\n+                  err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>| {\n+        let var = &vs[idx]; // HIR for the duplicate discriminant\n+        let (span, display_discr) = match var.disr_expr {\n+            Some(ref expr) => {\n+                // In the case the discriminant is both a duplicate and overflowed, let the user know\n+                if let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n+                    && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n+                    && *lit_value != dis.val\n+                {\n+                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n+                // Otherwise, format the value as-is\n+                } else {\n+                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}`\"))\n+                }\n+            }\n+            None => {\n+                // At this point we know this discriminant is a duplicate, and was not explicitly\n+                // assigned by the user. Here we iterate backwards to fetch the HIR for the last\n+                // explictly assigned discriminant, and letting the user know that this was the\n+                // increment startpoint, and how many steps from there leading to the duplicate\n+                if let Some((n, hir::Variant { span, ident, .. })) =\n+                    vs[..idx].iter().rev().enumerate().find(|v| v.1.disr_expr.is_some())\n+                {\n+                    let ve_ident = var.ident;\n+                    let n = n + 1;\n+                    let sp = if n > 1 { \"variants\" } else { \"variant\" };\n+\n+                    err.span_label(\n+                        *span,\n+                        format!(\"discriminant for `{ve_ident}` incremented from this startpoint (`{ident}` + {n} {sp} later => `{ve_ident}` = {dis})\"),\n+                    );\n+                }\n+\n+                (vs[idx].span, format!(\"`{dis}`\"))\n+            }\n+        };\n+\n+        err.span_label(span, format!(\"{display_discr} assigned here\"));\n+    };\n+\n+    // Here we loop through the discriminants, comparing each discriminant to another.\n+    // When a duplicate is detected, we instatiate an error and point to both\n+    // initial and duplicate value. The duplicate discriminant is then discarded by swapping\n+    // it with the last element and decrementing the `vec.len` (which is why we have to evaluate\n+    // `discrs.len()` anew every iteration, and why this could be tricky to do in a functional\n+    // style as we are mutating `discrs` on the fly).\n+    let mut i = 0;\n+    while i < discrs.len() {\n+        let hir_var_i_idx = discrs[i].0.index();\n+        let mut error: Option<DiagnosticBuilder<'_, _>> = None;\n+\n+        let mut o = i + 1;\n+        while o < discrs.len() {\n+            let hir_var_o_idx = discrs[o].0.index();\n+\n+            if discrs[i].1.val == discrs[o].1.val {\n+                let err = error.get_or_insert_with(|| {\n+                    let mut ret = struct_span_err!(\n+                        tcx.sess,\n+                        self_span,\n+                        E0081,\n+                        \"discriminant value `{}` assigned more than once\",\n+                        discrs[i].1,\n+                    );\n+\n+                    report(discrs[i].1, hir_var_i_idx, &mut ret);\n+\n+                    ret\n+                });\n+\n+                report(discrs[o].1, hir_var_o_idx, err);\n+\n+                // Safe to unwrap here, as we wouldn't reach this point if `discrs` was empty\n+                discrs[o] = *discrs.last().unwrap();\n+                discrs.pop();\n+            } else {\n+                o += 1;\n+            }\n         }\n-    }\n \n-    format!(\"`{dis}`\")\n+        if let Some(mut e) = error {\n+            e.emit();\n+        }\n+\n+        i += 1;\n+    }\n }\n \n pub(super) fn check_type_params_are_used<'tcx>("}, {"sha": "540a8c3a83d9576d1c25b0860de4dcd8d4e0307d", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1589,11 +1589,11 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     ) {\n         let hir::ExprKind::Loop(_, _, _, loop_span) = expr.kind else { return;};\n         let mut span: MultiSpan = vec![loop_span].into();\n-        span.push_span_label(loop_span, \"this might have zero elements to iterate on\".to_string());\n+        span.push_span_label(loop_span, \"this might have zero elements to iterate on\");\n         for ret_expr in ret_exprs {\n             span.push_span_label(\n                 ret_expr.span,\n-                \"if the loop doesn't execute, this value would never get returned\".to_string(),\n+                \"if the loop doesn't execute, this value would never get returned\",\n             );\n         }\n         err.span_note("}, {"sha": "fb78632069e44a584446bc023a2e5d33c841c914", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -50,7 +50,6 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Pos};\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n@@ -2398,37 +2397,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expr,\n                 Some(span),\n             );\n+        } else if let ty::RawPtr(ty_and_mut) = expr_t.kind()\n+            && let ty::Adt(adt_def, _) = ty_and_mut.ty.kind()\n+            && let ExprKind::Field(base_expr, _) = expr.kind\n+            && adt_def.variants().len() == 1\n+            && adt_def\n+                .variants()\n+                .iter()\n+                .next()\n+                .unwrap()\n+                .fields\n+                .iter()\n+                .any(|f| f.ident(self.tcx) == field)\n+        {\n+            err.multipart_suggestion(\n+                \"to access the field, dereference first\",\n+                vec![\n+                    (base_expr.span.shrink_to_lo(), \"(*\".to_string()),\n+                    (base_expr.span.shrink_to_hi(), \")\".to_string()),\n+                ],\n+                Applicability::MaybeIncorrect,\n+            );\n         } else {\n-            let mut found = false;\n-\n-            if let ty::RawPtr(ty_and_mut) = expr_t.kind()\n-                && let ty::Adt(adt_def, _) = ty_and_mut.ty.kind()\n-            {\n-                if adt_def.variants().len() == 1\n-                    && adt_def\n-                        .variants()\n-                        .iter()\n-                        .next()\n-                        .unwrap()\n-                        .fields\n-                        .iter()\n-                        .any(|f| f.ident(self.tcx) == field)\n-                {\n-                    if let Some(dot_loc) = expr_snippet.rfind('.') {\n-                        found = true;\n-                        err.span_suggestion(\n-                            expr.span.with_hi(expr.span.lo() + BytePos::from_usize(dot_loc)),\n-                            \"to access the field, dereference first\",\n-                            format!(\"(*{})\", &expr_snippet[0..dot_loc]),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n-\n-            if !found {\n-                err.help(\"methods are immutable and cannot be assigned to\");\n-            }\n+            err.help(\"methods are immutable and cannot be assigned to\");\n         }\n \n         err.emit();"}, {"sha": "b73d9a9eb7599d13081679922cc31a86dc9cdf39", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -112,7 +112,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirIdMap, ImplicitSelfKind, Node};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::Idx;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n@@ -122,13 +121,14 @@ use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, Ident};\n-use rustc_span::{self, BytePos, Span};\n+use rustc_span::{self, BytePos, Span, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n use std::cell::RefCell;\n+use std::num::NonZeroU32;\n \n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n@@ -662,6 +662,37 @@ fn missing_items_must_implement_one_of_err(\n     err.emit();\n }\n \n+fn default_body_is_unstable(\n+    tcx: TyCtxt<'_>,\n+    impl_span: Span,\n+    item_did: DefId,\n+    feature: Symbol,\n+    reason: Option<Symbol>,\n+    issue: Option<NonZeroU32>,\n+) {\n+    let missing_item_name = &tcx.associated_item(item_did).name;\n+    let use_of_unstable_library_feature_note = match reason {\n+        Some(r) => format!(\"use of unstable library feature '{feature}': {r}\"),\n+        None => format!(\"use of unstable library feature '{feature}'\"),\n+    };\n+\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        impl_span,\n+        E0046,\n+        \"not all trait items implemented, missing: `{missing_item_name}`\",\n+    );\n+    err.note(format!(\"default implementation of `{missing_item_name}` is unstable\"));\n+    err.note(use_of_unstable_library_feature_note);\n+    rustc_session::parse::add_feature_diagnostics_for_issue(\n+        &mut err,\n+        &tcx.sess.parse_sess,\n+        feature,\n+        rustc_feature::GateIssue::Library(issue),\n+    );\n+    err.emit();\n+}\n+\n /// Re-sugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n fn bounds_from_generic_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "48353756741a157070096c14a5734c903eecc874", "filename": "library/core/src/time.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -318,19 +318,11 @@ impl Duration {\n     /// assert_eq!(duration.as_secs(), 5);\n     /// ```\n     ///\n-    /// To determine the total number of seconds represented by the `Duration`,\n-    /// use `as_secs` in combination with [`subsec_nanos`]:\n-    ///\n-    /// ```\n-    /// use std::time::Duration;\n-    ///\n-    /// let duration = Duration::new(5, 730023852);\n-    ///\n-    /// assert_eq!(5.730023852,\n-    ///            duration.as_secs() as f64\n-    ///            + duration.subsec_nanos() as f64 * 1e-9);\n-    /// ```\n+    /// To determine the total number of seconds represented by the `Duration`\n+    /// including the fractional part, use [`as_secs_f64`] or [`as_secs_f32`]\n     ///\n+    /// [`as_secs_f32`]: Duration::as_secs_f64\n+    /// [`as_secs_f64`]: Duration::as_secs_f32\n     /// [`subsec_nanos`]: Duration::subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[rustc_const_stable(feature = \"duration_consts\", since = \"1.32.0\")]"}, {"sha": "ed1d883d0dca6f4d678448eea67240e82aec3bd1", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -628,6 +628,10 @@ impl Step for Miri {\n             cargo.env(\"MIRI_HOST_SYSROOT\", sysroot);\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n             cargo.env(\"MIRI\", miri);\n+            // propagate --bless\n+            if builder.config.cmd.bless() {\n+                cargo.env(\"MIRI_BLESS\", \"Gesundheit\");\n+            }\n \n             cargo.arg(\"--\").args(builder.config.cmd.test_args());\n "}, {"sha": "a705e2384959f1b8ad56db2d1a2ce3d2e44d9fc7", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -88,8 +88,8 @@ def check_type(ty):\n                         for bound in binding[\"binding\"][\"constraint\"]:\n                             check_generic_bound(bound)\n             elif \"parenthesized\" in args:\n-                for ty in args[\"parenthesized\"][\"inputs\"]:\n-                    check_type(ty)\n+                for input_ty in args[\"parenthesized\"][\"inputs\"]:\n+                    check_type(input_ty)\n                 if args[\"parenthesized\"][\"output\"]:\n                     check_type(args[\"parenthesized\"][\"output\"])\n         if not valid_id(ty[\"inner\"][\"id\"]):"}, {"sha": "a94520b121926e254adfe628c76a889063ea4783", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -348,15 +348,13 @@ where\n     fn make_final_bounds(\n         &self,\n         ty_to_bounds: FxHashMap<Type, FxHashSet<GenericBound>>,\n-        ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)>,\n+        ty_to_fn: FxHashMap<Type, (PolyTrait, Option<Type>)>,\n         lifetime_to_bounds: FxHashMap<Lifetime, FxHashSet<GenericBound>>,\n     ) -> Vec<WherePredicate> {\n         ty_to_bounds\n             .into_iter()\n             .flat_map(|(ty, mut bounds)| {\n-                if let Some(data) = ty_to_fn.get(&ty) {\n-                    let (poly_trait, output) =\n-                        (data.0.as_ref().unwrap().clone(), data.1.as_ref().cloned().map(Box::new));\n+                if let Some((ref poly_trait, ref output)) = ty_to_fn.get(&ty) {\n                     let mut new_path = poly_trait.trait_.clone();\n                     let last_segment = new_path.segments.pop().expect(\"segments were empty\");\n \n@@ -374,8 +372,9 @@ where\n                         GenericArgs::Parenthesized { inputs, output } => (inputs, output),\n                     };\n \n+                    let output = output.as_ref().cloned().map(Box::new);\n                     if old_output.is_some() && old_output != output {\n-                        panic!(\"Output mismatch for {:?} {:?} {:?}\", ty, old_output, data.1);\n+                        panic!(\"Output mismatch for {:?} {:?} {:?}\", ty, old_output, output);\n                     }\n \n                     let new_params = GenericArgs::Parenthesized { inputs: old_input, output };\n@@ -385,7 +384,10 @@ where\n                         .push(PathSegment { name: last_segment.name, args: new_params });\n \n                     bounds.insert(GenericBound::TraitBound(\n-                        PolyTrait { trait_: new_path, generic_params: poly_trait.generic_params },\n+                        PolyTrait {\n+                            trait_: new_path,\n+                            generic_params: poly_trait.generic_params.clone(),\n+                        },\n                         hir::TraitBoundModifier::None,\n                     ));\n                 }\n@@ -471,10 +473,10 @@ where\n         let mut lifetime_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n         let mut ty_to_traits: FxHashMap<Type, FxHashSet<Path>> = Default::default();\n \n-        let mut ty_to_fn: FxHashMap<Type, (Option<PolyTrait>, Option<Type>)> = Default::default();\n+        let mut ty_to_fn: FxHashMap<Type, (PolyTrait, Option<Type>)> = Default::default();\n \n         for p in clean_where_predicates {\n-            let (orig_p, p) = (p, p.clean(self.cx));\n+            let (orig_p, p) = (p, clean_predicate(p, self.cx));\n             if p.is_none() {\n                 continue;\n             }\n@@ -535,8 +537,8 @@ where\n                         if is_fn {\n                             ty_to_fn\n                                 .entry(ty.clone())\n-                                .and_modify(|e| *e = (Some(poly_trait.clone()), e.1.clone()))\n-                                .or_insert(((Some(poly_trait.clone())), None));\n+                                .and_modify(|e| *e = (poly_trait.clone(), e.1.clone()))\n+                                .or_insert(((poly_trait.clone()), None));\n \n                             ty_to_bounds.entry(ty.clone()).or_default();\n                         } else {\n@@ -559,7 +561,13 @@ where\n                                     .and_modify(|e| {\n                                         *e = (e.0.clone(), Some(rhs.ty().unwrap().clone()))\n                                     })\n-                                    .or_insert((None, Some(rhs.ty().unwrap().clone())));\n+                                    .or_insert((\n+                                        PolyTrait {\n+                                            trait_: trait_.clone(),\n+                                            generic_params: Vec::new(),\n+                                        },\n+                                        Some(rhs.ty().unwrap().clone()),\n+                                    ));\n                                 continue;\n                             }\n "}, {"sha": "58d0aedb0239955eee4bcf23914679e2d0bba9e0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -145,6 +145,7 @@ pub(crate) fn try_inline_glob(\n     cx: &mut DocContext<'_>,\n     res: Res,\n     visited: &mut FxHashSet<DefId>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n ) -> Option<Vec<clean::Item>> {\n     let did = res.opt_def_id()?;\n     if did.is_local() {\n@@ -153,8 +154,17 @@ pub(crate) fn try_inline_glob(\n \n     match res {\n         Res::Def(DefKind::Mod, did) => {\n-            let m = build_module(cx, did, visited);\n-            Some(m.items)\n+            let mut items = build_module_items(cx, did, visited, inlined_names);\n+            items.drain_filter(|item| {\n+                if let Some(name) = item.name {\n+                    // If an item with the same type and name already exists,\n+                    // it takes priority over the inlined stuff.\n+                    !inlined_names.insert((item.type_(), name))\n+                } else {\n+                    false\n+                }\n+            });\n+            Some(items)\n         }\n         // glob imports on things like enums aren't inlined even for local exports, so just bail\n         _ => None,\n@@ -517,6 +527,18 @@ fn build_module(\n     did: DefId,\n     visited: &mut FxHashSet<DefId>,\n ) -> clean::Module {\n+    let items = build_module_items(cx, did, visited, &mut FxHashSet::default());\n+\n+    let span = clean::Span::new(cx.tcx.def_span(did));\n+    clean::Module { items, span }\n+}\n+\n+fn build_module_items(\n+    cx: &mut DocContext<'_>,\n+    did: DefId,\n+    visited: &mut FxHashSet<DefId>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n+) -> Vec<clean::Item> {\n     let mut items = Vec::new();\n \n     // If we're re-exporting a re-export it may actually re-export something in\n@@ -526,7 +548,13 @@ fn build_module(\n         if item.vis.is_public() {\n             let res = item.res.expect_non_local();\n             if let Some(def_id) = res.mod_def_id() {\n-                if did == def_id || !visited.insert(def_id) {\n+                // If we're inlining a glob import, it's possible to have\n+                // two distinct modules with the same name. We don't want to\n+                // inline it, or mark any of its contents as visited.\n+                if did == def_id\n+                    || inlined_names.contains(&(ItemType::Module, item.ident.name))\n+                    || !visited.insert(def_id)\n+                {\n                     continue;\n                 }\n             }\n@@ -563,8 +591,7 @@ fn build_module(\n         }\n     }\n \n-    let span = clean::Span::new(cx.tcx.def_span(did));\n-    clean::Module { items, span }\n+    items\n }\n \n pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {"}, {"sha": "78b93725537be9b6e9d6c194587a3b8afafb0a3f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 74, "deletions": 73, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n         // priority to the not-imported one, so we should, too.\n         items.extend(self.items.iter().flat_map(|(item, renamed)| {\n             // First, lower everything other than imports.\n-            if matches!(item.kind, hir::ItemKind::Use(..)) {\n+            if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n                 return Vec::new();\n             }\n             let v = clean_maybe_renamed_item(cx, item, *renamed);\n@@ -84,20 +84,13 @@ impl<'tcx> Clean<'tcx, Item> for DocModule<'tcx> {\n         }));\n         items.extend(self.items.iter().flat_map(|(item, renamed)| {\n             // Now we actually lower the imports, skipping everything else.\n-            if !matches!(item.kind, hir::ItemKind::Use(..)) {\n-                return Vec::new();\n+            if let hir::ItemKind::Use(path, hir::UseKind::Glob) = item.kind {\n+                let name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n+                clean_use_statement(item, name, path, hir::UseKind::Glob, cx, &mut inserted)\n+            } else {\n+                // skip everything else\n+                Vec::new()\n             }\n-            let mut v = clean_maybe_renamed_item(cx, item, *renamed);\n-            v.drain_filter(|item| {\n-                if let Some(name) = item.name {\n-                    // If an item with the same type and name already exists,\n-                    // it takes priority over the inlined stuff.\n-                    !inserted.insert((item.type_(), name))\n-                } else {\n-                    false\n-                }\n-            });\n-            v\n         }));\n \n         // determine if we should display the inner contents or\n@@ -266,66 +259,68 @@ pub(crate) fn clean_middle_region<'tcx>(region: ty::Region<'tcx>) -> Option<Life\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Option<WherePredicate>> for hir::WherePredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n-        if !self.in_where_clause() {\n-            return None;\n-        }\n-        Some(match *self {\n-            hir::WherePredicate::BoundPredicate(ref wbp) => {\n-                let bound_params = wbp\n-                    .bound_generic_params\n-                    .iter()\n-                    .map(|param| {\n-                        // Higher-ranked params must be lifetimes.\n-                        // Higher-ranked lifetimes can't have bounds.\n-                        assert_matches!(\n-                            param,\n-                            hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n-                        );\n-                        Lifetime(param.name.ident().name)\n-                    })\n-                    .collect();\n-                WherePredicate::BoundPredicate {\n-                    ty: clean_ty(wbp.bounded_ty, cx),\n-                    bounds: wbp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-                    bound_params,\n-                }\n+fn clean_where_predicate<'tcx>(\n+    predicate: &hir::WherePredicate<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Option<WherePredicate> {\n+    if !predicate.in_where_clause() {\n+        return None;\n+    }\n+    Some(match *predicate {\n+        hir::WherePredicate::BoundPredicate(ref wbp) => {\n+            let bound_params = wbp\n+                .bound_generic_params\n+                .iter()\n+                .map(|param| {\n+                    // Higher-ranked params must be lifetimes.\n+                    // Higher-ranked lifetimes can't have bounds.\n+                    assert_matches!(\n+                        param,\n+                        hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n+                    );\n+                    Lifetime(param.name.ident().name)\n+                })\n+                .collect();\n+            WherePredicate::BoundPredicate {\n+                ty: clean_ty(wbp.bounded_ty, cx),\n+                bounds: wbp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n+                bound_params,\n             }\n+        }\n \n-            hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n-                lifetime: clean_lifetime(wrp.lifetime, cx),\n-                bounds: wrp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-            },\n+        hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n+            lifetime: clean_lifetime(wrp.lifetime, cx),\n+            bounds: wrp.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n+        },\n \n-            hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n-                lhs: clean_ty(wrp.lhs_ty, cx),\n-                rhs: clean_ty(wrp.rhs_ty, cx).into(),\n-            },\n-        })\n-    }\n+        hir::WherePredicate::EqPredicate(ref wrp) => WherePredicate::EqPredicate {\n+            lhs: clean_ty(wrp.lhs_ty, cx),\n+            rhs: clean_ty(wrp.rhs_ty, cx).into(),\n+        },\n+    })\n }\n \n-impl<'tcx> Clean<'tcx, Option<WherePredicate>> for ty::Predicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n-        let bound_predicate = self.kind();\n-        match bound_predicate.skip_binder() {\n-            ty::PredicateKind::Trait(pred) => {\n-                clean_poly_trait_predicate(bound_predicate.rebind(pred), cx)\n-            }\n-            ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),\n-            ty::PredicateKind::TypeOutlives(pred) => clean_type_outlives_predicate(pred, cx),\n-            ty::PredicateKind::Projection(pred) => Some(clean_projection_predicate(pred, cx)),\n-            ty::PredicateKind::ConstEvaluatable(..) => None,\n-            ty::PredicateKind::WellFormed(..) => None,\n-\n-            ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Coerce(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n+pub(crate) fn clean_predicate<'tcx>(\n+    predicate: ty::Predicate<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Option<WherePredicate> {\n+    let bound_predicate = predicate.kind();\n+    match bound_predicate.skip_binder() {\n+        ty::PredicateKind::Trait(pred) => {\n+            clean_poly_trait_predicate(bound_predicate.rebind(pred), cx)\n         }\n+        ty::PredicateKind::RegionOutlives(pred) => clean_region_outlives_predicate(pred),\n+        ty::PredicateKind::TypeOutlives(pred) => clean_type_outlives_predicate(pred, cx),\n+        ty::PredicateKind::Projection(pred) => Some(clean_projection_predicate(pred, cx)),\n+        ty::PredicateKind::ConstEvaluatable(..) => None,\n+        ty::PredicateKind::WellFormed(..) => None,\n+\n+        ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::Coerce(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n     }\n }\n \n@@ -601,7 +596,11 @@ impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n \n         let mut generics = Generics {\n             params,\n-            where_predicates: self.predicates.iter().filter_map(|x| x.clean(cx)).collect(),\n+            where_predicates: self\n+                .predicates\n+                .iter()\n+                .filter_map(|x| clean_where_predicate(x, cx))\n+                .collect(),\n         };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n@@ -702,7 +701,7 @@ fn clean_ty_generics<'tcx>(\n \n             if let Some(param_idx) = param_idx {\n                 if let Some(b) = impl_trait.get_mut(&param_idx.into()) {\n-                    let p: WherePredicate = p.clean(cx)?;\n+                    let p: WherePredicate = clean_predicate(*p, cx)?;\n \n                     b.extend(\n                         p.get_bounds()\n@@ -759,7 +758,7 @@ fn clean_ty_generics<'tcx>(\n     // Now that `cx.impl_trait_bounds` is populated, we can process\n     // remaining predicates which could contain `impl Trait`.\n     let mut where_predicates =\n-        where_predicates.into_iter().flat_map(|p| p.clean(cx)).collect::<Vec<_>>();\n+        where_predicates.into_iter().flat_map(|p| clean_predicate(*p, cx)).collect::<Vec<_>>();\n \n     // Type parameters have a Sized bound by default unless removed with\n     // ?Sized. Scan through the predicates and mark any type parameter with\n@@ -1962,7 +1961,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 return clean_extern_crate(item, name, orig_name, cx);\n             }\n             ItemKind::Use(path, kind) => {\n-                return clean_use_statement(item, name, path, kind, cx);\n+                return clean_use_statement(item, name, path, kind, cx, &mut FxHashSet::default());\n             }\n             _ => unreachable!(\"not yet converted\"),\n         };\n@@ -2083,6 +2082,7 @@ fn clean_use_statement<'tcx>(\n     path: &hir::Path<'tcx>,\n     kind: hir::UseKind,\n     cx: &mut DocContext<'tcx>,\n+    inlined_names: &mut FxHashSet<(ItemType, Symbol)>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2148,7 +2148,8 @@ fn clean_use_statement<'tcx>(\n     let inner = if kind == hir::UseKind::Glob {\n         if !denied {\n             let mut visited = FxHashSet::default();\n-            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited) {\n+            if let Some(items) = inline::try_inline_glob(cx, path.res, &mut visited, inlined_names)\n+            {\n                 return items;\n             }\n         }"}, {"sha": "ae7d8c108d3eefa21cf0d1293b1dfea9432cc82d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1550,6 +1550,15 @@ fn render_impl(\n         rendering_params: ImplRenderingParameters,\n     ) {\n         for trait_item in &t.items {\n+            // Skip over any default trait items that are impossible to call\n+            // (e.g. if it has a `Self: Sized` bound on an unsized type).\n+            if let Some(impl_def_id) = parent.item_id.as_def_id()\n+                && let Some(trait_item_def_id) = trait_item.item_id.as_def_id()\n+                && cx.tcx().is_impossible_method((impl_def_id, trait_item_def_id))\n+            {\n+                continue;\n+            }\n+\n             let n = trait_item.name;\n             if i.items.iter().any(|m| m.name == n) {\n                 continue;"}, {"sha": "8caba8cb9029cf1548c2c9892122bdf1c19767f9", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 59, "deletions": 61, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -119,6 +119,16 @@ where\n     }\n }\n \n+impl<I, T, U> FromWithTcx<I> for Vec<U>\n+where\n+    I: IntoIterator<Item = T>,\n+    U: FromWithTcx<T>,\n+{\n+    fn from_tcx(f: I, tcx: TyCtxt<'_>) -> Vec<U> {\n+        f.into_iter().map(|x| x.into_tcx(tcx)).collect()\n+    }\n+}\n+\n pub(crate) fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n     #[rustfmt::skip]\n     let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n@@ -130,11 +140,11 @@ impl FromWithTcx<clean::GenericArgs> for GenericArgs {\n         use clean::GenericArgs::*;\n         match args {\n             AngleBracketed { args, bindings } => GenericArgs::AngleBracketed {\n-                args: args.into_vec().into_iter().map(|a| a.into_tcx(tcx)).collect(),\n-                bindings: bindings.into_iter().map(|a| a.into_tcx(tcx)).collect(),\n+                args: args.into_vec().into_tcx(tcx),\n+                bindings: bindings.into_tcx(tcx),\n             },\n             Parenthesized { inputs, output } => GenericArgs::Parenthesized {\n-                inputs: inputs.into_vec().into_iter().map(|a| a.into_tcx(tcx)).collect(),\n+                inputs: inputs.into_vec().into_tcx(tcx),\n                 output: output.map(|a| (*a).into_tcx(tcx)),\n             },\n         }\n@@ -145,7 +155,7 @@ impl FromWithTcx<clean::GenericArg> for GenericArg {\n     fn from_tcx(arg: clean::GenericArg, tcx: TyCtxt<'_>) -> Self {\n         use clean::GenericArg::*;\n         match arg {\n-            Lifetime(l) => GenericArg::Lifetime(l.0.to_string()),\n+            Lifetime(l) => GenericArg::Lifetime(convert_lifetime(l)),\n             Type(t) => GenericArg::Type(t.into_tcx(tcx)),\n             Const(box c) => GenericArg::Const(c.into_tcx(tcx)),\n             Infer => GenericArg::Infer,\n@@ -177,9 +187,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n         use clean::TypeBindingKind::*;\n         match kind {\n             Equality { term } => TypeBindingKind::Equality(term.into_tcx(tcx)),\n-            Constraint { bounds } => {\n-                TypeBindingKind::Constraint(bounds.into_iter().map(|a| a.into_tcx(tcx)).collect())\n-            }\n+            Constraint { bounds } => TypeBindingKind::Constraint(bounds.into_tcx(tcx)),\n         }\n     }\n }\n@@ -244,7 +252,7 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         TraitAliasItem(t) => ItemEnum::TraitAlias(t.into_tcx(tcx)),\n         MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true, header.unwrap(), tcx)),\n         TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false, header.unwrap(), tcx)),\n-        ImplItem(i) => ItemEnum::Impl(i.into_tcx(tcx)),\n+        ImplItem(i) => ItemEnum::Impl((*i).into_tcx(tcx)),\n         StaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignStaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignTypeItem => ItemEnum::ForeignType,\n@@ -260,12 +268,12 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         }\n         TyAssocTypeItem(g, b) => ItemEnum::AssocType {\n             generics: (*g).into_tcx(tcx),\n-            bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            bounds: b.into_tcx(tcx),\n             default: None,\n         },\n         AssocTypeItem(t, b) => ItemEnum::AssocType {\n             generics: t.generics.into_tcx(tcx),\n-            bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            bounds: b.into_tcx(tcx),\n             default: Some(t.item_type.unwrap_or(t.type_).into_tcx(tcx)),\n         },\n         // `convert_item` early returns `None` for stripped items and keywords.\n@@ -347,15 +355,15 @@ fn convert_abi(a: RustcAbi) -> Abi {\n     }\n }\n \n+fn convert_lifetime(l: clean::Lifetime) -> String {\n+    l.0.to_string()\n+}\n+\n impl FromWithTcx<clean::Generics> for Generics {\n     fn from_tcx(generics: clean::Generics, tcx: TyCtxt<'_>) -> Self {\n         Generics {\n-            params: generics.params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n-            where_predicates: generics\n-                .where_predicates\n-                .into_iter()\n-                .map(|x| x.into_tcx(tcx))\n-                .collect(),\n+            params: generics.params.into_tcx(tcx),\n+            where_predicates: generics.where_predicates.into_tcx(tcx),\n         }\n     }\n }\n@@ -374,10 +382,10 @@ impl FromWithTcx<clean::GenericParamDefKind> for GenericParamDefKind {\n         use clean::GenericParamDefKind::*;\n         match kind {\n             Lifetime { outlives } => GenericParamDefKind::Lifetime {\n-                outlives: outlives.into_iter().map(|lt| lt.0.to_string()).collect(),\n+                outlives: outlives.into_iter().map(convert_lifetime).collect(),\n             },\n             Type { did: _, bounds, default, synthetic } => GenericParamDefKind::Type {\n-                bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+                bounds: bounds.into_tcx(tcx),\n                 default: default.map(|x| (*x).into_tcx(tcx)),\n                 synthetic,\n             },\n@@ -395,7 +403,7 @@ impl FromWithTcx<clean::WherePredicate> for WherePredicate {\n         match predicate {\n             BoundPredicate { ty, bounds, bound_params } => WherePredicate::BoundPredicate {\n                 type_: ty.into_tcx(tcx),\n-                bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+                bounds: bounds.into_tcx(tcx),\n                 generic_params: bound_params\n                     .into_iter()\n                     .map(|x| GenericParamDef {\n@@ -405,8 +413,8 @@ impl FromWithTcx<clean::WherePredicate> for WherePredicate {\n                     .collect(),\n             },\n             RegionPredicate { lifetime, bounds } => WherePredicate::RegionPredicate {\n-                lifetime: lifetime.0.to_string(),\n-                bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+                lifetime: convert_lifetime(lifetime),\n+                bounds: bounds.into_tcx(tcx),\n             },\n             EqPredicate { lhs, rhs } => {\n                 WherePredicate::EqPredicate { lhs: lhs.into_tcx(tcx), rhs: rhs.into_tcx(tcx) }\n@@ -424,11 +432,11 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n                 let trait_ = clean::Type::Path { path: trait_ }.into_tcx(tcx);\n                 GenericBound::TraitBound {\n                     trait_,\n-                    generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+                    generic_params: generic_params.into_tcx(tcx),\n                     modifier: from_trait_bound_modifier(modifier),\n                 }\n             }\n-            Outlives(lifetime) => GenericBound::Outlives(lifetime.0.to_string()),\n+            Outlives(lifetime) => GenericBound::Outlives(convert_lifetime(lifetime)),\n         }\n     }\n }\n@@ -447,8 +455,8 @@ pub(crate) fn from_trait_bound_modifier(\n impl FromWithTcx<clean::Type> for Type {\n     fn from_tcx(ty: clean::Type, tcx: TyCtxt<'_>) -> Self {\n         use clean::Type::{\n-            Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive,\n-            QPath, RawPointer, Slice, Tuple,\n+            Array, BareFunction, BorrowedRef, Generic, ImplTrait, Infer, Primitive, QPath,\n+            RawPointer, Slice, Tuple,\n         };\n \n         match ty {\n@@ -458,40 +466,24 @@ impl FromWithTcx<clean::Type> for Type {\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n                 param_names: Vec::new(),\n             },\n-            DynTrait(mut bounds, lt) => {\n-                let first_trait = bounds.remove(0).trait_;\n-\n-                Type::ResolvedPath {\n-                    name: first_trait.whole_name(),\n-                    id: from_item_id(first_trait.def_id().into(), tcx),\n-                    args: first_trait\n-                        .segments\n-                        .last()\n-                        .map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n-                    param_names: bounds\n-                        .into_iter()\n-                        .map(|t| {\n-                            clean::GenericBound::TraitBound(t, rustc_hir::TraitBoundModifier::None)\n-                        })\n-                        .chain(lt.map(clean::GenericBound::Outlives))\n-                        .map(|bound| bound.into_tcx(tcx))\n-                        .collect(),\n-                }\n-            }\n+            clean::Type::DynTrait(bounds, lt) => Type::DynTrait(DynTrait {\n+                lifetime: lt.map(convert_lifetime),\n+                traits: bounds.into_tcx(tcx),\n+            }),\n             Generic(s) => Type::Generic(s.to_string()),\n             Primitive(p) => Type::Primitive(p.as_sym().to_string()),\n             BareFunction(f) => Type::FunctionPointer(Box::new((*f).into_tcx(tcx))),\n-            Tuple(t) => Type::Tuple(t.into_iter().map(|x| x.into_tcx(tcx)).collect()),\n+            Tuple(t) => Type::Tuple(t.into_tcx(tcx)),\n             Slice(t) => Type::Slice(Box::new((*t).into_tcx(tcx))),\n             Array(t, s) => Type::Array { type_: Box::new((*t).into_tcx(tcx)), len: s },\n-            ImplTrait(g) => Type::ImplTrait(g.into_iter().map(|x| x.into_tcx(tcx)).collect()),\n+            ImplTrait(g) => Type::ImplTrait(g.into_tcx(tcx)),\n             Infer => Type::Infer,\n             RawPointer(mutability, type_) => Type::RawPointer {\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n             BorrowedRef { lifetime, mutability, type_ } => Type::BorrowedRef {\n-                lifetime: lifetime.map(|l| l.0.to_string()),\n+                lifetime: lifetime.map(convert_lifetime),\n                 mutable: mutability == ast::Mutability::Mut,\n                 type_: Box::new((*type_).into_tcx(tcx)),\n             },\n@@ -528,7 +520,7 @@ impl FromWithTcx<clean::BareFunctionDecl> for FunctionPointer {\n                 async_: false,\n                 abi: convert_abi(abi),\n             },\n-            generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            generic_params: generic_params.into_tcx(tcx),\n             decl: decl.into_tcx(tcx),\n         }\n     }\n@@ -562,16 +554,28 @@ impl FromWithTcx<clean::Trait> for Trait {\n             is_unsafe,\n             items: ids(items, tcx),\n             generics: generics.into_tcx(tcx),\n-            bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+            bounds: bounds.into_tcx(tcx),\n             implementations: Vec::new(), // Added in JsonRenderer::item\n         }\n     }\n }\n \n-impl FromWithTcx<Box<clean::Impl>> for Impl {\n-    fn from_tcx(impl_: Box<clean::Impl>, tcx: TyCtxt<'_>) -> Self {\n+impl FromWithTcx<clean::PolyTrait> for PolyTrait {\n+    fn from_tcx(\n+        clean::PolyTrait { trait_, generic_params }: clean::PolyTrait,\n+        tcx: TyCtxt<'_>,\n+    ) -> Self {\n+        PolyTrait {\n+            trait_: clean::Type::Path { path: trait_ }.into_tcx(tcx),\n+            generic_params: generic_params.into_tcx(tcx),\n+        }\n+    }\n+}\n+\n+impl FromWithTcx<clean::Impl> for Impl {\n+    fn from_tcx(impl_: clean::Impl, tcx: TyCtxt<'_>) -> Self {\n         let provided_trait_methods = impl_.provided_trait_methods(tcx);\n-        let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = *impl_;\n+        let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = impl_;\n         // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n         let trait_ = trait_.map(|path| clean::Type::Path { path }.into_tcx(tcx));\n         // FIXME: use something like ImplKind in JSON?\n@@ -730,10 +734,7 @@ impl FromWithTcx<Box<clean::Typedef>> for Typedef {\n \n impl FromWithTcx<clean::OpaqueTy> for OpaqueTy {\n     fn from_tcx(opaque: clean::OpaqueTy, tcx: TyCtxt<'_>) -> Self {\n-        OpaqueTy {\n-            bounds: opaque.bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n-            generics: opaque.generics.into_tcx(tcx),\n-        }\n+        OpaqueTy { bounds: opaque.bounds.into_tcx(tcx), generics: opaque.generics.into_tcx(tcx) }\n     }\n }\n \n@@ -749,10 +750,7 @@ impl FromWithTcx<clean::Static> for Static {\n \n impl FromWithTcx<clean::TraitAlias> for TraitAlias {\n     fn from_tcx(alias: clean::TraitAlias, tcx: TyCtxt<'_>) -> Self {\n-        TraitAlias {\n-            generics: alias.generics.into_tcx(tcx),\n-            params: alias.bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n-        }\n+        TraitAlias { generics: alias.generics.into_tcx(tcx), params: alias.bounds.into_tcx(tcx) }\n     }\n }\n "}, {"sha": "bd4ea98441d66d5c6eab5bcfcf1f69fb1253d08a", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -9,7 +9,7 @@ use std::path::PathBuf;\n use serde::{Deserialize, Serialize};\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 16;\n+pub const FORMAT_VERSION: u32 = 17;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -115,6 +115,35 @@ pub enum Visibility {\n     },\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n+pub struct DynTrait {\n+    /// All the traits implemented. One of them is the vtable, and the rest must be auto traits.\n+    pub traits: Vec<PolyTrait>,\n+    /// The lifetime of the whole dyn object\n+    /// ```text\n+    /// dyn Debug + 'static\n+    ///             ^^^^^^^\n+    ///             |\n+    ///             this part\n+    /// ```\n+    pub lifetime: Option<String>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n+/// A trait and potential HRTBs\n+pub struct PolyTrait {\n+    #[serde(rename = \"trait\")]\n+    pub trait_: Type,\n+    /// Used for Higher-Rank Trait Bounds (HRTBs)\n+    /// ```text\n+    /// dyn for<'a> Fn() -> &'a i32\"\n+    ///     ^^^^^^^\n+    ///       |\n+    ///       this part\n+    /// ```\n+    pub generic_params: Vec<GenericParamDef>,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n #[serde(rename_all = \"snake_case\")]\n pub enum GenericArgs {\n@@ -395,7 +424,7 @@ pub enum WherePredicate {\n         type_: Type,\n         bounds: Vec<GenericBound>,\n         /// Used for Higher-Rank Trait Bounds (HRTBs)\n-        /// ```plain\n+        /// ```text\n         /// where for<'a> &'a T: Iterator,\"\n         ///       ^^^^^^^\n         ///       |\n@@ -420,7 +449,7 @@ pub enum GenericBound {\n         #[serde(rename = \"trait\")]\n         trait_: Type,\n         /// Used for Higher-Rank Trait Bounds (HRTBs)\n-        /// ```plain\n+        /// ```text\n         /// where F: for<'a, 'b> Fn(&'a u8, &'b u8)\n         ///          ^^^^^^^^^^^\n         ///          |\n@@ -458,6 +487,7 @@ pub enum Type {\n         args: Option<Box<GenericArgs>>,\n         param_names: Vec<GenericBound>,\n     },\n+    DynTrait(DynTrait),\n     /// Parameterized types\n     Generic(String),\n     /// Fixed-size numeric types (plus int/usize/float), char, arrays, slices, and tuples\n@@ -505,7 +535,7 @@ pub enum Type {\n pub struct FunctionPointer {\n     pub decl: FnDecl,\n     /// Used for Higher-Rank Trait Bounds (HRTBs)\n-    /// ```plain\n+    /// ```text\n     /// for<'c> fn(val: &'c i32) -> i32\n     /// ^^^^^^^\n     ///       |"}, {"sha": "c18b54d1fdf0ed18bba992190874850bed4e7a16", "filename": "src/test/rustdoc-json/type/dyn.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc-json%2Ftype%2Fdyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc-json%2Ftype%2Fdyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ftype%2Fdyn.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,21 +1,49 @@\n // ignore-tidy-linelength\n+use std::fmt::Debug;\n \n-// @count dyn.json \"$.index[*][?(@.name=='dyn')].inner.items\" 1\n+// @count dyn.json \"$.index[*][?(@.name=='dyn')].inner.items[*]\" 3\n // @set sync_int_gen = - \"$.index[*][?(@.name=='SyncIntGen')].id\"\n-// @is - \"$.index[*][?(@.name=='dyn')].inner.items[0]\" $sync_int_gen\n+// @set ref_fn       = - \"$.index[*][?(@.name=='RefFn')].id\"\n+// @set weird_order  = - \"$.index[*][?(@.name=='WeirdOrder')].id\"\n+// @has - \"$.index[*][?(@.name=='dyn')].inner.items[*]\" $sync_int_gen\n+// @has - \"$.index[*][?(@.name=='dyn')].inner.items[*]\" $ref_fn\n+// @has - \"$.index[*][?(@.name=='dyn')].inner.items[*]\" $weird_order\n \n // @is    - \"$.index[*][?(@.name=='SyncIntGen')].kind\" \\\"typedef\\\"\n // @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.generics\" '{\"params\": [], \"where_predicates\": []}'\n // @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.kind\" \\\"resolved_path\\\"\n // @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.name\" \\\"Box\\\"\n // @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.bindings\" []\n // @count - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args\" 1\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.kind\" \\\"resolved_path\\\"\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.kind\" \\\"resolved_path\\\"\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.name\" \\\"Fn\\\"\n-// @count - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.param_names[*]\" 3\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.param_names[0].trait_bound.trait.inner.name\" \\\"Send\\\"\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.param_names[1].trait_bound.trait.inner.name\" \\\"Sync\\\"\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.param_names[2]\" \"{\\\"outlives\\\": \\\"'static\\\"}\"\n-// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.args\" '{\"parenthesized\": {\"inputs\": [],\"output\": {\"inner\": \"i32\",\"kind\": \"primitive\"}}}'\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.kind\" \\\"dyn_trait\\\"\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.lifetime\" \\\"\\'static\\\"\n+// @count - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[*]\" 3\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[0].generic_params\" []\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[1].generic_params\" []\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[2].generic_params\" []\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[0].trait.inner.name\" '\"Fn\"'\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[1].trait.inner.name\" '\"Send\"'\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[2].trait.inner.name\" '\"Sync\"'\n+// @is    - \"$.index[*][?(@.name=='SyncIntGen')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[0].trait.inner.args\" '{\"parenthesized\": {\"inputs\": [],\"output\": {\"inner\": \"i32\",\"kind\": \"primitive\"}}}'\n pub type SyncIntGen = Box<dyn Fn() -> i32 + Send + Sync + 'static>;\n+\n+// @is - \"$.index[*][?(@.name=='RefFn')].kind\" \\\"typedef\\\"\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.generics\" '{\"params\": [{\"kind\": {\"lifetime\": {\"outlives\": []}},\"name\": \"'\\''a\"}],\"where_predicates\": []}'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.kind\" '\"borrowed_ref\"'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.mutable\" 'false'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.lifetime\" \"\\\"'a\\\"\"\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.kind\" '\"dyn_trait\"'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.lifetime\" null\n+// @count - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[*]\" 1\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].generic_params\" '[{\"kind\": {\"lifetime\": {\"outlives\": []}},\"name\": \"'\\''b\"}]'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].trait.kind\" '\"resolved_path\"'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].trait.inner.name\" '\"Fn\"'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].trait.inner.args.parenthesized.inputs[0].kind\" '\"borrowed_ref\"'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].trait.inner.args.parenthesized.inputs[0].inner.lifetime\" \"\\\"'b\\\"\"\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].trait.inner.args.parenthesized.output.kind\" '\"borrowed_ref\"'\n+// @is - \"$.index[*][?(@.name=='RefFn')].inner.type.inner.type.inner.traits[0].trait.inner.args.parenthesized.output.inner.lifetime\" \"\\\"'b\\\"\"\n+pub type RefFn<'a> = &'a dyn for<'b> Fn(&'b i32) -> &'b i32;\n+\n+// @is    - \"$.index[*][?(@.name=='WeirdOrder')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[0].trait.inner.name\" '\"Send\"'\n+// @is    - \"$.index[*][?(@.name=='WeirdOrder')].inner.type.inner.args.angle_bracketed.args[0].type.inner.traits[1].trait.inner.name\" '\"Debug\"'\n+pub type WeirdOrder = Box<dyn Send + Debug>;"}, {"sha": "9311737be0fec0ead932028d4332be8e5b4b034d", "filename": "src/test/rustdoc-json/type/hrtb.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc-json%2Ftype%2Fhrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc-json%2Ftype%2Fhrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Ftype%2Fhrtb.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,26 @@\n+// ignore-tidy-linelength\n+\n+// @has hrtb.json\n+\n+// @is - \"$.index[*][?(@.name=='genfn')].inner.generics.where_predicates[0].bound_predicate.type\" '{\"inner\": \"F\",\"kind\": \"generic\"}'\n+// @is - \"$.index[*][?(@.name=='genfn')].inner.generics.where_predicates[0].bound_predicate.generic_params\" '[{\"kind\": {\"lifetime\": {\"outlives\": []}},\"name\": \"'\\''a\"},{\"kind\": {\"lifetime\": {\"outlives\": []}},\"name\": \"'\\''b\"}]'\n+pub fn genfn<F>(f: F)\n+where\n+    for<'a, 'b> F: Fn(&'a i32, &'b i32),\n+{\n+    let zero = 0;\n+    f(&zero, &zero);\n+}\n+\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.generics\" '{\"params\": [], \"where_predicates\": []}'\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.generics\" '{\"params\": [], \"where_predicates\": []}'\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.decl.inputs[0][1].kind\" '\"borrowed_ref\"'\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.decl.inputs[0][1].inner.type.kind\" '\"dyn_trait\"'\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.decl.inputs[0][1].inner.type.inner.lifetime\" null\n+// @count - \"$.index[*][?(@.name=='dynfn')].inner.decl.inputs[0][1].inner.type.inner.traits[*]\" 1\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.decl.inputs[0][1].inner.type.inner.traits[0].generic_params\" '[{\"kind\": {\"lifetime\": {\"outlives\": []}},\"name\": \"'\\''a\"},{\"kind\": {\"lifetime\": {\"outlives\": []}},\"name\": \"'\\''b\"}]'\n+// @is - \"$.index[*][?(@.name=='dynfn')].inner.decl.inputs[0][1].inner.type.inner.traits[0].trait.inner.name\" '\"Fn\"'\n+pub fn dynfn(f: &dyn for<'a, 'b> Fn(&'a i32, &'b i32)) {\n+    let zero = 0;\n+    f(&zero, &zero);\n+}"}, {"sha": "df1b59069be994b4783fa6e8f0883bf777043e07", "filename": "src/test/rustdoc/auxiliary/issue-100204-aux.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-100204-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-100204-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fissue-100204-aux.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,13 @@\n+#![crate_name=\"first\"]\n+\n+pub mod prelude {\n+    pub use crate::Bot;\n+}\n+\n+pub struct Bot;\n+\n+impl Bot {\n+    pub fn new() -> Bot {\n+        Bot\n+    }\n+}"}, {"sha": "4c4ffddc8a648abaafe7a17c0e3251acc785a9a9", "filename": "src/test/rustdoc/fn-bound.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Ffn-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Ffn-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ffn-bound.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #100143\n+\n+use std::iter::Peekable;\n+\n+pub struct Span<F: Fn(&i32)> {\n+    inner: Peekable<ConditionalIterator<F>>,\n+}\n+\n+pub struct ConditionalIterator<F> {\n+    f: F,\n+}\n+\n+\n+// @has 'fn_bound/struct.ConditionalIterator.html' '//h3[@class=\"code-header in-band\"]' 'impl<F: Fn(&i32)> Iterator for ConditionalIterator<F>'\n+impl<F: Fn(&i32)> Iterator for ConditionalIterator<F> {\n+    type Item = ();\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        todo!()\n+    }\n+}"}, {"sha": "24d6e3bdac1bd259a6213fedd7cf55d6aa96e216", "filename": "src/test/rustdoc/impossible-default.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Fimpossible-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Fimpossible-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpossible-default.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,20 @@\n+#![crate_name = \"foo\"]\n+\n+// Check that default trait items that are impossible to satisfy\n+\n+pub trait Foo {\n+    fn needs_sized(&self)\n+    where\n+        Self: Sized,\n+    {}\n+\n+    fn no_needs_sized(&self) {}\n+}\n+\n+// @!has foo/struct.Bar.html '//*[@id=\"method.needs_sized\"]//h4[@class=\"code-header\"]' \\\n+// \"fn needs_sized\"\n+// @has foo/struct.Bar.html '//*[@id=\"method.no_needs_sized\"]//h4[@class=\"code-header\"]' \\\n+// \"fn no_needs_sized\"\n+pub struct Bar([u8]);\n+\n+impl Foo for Bar {}"}, {"sha": "3e20c5c0741efaa045855fd6944d28c3f09b4a58", "filename": "src/test/rustdoc/issue-100204-inline-impl-through-glob-import.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Fissue-100204-inline-impl-through-glob-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Frustdoc%2Fissue-100204-inline-impl-through-glob-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-100204-inline-impl-through-glob-import.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,14 @@\n+// aux-build:issue-100204-aux.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+#![crate_name=\"second\"]\n+\n+extern crate first;\n+\n+pub mod prelude {}\n+\n+// @has first/struct.Bot.html '//h4[@class=\"code-header\"]' 'pub fn new() -> Bot'\n+// @has second/struct.Bot.html '//h4[@class=\"code-header\"]' 'pub fn new() -> Bot'\n+#[doc(inline)]\n+pub use first::*;"}, {"sha": "f90967fbe6e43ae65e6776da071f80d0fca8da84", "filename": "src/test/ui/asm/naked-functions.stderr", "status": "modified", "additions": 45, "deletions": 58, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fnaked-functions.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -57,13 +57,11 @@ LL |     a + 1\n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:33:1\n    |\n-LL | / pub unsafe extern \"C\" fn inc(a: u32) -> u32 {\n-LL | |\n-LL | |     a + 1\n-   | |     ----- non-asm is unsupported in naked functions\n-LL | |\n-LL | | }\n-   | |_^\n+LL | pub unsafe extern \"C\" fn inc(a: u32) -> u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL |     a + 1\n+   |     ----- non-asm is unsupported in naked functions\n \n error: referencing function parameters is not allowed in naked functions\n   --> $DIR/naked-functions.rs:42:31\n@@ -82,12 +80,11 @@ LL |     asm!(\"/* {0} */\", in(reg) a, options(noreturn));\n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:48:1\n    |\n-LL | / pub unsafe extern \"C\" fn inc_closure(a: u32) -> u32 {\n-LL | |\n-LL | |     (|| a + 1)()\n-   | |     ------------ non-asm is unsupported in naked functions\n-LL | | }\n-   | |_^\n+LL | pub unsafe extern \"C\" fn inc_closure(a: u32) -> u32 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL |     (|| a + 1)()\n+   |     ------------ non-asm is unsupported in naked functions\n \n error[E0787]: only `const` and `sym` operands are supported in naked functions\n   --> $DIR/naked-functions.rs:65:10\n@@ -124,30 +121,25 @@ LL |          sym G, options(noreturn),\n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:54:1\n    |\n-LL | / pub unsafe extern \"C\" fn unsupported_operands() {\n-LL | |\n-LL | |     let mut a = 0usize;\n-   | |     ------------------- non-asm is unsupported in naked functions\n-LL | |     let mut b = 0usize;\n-   | |     ------------------- non-asm is unsupported in naked functions\n-LL | |     let mut c = 0usize;\n-   | |     ------------------- non-asm is unsupported in naked functions\n-LL | |     let mut d = 0usize;\n-   | |     ------------------- non-asm is unsupported in naked functions\n-LL | |     let mut e = 0usize;\n-   | |     ------------------- non-asm is unsupported in naked functions\n-...  |\n-LL | |     );\n-LL | | }\n-   | |_^\n+LL | pub unsafe extern \"C\" fn unsupported_operands() {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL |     let mut a = 0usize;\n+   |     ------------------- non-asm is unsupported in naked functions\n+LL |     let mut b = 0usize;\n+   |     ------------------- non-asm is unsupported in naked functions\n+LL |     let mut c = 0usize;\n+   |     ------------------- non-asm is unsupported in naked functions\n+LL |     let mut d = 0usize;\n+   |     ------------------- non-asm is unsupported in naked functions\n+LL |     let mut e = 0usize;\n+   |     ------------------- non-asm is unsupported in naked functions\n \n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:77:1\n    |\n-LL | / pub extern \"C\" fn missing_assembly() {\n-LL | |\n-LL | | }\n-   | |_^\n+LL | pub extern \"C\" fn missing_assembly() {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0787]: asm in naked functions must use `noreturn` option\n   --> $DIR/naked-functions.rs:84:5\n@@ -185,20 +177,17 @@ LL |     asm!(\"\", options(noreturn));\n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:82:1\n    |\n-LL | / pub extern \"C\" fn too_many_asm_blocks() {\n-LL | |\n-LL | |     asm!(\"\");\n-LL | |\n-LL | |     asm!(\"\");\n-   | |     -------- multiple asm blocks are unsupported in naked functions\n-LL | |\n-LL | |     asm!(\"\");\n-   | |     -------- multiple asm blocks are unsupported in naked functions\n-LL | |\n-LL | |     asm!(\"\", options(noreturn));\n-   | |     --------------------------- multiple asm blocks are unsupported in naked functions\n-LL | | }\n-   | |_^\n+LL | pub extern \"C\" fn too_many_asm_blocks() {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     asm!(\"\");\n+   |     -------- multiple asm blocks are unsupported in naked functions\n+LL |\n+LL |     asm!(\"\");\n+   |     -------- multiple asm blocks are unsupported in naked functions\n+LL |\n+LL |     asm!(\"\", options(noreturn));\n+   |     --------------------------- multiple asm blocks are unsupported in naked functions\n \n error: referencing function parameters is not allowed in naked functions\n   --> $DIR/naked-functions.rs:97:11\n@@ -211,13 +200,11 @@ LL |         *&y\n error[E0787]: naked functions must contain a single asm block\n   --> $DIR/naked-functions.rs:95:5\n    |\n-LL | /     pub extern \"C\" fn inner(y: usize) -> usize {\n-LL | |\n-LL | |         *&y\n-   | |         --- non-asm is unsupported in naked functions\n-LL | |\n-LL | |     }\n-   | |_____^\n+LL |     pub extern \"C\" fn inner(y: usize) -> usize {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |\n+LL |         *&y\n+   |         --- non-asm is unsupported in naked functions\n \n error[E0787]: asm options unsupported in naked functions: `nomem`, `preserves_flags`\n   --> $DIR/naked-functions.rs:105:5\n@@ -249,18 +236,18 @@ LL |     asm!(\"\", options(noreturn, may_unwind));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: Rust ABI is unsupported in naked functions\n-  --> $DIR/naked-functions.rs:124:15\n+  --> $DIR/naked-functions.rs:124:1\n    |\n LL | pub unsafe fn default_abi() {\n-   |               ^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(undefined_naked_function_abi)]` on by default\n \n warning: Rust ABI is unsupported in naked functions\n-  --> $DIR/naked-functions.rs:130:15\n+  --> $DIR/naked-functions.rs:130:1\n    |\n LL | pub unsafe fn rust_abi() {\n-   |               ^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: naked functions cannot be inlined\n   --> $DIR/naked-functions.rs:170:1"}, {"sha": "26b9f4b3a92660ea78b923adb3884545ea4eb81a", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -4,5 +4,5 @@ trait I32Iterator = Iterator<Item = i32>;\n \n fn main() {\n     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();\n-    //~^ ERROR type mismatch\n+    //~^ ERROR expected `std::vec::IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n }"}, {"sha": "2d25f68de44ad1c34a7c36976ce21a9300699deb", "filename": "src/test/ui/associated-types/associated-types-overridden-binding-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-overridden-binding-2.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == i32`\n+error[E0271]: expected `std::vec::IntoIter<u32>` to be an iterator that yields `i32`, but it yields `u32`\n   --> $DIR/associated-types-overridden-binding-2.rs:6:43\n    |\n LL |     let _: &dyn I32Iterator<Item = u32> = &vec![42].into_iter();"}, {"sha": "446212ca767c430206b8609e1526925a35f06c35", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -15,7 +15,7 @@ fn return_targets_async_block_not_fn() -> u8 {\n         return 0u8;\n     };\n     let _: &dyn Future<Output = ()> = &block;\n-    //~^ ERROR type mismatch\n+    //~^ ERROR expected `impl Future<Output = u8>` to be a future that resolves to `()`, but it resolves to `u8`\n }\n \n async fn return_targets_async_block_not_async_fn() -> u8 {\n@@ -24,7 +24,7 @@ async fn return_targets_async_block_not_async_fn() -> u8 {\n         return 0u8;\n     };\n     let _: &dyn Future<Output = ()> = &block;\n-    //~^ ERROR type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+    //~^ ERROR expected `impl Future<Output = u8>` to be a future that resolves to `()`, but it resolves to `u8`\n }\n \n fn no_break_in_async_block() {\n@@ -42,7 +42,9 @@ fn no_break_in_async_block_even_with_outer_loop() {\n }\n \n struct MyErr;\n-fn err() -> Result<u8, MyErr> { Err(MyErr) }\n+fn err() -> Result<u8, MyErr> {\n+    Err(MyErr)\n+}\n \n fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n     //~^ ERROR mismatched types"}, {"sha": "2a08d5d6ce5f8305aa24a50bb95f9445e7d00701", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -31,7 +31,7 @@ LL | |\n LL | | }\n    | |_^ expected `u8`, found `()`\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+error[E0271]: expected `impl Future<Output = u8>` to be a future that resolves to `()`, but it resolves to `u8`\n   --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n@@ -47,7 +47,7 @@ LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+error[E0271]: expected `impl Future<Output = u8>` to be a future that resolves to `()`, but it resolves to `u8`\n   --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n@@ -56,7 +56,7 @@ LL |     let _: &dyn Future<Output = ()> = &block;\n    = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:47:44\n+  --> $DIR/async-block-control-flow-static-semantics.rs:49:44\n    |\n LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`\n@@ -67,7 +67,7 @@ LL | fn rethrow_targets_async_block_not_fn() -> Result<u8, MyErr> {\n            found unit type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/async-block-control-flow-static-semantics.rs:56:50\n+  --> $DIR/async-block-control-flow-static-semantics.rs:58:50\n    |\n LL | fn rethrow_targets_async_block_not_async_fn() -> Result<u8, MyErr> {\n    |    ----------------------------------------      ^^^^^^^^^^^^^^^^^ expected enum `Result`, found `()`"}, {"sha": "fc94d281c77e20578c4065eef3fd37f04d39e2b5", "filename": "src/test/ui/enum/enum-discrim-autosizing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -6,9 +6,9 @@\n enum Eu64 {\n     //~^ ERROR discriminant value `0` assigned more than once\n     Au64 = 0,\n-    //~^NOTE first assignment of `0`\n+    //~^NOTE `0` assigned here\n     Bu64 = 0x8000_0000_0000_0000\n-    //~^NOTE second assignment of `0` (overflowed from `9223372036854775808`)\n+    //~^NOTE `0` (overflowed from `9223372036854775808`) assigned here\n }\n \n fn main() {}"}, {"sha": "be3d7c64e28bd988febb63697c6a99279a7b6736", "filename": "src/test/ui/enum/enum-discrim-autosizing.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -5,10 +5,10 @@ LL | enum Eu64 {\n    | ^^^^^^^^^\n LL |\n LL |     Au64 = 0,\n-   |            - first assignment of `0`\n+   |            - `0` assigned here\n LL |\n LL |     Bu64 = 0x8000_0000_0000_0000\n-   |            --------------------- second assignment of `0` (overflowed from `9223372036854775808`)\n+   |            --------------------- `0` (overflowed from `9223372036854775808`) assigned here\n \n error: aborting due to previous error\n "}, {"sha": "f53fda864d6558224b082fb5f454e446b7b3a977", "filename": "src/test/ui/error-codes/E0081.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,30 +1,53 @@\n enum Enum {\n     //~^ ERROR discriminant value `3` assigned more than once\n     P = 3,\n-    //~^ NOTE first assignment of `3`\n+    //~^ NOTE `3` assigned here\n     X = 3,\n-    //~^ NOTE second assignment of `3`\n+    //~^ NOTE `3` assigned here\n     Y = 5\n }\n \n #[repr(u8)]\n enum EnumOverflowRepr {\n     //~^ ERROR discriminant value `1` assigned more than once\n     P = 257,\n-    //~^ NOTE first assignment of `1` (overflowed from `257`)\n+    //~^ NOTE `1` (overflowed from `257`) assigned here\n     X = 513,\n-    //~^ NOTE second assignment of `1` (overflowed from `513`)\n+    //~^ NOTE `1` (overflowed from `513`) assigned here\n }\n \n #[repr(i8)]\n enum NegDisEnum {\n     //~^ ERROR discriminant value `-1` assigned more than once\n     First = -1,\n-    //~^ NOTE first assignment of `-1`\n+    //~^ NOTE `-1` assigned here\n     Second = -2,\n-    //~^ NOTE assigned discriminant for `Last` was incremented from this discriminant\n+    //~^ NOTE discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n     Last,\n-    //~^ NOTE second assignment of `-1`\n+    //~^ NOTE `-1` assigned here\n+}\n+\n+enum MultipleDuplicates {\n+    //~^ ERROR discriminant value `0` assigned more than once\n+    //~^^ ERROR discriminant value `-2` assigned more than once\n+    V0,\n+    //~^ NOTE `0` assigned here\n+    V1 = 0,\n+    //~^ NOTE `0` assigned here\n+    V2,\n+    V3,\n+    V4 = 0,\n+    //~^ NOTE `0` assigned here\n+    V5 = -2,\n+    //~^ NOTE discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n+    //~^^ NOTE `-2` assigned here\n+    V6,\n+    V7,\n+    //~^ NOTE `0` assigned here\n+    V8 = -3,\n+    //~^ NOTE discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n+    V9,\n+    //~^ NOTE `-2` assigned here\n }\n \n fn main() {"}, {"sha": "64562fefc866c2dc707265a34df1ba346764f5fa", "filename": "src/test/ui/error-codes/E0081.stderr", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -5,10 +5,10 @@ LL | enum Enum {\n    | ^^^^^^^^^\n LL |\n LL |     P = 3,\n-   |         - first assignment of `3`\n+   |         - `3` assigned here\n LL |\n LL |     X = 3,\n-   |         - second assignment of `3`\n+   |         - `3` assigned here\n \n error[E0081]: discriminant value `1` assigned more than once\n   --> $DIR/E0081.rs:11:1\n@@ -17,10 +17,10 @@ LL | enum EnumOverflowRepr {\n    | ^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |     P = 257,\n-   |         --- first assignment of `1` (overflowed from `257`)\n+   |         --- `1` (overflowed from `257`) assigned here\n LL |\n LL |     X = 513,\n-   |         --- second assignment of `1` (overflowed from `513`)\n+   |         --- `1` (overflowed from `513`) assigned here\n \n error[E0081]: discriminant value `-1` assigned more than once\n   --> $DIR/E0081.rs:20:1\n@@ -29,14 +29,50 @@ LL | enum NegDisEnum {\n    | ^^^^^^^^^^^^^^^\n LL |\n LL |     First = -1,\n-   |             -- first assignment of `-1`\n+   |             -- `-1` assigned here\n LL |\n LL |     Second = -2,\n-   |     ----------- assigned discriminant for `Last` was incremented from this discriminant\n+   |     ----------- discriminant for `Last` incremented from this startpoint (`Second` + 1 variant later => `Last` = -1)\n LL |\n LL |     Last,\n-   |     ---- second assignment of `-1`\n+   |     ---- `-1` assigned here\n \n-error: aborting due to 3 previous errors\n+error[E0081]: discriminant value `0` assigned more than once\n+  --> $DIR/E0081.rs:30:1\n+   |\n+LL | enum MultipleDuplicates {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     V0,\n+   |     -- `0` assigned here\n+LL |\n+LL |     V1 = 0,\n+   |          - `0` assigned here\n+...\n+LL |     V4 = 0,\n+   |          - `0` assigned here\n+LL |\n+LL |     V5 = -2,\n+   |     ------- discriminant for `V7` incremented from this startpoint (`V5` + 2 variants later => `V7` = 0)\n+...\n+LL |     V7,\n+   |     -- `0` assigned here\n+\n+error[E0081]: discriminant value `-2` assigned more than once\n+  --> $DIR/E0081.rs:30:1\n+   |\n+LL | enum MultipleDuplicates {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     V5 = -2,\n+   |          -- `-2` assigned here\n+...\n+LL |     V8 = -3,\n+   |     ------- discriminant for `V9` incremented from this startpoint (`V8` + 1 variant later => `V9` = -2)\n+LL |\n+LL |     V9,\n+   |     -- `-2` assigned here\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0081`."}, {"sha": "ae21dbce011398b060b4e9fd62a659d24ef74a76", "filename": "src/test/ui/hrtb/issue-62203-hrtb-ice.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fhrtb%2Fissue-62203-hrtb-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fhrtb%2Fissue-62203-hrtb-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-62203-hrtb-ice.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -38,9 +38,13 @@ fn main() {\n     let v = Unit2.m(\n         //~^ ERROR type mismatch\n         L {\n-        //~^ ERROR type mismatch\n-            f : |x| { drop(x); Unit4 }\n-        });\n+            //~^ ERROR to be a closure that returns `Unit3`, but it returns `Unit4`\n+            f: |x| {\n+                drop(x);\n+                Unit4\n+            },\n+        },\n+    );\n }\n \n impl<'a> Ty<'a> for Unit2 {"}, {"sha": "8365fd0c79e1b52031fdda59825593ec9c5026b9", "filename": "src/test/ui/hrtb/issue-62203-hrtb-ice.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fhrtb%2Fissue-62203-hrtb-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fhrtb%2Fissue-62203-hrtb-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-62203-hrtb-ice.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,8 +1,8 @@\n-error[E0271]: type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:17: 42:20]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n+error[E0271]: type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n   --> $DIR/issue-62203-hrtb-ice.rs:38:19\n    |\n LL |     let v = Unit2.m(\n-   |                   ^ type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:17: 42:20]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n+   |                   ^ type mismatch resolving `for<'r> <L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]> as T0<'r, (&'r u8,)>>::O == <_ as Ty<'r>>::V`\n    |\n note: expected this to be `<_ as Ty<'_>>::V`\n   --> $DIR/issue-62203-hrtb-ice.rs:21:14\n@@ -22,19 +22,22 @@ LL |     where\n LL |         F: for<'r> T0<'r, (<Self as Ty<'r>>::V,), O = <B as Ty<'r>>::V>,\n    |                                                   ^^^^^^^^^^^^^^^^^^^^ required by this bound in `T1::m`\n \n-error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/issue-62203-hrtb-ice.rs:42:17: 42:20] as FnOnce<((&'r u8,),)>>::Output == Unit3`\n+error[E0271]: expected `[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]` to be a closure that returns `Unit3`, but it returns `Unit4`\n   --> $DIR/issue-62203-hrtb-ice.rs:40:9\n    |\n LL |       let v = Unit2.m(\n    |                     - required by a bound introduced by this call\n LL |\n LL | /         L {\n LL | |\n-LL | |             f : |x| { drop(x); Unit4 }\n-LL | |         });\n+LL | |             f: |x| {\n+LL | |                 drop(x);\n+LL | |                 Unit4\n+LL | |             },\n+LL | |         },\n    | |_________^ expected struct `Unit3`, found struct `Unit4`\n    |\n-note: required because of the requirements on the impl of `for<'r> T0<'r, (&'r u8,)>` for `L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:17: 42:20]>`\n+note: required because of the requirements on the impl of `for<'r> T0<'r, (&'r u8,)>` for `L<[closure@$DIR/issue-62203-hrtb-ice.rs:42:16: 42:19]>`\n   --> $DIR/issue-62203-hrtb-ice.rs:17:16\n    |\n LL | impl<'a, A, T> T0<'a, A> for L<T>"}, {"sha": "90d1cd3798a83b2ae89a2b7cc4a173c2d3e235f2", "filename": "src/test/ui/impl-trait/issues/issue-78722.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -7,7 +7,7 @@ type F = impl core::future::Future<Output = u8>;\n struct Bug {\n     V1: [(); {\n         fn concrete_use() -> F {\n-            //~^ ERROR type mismatch\n+            //~^ ERROR expected `impl Future<Output = ()>` to be a future that resolves to `u8`, but it resolves to `()`\n             async {}\n         }\n         let f: F = async { 1 };"}, {"sha": "9a0ffbc89d92e6ce1321fd371f53f39cc035b52e", "filename": "src/test/ui/impl-trait/issues/issue-78722.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-78722.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -16,7 +16,7 @@ LL |         let f: F = async { 1 };\n LL |     }],\n    |     - value is dropped here\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = ()> as Future>::Output == u8`\n+error[E0271]: expected `impl Future<Output = ()>` to be a future that resolves to `u8`, but it resolves to `()`\n   --> $DIR/issue-78722.rs:9:30\n    |\n LL |         fn concrete_use() -> F {"}, {"sha": "e5640f5ab53b192ab352109e039dc3b4616a59fe", "filename": "src/test/ui/intrinsics/const-eval-select-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -27,7 +27,7 @@ fn baz(n: bool) -> i32 {\n \n const fn return_ty_mismatch() {\n     const_eval_select((1,), foo, bar);\n-    //~^ ERROR type mismatch\n+    //~^ ERROR expected `fn(i32) -> bool {bar}` to be a fn item that returns `i32`, but it returns `bool`\n }\n \n const fn args_ty_mismatch() {"}, {"sha": "e7b7e4a4a910c85d9251fc6e32959f6a1c0a7ee1", "filename": "src/test/ui/intrinsics/const-eval-select-bad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -51,7 +51,7 @@ note: required by a bound in `const_eval_select`\n LL |     G: FnOnce<ARG, Output = RET> + ~const Destruct,\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n-error[E0271]: type mismatch resolving `<fn(i32) -> bool {bar} as FnOnce<(i32,)>>::Output == i32`\n+error[E0271]: expected `fn(i32) -> bool {bar}` to be a fn item that returns `i32`, but it returns `bool`\n   --> $DIR/const-eval-select-bad.rs:29:5\n    |\n LL |     const_eval_select((1,), foo, bar);"}, {"sha": "565db2d0fcab82d44251853957b95b8c52b7a37a", "filename": "src/test/ui/issues/issue-15524.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Fissues%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Fissues%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15524.rs?ref=cc8259e4b6b1c8c390969ad24ce09ca502b55f69", "patch": "@@ -1,16 +0,0 @@\n-const N: isize = 1;\n-\n-enum Foo {\n-    //~^ ERROR discriminant value `1` assigned more than once\n-    //~| ERROR discriminant value `1` assigned more than once\n-    //~| ERROR discriminant value `1` assigned more than once\n-    A = 1,\n-    B = 1,\n-    C = 0,\n-    D,\n-\n-    E = N,\n-\n-}\n-\n-fn main() {}"}, {"sha": "1195e0a346ddff0df37508d52559911c16a44426", "filename": "src/test/ui/issues/issue-15524.stderr", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Fissues%2Fissue-15524.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Fissues%2Fissue-15524.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15524.stderr?ref=cc8259e4b6b1c8c390969ad24ce09ca502b55f69", "patch": "@@ -1,40 +0,0 @@\n-error[E0081]: discriminant value `1` assigned more than once\n-  --> $DIR/issue-15524.rs:3:1\n-   |\n-LL | enum Foo {\n-   | ^^^^^^^^\n-...\n-LL |     A = 1,\n-   |         - first assignment of `1`\n-LL |     B = 1,\n-   |         - second assignment of `1`\n-\n-error[E0081]: discriminant value `1` assigned more than once\n-  --> $DIR/issue-15524.rs:3:1\n-   |\n-LL | enum Foo {\n-   | ^^^^^^^^\n-...\n-LL |     A = 1,\n-   |         - first assignment of `1`\n-LL |     B = 1,\n-LL |     C = 0,\n-   |     ----- assigned discriminant for `D` was incremented from this discriminant\n-LL |     D,\n-   |     - second assignment of `1`\n-\n-error[E0081]: discriminant value `1` assigned more than once\n-  --> $DIR/issue-15524.rs:3:1\n-   |\n-LL | enum Foo {\n-   | ^^^^^^^^\n-...\n-LL |     A = 1,\n-   |         - first assignment of `1`\n-...\n-LL |     E = N,\n-   |         - second assignment of `1`\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0081`."}, {"sha": "472a95d4636bc16e39b756a08df4aacb00a29782", "filename": "src/test/ui/issues/issue-31173.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -3,12 +3,13 @@ use std::vec::IntoIter;\n pub fn get_tok(it: &mut IntoIter<u8>) {\n     let mut found_e = false;\n \n-    let temp: Vec<u8> = it.take_while(|&x| {\n-        found_e = true;\n-        false\n-    })\n+    let temp: Vec<u8> = it\n+        .take_while(|&x| {\n+            found_e = true;\n+            false\n+        })\n         .cloned()\n-        //~^ ERROR type mismatch resolving\n+        //~^ ERROR to be an iterator that yields `&_`, but it yields `u8`\n         .collect(); //~ ERROR the method\n }\n "}, {"sha": "e89105540dfb22fac332455c81ced467fc02bf19", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,5 +1,5 @@\n-error[E0271]: type mismatch resolving `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]> as Iterator>::Item == &_`\n-  --> $DIR/issue-31173.rs:10:10\n+error[E0271]: expected `TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>` to be an iterator that yields `&_`, but it yields `u8`\n+  --> $DIR/issue-31173.rs:11:10\n    |\n LL |         .cloned()\n    |          ^^^^^^ expected reference, found `u8`\n@@ -12,11 +12,11 @@ note: required by a bound in `cloned`\n LL |         Self: Sized + Iterator<Item = &'a T>,\n    |                                ^^^^^^^^^^^^ required by this bound in `cloned`\n \n-error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]>>`, but its trait bounds were not satisfied\n-  --> $DIR/issue-31173.rs:12:10\n+error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>`, but its trait bounds were not satisfied\n+  --> $DIR/issue-31173.rs:13:10\n    |\n LL |         .collect();\n-   |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]>>` due to unsatisfied trait bounds\n+   |          ^^^^^^^ method cannot be called on `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>` due to unsatisfied trait bounds\n    |\n   ::: $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n    |\n@@ -29,10 +29,10 @@ LL | pub struct TakeWhile<I, P> {\n    | -------------------------- doesn't satisfy `<_ as Iterator>::Item = &_`\n    |\n    = note: the following trait bounds were not satisfied:\n-           `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]> as Iterator>::Item = &_`\n-           which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]>>: Iterator`\n-           `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]>>: Iterator`\n-           which is required by `&mut Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 6:43]>>: Iterator`\n+           `<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]> as Iterator>::Item = &_`\n+           which is required by `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n+           `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n+           which is required by `&mut Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:7:21: 7:25]>>: Iterator`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8430e85df871514f1269f49b6c7b9bccfe2b6efa", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -3,7 +3,7 @@\n use std::collections::HashMap;\n \n fn main() {\n-    for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n-    //~^ ERROR type mismatch\n-    //~| ERROR type mismatch\n+    for _ in HashMap::new().iter().cloned() {} //~ ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    //~^ ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n+    //~| ERROR expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n }"}, {"sha": "565a7fef379411cdd21ad61145fe9fb38c1eb2ca", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n+error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:36\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n@@ -12,7 +12,7 @@ note: required by a bound in `cloned`\n LL |         Self: Sized + Iterator<Item = &'a T>,\n    |                                ^^^^^^^^^^^^ required by this bound in `cloned`\n \n-error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n+error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n@@ -23,7 +23,7 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n    = note: required because of the requirements on the impl of `IntoIterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n+error[E0271]: expected `std::collections::hash_map::Iter<'_, _, _>` to be an iterator that yields `&_`, but it yields `(&_, &_)`\n   --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}"}, {"sha": "9e190b542db49d438e79e22717355b363d538767", "filename": "src/test/ui/macros/auxiliary/issue-100199.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fissue-100199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fissue-100199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fissue-100199.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,18 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_quote)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{quote, Ident, Span, TokenStream, TokenTree};\n+\n+#[proc_macro_attribute]\n+pub fn struct_with_bound(_: TokenStream, _: TokenStream) -> TokenStream {\n+    let crate_ident = TokenTree::Ident(Ident::new(\"crate\", Span::call_site()));\n+    let trait_ident = TokenTree::Ident(Ident::new(\"MyTrait\", Span::call_site()));\n+    quote!(\n+        struct Foo<T: $crate_ident::$trait_ident> {}\n+    )\n+}"}, {"sha": "6e50afa075984b181f266a0aea8ca93dee13bcfe", "filename": "src/test/ui/macros/issue-100199.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fmacros%2Fissue-100199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fmacros%2Fissue-100199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-100199.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,16 @@\n+#[issue_100199::struct_with_bound] //~ ERROR cannot find trait `MyTrait` in the crate root\n+struct Foo {}\n+// The above must be on the first line so that it's span points to pos 0.\n+// This used to trigger an ICE because the diagnostic emitter would get\n+// an unexpected dummy span (lo == 0 == hi) while attempting to print a\n+// suggestion.\n+\n+// aux-build: issue-100199.rs\n+\n+extern crate issue_100199;\n+\n+mod traits {\n+    pub trait MyTrait {}\n+}\n+\n+fn main() {}"}, {"sha": "2cb45dc12473ef52311aeb7cfa4bda97292a1a54", "filename": "src/test/ui/macros/issue-100199.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fmacros%2Fissue-100199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fmacros%2Fissue-100199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-100199.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,15 @@\n+error[E0405]: cannot find trait `MyTrait` in the crate root\n+  --> $DIR/issue-100199.rs:1:1\n+   |\n+LL | #[issue_100199::struct_with_bound]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in the crate root\n+   |\n+   = note: this error originates in the attribute macro `issue_100199::struct_with_bound` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider importing this trait\n+   |\n+LL | use traits::MyTrait;\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "45cf3723483f3a05f0ca60546bc6c949bb7df68a", "filename": "src/test/ui/never_type/fallback-closure-wrap.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.fallback.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: type mismatch resolving `<[closure@$DIR/fallback-closure-wrap.rs:18:40: 18:47] as FnOnce<()>>::Output == ()`\n+error[E0271]: expected `[closure@$DIR/fallback-closure-wrap.rs:18:40: 18:47]` to be a closure that returns `()`, but it returns `!`\n   --> $DIR/fallback-closure-wrap.rs:18:31\n    |\n LL |       let error = Closure::wrap(Box::new(move || {"}, {"sha": "35052da6760b64ecfe443cbc67eed82304b30aba", "filename": "src/test/ui/never_type/fallback-closure-wrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffallback-closure-wrap.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -16,7 +16,7 @@ use std::marker::PhantomData;\n \n fn main() {\n     let error = Closure::wrap(Box::new(move || {\n-        //[fallback]~^ ERROR type mismatch resolving\n+        //[fallback]~^ to be a closure that returns `()`, but it returns `!`\n         panic!(\"Can't connect to server.\");\n     }) as Box<dyn FnMut()>);\n }"}, {"sha": "b28dce8810593c8b3b1c41487456a9352245c1b7", "filename": "src/test/ui/pattern/suggest-adding-appropriate-missing-pattern-excluding-comments.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.fixed?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+\n+fn main() {\n+    match Some(1) { //~ ERROR non-exhaustive patterns: `None` not covered\n+        Some(1) => {}\n+        // hello\n+        Some(_) => {}\n+        None => todo!()\n+    }\n+}"}, {"sha": "42493a6327173f30b51d6ac096454a83dafaf76f", "filename": "src/test/ui/pattern/suggest-adding-appropriate-missing-pattern-excluding-comments.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+\n+fn main() {\n+    match Some(1) { //~ ERROR non-exhaustive patterns: `None` not covered\n+        Some(1) => {}\n+        // hello\n+        Some(_) => {}\n+    }\n+}"}, {"sha": "f3dca9bcb07d1f42b6ca0e3b628cefea64441f43", "filename": "src/test/ui/pattern/suggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fsuggest-adding-appropriate-missing-pattern-excluding-comments.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,24 @@\n+error[E0004]: non-exhaustive patterns: `None` not covered\n+  --> $DIR/suggest-adding-appropriate-missing-pattern-excluding-comments.rs:4:11\n+   |\n+LL |     match Some(1) {\n+   |           ^^^^^^^ pattern `None` not covered\n+   |\n+note: `Option<i32>` defined here\n+  --> $SRC_DIR/core/src/option.rs:LL:COL\n+   |\n+LL | pub enum Option<T> {\n+   | ------------------\n+...\n+LL |     None,\n+   |     ^^^^ not covered\n+   = note: the matched value is of type `Option<i32>`\n+help: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n+   |\n+LL ~         Some(_) => {}\n+LL +         None => todo!()\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "e8e9c9d3ecb992df65a95607d6ddc711f5e87dae", "filename": "src/test/ui/proc-macro/auxiliary/re-export.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fre-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fre-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fre-export.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,19 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn cause_ice(_: TokenStream) -> TokenStream {\n+    \"\n+        enum IceCause {\n+            Variant,\n+        }\n+\n+        pub use IceCause::Variant;\n+    \".parse().unwrap()\n+}"}, {"sha": "3f01187a8bfffe74a1bde1a28a852d21b9e907ec", "filename": "src/test/ui/proc-macro/issue-79148.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-79148.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-79148.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-79148.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:re-export.rs\n+// edition:2018\n+\n+extern crate re_export;\n+\n+use re_export::cause_ice;\n+\n+cause_ice!(); //~ ERROR `Variant` is only public within the crate, and cannot be re-exported outside\n+\n+fn main() {}"}, {"sha": "a3b2de01ddfbbbcf1f4645292ee75034dbe4a20e", "filename": "src/test/ui/proc-macro/issue-79148.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-79148.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fproc-macro%2Fissue-79148.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-79148.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,16 @@\n+error[E0364]: `Variant` is only public within the crate, and cannot be re-exported outside\n+  --> $DIR/issue-79148.rs:8:1\n+   |\n+LL | cause_ice!();\n+   | ^^^^^^^^^^^^\n+   |\n+note: consider marking `Variant` as `pub` in the imported module\n+  --> $DIR/issue-79148.rs:8:1\n+   |\n+LL | cause_ice!();\n+   | ^^^^^^^^^^^^\n+   = note: this error originates in the macro `cause_ice` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0364`."}, {"sha": "3a177419d666ddd48d7e3b20c830b5be1ca0ce72", "filename": "src/test/ui/stability-attribute/auxiliary/default_body.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Fdefault_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Fdefault_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fauxiliary%2Fdefault_body.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,29 @@\n+#![crate_type = \"lib\"]\n+#![feature(staged_api, rustc_attrs)]\n+#![stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+\n+#[stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+pub trait JustTrait {\n+    #[stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+    #[rustc_default_body_unstable(feature = \"constant_default_body\", issue = \"none\")]\n+    const CONSTANT: usize = 0;\n+\n+    #[rustc_default_body_unstable(feature = \"fun_default_body\", issue = \"none\")]\n+    #[stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+    fn fun() {}\n+}\n+\n+#[rustc_must_implement_one_of(eq, neq)]\n+#[stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+pub trait Equal {\n+    #[rustc_default_body_unstable(feature = \"eq_default_body\", issue = \"none\")]\n+    #[stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+    fn eq(&self, other: &Self) -> bool {\n+        !self.neq(other)\n+    }\n+\n+    #[stable(feature = \"stable_feature\", since = \"1.0.0\")]\n+    fn neq(&self, other: &Self) -> bool {\n+        !self.eq(other)\n+    }\n+}"}, {"sha": "ecb281bccf604d1ed3173ee309f47b5fae92c4f9", "filename": "src/test/ui/stability-attribute/default-body-stability-err.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-err.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,19 @@\n+// aux-build:default_body.rs\n+#![crate_type = \"lib\"]\n+\n+extern crate default_body;\n+\n+use default_body::{Equal, JustTrait};\n+\n+struct Type;\n+\n+impl JustTrait for Type {}\n+//~^ ERROR not all trait items implemented, missing: `CONSTANT` [E0046]\n+//~| ERROR not all trait items implemented, missing: `fun` [E0046]\n+\n+impl Equal for Type {\n+    //~^ ERROR not all trait items implemented, missing: `eq` [E0046]\n+    fn neq(&self, other: &Self) -> bool {\n+        false\n+    }\n+}"}, {"sha": "ef666f30fc2a294fd5a3a4b6715aada8adee7f17", "filename": "src/test/ui/stability-attribute/default-body-stability-err.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-err.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,38 @@\n+error[E0046]: not all trait items implemented, missing: `CONSTANT`\n+  --> $DIR/default-body-stability-err.rs:10:1\n+   |\n+LL | impl JustTrait for Type {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: default implementation of `CONSTANT` is unstable\n+   = note: use of unstable library feature 'constant_default_body'\n+   = help: add `#![feature(constant_default_body)]` to the crate attributes to enable\n+\n+error[E0046]: not all trait items implemented, missing: `fun`\n+  --> $DIR/default-body-stability-err.rs:10:1\n+   |\n+LL | impl JustTrait for Type {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: default implementation of `fun` is unstable\n+   = note: use of unstable library feature 'fun_default_body'\n+   = help: add `#![feature(fun_default_body)]` to the crate attributes to enable\n+\n+error[E0046]: not all trait items implemented, missing: `eq`\n+  --> $DIR/default-body-stability-err.rs:14:1\n+   |\n+LL | / impl Equal for Type {\n+LL | |\n+LL | |     fn neq(&self, other: &Self) -> bool {\n+LL | |         false\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+   = note: default implementation of `eq` is unstable\n+   = note: use of unstable library feature 'eq_default_body'\n+   = help: add `#![feature(eq_default_body)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0046`."}, {"sha": "bdc7522f48dde92f9fb89f5e88688484be90540a", "filename": "src/test/ui/stability-attribute/default-body-stability-ok-enables.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-ok-enables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-ok-enables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-ok-enables.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// aux-build:default_body.rs\n+#![crate_type = \"lib\"]\n+#![feature(fun_default_body, eq_default_body, constant_default_body)]\n+\n+extern crate default_body;\n+\n+use default_body::{Equal, JustTrait};\n+\n+struct Type;\n+\n+impl JustTrait for Type {}\n+\n+impl Equal for Type {\n+    fn neq(&self, other: &Self) -> bool {\n+        false\n+    }\n+}"}, {"sha": "e1f5c017096ab74261933767b74020b9efaf6866", "filename": "src/test/ui/stability-attribute/default-body-stability-ok-impls.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-ok-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-ok-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstability-attribute%2Fdefault-body-stability-ok-impls.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// aux-build:default_body.rs\n+#![crate_type = \"lib\"]\n+\n+extern crate default_body;\n+\n+use default_body::{Equal, JustTrait};\n+\n+struct Type;\n+\n+impl JustTrait for Type {\n+    const CONSTANT: usize = 1;\n+\n+    fn fun() {}\n+}\n+\n+impl Equal for Type {\n+    fn eq(&self, other: &Self) -> bool {\n+        false\n+    }\n+}"}, {"sha": "e497f993da2801ac4b2ad2733c834c56131875ac", "filename": "src/test/ui/tag-variant-disr-dup.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Ftag-variant-disr-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Ftag-variant-disr-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-disr-dup.rs?ref=cc8259e4b6b1c8c390969ad24ce09ca502b55f69", "patch": "@@ -1,12 +0,0 @@\n-// Black and White have the same discriminator value ...\n-\n-enum Color {\n-    //~^ ERROR discriminant value `0` assigned more than once\n-    Red = 0xff0000,\n-    Green = 0x00ff00,\n-    Blue = 0x0000ff,\n-    Black = 0x000000,\n-    White = 0x000000,\n-}\n-\n-fn main() { }"}, {"sha": "6b1ba43d2ba6e79c89051577d75200d5511c62c0", "filename": "src/test/ui/tag-variant-disr-dup.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Ftag-variant-disr-dup.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cc8259e4b6b1c8c390969ad24ce09ca502b55f69/src%2Ftest%2Fui%2Ftag-variant-disr-dup.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftag-variant-disr-dup.stderr?ref=cc8259e4b6b1c8c390969ad24ce09ca502b55f69", "patch": "@@ -1,14 +0,0 @@\n-error[E0081]: discriminant value `0` assigned more than once\n-  --> $DIR/tag-variant-disr-dup.rs:3:1\n-   |\n-LL | enum Color {\n-   | ^^^^^^^^^^\n-...\n-LL |     Black = 0x000000,\n-   |             -------- first assignment of `0`\n-LL |     White = 0x000000,\n-   |             -------- second assignment of `0`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0081`."}, {"sha": "d7d6241ef708cda1a68a922940d7a3963417a6ba", "filename": "src/test/ui/traits/assoc-type-in-superbad.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -4,13 +4,13 @@\n \n use std::vec::IntoIter;\n \n-pub trait Foo: Iterator<Item=<Self as Foo>::Key> {\n+pub trait Foo: Iterator<Item = <Self as Foo>::Key> {\n     type Key;\n }\n \n impl Foo for IntoIter<i32> {\n-    type Key = u32; //~ ERROR type mismatch\n+    type Key = u32;\n+    //~^ ERROR expected `std::vec::IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "3e2d9d9038aa7c1e6b8655cd3fdf668cc42f6190", "filename": "src/test/ui/traits/assoc-type-in-superbad.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassoc-type-in-superbad.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: type mismatch resolving `<std::vec::IntoIter<i32> as Iterator>::Item == u32`\n+error[E0271]: expected `std::vec::IntoIter<i32>` to be an iterator that yields `u32`, but it yields `i32`\n   --> $DIR/assoc-type-in-superbad.rs:12:16\n    |\n LL |     type Key = u32;\n@@ -7,8 +7,8 @@ LL |     type Key = u32;\n note: required by a bound in `Foo`\n   --> $DIR/assoc-type-in-superbad.rs:7:25\n    |\n-LL | pub trait Foo: Iterator<Item=<Self as Foo>::Key> {\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo`\n+LL | pub trait Foo: Iterator<Item = <Self as Foo>::Key> {\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "24b3a045856a6accd5656b25a2531e4afae89465", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -8,7 +8,7 @@ trait Foo {\n \n impl Foo for () {\n     type Bar = std::vec::IntoIter<u32>;\n-    //~^ ERROR type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == X\n+    //~^ ERROR expected `std::vec::IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n }\n \n fn incoherent() {"}, {"sha": "fb40895c49f15d13e28a81527f3ef4ac2e159014", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,4 +1,4 @@\n-error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == X`\n+error[E0271]: expected `std::vec::IntoIter<u32>` to be an iterator that yields `X`, but it yields `u32`\n   --> $DIR/issue-57961.rs:10:16\n    |\n LL | type X = impl Sized;"}, {"sha": "32c2f9ed51edf3476df927c63f6465635a7946a0", "filename": "src/test/ui/type-alias-impl-trait/issue-98604.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,13 +1,11 @@\n // edition:2018\n \n-type AsyncFnPtr = Box<\n-    dyn Fn() -> std::pin::Pin<Box<dyn std::future::Future<Output = ()>>>,\n->;\n+type AsyncFnPtr = Box<dyn Fn() -> std::pin::Pin<Box<dyn std::future::Future<Output = ()>>>>;\n \n async fn test() {}\n \n #[allow(unused_must_use)]\n fn main() {\n     Box::new(test) as AsyncFnPtr;\n-    //~^ ERROR type mismatch\n+    //~^ ERROR expected `fn() -> impl Future<Output = ()> {test}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n }"}, {"sha": "92d01eb0d3d5ea0a1128208af5075fff0435b3e2", "filename": "src/test/ui/type-alias-impl-trait/issue-98604.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98604.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,11 +1,11 @@\n-error[E0271]: type mismatch resolving `<fn() -> impl Future<Output = ()> {test} as FnOnce<()>>::Output == Pin<Box<(dyn Future<Output = ()> + 'static)>>`\n-  --> $DIR/issue-98604.rs:11:5\n+error[E0271]: expected `fn() -> impl Future<Output = ()> {test}` to be a fn item that returns `Pin<Box<(dyn Future<Output = ()> + 'static)>>`, but it returns `impl Future<Output = ()>`\n+  --> $DIR/issue-98604.rs:9:5\n    |\n LL |     Box::new(test) as AsyncFnPtr;\n    |     ^^^^^^^^^^^^^^ expected struct `Pin`, found opaque type\n    |\n note: while checking the return type of the `async fn`\n-  --> $DIR/issue-98604.rs:7:17\n+  --> $DIR/issue-98604.rs:5:17\n    |\n LL | async fn test() {}\n    |                 ^ checked the `Output` of this `async fn`, found opaque type"}, {"sha": "1f89af0457653b066d09f2c0455f9cdf915329ff", "filename": "src/test/ui/type-alias-impl-trait/issue-98608.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98608.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98608.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98608.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,8 +1,10 @@\n-fn hi() -> impl Sized { std::ptr::null::<u8>() }\n+fn hi() -> impl Sized {\n+    std::ptr::null::<u8>()\n+}\n \n fn main() {\n     let b: Box<dyn Fn() -> Box<u8>> = Box::new(hi);\n-    //~^ ERROR type mismatch resolving `<fn() -> impl Sized {hi} as FnOnce<()>>::Output == Box<u8>`\n+    //~^ ERROR expected `fn() -> impl Sized {hi}` to be a fn item that returns `Box<u8>`, but it returns `impl Sized`\n     let boxed = b();\n     let null = *boxed;\n     println!(\"{null:?}\");"}, {"sha": "916a58451baa2f8b5c7d0f1a3414e98ae51faa02", "filename": "src/test/ui/type-alias-impl-trait/issue-98608.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98608.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98608.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-98608.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,7 +1,7 @@\n-error[E0271]: type mismatch resolving `<fn() -> impl Sized {hi} as FnOnce<()>>::Output == Box<u8>`\n-  --> $DIR/issue-98608.rs:4:39\n+error[E0271]: expected `fn() -> impl Sized {hi}` to be a fn item that returns `Box<u8>`, but it returns `impl Sized`\n+  --> $DIR/issue-98608.rs:6:39\n    |\n-LL | fn hi() -> impl Sized { std::ptr::null::<u8>() }\n+LL | fn hi() -> impl Sized {\n    |            ---------- the found opaque type\n ...\n LL |     let b: Box<dyn Fn() -> Box<u8>> = Box::new(hi);"}, {"sha": "7a0cfb2cf51a727bb39f0df6a92a3cf93e5842ed", "filename": "src/test/ui/typeck/issue-91210-ptr-method.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-91210-ptr-method.stderr?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -2,9 +2,12 @@ error[E0615]: attempted to take value of method `read` on type `*mut Foo`\n   --> $DIR/issue-91210-ptr-method.rs:10:7\n    |\n LL |     x.read = 4;\n-   |     - ^^^^ method, not a field\n-   |     |\n-   |     help: to access the field, dereference first: `(*x)`\n+   |       ^^^^ method, not a field\n+   |\n+help: to access the field, dereference first\n+   |\n+LL |     (*x).read = 4;\n+   |     ++ +\n \n error: aborting due to previous error\n "}, {"sha": "a038dce3248aa41fb5ede1be651a3cf7fce1c078", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -19,7 +19,7 @@ Before submitting, please make sure that you're not running into one of these kn\n Otherwise please try to provide information which will help us to fix the issue faster. Minimal reproducible examples with few dependencies are especially lovely <3.\n -->\n \n-**rust-analyzer version**: (eg. output of \"Rust Analyzer: Show RA Version\" command)\n+**rust-analyzer version**: (eg. output of \"rust-analyzer: Show RA Version\" command, accessible in VSCode via <kbd>Ctrl/\u2318</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd>)\n \n **rustc version**: (eg. output of `rustc -V`)\n "}, {"sha": "ca8eb1309de3dce3d92aa96a3e03a14ded9c781a", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -18,6 +18,7 @@ env:\n   FETCH_DEPTH: 0 # pull in the tags for the version string\n   MACOSX_DEPLOYMENT_TARGET: 10.15\n   CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc\n+  CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_LINKER: arm-linux-gnueabihf-gcc\n \n jobs:\n   dist:\n@@ -36,6 +37,9 @@ jobs:\n           - os: ubuntu-18.04\n             target: aarch64-unknown-linux-gnu\n             code-target: linux-arm64\n+          - os: ubuntu-18.04\n+            target: arm-unknown-linux-gnueabihf\n+            code-target: linux-armhf\n           - os: macos-11\n             target: x86_64-apple-darwin\n             code-target: darwin-x64\n@@ -67,13 +71,17 @@ jobs:\n           node-version: 14.x\n \n       - name: Update apt repositories\n-        if: matrix.target == 'aarch64-unknown-linux-gnu'\n+        if: matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'arm-unknown-linux-gnueabihf'\n         run: sudo apt-get update\n \n-      - name: Install target toolchain\n+      - name: Install AArch64 target toolchain\n         if: matrix.target == 'aarch64-unknown-linux-gnu'\n         run: sudo apt-get install gcc-aarch64-linux-gnu\n \n+      - name: Install ARM target toolchain\n+        if: matrix.target == 'arm-unknown-linux-gnueabihf'\n+        run: sudo apt-get install gcc-arm-linux-gnueabihf\n+\n       - name: Dist\n         run: cargo xtask dist --client-patch-version ${{ github.run_number }}\n \n@@ -204,6 +212,10 @@ jobs:\n         with:\n           name: dist-aarch64-unknown-linux-gnu\n           path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-arm-unknown-linux-gnueabihf\n+          path: dist\n       - uses: actions/download-artifact@v1\n         with:\n           name: dist-x86_64-pc-windows-msvc"}, {"sha": "8c3f6f8468bf6f64a1872b1c637fd774c844cbdc", "filename": "src/tools/rust-analyzer/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FREADME.md?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -43,7 +43,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer\n \n ## License\n \n-Rust analyzer is primarily distributed under the terms of both the MIT\n+rust-analyzer is primarily distributed under the terms of both the MIT\n license and the Apache License (Version 2.0).\n \n See LICENSE-APACHE and LICENSE-MIT for details."}, {"sha": "3347940ec6d639015304407bdd708dcff184c2bb", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -57,6 +57,7 @@ pub struct FlycheckHandle {\n     // XXX: drop order is significant\n     sender: Sender<Restart>,\n     _thread: jod_thread::JoinHandle,\n+    id: usize,\n }\n \n impl FlycheckHandle {\n@@ -72,18 +73,22 @@ impl FlycheckHandle {\n             .name(\"Flycheck\".to_owned())\n             .spawn(move || actor.run(receiver))\n             .expect(\"failed to spawn thread\");\n-        FlycheckHandle { sender, _thread: thread }\n+        FlycheckHandle { id, sender, _thread: thread }\n     }\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn update(&self) {\n         self.sender.send(Restart).unwrap();\n     }\n+\n+    pub fn id(&self) -> usize {\n+        self.id\n+    }\n }\n \n pub enum Message {\n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic { workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n+    AddDiagnostic { id: usize, workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n     Progress {\n@@ -96,8 +101,9 @@ pub enum Message {\n impl fmt::Debug for Message {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n-            Message::AddDiagnostic { workspace_root, diagnostic } => f\n+            Message::AddDiagnostic { id, workspace_root, diagnostic } => f\n                 .debug_struct(\"AddDiagnostic\")\n+                .field(\"id\", id)\n                 .field(\"workspace_root\", workspace_root)\n                 .field(\"diagnostic_code\", &diagnostic.code.as_ref().map(|it| &it.code))\n                 .finish(),\n@@ -183,7 +189,7 @@ impl FlycheckActor {\n                     }\n                 }\n                 Event::CheckEvent(None) => {\n-                    tracing::debug!(\"flycheck finished\");\n+                    tracing::debug!(flycheck_id = self.id, \"flycheck finished\");\n \n                     // Watcher finished\n                     let cargo_handle = self.cargo_handle.take().unwrap();\n@@ -203,6 +209,7 @@ impl FlycheckActor {\n \n                     CargoMessage::Diagnostic(msg) => {\n                         self.send(Message::AddDiagnostic {\n+                            id: self.id,\n                             workspace_root: self.workspace_root.clone(),\n                             diagnostic: msg,\n                         });"}, {"sha": "469b28c2d9ede6a8edc9904792215579df6285af", "filename": "src/tools/rust-analyzer/crates/hir-def/src/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -451,7 +451,7 @@ impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n         if let GenericDefId::TraitId(id) = *self {\n             let trait_ref = id.lookup(db).source(db).value;\n             let idx = idx_iter.next().unwrap();\n-            params.insert(idx, Either::Right(trait_ref))\n+            params.insert(idx, Either::Right(trait_ref));\n         }\n \n         if let Some(generic_params_list) = generic_params_list {"}, {"sha": "3342d4db4aa64812d88c5c40e1cbd4a53a644165", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -14,7 +14,7 @@\n //! unaffected, so we don't have to recompute name resolution results or item data (see `data.rs`).\n //!\n //! The `ItemTree` for the currently open file can be displayed by using the VS Code command\n-//! \"Rust Analyzer: Debug ItemTree\".\n+//! \"rust-analyzer: Debug ItemTree\".\n //!\n //! Compared to rustc's architecture, `ItemTree` has properties from both rustc's AST and HIR: many\n //! syntax-level Rust features are already desugared to simpler forms in the `ItemTree`, but name"}, {"sha": "087268a9ecee4f2c3cac07835bb92b13277d7b0e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -224,7 +224,7 @@ pub(crate) fn field_visibilities_query(\n     let resolver = variant_id.module(db).resolver(db);\n     let mut res = ArenaMap::default();\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, field_data.visibility.resolve(db, &resolver))\n+        res.insert(field_id, field_data.visibility.resolve(db, &resolver));\n     }\n     Arc::new(res)\n }"}, {"sha": "e46f43a878fe13c7597b2d0a23e456d35a537587", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "modified", "additions": 108, "deletions": 2, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -5,7 +5,7 @@ use std::mem;\n use mbe::{SyntheticToken, SyntheticTokenId, TokenMap};\n use rustc_hash::FxHashMap;\n use syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, HasLoopBody},\n     match_ast, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n };\n use tt::Subtree;\n@@ -142,8 +142,59 @@ pub(crate) fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n                         ]);\n                     }\n                 },\n+                ast::WhileExpr(it) => {\n+                    if it.condition().is_none() {\n+                        // insert placeholder token after the while token\n+                        let while_token = match it.while_token() {\n+                            Some(t) => t,\n+                            None => continue,\n+                        };\n+                        append.insert(while_token.into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::IDENT,\n+                                text: \"__ra_fixup\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                    if it.loop_body().is_none() {\n+                        append.insert(node.clone().into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::L_CURLY,\n+                                text: \"{\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                            SyntheticToken {\n+                                kind: SyntaxKind::R_CURLY,\n+                                text: \"}\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                },\n+                ast::LoopExpr(it) => {\n+                    if it.loop_body().is_none() {\n+                        append.insert(node.clone().into(), vec![\n+                            SyntheticToken {\n+                                kind: SyntaxKind::L_CURLY,\n+                                text: \"{\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                            SyntheticToken {\n+                                kind: SyntaxKind::R_CURLY,\n+                                text: \"}\".into(),\n+                                range: end_range,\n+                                id: EMPTY_ID,\n+                            },\n+                        ]);\n+                    }\n+                },\n                 // FIXME: foo::\n-                // FIXME: for, loop, match etc.\n+                // FIXME: for, match etc.\n                 _ => (),\n             }\n         }\n@@ -376,6 +427,61 @@ fn foo() {\n             // the {} gets parsed as the condition, I think?\n             expect![[r#\"\n fn foo () {if {} {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn fixup_while_1() {\n+        check(\n+            r#\"\n+fn foo() {\n+    while\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {while __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn fixup_while_2() {\n+        check(\n+            r#\"\n+fn foo() {\n+    while foo\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {while foo {}}\n+\"#]],\n+        )\n+    }\n+    #[test]\n+    fn fixup_while_3() {\n+        check(\n+            r#\"\n+fn foo() {\n+    while {}\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {while __ra_fixup {}}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn fixup_loop() {\n+        check(\n+            r#\"\n+fn foo() {\n+    loop\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {loop {}}\n \"#]],\n         )\n     }"}, {"sha": "47d191822d841af60e5ae81977cabc7b45747e56", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -381,6 +381,7 @@ pub mod known {\n         bitor,\n         bitxor_assign,\n         bitxor,\n+        branch,\n         deref_mut,\n         deref,\n         div_assign,\n@@ -396,6 +397,7 @@ pub mod known {\n         not,\n         owned_box,\n         partial_ord,\n+        poll,\n         r#fn,\n         rem_assign,\n         rem,"}, {"sha": "2a13106390d9f7f90773d1377bdc8b24351ca393", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -10,13 +10,13 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Ordering, Statement, UnaryOp},\n+    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    ConstParamId, FieldId, FunctionId, ItemContainerId, Lookup,\n+    ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::Name;\n use stdx::always;\n use syntax::ast::RangeOp;\n \n@@ -28,7 +28,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution::{self, VisibleFromModule},\n+    method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -947,7 +947,9 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = self.resolve_binop_method(op);\n+        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        });\n         let func = match func {\n             Some(func) => func,\n             None => {\n@@ -1473,55 +1475,4 @@ impl<'a> InferenceContext<'a> {\n             },\n         })\n     }\n-\n-    fn resolve_binop_method(&self, op: BinaryOp) -> Option<FunctionId> {\n-        let (name, lang_item) = match op {\n-            BinaryOp::LogicOp(_) => return None,\n-            BinaryOp::ArithOp(aop) => match aop {\n-                ArithOp::Add => (name!(add), name!(add)),\n-                ArithOp::Mul => (name!(mul), name!(mul)),\n-                ArithOp::Sub => (name!(sub), name!(sub)),\n-                ArithOp::Div => (name!(div), name!(div)),\n-                ArithOp::Rem => (name!(rem), name!(rem)),\n-                ArithOp::Shl => (name!(shl), name!(shl)),\n-                ArithOp::Shr => (name!(shr), name!(shr)),\n-                ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n-                ArithOp::BitOr => (name!(bitor), name!(bitor)),\n-                ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n-            },\n-            BinaryOp::Assignment { op: Some(aop) } => match aop {\n-                ArithOp::Add => (name!(add_assign), name!(add_assign)),\n-                ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n-                ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n-                ArithOp::Div => (name!(div_assign), name!(div_assign)),\n-                ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n-                ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n-                ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n-                ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n-                ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n-                ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n-            },\n-            BinaryOp::CmpOp(cop) => match cop {\n-                CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n-                CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n-                CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                    (name!(le), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n-                    (name!(lt), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                    (name!(ge), name!(partial_ord))\n-                }\n-                CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                    (name!(gt), name!(partial_ord))\n-                }\n-            },\n-            BinaryOp::Assignment { op: None } => return None,\n-        };\n-\n-        let trait_ = self.resolve_lang_item(lang_item)?.as_trait()?;\n-\n-        self.db.trait_data(trait_).method_by_name(&name)\n-    }\n }"}, {"sha": "239f66bcb7e798f813a0e2d9206f78897a1d0c95", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1126,7 +1126,7 @@ pub(crate) fn field_types_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, make_binders(db, &generics, ctx.lower_ty(&field_data.type_ref)))\n+        res.insert(field_id, make_binders(db, &generics, ctx.lower_ty(&field_data.type_ref)));\n     }\n     Arc::new(res)\n }"}, {"sha": "64622545f8408b190cec4f87e906a0627d515a6a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -336,7 +336,7 @@ impl InherentImpls {\n     }\n }\n \n-pub fn inherent_impl_crates_query(\n+pub(crate) fn inherent_impl_crates_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n     fp: TyFingerprint,\n@@ -419,6 +419,55 @@ pub fn def_crates(\n     }\n }\n \n+pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)> {\n+    use hir_expand::name;\n+    use syntax::ast::{ArithOp, BinaryOp, CmpOp, Ordering};\n+    Some(match op {\n+        BinaryOp::LogicOp(_) => return None,\n+        BinaryOp::ArithOp(aop) => match aop {\n+            ArithOp::Add => (name!(add), name!(add)),\n+            ArithOp::Mul => (name!(mul), name!(mul)),\n+            ArithOp::Sub => (name!(sub), name!(sub)),\n+            ArithOp::Div => (name!(div), name!(div)),\n+            ArithOp::Rem => (name!(rem), name!(rem)),\n+            ArithOp::Shl => (name!(shl), name!(shl)),\n+            ArithOp::Shr => (name!(shr), name!(shr)),\n+            ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n+            ArithOp::BitOr => (name!(bitor), name!(bitor)),\n+            ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n+        },\n+        BinaryOp::Assignment { op: Some(aop) } => match aop {\n+            ArithOp::Add => (name!(add_assign), name!(add_assign)),\n+            ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n+            ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n+            ArithOp::Div => (name!(div_assign), name!(div_assign)),\n+            ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n+            ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n+            ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n+            ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n+            ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n+            ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n+        },\n+        BinaryOp::CmpOp(cop) => match cop {\n+            CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n+            CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n+            CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n+                (name!(le), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n+                (name!(lt), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n+                (name!(ge), name!(partial_ord))\n+            }\n+            CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n+                (name!(gt), name!(partial_ord))\n+            }\n+        },\n+        BinaryOp::Assignment { op: None } => return None,\n+    })\n+}\n+\n /// Look up the method with the given name.\n pub(crate) fn lookup_method(\n     ty: &Canonical<Ty>,"}, {"sha": "416b6f58061da344580f4d9b672c6006e4749852", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -357,6 +357,26 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n \n+    pub fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<Function> {\n+        self.imp.resolve_await_to_poll(await_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_prefix_expr(&self, prefix_expr: &ast::PrefixExpr) -> Option<Function> {\n+        self.imp.resolve_prefix_expr(prefix_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_index_expr(&self, index_expr: &ast::IndexExpr) -> Option<Function> {\n+        self.imp.resolve_index_expr(index_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_bin_expr(&self, bin_expr: &ast::BinExpr) -> Option<Function> {\n+        self.imp.resolve_bin_expr(bin_expr).map(Function::from)\n+    }\n+\n+    pub fn resolve_try_expr(&self, try_expr: &ast::TryExpr) -> Option<Function> {\n+        self.imp.resolve_try_expr(try_expr).map(Function::from)\n+    }\n+\n     pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.imp.resolve_method_call_as_callable(call)\n     }\n@@ -1066,6 +1086,26 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(call.syntax())?.resolve_method_call(self.db, call)\n     }\n \n+    fn resolve_await_to_poll(&self, await_expr: &ast::AwaitExpr) -> Option<FunctionId> {\n+        self.analyze(await_expr.syntax())?.resolve_await_to_poll(self.db, await_expr)\n+    }\n+\n+    fn resolve_prefix_expr(&self, prefix_expr: &ast::PrefixExpr) -> Option<FunctionId> {\n+        self.analyze(prefix_expr.syntax())?.resolve_prefix_expr(self.db, prefix_expr)\n+    }\n+\n+    fn resolve_index_expr(&self, index_expr: &ast::IndexExpr) -> Option<FunctionId> {\n+        self.analyze(index_expr.syntax())?.resolve_index_expr(self.db, index_expr)\n+    }\n+\n+    fn resolve_bin_expr(&self, bin_expr: &ast::BinExpr) -> Option<FunctionId> {\n+        self.analyze(bin_expr.syntax())?.resolve_bin_expr(self.db, bin_expr)\n+    }\n+\n+    fn resolve_try_expr(&self, try_expr: &ast::TryExpr) -> Option<FunctionId> {\n+        self.analyze(try_expr.syntax())?.resolve_try_expr(self.db, try_expr)\n+    }\n+\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.analyze(call.syntax())?.resolve_method_call_as_callable(self.db, call)\n     }"}, {"sha": "f5e2e44307090151c24908cd5cf11a5896b0e709", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 115, "deletions": 5, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -25,15 +25,20 @@ use hir_def::{\n     Lookup, ModuleDefId, VariantId,\n };\n use hir_expand::{\n-    builtin_fn_macro::BuiltinFnLikeExpander, hygiene::Hygiene, name::AsName, HirFileId, InFile,\n+    builtin_fn_macro::BuiltinFnLikeExpander,\n+    hygiene::Hygiene,\n+    name,\n+    name::{AsName, Name},\n+    HirFileId, InFile,\n };\n use hir_ty::{\n     diagnostics::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    method_resolution, Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution,\n-    TyExt, TyKind, TyLoweringContext,\n+    method_resolution::{self, lang_names_for_bin_op},\n+    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind,\n+    TyLoweringContext,\n };\n use itertools::Itertools;\n use smallvec::SmallVec;\n@@ -255,8 +260,90 @@ impl SourceAnalyzer {\n     ) -> Option<FunctionId> {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n-        let f_in_impl = self.resolve_impl_method(db, f_in_trait, &substs);\n-        f_in_impl.or(Some(f_in_trait))\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+    }\n+\n+    pub(crate) fn resolve_await_to_poll(\n+        &self,\n+        db: &dyn HirDatabase,\n+        await_expr: &ast::AwaitExpr,\n+    ) -> Option<FunctionId> {\n+        let ty = self.ty_of_expr(db, &await_expr.expr()?.into())?;\n+\n+        let op_fn = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n+            .as_function()?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_prefix_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        prefix_expr: &ast::PrefixExpr,\n+    ) -> Option<FunctionId> {\n+        let lang_item_name = match prefix_expr.op_kind()? {\n+            ast::UnaryOp::Deref => name![deref],\n+            ast::UnaryOp::Not => name![not],\n+            ast::UnaryOp::Neg => name![neg],\n+        };\n+        let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n+\n+        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_index_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        index_expr: &ast::IndexExpr,\n+    ) -> Option<FunctionId> {\n+        let base_ty = self.ty_of_expr(db, &index_expr.base()?.into())?;\n+        let index_ty = self.ty_of_expr(db, &index_expr.index()?.into())?;\n+\n+        let lang_item_name = name![index];\n+\n+        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+            .push(base_ty.clone())\n+            .push(index_ty.clone())\n+            .build();\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_bin_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        binop_expr: &ast::BinExpr,\n+    ) -> Option<FunctionId> {\n+        let op = binop_expr.op_kind()?;\n+        let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n+        let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n+\n+        let op_fn = lang_names_for_bin_op(op)\n+            .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n+        let substs =\n+            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+    }\n+\n+    pub(crate) fn resolve_try_expr(\n+        &self,\n+        db: &dyn HirDatabase,\n+        try_expr: &ast::TryExpr,\n+    ) -> Option<FunctionId> {\n+        let ty = self.ty_of_expr(db, &try_expr.expr()?.into())?;\n+\n+        let op_fn =\n+            db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -666,6 +753,29 @@ impl SourceAnalyzer {\n         let fun_data = db.function_data(func);\n         method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n     }\n+\n+    fn resolve_impl_method_or_trait_def(\n+        &self,\n+        db: &dyn HirDatabase,\n+        func: FunctionId,\n+        substs: &Substitution,\n+    ) -> FunctionId {\n+        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+    }\n+\n+    fn lang_trait_fn(\n+        &self,\n+        db: &dyn HirDatabase,\n+        lang_trait: &Name,\n+        method_name: &Name,\n+    ) -> Option<FunctionId> {\n+        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n+            .method_by_name(method_name)\n+    }\n+\n+    fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {\n+        self.infer.as_ref()?.type_of_expr.get(self.expr_id(db, &expr)?)\n+    }\n }\n \n fn scope_for("}, {"sha": "35cd42908af2c0d225d3fa5d0fb3336fb3629d96", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 356, "deletions": 19, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,8 +1,8 @@\n-use hir::{HasSource, InFile};\n+use hir::{HasSource, HirDisplay, InFile};\n use ide_db::assists::{AssistId, AssistKind};\n use syntax::{\n-    ast::{self, edit::IndentLevel},\n-    AstNode, TextSize,\n+    ast::{self, make, HasArgList},\n+    match_ast, AstNode, SyntaxNode,\n };\n \n use crate::assist_context::{AssistContext, Assists};\n@@ -32,8 +32,8 @@ use crate::assist_context::{AssistContext, Assists};\n // }\n // ```\n pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n-    let path = path_expr.path()?;\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n+    let parent = path_parent(&path)?;\n \n     if ctx.sema.resolve_path(&path).is_some() {\n         // No need to generate anything if the path resolves\n@@ -50,45 +50,152 @@ pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>)\n         ctx.sema.resolve_path(&path.qualifier()?)\n     {\n         let target = path.syntax().text_range();\n-        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref);\n+        return add_variant_to_accumulator(acc, ctx, target, e, &name_ref, parent);\n     }\n \n     None\n }\n \n+#[derive(Debug)]\n+enum PathParent {\n+    PathExpr(ast::PathExpr),\n+    RecordExpr(ast::RecordExpr),\n+    PathPat(ast::PathPat),\n+    UseTree(ast::UseTree),\n+}\n+\n+impl PathParent {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            PathParent::PathExpr(it) => it.syntax(),\n+            PathParent::RecordExpr(it) => it.syntax(),\n+            PathParent::PathPat(it) => it.syntax(),\n+            PathParent::UseTree(it) => it.syntax(),\n+        }\n+    }\n+\n+    fn make_field_list(&self, ctx: &AssistContext<'_>) -> Option<ast::FieldList> {\n+        let scope = ctx.sema.scope(self.syntax())?;\n+\n+        match self {\n+            PathParent::PathExpr(it) => {\n+                if let Some(call_expr) = it.syntax().parent().and_then(ast::CallExpr::cast) {\n+                    make_tuple_field_list(call_expr, ctx, &scope)\n+                } else {\n+                    None\n+                }\n+            }\n+            PathParent::RecordExpr(it) => make_record_field_list(it, ctx, &scope),\n+            PathParent::UseTree(_) | PathParent::PathPat(_) => None,\n+        }\n+    }\n+}\n+\n+fn path_parent(path: &ast::Path) -> Option<PathParent> {\n+    let parent = path.syntax().parent()?;\n+\n+    match_ast! {\n+        match parent {\n+            ast::PathExpr(it) => Some(PathParent::PathExpr(it)),\n+            ast::RecordExpr(it) => Some(PathParent::RecordExpr(it)),\n+            ast::PathPat(it) => Some(PathParent::PathPat(it)),\n+            ast::UseTree(it) => Some(PathParent::UseTree(it)),\n+            _ => None\n+        }\n+    }\n+}\n+\n fn add_variant_to_accumulator(\n     acc: &mut Assists,\n     ctx: &AssistContext<'_>,\n     target: syntax::TextRange,\n     adt: hir::Enum,\n     name_ref: &ast::NameRef,\n+    parent: PathParent,\n ) -> Option<()> {\n     let db = ctx.db();\n     let InFile { file_id, value: enum_node } = adt.source(db)?.original_ast_node(db)?;\n-    let enum_indent = IndentLevel::from_node(&enum_node.syntax());\n-\n-    let variant_list = enum_node.variant_list()?;\n-    let offset = variant_list.syntax().text_range().end() - TextSize::of('}');\n-    let empty_enum = variant_list.variants().next().is_none();\n \n     acc.add(\n         AssistId(\"generate_enum_variant\", AssistKind::Generate),\n         \"Generate variant\",\n         target,\n         |builder| {\n             builder.edit_file(file_id.original_file(db));\n-            let text = format!(\n-                \"{maybe_newline}{indent_1}{name},\\n{enum_indent}\",\n-                maybe_newline = if empty_enum { \"\\n\" } else { \"\" },\n-                indent_1 = IndentLevel(1),\n-                name = name_ref,\n-                enum_indent = enum_indent\n-            );\n-            builder.insert(offset, text)\n+            let node = builder.make_mut(enum_node);\n+            let variant = make_variant(ctx, name_ref, parent);\n+            node.variant_list().map(|it| it.add_variant(variant.clone_for_update()));\n         },\n     )\n }\n \n+fn make_variant(\n+    ctx: &AssistContext<'_>,\n+    name_ref: &ast::NameRef,\n+    parent: PathParent,\n+) -> ast::Variant {\n+    let field_list = parent.make_field_list(ctx);\n+    make::variant(make::name(&name_ref.text()), field_list)\n+}\n+\n+fn make_record_field_list(\n+    record: &ast::RecordExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let fields = record.record_expr_field_list()?.fields();\n+    let record_fields = fields.map(|field| {\n+        let name = name_from_field(&field);\n+\n+        let ty = field\n+            .expr()\n+            .and_then(|it| expr_ty(ctx, it, scope))\n+            .unwrap_or_else(make::ty_placeholder);\n+\n+        make::record_field(None, name, ty)\n+    });\n+    Some(make::record_field_list(record_fields).into())\n+}\n+\n+fn name_from_field(field: &ast::RecordExprField) -> ast::Name {\n+    let text = match field.name_ref() {\n+        Some(it) => it.to_string(),\n+        None => name_from_field_shorthand(field).unwrap_or(\"unknown\".to_string()),\n+    };\n+    make::name(&text)\n+}\n+\n+fn name_from_field_shorthand(field: &ast::RecordExprField) -> Option<String> {\n+    let path = match field.expr()? {\n+        ast::Expr::PathExpr(path_expr) => path_expr.path(),\n+        _ => None,\n+    }?;\n+    Some(path.as_single_name_ref()?.to_string())\n+}\n+\n+fn make_tuple_field_list(\n+    call_expr: ast::CallExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let args = call_expr.arg_list()?.args();\n+    let tuple_fields = args.map(|arg| {\n+        let ty = expr_ty(ctx, arg, &scope).unwrap_or_else(make::ty_placeholder);\n+        make::tuple_field(None, ty)\n+    });\n+    Some(make::tuple_field_list(tuple_fields).into())\n+}\n+\n+fn expr_ty(\n+    ctx: &AssistContext<'_>,\n+    arg: ast::Expr,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::Type> {\n+    let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted())?;\n+    let text = ty.display_source_code(ctx.db(), scope.module().into()).ok()?;\n+    Some(make::ty(&text))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -221,6 +328,236 @@ mod m {\n fn main() {\n     m::Foo::Baz\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(bool),\n+}\n+fn main() {\n+    Foo::Bar(true)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_single_element_tuple_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(x)\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar(_),\n+}\n+fn main() {\n+    Foo::Bar(x)\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_multi_element_tuple() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::Bar$0(true, x, Struct {})\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar(bool, _, Struct),\n+}\n+fn main() {\n+    Foo::Bar(true, x, Struct {})\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: true }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    Foo::Bar { x: true }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: y }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x: y }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    let x = true;\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    let x = true;\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_multiple_fields() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar { x: _, y: _, s: Struct },\n+}\n+fn main() {\n+    Foo::Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn use_tree() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+//- /main.rs\n+mod foo;\n+use foo::Foo::Bar$0;\n+\n+//- /foo.rs\n+enum Foo {}\n+\",\n+            r\"\n+enum Foo {\n+    Bar,\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_for_path_type() {\n+        check_assist_not_applicable(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+impl Foo::Bar$0 {}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn path_pat() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn foo(x: Foo) {\n+    match x {\n+        Foo::Bar$0 =>\n+    }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar,\n+}\n+fn foo(x: Foo) {\n+    match x {\n+        Foo::Bar =>\n+    }\n+}\n \",\n         )\n     }"}, {"sha": "f8134c552f7563295d264cc0681bbc8af49e47f7", "filename": "src/tools/rust-analyzer/crates/ide-db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fapply_change.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -45,7 +45,7 @@ impl RootDatabase {\n     // |===\n     // | Editor  | Action Name\n     //\n-    // | VS Code | **Rust Analyzer: Memory Usage (Clears Database)**\n+    // | VS Code | **rust-analyzer: Memory Usage (Clears Database)**\n     // |===\n     // image::https://user-images.githubusercontent.com/48062697/113065592-08559f00-91b1-11eb-8c96-64b88068ec02.gif[]\n     pub fn per_query_memory_usage(&mut self) -> Vec<(String, Bytes)> {"}, {"sha": "6c13c039723b297a2a5b22645893b2c4c4e09590", "filename": "src/tools/rust-analyzer/crates/ide-db/src/defs.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fdefs.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -127,10 +127,12 @@ impl Definition {\n     }\n }\n \n+// FIXME: IdentClass as a name no longer fits\n #[derive(Debug)]\n pub enum IdentClass {\n     NameClass(NameClass),\n     NameRefClass(NameRefClass),\n+    Operator(OperatorClass),\n }\n \n impl IdentClass {\n@@ -147,6 +149,11 @@ impl IdentClass {\n                         .map(IdentClass::NameClass)\n                         .or_else(|| NameRefClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameRefClass))\n                 },\n+                ast::AwaitExpr(await_expr) => OperatorClass::classify_await(sema, &await_expr).map(IdentClass::Operator),\n+                ast::BinExpr(bin_expr) => OperatorClass::classify_bin(sema, &bin_expr).map(IdentClass::Operator),\n+                ast::IndexExpr(index_expr) => OperatorClass::classify_index(sema, &index_expr).map(IdentClass::Operator),\n+                ast::PrefixExpr(prefix_expr) => OperatorClass::classify_prefix(sema,&prefix_expr).map(IdentClass::Operator),\n+                ast::TryExpr(try_expr) => OperatorClass::classify_try(sema,&try_expr).map(IdentClass::Operator),\n                 _ => None,\n             }\n         }\n@@ -184,6 +191,33 @@ impl IdentClass {\n                 res.push(Definition::Local(local_ref));\n                 res.push(Definition::Field(field_ref));\n             }\n+            IdentClass::Operator(\n+                OperatorClass::Await(func)\n+                | OperatorClass::Prefix(func)\n+                | OperatorClass::Bin(func)\n+                | OperatorClass::Index(func)\n+                | OperatorClass::Try(func),\n+            ) => res.push(Definition::Function(func)),\n+        }\n+        res\n+    }\n+\n+    pub fn definitions_no_ops(self) -> ArrayVec<Definition, 2> {\n+        let mut res = ArrayVec::new();\n+        match self {\n+            IdentClass::NameClass(NameClass::Definition(it) | NameClass::ConstReference(it)) => {\n+                res.push(it)\n+            }\n+            IdentClass::NameClass(NameClass::PatFieldShorthand { local_def, field_ref }) => {\n+                res.push(Definition::Local(local_def));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::NameRefClass(NameRefClass::Definition(it)) => res.push(it),\n+            IdentClass::NameRefClass(NameRefClass::FieldShorthand { local_ref, field_ref }) => {\n+                res.push(Definition::Local(local_ref));\n+                res.push(Definition::Field(field_ref));\n+            }\n+            IdentClass::Operator(_) => (),\n         }\n         res\n     }\n@@ -332,6 +366,52 @@ impl NameClass {\n     }\n }\n \n+#[derive(Debug)]\n+pub enum OperatorClass {\n+    Await(Function),\n+    Prefix(Function),\n+    Index(Function),\n+    Try(Function),\n+    Bin(Function),\n+}\n+\n+impl OperatorClass {\n+    pub fn classify_await(\n+        sema: &Semantics<'_, RootDatabase>,\n+        await_expr: &ast::AwaitExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_await_to_poll(await_expr).map(OperatorClass::Await)\n+    }\n+\n+    pub fn classify_prefix(\n+        sema: &Semantics<'_, RootDatabase>,\n+        prefix_expr: &ast::PrefixExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_prefix_expr(prefix_expr).map(OperatorClass::Prefix)\n+    }\n+\n+    pub fn classify_try(\n+        sema: &Semantics<'_, RootDatabase>,\n+        try_expr: &ast::TryExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_try_expr(try_expr).map(OperatorClass::Try)\n+    }\n+\n+    pub fn classify_index(\n+        sema: &Semantics<'_, RootDatabase>,\n+        index_expr: &ast::IndexExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_index_expr(index_expr).map(OperatorClass::Index)\n+    }\n+\n+    pub fn classify_bin(\n+        sema: &Semantics<'_, RootDatabase>,\n+        bin_expr: &ast::BinExpr,\n+    ) -> Option<OperatorClass> {\n+        sema.resolve_bin_expr(bin_expr).map(OperatorClass::Bin)\n+    }\n+}\n+\n /// This is similar to [`NameClass`], but works for [`ast::NameRef`] rather than\n /// for [`ast::Name`]. Similarly, what looks like a reference in syntax is a\n /// reference most of the time, but there are a couple of annoying exceptions."}, {"sha": "739e0ccb436dbeebad6112430c610ca79a93688e", "filename": "src/tools/rust-analyzer/crates/ide-ssr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -57,7 +57,7 @@\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Structural Search Replace**\n+// | VS Code | **rust-analyzer: Structural Search Replace**\n // |===\n //\n // Also available as an assist, by writing a comment containing the structural"}, {"sha": "5a8cda8fb3dda19e0c4ea6c5c0f4b0fbc72073f9", "filename": "src/tools/rust-analyzer/crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -7,7 +7,7 @@ use ide_db::{\n     search::FileReference,\n     FxIndexMap, RootDatabase,\n };\n-use syntax::{ast, AstNode, SyntaxKind::NAME, TextRange};\n+use syntax::{ast, AstNode, SyntaxKind::IDENT, TextRange};\n \n use crate::{goto_definition, FilePosition, NavigationTarget, RangeInfo, TryToNav};\n \n@@ -79,7 +79,7 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n     let file = sema.parse(file_id);\n     let file = file.syntax();\n     let token = pick_best_token(file.token_at_offset(position.offset), |kind| match kind {\n-        NAME => 1,\n+        IDENT => 1,\n         _ => 0,\n     })?;\n     let mut calls = CallLocations::default();"}, {"sha": "93252339cd4a83885f6b26a54b30b3f0ecf65cb4", "filename": "src/tools/rust-analyzer/crates/ide/src/expand_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -19,7 +19,7 @@ pub struct ExpandedMacro {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Expand macro recursively**\n+// | VS Code | **rust-analyzer: Expand macro recursively**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113020648-b3973180-917a-11eb-84a9-ecb921293dc5.gif[]\n@@ -32,7 +32,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n         _ => 0,\n     })?;\n \n-    // due to how Rust Analyzer works internally, we need to special case derive attributes,\n+    // due to how rust-analyzer works internally, we need to special case derive attributes,\n     // otherwise they might not get found, e.g. here with the cursor at $0 `#[attr]` would expand:\n     // ```\n     // #[attr]"}, {"sha": "b2123b9a87938545f4e9609e4e586289b8634aa9", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 121, "deletions": 1, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -39,7 +39,11 @@ pub(crate) fn goto_definition(\n             | T![super]\n             | T![crate]\n             | T![Self]\n-            | COMMENT => 2,\n+            | COMMENT => 4,\n+            // index and prefix ops\n+            T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n+            kind if kind.is_keyword() => 2,\n+            T!['('] | T![')'] => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         })?;\n@@ -1628,6 +1632,122 @@ macro_rules! foo {\n }\n \n foo!(bar$0);\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_await_poll() {\n+        check(\n+            r#\"\n+//- minicore: future\n+\n+struct MyFut;\n+\n+impl core::future::Future for MyFut {\n+    type Output = ();\n+\n+    fn poll(\n+     //^^^^\n+        self: std::pin::Pin<&mut Self>,\n+        cx: &mut std::task::Context<'_>\n+    ) -> std::task::Poll<Self::Output>\n+    {\n+        ()\n+    }\n+}\n+\n+fn f() {\n+    MyFut.await$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_try_op() {\n+        check(\n+            r#\"\n+//- minicore: try\n+\n+struct Struct;\n+\n+impl core::ops::Try for Struct {\n+    fn branch(\n+     //^^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct?$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_index_op() {\n+        check(\n+            r#\"\n+//- minicore: index\n+\n+struct Struct;\n+\n+impl core::ops::Index<usize> for Struct {\n+    fn index(\n+     //^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct[0]$0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_prefix_op() {\n+        check(\n+            r#\"\n+//- minicore: deref\n+\n+struct Struct;\n+\n+impl core::ops::Deref for Struct {\n+    fn deref(\n+     //^^^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    $0*Struct;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_bin_op() {\n+        check(\n+            r#\"\n+//- minicore: add\n+\n+struct Struct;\n+\n+impl core::ops::Add for Struct {\n+    fn add(\n+     //^^^\n+        self\n+    ) {}\n+}\n+\n+fn f() {\n+    Struct +$0 Struct;\n+}\n \"#,\n         );\n     }"}, {"sha": "b3f711b6b88c4edd0b97403d85fc99b0857317a9", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -30,7 +30,7 @@ pub(crate) fn goto_implementation(\n \n     let original_token =\n         pick_best_token(syntax.token_at_offset(position.offset), |kind| match kind {\n-            IDENT | T![self] => 1,\n+            IDENT | T![self] | INT_NUMBER => 1,\n             _ => 0,\n         })?;\n     let range = original_token.text_range();"}, {"sha": "f190da326e455fd8a6563df8ad19fd73d1aff90d", "filename": "src/tools/rust-analyzer/crates/ide/src/highlight_related.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -333,7 +333,8 @@ fn cover_range(r0: Option<TextRange>, r1: Option<TextRange>) -> Option<TextRange\n fn find_defs(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> FxHashSet<Definition> {\n     sema.descend_into_macros(token)\n         .into_iter()\n-        .filter_map(|token| IdentClass::classify_token(sema, &token).map(IdentClass::definitions))\n+        .filter_map(|token| IdentClass::classify_token(sema, &token))\n+        .map(IdentClass::definitions_no_ops)\n         .flatten()\n         .collect()\n }"}, {"sha": "3ada181f1ed2ba63a3e69d775af8a9bc3c35ab25", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -9,7 +9,7 @@ use either::Either;\n use hir::{HasSource, Semantics};\n use ide_db::{\n     base_db::FileRange,\n-    defs::{Definition, IdentClass},\n+    defs::{Definition, IdentClass, OperatorClass},\n     famous_defs::FamousDefs,\n     helpers::pick_best_token,\n     FxIndexSet, RootDatabase,\n@@ -101,7 +101,10 @@ pub(crate) fn hover(\n     let offset = range.start();\n \n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 3,\n+        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 4,\n+        // index and prefix ops\n+        T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n+        kind if kind.is_keyword() => 2,\n         T!['('] | T![')'] => 2,\n         kind if kind.is_trivia() => 0,\n         _ => 1,\n@@ -136,6 +139,11 @@ pub(crate) fn hover(\n         .filter_map(|token| {\n             let node = token.parent()?;\n             let class = IdentClass::classify_token(sema, token)?;\n+            if let IdentClass::Operator(OperatorClass::Await(_)) = class {\n+                // It's better for us to fall back to the keyword hover here,\n+                // rendering poll is very confusing\n+                return None;\n+            }\n             Some(class.definitions().into_iter().zip(iter::once(node).cycle()))\n         })\n         .flatten()\n@@ -232,10 +240,12 @@ fn hover_type_fallback(\n     token: &SyntaxToken,\n     original_token: &SyntaxToken,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let node = token\n-        .parent_ancestors()\n-        .take_while(|it| !ast::Item::can_cast(it.kind()))\n-        .find(|n| ast::Expr::can_cast(n.kind()) || ast::Pat::can_cast(n.kind()))?;\n+    let node =\n+        token.parent_ancestors().take_while(|it| !ast::Item::can_cast(it.kind())).find(|n| {\n+            ast::Expr::can_cast(n.kind())\n+                || ast::Pat::can_cast(n.kind())\n+                || ast::Type::can_cast(n.kind())\n+        })?;\n \n     let expr_or_pat = match_ast! {\n         match node {"}, {"sha": "c6274264b8f1a55770cd1a478bc8559a5c7ff9c3", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -5051,3 +5051,37 @@ fn f() {\n             ```\"#]],\n     );\n }\n+\n+#[test]\n+fn hover_deref() {\n+    check(\n+        r#\"\n+//- minicore: deref\n+\n+struct Struct(usize);\n+\n+impl core::ops::Deref for Struct {\n+    type Target = usize;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn f() {\n+    $0*Struct(0);\n+}\n+\"#,\n+        expect![[r#\"\n+            ***\n+\n+            ```rust\n+            test::Struct\n+            ```\n+\n+            ```rust\n+            fn deref(&self) -> &Self::Target\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "ed19784d1fa49d11355835d94be8b83983f75792", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -100,7 +100,7 @@ pub enum InlayTooltip {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Toggle inlay hints*\n+// | VS Code | **rust-analyzer: Toggle inlay hints*\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png[]"}, {"sha": "edc48e84d72528f7ce14d6db2b8f5dc533c9b8ff", "filename": "src/tools/rust-analyzer/crates/ide/src/join_lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -28,7 +28,7 @@ pub struct JoinLinesConfig {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Join lines**\n+// | VS Code | **rust-analyzer: Join lines**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113020661-b6922200-917a-11eb-87c4-b75acc028f11.gif[]"}, {"sha": "6e8a6d020cc7888db3ede65c8e2c5b91fc165b58", "filename": "src/tools/rust-analyzer/crates/ide/src/matching_brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmatching_brace.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -12,7 +12,7 @@ use syntax::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Find matching brace**\n+// | VS Code | **rust-analyzer: Find matching brace**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113065573-04298180-91b1-11eb-8dec-d4e2a202f304.gif[]"}, {"sha": "4f758967b46194538d41c753da10372f997ba7de", "filename": "src/tools/rust-analyzer/crates/ide/src/moniker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmoniker.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn moniker(\n         .descend_into_macros(original_token.clone())\n         .into_iter()\n         .filter_map(|token| {\n-            IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+            IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops).map(|it| {\n                 it.into_iter().flat_map(|def| def_to_moniker(sema.db, def, current_crate))\n             })\n         })"}, {"sha": "ffc4bdd7da33f9453e232518170c2000e06f7e0a", "filename": "src/tools/rust-analyzer/crates/ide/src/move_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmove_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmove_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fmove_item.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -19,8 +19,8 @@ pub enum Direction {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Move item up**\n-// | VS Code | **Rust Analyzer: Move item down**\n+// | VS Code | **rust-analyzer: Move item up**\n+// | VS Code | **rust-analyzer: Move item down**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113065576-04298180-91b1-11eb-91ce-4505e99ed598.gif[]"}, {"sha": "8f3cc86873f5ed06d5325274079e69bfa22f4fca", "filename": "src/tools/rust-analyzer/crates/ide/src/parent_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fparent_module.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -18,7 +18,7 @@ use crate::NavigationTarget;\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Locate parent module**\n+// | VS Code | **rust-analyzer: Locate parent module**\n // |===\n //\n // image::https://user-images.githubusercontent.com/48062697/113065580-04c21800-91b1-11eb-9a32-00086161c0bd.gif[]"}, {"sha": "b0853b10fde2f818d66f0c97d7c83e01ba2e906b", "filename": "src/tools/rust-analyzer/crates/ide/src/runnables.rs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frunnables.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -116,7 +116,7 @@ impl Runnable {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Run**\n+// | VS Code | **rust-analyzer: Run**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065583-055aae80-91b1-11eb-958f-d67efcaf6a2f.gif[]\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n@@ -202,7 +202,7 @@ pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Peek related tests**\n+// | VS Code | **rust-analyzer: Peek related tests**\n // |===\n pub(crate) fn related_tests(\n     db: &RootDatabase,\n@@ -373,11 +373,13 @@ pub(crate) fn runnable_impl(\n     let adt_name = ty.as_adt()?.name(sema.db);\n     let mut ty_args = ty.type_arguments().peekable();\n     let params = if ty_args.peek().is_some() {\n-        format!(\"<{}>\", ty_args.format_with(\", \", |ty, cb| cb(&ty.display(sema.db))))\n+        format!(\"<{}>\", ty_args.format_with(\",\", |ty, cb| cb(&ty.display(sema.db))))\n     } else {\n         String::new()\n     };\n-    let test_id = TestId::Path(format!(\"{}{}\", adt_name, params));\n+    let mut test_id = format!(\"{}{}\", adt_name, params);\n+    test_id.retain(|c| c != ' ');\n+    let test_id = TestId::Path(test_id);\n \n     Some(Runnable { use_name_in_title: false, nav, kind: RunnableKind::DocTest { test_id }, cfg })\n }\n@@ -441,10 +443,11 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n                         format_to!(\n                             path,\n                             \"<{}>\",\n-                            ty_args.format_with(\", \", |ty, cb| cb(&ty.display(db)))\n+                            ty_args.format_with(\",\", |ty, cb| cb(&ty.display(db)))\n                         );\n                     }\n                     format_to!(path, \"::{}\", def_name);\n+                    path.retain(|c| c != ' ');\n                     return Some(path);\n                 }\n             }\n@@ -2067,13 +2070,23 @@ mod tests {\n $0\n struct Foo<T, U>;\n \n+/// ```\n+/// ```\n impl<T, U> Foo<T, U> {\n     /// ```rust\n     /// ````\n     fn t() {}\n }\n+\n+/// ```\n+/// ```\n+impl Foo<Foo<(), ()>, ()> {\n+    /// ```\n+    /// ```\n+    fn t() {}\n+}\n \"#,\n-            &[DocTest],\n+            &[DocTest, DocTest, DocTest, DocTest],\n             expect![[r#\"\n                 [\n                     Runnable {\n@@ -2082,12 +2095,64 @@ impl<T, U> Foo<T, U> {\n                             file_id: FileId(\n                                 0,\n                             ),\n-                            full_range: 47..85,\n+                            full_range: 20..103,\n+                            focus_range: 47..56,\n+                            name: \"impl\",\n+                            kind: Impl,\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Foo<T,U>\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 63..101,\n+                            name: \"t\",\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Foo<T,U>::t\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 105..188,\n+                            focus_range: 126..146,\n+                            name: \"impl\",\n+                            kind: Impl,\n+                        },\n+                        kind: DocTest {\n+                            test_id: Path(\n+                                \"Foo<Foo<(),()>,()>\",\n+                            ),\n+                        },\n+                        cfg: None,\n+                    },\n+                    Runnable {\n+                        use_name_in_title: false,\n+                        nav: NavigationTarget {\n+                            file_id: FileId(\n+                                0,\n+                            ),\n+                            full_range: 153..186,\n                             name: \"t\",\n                         },\n                         kind: DocTest {\n                             test_id: Path(\n-                                \"Foo<T, U>::t\",\n+                                \"Foo<Foo<(),()>,()>::t\",\n                             ),\n                         },\n                         cfg: None,"}, {"sha": "2d86627643d7c8d66c2c84adbc133d0a9c01d813", "filename": "src/tools/rust-analyzer/crates/ide/src/shuffle_crate_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Shuffle Crate Graph**\n+// | VS Code | **rust-analyzer: Shuffle Crate Graph**\n // |===\n pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n     let crate_graph = db.crate_graph();"}, {"sha": "cc79ee55b7dac2be43bf41ae084af390ae198b0e", "filename": "src/tools/rust-analyzer/crates/ide/src/static_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatic_index.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -204,7 +204,7 @@ impl StaticIndex<'_> {\n \n fn get_definition(sema: &Semantics<'_, RootDatabase>, token: SyntaxToken) -> Option<Definition> {\n     for token in sema.descend_into_macros(token) {\n-        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions);\n+        let def = IdentClass::classify_token(sema, &token).map(IdentClass::definitions_no_ops);\n         if let Some(&[x]) = def.as_deref() {\n             return Some(x);\n         } else {"}, {"sha": "32e39f82a0e9f2b6ef870bca1371db19cf319d02", "filename": "src/tools/rust-analyzer/crates/ide/src/status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fstatus.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -29,7 +29,7 @@ fn macro_syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Status**\n+// | VS Code | **rust-analyzer: Status**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065584-05f34500-91b1-11eb-98cc-5c196f76be7f.gif[]\n pub(crate) fn status(db: &RootDatabase, file_id: Option<FileId>) -> String {"}, {"sha": "382735cb368df3cac89ca0bb72559896b944f28c", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -958,7 +958,7 @@ pub struct Struct;\n \n #[test]\n #[cfg_attr(\n-    all(unix, not(target_pointer_width = \"64\")),\n+    not(all(unix, target_pointer_width = \"64\")),\n     ignore = \"depends on `DefaultHasher` outputs\"\n )]\n fn test_rainbow_highlighting() {"}, {"sha": "4256fea0f81e45679ff6567fda769c93c92578eb", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_tree.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -12,7 +12,7 @@ use syntax::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Show Syntax Tree**\n+// | VS Code | **rust-analyzer: Show Syntax Tree**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065586-068bdb80-91b1-11eb-9507-fee67f9f45a0.gif[]\n pub(crate) fn syntax_tree("}, {"sha": "bf7b7efe28228885712908e998c30b31135573d5", "filename": "src/tools/rust-analyzer/crates/ide/src/view_crate_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_crate_graph.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -16,7 +16,7 @@ use ide_db::{\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: View Crate Graph**\n+// | VS Code | **rust-analyzer: View Crate Graph**\n // |===\n pub(crate) fn view_crate_graph(db: &RootDatabase, full: bool) -> Result<String, String> {\n     let crate_graph = db.crate_graph();"}, {"sha": "bf0835ed7e0d3a1f2a5f675e2f67754483e6d5ab", "filename": "src/tools/rust-analyzer/crates/ide/src/view_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_hir.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -8,7 +8,7 @@ use syntax::{algo::find_node_at_offset, ast, AstNode};\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: View Hir**\n+// | VS Code | **rust-analyzer: View Hir**\n // |===\n // image::https://user-images.githubusercontent.com/48062697/113065588-068bdb80-91b1-11eb-9a78-0b4ef1e972fb.gif[]\n pub(crate) fn view_hir(db: &RootDatabase, position: FilePosition) -> String {"}, {"sha": "9c1f93356ee2d0637733ae7f035f230313b0fa76", "filename": "src/tools/rust-analyzer/crates/ide/src/view_item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_item_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_item_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fview_item_tree.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -9,7 +9,7 @@ use ide_db::RootDatabase;\n // |===\n // | Editor  | Action Name\n //\n-// | VS Code | **Rust Analyzer: Debug ItemTree**\n+// | VS Code | **rust-analyzer: Debug ItemTree**\n // |===\n pub(crate) fn view_item_tree(db: &RootDatabase, file_id: FileId) -> String {\n     db.file_item_tree(file_id.into()).pretty_print()"}, {"sha": "6ae23ac841adaa6a7f97d8841c57aec96f2d2439", "filename": "src/tools/rust-analyzer/crates/paths/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fpaths%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -106,6 +106,14 @@ impl AsRef<Path> for AbsPath {\n     }\n }\n \n+impl ToOwned for AbsPath {\n+    type Owned = AbsPathBuf;\n+\n+    fn to_owned(&self) -> Self::Owned {\n+        AbsPathBuf(self.0.to_owned())\n+    }\n+}\n+\n impl<'a> TryFrom<&'a Path> for &'a AbsPath {\n     type Error = &'a Path;\n     fn try_from(path: &'a Path) -> Result<&'a AbsPath, &'a Path> {"}, {"sha": "a3ea05f4aff8e9ca60cc2ca53e4858e0f5e1fe9c", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -60,7 +60,7 @@ impl MacroDylib {\n \n         let info = version::read_dylib_info(&path)?;\n         if info.version.0 < 1 || info.version.1 < 47 {\n-            let msg = format!(\"proc-macro {} built by {:#?} is not supported by Rust Analyzer, please update your rust version.\", path.display(), info);\n+            let msg = format!(\"proc-macro {} built by {:#?} is not supported by rust-analyzer, please update your Rust version.\", path.display(), info);\n             return Err(io::Error::new(io::ErrorKind::InvalidData, msg));\n         }\n "}, {"sha": "705d09ea9458bdad7cb17e87e0a366a17aa2fdae", "filename": "src/tools/rust-analyzer/crates/proc-macro-srv/src/abis/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-srv%2Fsrc%2Fabis%2Fmod.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -5,7 +5,7 @@\n //! compiler into submodules of this module (e.g proc_macro_srv::abis::abi_1_47).\n //!\n //! All of these ABIs are subsumed in the `Abi` enum, which exposes a simple\n-//! interface the rest of rust analyzer can use to talk to the macro\n+//! interface the rest of rust-analyzer can use to talk to the macro\n //! provider.\n //!\n //! # Adding a new ABI"}, {"sha": "eed955b42daae9816c97951a8250571257cd68cd", "filename": "src/tools/rust-analyzer/crates/project-model/src/cargo_workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fcargo_workspace.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -19,7 +19,7 @@ use crate::{utf8_stdout, ManifestPath};\n /// [`CargoWorkspace`] represents the logical structure of, well, a Cargo\n /// workspace. It pretty closely mirrors `cargo metadata` output.\n ///\n-/// Note that internally, rust analyzer uses a different structure:\n+/// Note that internally, rust-analyzer uses a different structure:\n /// `CrateGraph`. `CrateGraph` is lower-level: it knows only about the crates,\n /// while this knows about `Packages` & `Targets`: purely cargo-related\n /// concepts."}, {"sha": "09150c77d7dd1d9de53adaff2a67382132e32711", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::lsp_ext;\n \n-pub(crate) type CheckFixes = Arc<FxHashMap<FileId, Vec<Fix>>>;\n+pub(crate) type CheckFixes = Arc<FxHashMap<usize, FxHashMap<FileId, Vec<Fix>>>>;\n \n #[derive(Debug, Default, Clone)]\n pub struct DiagnosticsMapConfig {\n@@ -22,7 +22,7 @@ pub(crate) struct DiagnosticCollection {\n     // FIXME: should be FxHashMap<FileId, Vec<ra_id::Diagnostic>>\n     pub(crate) native: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n     // FIXME: should be Vec<flycheck::Diagnostic>\n-    pub(crate) check: FxHashMap<FileId, Vec<lsp_types::Diagnostic>>,\n+    pub(crate) check: FxHashMap<usize, FxHashMap<FileId, Vec<lsp_types::Diagnostic>>>,\n     pub(crate) check_fixes: CheckFixes,\n     changes: FxHashSet<FileId>,\n }\n@@ -35,9 +35,19 @@ pub(crate) struct Fix {\n }\n \n impl DiagnosticCollection {\n-    pub(crate) fn clear_check(&mut self) {\n+    pub(crate) fn clear_check(&mut self, flycheck_id: usize) {\n+        if let Some(it) = Arc::make_mut(&mut self.check_fixes).get_mut(&flycheck_id) {\n+            it.clear();\n+        }\n+        if let Some(it) = self.check.get_mut(&flycheck_id) {\n+            self.changes.extend(it.drain().map(|(key, _value)| key));\n+        }\n+    }\n+\n+    pub(crate) fn clear_check_all(&mut self) {\n         Arc::make_mut(&mut self.check_fixes).clear();\n-        self.changes.extend(self.check.drain().map(|(key, _value)| key))\n+        self.changes\n+            .extend(self.check.values_mut().flat_map(|it| it.drain().map(|(key, _value)| key)))\n     }\n \n     pub(crate) fn clear_native_for(&mut self, file_id: FileId) {\n@@ -47,19 +57,20 @@ impl DiagnosticCollection {\n \n     pub(crate) fn add_check_diagnostic(\n         &mut self,\n+        flycheck_id: usize,\n         file_id: FileId,\n         diagnostic: lsp_types::Diagnostic,\n         fix: Option<Fix>,\n     ) {\n-        let diagnostics = self.check.entry(file_id).or_default();\n+        let diagnostics = self.check.entry(flycheck_id).or_default().entry(file_id).or_default();\n         for existing_diagnostic in diagnostics.iter() {\n             if are_diagnostics_equal(existing_diagnostic, &diagnostic) {\n                 return;\n             }\n         }\n \n         let check_fixes = Arc::make_mut(&mut self.check_fixes);\n-        check_fixes.entry(file_id).or_default().extend(fix);\n+        check_fixes.entry(flycheck_id).or_default().entry(file_id).or_default().extend(fix);\n         diagnostics.push(diagnostic);\n         self.changes.insert(file_id);\n     }\n@@ -89,7 +100,8 @@ impl DiagnosticCollection {\n         file_id: FileId,\n     ) -> impl Iterator<Item = &lsp_types::Diagnostic> {\n         let native = self.native.get(&file_id).into_iter().flatten();\n-        let check = self.check.get(&file_id).into_iter().flatten();\n+        let check =\n+            self.check.values().filter_map(move |it| it.get(&file_id)).into_iter().flatten();\n         native.chain(check)\n     }\n "}, {"sha": "b5f6aef2e1a84e60abb268aeebf86bd6be85301c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -8,7 +8,7 @@ use std::{sync::Arc, time::Instant};\n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n use ide::{Analysis, AnalysisHost, Cancellable, Change, FileId};\n-use ide_db::base_db::{CrateId, FileLoader, SourceDatabase};\n+use ide_db::base_db::{CrateId, FileLoader, SourceDatabase, SourceDatabaseExt};\n use lsp_types::{SemanticTokens, Url};\n use parking_lot::{Mutex, RwLock};\n use proc_macro_api::ProcMacroServer;\n@@ -176,7 +176,7 @@ impl GlobalState {\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n         let _p = profile::span(\"GlobalState::process_changes\");\n-        let mut fs_changes = Vec::new();\n+        let mut fs_refresh_changes = Vec::new();\n         // A file was added or deleted\n         let mut has_structure_changes = false;\n \n@@ -192,15 +192,14 @@ impl GlobalState {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();\n                     if reload::should_refresh_for_change(&path, file.change_kind) {\n-                        self.fetch_workspaces_queue\n-                            .request_op(format!(\"vfs file change: {}\", path.display()));\n+                        fs_refresh_changes.push((path, file.file_id));\n                     }\n-                    fs_changes.push((path, file.change_kind));\n                     if file.is_created_or_deleted() {\n                         has_structure_changes = true;\n                     }\n                 }\n \n+                // Clear native diagnostics when their file gets deleted\n                 if !file.exists() {\n                     self.diagnostics.clear_native_for(file.file_id);\n                 }\n@@ -226,14 +225,25 @@ impl GlobalState {\n \n         self.analysis_host.apply_change(change);\n \n-        let raw_database = &self.analysis_host.raw_database();\n-        self.proc_macro_changed =\n-            changed_files.iter().filter(|file| !file.is_created_or_deleted()).any(|file| {\n-                let crates = raw_database.relevant_crates(file.file_id);\n-                let crate_graph = raw_database.crate_graph();\n+        {\n+            let raw_database = self.analysis_host.raw_database();\n+            let workspace_structure_change =\n+                fs_refresh_changes.into_iter().find(|&(_, file_id)| {\n+                    !raw_database.source_root(raw_database.file_source_root(file_id)).is_library\n+                });\n+            if let Some((path, _)) = workspace_structure_change {\n+                self.fetch_workspaces_queue\n+                    .request_op(format!(\"workspace vfs file change: {}\", path.display()));\n+            }\n+            self.proc_macro_changed =\n+                changed_files.iter().filter(|file| !file.is_created_or_deleted()).any(|file| {\n+                    let crates = raw_database.relevant_crates(file.file_id);\n+                    let crate_graph = raw_database.crate_graph();\n+\n+                    crates.iter().any(|&krate| crate_graph[krate].is_proc_macro)\n+                });\n+        }\n \n-                crates.iter().any(|&krate| crate_graph[krate].is_proc_macro)\n-            });\n         true\n     }\n "}, {"sha": "47daa732d5d3254ab779a9af4ae2091697c0bd13", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1094,7 +1094,9 @@ pub(crate) fn handle_code_action(\n     }\n \n     // Fixes from `cargo check`.\n-    for fix in snap.check_fixes.get(&frange.file_id).into_iter().flatten() {\n+    for fix in\n+        snap.check_fixes.values().filter_map(|it| it.get(&frange.file_id)).into_iter().flatten()\n+    {\n         // FIXME: this mapping is awkward and shouldn't exist. Refactor\n         // `snap.check_fixes` to not convert to LSP prematurely.\n         let intersect_fix_range = fix"}, {"sha": "e49a98685a7f11302fbaff40afe55d36c3719355", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/integrated_benchmarks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fintegrated_benchmarks.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -6,8 +6,8 @@\n //! code here exercise this specific completion, and thus have a fast\n //! edit/compile/test cycle.\n //!\n-//! Note that \"Rust Analyzer: Run\" action does not allow running a single test\n-//! in release mode in VS Code. There's however \"Rust Analyzer: Copy Run Command Line\"\n+//! Note that \"rust-analyzer: Run\" action does not allow running a single test\n+//! in release mode in VS Code. There's however \"rust-analyzer: Copy Run Command Line\"\n //! which you can use to paste the command in terminal and add `--release` manually.\n \n use std::sync::Arc;"}, {"sha": "b504c248782667752c8adfb5f10d8cbe1ecef11a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -2,13 +2,15 @@\n //! requests/replies and notifications back to the client.\n use std::{\n     fmt,\n+    ops::Deref,\n     sync::Arc,\n     time::{Duration, Instant},\n };\n \n use always_assert::always;\n use crossbeam_channel::{select, Receiver};\n-use ide_db::base_db::{SourceDatabaseExt, VfsPath};\n+use ide_db::base_db::{SourceDatabase, SourceDatabaseExt, VfsPath};\n+use itertools::Itertools;\n use lsp_server::{Connection, Notification, Request};\n use lsp_types::notification::Notification as _;\n use vfs::{ChangeKind, FileId};\n@@ -371,7 +373,7 @@ impl GlobalState {\n                 let _p = profile::span(\"GlobalState::handle_event/flycheck\");\n                 loop {\n                     match task {\n-                        flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n+                        flycheck::Message::AddDiagnostic { id, workspace_root, diagnostic } => {\n                             let snap = self.snapshot();\n                             let diagnostics =\n                                 crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n@@ -383,6 +385,7 @@ impl GlobalState {\n                             for diag in diagnostics {\n                                 match url_to_file_id(&self.vfs.read().0, &diag.url) {\n                                     Ok(file_id) => self.diagnostics.add_check_diagnostic(\n+                                        id,\n                                         file_id,\n                                         diag.diagnostic,\n                                         diag.fix,\n@@ -400,7 +403,7 @@ impl GlobalState {\n                         flycheck::Message::Progress { id, progress } => {\n                             let (state, message) = match progress {\n                                 flycheck::Progress::DidStart => {\n-                                    self.diagnostics.clear_check();\n+                                    self.diagnostics.clear_check(id);\n                                     (Progress::Begin, None)\n                                 }\n                                 flycheck::Progress::DidCheckCrate(target) => {\n@@ -444,7 +447,10 @@ impl GlobalState {\n         let memdocs_added_or_removed = self.mem_docs.take_changes();\n \n         if self.is_quiescent() {\n-            if !was_quiescent {\n+            if !was_quiescent\n+                && !self.fetch_workspaces_queue.op_requested()\n+                && !self.fetch_build_data_queue.op_requested()\n+            {\n                 for flycheck in &self.flycheck {\n                     flycheck.update();\n                 }\n@@ -734,13 +740,76 @@ impl GlobalState {\n                 Ok(())\n             })?\n             .on::<lsp_types::notification::DidSaveTextDocument>(|this, params| {\n-                for flycheck in &this.flycheck {\n-                    flycheck.update();\n+                let mut updated = false;\n+                if let Ok(vfs_path) = from_proto::vfs_path(&params.text_document.uri) {\n+                    let (vfs, _) = &*this.vfs.read();\n+                    if let Some(file_id) = vfs.file_id(&vfs_path) {\n+                        let analysis = this.analysis_host.analysis();\n+                        // Crates containing or depending on the saved file\n+                        let crate_ids: Vec<_> = analysis\n+                            .crate_for(file_id)?\n+                            .into_iter()\n+                            .flat_map(|id| {\n+                                this.analysis_host\n+                                    .raw_database()\n+                                    .crate_graph()\n+                                    .transitive_rev_deps(id)\n+                            })\n+                            .sorted()\n+                            .unique()\n+                            .collect();\n+\n+                        let crate_root_paths: Vec<_> = crate_ids\n+                            .iter()\n+                            .filter_map(|&crate_id| {\n+                                analysis\n+                                    .crate_root(crate_id)\n+                                    .map(|file_id| {\n+                                        vfs.file_path(file_id).as_path().map(ToOwned::to_owned)\n+                                    })\n+                                    .transpose()\n+                            })\n+                            .collect::<ide::Cancellable<_>>()?;\n+                        let crate_root_paths: Vec<_> =\n+                            crate_root_paths.iter().map(Deref::deref).collect();\n+\n+                        // Find all workspaces that have at least one target containing the saved file\n+                        let workspace_ids =\n+                            this.workspaces.iter().enumerate().filter(|(_, ws)| match ws {\n+                                project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+                                    cargo.packages().any(|pkg| {\n+                                        cargo[pkg].targets.iter().any(|&it| {\n+                                            crate_root_paths.contains(&cargo[it].root.as_path())\n+                                        })\n+                                    })\n+                                }\n+                                project_model::ProjectWorkspace::Json { project, .. } => project\n+                                    .crates()\n+                                    .any(|(c, _)| crate_ids.iter().any(|&crate_id| crate_id == c)),\n+                                project_model::ProjectWorkspace::DetachedFiles { .. } => false,\n+                            });\n+\n+                        // Find and trigger corresponding flychecks\n+                        for flycheck in &this.flycheck {\n+                            for (id, _) in workspace_ids.clone() {\n+                                if id == flycheck.id() {\n+                                    updated = true;\n+                                    flycheck.update();\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if let Some(abs_path) = vfs_path.as_path() {\n+                        if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n+                            this.fetch_workspaces_queue\n+                                .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n+                        }\n+                    }\n                 }\n-                if let Ok(abs_path) = from_proto::abs_path(&params.text_document.uri) {\n-                    if reload::should_refresh_for_change(&abs_path, ChangeKind::Modify) {\n-                        this.fetch_workspaces_queue\n-                            .request_op(format!(\"DidSaveTextDocument {}\", abs_path.display()));\n+                if !updated {\n+                    for flycheck in &this.flycheck {\n+                        flycheck.update();\n                     }\n                 }\n                 Ok(())"}, {"sha": "49ccad71a10e851e0cdcac2aeadab773f2171f7b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -196,10 +196,7 @@ impl GlobalState {\n         }\n \n         if let Err(error) = self.fetch_build_data_error() {\n-            self.show_and_log_error(\n-                \"rust-analyzer failed to run build scripts\".to_string(),\n-                Some(error),\n-            );\n+            self.show_and_log_error(\"failed to run build scripts\".to_string(), Some(error));\n         }\n \n         let workspaces = self\n@@ -308,6 +305,7 @@ impl GlobalState {\n \n         if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n+                tracing::info!(\"Spawning proc-macro servers\");\n                 self.proc_macro_clients = self\n                     .workspaces\n                     .iter()\n@@ -316,35 +314,31 @@ impl GlobalState {\n                         let mut path = path.clone();\n \n                         if let ProjectWorkspace::Cargo { sysroot, .. } = ws {\n-                            tracing::info!(\"Found a cargo workspace...\");\n+                            tracing::debug!(\"Found a cargo workspace...\");\n                             if let Some(sysroot) = sysroot.as_ref() {\n-                                tracing::info!(\"Found a cargo workspace with a sysroot...\");\n+                                tracing::debug!(\"Found a cargo workspace with a sysroot...\");\n                                 let server_path =\n                                     sysroot.root().join(\"libexec\").join(&standalone_server_name);\n                                 if std::fs::metadata(&server_path).is_ok() {\n-                                    tracing::info!(\n+                                    tracing::debug!(\n                                         \"And the server exists at {}\",\n                                         server_path.display()\n                                     );\n                                     path = server_path;\n                                     args = vec![];\n                                 } else {\n-                                    tracing::info!(\n+                                    tracing::debug!(\n                                         \"And the server does not exist at {}\",\n                                         server_path.display()\n                                     );\n                                 }\n                             }\n                         }\n \n-                        tracing::info!(\n-                            \"Using proc-macro server at {} with args {:?}\",\n-                            path.display(),\n-                            args\n-                        );\n+                        tracing::info!(?args, \"Using proc-macro server at {}\", path.display(),);\n                         ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n                             let error = format!(\n-                                \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n+                                \"Failed to run proc-macro server from path {}, error: {:?}\",\n                                 path.display(),\n                                 err\n                             );\n@@ -458,7 +452,7 @@ impl GlobalState {\n             Some(it) => it,\n             None => {\n                 self.flycheck = Vec::new();\n-                self.diagnostics.clear_check();\n+                self.diagnostics.clear_check_all();\n                 return;\n             }\n         };\n@@ -621,7 +615,10 @@ pub(crate) fn load_proc_macro(\n         };\n         let expander: Arc<dyn ProcMacroExpander> =\n             if dummy_replace.iter().any(|replace| &**replace == name) {\n-                Arc::new(DummyExpander)\n+                match kind {\n+                    ProcMacroKind::Attr => Arc::new(IdentityExpander),\n+                    _ => Arc::new(EmptyExpander),\n+                }\n             } else {\n                 Arc::new(Expander(expander))\n             };\n@@ -647,11 +644,11 @@ pub(crate) fn load_proc_macro(\n         }\n     }\n \n-    /// Dummy identity expander, used for proc-macros that are deliberately ignored by the user.\n+    /// Dummy identity expander, used for attribute proc-macros that are deliberately ignored by the user.\n     #[derive(Debug)]\n-    struct DummyExpander;\n+    struct IdentityExpander;\n \n-    impl ProcMacroExpander for DummyExpander {\n+    impl ProcMacroExpander for IdentityExpander {\n         fn expand(\n             &self,\n             subtree: &tt::Subtree,\n@@ -661,27 +658,46 @@ pub(crate) fn load_proc_macro(\n             Ok(subtree.clone())\n         }\n     }\n+\n+    /// Empty expander, used for proc-macros that are deliberately ignored by the user.\n+    #[derive(Debug)]\n+    struct EmptyExpander;\n+\n+    impl ProcMacroExpander for EmptyExpander {\n+        fn expand(\n+            &self,\n+            _: &tt::Subtree,\n+            _: Option<&tt::Subtree>,\n+            _: &Env,\n+        ) -> Result<tt::Subtree, ProcMacroExpansionError> {\n+            Ok(tt::Subtree::default())\n+        }\n+    }\n }\n \n pub(crate) fn should_refresh_for_change(path: &AbsPath, change_kind: ChangeKind) -> bool {\n     const IMPLICIT_TARGET_FILES: &[&str] = &[\"build.rs\", \"src/main.rs\", \"src/lib.rs\"];\n     const IMPLICIT_TARGET_DIRS: &[&str] = &[\"src/bin\", \"examples\", \"tests\", \"benches\"];\n-    let file_name = path.file_name().unwrap_or_default();\n \n-    if file_name == \"Cargo.toml\" || file_name == \"Cargo.lock\" {\n+    let file_name = match path.file_name().unwrap_or_default().to_str() {\n+        Some(it) => it,\n+        None => return false,\n+    };\n+\n+    if let \"Cargo.toml\" | \"Cargo.lock\" = file_name {\n         return true;\n     }\n     if change_kind == ChangeKind::Modify {\n         return false;\n     }\n+\n+    // .cargo/config{.toml}\n     if path.extension().unwrap_or_default() != \"rs\" {\n-        if (file_name == \"config.toml\" || file_name == \"config\")\n-            && path.parent().map(|parent| parent.as_ref().ends_with(\".cargo\")) == Some(true)\n-        {\n-            return true;\n-        }\n-        return false;\n+        let is_cargo_config = matches!(file_name, \"config.toml\" | \"config\")\n+            && path.parent().map(|parent| parent.as_ref().ends_with(\".cargo\")).unwrap_or(false);\n+        return is_cargo_config;\n     }\n+\n     if IMPLICIT_TARGET_FILES.iter().any(|it| path.as_ref().ends_with(it)) {\n         return true;\n     }"}, {"sha": "58099a58de053acb0506bfc61a77b264a987e6dd", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -13,19 +13,18 @@ use xshell::cmd;\n fn check_code_formatting() {\n     let sh = &Shell::new().unwrap();\n     sh.change_dir(sourcegen::project_root());\n-    sh.set_var(\"RUSTUP_TOOLCHAIN\", \"stable\");\n \n-    let out = cmd!(sh, \"rustfmt --version\").read().unwrap();\n+    let out = cmd!(sh, \"rustup run stable rustfmt --version\").read().unwrap();\n     if !out.contains(\"stable\") {\n         panic!(\n             \"Failed to run rustfmt from toolchain 'stable'. \\\n                  Please run `rustup component add rustfmt --toolchain stable` to install it.\",\n         )\n     }\n \n-    let res = cmd!(sh, \"cargo fmt -- --check\").run();\n+    let res = cmd!(sh, \"rustup run stable cargo fmt -- --check\").run();\n     if res.is_err() {\n-        let _ = cmd!(sh, \"cargo fmt\").run();\n+        let _ = cmd!(sh, \"rustup run stable cargo fmt\").run();\n     }\n     res.unwrap()\n }"}, {"sha": "4e0ee63f32f26a2e7ce56b832325e223bb0233b7", "filename": "src/tools/rust-analyzer/crates/sourcegen/src/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsourcegen%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -136,7 +136,7 @@ impl fmt::Display for Location {\n }\n \n fn ensure_rustfmt(sh: &Shell) {\n-    let version = cmd!(sh, \"rustfmt --version\").read().unwrap_or_default();\n+    let version = cmd!(sh, \"rustup run stable rustfmt --version\").read().unwrap_or_default();\n     if !version.contains(\"stable\") {\n         panic!(\n             \"Failed to run rustfmt from toolchain 'stable'. \\\n@@ -147,13 +147,15 @@ fn ensure_rustfmt(sh: &Shell) {\n \n pub fn reformat(text: String) -> String {\n     let sh = Shell::new().unwrap();\n-    sh.set_var(\"RUSTUP_TOOLCHAIN\", \"stable\");\n     ensure_rustfmt(&sh);\n     let rustfmt_toml = project_root().join(\"rustfmt.toml\");\n-    let mut stdout = cmd!(sh, \"rustfmt --config-path {rustfmt_toml} --config fn_single_line=true\")\n-        .stdin(text)\n-        .read()\n-        .unwrap();\n+    let mut stdout = cmd!(\n+        sh,\n+        \"rustup run stable rustfmt --config-path {rustfmt_toml} --config fn_single_line=true\"\n+    )\n+    .stdin(text)\n+    .read()\n+    .unwrap();\n     if !stdout.ends_with('\\n') {\n         stdout.push('\\n');\n     }"}, {"sha": "8efd58e2c39aa48c098844ad853a30993d314f42", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 144, "deletions": 27, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     ted::{self, Position},\n     AstNode, AstToken, Direction,\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n-    SyntaxNode,\n+    SyntaxNode, SyntaxToken,\n };\n \n use super::HasName;\n@@ -506,19 +506,7 @@ impl ast::RecordExprFieldList {\n \n         let position = match self.fields().last() {\n             Some(last_field) => {\n-                let comma = match last_field\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .filter_map(|it| it.into_token())\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    Some(it) => it,\n-                    None => {\n-                        let comma = ast::make::token(T![,]);\n-                        ted::insert(Position::after(last_field.syntax()), &comma);\n-                        comma\n-                    }\n-                };\n+                let comma = get_or_insert_comma_after(last_field.syntax());\n                 Position::after(comma)\n             }\n             None => match self.l_curly_token() {\n@@ -579,19 +567,8 @@ impl ast::RecordPatFieldList {\n \n         let position = match self.fields().last() {\n             Some(last_field) => {\n-                let comma = match last_field\n-                    .syntax()\n-                    .siblings_with_tokens(Direction::Next)\n-                    .filter_map(|it| it.into_token())\n-                    .find(|it| it.kind() == T![,])\n-                {\n-                    Some(it) => it,\n-                    None => {\n-                        let comma = ast::make::token(T![,]);\n-                        ted::insert(Position::after(last_field.syntax()), &comma);\n-                        comma\n-                    }\n-                };\n+                let syntax = last_field.syntax();\n+                let comma = get_or_insert_comma_after(syntax);\n                 Position::after(comma)\n             }\n             None => match self.l_curly_token() {\n@@ -606,12 +583,53 @@ impl ast::RecordPatFieldList {\n         }\n     }\n }\n+\n+fn get_or_insert_comma_after(syntax: &SyntaxNode) -> SyntaxToken {\n+    let comma = match syntax\n+        .siblings_with_tokens(Direction::Next)\n+        .filter_map(|it| it.into_token())\n+        .find(|it| it.kind() == T![,])\n+    {\n+        Some(it) => it,\n+        None => {\n+            let comma = ast::make::token(T![,]);\n+            ted::insert(Position::after(syntax), &comma);\n+            comma\n+        }\n+    };\n+    comma\n+}\n+\n impl ast::StmtList {\n     pub fn push_front(&self, statement: ast::Stmt) {\n         ted::insert(Position::after(self.l_curly_token().unwrap()), statement.syntax());\n     }\n }\n \n+impl ast::VariantList {\n+    pub fn add_variant(&self, variant: ast::Variant) {\n+        let (indent, position) = match self.variants().last() {\n+            Some(last_item) => (\n+                IndentLevel::from_node(last_item.syntax()),\n+                Position::after(get_or_insert_comma_after(last_item.syntax())),\n+            ),\n+            None => match self.l_curly_token() {\n+                Some(l_curly) => {\n+                    normalize_ws_between_braces(self.syntax());\n+                    (IndentLevel::from_token(&l_curly) + 1, Position::after(&l_curly))\n+                }\n+                None => (IndentLevel::single(), Position::last_child_of(self.syntax())),\n+            },\n+        };\n+        let elements: Vec<SyntaxElement<_>> = vec![\n+            make::tokens::whitespace(&format!(\"{}{}\", \"\\n\", indent)).into(),\n+            variant.syntax().clone().into(),\n+            ast::make::token(T![,]).into(),\n+        ];\n+        ted::insert_all(position, elements);\n+    }\n+}\n+\n fn normalize_ws_between_braces(node: &SyntaxNode) -> Option<()> {\n     let l = node\n         .children_with_tokens()\n@@ -661,6 +679,9 @@ impl<N: AstNode + Clone> Indent for N {}\n mod tests {\n     use std::fmt;\n \n+    use stdx::trim_indent;\n+    use test_utils::assert_eq_text;\n+\n     use crate::SourceFile;\n \n     use super::*;\n@@ -714,4 +735,100 @@ mod tests {\n         }\",\n         );\n     }\n+\n+    #[test]\n+    fn add_variant_to_empty_enum() {\n+        let variant = make::variant(make::name(\"Bar\"), None).clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_to_non_empty_enum() {\n+        let variant = make::variant(make::name(\"Baz\"), None).clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_with_tuple_field_list() {\n+        let variant = make::variant(\n+            make::name(\"Baz\"),\n+            Some(ast::FieldList::TupleFieldList(make::tuple_field_list(std::iter::once(\n+                make::tuple_field(None, make::ty(\"bool\")),\n+            )))),\n+        )\n+        .clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz(bool),\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_variant_with_record_field_list() {\n+        let variant = make::variant(\n+            make::name(\"Baz\"),\n+            Some(ast::FieldList::RecordFieldList(make::record_field_list(std::iter::once(\n+                make::record_field(None, make::name(\"x\"), make::ty(\"bool\")),\n+            )))),\n+        )\n+        .clone_for_update();\n+\n+        check_add_variant(\n+            r#\"\n+enum Foo {\n+    Bar,\n+}\n+\"#,\n+            r#\"\n+enum Foo {\n+    Bar,\n+    Baz { x: bool },\n+}\n+\"#,\n+            variant,\n+        );\n+    }\n+\n+    fn check_add_variant(before: &str, expected: &str, variant: ast::Variant) {\n+        let enum_ = ast_mut_from_text::<ast::Enum>(before);\n+        enum_.variant_list().map(|it| it.add_variant(variant));\n+        let after = enum_.to_string();\n+        assert_eq_text!(&trim_indent(expected.trim()), &trim_indent(&after.trim()));\n+    }\n }"}, {"sha": "037de876d45c94f16955502621129bc2872b2b85", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -745,7 +745,10 @@ pub fn tuple_field(visibility: Option<ast::Visibility>, ty: ast::Type) -> ast::T\n pub fn variant(name: ast::Name, field_list: Option<ast::FieldList>) -> ast::Variant {\n     let field_list = match field_list {\n         None => String::new(),\n-        Some(it) => format!(\"{}\", it),\n+        Some(it) => match it {\n+            ast::FieldList::RecordFieldList(record) => format!(\" {}\", record),\n+            ast::FieldList::TupleFieldList(tuple) => format!(\"{}\", tuple),\n+        },\n     };\n     ast_from_text(&format!(\"enum f {{ {}{} }}\", name, field_list))\n }"}, {"sha": "4f5e273a520a14212256f1ac7a898b354e942216", "filename": "src/tools/rust-analyzer/crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -1,4 +1,4 @@\n-//! Syntax Tree library used throughout the rust analyzer.\n+//! Syntax Tree library used throughout the rust-analyzer.\n //!\n //! Properties:\n //!   - easy and fast incremental re-parsing"}, {"sha": "d6d9c66159fe1fa624c742d69a9ecfbbd3918de2", "filename": "src/tools/rust-analyzer/crates/vfs-notify/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -40,12 +40,15 @@ impl loader::Handle for NotifyHandle {\n             .expect(\"failed to spawn thread\");\n         NotifyHandle { sender, _thread: thread }\n     }\n+\n     fn set_config(&mut self, config: loader::Config) {\n         self.sender.send(Message::Config(config)).unwrap();\n     }\n+\n     fn invalidate(&mut self, path: AbsPathBuf) {\n         self.sender.send(Message::Invalidate(path)).unwrap();\n     }\n+\n     fn load_sync(&mut self, path: &AbsPath) -> Option<Vec<u8>> {\n         read(path)\n     }\n@@ -70,16 +73,18 @@ impl NotifyActor {\n     fn new(sender: loader::Sender) -> NotifyActor {\n         NotifyActor { sender, watched_entries: Vec::new(), watcher: None }\n     }\n+\n     fn next_event(&self, receiver: &Receiver<Message>) -> Option<Event> {\n         let watcher_receiver = self.watcher.as_ref().map(|(_, receiver)| receiver);\n         select! {\n             recv(receiver) -> it => it.ok().map(Event::Message),\n             recv(watcher_receiver.unwrap_or(&never())) -> it => Some(Event::NotifyEvent(it.unwrap())),\n         }\n     }\n+\n     fn run(mut self, inbox: Receiver<Message>) {\n         while let Some(event) = self.next_event(&inbox) {\n-            tracing::debug!(\"vfs-notify event: {:?}\", event);\n+            tracing::debug!(?event, \"vfs-notify event\");\n             match event {\n                 Event::Message(msg) => match msg {\n                     Message::Config(config) => {"}, {"sha": "c7f152acc26690ecce60fdb3a9a15313e2d22ed7", "filename": "src/tools/rust-analyzer/docs/dev/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2FREADME.md?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -82,7 +82,7 @@ There's **\"Run Extension (Debug Build)\"** launch configuration for this in VS Co\n In general, I use one of the following workflows for fixing bugs and implementing features:\n \n If the problem concerns only internal parts of rust-analyzer (i.e. I don't need to touch the `rust-analyzer` crate or TypeScript code), there is a unit-test for it.\n-So, I use **Rust Analyzer: Run** action in VS Code to run this single test, and then just do printf-driven development/debugging.\n+So, I use **rust-analyzer: Run** action in VS Code to run this single test, and then just do printf-driven development/debugging.\n As a sanity check after I'm done, I use `cargo xtask install --server` and **Reload Window** action in VS Code to verify that the thing works as I expect.\n \n If the problem concerns only the VS Code extension, I use **Run Installed Extension** launch configuration from `launch.json`.\n@@ -152,11 +152,11 @@ To log all communication between the server and the client, there are two choice\n \n There are also several VS Code commands which might be of interest:\n \n-* `Rust Analyzer: Status` shows some memory-usage statistics.\n+* `rust-analyzer: Status` shows some memory-usage statistics.\n \n-* `Rust Analyzer: Syntax Tree` shows syntax tree of the current file/selection.\n+* `rust-analyzer: Syntax Tree` shows syntax tree of the current file/selection.\n \n-* `Rust Analyzer: View Hir` shows the HIR expressions within the function containing the cursor.\n+* `rust-analyzer: View Hir` shows the HIR expressions within the function containing the cursor.\n \n   You can hover over syntax nodes in the opened text file to see the appropriate\n   rust code that it refers to and the rust editor will also highlight the proper"}, {"sha": "51e26c58a9175d4c8c17efa58df77249a73860cd", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -371,7 +371,7 @@ That is, rust-analyzer requires unwinding.\n \n ### Testing\n \n-Rust Analyzer has three interesting [system boundaries](https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html) to concentrate tests on.\n+rust-analyzer has three interesting [system boundaries](https://www.tedinski.com/2018/04/10/making-tests-a-positive-influence-on-design.html) to concentrate tests on.\n \n The outermost boundary is the `rust-analyzer` crate, which defines an LSP interface in terms of stdio.\n We do integration testing of this component, by feeding it with a stream of LSP requests and checking responses."}, {"sha": "808eb5d10bf4acb80fff8f02f7ba8c2b797b2175", "filename": "src/tools/rust-analyzer/docs/dev/guide.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -63,7 +63,7 @@ Next, let's talk about what the inputs to the `Analysis` are, precisely.\n \n ## Inputs\n \n-Rust Analyzer never does any I/O itself, all inputs get passed explicitly via\n+rust-analyzer never does any I/O itself, all inputs get passed explicitly via\n the `AnalysisHost::apply_change` method, which accepts a single argument, a\n `Change`. [`Change`] is a builder for a single change\n \"transaction\", so it suffices to study its methods to understand all of the"}, {"sha": "c482fcbed0e01ccea9ab998dad16a7649f6fb61a", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -479,7 +479,7 @@ You can follow instructions for installing <<rust-analyzer-language-server-binar\n == Troubleshooting\n \n Start with looking at the rust-analyzer version.\n-Try **Rust Analyzer: Show RA Version** in VS Code (using **Command Palette** feature typically activated by Ctrl+Shift+P) or `rust-analyzer --version` in the command line.\n+Try **rust-analyzer: Show RA Version** in VS Code (using **Command Palette** feature typically activated by Ctrl+Shift+P) or `rust-analyzer --version` in the command line.\n If the date is more than a week ago, it's better to update rust-analyzer version.\n \n The next thing to check would be panic messages in rust-analyzer's log.\n@@ -492,7 +492,7 @@ To fully capture LSP messages between the editor and the server, set `\"rust-anal\n The root cause for many \"`nothing works`\" problems is that rust-analyzer fails to understand the project structure.\n To debug that, first note the `rust-analyzer` section in the status bar.\n If it has an error icon and red, that's the problem (hover will have somewhat helpful error message).\n-**Rust Analyzer: Status** prints dependency information for the current file.\n+**rust-analyzer: Status** prints dependency information for the current file.\n Finally, `RA_LOG=project_model=debug` enables verbose logs during project loading.\n \n If rust-analyzer outright crashes, try running `rust-analyzer analysis-stats /path/to/project/directory/` on the command line."}, {"sha": "fbdc69c80137646c98187022e39030e4a791762d", "filename": "src/tools/rust-analyzer/editors/code/package.json", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fpackage.json?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -99,142 +99,142 @@\n             {\n                 \"command\": \"rust-analyzer.syntaxTree\",\n                 \"title\": \"Show Syntax Tree\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewHir\",\n                 \"title\": \"View Hir\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewFileText\",\n                 \"title\": \"View File Text (as seen by the server)\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewItemTree\",\n                 \"title\": \"Debug ItemTree\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewCrateGraph\",\n                 \"title\": \"View Crate Graph\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewFullCrateGraph\",\n                 \"title\": \"View Crate Graph (Full)\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.expandMacro\",\n                 \"title\": \"Expand macro recursively\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.matchingBrace\",\n                 \"title\": \"Find matching brace\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.parentModule\",\n                 \"title\": \"Locate parent module\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.joinLines\",\n                 \"title\": \"Join lines\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.run\",\n                 \"title\": \"Run\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.copyRunCommandLine\",\n                 \"title\": \"Copy Run Command Line\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.debug\",\n                 \"title\": \"Debug\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.newDebugConfig\",\n                 \"title\": \"Generate launch configuration\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.analyzerStatus\",\n                 \"title\": \"Status\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.memoryUsage\",\n                 \"title\": \"Memory Usage (Clears Database)\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.shuffleCrateGraph\",\n                 \"title\": \"Shuffle Crate Graph\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.reloadWorkspace\",\n                 \"title\": \"Reload workspace\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.reload\",\n                 \"title\": \"Restart server\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.onEnter\",\n                 \"title\": \"Enhanced enter key\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.ssr\",\n                 \"title\": \"Structural Search Replace\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.serverVersion\",\n                 \"title\": \"Show RA Version\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.toggleInlayHints\",\n                 \"title\": \"Toggle inlay hints\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.openDocs\",\n                 \"title\": \"Open docs under cursor\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.openCargoToml\",\n                 \"title\": \"Open Cargo.toml\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.peekTests\",\n                 \"title\": \"Peek related tests\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.moveItemUp\",\n                 \"title\": \"Move item up\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             },\n             {\n                 \"command\": \"rust-analyzer.moveItemDown\",\n                 \"title\": \"Move item down\",\n-                \"category\": \"Rust Analyzer\"\n+                \"category\": \"rust-analyzer\"\n             }\n         ],\n         \"keybindings\": [\n@@ -256,7 +256,7 @@\n         ],\n         \"configuration\": {\n             \"type\": \"object\",\n-            \"title\": \"Rust Analyzer\",\n+            \"title\": \"rust-analyzer\",\n             \"properties\": {\n                 \"rust-analyzer.cargoRunner\": {\n                     \"type\": [\n@@ -380,6 +380,11 @@\n                     \"default\": false,\n                     \"type\": \"boolean\"\n                 },\n+                \"rust-analyzer.typing.continueCommentsOnNewline\": {\n+                    \"markdownDescription\": \"Whether to prefix newlines after comments with the corresponding comment prefix.\",\n+                    \"default\": true,\n+                    \"type\": \"boolean\"\n+                },\n                 \"$generated-start\": {},\n                 \"rust-analyzer.assist.expressionFillDefault\": {\n                     \"markdownDescription\": \"Placeholder expression to use for missing expressions in assists.\","}, {"sha": "1c58040d58c2b4cc4d493937d8200135d4652fa7", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -16,9 +16,13 @@ export class Config {\n     readonly extensionId = \"rust-lang.rust-analyzer\";\n \n     readonly rootSection = \"rust-analyzer\";\n-    private readonly requiresWorkspaceReloadOpts = [\"serverPath\", \"server\"].map(\n-        (opt) => `${this.rootSection}.${opt}`\n-    );\n+    private readonly requiresWorkspaceReloadOpts = [\n+        \"serverPath\",\n+        \"server\",\n+        // FIXME: This shouldn't be here, changing this setting should reload\n+        // `continueCommentsOnNewline` behavior without restart\n+        \"typing\",\n+    ].map((opt) => `${this.rootSection}.${opt}`);\n     private readonly requiresReloadOpts = [\n         \"cargo\",\n         \"procMacro\",\n@@ -140,6 +144,10 @@ export class Config {\n         return this.get<boolean>(\"restartServerOnConfigChange\");\n     }\n \n+    get typingContinueCommentsOnNewline() {\n+        return this.get<boolean>(\"typing.continueCommentsOnNewline\");\n+    }\n+\n     get debug() {\n         let sourceFileMap = this.get<Record<string, string> | \"auto\">(\"debug.sourceFileMap\");\n         if (sourceFileMap !== \"auto\") {"}, {"sha": "d78b711a47a8f76628569026bcf8a961367c8ab1", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -84,7 +84,9 @@ async function tryActivate(context: vscode.ExtensionContext): Promise<RustAnalyz\n \n     warnAboutExtensionConflicts();\n \n-    ctx.pushCleanup(configureLanguage());\n+    if (config.typingContinueCommentsOnNewline) {\n+        ctx.pushCleanup(configureLanguage());\n+    }\n \n     vscode.workspace.onDidChangeConfiguration(\n         (_) =>"}, {"sha": "a3fe59e946ee9be8e60789c8b016d8231c9c48b4", "filename": "src/tools/rust-analyzer/lib/la-arena/src/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -12,7 +12,7 @@ use std::{\n };\n \n mod map;\n-pub use map::ArenaMap;\n+pub use map::{ArenaMap, Entry, OccupiedEntry, VacantEntry};\n \n /// The raw index of a value in an arena.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -208,6 +208,16 @@ impl<T> Arena<T> {\n         Arena { data: Vec::new() }\n     }\n \n+    /// Create a new empty arena with specific capacity.\n+    ///\n+    /// ```\n+    /// let arena: la_arena::Arena<i32> = la_arena::Arena::with_capacity(42);\n+    /// assert!(arena.is_empty());\n+    /// ```\n+    pub fn with_capacity(capacity: usize) -> Arena<T> {\n+        Arena { data: Vec::with_capacity(capacity) }\n+    }\n+\n     /// Empties the arena, removing all contained values.\n     ///\n     /// ```"}, {"sha": "5f347e274500eefe7b5fcf0cda0b5d281cf8c040", "filename": "src/tools/rust-analyzer/lib/la-arena/src/map.rs", "status": "modified", "additions": 166, "deletions": 3, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Fmap.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -11,12 +11,52 @@ pub struct ArenaMap<IDX, V> {\n }\n \n impl<T, V> ArenaMap<Idx<T>, V> {\n+    /// Creates a new empty map.\n+    pub const fn new() -> Self {\n+        Self { v: Vec::new(), _ty: PhantomData }\n+    }\n+\n+    /// Create a new empty map with specific capacity.\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        Self { v: Vec::with_capacity(capacity), _ty: PhantomData }\n+    }\n+\n+    /// Reserves capacity for at least additional more elements to be inserted in the map.\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.v.reserve(additional);\n+    }\n+\n+    /// Clears the map, removing all elements.\n+    pub fn clear(&mut self) {\n+        self.v.clear();\n+    }\n+\n+    /// Shrinks the capacity of the map as much as possible.\n+    pub fn shrink_to_fit(&mut self) {\n+        let min_len = self.v.iter().rposition(|slot| slot.is_some()).map_or(0, |i| i + 1);\n+        self.v.truncate(min_len);\n+        self.v.shrink_to_fit();\n+    }\n+\n+    /// Returns whether the map contains a value for the specified index.\n+    pub fn contains_idx(&self, idx: Idx<T>) -> bool {\n+        matches!(self.v.get(Self::to_idx(idx)), Some(Some(_)))\n+    }\n+\n+    /// Removes an index from the map, returning the value at the index if the index was previously in the map.\n+    pub fn remove(&mut self, idx: Idx<T>) -> Option<V> {\n+        self.v.get_mut(Self::to_idx(idx))?.take()\n+    }\n+\n     /// Inserts a value associated with a given arena index into the map.\n-    pub fn insert(&mut self, idx: Idx<T>, t: V) {\n+    ///\n+    /// If the map did not have this index present, None is returned.\n+    /// Otherwise, the value is updated, and the old value is returned.\n+    pub fn insert(&mut self, idx: Idx<T>, t: V) -> Option<V> {\n         let idx = Self::to_idx(idx);\n \n         self.v.resize_with((idx + 1).max(self.v.len()), || None);\n-        self.v[idx] = Some(t);\n+        self.v[idx].replace(t)\n     }\n \n     /// Returns a reference to the value associated with the provided index\n@@ -46,6 +86,16 @@ impl<T, V> ArenaMap<Idx<T>, V> {\n         self.v.iter().enumerate().filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n     }\n \n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    pub fn entry(&mut self, idx: Idx<T>) -> Entry<'_, Idx<T>, V> {\n+        let idx = Self::to_idx(idx);\n+        self.v.resize_with((idx + 1).max(self.v.len()), || None);\n+        match &mut self.v[idx] {\n+            slot @ Some(_) => Entry::Occupied(OccupiedEntry { slot, _ty: PhantomData }),\n+            slot @ None => Entry::Vacant(VacantEntry { slot, _ty: PhantomData }),\n+        }\n+    }\n+\n     fn to_idx(idx: Idx<T>) -> usize {\n         u32::from(idx.into_raw()) as usize\n     }\n@@ -70,6 +120,119 @@ impl<T, V> std::ops::IndexMut<Idx<V>> for ArenaMap<Idx<V>, T> {\n \n impl<T, V> Default for ArenaMap<Idx<V>, T> {\n     fn default() -> Self {\n-        ArenaMap { v: Vec::new(), _ty: PhantomData }\n+        Self::new()\n+    }\n+}\n+\n+impl<T, V> Extend<(Idx<V>, T)> for ArenaMap<Idx<V>, T> {\n+    fn extend<I: IntoIterator<Item = (Idx<V>, T)>>(&mut self, iter: I) {\n+        iter.into_iter().for_each(move |(k, v)| {\n+            self.insert(k, v);\n+        });\n+    }\n+}\n+\n+impl<T, V> FromIterator<(Idx<V>, T)> for ArenaMap<Idx<V>, T> {\n+    fn from_iter<I: IntoIterator<Item = (Idx<V>, T)>>(iter: I) -> Self {\n+        let mut this = Self::new();\n+        this.extend(iter);\n+        this\n+    }\n+}\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This `enum` is constructed from the [`entry`] method on [`ArenaMap`].\n+///\n+/// [`entry`]: ArenaMap::entry\n+pub enum Entry<'a, IDX, V> {\n+    /// A vacant entry.\n+    Vacant(VacantEntry<'a, IDX, V>),\n+    /// An occupied entry.\n+    Occupied(OccupiedEntry<'a, IDX, V>),\n+}\n+\n+impl<'a, IDX, V> Entry<'a, IDX, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns a mutable reference to\n+    /// the value in the entry.\n+    pub fn or_insert(self, default: V) -> &'a mut V {\n+        match self {\n+            Self::Vacant(ent) => ent.insert(default),\n+            Self::Occupied(ent) => ent.into_mut(),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Self::Vacant(ent) => ent.insert(default()),\n+            Self::Occupied(ent) => ent.into_mut(),\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any potential inserts into the map.\n+    pub fn and_modify<F: FnOnce(&mut V)>(mut self, f: F) -> Self {\n+        if let Self::Occupied(ent) = &mut self {\n+            f(ent.get_mut());\n+        }\n+        self\n+    }\n+}\n+\n+impl<'a, IDX, V> Entry<'a, IDX, V>\n+where\n+    V: Default,\n+{\n+    /// Ensures a value is in the entry by inserting the default value if empty, and returns a mutable reference\n+    /// to the value in the entry.\n+    pub fn or_default(self) -> &'a mut V {\n+        self.or_insert_with(Default::default)\n+    }\n+}\n+\n+/// A view into an vacant entry in a [`ArenaMap`]. It is part of the [`Entry`] enum.\n+pub struct VacantEntry<'a, IDX, V> {\n+    slot: &'a mut Option<V>,\n+    _ty: PhantomData<IDX>,\n+}\n+\n+impl<'a, IDX, V> VacantEntry<'a, IDX, V> {\n+    /// Sets the value of the entry with the `VacantEntry`\u2019s key, and returns a mutable reference to it.\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        self.slot.insert(value)\n+    }\n+}\n+\n+/// A view into an occupied entry in a [`ArenaMap`]. It is part of the [`Entry`] enum.\n+pub struct OccupiedEntry<'a, IDX, V> {\n+    slot: &'a mut Option<V>,\n+    _ty: PhantomData<IDX>,\n+}\n+\n+impl<'a, IDX, V> OccupiedEntry<'a, IDX, V> {\n+    /// Gets a reference to the value in the entry.\n+    pub fn get(&self) -> &V {\n+        self.slot.as_ref().expect(\"Occupied\")\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.slot.as_mut().expect(\"Occupied\")\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.slot.as_mut().expect(\"Occupied\")\n+    }\n+\n+    /// Sets the value of the entry with the `OccupiedEntry`\u2019s key, and returns the entry\u2019s old value.\n+    pub fn insert(&mut self, value: V) -> V {\n+        self.slot.replace(value).expect(\"Occupied\")\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    pub fn remove(self) -> V {\n+        self.slot.take().expect(\"Occupied\")\n     }\n }"}, {"sha": "eda8fceef05ba2aa78da842a18f53be5987037bf", "filename": "src/tools/rust-analyzer/xtask/src/release.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0436067210cb12d08cfe0e3c06a18bbd4ee768d0/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2Fsrc%2Frelease.rs?ref=0436067210cb12d08cfe0e3c06a18bbd4ee768d0", "patch": "@@ -81,7 +81,7 @@ impl flags::Promote {\n         let date = date_iso(sh)?;\n         let branch = format!(\"rust-analyzer-{date}\");\n         cmd!(sh, \"git switch -c {branch}\").run()?;\n-        cmd!(sh, \"git subtree pull -P src/tools/rust-analyzer rust-analyzer master\").run()?;\n+        cmd!(sh, \"git subtree pull -m ':arrow_up: rust-analyzer' -P src/tools/rust-analyzer rust-analyzer release\").run()?;\n \n         if !self.dry_run {\n             cmd!(sh, \"git push -u origin {branch}\").run()?;"}]}