{"sha": "d39864d64e6e0762d418f6beeedb4510942fc828", "node_id": "C_kwDOAAsO6NoAKGQzOTg2NGQ2NGU2ZTA3NjJkNDE4ZjZiZWVlZGI0NTEwOTQyZmM4Mjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T13:34:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-20T13:34:48Z"}, "message": "Auto merge of #96135 - petrochenkov:doclink6, r=GuillaumeGomez\n\nrustdoc: Optimize and refactor doc link resolution\n\nOne more subset of https://github.com/rust-lang/rust/pull/94857 that should bring perf improvements rather than regressions + a couple more optimizations on top of it.\nIt's better to read individual commits and their descriptions to understand the changes.\nThe `may_have_doc_links` optimization is not *very* useful here, but it's much more important for https://github.com/rust-lang/rust/pull/94857.\n\nCloses https://github.com/rust-lang/rust/issues/96079", "tree": {"sha": "2106cdb1ff078a58995e08633bbed36b189efd95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2106cdb1ff078a58995e08633bbed36b189efd95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d39864d64e6e0762d418f6beeedb4510942fc828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d39864d64e6e0762d418f6beeedb4510942fc828", "html_url": "https://github.com/rust-lang/rust/commit/d39864d64e6e0762d418f6beeedb4510942fc828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d39864d64e6e0762d418f6beeedb4510942fc828/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0034bbca260bfa00798d70150970924221688ede", "url": "https://api.github.com/repos/rust-lang/rust/commits/0034bbca260bfa00798d70150970924221688ede", "html_url": "https://github.com/rust-lang/rust/commit/0034bbca260bfa00798d70150970924221688ede"}, {"sha": "ca5c752a7a04f9a5149df1399106f103c6e5ba17", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca5c752a7a04f9a5149df1399106f103c6e5ba17", "html_url": "https://github.com/rust-lang/rust/commit/ca5c752a7a04f9a5149df1399106f103c6e5ba17"}], "stats": {"total": 409, "additions": 275, "deletions": 134}, "files": [{"sha": "fbc9ca7051f6de62399b6de89dc572b51069a36c", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -2894,6 +2894,7 @@ dependencies = [\n name = \"proc_macro\"\n version = \"0.0.0\"\n dependencies = [\n+ \"core\",\n  \"std\",\n ]\n "}, {"sha": "9a6d12faa605d62bcdf7540aeb1adf28a9dbb8b1", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -9,6 +9,7 @@ use crate::token::{self, CommentKind, Token};\n use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree, TreeAndSpacing};\n use crate::tokenstream::{LazyTokenStream, TokenStream};\n+use crate::util::comments;\n \n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::source_map::BytePos;\n@@ -262,6 +263,10 @@ impl Attribute {\n         }\n     }\n \n+    pub fn may_have_doc_links(&self) -> bool {\n+        self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n+    }\n+\n     pub fn get_normal_item(&self) -> &AttrItem {\n         match self.kind {\n             AttrKind::Normal(ref item, _) => item,"}, {"sha": "b4fff0022e29547e2cd17c2994ac09f528258456", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -24,6 +24,14 @@ pub struct Comment {\n     pub pos: BytePos,\n }\n \n+/// A fast conservative estimate on whether the string can contain documentation links.\n+/// A pair of square brackets `[]` must exist in the string, but we only search for the\n+/// opening bracket because brackets always go in pairs in practice.\n+#[inline]\n+pub fn may_have_doc_links(s: &str) -> bool {\n+    s.contains('[')\n+}\n+\n /// Makes a doc string more presentable to users.\n /// Used by rustdoc and perhaps other tools, but not by rustc.\n pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {"}, {"sha": "77afa7b4a5cf0a7f1d94b90c17d47046c37caf97", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -1744,6 +1744,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 adjustments: generator_data.adjustments,\n             })\n     }\n+\n+    fn get_may_have_doc_links(self, index: DefIndex) -> bool {\n+        self.root.tables.may_have_doc_links.get(self, index).is_some()\n+    }\n }\n \n impl CrateMetadata {"}, {"sha": "6b1f7d55026ad7ed9ec4eb5f591dcffdcf288696", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -531,6 +531,10 @@ impl CStore {\n     ) -> impl Iterator<Item = DefId> + '_ {\n         self.get_crate_data(cnum).get_all_incoherent_impls()\n     }\n+\n+    pub fn may_have_doc_links_untracked(&self, def_id: DefId) -> bool {\n+        self.get_crate_data(def_id.krate).get_may_have_doc_links(def_id.index)\n+    }\n }\n \n impl CrateStore for CStore {"}, {"sha": "f485e09913e9d0d054179c1fab53db12167bd4e0", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -977,6 +977,14 @@ fn should_encode_generics(def_kind: DefKind) -> bool {\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+    fn encode_attrs(&mut self, def_id: DefId) {\n+        let attrs = self.tcx.get_attrs(def_id);\n+        record!(self.tables.attributes[def_id] <- attrs);\n+        if attrs.iter().any(|attr| attr.may_have_doc_links()) {\n+            self.tables.may_have_doc_links.set(def_id.index, ());\n+        }\n+    }\n+\n     fn encode_def_ids(&mut self) {\n         if self.is_proc_macro {\n             return;\n@@ -989,7 +997,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let Some(def_kind) = def_kind else { continue };\n             self.tables.opt_def_kind.set(def_id.index, def_kind);\n             record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n-            record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n+            self.encode_attrs(def_id);\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if should_encode_visibility(def_kind) {\n                 record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n@@ -1651,7 +1659,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n-            record!(self.tables.attributes[LOCAL_CRATE.as_def_id()] <- tcx.get_attrs(LOCAL_CRATE.as_def_id()));\n+            self.encode_attrs(LOCAL_CRATE.as_def_id());\n             record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n             if let Some(stability) = stability {\n                 record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n@@ -1692,7 +1700,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 let def_id = id.to_def_id();\n                 self.tables.opt_def_kind.set(def_id.index, DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n-                record!(self.tables.attributes[def_id] <- attrs);\n+                self.encode_attrs(def_id);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n                 record!(self.tables.def_ident_span[def_id] <- span);\n                 record!(self.tables.def_span[def_id] <- span);"}, {"sha": "f1498665ff3853bcf92b7dde96f58a46dce7905a", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -360,6 +360,7 @@ define_tables! {\n     def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, Lazy<Span>>,\n     generator_diagnostic_data: Table<DefIndex, Lazy<GeneratorDiagnosticData<'tcx>>>,\n+    may_have_doc_links: Table<DefIndex, ()>,\n }\n \n #[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]"}, {"sha": "53fc2efe00bb79c230515dd319c9246ddca47c99", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -186,6 +186,20 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     }\n }\n \n+impl FixedSizeEncoding for Option<()> {\n+    type ByteArray = [u8; 1];\n+\n+    #[inline]\n+    fn from_bytes(b: &[u8; 1]) -> Self {\n+        (b[0] != 0).then(|| ())\n+    }\n+\n+    #[inline]\n+    fn write_to_bytes(self, b: &mut [u8; 1]) {\n+        b[0] = self.is_some() as u8\n+    }\n+}\n+\n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n // generic `Lazy<T>` impl, but in the general case we might not need / want to\n // fit every `usize` in `u32`."}, {"sha": "e54a50aa15c616bcf16b03e186ec4abf4985e51d", "filename": "library/proc_macro/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/library%2Fproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/library%2Fproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2FCargo.toml?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -5,3 +5,7 @@ edition = \"2021\"\n \n [dependencies]\n std = { path = \"../std\" }\n+# Workaround: when documenting this crate rustdoc will try to load crate named\n+# `core` when resolving doc links. Without this line a different `core` will be\n+# loaded from sysroot causing duplicate lang items and other similar errors.\n+core = { path = \"../core\" }"}, {"sha": "95ac3ab622a149bbdc2ba9b37291902655cdacc6", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -1089,35 +1089,35 @@ impl Attributes {\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n-        let mut doc_strings: Vec<DocFragment> = vec![];\n-        let clean_attr = |(attr, parent_module): (&ast::Attribute, Option<DefId>)| {\n-            if let Some((value, kind)) = attr.doc_str_and_comment_kind() {\n-                trace!(\"got doc_str={:?}\", value);\n-                let value = beautify_doc_string(value, kind);\n+        // Additional documentation should be shown before the original documentation.\n+        let attrs1 = additional_attrs\n+            .into_iter()\n+            .flat_map(|(attrs, def_id)| attrs.iter().map(move |attr| (attr, Some(def_id))));\n+        let attrs2 = attrs.iter().map(|attr| (attr, None));\n+        Attributes::from_ast_iter(attrs1.chain(attrs2), false)\n+    }\n+\n+    crate fn from_ast_iter<'a>(\n+        attrs: impl Iterator<Item = (&'a ast::Attribute, Option<DefId>)>,\n+        doc_only: bool,\n+    ) -> Attributes {\n+        let mut doc_strings = Vec::new();\n+        let mut other_attrs = Vec::new();\n+        for (attr, parent_module) in attrs {\n+            if let Some((doc_str, comment_kind)) = attr.doc_str_and_comment_kind() {\n+                trace!(\"got doc_str={doc_str:?}\");\n+                let doc = beautify_doc_string(doc_str, comment_kind);\n                 let kind = if attr.is_doc_comment() {\n                     DocFragmentKind::SugaredDoc\n                 } else {\n                     DocFragmentKind::RawDoc\n                 };\n-\n-                let frag =\n-                    DocFragment { span: attr.span, doc: value, kind, parent_module, indent: 0 };\n-\n-                doc_strings.push(frag);\n-\n-                None\n-            } else {\n-                Some(attr.clone())\n+                let fragment = DocFragment { span: attr.span, doc, kind, parent_module, indent: 0 };\n+                doc_strings.push(fragment);\n+            } else if !doc_only {\n+                other_attrs.push(attr.clone());\n             }\n-        };\n-\n-        // Additional documentation should be shown before the original documentation\n-        let other_attrs = additional_attrs\n-            .into_iter()\n-            .flat_map(|(attrs, id)| attrs.iter().map(move |attr| (attr, Some(id))))\n-            .chain(attrs.iter().map(|attr| (attr, None)))\n-            .filter_map(clean_attr)\n-            .collect();\n+        }\n \n         Attributes { doc_strings, other_attrs }\n     }\n@@ -1138,23 +1138,17 @@ impl Attributes {\n     }\n \n     /// Return the doc-comments on this item, grouped by the module they came from.\n-    ///\n     /// The module can be different if this is a re-export with added documentation.\n-    crate fn collapsed_doc_value_by_module_level(&self) -> FxHashMap<Option<DefId>, String> {\n-        let mut ret = FxHashMap::default();\n-        if self.doc_strings.len() == 0 {\n-            return ret;\n-        }\n-        let last_index = self.doc_strings.len() - 1;\n-\n-        for (i, new_frag) in self.doc_strings.iter().enumerate() {\n-            let out = ret.entry(new_frag.parent_module).or_default();\n-            add_doc_fragment(out, new_frag);\n-            if i == last_index {\n-                out.pop();\n-            }\n+    ///\n+    /// The last newline is not trimmed so the produced strings are reusable between\n+    /// early and late doc link resolution regardless of their position.\n+    crate fn prepare_to_doc_link_resolution(&self) -> FxHashMap<Option<DefId>, String> {\n+        let mut res = FxHashMap::default();\n+        for fragment in &self.doc_strings {\n+            let out_str = res.entry(fragment.parent_module).or_default();\n+            add_doc_fragment(out_str, fragment);\n         }\n-        ret\n+        res\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined"}, {"sha": "1db6064551cae362fc30911ba5528b00e052b1c7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{HirId, Path, TraitCandidate};\n@@ -29,11 +29,14 @@ use crate::clean::inline::build_external_trait;\n use crate::clean::{self, ItemId, TraitWithExtraInfo};\n use crate::config::{Options as RustdocOptions, OutputFormat, RenderOptions};\n use crate::formats::cache::Cache;\n+use crate::passes::collect_intra_doc_links::PreprocessedMarkdownLink;\n use crate::passes::{self, Condition::*};\n \n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n crate struct ResolverCaches {\n+    crate markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n+    crate doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n     crate traits_in_scope: DefIdMap<Vec<TraitCandidate>>,"}, {"sha": "eafe6f17d44bf6788239e6d7a59f28a3899981eb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -1255,7 +1255,7 @@ crate struct MarkdownLink {\n     pub range: Range<usize>,\n }\n \n-crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n+crate fn markdown_links<R>(md: &str, filter_map: impl Fn(MarkdownLink) -> Option<R>) -> Vec<R> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1295,11 +1295,12 @@ crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n \n     let mut push = |link: BrokenLink<'_>| {\n         let span = span_for_link(&link.reference, link.span);\n-        links.borrow_mut().push(MarkdownLink {\n+        filter_map(MarkdownLink {\n             kind: LinkType::ShortcutUnknown,\n             link: link.reference.to_string(),\n             range: span,\n-        });\n+        })\n+        .map(|link| links.borrow_mut().push(link));\n         None\n     };\n     let p = Parser::new_with_broken_link_callback(md, main_body_opts(), Some(&mut push))\n@@ -1314,7 +1315,8 @@ crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n         if let Event::Start(Tag::Link(kind, dest, _)) = ev.0 {\n             debug!(\"found link: {dest}\");\n             let span = span_for_link(&dest, ev.1);\n-            links.borrow_mut().push(MarkdownLink { kind, link: dest.into_string(), range: span });\n+            filter_map(MarkdownLink { kind, link: dest.into_string(), range: span })\n+                .map(|link| links.borrow_mut().push(link));\n         }\n     }\n "}, {"sha": "42e87f3f9610b1b54cb855fce0679998e7cce810", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 76, "deletions": 36, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -3,6 +3,7 @@\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n use pulldown_cmark::LinkType;\n+use rustc_ast::util::comments::may_have_doc_links;\n use rustc_data_structures::{fx::FxHashMap, intern::Interned, stable_set::FxHashSet};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir::def::Namespace::*;\n@@ -159,7 +160,7 @@ impl TryFrom<ResolveRes> for Res {\n }\n \n /// A link failed to resolve.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     WrongNamespace {\n@@ -199,7 +200,7 @@ enum ResolutionFailure<'a> {\n     Dummy,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum MalformedGenerics {\n     /// This link has unbalanced angle brackets.\n     ///\n@@ -252,6 +253,7 @@ impl ResolutionFailure<'_> {\n     }\n }\n \n+#[derive(Clone, Copy)]\n enum AnchorFailure {\n     /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n@@ -556,7 +558,15 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // Resolver doesn't know about true, false, and types that aren't paths (e.g. `()`).\n         let result = self\n             .cx\n-            .enter_resolver(|resolver| resolver.resolve_rustdoc_path(path_str, ns, module_id))\n+            .resolver_caches\n+            .doc_link_resolutions\n+            .get(&(Symbol::intern(path_str), ns, module_id))\n+            .copied()\n+            .unwrap_or_else(|| {\n+                self.cx.enter_resolver(|resolver| {\n+                    resolver.resolve_rustdoc_path(path_str, ns, module_id)\n+                })\n+            })\n             .and_then(|res| res.try_into().ok())\n             .or_else(|| resolve_primitive(path_str, ns))\n             .or_else(|| self.resolve_macro_rules(path_str, ns));\n@@ -1040,17 +1050,30 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n         // In the presence of re-exports, this is not the same as the module of the item.\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n         // so we know which module it came from.\n-        for (parent_module, doc) in item.attrs.collapsed_doc_value_by_module_level() {\n+        for (parent_module, doc) in item.attrs.prepare_to_doc_link_resolution() {\n+            if !may_have_doc_links(&doc) {\n+                continue;\n+            }\n             debug!(\"combined_docs={}\", doc);\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n             let parent_node = parent_module.or(parent_node);\n-            for md_link in markdown_links(&doc) {\n+            let mut tmp_links = self\n+                .cx\n+                .resolver_caches\n+                .markdown_links\n+                .take()\n+                .expect(\"`markdown_links` are already borrowed\");\n+            if !tmp_links.contains_key(&doc) {\n+                tmp_links.insert(doc.clone(), preprocessed_markdown_links(&doc));\n+            }\n+            for md_link in &tmp_links[&doc] {\n                 let link = self.resolve_link(&item, &doc, parent_node, md_link);\n                 if let Some(link) = link {\n                     self.cx.cache.intra_doc_links.entry(item.item_id).or_default().push(link);\n                 }\n             }\n+            self.cx.resolver_caches.markdown_links = Some(tmp_links);\n         }\n \n         if item.is_mod() {\n@@ -1066,34 +1089,38 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     }\n }\n \n-enum PreprocessingError<'a> {\n+enum PreprocessingError {\n     Anchor(AnchorFailure),\n     Disambiguator(Range<usize>, String),\n-    Resolution(ResolutionFailure<'a>, String, Option<Disambiguator>),\n+    Resolution(ResolutionFailure<'static>, String, Option<Disambiguator>),\n }\n \n-impl From<AnchorFailure> for PreprocessingError<'_> {\n+impl From<AnchorFailure> for PreprocessingError {\n     fn from(err: AnchorFailure) -> Self {\n         Self::Anchor(err)\n     }\n }\n \n+#[derive(Clone)]\n struct PreprocessingInfo {\n     path_str: String,\n     disambiguator: Option<Disambiguator>,\n     extra_fragment: Option<String>,\n     link_text: String,\n }\n \n+// Not a typedef to avoid leaking several private structures from this module.\n+crate struct PreprocessedMarkdownLink(Result<PreprocessingInfo, PreprocessingError>, MarkdownLink);\n+\n /// Returns:\n /// - `None` if the link should be ignored.\n /// - `Some(Err)` if the link should emit an error\n /// - `Some(Ok)` if the link is valid\n ///\n /// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n-fn preprocess_link<'a>(\n-    ori_link: &'a MarkdownLink,\n-) -> Option<Result<PreprocessingInfo, PreprocessingError<'a>>> {\n+fn preprocess_link(\n+    ori_link: &MarkdownLink,\n+) -> Option<Result<PreprocessingInfo, PreprocessingError>> {\n     // [] is mostly likely not supposed to be a link\n     if ori_link.link.is_empty() {\n         return None;\n@@ -1172,6 +1199,12 @@ fn preprocess_link<'a>(\n     }))\n }\n \n+fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n+    markdown_links(s, |link| {\n+        preprocess_link(&link).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n+    })\n+}\n+\n impl LinkCollector<'_, '_> {\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n@@ -1181,8 +1214,9 @@ impl LinkCollector<'_, '_> {\n         item: &Item,\n         dox: &str,\n         parent_node: Option<DefId>,\n-        ori_link: MarkdownLink,\n+        link: &PreprocessedMarkdownLink,\n     ) -> Option<ItemLink> {\n+        let PreprocessedMarkdownLink(pp_link, ori_link) = link;\n         trace!(\"considering link '{}'\", ori_link.link);\n \n         let diag_info = DiagnosticInfo {\n@@ -1192,28 +1226,29 @@ impl LinkCollector<'_, '_> {\n             link_range: ori_link.range.clone(),\n         };\n \n-        let PreprocessingInfo { ref path_str, disambiguator, extra_fragment, link_text } =\n-            match preprocess_link(&ori_link)? {\n-                Ok(x) => x,\n-                Err(err) => {\n-                    match err {\n-                        PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, err),\n-                        PreprocessingError::Disambiguator(range, msg) => {\n-                            disambiguator_error(self.cx, diag_info, range, &msg)\n-                        }\n-                        PreprocessingError::Resolution(err, path_str, disambiguator) => {\n-                            resolution_failure(\n-                                self,\n-                                diag_info,\n-                                &path_str,\n-                                disambiguator,\n-                                smallvec![err],\n-                            );\n-                        }\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } = match pp_link\n+        {\n+            Ok(x) => x,\n+            Err(err) => {\n+                match err {\n+                    PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, *err),\n+                    PreprocessingError::Disambiguator(range, msg) => {\n+                        disambiguator_error(self.cx, diag_info, range.clone(), msg)\n+                    }\n+                    PreprocessingError::Resolution(err, path_str, disambiguator) => {\n+                        resolution_failure(\n+                            self,\n+                            diag_info,\n+                            path_str,\n+                            *disambiguator,\n+                            smallvec![err.clone()],\n+                        );\n                     }\n-                    return None;\n                 }\n-            };\n+                return None;\n+            }\n+        };\n+        let disambiguator = *disambiguator;\n \n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n@@ -1250,7 +1285,7 @@ impl LinkCollector<'_, '_> {\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n-                extra_fragment,\n+                extra_fragment: extra_fragment.clone(),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n@@ -1320,8 +1355,8 @@ impl LinkCollector<'_, '_> {\n                 }\n \n                 Some(ItemLink {\n-                    link: ori_link.link,\n-                    link_text,\n+                    link: ori_link.link.clone(),\n+                    link_text: link_text.clone(),\n                     did: res.def_id(self.cx.tcx),\n                     fragment,\n                 })\n@@ -1343,7 +1378,12 @@ impl LinkCollector<'_, '_> {\n                     &diag_info,\n                 )?;\n                 let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link.link, link_text, did: id, fragment })\n+                Some(ItemLink {\n+                    link: ori_link.link.clone(),\n+                    link_text: link_text.clone(),\n+                    did: id,\n+                    fragment,\n+                })\n             }\n         }\n     }"}, {"sha": "e2359da870edc21ba6edefa2cfa5250d0e1b373e", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 78, "deletions": 35, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -1,19 +1,20 @@\n use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n-use crate::html::markdown::markdown_links;\n-use crate::passes::collect_intra_doc_links::preprocess_link;\n+use crate::passes::collect_intra_doc_links::preprocessed_markdown_links;\n+use crate::passes::collect_intra_doc_links::PreprocessedMarkdownLink;\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n use rustc_ast_lowering::ResolverAstLowering;\n-use rustc_hir::def::Namespace::TypeNS;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def::Namespace::*;\n+use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n use rustc_session::config::Externs;\n-use rustc_span::SyntaxContext;\n+use rustc_span::{Symbol, SyntaxContext};\n \n use std::collections::hash_map::Entry;\n use std::mem;\n@@ -28,6 +29,8 @@ crate fn early_resolve_intra_doc_links(\n         resolver,\n         current_mod: CRATE_DEF_ID,\n         visited_mods: Default::default(),\n+        markdown_links: Default::default(),\n+        doc_link_resolutions: Default::default(),\n         traits_in_scope: Default::default(),\n         all_traits: Default::default(),\n         all_trait_impls: Default::default(),\n@@ -36,7 +39,7 @@ crate fn early_resolve_intra_doc_links(\n \n     // Overridden `visit_item` below doesn't apply to the crate root,\n     // so we have to visit its attributes and reexports separately.\n-    link_resolver.load_links_in_attrs(&krate.attrs);\n+    link_resolver.resolve_doc_links_local(&krate.attrs);\n     link_resolver.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut link_resolver, krate);\n     link_resolver.process_extern_impls();\n@@ -50,17 +53,27 @@ crate fn early_resolve_intra_doc_links(\n     }\n \n     ResolverCaches {\n+        markdown_links: Some(link_resolver.markdown_links),\n+        doc_link_resolutions: link_resolver.doc_link_resolutions,\n         traits_in_scope: link_resolver.traits_in_scope,\n         all_traits: Some(link_resolver.all_traits),\n         all_trait_impls: Some(link_resolver.all_trait_impls),\n         all_macro_rules: link_resolver.resolver.take_all_macro_rules(),\n     }\n }\n \n+fn doc_attrs<'a>(attrs: impl Iterator<Item = &'a ast::Attribute>) -> Attributes {\n+    let mut attrs = Attributes::from_ast_iter(attrs.map(|attr| (attr, None)), true);\n+    attrs.unindent_doc_comments();\n+    attrs\n+}\n+\n struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n     visited_mods: DefIdSet,\n+    markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n+    doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_traits: Vec<DefId>,\n     all_trait_impls: Vec<DefId>,\n@@ -92,18 +105,11 @@ impl EarlyDocLinkResolver<'_, '_> {\n         }\n     }\n \n-    fn add_traits_in_parent_scope(&mut self, def_id: DefId) {\n-        if let Some(module_id) = self.resolver.parent(def_id) {\n-            self.add_traits_in_scope(module_id);\n-        }\n-    }\n-\n     /// Add traits in scope for links in impls collected by the `collect-intra-doc-links` pass.\n     /// That pass filters impls using type-based information, but we don't yet have such\n     /// information here, so we just conservatively calculate traits in scope for *all* modules\n     /// having impls in them.\n     fn process_extern_impls(&mut self) {\n-        // FIXME: Need to resolve doc links on all these impl and trait items below.\n         // Resolving links in already existing crates may trigger loading of new crates.\n         let mut start_cnum = 0;\n         loop {\n@@ -124,7 +130,7 @@ impl EarlyDocLinkResolver<'_, '_> {\n                 // the current crate, and links in their doc comments are not resolved.\n                 for &def_id in &all_traits {\n                     if self.resolver.cstore().visibility_untracked(def_id) == Visibility::Public {\n-                        self.add_traits_in_parent_scope(def_id);\n+                        self.resolve_doc_links_extern_impl(def_id, false);\n                     }\n                 }\n                 for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n@@ -135,17 +141,17 @@ impl EarlyDocLinkResolver<'_, '_> {\n                                 == Visibility::Public\n                         })\n                     {\n-                        self.add_traits_in_parent_scope(impl_def_id);\n+                        self.resolve_doc_links_extern_impl(impl_def_id, false);\n                     }\n                 }\n                 for (ty_def_id, impl_def_id) in all_inherent_impls {\n                     if self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public\n                     {\n-                        self.add_traits_in_parent_scope(impl_def_id);\n+                        self.resolve_doc_links_extern_impl(impl_def_id, true);\n                     }\n                 }\n-                for def_id in all_incoherent_impls {\n-                    self.add_traits_in_parent_scope(def_id);\n+                for impl_def_id in all_incoherent_impls {\n+                    self.resolve_doc_links_extern_impl(impl_def_id, true);\n                 }\n \n                 self.all_traits.extend(all_traits);\n@@ -161,16 +167,55 @@ impl EarlyDocLinkResolver<'_, '_> {\n         }\n     }\n \n-    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn resolve_doc_links_extern_impl(&mut self, def_id: DefId, _is_inherent: bool) {\n+        // FIXME: Resolve links in associated items in addition to traits themselves,\n+        // `force` is used to provide traits in scope for the associated items.\n+        self.resolve_doc_links_extern_outer(def_id, def_id, true);\n+    }\n+\n+    fn resolve_doc_links_extern_outer(&mut self, def_id: DefId, scope_id: DefId, force: bool) {\n+        if !force && !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n+            return;\n+        }\n+        // FIXME: actually resolve links, not just add traits in scope.\n+        if let Some(parent_id) = self.resolver.parent(scope_id) {\n+            self.add_traits_in_scope(parent_id);\n+        }\n+    }\n+\n+    fn resolve_doc_links_extern_inner(&mut self, def_id: DefId) {\n+        if !self.resolver.cstore().may_have_doc_links_untracked(def_id) {\n+            return;\n+        }\n+        // FIXME: actually resolve links, not just add traits in scope.\n+        self.add_traits_in_scope(def_id);\n+    }\n+\n+    fn resolve_doc_links_local(&mut self, attrs: &[ast::Attribute]) {\n+        if !attrs.iter().any(|attr| attr.may_have_doc_links()) {\n+            return;\n+        }\n         let module_id = self.current_mod.to_def_id();\n+        self.resolve_doc_links(doc_attrs(attrs.iter()), module_id);\n+    }\n+\n+    fn resolve_doc_links(&mut self, attrs: Attributes, module_id: DefId) {\n         let mut need_traits_in_scope = false;\n-        for (doc_module, doc) in\n-            Attributes::from_ast(attrs, None).collapsed_doc_value_by_module_level()\n-        {\n+        for (doc_module, doc) in attrs.prepare_to_doc_link_resolution() {\n             assert_eq!(doc_module, None);\n-            for link in markdown_links(&doc.as_str()) {\n-                if let Some(Ok(pinfo)) = preprocess_link(&link) {\n-                    self.resolver.resolve_rustdoc_path(&pinfo.path_str, TypeNS, module_id);\n+            let links = self\n+                .markdown_links\n+                .entry(doc)\n+                .or_insert_with_key(|doc| preprocessed_markdown_links(doc));\n+            for PreprocessedMarkdownLink(pp_link, _) in links {\n+                if let Ok(pinfo) = pp_link {\n+                    // FIXME: Resolve the path in all namespaces and resolve its prefixes too.\n+                    let ns = TypeNS;\n+                    self.doc_link_resolutions\n+                        .entry((Symbol::intern(&pinfo.path_str), ns, module_id))\n+                        .or_insert_with_key(|(path, ns, module_id)| {\n+                            self.resolver.resolve_rustdoc_path(path.as_str(), *ns, *module_id)\n+                        });\n                     need_traits_in_scope = true;\n                 }\n             }\n@@ -197,15 +242,13 @@ impl EarlyDocLinkResolver<'_, '_> {\n                     && module_id.is_local()\n             {\n                 if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n-                    // FIXME: Need to resolve doc links on all these extern items\n-                    // reached through reexports.\n                     let scope_id = match child.res {\n                         Res::Def(DefKind::Variant, ..) => self.resolver.parent(def_id).unwrap(),\n                         _ => def_id,\n                     };\n-                    self.add_traits_in_parent_scope(scope_id); // Outer attribute scope\n+                    self.resolve_doc_links_extern_outer(def_id, scope_id, false); // Outer attribute scope\n                     if let Res::Def(DefKind::Mod, ..) = child.res {\n-                        self.add_traits_in_scope(def_id); // Inner attribute scope\n+                        self.resolve_doc_links_extern_inner(def_id); // Inner attribute scope\n                     }\n                     // Traits are processed in `add_extern_traits_in_scope`.\n                     if let Res::Def(DefKind::Mod | DefKind::Enum, ..) = child.res {\n@@ -219,10 +262,10 @@ impl EarlyDocLinkResolver<'_, '_> {\n \n impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        self.load_links_in_attrs(&item.attrs); // Outer attribute scope\n+        self.resolve_doc_links_local(&item.attrs); // Outer attribute scope\n         if let ItemKind::Mod(..) = item.kind {\n             let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n-            self.load_links_in_attrs(&item.attrs); // Inner attribute scope\n+            self.resolve_doc_links_local(&item.attrs); // Inner attribute scope\n             self.process_module_children_or_reexports(self.current_mod.to_def_id());\n             visit::walk_item(self, item);\n             self.current_mod = old_mod;\n@@ -241,22 +284,22 @@ impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n-        self.load_links_in_attrs(&item.attrs);\n+        self.resolve_doc_links_local(&item.attrs);\n         visit::walk_assoc_item(self, item, ctxt)\n     }\n \n     fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.load_links_in_attrs(&item.attrs);\n+        self.resolve_doc_links_local(&item.attrs);\n         visit::walk_foreign_item(self, item)\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant) {\n-        self.load_links_in_attrs(&v.attrs);\n+        self.resolve_doc_links_local(&v.attrs);\n         visit::walk_variant(self, v)\n     }\n \n     fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.load_links_in_attrs(&field.attrs);\n+        self.resolve_doc_links_local(&field.attrs);\n         visit::walk_field_def(self, field)\n     }\n "}, {"sha": "7a5156e81c4c875fbd0a5d58bb216ff0b7074b8e", "filename": "src/test/rustdoc-ui/intra-doc/email-address-localhost.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Femail-address-localhost.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Femail-address-localhost.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Femail-address-localhost.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -1,7 +1,7 @@\n // normalize-stderr-test: \"nightly|beta|1\\.[0-9][0-9]\\.[0-9]\" -> \"$$CHANNEL\"\n+// check-pass\n #![deny(warnings)]\n \n //! Email me at <hello@localhost>.\n-//~^ ERROR unknown disambiguator `hello`\n \n //! This should *not* warn: <hello@example.com>."}, {"sha": "1b07828fc6e55e4217022e220646b0d61ef530a9", "filename": "src/test/rustdoc-ui/intra-doc/email-address-localhost.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0034bbca260bfa00798d70150970924221688ede/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Femail-address-localhost.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0034bbca260bfa00798d70150970924221688ede/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Femail-address-localhost.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Femail-address-localhost.stderr?ref=0034bbca260bfa00798d70150970924221688ede", "patch": "@@ -1,16 +0,0 @@\n-error: unknown disambiguator `hello`\n-  --> $DIR/email-address-localhost.rs:4:18\n-   |\n-LL | //! Email me at <hello@localhost>.\n-   |                  ^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/email-address-localhost.rs:2:9\n-   |\n-LL | #![deny(warnings)]\n-   |         ^^^^^^^^\n-   = note: `#[deny(rustdoc::broken_intra_doc_links)]` implied by `#[deny(warnings)]`\n-   = note: see https://doc.rust-lang.org/$CHANNEL/rustdoc/linking-to-items-by-name.html#namespaces-and-disambiguators for more info about disambiguators\n-\n-error: aborting due to previous error\n-"}, {"sha": "791a452c9571b7834747b7cae3f2a5fd7d86b613", "filename": "src/test/rustdoc/early-unindent.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Ftest%2Frustdoc%2Fearly-unindent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d39864d64e6e0762d418f6beeedb4510942fc828/src%2Ftest%2Frustdoc%2Fearly-unindent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fearly-unindent.rs?ref=d39864d64e6e0762d418f6beeedb4510942fc828", "patch": "@@ -0,0 +1,26 @@\n+// This is a regression for https://github.com/rust-lang/rust/issues/96079.\n+\n+#![crate_name = \"foo\"]\n+\n+pub mod app {\n+    pub struct S;\n+\n+    impl S {\n+        // @has 'foo/app/struct.S.html'\n+        // @has - '//a[@href=\"../enums/enum.Foo.html#method.by_name\"]' 'Foo::by_name'\n+        /**\n+        Doc comment hello! [`Foo::by_name`](`crate::enums::Foo::by_name`).\n+        */\n+        pub fn whatever(&self) {}\n+    }\n+}\n+\n+pub mod enums {\n+    pub enum Foo {\n+        Bar,\n+    }\n+\n+    impl Foo {\n+        pub fn by_name(&self) {}\n+    }\n+}"}]}