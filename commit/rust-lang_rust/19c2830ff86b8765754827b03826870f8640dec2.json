{"sha": "19c2830ff86b8765754827b03826870f8640dec2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YzI4MzBmZjg2Yjg3NjU3NTQ4MjdiMDM4MjY4NzBmODY0MGRlYzI=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-01T00:55:04Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-01T00:55:04Z"}, "message": "move into separate module", "tree": {"sha": "51181cac8b44608bc647c41707fcccabedf6a1db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51181cac8b44608bc647c41707fcccabedf6a1db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19c2830ff86b8765754827b03826870f8640dec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19c2830ff86b8765754827b03826870f8640dec2", "html_url": "https://github.com/rust-lang/rust/commit/19c2830ff86b8765754827b03826870f8640dec2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19c2830ff86b8765754827b03826870f8640dec2/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7a00a87fd20a8b697a603d68e60e6ffbc59aac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a00a87fd20a8b697a603d68e60e6ffbc59aac8", "html_url": "https://github.com/rust-lang/rust/commit/a7a00a87fd20a8b697a603d68e60e6ffbc59aac8"}], "stats": {"total": 606, "additions": 308, "deletions": 298}, "files": [{"sha": "7e78ee597429fa1030aa5601226fca4fb61958df", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 4, "deletions": 298, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/19c2830ff86b8765754827b03826870f8640dec2/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c2830ff86b8765754827b03826870f8640dec2/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=19c2830ff86b8765754827b03826870f8640dec2", "patch": "@@ -1,26 +1,20 @@\n-use std::iter::once;\n-\n use hir::{\n-    db::DefDatabase, Adt, AsAssocItem, AsName, AssocItemContainer, AttrDef, Crate, Documentation,\n-    FieldSource, HasSource, HirDisplay, Hygiene, ItemInNs, ModPath, Module, ModuleDef,\n-    ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n+    Module, ModuleDef, ModuleSource, Semantics,\n };\n use itertools::Itertools;\n-use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n-use pulldown_cmark_to_cmark::cmark;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n-use ra_syntax::{ast, ast::Path, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n-use ra_tt::{Ident, Leaf, Literal, TokenTree};\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n use stdx::format_to;\n use test_utils::mark;\n-use url::Url;\n \n use crate::{\n     display::{macro_label, ShortLabel, ToNav, TryToNav},\n+    link_rewrite::rewrite_links,\n     markup::Markup,\n     runnables::runnable,\n     FileId, FilePosition, NavigationTarget, RangeInfo, Runnable,\n@@ -343,294 +337,6 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n     }\n }\n \n-// Rewrites a markdown document, resolving links using `callback` and additionally striping prefixes/suffixes on link titles.\n-fn map_links<'e>(\n-    events: impl Iterator<Item = Event<'e>>,\n-    callback: impl Fn(&str, &str) -> (String, String),\n-) -> impl Iterator<Item = Event<'e>> {\n-    let mut in_link = false;\n-    let mut link_target: Option<CowStr> = None;\n-\n-    events.map(move |evt| match evt {\n-        Event::Start(Tag::Link(_link_type, ref target, _)) => {\n-            in_link = true;\n-            link_target = Some(target.clone());\n-            evt\n-        }\n-        Event::End(Tag::Link(link_type, _target, _)) => {\n-            in_link = false;\n-            Event::End(Tag::Link(link_type, link_target.take().unwrap(), CowStr::Borrowed(\"\")))\n-        }\n-        Event::Text(s) if in_link => {\n-            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n-            link_target = Some(CowStr::Boxed(link_target_s.into()));\n-            Event::Text(CowStr::Boxed(link_name.into()))\n-        }\n-        Event::Code(s) if in_link => {\n-            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n-            link_target = Some(CowStr::Boxed(link_target_s.into()));\n-            Event::Code(CowStr::Boxed(link_name.into()))\n-        }\n-        _ => evt,\n-    })\n-}\n-\n-/// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n-fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n-    let doc = Parser::new_with_broken_link_callback(\n-        markdown,\n-        Options::empty(),\n-        Some(&|label, _| Some((/*url*/ label.to_string(), /*title*/ label.to_string()))),\n-    );\n-\n-    let doc = map_links(doc, |target, title: &str| {\n-        // This check is imperfect, there's some overlap between valid intra-doc links\n-        // and valid URLs so we choose to be too eager to try to resolve what might be\n-        // a URL.\n-        if target.contains(\"://\") {\n-            (target.to_string(), title.to_string())\n-        } else {\n-            // Two posibilities:\n-            // * path-based links: `../../module/struct.MyStruct.html`\n-            // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            let resolved = try_resolve_intra(db, definition, title, &target).or_else(|| {\n-                try_resolve_path(db, definition, &target).map(|target| (target, title.to_string()))\n-            });\n-\n-            match resolved {\n-                Some((target, title)) => (target, title),\n-                None => (target.to_string(), title.to_string()),\n-            }\n-        }\n-    });\n-    let mut out = String::new();\n-    cmark(doc, &mut out, None).ok();\n-    out\n-}\n-\n-#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n-enum Namespace {\n-    Types,\n-    Values,\n-    Macros,\n-}\n-\n-static TYPES: ([&str; 7], [&str; 0]) =\n-    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n-static VALUES: ([&str; 8], [&str; 1]) =\n-    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n-static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n-\n-impl Namespace {\n-    /// Extract the specified namespace from an intra-doc-link if one exists.\n-    ///\n-    /// # Examples\n-    ///\n-    /// * `struct MyStruct` -> `Namespace::Types`\n-    /// * `panic!` -> `Namespace::Macros`\n-    /// * `fn@from_intra_spec` -> `Namespace::Values`\n-    fn from_intra_spec(s: &str) -> Option<Self> {\n-        [\n-            (Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n-            (Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n-            (Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n-        ]\n-        .iter()\n-        .filter(|(_ns, (prefixes, suffixes))| {\n-            prefixes\n-                .clone()\n-                .map(|prefix| {\n-                    s.starts_with(*prefix)\n-                        && s.chars()\n-                            .nth(prefix.len() + 1)\n-                            .map(|c| c == '@' || c == ' ')\n-                            .unwrap_or(false)\n-                })\n-                .any(|cond| cond)\n-                || suffixes\n-                    .clone()\n-                    .map(|suffix| {\n-                        s.starts_with(*suffix)\n-                            && s.chars()\n-                                .nth(suffix.len() + 1)\n-                                .map(|c| c == '@' || c == ' ')\n-                                .unwrap_or(false)\n-                    })\n-                    .any(|cond| cond)\n-        })\n-        .map(|(ns, (_, _))| *ns)\n-        .next()\n-    }\n-}\n-\n-// Strip prefixes, suffixes, and inline code marks from the given string.\n-fn strip_prefixes_suffixes(mut s: &str) -> &str {\n-    s = s.trim_matches('`');\n-\n-    [\n-        (TYPES.0.iter(), TYPES.1.iter()),\n-        (VALUES.0.iter(), VALUES.1.iter()),\n-        (MACROS.0.iter(), MACROS.1.iter()),\n-    ]\n-    .iter()\n-    .for_each(|(prefixes, suffixes)| {\n-        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n-        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n-    });\n-    s.trim_start_matches(\"@\").trim()\n-}\n-\n-/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n-///\n-/// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n-fn try_resolve_intra(\n-    db: &RootDatabase,\n-    definition: &Definition,\n-    link_text: &str,\n-    link_target: &str,\n-) -> Option<(String, String)> {\n-    eprintln!(\"resolving intra\");\n-\n-    // Set link_target for implied shortlinks\n-    let link_target =\n-        if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n-\n-    // Namespace disambiguation\n-    let namespace = Namespace::from_intra_spec(link_target);\n-\n-    // Strip prefixes/suffixes\n-    let link_target = strip_prefixes_suffixes(link_target);\n-\n-    // Parse link as a module path\n-    let path = Path::parse(link_target).ok()?;\n-    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n-\n-    // Resolve it relative to symbol's location (according to the RFC this should consider small scopes\n-    let resolver = definition.resolver(db)?;\n-\n-    let resolved = resolver.resolve_module_path_in_items(db, &modpath);\n-    let (defid, namespace) = match namespace {\n-        // FIXME: .or(resolved.macros)\n-        None => resolved\n-            .types\n-            .map(|t| (t.0, Namespace::Types))\n-            .or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n-        Some(ns @ Namespace::Types) => (resolved.types?.0, ns),\n-        Some(ns @ Namespace::Values) => (resolved.values?.0, ns),\n-        // FIXME:\n-        Some(Namespace::Macros) => None?,\n-    };\n-\n-    // Get the filepath of the final symbol\n-    let def: ModuleDef = defid.into();\n-    let module = def.module(db)?;\n-    let krate = module.krate();\n-    let ns = match namespace {\n-        Namespace::Types => ItemInNs::Types(defid),\n-        Namespace::Values => ItemInNs::Values(defid),\n-        // FIXME:\n-        Namespace::Macros => None?,\n-    };\n-    let import_map = db.import_map(krate.into());\n-    let path = import_map.path_of(ns)?;\n-\n-    Some((\n-        get_doc_url(db, &krate)?\n-            .join(&format!(\"{}/\", krate.display_name(db)?))\n-            .ok()?\n-            .join(&path.segments.iter().map(|name| name.to_string()).join(\"/\"))\n-            .ok()?\n-            .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?)\n-            .ok()?\n-            .into_string(),\n-        strip_prefixes_suffixes(link_text).to_string(),\n-    ))\n-}\n-\n-/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n-fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> Option<String> {\n-    eprintln!(\"resolving path\");\n-\n-    if !link.contains(\"#\") && !link.contains(\".html\") {\n-        return None;\n-    }\n-    let ns = if let Definition::ModuleDef(moddef) = definition {\n-        ItemInNs::Types(moddef.clone().into())\n-    } else {\n-        return None;\n-    };\n-    let module = definition.module(db)?;\n-    let krate = module.krate();\n-    let import_map = db.import_map(krate.into());\n-    let base = once(format!(\"{}\", krate.display_name(db)?))\n-        .chain(import_map.path_of(ns)?.segments.iter().map(|name| format!(\"{}\", name)))\n-        .join(\"/\");\n-\n-    get_doc_url(db, &krate)\n-        .and_then(|url| url.join(&base).ok())\n-        .and_then(|url| {\n-            get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten()\n-        })\n-        .and_then(|url| url.join(link).ok())\n-        .map(|url| url.into_string())\n-}\n-\n-/// Try to get the root URL of the documentation of a crate.\n-fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n-    // Look for #![doc(html_root_url = \"...\")]\n-    let attrs = db.attrs(AttrDef::from(krate.root_module(db)?).into());\n-    let doc_attr_q = attrs.by_key(\"doc\");\n-\n-    let doc_url = if doc_attr_q.exists() {\n-        doc_attr_q.tt_values().map(|tt| {\n-            let name = tt.token_trees.iter()\n-                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident, ..})) if ident == \"html_root_url\"))\n-                .skip(2)\n-                .next();\n-\n-            match name {\n-                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n-                _ => None\n-            }\n-        }).flat_map(|t| t).next().map(|s| s.to_string())\n-    } else {\n-        // Fallback to docs.rs\n-        // FIXME: Specify an exact version here (from Cargo.lock)\n-        Some(format!(\"https://docs.rs/{}/*\", krate.display_name(db)?))\n-    };\n-\n-    doc_url\n-        .map(|s| s.trim_matches('\"').trim_end_matches(\"/\").to_owned() + \"/\")\n-        .and_then(|s| Url::parse(&s).ok())\n-}\n-\n-/// Get the filename and extension generated for a symbol by rustdoc.\n-///\n-/// Example: `struct.Shard.html`\n-fn get_symbol_filename(db: &RootDatabase, definition: &Definition) -> Option<String> {\n-    Some(match definition {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Adt(adt) => match adt {\n-                Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n-                Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n-                Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n-            },\n-            ModuleDef::Module(_) => \"index.html\".to_string(),\n-            ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n-            ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n-            ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n-            ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n-            ModuleDef::EnumVariant(ev) => {\n-                format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n-            }\n-            ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n-            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n-        },\n-        Definition::Macro(m) => format!(\"macro.{}.html\", m.name(db)?),\n-        _ => None?,\n-    })\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {"}, {"sha": "e615e993aba6cdf8b7effee1ede5c7267a918f47", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c2830ff86b8765754827b03826870f8640dec2/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c2830ff86b8765754827b03826870f8640dec2/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=19c2830ff86b8765754827b03826870f8640dec2", "patch": "@@ -44,6 +44,7 @@ mod status;\n mod syntax_highlighting;\n mod syntax_tree;\n mod typing;\n+mod link_rewrite;\n \n use std::sync::Arc;\n "}, {"sha": "85e6188e82551c5aff2ce46fb4c9ed47b74f225a", "filename": "crates/ra_ide/src/link_rewrite.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/19c2830ff86b8765754827b03826870f8640dec2/crates%2Fra_ide%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c2830ff86b8765754827b03826870f8640dec2/crates%2Fra_ide%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flink_rewrite.rs?ref=19c2830ff86b8765754827b03826870f8640dec2", "patch": "@@ -0,0 +1,302 @@\n+//! Resolves and rewrites links in markdown documentation for hovers/completion windows.\n+\n+use std::iter::once;\n+\n+use itertools::Itertools;\n+use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n+use pulldown_cmark_to_cmark::cmark;\n+use url::Url;\n+\n+use hir::{Adt, AsName, AttrDef, Crate, Hygiene, ItemInNs, ModPath, ModuleDef};\n+use ra_hir_def::db::DefDatabase;\n+use ra_ide_db::{defs::Definition, RootDatabase};\n+use ra_syntax::ast::Path;\n+use ra_tt::{Ident, Leaf, Literal, TokenTree};\n+\n+/// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n+pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n+    let doc = Parser::new_with_broken_link_callback(\n+        markdown,\n+        Options::empty(),\n+        Some(&|label, _| Some((/*url*/ label.to_string(), /*title*/ label.to_string()))),\n+    );\n+\n+    let doc = map_links(doc, |target, title: &str| {\n+        // This check is imperfect, there's some overlap between valid intra-doc links\n+        // and valid URLs so we choose to be too eager to try to resolve what might be\n+        // a URL.\n+        if target.contains(\"://\") {\n+            (target.to_string(), title.to_string())\n+        } else {\n+            // Two posibilities:\n+            // * path-based links: `../../module/struct.MyStruct.html`\n+            // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n+            let resolved = try_resolve_intra(db, definition, title, &target).or_else(|| {\n+                try_resolve_path(db, definition, &target).map(|target| (target, title.to_string()))\n+            });\n+\n+            match resolved {\n+                Some((target, title)) => (target, title),\n+                None => (target.to_string(), title.to_string()),\n+            }\n+        }\n+    });\n+    let mut out = String::new();\n+    cmark(doc, &mut out, None).ok();\n+    out\n+}\n+\n+// Rewrites a markdown document, resolving links using `callback` and additionally striping prefixes/suffixes on link titles.\n+fn map_links<'e>(\n+    events: impl Iterator<Item = Event<'e>>,\n+    callback: impl Fn(&str, &str) -> (String, String),\n+) -> impl Iterator<Item = Event<'e>> {\n+    let mut in_link = false;\n+    let mut link_target: Option<CowStr> = None;\n+\n+    events.map(move |evt| match evt {\n+        Event::Start(Tag::Link(_link_type, ref target, _)) => {\n+            in_link = true;\n+            link_target = Some(target.clone());\n+            evt\n+        }\n+        Event::End(Tag::Link(link_type, _target, _)) => {\n+            in_link = false;\n+            Event::End(Tag::Link(link_type, link_target.take().unwrap(), CowStr::Borrowed(\"\")))\n+        }\n+        Event::Text(s) if in_link => {\n+            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n+            link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            Event::Text(CowStr::Boxed(link_name.into()))\n+        }\n+        Event::Code(s) if in_link => {\n+            let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n+            link_target = Some(CowStr::Boxed(link_target_s.into()));\n+            Event::Code(CowStr::Boxed(link_name.into()))\n+        }\n+        _ => evt,\n+    })\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Copy, Clone, Debug)]\n+enum Namespace {\n+    Types,\n+    Values,\n+    Macros,\n+}\n+\n+static TYPES: ([&str; 7], [&str; 0]) =\n+    ([\"type\", \"struct\", \"enum\", \"mod\", \"trait\", \"union\", \"module\"], []);\n+static VALUES: ([&str; 8], [&str; 1]) =\n+    ([\"value\", \"function\", \"fn\", \"method\", \"const\", \"static\", \"mod\", \"module\"], [\"()\"]);\n+static MACROS: ([&str; 1], [&str; 1]) = ([\"macro\"], [\"!\"]);\n+\n+impl Namespace {\n+    /// Extract the specified namespace from an intra-doc-link if one exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// * `struct MyStruct` -> `Namespace::Types`\n+    /// * `panic!` -> `Namespace::Macros`\n+    /// * `fn@from_intra_spec` -> `Namespace::Values`\n+    fn from_intra_spec(s: &str) -> Option<Self> {\n+        [\n+            (Namespace::Types, (TYPES.0.iter(), TYPES.1.iter())),\n+            (Namespace::Values, (VALUES.0.iter(), VALUES.1.iter())),\n+            (Namespace::Macros, (MACROS.0.iter(), MACROS.1.iter())),\n+        ]\n+        .iter()\n+        .filter(|(_ns, (prefixes, suffixes))| {\n+            prefixes\n+                .clone()\n+                .map(|prefix| {\n+                    s.starts_with(*prefix)\n+                        && s.chars()\n+                            .nth(prefix.len() + 1)\n+                            .map(|c| c == '@' || c == ' ')\n+                            .unwrap_or(false)\n+                })\n+                .any(|cond| cond)\n+                || suffixes\n+                    .clone()\n+                    .map(|suffix| {\n+                        s.starts_with(*suffix)\n+                            && s.chars()\n+                                .nth(suffix.len() + 1)\n+                                .map(|c| c == '@' || c == ' ')\n+                                .unwrap_or(false)\n+                    })\n+                    .any(|cond| cond)\n+        })\n+        .map(|(ns, (_, _))| *ns)\n+        .next()\n+    }\n+}\n+\n+// Strip prefixes, suffixes, and inline code marks from the given string.\n+fn strip_prefixes_suffixes(mut s: &str) -> &str {\n+    s = s.trim_matches('`');\n+\n+    [\n+        (TYPES.0.iter(), TYPES.1.iter()),\n+        (VALUES.0.iter(), VALUES.1.iter()),\n+        (MACROS.0.iter(), MACROS.1.iter()),\n+    ]\n+    .iter()\n+    .for_each(|(prefixes, suffixes)| {\n+        prefixes.clone().for_each(|prefix| s = s.trim_start_matches(*prefix));\n+        suffixes.clone().for_each(|suffix| s = s.trim_end_matches(*suffix));\n+    });\n+    s.trim_start_matches(\"@\").trim()\n+}\n+\n+/// Try to resolve path to local documentation via intra-doc-links (i.e. `super::gateway::Shard`).\n+///\n+/// See [RFC1946](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md).\n+fn try_resolve_intra(\n+    db: &RootDatabase,\n+    definition: &Definition,\n+    link_text: &str,\n+    link_target: &str,\n+) -> Option<(String, String)> {\n+    eprintln!(\"resolving intra\");\n+\n+    // Set link_target for implied shortlinks\n+    let link_target =\n+        if link_target.is_empty() { link_text.trim_matches('`') } else { link_target };\n+\n+    // Namespace disambiguation\n+    let namespace = Namespace::from_intra_spec(link_target);\n+\n+    // Strip prefixes/suffixes\n+    let link_target = strip_prefixes_suffixes(link_target);\n+\n+    // Parse link as a module path\n+    let path = Path::parse(link_target).ok()?;\n+    let modpath = ModPath::from_src(path, &Hygiene::new_unhygienic()).unwrap();\n+\n+    // Resolve it relative to symbol's location (according to the RFC this should consider small scopes\n+    let resolver = definition.resolver(db)?;\n+\n+    let resolved = resolver.resolve_module_path_in_items(db, &modpath);\n+    let (defid, namespace) = match namespace {\n+        // FIXME: .or(resolved.macros)\n+        None => resolved\n+            .types\n+            .map(|t| (t.0, Namespace::Types))\n+            .or(resolved.values.map(|t| (t.0, Namespace::Values)))?,\n+        Some(ns @ Namespace::Types) => (resolved.types?.0, ns),\n+        Some(ns @ Namespace::Values) => (resolved.values?.0, ns),\n+        // FIXME:\n+        Some(Namespace::Macros) => None?,\n+    };\n+\n+    // Get the filepath of the final symbol\n+    let def: ModuleDef = defid.into();\n+    let module = def.module(db)?;\n+    let krate = module.krate();\n+    let ns = match namespace {\n+        Namespace::Types => ItemInNs::Types(defid),\n+        Namespace::Values => ItemInNs::Values(defid),\n+        // FIXME:\n+        Namespace::Macros => None?,\n+    };\n+    let import_map = db.import_map(krate.into());\n+    let path = import_map.path_of(ns)?;\n+\n+    Some((\n+        get_doc_url(db, &krate)?\n+            .join(&format!(\"{}/\", krate.display_name(db)?))\n+            .ok()?\n+            .join(&path.segments.iter().map(|name| name.to_string()).join(\"/\"))\n+            .ok()?\n+            .join(&get_symbol_filename(db, &Definition::ModuleDef(def))?)\n+            .ok()?\n+            .into_string(),\n+        strip_prefixes_suffixes(link_text).to_string(),\n+    ))\n+}\n+\n+/// Try to resolve path to local documentation via path-based links (i.e. `../gateway/struct.Shard.html`).\n+fn try_resolve_path(db: &RootDatabase, definition: &Definition, link: &str) -> Option<String> {\n+    eprintln!(\"resolving path\");\n+\n+    if !link.contains(\"#\") && !link.contains(\".html\") {\n+        return None;\n+    }\n+    let ns = if let Definition::ModuleDef(moddef) = definition {\n+        ItemInNs::Types(moddef.clone().into())\n+    } else {\n+        return None;\n+    };\n+    let module = definition.module(db)?;\n+    let krate = module.krate();\n+    let import_map = db.import_map(krate.into());\n+    let base = once(format!(\"{}\", krate.display_name(db)?))\n+        .chain(import_map.path_of(ns)?.segments.iter().map(|name| format!(\"{}\", name)))\n+        .join(\"/\");\n+\n+    get_doc_url(db, &krate)\n+        .and_then(|url| url.join(&base).ok())\n+        .and_then(|url| {\n+            get_symbol_filename(db, definition).as_deref().map(|f| url.join(f).ok()).flatten()\n+        })\n+        .and_then(|url| url.join(link).ok())\n+        .map(|url| url.into_string())\n+}\n+\n+/// Try to get the root URL of the documentation of a crate.\n+fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+    // Look for #![doc(html_root_url = \"...\")]\n+    let attrs = db.attrs(AttrDef::from(krate.root_module(db)?).into());\n+    let doc_attr_q = attrs.by_key(\"doc\");\n+\n+    let doc_url = if doc_attr_q.exists() {\n+        doc_attr_q.tt_values().map(|tt| {\n+            let name = tt.token_trees.iter()\n+                .skip_while(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Ident(Ident{text: ref ident, ..})) if ident == \"html_root_url\"))\n+                .skip(2)\n+                .next();\n+\n+            match name {\n+                Some(TokenTree::Leaf(Leaf::Literal(Literal{ref text, ..}))) => Some(text),\n+                _ => None\n+            }\n+        }).flat_map(|t| t).next().map(|s| s.to_string())\n+    } else {\n+        // Fallback to docs.rs\n+        // FIXME: Specify an exact version here (from Cargo.lock)\n+        Some(format!(\"https://docs.rs/{}/*\", krate.display_name(db)?))\n+    };\n+\n+    doc_url\n+        .map(|s| s.trim_matches('\"').trim_end_matches(\"/\").to_owned() + \"/\")\n+        .and_then(|s| Url::parse(&s).ok())\n+}\n+\n+/// Get the filename and extension generated for a symbol by rustdoc.\n+///\n+/// Example: `struct.Shard.html`\n+fn get_symbol_filename(db: &RootDatabase, definition: &Definition) -> Option<String> {\n+    Some(match definition {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Adt(adt) => match adt {\n+                Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n+                Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n+                Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n+            },\n+            ModuleDef::Module(_) => \"index.html\".to_string(),\n+            ModuleDef::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n+            ModuleDef::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n+            ModuleDef::BuiltinType(t) => format!(\"primitive.{}.html\", t.as_name()),\n+            ModuleDef::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n+            ModuleDef::EnumVariant(ev) => {\n+                format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n+            }\n+            ModuleDef::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n+            ModuleDef::Static(s) => format!(\"static.{}.html\", s.name(db)?),\n+        },\n+        Definition::Macro(m) => format!(\"macro.{}.html\", m.name(db)?),\n+        _ => None?,\n+    })\n+}"}, {"sha": "2096a14a20e45d505633a739be943f067dbc99e4", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19c2830ff86b8765754827b03826870f8640dec2/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19c2830ff86b8765754827b03826870f8640dec2/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=19c2830ff86b8765754827b03826870f8640dec2", "patch": "@@ -53,6 +53,7 @@ fn rust_files_are_tidy() {\n fn check_licenses() {\n     let expected = \"\n 0BSD OR MIT OR Apache-2.0\n+Apache-2.0\n Apache-2.0 OR BSL-1.0\n Apache-2.0 OR MIT\n Apache-2.0/MIT"}]}