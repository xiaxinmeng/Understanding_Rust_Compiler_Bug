{"sha": "1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhOTIzOWM5NjRmNDU4OWM3ZjE2NDZhMWZhZjg0MTJlYjBjMzdhMGU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-11-26T16:26:15Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-18T01:14:46Z"}, "message": "Report errors not caught by the old visitor as warnings", "tree": {"sha": "c4d27d89e3ad1d702d7df18473ed36d6e07cf266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4d27d89e3ad1d702d7df18473ed36d6e07cf266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "html_url": "https://github.com/rust-lang/rust/commit/1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73307475f9bc405d3aebd6f3a5240b364746217d", "url": "https://api.github.com/repos/rust-lang/rust/commits/73307475f9bc405d3aebd6f3a5240b364746217d", "html_url": "https://github.com/rust-lang/rust/commit/73307475f9bc405d3aebd6f3a5240b364746217d"}], "stats": {"total": 418, "additions": 390, "deletions": 28}, "files": [{"sha": "b65c0c194979ead7c56fd43c2209b1a3b786bb4a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 372, "deletions": 14, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "patch": "@@ -46,7 +46,7 @@ use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::ExternalExports;\n use rustc::middle::ty;\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::{NodeMap, NodeSet};\n use rustc::front::map as ast_map;\n \n use syntax::ast;\n@@ -1101,6 +1101,348 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+/// Obsolete visitors for checking for private items in public interfaces.\n+/// These visitors are supposed to be kept in frozen state and produce an\n+/// \"old error node set\". For backward compatibility the new visitor reports\n+/// warnings instead of hard errors when the erroneous node is not in this old set.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    access_levels: &'a AccessLevels,\n+    in_variant: bool,\n+    // set of errors produced by this obsolete visitor\n+    old_error_set: NodeSet,\n+}\n+\n+struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    inner: &'a ObsoleteVisiblePrivateTypesVisitor<'b, 'tcx>,\n+    /// whether the type refers to private types.\n+    contains_private: bool,\n+    /// whether we've recurred at all (i.e. if we're pointing at the\n+    /// first type on which visit_ty was called).\n+    at_outer_type: bool,\n+    // whether that first type is a public path.\n+    outer_type_is_public_path: bool,\n+}\n+\n+impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n+    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n+        let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n+            // `int` etc. (None doesn't seem to occur.)\n+            None | Some(def::DefPrimTy(..)) | Some(def::DefSelfTy(..)) => return false,\n+            Some(def) => def.def_id(),\n+        };\n+\n+        // A path can only be private if:\n+        // it's in this crate...\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            // .. and it corresponds to a private type in the AST (this returns\n+            // None for type parameters)\n+            match self.tcx.map.find(node_id) {\n+                Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n+                Some(_) | None => false,\n+            }\n+        } else {\n+            return false\n+        }\n+    }\n+\n+    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n+        // FIXME: this would preferably be using `exported_items`, but all\n+        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n+        self.access_levels.is_public(trait_id)\n+    }\n+\n+    fn check_ty_param_bound(&mut self,\n+                            ty_param_bound: &hir::TyParamBound) {\n+        if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n+            if self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n+                self.old_error_set.insert(trait_ref.trait_ref.ref_id);\n+            }\n+        }\n+    }\n+\n+    fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n+        self.access_levels.is_reachable(*id) || vis == hir::Public\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyPath(..) = ty.node {\n+            if self.inner.path_is_private_type(ty.id) {\n+                self.contains_private = true;\n+                // found what we're looking for so let's stop\n+                // working.\n+                return\n+            } else if self.at_outer_type {\n+                self.outer_type_is_public_path = true;\n+            }\n+        }\n+        self.at_outer_type = false;\n+        intravisit::walk_ty(self, ty)\n+    }\n+\n+    // don't want to recurse into [, .. expr]\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n+    /// We want to visit items in the context of their containing\n+    /// module and so forth, so supply a crate for doing a deep walk.\n+    fn visit_nested_item(&mut self, item: hir::ItemId) {\n+        self.visit_item(self.tcx.map.expect_item(item.id))\n+    }\n+\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        match item.node {\n+            // contents of a private mod can be reexported, so we need\n+            // to check internals.\n+            hir::ItemMod(_) => {}\n+\n+            // An `extern {}` doesn't introduce a new privacy\n+            // namespace (the contents have their own privacies).\n+            hir::ItemForeignMod(_) => {}\n+\n+            hir::ItemTrait(_, _, ref bounds, _) => {\n+                if !self.trait_is_public(item.id) {\n+                    return\n+                }\n+\n+                for bound in bounds.iter() {\n+                    self.check_ty_param_bound(bound)\n+                }\n+            }\n+\n+            // impls need some special handling to try to offer useful\n+            // error messages without (too many) false positives\n+            // (i.e. we could just return here to not check them at\n+            // all, or some worse estimation of whether an impl is\n+            // publicly visible).\n+            hir::ItemImpl(_, _, ref g, ref trait_ref, ref self_, ref impl_items) => {\n+                // `impl [... for] Private` is never visible.\n+                let self_contains_private;\n+                // impl [... for] Public<...>, but not `impl [... for]\n+                // Vec<Public>` or `(Public,)` etc.\n+                let self_is_public_path;\n+\n+                // check the properties of the Self type:\n+                {\n+                    let mut visitor = ObsoleteCheckTypeForPrivatenessVisitor {\n+                        inner: self,\n+                        contains_private: false,\n+                        at_outer_type: true,\n+                        outer_type_is_public_path: false,\n+                    };\n+                    visitor.visit_ty(&**self_);\n+                    self_contains_private = visitor.contains_private;\n+                    self_is_public_path = visitor.outer_type_is_public_path;\n+                }\n+\n+                // miscellaneous info about the impl\n+\n+                // `true` iff this is `impl Private for ...`.\n+                let not_private_trait =\n+                    trait_ref.as_ref().map_or(true, // no trait counts as public trait\n+                                              |tr| {\n+                        let did = self.tcx.trait_ref_to_def_id(tr);\n+\n+                        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+                            self.trait_is_public(node_id)\n+                        } else {\n+                            true // external traits must be public\n+                        }\n+                    });\n+\n+                // `true` iff this is a trait impl or at least one method is public.\n+                //\n+                // `impl Public { $( fn ...() {} )* }` is not visible.\n+                //\n+                // This is required over just using the methods' privacy\n+                // directly because we might have `impl<T: Foo<Private>> ...`,\n+                // and we shouldn't warn about the generics if all the methods\n+                // are private (because `T` won't be visible externally).\n+                let trait_or_some_public_method =\n+                    trait_ref.is_some() ||\n+                    impl_items.iter()\n+                              .any(|impl_item| {\n+                                  match impl_item.node {\n+                                      hir::ImplItemKind::Const(..) |\n+                                      hir::ImplItemKind::Method(..) => {\n+                                          self.access_levels.is_reachable(impl_item.id)\n+                                      }\n+                                      hir::ImplItemKind::Type(_) => false,\n+                                  }\n+                              });\n+\n+                if !self_contains_private &&\n+                        not_private_trait &&\n+                        trait_or_some_public_method {\n+\n+                    intravisit::walk_generics(self, g);\n+\n+                    match *trait_ref {\n+                        None => {\n+                            for impl_item in impl_items {\n+                                // This is where we choose whether to walk down\n+                                // further into the impl to check its items. We\n+                                // should only walk into public items so that we\n+                                // don't erroneously report errors for private\n+                                // types in private items.\n+                                match impl_item.node {\n+                                    hir::ImplItemKind::Const(..) |\n+                                    hir::ImplItemKind::Method(..)\n+                                        if self.item_is_public(&impl_item.id, impl_item.vis) =>\n+                                    {\n+                                        intravisit::walk_impl_item(self, impl_item)\n+                                    }\n+                                    hir::ImplItemKind::Type(..) => {\n+                                        intravisit::walk_impl_item(self, impl_item)\n+                                    }\n+                                    _ => {}\n+                                }\n+                            }\n+                        }\n+                        Some(ref tr) => {\n+                            // Any private types in a trait impl fall into three\n+                            // categories.\n+                            // 1. mentioned in the trait definition\n+                            // 2. mentioned in the type params/generics\n+                            // 3. mentioned in the associated types of the impl\n+                            //\n+                            // Those in 1. can only occur if the trait is in\n+                            // this crate and will've been warned about on the\n+                            // trait definition (there's no need to warn twice\n+                            // so we don't check the methods).\n+                            //\n+                            // Those in 2. are warned via walk_generics and this\n+                            // call here.\n+                            intravisit::walk_path(self, &tr.path);\n+\n+                            // Those in 3. are warned with this call.\n+                            for impl_item in impl_items {\n+                                if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n+                                    self.visit_ty(ty);\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else if trait_ref.is_none() && self_is_public_path {\n+                    // impl Public<Private> { ... }. Any public static\n+                    // methods will be visible as `Public::foo`.\n+                    let mut found_pub_static = false;\n+                    for impl_item in impl_items {\n+                        match impl_item.node {\n+                            hir::ImplItemKind::Const(..) => {\n+                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                    found_pub_static = true;\n+                                    intravisit::walk_impl_item(self, impl_item);\n+                                }\n+                            }\n+                            hir::ImplItemKind::Method(ref sig, _) => {\n+                                if sig.explicit_self.node == hir::SelfStatic &&\n+                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                    found_pub_static = true;\n+                                    intravisit::walk_impl_item(self, impl_item);\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    if found_pub_static {\n+                        intravisit::walk_generics(self, g)\n+                    }\n+                }\n+                return\n+            }\n+\n+            // `type ... = ...;` can contain private types, because\n+            // we're introducing a new name.\n+            hir::ItemTy(..) => return,\n+\n+            // not at all public, so we don't care\n+            _ if !self.item_is_public(&item.id, item.vis) => {\n+                return;\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // We've carefully constructed it so that if we're here, then\n+        // any `visit_ty`'s will be called on things that are in\n+        // public signatures, i.e. things that we're interested in for\n+        // this visitor.\n+        debug!(\"VisiblePrivateTypesVisitor entering item {:?}\", item);\n+        intravisit::walk_item(self, item);\n+    }\n+\n+    fn visit_generics(&mut self, generics: &hir::Generics) {\n+        for ty_param in generics.ty_params.iter() {\n+            for bound in ty_param.bounds.iter() {\n+                self.check_ty_param_bound(bound)\n+            }\n+        }\n+        for predicate in &generics.where_clause.predicates {\n+            match predicate {\n+                &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                    for bound in bound_pred.bounds.iter() {\n+                        self.check_ty_param_bound(bound)\n+                    }\n+                }\n+                &hir::WherePredicate::RegionPredicate(_) => {}\n+                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+                    self.visit_ty(&*eq_pred.ty);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n+        if self.access_levels.is_reachable(item.id) {\n+            intravisit::walk_foreign_item(self, item)\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, t: &hir::Ty) {\n+        debug!(\"VisiblePrivateTypesVisitor checking ty {:?}\", t);\n+        if let hir::TyPath(..) = t.node {\n+            if self.path_is_private_type(t.id) {\n+                self.old_error_set.insert(t.id);\n+            }\n+        }\n+        intravisit::walk_ty(self, t)\n+    }\n+\n+    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n+        if self.access_levels.is_reachable(v.node.data.id()) {\n+            self.in_variant = true;\n+            intravisit::walk_variant(self, v, g, item_id);\n+            self.in_variant = false;\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &hir::StructField) {\n+        let vis = match s.node.kind {\n+            hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n+        };\n+        if vis == hir::Public || self.in_variant {\n+            intravisit::walk_struct_field(self, s);\n+        }\n+    }\n+\n+    // we don't need to introspect into these at all: an\n+    // expression/block context can't possibly contain exported things.\n+    // (Making them no-ops stops us from traversing the whole AST without\n+    // having to be super careful about our `walk_...` calls above.)\n+    // FIXME(#29524): Unfortunately this ^^^ is not true, blocks can contain\n+    // exported items (e.g. impls) and actual code in rustc itself breaks\n+    // if we don't traverse blocks in `EmbargoVisitor`\n+    fn visit_block(&mut self, _: &hir::Block) {}\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n /// SearchInterfaceForPrivateItemsVisitor traverses an item's interface and\n /// finds any private components in it.\n@@ -1114,6 +1456,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     is_quiet: bool,\n     // Is private component found?\n     is_public: bool,\n+    old_error_set: &'a NodeSet,\n }\n \n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n@@ -1145,8 +1488,9 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                             }\n                             if item.vis != hir::Public {\n                                 if !self.is_quiet {\n-                                    span_err!(self.tcx.sess, ty.span, E0446,\n-                                              \"private type in public interface\");\n+                                    let is_warning = !self.old_error_set.contains(&ty.id);\n+                                    span_err_or_warn!(is_warning, self.tcx.sess, ty.span, E0446,\n+                                                      \"private type in public interface\");\n                                 }\n                                 self.is_public = false;\n                             }\n@@ -1171,8 +1515,9 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n             if let Some(ast_map::NodeItem(ref item)) = self.tcx.map.find(node_id) {\n                 if item.vis != hir::Public {\n                     if !self.is_quiet {\n-                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                  \"private trait in public interface\");\n+                        let is_warning = !self.old_error_set.contains(&trait_ref.ref_id);\n+                        span_err_or_warn!(is_warning, self.tcx.sess, trait_ref.path.span, E0445,\n+                                          \"private trait in public interface\");\n                     }\n                     self.is_public = false;\n                 }\n@@ -1192,13 +1537,14 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+    old_error_set: &'a NodeSet,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     // A type is considered public if it doesn't contain any private components\n     fn is_public_ty(&self, ty: &hir::Ty) -> bool {\n         let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true\n+            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n         };\n         check.visit_ty(ty);\n         check.is_public\n@@ -1207,7 +1553,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     // A trait is considered public if it doesn't contain any private components\n     fn is_public_trait(&self, trait_ref: &hir::TraitRef) -> bool {\n         let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true\n+            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n         };\n         check.visit_trait_ref(trait_ref);\n         check.is_public\n@@ -1217,7 +1563,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: false, is_public: true\n+            tcx: self.tcx, is_quiet: false, is_public: true, old_error_set: self.old_error_set\n         };\n         match item.node {\n             // Crates are always public\n@@ -1314,12 +1660,6 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     tcx.sess.abort_if_errors();\n \n-    // Check for private types and traits in public interfaces\n-    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n-        tcx: tcx,\n-    };\n-    krate.visit_all_items(&mut visitor);\n-\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n@@ -1338,6 +1678,24 @@ pub fn check_crate(tcx: &ty::ctxt,\n         }\n     }\n     visitor.update(ast::CRATE_NODE_ID, Some(AccessLevel::Public));\n+\n+    {\n+        let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n+            tcx: tcx,\n+            access_levels: &visitor.access_levels,\n+            in_variant: false,\n+            old_error_set: NodeSet(),\n+        };\n+        intravisit::walk_crate(&mut visitor, krate);\n+\n+        // Check for private types and traits in public interfaces\n+        let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+            tcx: tcx,\n+            old_error_set: &visitor.old_error_set,\n+        };\n+        krate.visit_all_items(&mut visitor);\n+    }\n+\n     visitor.access_levels\n }\n "}, {"sha": "34a623846935a11f95f7cb3b0c2007ea04d25842", "filename": "src/test/compile-fail/issue-28325.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Ftest%2Fcompile-fail%2Fissue-28325.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Ftest%2Fcompile-fail%2Fissue-28325.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28325.rs?ref=1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "patch": "@@ -10,13 +10,16 @@\n \n // Checks for private types in public interfaces\n \n+#![feature(rustc_attrs)]\n+#![allow(dead_code, unused_variables)]\n+\n mod y {\n     pub struct Foo { x: u32 }\n \n     struct Bar { x: u32 }\n \n     impl Foo {\n-        pub fn foo(&self, x: Self, y: Bar) { } //~ ERROR private type in public interface\n+        pub fn foo(&self, x: Self, y: Bar) { } //~ WARN private type in public interface\n     }\n }\n \n@@ -26,13 +29,14 @@ mod x {\n     struct Bar { _x: u32 }\n \n     impl Foo {\n-        pub fn foo(&self, _x: Self, _y: Bar) { } //~ ERROR private type in public interface\n+        pub fn foo(&self, _x: Self, _y: Bar) { } //~ WARN private type in public interface\n         pub fn bar(&self) -> Bar { Bar { _x: self.x } }\n-        //~^ ERROR private type in public interface\n+        //~^ WARN private type in public interface\n     }\n }\n \n-pub fn main() {\n+#[rustc_error]\n+pub fn main() { //~ ERROR compilation successful\n     let f = x::Foo { x: 4 };\n     let b = f.bar();\n     f.foo(x::Foo { x: 5 }, b);"}, {"sha": "2e07305185818ba4bef13fccc568659fb613278f", "filename": "src/test/compile-fail/issue-28450.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Ftest%2Fcompile-fail%2Fissue-28450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Ftest%2Fcompile-fail%2Fissue-28450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28450.rs?ref=1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "patch": "@@ -15,18 +15,18 @@ struct Priv;\n pub use self::private::public;\n \n mod private {\n-    pub type Priv = super::Priv; //~ ERROR private type in public interface\n+    pub type Priv = super::Priv; //~ WARN private type in public interface\n \n     pub fn public(_x: Priv) {\n     }\n }\n \n struct __CFArray;\n-pub type CFArrayRef = *const __CFArray; //~ ERROR private type in public interface\n+pub type CFArrayRef = *const __CFArray; //~ WARN private type in public interface\n trait Pointer { type Pointee; }\n impl<T> Pointer for *const T { type Pointee = T; }\n pub type __CFArrayRevealed = <CFArrayRef as Pointer>::Pointee;\n-//~^ ERROR private type in public interface\n+//~^ WARN private type in public interface\n \n type Foo = u8;\n pub fn foo(f: Foo) {} //~ ERROR private type in public interface\n@@ -43,7 +43,7 @@ pub fn block() -> <Helper as Exporter>::Output {\n     }\n \n     impl Exporter for Helper {\n-        type Output = Inner; //~ ERROR private type in public interface\n+        type Output = Inner; //~ WARN private type in public interface\n     }\n \n     Inner"}, {"sha": "154acbcfd60f4bf892f4e65c2fb910342bbd8749", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a9239c964f4589c7f1646a1faf8412eb0c37a0e/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=1a9239c964f4589c7f1646a1faf8412eb0c37a0e", "patch": "@@ -75,8 +75,8 @@ pub trait PubTrait {\n }\n \n impl PubTrait for Public<isize> {\n-    fn bar(&self) -> Private<isize> { panic!() } //~ ERROR private type in public interface\n-    fn baz() -> Private<isize> { panic!() } //~ ERROR private type in public interface\n+    fn bar(&self) -> Private<isize> { panic!() } //~ WARN private type in public interface\n+    fn baz() -> Private<isize> { panic!() } //~ WARN private type in public interface\n }\n impl PubTrait for Public<Private<isize>> {\n     fn bar(&self) -> Private<isize> { panic!() }\n@@ -132,11 +132,11 @@ impl PrivTrait2 for Private<isize> {\n }\n \n impl PubTrait for PrivAlias {\n-    fn bar(&self) -> Private<isize> { panic!() } //~ ERROR private type in public interface\n-    fn baz() -> Private<isize> { panic!() } //~ ERROR private type in public interface\n+    fn bar(&self) -> Private<isize> { panic!() } //~ WARN private type in public interface\n+    fn baz() -> Private<isize> { panic!() } //~ WARN private type in public interface\n }\n \n impl PubTrait for <Private<isize> as PrivTrait2>::Alias {\n-    fn bar(&self) -> Private<isize> { panic!() } //~ ERROR private type in public interface\n-    fn baz() -> Private<isize> { panic!() } //~ ERROR private type in public interface\n+    fn bar(&self) -> Private<isize> { panic!() } //~ WARN private type in public interface\n+    fn baz() -> Private<isize> { panic!() } //~ WARN private type in public interface\n }"}]}