{"sha": "332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "node_id": "C_kwDOAAsO6NoAKDMzMmNjOGZiNzUyZmU5OGMyMTgzN2VkNmYzNTcxZjZhZGIwZDA4Yjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-27T14:00:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-27T14:00:53Z"}, "message": "Auto merge of #100999 - nnethercote:shrink-FnAbi, r=bjorn3\n\nShrink `FnAbi`\n\nBecause they can take up a lot of memory in debug and release builds.\n\nr? `@bjorn3`", "tree": {"sha": "006a0c638d4ebdbc938bd557054f907e3ed6dbd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/006a0c638d4ebdbc938bd557054f907e3ed6dbd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "html_url": "https://github.com/rust-lang/rust/commit/332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b3f3b72c5f6ebee82a0530ae40284926bb193b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b3f3b72c5f6ebee82a0530ae40284926bb193b3", "html_url": "https://github.com/rust-lang/rust/commit/3b3f3b72c5f6ebee82a0530ae40284926bb193b3"}, {"sha": "f974617bdafa2e5205c1e852fe3ce61f29e2c026", "url": "https://api.github.com/repos/rust-lang/rust/commits/f974617bdafa2e5205c1e852fe3ce61f29e2c026", "html_url": "https://github.com/rust-lang/rust/commit/f974617bdafa2e5205c1e852fe3ce61f29e2c026"}], "stats": {"total": 346, "additions": 165, "deletions": 181}, "files": [{"sha": "7f4619b5c940b12f3701ca2aebba46e92808a163", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -24,7 +24,7 @@ pub(super) fn add_arg_comment<'tcx>(\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n     params: &[Value],\n-    arg_abi_mode: PassMode,\n+    arg_abi_mode: &PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n     if !fx.clif_comments.enabled() {"}, {"sha": "96e25d3a8d4c9423ba85eea5de2006e4db2a6cd4", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -38,7 +38,7 @@ fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -\n     param\n }\n \n-fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+fn cast_target_to_abi_params(cast: &CastTarget) -> SmallVec<[AbiParam; 2]> {\n     let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n         (0, 0)\n     } else {\n@@ -100,7 +100,10 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Cast(ref cast, pad_i32) => {\n+                assert!(!pad_i32, \"padding support not yet implemented\");\n+                cast_target_to_abi_params(cast)\n+            }\n             PassMode::Indirect { attrs, extra_attrs: None, on_stack } => {\n                 if on_stack {\n                     // Abi requires aligning struct size to pointer size\n@@ -145,7 +148,9 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Cast(ref cast, _) => {\n+                (None, cast_target_to_abi_params(cast).into_iter().collect())\n+            }\n             PassMode::Indirect { attrs: _, extra_attrs: None, on_stack } => {\n                 assert!(!on_stack);\n                 (Some(AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructReturn)), vec![])\n@@ -160,7 +165,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n pub(super) fn to_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> SmallVec<[Value; 2]> {\n     let (ptr, meta) = arg.force_stack(fx);\n     assert!(meta.is_none());\n@@ -179,7 +184,7 @@ pub(super) fn from_casted_value<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     block_params: &[Value],\n     layout: TyAndLayout<'tcx>,\n-    cast: CastTarget,\n+    cast: &CastTarget,\n ) -> CValue<'tcx> {\n     let abi_params = cast_target_to_abi_params(cast);\n     let abi_param_size: u32 = abi_params.iter().map(|param| param.value_type.bytes()).sum();\n@@ -224,7 +229,7 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n             let (a, b) = arg.load_scalar_pair(fx);\n             smallvec![a, b]\n         }\n-        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Cast(ref cast, _) => to_casted_value(fx, arg, cast),\n         PassMode::Indirect { .. } => {\n             if is_owned {\n                 match arg.force_stack(fx) {\n@@ -268,7 +273,7 @@ pub(super) fn cvalue_for_param<'tcx>(\n         local,\n         local_field,\n         &block_params,\n-        arg_abi.mode,\n+        &arg_abi.mode,\n         arg_abi.layout,\n     );\n \n@@ -282,7 +287,9 @@ pub(super) fn cvalue_for_param<'tcx>(\n             assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n             Some(CValue::by_val_pair(block_params[0], block_params[1], arg_abi.layout))\n         }\n-        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Cast(ref cast, _) => {\n+            Some(from_casted_value(fx, &block_params, arg_abi.layout, cast))\n+        }\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n             assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n             Some(CValue::by_ref(Pointer::new(block_params[0]), arg_abi.layout))"}, {"sha": "aaa1418767a357680ef3b2cd5b2ad8a2d970c015", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -13,7 +13,7 @@ pub(super) fn codegen_return_param<'tcx>(\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n-        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n                 super::make_local_place(\n@@ -44,7 +44,7 @@ pub(super) fn codegen_return_param<'tcx>(\n         Some(RETURN_PLACE),\n         None,\n         &ret_param,\n-        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        &fx.fn_abi.as_ref().unwrap().ret.mode,\n         fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n@@ -75,7 +75,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n         PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n             unreachable!(\"unsized return value\")\n         }\n-        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => (None, None),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => (None, None),\n     };\n \n     let call_inst = f(fx, return_ptr);\n@@ -92,7 +92,7 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n             ret_place\n                 .write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout));\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let results =\n                 fx.bcx.inst_results(call_inst).iter().copied().collect::<SmallVec<[Value; 2]>>();\n             let result =\n@@ -131,7 +131,7 @@ pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, '_>) {\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n-        PassMode::Cast(cast) => {\n+        PassMode::Cast(ref cast, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx);\n             let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);"}, {"sha": "848c34211ff616c09c9bf2f8a62b535442646fbf", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -107,45 +107,24 @@ pub trait FnAbiGccExt<'gcc, 'tcx> {\n impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn gcc_type(&self, cx: &CodegenCx<'gcc, 'tcx>) -> (Type<'gcc>, Vec<Type<'gcc>>, bool, FxHashSet<usize>) {\n         let mut on_stack_param_indices = FxHashSet::default();\n-        let args_capacity: usize = self.args.iter().map(|arg|\n-            if arg.pad.is_some() {\n-                1\n-            }\n-            else {\n-                0\n-            } +\n-            if let PassMode::Pair(_, _) = arg.mode {\n-                2\n-            } else {\n-                1\n-            }\n-        ).sum();\n+\n+        // This capacity calculation is approximate.\n         let mut argument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect { .. } = self.ret.mode {\n-                1\n-            }\n-            else {\n-                0\n-            } + args_capacity,\n+            self.args.len() + if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 }\n         );\n \n         let return_ty =\n             match self.ret.mode {\n                 PassMode::Ignore => cx.type_void(),\n                 PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_gcc_type(cx),\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, _) => cast.gcc_type(cx),\n                 PassMode::Indirect { .. } => {\n                     argument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                     cx.type_void()\n                 }\n             };\n \n-        for arg in &self.args {\n-            // add padding\n-            if let Some(ty) = arg.pad {\n-                argument_tys.push(ty.gcc_type(cx));\n-            }\n-\n+        for arg in self.args.iter() {\n             let arg_ty = match arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_gcc_type(cx),\n@@ -157,7 +136,13 @@ impl<'gcc, 'tcx> FnAbiGccExt<'gcc, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                     unimplemented!();\n                 }\n-                PassMode::Cast(cast) => cast.gcc_type(cx),\n+                PassMode::Cast(ref cast, pad_i32) => {\n+                    // add padding\n+                    if pad_i32 {\n+                        argument_tys.push(Reg::i32().gcc_type(cx));\n+                    }\n+                    cast.gcc_type(cx)\n+                }\n                 PassMode::Indirect { extra_attrs: None, on_stack: true, .. } => {\n                     on_stack_param_indices.insert(argument_tys.len());\n                     arg.memory_ty(cx)"}, {"sha": "352fe7568eff0011fb84110c95be011cd83603a9", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 sym::volatile_load | sym::unaligned_volatile_load => {\n                     let tp_ty = substs.type_at(0);\n                     let mut ptr = args[0].immediate();\n-                    if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                    if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                         ptr = self.pointercast(ptr, self.type_ptr_to(ty.gcc_type(self)));\n                     }\n                     let load = self.volatile_load(ptr.get_type(), ptr);\n@@ -320,7 +320,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n             };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.gcc_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);\n@@ -416,7 +416,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n         else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n         }\n-        else if let PassMode::Cast(cast) = self.mode {\n+        else if let PassMode::Cast(ref cast, _) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -481,7 +481,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Indirect { extra_attrs: Some(_), .. } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             },\n-            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(_) => {\n+            PassMode::Direct(_) | PassMode::Indirect { extra_attrs: None, .. } | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             },"}, {"sha": "0ce161d7e756cfbc2960375df513f12bd917733f", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -213,7 +213,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             OperandValue::Ref(val, None, self.layout.align.abi).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized `ArgAbi` must be handled through `store_fn_arg`\");\n-        } else if let PassMode::Cast(cast) = self.mode {\n+        } else if let PassMode::Cast(cast, _) = &self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n@@ -283,7 +283,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             }\n             PassMode::Direct(_)\n             | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ }\n-            | PassMode::Cast(_) => {\n+            | PassMode::Cast(..) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             }\n@@ -325,33 +325,26 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n     fn llvm_type(&self, cx: &CodegenCx<'ll, 'tcx>) -> &'ll Type {\n         // Ignore \"extra\" args from the call site for C variadic functions.\n         // Only the \"fixed\" args are part of the LLVM function signature.\n-        let args = if self.c_variadic { &self.args[..self.fixed_count] } else { &self.args };\n+        let args =\n+            if self.c_variadic { &self.args[..self.fixed_count as usize] } else { &self.args };\n \n-        let args_capacity: usize = args.iter().map(|arg|\n-            if arg.pad.is_some() { 1 } else { 0 } +\n-            if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n-        ).sum();\n+        // This capacity calculation is approximate.\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 } + args_capacity,\n+            self.args.len() + if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 },\n         );\n \n-        let llreturn_ty = match self.ret.mode {\n+        let llreturn_ty = match &self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n-            PassMode::Cast(cast) => cast.llvm_type(cx),\n+            PassMode::Cast(cast, _) => cast.llvm_type(cx),\n             PassMode::Indirect { .. } => {\n                 llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                 cx.type_void()\n             }\n         };\n \n         for arg in args {\n-            // add padding\n-            if let Some(ty) = arg.pad {\n-                llargument_tys.push(ty.llvm_type(cx));\n-            }\n-\n-            let llarg_ty = match arg.mode {\n+            let llarg_ty = match &arg.mode {\n                 PassMode::Ignore => continue,\n                 PassMode::Direct(_) => arg.layout.immediate_llvm_type(cx),\n                 PassMode::Pair(..) => {\n@@ -366,7 +359,13 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::Cast(cast) => cast.llvm_type(cx),\n+                PassMode::Cast(cast, pad_i32) => {\n+                    // add padding\n+                    if *pad_i32 {\n+                        llargument_tys.push(Reg::i32().llvm_type(cx));\n+                    }\n+                    cast.llvm_type(cx)\n+                }\n                 PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n                     cx.type_ptr_to(arg.memory_ty(cx))\n                 }\n@@ -426,46 +425,46 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             i += 1;\n             i - 1\n         };\n-        match self.ret.mode {\n-            PassMode::Direct(ref attrs) => {\n+        match &self.ret.mode {\n+            PassMode::Direct(attrs) => {\n                 attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n-            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+            PassMode::Indirect { attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(attrs);\n                 let sret = llvm::CreateStructRetAttr(cx.llcx, self.ret.layout.llvm_type(cx));\n                 attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n-            PassMode::Cast(cast) => {\n+            PassMode::Cast(cast, _) => {\n                 cast.attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, cx, llfn);\n             }\n             _ => {}\n         }\n-        for arg in &self.args {\n-            if arg.pad.is_some() {\n-                apply(&ArgAttributes::new());\n-            }\n-            match arg.mode {\n+        for arg in self.args.iter() {\n+            match &arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(attrs);\n                     let byval = llvm::CreateByValAttr(cx.llcx, arg.layout.llvm_type(cx));\n                     attributes::apply_to_llfn(llfn, llvm::AttributePlace::Argument(i), &[byval]);\n                 }\n-                PassMode::Direct(ref attrs)\n-                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                PassMode::Direct(attrs)\n+                | PassMode::Indirect { attrs, extra_attrs: None, on_stack: false } => {\n                     apply(attrs);\n                 }\n-                PassMode::Indirect { ref attrs, extra_attrs: Some(ref extra_attrs), on_stack } => {\n+                PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack } => {\n                     assert!(!on_stack);\n                     apply(attrs);\n                     apply(extra_attrs);\n                 }\n-                PassMode::Pair(ref a, ref b) => {\n+                PassMode::Pair(a, b) => {\n                     apply(a);\n                     apply(b);\n                 }\n-                PassMode::Cast(cast) => {\n+                PassMode::Cast(cast, pad_i32) => {\n+                    if *pad_i32 {\n+                        apply(&ArgAttributes::new());\n+                    }\n                     apply(&cast.attrs);\n                 }\n             }\n@@ -488,17 +487,17 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             i += 1;\n             i - 1\n         };\n-        match self.ret.mode {\n-            PassMode::Direct(ref attrs) => {\n+        match &self.ret.mode {\n+            PassMode::Direct(attrs) => {\n                 attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, bx.cx, callsite);\n             }\n-            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+            PassMode::Indirect { attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);\n                 let i = apply(bx.cx, attrs);\n                 let sret = llvm::CreateStructRetAttr(bx.cx.llcx, self.ret.layout.llvm_type(bx));\n                 attributes::apply_to_callsite(callsite, llvm::AttributePlace::Argument(i), &[sret]);\n             }\n-            PassMode::Cast(cast) => {\n+            PassMode::Cast(cast, _) => {\n                 cast.attrs.apply_attrs_to_callsite(\n                     llvm::AttributePlace::ReturnValue,\n                     &bx.cx,\n@@ -517,13 +516,10 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                 }\n             }\n         }\n-        for arg in &self.args {\n-            if arg.pad.is_some() {\n-                apply(bx.cx, &ArgAttributes::new());\n-            }\n-            match arg.mode {\n+        for arg in self.args.iter() {\n+            match &arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                PassMode::Indirect { attrs, extra_attrs: None, on_stack: true } => {\n                     let i = apply(bx.cx, attrs);\n                     let byval = llvm::CreateByValAttr(bx.cx.llcx, arg.layout.llvm_type(bx));\n                     attributes::apply_to_callsite(\n@@ -532,23 +528,22 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                         &[byval],\n                     );\n                 }\n-                PassMode::Direct(ref attrs)\n-                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                PassMode::Direct(attrs)\n+                | PassMode::Indirect { attrs, extra_attrs: None, on_stack: false } => {\n                     apply(bx.cx, attrs);\n                 }\n-                PassMode::Indirect {\n-                    ref attrs,\n-                    extra_attrs: Some(ref extra_attrs),\n-                    on_stack: _,\n-                } => {\n+                PassMode::Indirect { attrs, extra_attrs: Some(extra_attrs), on_stack: _ } => {\n                     apply(bx.cx, attrs);\n                     apply(bx.cx, extra_attrs);\n                 }\n-                PassMode::Pair(ref a, ref b) => {\n+                PassMode::Pair(a, b) => {\n                     apply(bx.cx, a);\n                     apply(bx.cx, b);\n                 }\n-                PassMode::Cast(cast) => {\n+                PassMode::Cast(cast, pad_i32) => {\n+                    if *pad_i32 {\n+                        apply(bx.cx, &ArgAttributes::new());\n+                    }\n                     apply(bx.cx, &cast.attrs);\n                 }\n             }"}, {"sha": "f4227fbd8fa3b9528ee224afb7f7ab6923071827", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -161,7 +161,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let ptr = args[0].immediate();\n-                let load = if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                let load = if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                     let llty = ty.llvm_type(self);\n                     let ptr = self.pointercast(ptr, self.type_ptr_to(llty));\n                     self.volatile_load(llty, ptr)\n@@ -374,7 +374,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n                 let ptr_llty = self.type_ptr_to(ty.llvm_type(self));\n                 let ptr = self.pointercast(result.llval, ptr_llty);\n                 self.store(llval, ptr, result.align);"}, {"sha": "5c67d3b6431fd5f346438bde0fe17ecb19904f72", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n-use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode, Reg};\n use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n@@ -324,7 +324,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.unreachable();\n             return;\n         }\n-        let llval = match self.fn_abi.ret.mode {\n+        let llval = match &self.fn_abi.ret.mode {\n             PassMode::Ignore | PassMode::Indirect { .. } => {\n                 bx.ret_void();\n                 return;\n@@ -339,7 +339,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            PassMode::Cast(cast_ty) => {\n+            PassMode::Cast(cast_ty, _) => {\n                 let op = match self.locals[mir::RETURN_PLACE] {\n                     LocalRef::Operand(Some(op)) => op,\n                     LocalRef::Operand(None) => bug!(\"use of return before def\"),\n@@ -360,7 +360,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         llval\n                     }\n                 };\n-                let ty = bx.cast_backend_type(&cast_ty);\n+                let ty = bx.cast_backend_type(cast_ty);\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n                 bx.load(ty, addr, self.fn_abi.ret.layout.align.abi)\n             }\n@@ -1158,39 +1158,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         llargs: &mut Vec<Bx::Value>,\n         arg: &ArgAbi<'tcx, Ty<'tcx>>,\n     ) {\n-        // Fill padding with undef value, where applicable.\n-        if let Some(ty) = arg.pad {\n-            llargs.push(bx.const_undef(bx.reg_backend_type(&ty)))\n-        }\n-\n-        if arg.is_ignore() {\n-            return;\n-        }\n-\n-        if let PassMode::Pair(..) = arg.mode {\n-            match op.val {\n+        match arg.mode {\n+            PassMode::Ignore => return,\n+            PassMode::Cast(_, true) => {\n+                // Fill padding with undef value, where applicable.\n+                llargs.push(bx.const_undef(bx.reg_backend_type(&Reg::i32())));\n+            }\n+            PassMode::Pair(..) => match op.val {\n                 Pair(a, b) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for pair argument\", op),\n-            }\n-        } else if arg.is_unsized_indirect() {\n-            match op.val {\n+            },\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => match op.val {\n                 Ref(a, Some(b), _) => {\n                     llargs.push(a);\n                     llargs.push(b);\n                     return;\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for unsized indirect argument\", op),\n-            }\n+            },\n+            _ => {}\n         }\n \n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => match arg.mode {\n-                PassMode::Indirect { .. } | PassMode::Cast(_) => {\n+                PassMode::Indirect { .. } | PassMode::Cast(..) => {\n                     let scratch = PlaceRef::alloca(bx, arg.layout);\n                     op.val.store(bx, scratch);\n                     (scratch.llval, scratch.align, true)\n@@ -1222,8 +1218,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if let PassMode::Cast(ty) = arg.mode {\n-                let llty = bx.cast_backend_type(&ty);\n+            if let PassMode::Cast(ty, _) = &arg.mode {\n+                let llty = bx.cast_backend_type(ty);\n                 let addr = bx.pointercast(llval, bx.type_ptr_to(llty));\n                 llval = bx.load(llty, addr, align.min(arg.layout.align.abi));\n             } else {\n@@ -1622,7 +1618,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n-                let op = if let PassMode::Cast(_) = ret_abi.mode {\n+                let op = if let PassMode::Cast(..) = ret_abi.mode {\n                     let tmp = PlaceRef::alloca(bx, ret_abi.layout);\n                     tmp.storage_live(bx);\n                     bx.store_arg(&ret_abi, llval, tmp);"}, {"sha": "16aad07194da8afa048c5fcf94a02a6caa5d134b", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -597,8 +597,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if !fn_abi.ret.is_ignore() {\n-            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n-                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(&ty));\n+            if let PassMode::Cast(ty, _) = &fn_abi.ret.mode {\n+                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(ty));\n                 let ptr = bx.pointercast(result.llval, ptr_llty);\n                 bx.store(llval, ptr, result.align);\n             } else {"}, {"sha": "c70c2bd9f741d7e4d4e0eab1e35497dc98683aa7", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -283,7 +283,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 for i in 0..tupled_arg_tys.len() {\n                     let arg = &fx.fn_abi.args[idx];\n                     idx += 1;\n-                    if arg.pad.is_some() {\n+                    if let PassMode::Cast(_, true) = arg.mode {\n                         llarg_idx += 1;\n                     }\n                     let pr_field = place.project_field(bx, i);\n@@ -309,7 +309,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n             let arg = &fx.fn_abi.args[idx];\n             idx += 1;\n-            if arg.pad.is_some() {\n+            if let PassMode::Cast(_, true) = arg.mode {\n                 llarg_idx += 1;\n             }\n "}, {"sha": "a71a5d4b833c8c43d2681f92afe6544e6c45ae4e", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -214,10 +214,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 _ => false,\n             }\n         };\n-        // Padding must be fully equal.\n-        let pad_compat = || caller_abi.pad == callee_abi.pad;\n         // When comparing the PassMode, we have to be smart about comparing the attributes.\n-        let arg_attr_compat = |a1: ArgAttributes, a2: ArgAttributes| {\n+        let arg_attr_compat = |a1: &ArgAttributes, a2: &ArgAttributes| {\n             // There's only one regular attribute that matters for the call ABI: InReg.\n             // Everything else is things like noalias, dereferencable, nonnull, ...\n             // (This also applies to pointee_size, pointee_align.)\n@@ -232,13 +230,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             return true;\n         };\n-        let mode_compat = || match (caller_abi.mode, callee_abi.mode) {\n+        let mode_compat = || match (&caller_abi.mode, &callee_abi.mode) {\n             (PassMode::Ignore, PassMode::Ignore) => true,\n             (PassMode::Direct(a1), PassMode::Direct(a2)) => arg_attr_compat(a1, a2),\n             (PassMode::Pair(a1, b1), PassMode::Pair(a2, b2)) => {\n                 arg_attr_compat(a1, a2) && arg_attr_compat(b1, b2)\n             }\n-            (PassMode::Cast(c1), PassMode::Cast(c2)) => c1 == c2,\n+            (PassMode::Cast(c1, pad1), PassMode::Cast(c2, pad2)) => c1 == c2 && pad1 == pad2,\n             (\n                 PassMode::Indirect { attrs: a1, extra_attrs: None, on_stack: s1 },\n                 PassMode::Indirect { attrs: a2, extra_attrs: None, on_stack: s2 },\n@@ -250,7 +248,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => false,\n         };\n \n-        if layout_compat() && pad_compat() && mode_compat() {\n+        if layout_compat() && mode_compat() {\n             return true;\n         }\n         trace!("}, {"sha": "980bb8e861551fc4832fe76d32c9bc6678542dfb", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -3251,7 +3251,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .map(|(i, ty)| arg_of(ty, Some(i)))\n                 .collect::<Result<_, _>>()?,\n             c_variadic: sig.c_variadic,\n-            fixed_count: inputs.len(),\n+            fixed_count: inputs.len() as u32,\n             conv,\n             can_unwind: fn_can_unwind(self.tcx(), fn_def_id, sig.abi),\n         };\n@@ -3323,7 +3323,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }\n             };\n             fixup(&mut fn_abi.ret);\n-            for arg in &mut fn_abi.args {\n+            for arg in fn_abi.args.iter_mut() {\n                 fixup(arg);\n             }\n         } else {"}, {"sha": "cb61f76af1d73669c5b05086aa9a19713255499b", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -888,7 +888,7 @@ pub fn typeid_for_fnabi<'tcx>(\n             typeid.push('v');\n         }\n     } else {\n-        for n in 0..fn_abi.fixed_count {\n+        for n in 0..fn_abi.fixed_count as usize {\n             let ty = transform_ty(tcx, fn_abi.args[n].layout.ty, transform_ty_options);\n             typeid.push_str(&encode_ty(tcx, ty, &mut dict, encode_ty_options));\n         }"}, {"sha": "8a5ad90db71f555041b4c45eab93759d884302e6", "filename": "compiler/rustc_target/src/abi/call/aarch64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Faarch64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -77,7 +77,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "e30dead63cbf8677069af5292294700c88345e63", "filename": "compiler/rustc_target/src/abi/call/amdgpu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Famdgpu.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -26,7 +26,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "1923ea58838ba12e2264f8778075a5be4a62d493", "filename": "compiler/rustc_target/src/abi/call/arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Farm.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -88,7 +88,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret, vfp);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "e20f01355a4a628c8767c4d5c31c0a929fad0d1f", "filename": "compiler/rustc_target/src/abi/call/avr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Favr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Favr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Favr.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -49,7 +49,7 @@ pub fn compute_abi_info<Ty>(fty: &mut FnAbi<'_, Ty>) {\n         classify_ret_ty(&mut fty.ret);\n     }\n \n-    for arg in &mut fty.args {\n+    for arg in fty.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "780e7df4383734abfda3c1a2a579ede03476e4bb", "filename": "compiler/rustc_target/src/abi/call/bpf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fbpf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fbpf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fbpf.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -22,7 +22,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "80a442048d53cab9ff4d5aca2002bb021e260023", "filename": "compiler/rustc_target/src/abi/call/hexagon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fhexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fhexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fhexagon.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -21,7 +21,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "c1e0f54af5f1ee673de803152f038059f45ed11c", "filename": "compiler/rustc_target/src/abi/call/m68k.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fm68k.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fm68k.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fm68k.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -21,7 +21,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "edcd1bab8b4b0606f5f6695bf262693f080c123c", "filename": "compiler/rustc_target/src/abi/call/mips.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -22,10 +22,8 @@ where\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform { unit: Reg::i32(), total: size });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with(Reg::i32());\n-        }\n+        let pad_i32 = !offset.is_aligned(align);\n+        arg.cast_to_and_pad_i32(Uniform { unit: Reg::i32(), total: size }, pad_i32);\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n@@ -42,7 +40,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret, &mut offset);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "2700f67b2096b408b872b29a82904bf4ad539861", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -158,7 +158,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "d2eb804d004804185f81c27bd64022f7acfa13ca", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -26,7 +26,7 @@ mod x86;\n mod x86_64;\n mod x86_win64;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum PassMode {\n     /// Ignore the argument.\n     ///\n@@ -40,9 +40,10 @@ pub enum PassMode {\n     ///\n     /// The argument has a layout abi of `ScalarPair`.\n     Pair(ArgAttributes, ArgAttributes),\n-    /// Pass the argument after casting it, to either\n-    /// a single uniform or a pair of registers.\n-    Cast(CastTarget),\n+    /// Pass the argument after casting it, to either a single uniform or a\n+    /// pair of registers. The bool indicates if a `Reg::i32()` dummy argument\n+    /// is emitted before the real argument.\n+    Cast(Box<CastTarget>, bool),\n     /// Pass the argument indirectly via a hidden pointer.\n     /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n@@ -463,10 +464,6 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct ArgAbi<'a, Ty> {\n     pub layout: TyAndLayout<'a, Ty>,\n-\n-    /// Dummy argument, which is emitted before the real argument.\n-    pub pad: Option<Reg>,\n-\n     pub mode: PassMode,\n }\n \n@@ -486,7 +483,7 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n             Abi::Vector { .. } => PassMode::Direct(ArgAttributes::new()),\n             Abi::Aggregate { .. } => PassMode::Direct(ArgAttributes::new()),\n         };\n-        ArgAbi { layout, pad: None, mode }\n+        ArgAbi { layout, mode }\n     }\n \n     fn indirect_pass_mode(layout: &TyAndLayout<'a, Ty>) -> PassMode {\n@@ -548,11 +545,11 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        self.mode = PassMode::Cast(target.into());\n+        self.mode = PassMode::Cast(Box::new(target.into()), false);\n     }\n \n-    pub fn pad_with(&mut self, reg: Reg) {\n-        self.pad = Some(reg);\n+    pub fn cast_to_and_pad_i32<T: Into<CastTarget>>(&mut self, target: T, pad_i32: bool) {\n+        self.mode = PassMode::Cast(Box::new(target.into()), pad_i32);\n     }\n \n     pub fn is_indirect(&self) -> bool {\n@@ -614,7 +611,7 @@ pub enum Conv {\n #[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct FnAbi<'a, Ty> {\n     /// The LLVM types of each argument.\n-    pub args: Vec<ArgAbi<'a, Ty>>,\n+    pub args: Box<[ArgAbi<'a, Ty>]>,\n \n     /// LLVM return type.\n     pub ret: ArgAbi<'a, Ty>,\n@@ -625,7 +622,7 @@ pub struct FnAbi<'a, Ty> {\n     ///\n     /// Should only be different from args.len() when c_variadic is true.\n     /// This can be used to know whether an argument is variadic or not.\n-    pub fixed_count: usize,\n+    pub fixed_count: u32,\n \n     pub conv: Conv,\n \n@@ -730,3 +727,13 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n         Ok(())\n     }\n }\n+\n+// Some types are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // These are in alphabetical order, which is easy to maintain.\n+    static_assert_size!(ArgAbi<'_, usize>, 56);\n+    static_assert_size!(FnAbi<'_, usize>, 80);\n+}"}, {"sha": "33ef47be00993d2d06991f32be843ad5c1a4170b", "filename": "compiler/rustc_target/src/abi/call/msp430.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmsp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmsp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmsp430.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -30,7 +30,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "4abe51cd697e0a24413d65468ca3524b5457ee64", "filename": "compiler/rustc_target/src/abi/call/nvptx64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fnvptx64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -38,7 +38,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }\n@@ -55,7 +55,7 @@ where\n         panic!(\"Kernels should not return anything other than () or !\");\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "70c32db0a871b3578cbe0e92b572b56460ebf32e", "filename": "compiler/rustc_target/src/abi/call/powerpc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -21,7 +21,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "359bb8fc09a876dce5026c4298c68c9ea69435f1", "filename": "compiler/rustc_target/src/abi/call/powerpc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fpowerpc64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -132,7 +132,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret, abi);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "1cb360f834e0e3b690983cbbf65aa44d0dc211bf", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -340,7 +340,7 @@ where\n             arg,\n             xlen,\n             flen,\n-            i >= fn_abi.fixed_count,\n+            i >= fn_abi.fixed_count as usize,\n             &mut avail_gprs,\n             &mut avail_fprs,\n         );"}, {"sha": "ea23692817f50f1ee7b2d33de41326f75e401efe", "filename": "compiler/rustc_target/src/abi/call/s390x.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fs390x.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -48,7 +48,7 @@ where\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "edcd1bab8b4b0606f5f6695bf262693f080c123c", "filename": "compiler/rustc_target/src/abi/call/sparc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -22,10 +22,8 @@ where\n     let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align).abi;\n \n     if arg.layout.is_aggregate() {\n-        arg.cast_to(Uniform { unit: Reg::i32(), total: size });\n-        if !offset.is_aligned(align) {\n-            arg.pad_with(Reg::i32());\n-        }\n+        let pad_i32 = !offset.is_aligned(align);\n+        arg.cast_to_and_pad_i32(Uniform { unit: Reg::i32(), total: size }, pad_i32);\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n@@ -42,7 +40,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret, &mut offset);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "1b74959ad17c2e577efc76d7cf759f4976ff7645", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -217,7 +217,7 @@ where\n         classify_arg(cx, &mut fn_abi.ret, Size { raw: 32 });\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "44427ee5317c1db7e50019e6959593f933d9d522", "filename": "compiler/rustc_target/src/abi/call/wasm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fwasm.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -50,7 +50,7 @@ where\n         classify_ret(cx, &mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }\n@@ -66,7 +66,7 @@ pub fn compute_wasm_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n         classify_ret(&mut fn_abi.ret);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "7c26335dcf4cde4c1641ddd0f747bacfb88f1adb", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -49,7 +49,7 @@ where\n         }\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }\n@@ -72,7 +72,7 @@ where\n \n         let mut free_regs = 2;\n \n-        for arg in &mut fn_abi.args {\n+        for arg in fn_abi.args.iter_mut() {\n             let attrs = match arg.mode {\n                 PassMode::Ignore\n                 | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n@@ -81,7 +81,7 @@ where\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..)\n                 | PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ }\n-                | PassMode::Cast(_) => {\n+                | PassMode::Cast(..) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }\n             };"}, {"sha": "c0c071a614f5058808e7bbd11384287ca9139e6e", "filename": "compiler/rustc_target/src/abi/call/x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -239,7 +239,7 @@ where\n         x86_64_arg_or_ret(&mut fn_abi.ret, false);\n     }\n \n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}, {"sha": "1aaf0e511ca41d51c06e329d92314292d4045dcc", "filename": "compiler/rustc_target/src/abi/call/x86_win64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/332cc8fb752fe98c21837ed6f3571f6adb0d08b8/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86_win64.rs?ref=332cc8fb752fe98c21837ed6f3571f6adb0d08b8", "patch": "@@ -31,7 +31,7 @@ pub fn compute_abi_info<Ty>(fn_abi: &mut FnAbi<'_, Ty>) {\n     if !fn_abi.ret.is_ignore() {\n         fixup(&mut fn_abi.ret);\n     }\n-    for arg in &mut fn_abi.args {\n+    for arg in fn_abi.args.iter_mut() {\n         if arg.is_ignore() {\n             continue;\n         }"}]}