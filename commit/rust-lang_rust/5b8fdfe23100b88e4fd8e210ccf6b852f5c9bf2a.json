{"sha": "5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViOGZkZmUyMzEwMGI4OGU0ZmQ4ZTIxMGNjZjZiODUyZjVjOWJmMmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-08-12T13:44:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-12T13:44:13Z"}, "message": "Merge #5553\n\n5553: Add fix ranges for diagnostics r=matklad a=SomeoneToIgnore\n\nA follow-up of https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Less.20red.20in.20the.20code\r\n\r\nNow diagnostics can apply fixes in a range that's different from the range used to highlight the diagnostics.\r\nPrevious logic did not consider the fix range, having both ranges equal, which could cause a lot of red noise in the editor.\r\nNow, the fix range gets used with the fix, the diagnostics range is used for everything else which allows to improve the error highlighting.\r\n\r\nbefore:\r\n<img width=\"191\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2690773/88590727-df9a6a00-d063-11ea-97ed-9809c1c5e6e6.png\">\r\nafter:\r\n<img width=\"222\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2690773/88590734-e1fcc400-d063-11ea-9b7c-25701cbd5352.png\">\r\n\r\n`MissingFields` and `MissingPatFields` diagnostics now have the fix range as `ast::RecordFieldList` of the expression with an error (as it was before this PR), and the diagnostics range as a `ast::Path` of the expression, if it's present (do you have any example of `ast::Expr::RecordLit` that has no path btw?).\r\nThe rest of the diagnostics have both ranges equal, same as it was before this PR.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "e321c900fe4997ec5ffe20cbb09946502745849c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e321c900fe4997ec5ffe20cbb09946502745849c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfM/ItCRBK7hj4Ov3rIwAAdHIIAEGr2Njd6CjN3hQOjsWR4qdl\nusK01l3skxvlx3I1Lrl4CF6glk/+Hq5QTPguRS5+/SQBAY5C9KhWj8cg4eCIh/QM\nnszrbwEtwlIWixlEcU9C6XZ0m33u1IhP0+nV6ob3fILGAWGy2JP/dY7I+MOWxSUt\nmfWrL1GNHI30iZzuIQnoIFRsTESjZnx6Q4mnl7/nehagqGGCaiz/XVdy+GExeT8n\nGAMbYrK5pQ0jnsxzkCTrs0NaLUeClkOraFbSeYxeNOjWlNvHtBYhXA5OfECg1sev\nFxPrd3Ofi8h8r/hOwT5kTjCI+VB1CFWkVdY0KY+LumPWZnyoHP02Ml05kAvrRKQ=\n=rO/L\n-----END PGP SIGNATURE-----\n", "payload": "tree e321c900fe4997ec5ffe20cbb09946502745849c\nparent 11de7ac2fb6514484076217acb8d93eb36468681\nparent db12ccee96bf37367b39ad99638d06da7123c088\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1597239853 +0000\ncommitter GitHub <noreply@github.com> 1597239853 +0000\n\nMerge #5553\n\n5553: Add fix ranges for diagnostics r=matklad a=SomeoneToIgnore\n\nA follow-up of https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Less.20red.20in.20the.20code\r\n\r\nNow diagnostics can apply fixes in a range that's different from the range used to highlight the diagnostics.\r\nPrevious logic did not consider the fix range, having both ranges equal, which could cause a lot of red noise in the editor.\r\nNow, the fix range gets used with the fix, the diagnostics range is used for everything else which allows to improve the error highlighting.\r\n\r\nbefore:\r\n<img width=\"191\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2690773/88590727-df9a6a00-d063-11ea-97ed-9809c1c5e6e6.png\">\r\nafter:\r\n<img width=\"222\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2690773/88590734-e1fcc400-d063-11ea-9b7c-25701cbd5352.png\">\r\n\r\n`MissingFields` and `MissingPatFields` diagnostics now have the fix range as `ast::RecordFieldList` of the expression with an error (as it was before this PR), and the diagnostics range as a `ast::Path` of the expression, if it's present (do you have any example of `ast::Expr::RecordLit` that has no path btw?).\r\nThe rest of the diagnostics have both ranges equal, same as it was before this PR.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "html_url": "https://github.com/rust-lang/rust/commit/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11de7ac2fb6514484076217acb8d93eb36468681", "url": "https://api.github.com/repos/rust-lang/rust/commits/11de7ac2fb6514484076217acb8d93eb36468681", "html_url": "https://github.com/rust-lang/rust/commit/11de7ac2fb6514484076217acb8d93eb36468681"}, {"sha": "db12ccee96bf37367b39ad99638d06da7123c088", "url": "https://api.github.com/repos/rust-lang/rust/commits/db12ccee96bf37367b39ad99638d06da7123c088", "html_url": "https://github.com/rust-lang/rust/commit/db12ccee96bf37367b39ad99638d06da7123c088"}], "stats": {"total": 575, "additions": 288, "deletions": 287}, "files": [{"sha": "a19dbf33f6bc85cfc129fd8f4f5789c2f621f9bf", "filename": "crates/ra_assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -121,7 +121,7 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) ->\n             Some(cap) => match current_visibility {\n                 Some(current_visibility) => builder.replace_snippet(\n                     cap,\n-                    dbg!(current_visibility.syntax()).text_range(),\n+                    current_visibility.syntax().text_range(),\n                     format!(\"$0{}\", missing_visibility),\n                 ),\n                 None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),"}, {"sha": "363164b9b4a68bc98c5afb5e1b465a6b1ac64785", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -1,8 +1,6 @@\n //! FIXME: write short doc here\n pub use hir_def::diagnostics::UnresolvedModule;\n-pub use hir_expand::diagnostics::{\n-    AstDiagnostic, Diagnostic, DiagnosticSink, DiagnosticSinkBuilder,\n-};\n+pub use hir_expand::diagnostics::{Diagnostic, DiagnosticSink, DiagnosticSinkBuilder};\n pub use hir_ty::diagnostics::{\n     MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField,\n };"}, {"sha": "36b688ccb697c2e0b218f0930e8df0e72d9e9085", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -8,7 +8,7 @@ use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n-use hir_expand::{diagnostics::AstDiagnostic, hygiene::Hygiene, name::AsName, ExpansionInfo};\n+use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n@@ -110,13 +110,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.parse(file_id)\n     }\n \n-    pub fn ast<T: AstDiagnostic + Diagnostic>(&self, d: &T) -> <T as AstDiagnostic>::AST {\n-        let file_id = d.source().file_id;\n-        let root = self.db.parse_or_expand(file_id).unwrap();\n-        self.imp.cache(root, file_id);\n-        d.ast(self.db.upcast())\n-    }\n-\n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         self.imp.expand(macro_call)\n     }\n@@ -146,8 +139,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.original_range(node)\n     }\n \n-    pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        self.imp.diagnostics_range(diagnostics)\n+    pub fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        self.imp.diagnostics_display_range(diagnostics)\n     }\n \n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n@@ -389,10 +382,11 @@ impl<'db> SemanticsImpl<'db> {\n         original_range(self.db, node.as_ref())\n     }\n \n-    fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        let src = diagnostics.source();\n+    fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        let src = diagnostics.display_source();\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n+        self.cache(root, src.file_id);\n         original_range(self.db, src.with_value(&node))\n     }\n "}, {"sha": "71d177070dd6c91ebfa71cf941fe7ebf47bb9b1f", "filename": "crates/ra_hir_def/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdiagnostics.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -18,7 +18,7 @@ impl Diagnostic for UnresolvedModule {\n     fn message(&self) -> String {\n         \"unresolved module\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.decl.clone().into())\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {"}, {"sha": "b138500e7342533b6a9d65684760e82fc6ace215", "filename": "crates/ra_hir_expand/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdiagnostics.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -16,35 +16,20 @@\n \n use std::{any::Any, fmt};\n \n-use ra_syntax::{SyntaxNode, SyntaxNodePtr};\n+use ra_syntax::SyntaxNodePtr;\n \n-use crate::{db::AstDatabase, InFile};\n+use crate::InFile;\n \n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n     fn message(&self) -> String;\n-    fn source(&self) -> InFile<SyntaxNodePtr>;\n+    /// Used in highlighting and related purposes\n+    fn display_source(&self) -> InFile<SyntaxNodePtr>;\n     fn as_any(&self) -> &(dyn Any + Send + 'static);\n     fn is_experimental(&self) -> bool {\n         false\n     }\n }\n \n-pub trait AstDiagnostic {\n-    type AST;\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST;\n-}\n-\n-impl dyn Diagnostic {\n-    pub fn syntax_node(&self, db: &impl AstDatabase) -> SyntaxNode {\n-        let node = db.parse_or_expand(self.source().file_id).unwrap();\n-        self.source().value.to_node(&node)\n-    }\n-\n-    pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n-        self.as_any().downcast_ref()\n-    }\n-}\n-\n pub struct DiagnosticSink<'a> {\n     callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n     filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n@@ -89,7 +74,7 @@ impl<'a> DiagnosticSinkBuilder<'a> {\n     }\n \n     pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> Self {\n-        let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n+        let cb = move |diag: &dyn Diagnostic| match diag.as_any().downcast_ref::<D>() {\n             Some(d) => {\n                 cb(d);\n                 Ok(())"}, {"sha": "7ab7f79db66521019fb39b3ac1fdd48f0bf270f5", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 46, "deletions": 82, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -6,10 +6,10 @@ mod unsafe_check;\n use std::any::Any;\n \n use hir_def::DefWithBodyId;\n-use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n+use hir_expand::diagnostics::{Diagnostic, DiagnosticSink};\n+use hir_expand::{name::Name, HirFileId, InFile};\n use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n+use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n use stdx::format_to;\n \n use crate::db::HirDatabase;\n@@ -37,7 +37,7 @@ impl Diagnostic for NoSuchField {\n         \"no such field\".to_string()\n     }\n \n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.field.clone().into())\n     }\n \n@@ -46,20 +46,11 @@ impl Diagnostic for NoSuchField {\n     }\n }\n \n-impl AstDiagnostic for NoSuchField {\n-    type AST = ast::RecordExprField;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::RecordExprField::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordExprFieldList>,\n+    pub field_list_parent: AstPtr<ast::RecordExpr>,\n+    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n \n@@ -71,28 +62,28 @@ impl Diagnostic for MissingFields {\n         }\n         buf\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field_list.clone().into() }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n     }\n+\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingFields {\n-    type AST = ast::RecordExprFieldList;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::RecordExprFieldList::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingPatFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordPatFieldList>,\n+    pub field_list_parent: AstPtr<ast::RecordPat>,\n+    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n \n@@ -104,8 +95,15 @@ impl Diagnostic for MissingPatFields {\n         }\n         buf\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field_list.clone().into() }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n@@ -123,7 +121,7 @@ impl Diagnostic for MissingMatchArms {\n     fn message(&self) -> String {\n         String::from(\"Missing match arm\")\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.match_expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -141,24 +139,14 @@ impl Diagnostic for MissingOkInTailExpr {\n     fn message(&self) -> String {\n         \"wrap return expression in Ok\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingOkInTailExpr {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub file: HirFileId,\n@@ -169,24 +157,14 @@ impl Diagnostic for BreakOutsideOfLoop {\n     fn message(&self) -> String {\n         \"break outside of loop\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for BreakOutsideOfLoop {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub file: HirFileId,\n@@ -197,24 +175,14 @@ impl Diagnostic for MissingUnsafe {\n     fn message(&self) -> String {\n         format!(\"This operation is unsafe and requires an unsafe function or block\")\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingUnsafe {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub file: HirFileId,\n@@ -228,7 +196,7 @@ impl Diagnostic for MismatchedArgCount {\n         let s = if self.expected == 1 { \"\" } else { \"s\" };\n         format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.call_expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -239,19 +207,13 @@ impl Diagnostic for MismatchedArgCount {\n     }\n }\n \n-impl AstDiagnostic for MismatchedArgCount {\n-    type AST = ast::CallExpr;\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::CallExpr::cast(node).unwrap()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n-    use hir_expand::diagnostics::{Diagnostic, DiagnosticSinkBuilder};\n+    use hir_expand::{\n+        db::AstDatabase,\n+        diagnostics::{Diagnostic, DiagnosticSinkBuilder},\n+    };\n     use ra_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n     use ra_syntax::{TextRange, TextSize};\n     use rustc_hash::FxHashMap;\n@@ -296,9 +258,11 @@ mod tests {\n \n         let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n         db.diagnostics(|d| {\n-            // FXIME: macros...\n-            let file_id = d.source().file_id.original_file(&db);\n-            let range = d.syntax_node(&db).text_range();\n+            let src = d.display_source();\n+            let root = db.parse_or_expand(src.file_id).unwrap();\n+            // FIXME: macros...\n+            let file_id = src.file_id.original_file(&db);\n+            let range = src.value.to_node(&root).text_range();\n             let message = d.message().to_owned();\n             actual.entry(file_id).or_default().push((range, message));\n         });\n@@ -326,8 +290,8 @@ struct S { foo: i32, bar: () }\n impl S {\n     fn new() -> S {\n         S {\n-        //^... Missing structure fields:\n-        //|    - bar\n+      //^ Missing structure fields:\n+      //|    - bar\n             foo: 92,\n             baz: 62,\n           //^^^^^^^ no such field\n@@ -448,8 +412,8 @@ impl Foo {\n struct S { foo: i32, bar: () }\n fn baz(s: S) {\n     let S { foo: _ } = s;\n-        //^^^^^^^^^^ Missing structure fields:\n-        //         | - bar\n+      //^ Missing structure fields:\n+      //| - bar\n }\n \"#,\n         );"}, {"sha": "51adcecafaea5aca418cb8de5d26b7813a69bc03", "filename": "crates/ra_hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -100,16 +100,17 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n             let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::RecordExpr(record_lit) = &source_ptr.value.to_node(&root) {\n-                if let Some(field_list) = record_lit.record_expr_field_list() {\n+            if let ast::Expr::RecordExpr(record_expr) = &source_ptr.value.to_node(&root) {\n+                if let Some(_) = record_expr.record_expr_field_list() {\n                     let variant_data = variant_data(db.upcast(), variant_def);\n                     let missed_fields = missed_fields\n                         .into_iter()\n                         .map(|idx| variant_data.fields()[idx].name.clone())\n                         .collect();\n                     self.sink.push(MissingFields {\n                         file: source_ptr.file_id,\n-                        field_list: AstPtr::new(&field_list),\n+                        field_list_parent: AstPtr::new(&record_expr),\n+                        field_list_parent_path: record_expr.path().map(|path| AstPtr::new(&path)),\n                         missed_fields,\n                     })\n                 }\n@@ -131,15 +132,18 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             if let Some(expr) = source_ptr.value.as_ref().left() {\n                 let root = source_ptr.file_syntax(db.upcast());\n                 if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_pat.record_pat_field_list() {\n+                    if let Some(_) = record_pat.record_pat_field_list() {\n                         let variant_data = variant_data(db.upcast(), variant_def);\n                         let missed_fields = missed_fields\n                             .into_iter()\n                             .map(|idx| variant_data.fields()[idx].name.clone())\n                             .collect();\n                         self.sink.push(MissingPatFields {\n                             file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n+                            field_list_parent: AstPtr::new(&record_pat),\n+                            field_list_parent_path: record_pat\n+                                .path()\n+                                .map(|path| AstPtr::new(&path)),\n                             missed_fields,\n                         })\n                     }"}, {"sha": "deca244dbbab5956f098401070a81aa398f9eb81", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -1161,15 +1161,15 @@ fn main() {\n         //^ Missing match arm\n     match a {\n         Either::A { } => (),\n-                //^^^ Missing structure fields:\n-                //  | - foo\n+      //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n         Either::B => (),\n     }\n     match a {\n         //^ Missing match arm\n         Either::A { } => (),\n-    }           //^^^ Missing structure fields:\n-                //  | - foo\n+    } //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n \n     match a {\n         Either::A { foo: true } => (),"}, {"sha": "1046d7ab374502218f9a8dd2f5d6badc41aabc1c", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 32, "deletions": 152, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -6,22 +6,21 @@\n \n use std::cell::RefCell;\n \n-use hir::{\n-    diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSinkBuilder},\n-    HasSource, HirDisplay, Semantics, VariantDef,\n-};\n+use hir::{diagnostics::DiagnosticSinkBuilder, Semantics};\n use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n-    algo,\n-    ast::{self, edit::IndentLevel, make, AstNode},\n+    ast::{self, AstNode},\n     SyntaxNode, TextRange, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{Diagnostic, FileId, FileSystemEdit, Fix, SourceFileEdit};\n+use crate::{Diagnostic, FileId, Fix, SourceFileEdit};\n+\n+mod diagnostics_with_fix;\n+use diagnostics_with_fix::DiagnosticWithFix;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Severity {\n@@ -54,81 +53,24 @@ pub(crate) fn diagnostics(\n     let res = RefCell::new(res);\n     let mut sink = DiagnosticSinkBuilder::new()\n         .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n-            let original_file = d.source().file_id.original_file(db);\n-            let fix = Fix::new(\n-                \"Create module\",\n-                FileSystemEdit::CreateFile { anchor: original_file, dst: d.candidate.clone() }\n-                    .into(),\n-            );\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: Some(fix),\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::MissingFields, _>(|d| {\n-            // Note that although we could add a diagnostics to\n-            // fill the missing tuple field, e.g :\n-            // `struct A(usize);`\n-            // `let a = A { 0: () }`\n-            // but it is uncommon usage and it should not be encouraged.\n-            let fix = if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-                None\n-            } else {\n-                let mut field_list = d.ast(db);\n-                for f in d.missed_fields.iter() {\n-                    let field = make::record_expr_field(\n-                        make::name_ref(&f.to_string()),\n-                        Some(make::expr_unit()),\n-                    );\n-                    field_list = field_list.append_field(&field);\n-                }\n-\n-                let edit = {\n-                    let mut builder = TextEditBuilder::default();\n-                    algo::diff(&d.ast(db).syntax(), &field_list.syntax())\n-                        .into_text_edit(&mut builder);\n-                    builder.finish()\n-                };\n-                Some(Fix::new(\"Fill struct fields\", SourceFileEdit { file_id, edit }.into()))\n-            };\n-\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix,\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n-            let node = d.ast(db);\n-            let replacement = format!(\"Ok({})\", node.syntax());\n-            let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n-            let source_change = SourceFileEdit { file_id, edit }.into();\n-            let fix = Fix::new(\"Wrap with ok\", source_change);\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: Some(fix),\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::NoSuchField, _>(|d| {\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: missing_struct_field_fix(&sema, file_id, d),\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !diag.is_experimental() || enable_experimental)\n         // Diagnostics not handled above get no fix and default treatment.\n         .build(|d| {\n             res.borrow_mut().push(Diagnostic {\n                 message: d.message(),\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_display_range(d).range,\n                 severity: Severity::Error,\n                 fix: None,\n             })\n@@ -141,77 +83,12 @@ pub(crate) fn diagnostics(\n     res.into_inner()\n }\n \n-fn missing_struct_field_fix(\n-    sema: &Semantics<RootDatabase>,\n-    usage_file_id: FileId,\n-    d: &hir::diagnostics::NoSuchField,\n-) -> Option<Fix> {\n-    let record_expr = sema.ast(d);\n-\n-    let record_lit = ast::RecordExpr::cast(record_expr.syntax().parent()?.parent()?)?;\n-    let def_id = sema.resolve_variant(record_lit)?;\n-    let module;\n-    let def_file_id;\n-    let record_fields = match VariantDef::from(def_id) {\n-        VariantDef::Struct(s) => {\n-            module = s.module(sema.db);\n-            let source = s.source(sema.db);\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-        VariantDef::Union(u) => {\n-            module = u.module(sema.db);\n-            let source = u.source(sema.db);\n-            def_file_id = source.file_id;\n-            source.value.record_field_list()?\n-        }\n-        VariantDef::EnumVariant(e) => {\n-            module = e.module(sema.db);\n-            let source = e.source(sema.db);\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-    };\n-    let def_file_id = def_file_id.original_file(sema.db);\n-\n-    let new_field_type = sema.type_of_expr(&record_expr.expr()?)?;\n-    if new_field_type.is_unknown() {\n-        return None;\n-    }\n-    let new_field = make::record_field(\n-        record_expr.field_name()?,\n-        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n-    );\n-\n-    let last_field = record_fields.fields().last()?;\n-    let last_field_syntax = last_field.syntax();\n-    let indent = IndentLevel::from_node(last_field_syntax);\n-\n-    let mut new_field = new_field.to_string();\n-    if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n-    }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n-\n-    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n-    if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n-    }\n-\n-    let source_change = SourceFileEdit {\n-        file_id: def_file_id,\n-        edit: TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n-    };\n-    let fix = Fix::new(\"Create field\", source_change.into());\n-    return Some(fix);\n-\n-    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n-        match field_def_list {\n-            ast::FieldList::RecordFieldList(it) => Some(it),\n-            ast::FieldList::TupleFieldList(_) => None,\n-        }\n+fn diagnostic_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabase>) -> Diagnostic {\n+    Diagnostic {\n+        range: sema.diagnostics_display_range(d).range,\n+        message: d.message(),\n+        severity: Severity::Error,\n+        fix: d.fix(&sema),\n     }\n }\n \n@@ -222,24 +99,25 @@ fn check_unnecessary_braces_in_use_statement(\n ) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node.clone())?;\n     if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-        let range = use_tree_list.syntax().text_range();\n+        let use_range = use_tree_list.syntax().text_range();\n         let edit =\n             text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(&single_use_tree)\n                 .unwrap_or_else(|| {\n                     let to_replace = single_use_tree.syntax().text().to_string();\n                     let mut edit_builder = TextEditBuilder::default();\n-                    edit_builder.delete(range);\n-                    edit_builder.insert(range.start(), to_replace);\n+                    edit_builder.delete(use_range);\n+                    edit_builder.insert(use_range.start(), to_replace);\n                     edit_builder.finish()\n                 });\n \n         acc.push(Diagnostic {\n-            range,\n+            range: use_range,\n             message: \"Unnecessary braces in use statement\".to_string(),\n             severity: Severity::WeakWarning,\n             fix: Some(Fix::new(\n                 \"Remove unnecessary braces\",\n                 SourceFileEdit { file_id, edit }.into(),\n+                use_range,\n             )),\n         });\n     }\n@@ -254,8 +132,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     if single_use_tree.path()?.segment()?.syntax().first_child_or_token()?.kind() == T![self] {\n         let start = use_tree_list_node.prev_sibling_or_token()?.text_range().start();\n         let end = use_tree_list_node.text_range().end();\n-        let range = TextRange::new(start, end);\n-        return Some(TextEdit::delete(range));\n+        return Some(TextEdit::delete(TextRange::new(start, end)));\n     }\n     None\n }\n@@ -278,13 +155,15 @@ fn check_struct_shorthand_initialization(\n                 edit_builder.insert(record_field.syntax().text_range().start(), field_name);\n                 let edit = edit_builder.finish();\n \n+                let field_range = record_field.syntax().text_range();\n                 acc.push(Diagnostic {\n-                    range: record_field.syntax().text_range(),\n+                    range: field_range,\n                     message: \"Shorthand struct initialization\".to_string(),\n                     severity: Severity::WeakWarning,\n                     fix: Some(Fix::new(\n                         \"Use struct shorthand initialization\",\n                         SourceFileEdit { file_id, edit }.into(),\n+                        field_range,\n                     )),\n                 });\n             }\n@@ -304,7 +183,7 @@ mod tests {\n     /// Takes a multi-file input fixture with annotated cursor positions,\n     /// and checks that:\n     ///  * a diagnostic is produced\n-    ///  * this diagnostic touches the input cursor position\n+    ///  * this diagnostic fix trigger range touches the input cursor position\n     ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n     fn check_fix(ra_fixture_before: &str, ra_fixture_after: &str) {\n         let after = trim_indent(ra_fixture_after);\n@@ -322,10 +201,10 @@ mod tests {\n \n         assert_eq_text!(&after, &actual);\n         assert!(\n-            diagnostic.range.start() <= file_position.offset\n-                && diagnostic.range.end() >= file_position.offset,\n-            \"diagnostic range {:?} does not touch cursor position {:?}\",\n-            diagnostic.range,\n+            fix.fix_trigger_range.start() <= file_position.offset\n+                && fix.fix_trigger_range.end() >= file_position.offset,\n+            \"diagnostic fix range {:?} does not touch cursor position {:?}\",\n+            fix.fix_trigger_range,\n             file_position.offset\n         );\n     }\n@@ -642,6 +521,7 @@ fn test_fn() {\n                                     ],\n                                     is_snippet: false,\n                                 },\n+                                fix_trigger_range: 0..8,\n                             },\n                         ),\n                     },"}, {"sha": "f7c73773f3ac9cecdfaf111243df64f3cae09b58", "filename": "crates/ra_ide/src/diagnostics/diagnostics_with_fix.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_ide%2Fsrc%2Fdiagnostics%2Fdiagnostics_with_fix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_ide%2Fsrc%2Fdiagnostics%2Fdiagnostics_with_fix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics%2Fdiagnostics_with_fix.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -0,0 +1,171 @@\n+//! Provides a way to attach fixes to the diagnostics.\n+//! The same module also has all curret custom fixes for the diagnostics implemented.\n+use crate::Fix;\n+use ast::{edit::IndentLevel, make};\n+use hir::{\n+    db::AstDatabase,\n+    diagnostics::{Diagnostic, MissingFields, MissingOkInTailExpr, NoSuchField, UnresolvedModule},\n+    HasSource, HirDisplay, Semantics, VariantDef,\n+};\n+use ra_db::FileId;\n+use ra_ide_db::{\n+    source_change::{FileSystemEdit, SourceFileEdit},\n+    RootDatabase,\n+};\n+use ra_syntax::{algo, ast, AstNode};\n+use ra_text_edit::{TextEdit, TextEditBuilder};\n+\n+/// A [Diagnostic] that potentially has a fix available.\n+///\n+/// [Diagnostic]: hir::diagnostics::Diagnostic\n+pub trait DiagnosticWithFix: Diagnostic {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix>;\n+}\n+\n+impl DiagnosticWithFix for UnresolvedModule {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let unresolved_module = self.decl.to_node(&root);\n+        Some(Fix::new(\n+            \"Create module\",\n+            FileSystemEdit::CreateFile {\n+                anchor: self.file.original_file(sema.db),\n+                dst: self.candidate.clone(),\n+            }\n+            .into(),\n+            unresolved_module.syntax().text_range(),\n+        ))\n+    }\n+}\n+\n+impl DiagnosticWithFix for NoSuchField {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        missing_record_expr_field_fix(\n+            &sema,\n+            self.file.original_file(sema.db),\n+            &self.field.to_node(&root),\n+        )\n+    }\n+}\n+\n+impl DiagnosticWithFix for MissingFields {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        // Note that although we could add a diagnostics to\n+        // fill the missing tuple field, e.g :\n+        // `struct A(usize);`\n+        // `let a = A { 0: () }`\n+        // but it is uncommon usage and it should not be encouraged.\n+        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+            return None;\n+        }\n+\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let old_field_list = self.field_list_parent.to_node(&root).record_expr_field_list()?;\n+        let mut new_field_list = old_field_list.clone();\n+        for f in self.missed_fields.iter() {\n+            let field =\n+                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()));\n+            new_field_list = new_field_list.append_field(&field);\n+        }\n+\n+        let edit = {\n+            let mut builder = TextEditBuilder::default();\n+            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n+                .into_text_edit(&mut builder);\n+            builder.finish()\n+        };\n+        Some(Fix::new(\n+            \"Fill struct fields\",\n+            SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into(),\n+            sema.original_range(&old_field_list.syntax()).range,\n+        ))\n+    }\n+}\n+\n+impl DiagnosticWithFix for MissingOkInTailExpr {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let tail_expr = self.expr.to_node(&root);\n+        let tail_expr_range = tail_expr.syntax().text_range();\n+        let edit = TextEdit::replace(tail_expr_range, format!(\"Ok({})\", tail_expr.syntax()));\n+        let source_change =\n+            SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into();\n+        Some(Fix::new(\"Wrap with ok\", source_change, tail_expr_range))\n+    }\n+}\n+\n+fn missing_record_expr_field_fix(\n+    sema: &Semantics<RootDatabase>,\n+    usage_file_id: FileId,\n+    record_expr_field: &ast::RecordExprField,\n+) -> Option<Fix> {\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n+    let def_id = sema.resolve_variant(record_lit)?;\n+    let module;\n+    let def_file_id;\n+    let record_fields = match VariantDef::from(def_id) {\n+        VariantDef::Struct(s) => {\n+            module = s.module(sema.db);\n+            let source = s.source(sema.db);\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+        VariantDef::Union(u) => {\n+            module = u.module(sema.db);\n+            let source = u.source(sema.db);\n+            def_file_id = source.file_id;\n+            source.value.record_field_list()?\n+        }\n+        VariantDef::EnumVariant(e) => {\n+            module = e.module(sema.db);\n+            let source = e.source(sema.db);\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+    };\n+    let def_file_id = def_file_id.original_file(sema.db);\n+\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    if new_field_type.is_unknown() {\n+        return None;\n+    }\n+    let new_field = make::record_field(\n+        record_expr_field.field_name()?,\n+        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n+    );\n+\n+    let last_field = record_fields.fields().last()?;\n+    let last_field_syntax = last_field.syntax();\n+    let indent = IndentLevel::from_node(last_field_syntax);\n+\n+    let mut new_field = new_field.to_string();\n+    if usage_file_id != def_file_id {\n+        new_field = format!(\"pub(crate) {}\", new_field);\n+    }\n+    new_field = format!(\"\\n{}{}\", indent, new_field);\n+\n+    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n+    if needs_comma {\n+        new_field = format!(\",{}\", new_field);\n+    }\n+\n+    let source_change = SourceFileEdit {\n+        file_id: def_file_id,\n+        edit: TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n+    };\n+    return Some(Fix::new(\n+        \"Create field\",\n+        source_change.into(),\n+        record_expr_field.syntax().text_range(),\n+    ));\n+\n+    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n+        match field_def_list {\n+            ast::FieldList::RecordFieldList(it) => Some(it),\n+            ast::FieldList::TupleFieldList(_) => None,\n+        }\n+    }\n+}"}, {"sha": "89fcb6f178f79de6a40f1daaec77f5d3044e21e2", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -112,13 +112,19 @@ pub struct Diagnostic {\n pub struct Fix {\n     pub label: String,\n     pub source_change: SourceChange,\n+    /// Allows to trigger the fix only when the caret is in the range given\n+    pub fix_trigger_range: TextRange,\n }\n \n impl Fix {\n-    pub fn new(label: impl Into<String>, source_change: SourceChange) -> Self {\n+    pub fn new(\n+        label: impl Into<String>,\n+        source_change: SourceChange,\n+        fix_trigger_range: TextRange,\n+    ) -> Self {\n         let label = label.into();\n         assert!(label.starts_with(char::is_uppercase) && !label.ends_with('.'));\n-        Self { label, source_change }\n+        Self { label, source_change, fix_trigger_range }\n     }\n }\n "}, {"sha": "785dd2a2678a38c31b20f7f1141f65a83b35b9bb", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=5b8fdfe23100b88e4fd8e210ccf6b852f5c9bf2a", "patch": "@@ -773,12 +773,11 @@ fn handle_fixes(\n \n     let diagnostics = snap.analysis.diagnostics(file_id, snap.config.experimental_diagnostics)?;\n \n-    let fixes_from_diagnostics = diagnostics\n+    for fix in diagnostics\n         .into_iter()\n-        .filter_map(|d| Some((d.range, d.fix?)))\n-        .filter(|(diag_range, _fix)| diag_range.intersect(range).is_some())\n-        .map(|(_range, fix)| fix);\n-    for fix in fixes_from_diagnostics {\n+        .filter_map(|d| d.fix)\n+        .filter(|fix| fix.fix_trigger_range.intersect(range).is_some())\n+    {\n         let title = fix.label;\n         let edit = to_proto::snippet_workspace_edit(&snap, fix.source_change)?;\n         let action = lsp_ext::CodeAction {"}]}