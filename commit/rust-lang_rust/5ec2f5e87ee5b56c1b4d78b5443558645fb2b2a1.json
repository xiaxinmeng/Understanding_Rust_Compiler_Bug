{"sha": "5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlYzJmNWU4N2VlNWI1NmMxYjRkNzhiNTQ0MzU1ODY0NWZiMmIyYTE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-27T11:44:51Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-04-30T21:43:51Z"}, "message": "Suggest using an inclusive range for an overflowing endpoint", "tree": {"sha": "8bdf3265d4e13e170f35823c52193494bc5ff857", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bdf3265d4e13e170f35823c52193494bc5ff857"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1", "html_url": "https://github.com/rust-lang/rust/commit/5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cefd9987b36488a3d6f0e2b350a8abd84cfce25", "html_url": "https://github.com/rust-lang/rust/commit/2cefd9987b36488a3d6f0e2b350a8abd84cfce25"}], "stats": {"total": 76, "additions": 61, "deletions": 15}, "files": [{"sha": "989eb350442da552b01a8868df7c6883aac80369", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5ec2f5e87ee5b56c1b4d78b5443558645fb2b2a1", "patch": "@@ -1,6 +1,7 @@\n #![allow(non_snake_case)]\n \n-use rustc::hir::Node;\n+use rustc::hir::{ExprKind, Node};\n+use rustc::hir::lowering::is_range_literal;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx};\n@@ -129,21 +130,66 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n                             if let Node::Expr(parent_expr) = cx.tcx.hir().get_by_hir_id(parent_id) {\n-                                if let hir::ExprKind::Cast(..) = parent_expr.node {\n-                                    if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n-                                        let mut err = cx.struct_span_lint(\n-                                                             OVERFLOWING_LITERALS,\n-                                                             parent_expr.span,\n-                                                             \"only u8 can be cast into char\");\n-                                        err.span_suggestion(\n-                                            parent_expr.span,\n-                                            &\"use a char literal instead\",\n-                                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                            Applicability::MachineApplicable\n-                                        );\n-                                        err.emit();\n-                                        return\n+                                match parent_expr.node {\n+                                    hir::ExprKind::Cast(..) => {\n+                                        if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n+                                            let mut err = cx.struct_span_lint(\n+                                                OVERFLOWING_LITERALS,\n+                                                parent_expr.span,\n+                                                \"only u8 can be cast into char\",\n+                                            );\n+                                            err.span_suggestion(\n+                                                parent_expr.span,\n+                                                &\"use a char literal instead\",\n+                                                format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                                                Applicability::MachineApplicable,\n+                                            );\n+                                            err.emit();\n+                                            return;\n+                                        }\n+                                    }\n+                                    hir::ExprKind::Struct(..)\n+                                        if is_range_literal(cx.sess(), parent_expr) => {\n+                                            // We only want to handle exclusive (`..`) ranges,\n+                                            // which are represented as `ExprKind::Struct`.\n+                                            if let ExprKind::Struct(_, eps, _) = &parent_expr.node {\n+                                                debug_assert_eq!(eps.len(), 2);\n+                                                // We can suggest using an inclusive range\n+                                                // (`..=`) instead only if it is the `end` that is\n+                                                // overflowing and only by 1.\n+                                                if eps[1].expr.hir_id == e.hir_id\n+                                                    && lit_val - 1 == max\n+                                                {\n+                                                    let mut err = cx.struct_span_lint(\n+                                                        OVERFLOWING_LITERALS,\n+                                                        parent_expr.span,\n+                                                        &format!(\n+                                                            \"range endpoint is out of range \\\n+                                                             for {:?}\",\n+                                                            t,\n+                                                        ),\n+                                                    );\n+                                                    if let Ok(start) = cx.sess().source_map()\n+                                                        .span_to_snippet(eps[0].span)\n+                                                    {\n+                                                        let suggestion = format!(\n+                                                            \"{}..={}\",\n+                                                            start,\n+                                                            lit_val - 1,\n+                                                        );\n+                                                        err.span_suggestion(\n+                                                            parent_expr.span,\n+                                                            &\"use an inclusive range instead\",\n+                                                            suggestion,\n+                                                            Applicability::MachineApplicable,\n+                                                        );\n+                                                        err.emit();\n+                                                        return;\n+                                                    }\n+                                                }\n+                                            }\n                                     }\n+                                    _ => {}\n                                 }\n                             }\n                             if let Some(repr_str) = get_bin_hex_repr(cx, lit) {"}]}