{"sha": "c78724f869add98e0f2af8950f760a37ec35243b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ODcyNGY4NjlhZGQ5OGUwZjJhZjg5NTBmNzYwYTM3ZWMzNTI0M2I=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-21T16:26:19Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-04-21T16:26:19Z"}, "message": "More review changes", "tree": {"sha": "7a930374fa45904592c116ebd1a74247ab0515e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a930374fa45904592c116ebd1a74247ab0515e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c78724f869add98e0f2af8950f760a37ec35243b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c78724f869add98e0f2af8950f760a37ec35243b", "html_url": "https://github.com/rust-lang/rust/commit/c78724f869add98e0f2af8950f760a37ec35243b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c78724f869add98e0f2af8950f760a37ec35243b/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "url": "https://api.github.com/repos/rust-lang/rust/commits/b78c0d8a4d5af91a4a55d029293e3ecb879ec142", "html_url": "https://github.com/rust-lang/rust/commit/b78c0d8a4d5af91a4a55d029293e3ecb879ec142"}], "stats": {"total": 144, "additions": 59, "deletions": 85}, "files": [{"sha": "174df09cbdbb2b5e4dcea4cb05da17b9f6974f5e", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 59, "deletions": 85, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c78724f869add98e0f2af8950f760a37ec35243b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78724f869add98e0f2af8950f760a37ec35243b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=c78724f869add98e0f2af8950f760a37ec35243b", "patch": "@@ -274,10 +274,8 @@ enum Scope<'a> {\n \n #[derive(Copy, Clone, Debug)]\n enum BinderScopeType {\n-    /// In a syntactic trait ref, this represents the outermost binder. So, if\n-    /// you had `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'a>`\n-    /// scope uses `PolyTraitRef`.\n-    PolyTraitRef,\n+    /// Any non-concatenating binder scopes.\n+    Normal,\n     /// Within a syntactic trait ref, there may be multiple poly trait refs that\n     /// are nested (under the `associcated_type_bounds` feature). The binders of\n     /// the innner poly trait refs are extended from the outer poly trait refs\n@@ -288,10 +286,6 @@ enum BinderScopeType {\n     /// out any lifetimes because they aren't needed to show the two scopes).\n     /// The inner `for<>` has a scope of `Concatenating`.\n     Concatenating,\n-    /// Any other binder scopes. These are \"normal\" in that they increase the binder\n-    /// depth, are fully syntactic, don't concatenate, and don't have special syntactical\n-    /// considerations.\n-    Other,\n }\n \n // A helper struct for debugging scopes without printing parent scopes\n@@ -573,6 +567,43 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n     }\n }\n \n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+    /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n+    fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n+        let mut scope = self.scope;\n+        let mut supertrait_lifetimes = vec![];\n+        loop {\n+            match scope {\n+                Scope::Body { .. } | Scope::Root => {\n+                    break (vec![], BinderScopeType::Normal);\n+                }\n+\n+                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Supertrait { s, lifetimes } => {\n+                    supertrait_lifetimes = lifetimes.clone();\n+                    scope = s;\n+                }\n+\n+                Scope::TraitRefBoundary { .. } => {\n+                    // We should only see super trait lifetimes if there is a `Binder` above\n+                    assert!(supertrait_lifetimes.is_empty());\n+                    break (vec![], BinderScopeType::Normal);\n+                }\n+\n+                Scope::Binder { hir_id, .. } => {\n+                    // Nested poly trait refs have the binders concatenated\n+                    let mut full_binders =\n+                        self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    break (full_binders, BinderScopeType::Concatenating);\n+                }\n+            }\n+        }\n+    }\n+}\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -630,7 +661,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    scope_type: BinderScopeType::Other,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, move |_old_scope, this| {\n                     intravisit::walk_fn(this, fk, fd, b, s, hir_id)\n@@ -755,7 +786,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n                     track_lifetime_uses,\n-                    scope_type: BinderScopeType::Other,\n+                    scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -827,7 +858,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    scope_type: BinderScopeType::Other,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -1023,7 +1054,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             s: this.scope,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            scope_type: BinderScopeType::Other,\n+                            scope_type: BinderScopeType::Normal,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -1043,7 +1074,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         s: self.scope,\n                         track_lifetime_uses: true,\n                         opaque_type_parent: false,\n-                        scope_type: BinderScopeType::Other,\n+                        scope_type: BinderScopeType::Normal,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -1102,7 +1133,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    scope_type: BinderScopeType::Other,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1171,7 +1202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    scope_type: BinderScopeType::Other,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1287,7 +1318,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             next_early_index,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            scope_type: BinderScopeType::PolyTraitRef,\n+                            scope_type: BinderScopeType::Normal,\n                         };\n                         this.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n@@ -1317,32 +1348,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n-        // FIXME(jackh726): This is pretty weird. `LangItemTrait` doesn't go\n-        // through the regular poly trait ref code, so we don't get another\n-        // chance to introduce a binder. For now, I'm keeping the existing logic\n-        // of \"if there isn't a Binder scope above us, add one\", but I\n-        // imagine there's a better way to go about this.\n-        let mut scope = self.scope;\n-        let (binders, scope_type) = loop {\n-            match scope {\n-                Scope::TraitRefBoundary { .. } | Scope::Body { .. } | Scope::Root => {\n-                    break (vec![], BinderScopeType::PolyTraitRef);\n-                }\n-\n-                Scope::Binder { hir_id, .. } => {\n-                    let binders = self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                    break (binders, BinderScopeType::Concatenating);\n-                }\n-\n-                Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n-                    scope = s;\n-                }\n-            }\n-        };\n         match bound {\n             hir::GenericBound::LangItemTrait(_, _, hir_id, _) => {\n+                // FIXME(jackh726): This is pretty weird. `LangItemTrait` doesn't go\n+                // through the regular poly trait ref code, so we don't get another\n+                // chance to introduce a binder. For now, I'm keeping the existing logic\n+                // of \"if there isn't a Binder scope above us, add one\", but I\n+                // imagine there's a better way to go about this.\n+                let (binders, scope_type) = self.poly_trait_ref_binder_info();\n+\n                 self.map.late_bound_vars.insert(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n@@ -1371,44 +1385,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n \n         let next_early_index = self.next_early_index();\n-        let mut scope = self.scope;\n-        let mut supertrait_lifetimes = vec![];\n-        let (mut binders, scope_type) = loop {\n-            match scope {\n-                Scope::Body { .. } | Scope::Root => {\n-                    break (vec![], BinderScopeType::PolyTraitRef);\n-                }\n-\n-                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n-                    scope = s;\n-                }\n-\n-                Scope::Supertrait { s, lifetimes } => {\n-                    supertrait_lifetimes = lifetimes.clone();\n-                    scope = s;\n-                }\n-\n-                Scope::TraitRefBoundary { .. } => {\n-                    // We should only see super trait lifetimes if there is a `Binder` above\n-                    assert!(supertrait_lifetimes.is_empty());\n-                    break (vec![], BinderScopeType::PolyTraitRef);\n-                }\n-\n-                Scope::Binder { hir_id, scope_type, .. } => {\n-                    if let BinderScopeType::Other = scope_type {\n-                        bug!(\n-                            \"Expected all syntacic poly trait refs to be surrounded by a `TraitRefBoundary`\"\n-                        )\n-                    }\n-\n-                    // Nested poly trait refs have the binders concatenated\n-                    let mut full_binders =\n-                        self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                    full_binders.extend(supertrait_lifetimes.into_iter());\n-                    break (full_binders, BinderScopeType::Concatenating);\n-                }\n-            }\n-        };\n+        let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n         let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n@@ -2185,7 +2162,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             s: self.scope,\n             opaque_type_parent: true,\n             track_lifetime_uses: false,\n-            scope_type: BinderScopeType::Other,\n+            scope_type: BinderScopeType::Normal,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n@@ -2270,8 +2247,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => bug!(\"expected LifetimeName::Param\"),\n                     }\n                     match scope_type {\n-                        BinderScopeType::Other => late_depth += 1,\n-                        BinderScopeType::PolyTraitRef => late_depth += 1,\n+                        BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n@@ -3001,8 +2977,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                     }\n                     match scope_type {\n-                        BinderScopeType::Other => late_depth += 1,\n-                        BinderScopeType::PolyTraitRef => late_depth += 1,\n+                        BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n@@ -3165,8 +3140,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             match *scope {\n                 Scope::Binder { s, scope_type, .. } => {\n                     match scope_type {\n-                        BinderScopeType::Other => late_depth += 1,\n-                        BinderScopeType::PolyTraitRef => late_depth += 1,\n+                        BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;"}]}