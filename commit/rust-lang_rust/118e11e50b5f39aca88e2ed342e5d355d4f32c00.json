{"sha": "118e11e50b5f39aca88e2ed342e5d355d4f32c00", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOGUxMWU1MGI1ZjM5YWNhODhlMmVkMzQyZTVkMzU1ZDRmMzJjMDA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-23T15:31:59Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-23T15:31:59Z"}, "message": "Merge #612\n\n612: Some random refactorings r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8b6f174292aee253fa6db15184a2ed7b440ca919", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b6f174292aee253fa6db15184a2ed7b440ca919"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/118e11e50b5f39aca88e2ed342e5d355d4f32c00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/118e11e50b5f39aca88e2ed342e5d355d4f32c00", "html_url": "https://github.com/rust-lang/rust/commit/118e11e50b5f39aca88e2ed342e5d355d4f32c00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/118e11e50b5f39aca88e2ed342e5d355d4f32c00/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a583070b7d47852094b498c3191b4b5d87520fc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a583070b7d47852094b498c3191b4b5d87520fc3", "html_url": "https://github.com/rust-lang/rust/commit/a583070b7d47852094b498c3191b4b5d87520fc3"}, {"sha": "d4ed25d86fdec0ce47199c262af62213b62e4863", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ed25d86fdec0ce47199c262af62213b62e4863", "html_url": "https://github.com/rust-lang/rust/commit/d4ed25d86fdec0ce47199c262af62213b62e4863"}], "stats": {"total": 295, "additions": 152, "deletions": 143}, "files": [{"sha": "b201bf69bf9ae1bd67cfea86a251ab65136e1a10", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 112, "deletions": 134, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=118e11e50b5f39aca88e2ed342e5d355d4f32c00", "patch": "@@ -62,14 +62,26 @@ impl Submodule {\n             file_items: &SourceFileItems,\n             root: &impl ast::ModuleItemOwner,\n         ) -> Vec<Submodule> {\n-            modules(root)\n-                .map(|(name, m)| Submodule {\n-                    name,\n-                    is_declaration: m.has_semi(),\n-                    source: SourceItemId {\n-                        file_id,\n-                        item_id: Some(file_items.id_of(file_id, m.syntax())),\n-                    },\n+            root.items()\n+                .filter_map(|item| match item.kind() {\n+                    ast::ModuleItemKind::Module(m) => Some(m),\n+                    _ => None,\n+                })\n+                .filter_map(|module| {\n+                    let name = module.name()?.as_name();\n+                    if !module.has_semi() && module.item_list().is_none() {\n+                        tested_by!(name_res_works_for_broken_modules);\n+                        return None;\n+                    }\n+                    let sub = Submodule {\n+                        name,\n+                        is_declaration: module.has_semi(),\n+                        source: SourceItemId {\n+                            file_id,\n+                            item_id: Some(file_items.id_of(file_id, module.syntax())),\n+                        },\n+                    };\n+                    Some(sub)\n                 })\n                 .collect()\n         }\n@@ -119,7 +131,8 @@ impl ModuleTree {\n         source_root: SourceRootId,\n     ) -> Arc<ModuleTree> {\n         db.check_canceled();\n-        let res = create_module_tree(db, source_root);\n+        let mut res = ModuleTree::default();\n+        res.init(db, source_root);\n         Arc::new(res)\n     }\n \n@@ -131,6 +144,96 @@ impl ModuleTree {\n         let (res, _) = self.mods.iter().find(|(_, m)| m.source == source)?;\n         Some(res)\n     }\n+\n+    fn init(&mut self, db: &impl HirDatabase, source_root: SourceRootId) {\n+        let mut roots = FxHashMap::default();\n+        let mut visited = FxHashSet::default();\n+\n+        let source_root = db.source_root(source_root);\n+        for &file_id in source_root.files.values() {\n+            let source = SourceItemId {\n+                file_id: file_id.into(),\n+                item_id: None,\n+            };\n+            if visited.contains(&source) {\n+                continue; // TODO: use explicit crate_roots here\n+            }\n+            assert!(!roots.contains_key(&file_id));\n+            let module_id =\n+                self.init_subtree(db, &source_root, &mut visited, &mut roots, None, source);\n+            roots.insert(file_id, module_id);\n+        }\n+    }\n+\n+    fn init_subtree(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        source_root: &SourceRoot,\n+        visited: &mut FxHashSet<SourceItemId>,\n+        roots: &mut FxHashMap<FileId, ModuleId>,\n+        parent: Option<LinkId>,\n+        source: SourceItemId,\n+    ) -> ModuleId {\n+        visited.insert(source);\n+        let id = self.alloc_mod(ModuleData {\n+            source,\n+            parent,\n+            children: Vec::new(),\n+        });\n+        for sub in db.submodules(source).iter() {\n+            let link = self.alloc_link(LinkData {\n+                source: sub.source,\n+                name: sub.name.clone(),\n+                owner: id,\n+                points_to: Vec::new(),\n+                problem: None,\n+            });\n+\n+            let (points_to, problem) = if sub.is_declaration {\n+                let (points_to, problem) = resolve_submodule(db, source.file_id, &sub.name);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| match roots.remove(&file_id) {\n+                        Some(module_id) => {\n+                            self.mods[module_id].parent = Some(link);\n+                            module_id\n+                        }\n+                        None => self.init_subtree(\n+                            db,\n+                            source_root,\n+                            visited,\n+                            roots,\n+                            Some(link),\n+                            SourceItemId {\n+                                file_id: file_id.into(),\n+                                item_id: None,\n+                            },\n+                        ),\n+                    })\n+                    .collect::<Vec<_>>();\n+                (points_to, problem)\n+            } else {\n+                let points_to =\n+                    self.init_subtree(db, source_root, visited, roots, Some(link), sub.source);\n+                (vec![points_to], None)\n+            };\n+\n+            self.links[link].points_to = points_to;\n+            self.links[link].problem = problem;\n+        }\n+        id\n+    }\n+\n+    fn alloc_mod(&mut self, data: ModuleData) -> ModuleId {\n+        self.mods.alloc(data)\n+    }\n+\n+    fn alloc_link(&mut self, data: LinkData) -> LinkId {\n+        let owner = data.owner;\n+        let id = self.links.alloc(data);\n+        self.mods[owner].children.push(id);\n+        id\n+    }\n }\n \n impl ModuleId {\n@@ -198,131 +301,6 @@ impl LinkId {\n     }\n }\n \n-impl ModuleTree {\n-    fn push_mod(&mut self, data: ModuleData) -> ModuleId {\n-        self.mods.alloc(data)\n-    }\n-    fn push_link(&mut self, data: LinkData) -> LinkId {\n-        let owner = data.owner;\n-        let id = self.links.alloc(data);\n-        self.mods[owner].children.push(id);\n-        id\n-    }\n-}\n-\n-fn modules(root: &impl ast::ModuleItemOwner) -> impl Iterator<Item = (Name, &ast::Module)> {\n-    root.items()\n-        .filter_map(|item| match item.kind() {\n-            ast::ModuleItemKind::Module(m) => Some(m),\n-            _ => None,\n-        })\n-        .filter_map(|module| {\n-            let name = module.name()?.as_name();\n-            if !module.has_semi() && module.item_list().is_none() {\n-                tested_by!(name_res_works_for_broken_modules);\n-                return None;\n-            }\n-            Some((name, module))\n-        })\n-}\n-\n-fn create_module_tree<'a>(db: &impl HirDatabase, source_root: SourceRootId) -> ModuleTree {\n-    let mut tree = ModuleTree::default();\n-\n-    let mut roots = FxHashMap::default();\n-    let mut visited = FxHashSet::default();\n-\n-    let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.values() {\n-        let source = SourceItemId {\n-            file_id: file_id.into(),\n-            item_id: None,\n-        };\n-        if visited.contains(&source) {\n-            continue; // TODO: use explicit crate_roots here\n-        }\n-        assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(\n-            db,\n-            &source_root,\n-            &mut tree,\n-            &mut visited,\n-            &mut roots,\n-            None,\n-            source,\n-        );\n-        roots.insert(file_id, module_id);\n-    }\n-    tree\n-}\n-\n-fn build_subtree(\n-    db: &impl HirDatabase,\n-    source_root: &SourceRoot,\n-    tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<SourceItemId>,\n-    roots: &mut FxHashMap<FileId, ModuleId>,\n-    parent: Option<LinkId>,\n-    source: SourceItemId,\n-) -> ModuleId {\n-    visited.insert(source);\n-    let id = tree.push_mod(ModuleData {\n-        source,\n-        parent,\n-        children: Vec::new(),\n-    });\n-    for sub in db.submodules(source).iter() {\n-        let link = tree.push_link(LinkData {\n-            source: sub.source,\n-            name: sub.name.clone(),\n-            owner: id,\n-            points_to: Vec::new(),\n-            problem: None,\n-        });\n-\n-        let (points_to, problem) = if sub.is_declaration {\n-            let (points_to, problem) = resolve_submodule(db, source.file_id, &sub.name);\n-            let points_to = points_to\n-                .into_iter()\n-                .map(|file_id| match roots.remove(&file_id) {\n-                    Some(module_id) => {\n-                        tree.mods[module_id].parent = Some(link);\n-                        module_id\n-                    }\n-                    None => build_subtree(\n-                        db,\n-                        source_root,\n-                        tree,\n-                        visited,\n-                        roots,\n-                        Some(link),\n-                        SourceItemId {\n-                            file_id: file_id.into(),\n-                            item_id: None,\n-                        },\n-                    ),\n-                })\n-                .collect::<Vec<_>>();\n-            (points_to, problem)\n-        } else {\n-            let points_to = build_subtree(\n-                db,\n-                source_root,\n-                tree,\n-                visited,\n-                roots,\n-                Some(link),\n-                sub.source,\n-            );\n-            (vec![points_to], None)\n-        };\n-\n-        tree.links[link].points_to = points_to;\n-        tree.links[link].problem = problem;\n-    }\n-    id\n-}\n-\n fn resolve_submodule(\n     db: &impl HirDatabase,\n     file_id: HirFileId,"}, {"sha": "921ba3c98a3f84a53af14289af1d938b63bb131e", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=118e11e50b5f39aca88e2ed342e5d355d4f32c00", "patch": "@@ -1,10 +1,10 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    SyntaxKind, AstNode, SourceFile, TreeArc, SyntaxNodePtr,\n+    SyntaxKind, AstNode, SourceFile, TreeArc, AstPtr,\n     ast::{self, ModuleItemOwner},\n };\n-use ra_db::{SourceRootId};\n+use ra_db::SourceRootId;\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n \n use crate::{\n@@ -72,13 +72,12 @@ pub struct LoweredModule {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImportSourceMap {\n-    map: ArenaMap<ImportId, SyntaxNodePtr>,\n+    map: ArenaMap<ImportId, AstPtr<ast::PathSegment>>,\n }\n \n impl ImportSourceMap {\n     fn insert(&mut self, import: ImportId, segment: &ast::PathSegment) {\n-        self.map\n-            .insert(import, SyntaxNodePtr::new(segment.syntax()))\n+        self.map.insert(import, AstPtr::new(segment))\n     }\n \n     pub fn get(&self, source: &ModuleSource, import: ImportId) -> TreeArc<ast::PathSegment> {\n@@ -87,9 +86,7 @@ impl ImportSourceMap {\n             ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n         };\n \n-        ast::PathSegment::cast(self.map[import].to_node(file))\n-            .unwrap()\n-            .to_owned()\n+        self.map[import].to_node(file).to_owned()\n     }\n }\n "}, {"sha": "104f3285159dbbff6b768a71204010545c588627", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=118e11e50b5f39aca88e2ed342e5d355d4f32c00", "patch": "@@ -43,7 +43,7 @@ pub use crate::{\n     lexer::{tokenize, Token},\n     syntax_kinds::SyntaxKind,\n     yellow::{Direction, SyntaxError, SyntaxNode, WalkEvent, Location, TreeArc},\n-    ptr::SyntaxNodePtr,\n+    ptr::{SyntaxNodePtr, AstPtr},\n };\n \n use ra_text_edit::AtomTextEdit;"}, {"sha": "b50cd8a520a14c7fbb204909135c591475200c9a", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/118e11e50b5f39aca88e2ed342e5d355d4f32c00/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=118e11e50b5f39aca88e2ed342e5d355d4f32c00", "patch": "@@ -1,3 +1,5 @@\n+use std::marker::PhantomData;\n+\n use crate::{\n     AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n     algo::generate,\n@@ -37,6 +39,38 @@ impl SyntaxNodePtr {\n     }\n }\n \n+/// Like `SyntaxNodePtr`, but remembers the type of node\n+#[derive(Debug, PartialEq, Eq, Hash)]\n+pub struct AstPtr<N: AstNode> {\n+    ptr: SyntaxNodePtr,\n+    _ty: PhantomData<N>,\n+}\n+\n+impl<N: AstNode> Copy for AstPtr<N> {}\n+impl<N: AstNode> Clone for AstPtr<N> {\n+    fn clone(&self) -> AstPtr<N> {\n+        *self\n+    }\n+}\n+\n+impl<N: AstNode> AstPtr<N> {\n+    pub fn new(node: &N) -> AstPtr<N> {\n+        AstPtr {\n+            ptr: SyntaxNodePtr::new(node.syntax()),\n+            _ty: PhantomData,\n+        }\n+    }\n+\n+    pub fn to_node(self, source_file: &SourceFile) -> &N {\n+        let syntax_node = self.ptr.to_node(source_file);\n+        N::cast(syntax_node).unwrap()\n+    }\n+\n+    pub fn syntax_node_ptr(self) -> SyntaxNodePtr {\n+        self.ptr\n+    }\n+}\n+\n #[test]\n fn test_local_syntax_ptr() {\n     use crate::{ast, AstNode};"}]}