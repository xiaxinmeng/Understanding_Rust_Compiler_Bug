{"sha": "7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "node_id": "C_kwDOAAsO6NoAKDdmYTA2ZjZiODgyYmQwZWU5MzY2ZjMxY2NmNGFlOTQ4YTE2NDk0Zjk", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-13T16:26:17Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-01-12T20:26:24Z"}, "message": "Avoid a hir access inside get_static", "tree": {"sha": "e16e9457dd5477ab5408c7b5f7e45803058a1064", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e16e9457dd5477ab5408c7b5f7e45803058a1064"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "html_url": "https://github.com/rust-lang/rust/commit/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c5a70de207adc466ab0ffd5151fc1c9161c83e7", "html_url": "https://github.com/rust-lang/rust/commit/6c5a70de207adc466ab0ffd5151fc1c9161c83e7"}], "stats": {"total": 129, "additions": 51, "deletions": 78}, "files": [{"sha": "d70c9076897b849e31708b03d1c6ad6227d291fa", "filename": "src/consts.rs", "status": "modified", "additions": 51, "deletions": 78, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fa06f6b882bd0ee9366f31ccf4ae948a16494f9/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=7fa06f6b882bd0ee9366f31ccf4ae948a16494f9", "patch": "@@ -2,9 +2,7 @@\n use gccjit::FnAttribute;\n use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n-use rustc_hir as hir;\n-use rustc_hir::Node;\n-use rustc_middle::{bug, span_bug};\n+use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -217,84 +215,59 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let sym = self.tcx.symbol_name(instance).name;\n \n-        let global =\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self);\n-                // FIXME: refactor this to work without accessing the HIR\n-                let global = match self.tcx.hir().get(id) {\n-                    Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n-                        if let Some(global) = self.get_declared_value(&sym) {\n-                            if self.val_ty(global) != self.type_ptr_to(llty) {\n-                                span_bug!(span, \"Conflicting types for static\");\n-                            }\n-                        }\n-\n-                        let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-                        let global = self.declare_global(\n-                            &sym,\n-                            llty,\n-                            GlobalKind::Exported,\n-                            is_tls,\n-                            fn_attrs.link_section,\n-                        );\n-\n-                        if !self.tcx.is_reachable_non_generic(def_id) {\n-                            // TODO(antoyo): set visibility.\n-                        }\n-\n-                        global\n-                    }\n-\n-                    Node::ForeignItem(&hir::ForeignItem {\n-                        span,\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    }) => {\n-                        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        check_and_apply_linkage(&self, &fn_attrs, ty, sym, span)\n-                    }\n-\n-                    item => bug!(\"get_static: expected static, found {:?}\", item),\n-                };\n+        let global = if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+            let llty = self.layout_of(ty).gcc_type(self);\n+            if let Some(global) = self.get_declared_value(sym) {\n+                if self.val_ty(global) != self.type_ptr_to(llty) {\n+                    span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n+                }\n+            }\n \n-                global\n+            let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+            let global = self.declare_global(\n+                &sym,\n+                llty,\n+                GlobalKind::Exported,\n+                is_tls,\n+                fn_attrs.link_section,\n+            );\n+\n+            if !self.tcx.is_reachable_non_generic(def_id) {\n+                // TODO(antoyo): set visibility.\n             }\n-            else {\n-                // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-                //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n-\n-                let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                let span = self.tcx.def_span(def_id);\n-                let global = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n-\n-                let needs_dll_storage_attr = false; // TODO(antoyo)\n-\n-                // If this assertion triggers, there's something wrong with commandline\n-                // argument validation.\n-                debug_assert!(\n-                    !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                        && self.tcx.sess.target.options.is_like_msvc\n-                        && self.tcx.sess.opts.cg.prefer_dynamic)\n-                );\n-\n-                if needs_dll_storage_attr {\n-                    // This item is external but not foreign, i.e., it originates from an external Rust\n-                    // crate. Since we don't know whether this crate will be linked dynamically or\n-                    // statically in the final application, we always mark such symbols as 'dllimport'.\n-                    // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n-                    // to make things work.\n-                    //\n-                    // However, in some scenarios we defer emission of statics to downstream\n-                    // crates, so there are cases where a static with an upstream DefId\n-                    // is actually present in the current crate. We can find out via the\n-                    // is_codegened_item query.\n-                    if !self.tcx.is_codegened_item(def_id) {\n-                        unimplemented!();\n-                    }\n+\n+            global\n+        } else {\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym, self.tcx.def_span(def_id))\n+        };\n+\n+        if !def_id.is_local() {\n+            let needs_dll_storage_attr = false; // TODO(antoyo)\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.options.is_like_msvc\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unimplemented!();\n                 }\n-                global\n-            };\n+            }\n+        }\n \n         // TODO(antoyo): set dll storage class.\n "}]}