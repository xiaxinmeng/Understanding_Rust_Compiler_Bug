{"sha": "9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNjczYjI0NmM2OWQxY2RjZmZiYWYwZTVjZjAxMjk0MWIwYjc4ZTI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-10T16:11:56Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-12-20T02:16:20Z"}, "message": "Remove the old serialization code\n\nCloses #3713.", "tree": {"sha": "98d1955c2cc1318f522eac4ec848f190ce5302e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98d1955c2cc1318f522eac4ec848f190ce5302e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "html_url": "https://github.com/rust-lang/rust/commit/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6742c982a46fb9fcad190d6b9c2c2fc1370a354b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6742c982a46fb9fcad190d6b9c2c2fc1370a354b", "html_url": "https://github.com/rust-lang/rust/commit/6742c982a46fb9fcad190d6b9c2c2fc1370a354b"}], "stats": {"total": 1627, "additions": 1, "deletions": 1626}, "files": [{"sha": "8a3e6213325a78fc9dfd818a0fde5b64c8acf107", "filename": "src/libstd/serialization.rs", "status": "removed", "additions": 0, "deletions": 585, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/6742c982a46fb9fcad190d6b9c2c2fc1370a354b/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6742c982a46fb9fcad190d6b9c2c2fc1370a354b/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=6742c982a46fb9fcad190d6b9c2c2fc1370a354b", "patch": "@@ -1,585 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Support code for serialization.\n-\n-/*\n-Core serialization interfaces.\n-*/\n-\n-#[forbid(deprecated_mode)];\n-#[forbid(non_camel_case_types)];\n-\n-pub trait Serializer {\n-    // Primitive types:\n-    fn emit_nil(&self);\n-    fn emit_uint(&self, v: uint);\n-    fn emit_u64(&self, v: u64);\n-    fn emit_u32(&self, v: u32);\n-    fn emit_u16(&self, v: u16);\n-    fn emit_u8(&self, v: u8);\n-    fn emit_int(&self, v: int);\n-    fn emit_i64(&self, v: i64);\n-    fn emit_i32(&self, v: i32);\n-    fn emit_i16(&self, v: i16);\n-    fn emit_i8(&self, v: i8);\n-    fn emit_bool(&self, v: bool);\n-    fn emit_float(&self, v: float);\n-    fn emit_f64(&self, v: f64);\n-    fn emit_f32(&self, v: f32);\n-    fn emit_char(&self, v: char);\n-    fn emit_borrowed_str(&self, v: &str);\n-    fn emit_owned_str(&self, v: &str);\n-    fn emit_managed_str(&self, v: &str);\n-\n-    // Compound types:\n-    fn emit_borrowed(&self, f: fn());\n-    fn emit_owned(&self, f: fn());\n-    fn emit_managed(&self, f: fn());\n-\n-    fn emit_enum(&self, name: &str, f: fn());\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: fn());\n-    fn emit_enum_variant_arg(&self, idx: uint, f: fn());\n-\n-    fn emit_borrowed_vec(&self, len: uint, f: fn());\n-    fn emit_owned_vec(&self, len: uint, f: fn());\n-    fn emit_managed_vec(&self, len: uint, f: fn());\n-    fn emit_vec_elt(&self, idx: uint, f: fn());\n-\n-    fn emit_rec(&self, f: fn());\n-    fn emit_struct(&self, name: &str, f: fn());\n-    fn emit_field(&self, f_name: &str, f_idx: uint, f: fn());\n-\n-    fn emit_tup(&self, len: uint, f: fn());\n-    fn emit_tup_elt(&self, idx: uint, f: fn());\n-}\n-\n-pub trait Deserializer {\n-    // Primitive types:\n-    fn read_nil(&self) -> ();\n-    fn read_uint(&self) -> uint;\n-    fn read_u64(&self) -> u64;\n-    fn read_u32(&self) -> u32;\n-    fn read_u16(&self) -> u16;\n-    fn read_u8(&self) -> u8;\n-    fn read_int(&self) -> int;\n-    fn read_i64(&self) -> i64;\n-    fn read_i32(&self) -> i32;\n-    fn read_i16(&self) -> i16;\n-    fn read_i8(&self) -> i8;\n-    fn read_bool(&self) -> bool;\n-    fn read_f64(&self) -> f64;\n-    fn read_f32(&self) -> f32;\n-    fn read_float(&self) -> float;\n-    fn read_char(&self) -> char;\n-    fn read_owned_str(&self) -> ~str;\n-    fn read_managed_str(&self) -> @str;\n-\n-    // Compound types:\n-    fn read_enum<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_owned<T>(&self, f: fn() -> T) -> T;\n-    fn read_managed<T>(&self, f: fn() -> T) -> T;\n-\n-    fn read_owned_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_managed_vec<T>(&self, f: fn(uint) -> T) -> T;\n-    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_rec<T>(&self, f: fn() -> T) -> T;\n-    fn read_struct<T>(&self, name: &str, f: fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: fn() -> T) -> T;\n-\n-    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T;\n-    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T;\n-}\n-\n-pub mod traits {\n-pub trait Serializable<S: Serializer> {\n-    fn serialize(&self, s: &S);\n-}\n-\n-pub trait Deserializable<D: Deserializer> {\n-    static fn deserialize(&self, d: &D) -> self;\n-}\n-\n-pub impl<S: Serializer> uint: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_uint(*self) }\n-}\n-\n-pub impl<D: Deserializer> uint: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> uint {\n-        d.read_uint()\n-    }\n-}\n-\n-pub impl<S: Serializer> u8: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_u8(*self) }\n-}\n-\n-pub impl<D: Deserializer> u8: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> u8 {\n-        d.read_u8()\n-    }\n-}\n-\n-pub impl<S: Serializer> u16: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_u16(*self) }\n-}\n-\n-pub impl<D: Deserializer> u16: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> u16 {\n-        d.read_u16()\n-    }\n-}\n-\n-pub impl<S: Serializer> u32: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_u32(*self) }\n-}\n-\n-pub impl<D: Deserializer> u32: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> u32 {\n-        d.read_u32()\n-    }\n-}\n-\n-pub impl<S: Serializer> u64: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_u64(*self) }\n-}\n-\n-pub impl<D: Deserializer> u64: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> u64 {\n-        d.read_u64()\n-    }\n-}\n-\n-pub impl<S: Serializer> int: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_int(*self) }\n-}\n-\n-pub impl<D: Deserializer> int: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> int {\n-        d.read_int()\n-    }\n-}\n-\n-pub impl<S: Serializer> i8: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_i8(*self) }\n-}\n-\n-pub impl<D: Deserializer> i8: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> i8 {\n-        d.read_i8()\n-    }\n-}\n-\n-pub impl<S: Serializer> i16: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_i16(*self) }\n-}\n-\n-pub impl<D: Deserializer> i16: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> i16 {\n-        d.read_i16()\n-    }\n-}\n-\n-pub impl<S: Serializer> i32: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_i32(*self) }\n-}\n-\n-pub impl<D: Deserializer> i32: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> i32 {\n-        d.read_i32()\n-    }\n-}\n-\n-pub impl<S: Serializer> i64: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_i64(*self) }\n-}\n-\n-pub impl<D: Deserializer> i64: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> i64 {\n-        d.read_i64()\n-    }\n-}\n-\n-pub impl<S: Serializer> &str: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_borrowed_str(*self) }\n-}\n-\n-pub impl<S: Serializer> ~str: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_owned_str(*self) }\n-}\n-\n-pub impl<D: Deserializer> ~str: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> ~str {\n-        d.read_owned_str()\n-    }\n-}\n-\n-pub impl<S: Serializer> @str: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_managed_str(*self) }\n-}\n-\n-pub impl<D: Deserializer> @str: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> @str {\n-        d.read_managed_str()\n-    }\n-}\n-\n-pub impl<S: Serializer> float: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_float(*self) }\n-}\n-\n-pub impl<D: Deserializer> float: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> float {\n-        d.read_float()\n-    }\n-}\n-\n-pub impl<S: Serializer> f32: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_f32(*self) }\n-}\n-\n-pub impl<D: Deserializer> f32: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> f32 {\n-        d.read_f32() }\n-}\n-\n-pub impl<S: Serializer> f64: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_f64(*self) }\n-}\n-\n-pub impl<D: Deserializer> f64: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> f64 {\n-        d.read_f64()\n-    }\n-}\n-\n-pub impl<S: Serializer> bool: Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_bool(*self) }\n-}\n-\n-pub impl<D: Deserializer> bool: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> bool {\n-        d.read_bool()\n-    }\n-}\n-\n-pub impl<S: Serializer> (): Serializable<S> {\n-    fn serialize(&self, s: &S) { s.emit_nil() }\n-}\n-\n-pub impl<D: Deserializer> (): Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> () {\n-        d.read_nil()\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> &T: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        s.emit_borrowed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> ~T: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        s.emit_owned(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<D: Deserializer, T: Deserializable<D>> ~T: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> ~T {\n-        d.read_owned(|| ~deserialize(d))\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> @T: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        s.emit_managed(|| (**self).serialize(s))\n-    }\n-}\n-\n-pub impl<D: Deserializer, T: Deserializable<D>> @T: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> @T {\n-        d.read_managed(|| @deserialize(d))\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> &[T]: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        do s.emit_borrowed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> ~[T]: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        do s.emit_owned_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<D: Deserializer, T: Deserializable<D>> ~[T]: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> ~[T] {\n-        do d.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> @[T]: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        do s.emit_managed_vec(self.len()) {\n-            for self.eachi |i, e| {\n-                s.emit_vec_elt(i, || e.serialize(s))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<D: Deserializer, T: Deserializable<D>> @[T]: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> @[T] {\n-        do d.read_managed_vec |len| {\n-            do at_vec::from_fn(len) |i| {\n-                d.read_vec_elt(i, || deserialize(d))\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<S: Serializer, T: Serializable<S>> Option<T>: Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        do s.emit_enum(~\"option\") {\n-            match *self {\n-              None => do s.emit_enum_variant(~\"none\", 0u, 0u) {\n-              },\n-\n-              Some(ref v) => do s.emit_enum_variant(~\"some\", 1u, 1u) {\n-                s.emit_enum_variant_arg(0u, || v.serialize(s))\n-              }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<D: Deserializer, T: Deserializable<D>> Option<T>: Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> Option<T> {\n-        do d.read_enum(~\"option\") {\n-            do d.read_enum_variant |i| {\n-                match i {\n-                  0 => None,\n-                  1 => Some(d.read_enum_variant_arg(0u, || deserialize(d))),\n-                  _ => fail(fmt!(\"Bad variant for option: %u\", i))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    S: Serializer,\n-    T0: Serializable<S>,\n-    T1: Serializable<S>\n-> (T0, T1): Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1) => {\n-                do s.emit_tup(2) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    D: Deserializer,\n-    T0: Deserializable<D>,\n-    T1: Deserializable<D>\n-> (T0, T1): Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> (T0, T1) {\n-        do d.read_tup(2) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    S: Serializer,\n-    T0: Serializable<S>,\n-    T1: Serializable<S>,\n-    T2: Serializable<S>\n-> (T0, T1, T2): Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2) => {\n-                do s.emit_tup(3) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    D: Deserializer,\n-    T0: Deserializable<D>,\n-    T1: Deserializable<D>,\n-    T2: Deserializable<D>\n-> (T0, T1, T2): Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> (T0, T1, T2) {\n-        do d.read_tup(3) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    S: Serializer,\n-    T0: Serializable<S>,\n-    T1: Serializable<S>,\n-    T2: Serializable<S>,\n-    T3: Serializable<S>\n-> (T0, T1, T2, T3): Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3) => {\n-                do s.emit_tup(4) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    D: Deserializer,\n-    T0: Deserializable<D>,\n-    T1: Deserializable<D>,\n-    T2: Deserializable<D>,\n-    T3: Deserializable<D>\n-> (T0, T1, T2, T3): Deserializable<D> {\n-    static fn deserialize(&self, d: &D) -> (T0, T1, T2, T3) {\n-        do d.read_tup(4) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-pub impl<\n-    S: Serializer,\n-    T0: Serializable<S>,\n-    T1: Serializable<S>,\n-    T2: Serializable<S>,\n-    T3: Serializable<S>,\n-    T4: Serializable<S>\n-> (T0, T1, T2, T3, T4): Serializable<S> {\n-    fn serialize(&self, s: &S) {\n-        match *self {\n-            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n-                do s.emit_tup(5) {\n-                    s.emit_tup_elt(0, || t0.serialize(s));\n-                    s.emit_tup_elt(1, || t1.serialize(s));\n-                    s.emit_tup_elt(2, || t2.serialize(s));\n-                    s.emit_tup_elt(3, || t3.serialize(s));\n-                    s.emit_tup_elt(4, || t4.serialize(s));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub impl<\n-    D: Deserializer,\n-    T0: Deserializable<D>,\n-    T1: Deserializable<D>,\n-    T2: Deserializable<D>,\n-    T3: Deserializable<D>,\n-    T4: Deserializable<D>\n-> (T0, T1, T2, T3, T4): Deserializable<D> {\n-    static fn deserialize(&self, d: &D)\n-      -> (T0, T1, T2, T3, T4) {\n-        do d.read_tup(5) {\n-            (\n-                d.read_tup_elt(0, || deserialize(d)),\n-                d.read_tup_elt(1, || deserialize(d)),\n-                d.read_tup_elt(2, || deserialize(d)),\n-                d.read_tup_elt(3, || deserialize(d)),\n-                d.read_tup_elt(4, || deserialize(d))\n-            )\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Helper routines\n-//\n-// In some cases, these should eventually be coded as traits.\n-\n-pub trait SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T));\n-}\n-\n-pub impl<S: Serializer> S: SerializerHelpers {\n-    fn emit_from_vec<T>(&self, v: ~[T], f: fn(v: &T)) {\n-        do self.emit_owned_vec(v.len()) {\n-            for v.eachi |i, e| {\n-                do self.emit_vec_elt(i) {\n-                    f(e)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub trait DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T];\n-}\n-\n-pub impl<D: Deserializer> D: DeserializerHelpers {\n-    fn read_to_vec<T>(&self, f: fn() -> T) -> ~[T] {\n-        do self.read_owned_vec |len| {\n-            do vec::from_fn(len) |i| {\n-                self.read_vec_elt(i, || f())\n-            }\n-        }\n-    }\n-}\n-}\n-\n-pub use serialization::traits::*;"}, {"sha": "eb3a741082801637465bab9d9567a1ed70f01b64", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "patch": "@@ -30,7 +30,7 @@ not required in or otherwise suitable for the core library.\n \n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n-// XXX this is set to allow because there are two methods in serialization\n+// XXX this is set to allow because there are two methods in encoding\n // that can't be silenced otherwise. Most every module is set to forbid\n #[allow(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n@@ -107,17 +107,13 @@ mod unicode;\n \n pub mod test;\n pub mod serialize;\n-#[cfg(stage0)]\n-pub mod serialization;\n \n // A curious inner-module that's not exported that contains the binding\n // 'std' so that macro-expanded references to std::serialize and such\n // can be resolved within libcore.\n #[doc(hidden)] // FIXME #3538\n mod std {\n     pub use serialize;\n-    #[cfg(stage0)]\n-    pub use serialization;\n }\n \n // Local Variables:"}, {"sha": "4c1725b10000c6acaa343369a1c7eb03d449f4db", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "removed", "additions": 0, "deletions": 1028, "changes": 1028, "blob_url": "https://github.com/rust-lang/rust/blob/6742c982a46fb9fcad190d6b9c2c2fc1370a354b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6742c982a46fb9fcad190d6b9c2c2fc1370a354b/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=6742c982a46fb9fcad190d6b9c2c2fc1370a354b", "patch": "@@ -1,1028 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*\n-\n-The compiler code necessary to implement the #[auto_serialize] and\n-#[auto_deserialize] extension.  The idea here is that type-defining items may\n-be tagged with #[auto_serialize] and #[auto_deserialize], which will cause\n-us to generate a little companion module with the same name as the item.\n-\n-For example, a type like:\n-\n-    #[auto_serialize]\n-    #[auto_deserialize]\n-    struct Node {id: uint}\n-\n-would generate two implementations like:\n-\n-    impl<S: Serializer> node_id: Serializable<S> {\n-        fn serialize(s: &S) {\n-            do s.emit_struct(\"Node\") {\n-                s.emit_field(\"id\", 0, || s.emit_uint(self))\n-            }\n-        }\n-    }\n-\n-    impl<D: Deserializer> node_id: Deserializable {\n-        static fn deserialize(d: &D) -> Node {\n-            do d.read_struct(\"Node\") {\n-                Node {\n-                    id: d.read_field(~\"x\", 0, || deserialize(d))\n-                }\n-            }\n-        }\n-    }\n-\n-Other interesting scenarios are whe the item has type parameters or\n-references other non-built-in types.  A type definition like:\n-\n-    #[auto_serialize]\n-    #[auto_deserialize]\n-    type spanned<T> = {node: T, span: span};\n-\n-would yield functions like:\n-\n-    impl<\n-        S: Serializer,\n-        T: Serializable<S>\n-    > spanned<T>: Serializable<S> {\n-        fn serialize<S: Serializer>(s: &S) {\n-            do s.emit_rec {\n-                s.emit_field(\"node\", 0, || self.node.serialize(s));\n-                s.emit_field(\"span\", 1, || self.span.serialize(s));\n-            }\n-        }\n-    }\n-\n-    impl<\n-        D: Deserializer,\n-        T: Deserializable<D>\n-    > spanned<T>: Deserializable<D> {\n-        static fn deserialize(d: &D) -> spanned<T> {\n-            do d.read_rec {\n-                {\n-                    node: d.read_field(~\"node\", 0, || deserialize(d)),\n-                    span: d.read_field(~\"span\", 1, || deserialize(d)),\n-                }\n-            }\n-        }\n-    }\n-\n-FIXME (#2810)--Hygiene. Search for \"__\" strings.  We also assume \"std\" is the\n-standard library.\n-\n-Misc notes:\n------------\n-\n-I use move mode arguments for ast nodes that will get inserted as is\n-into the tree.  This is intended to prevent us from inserting the same\n-node twice.\n-\n-*/\n-\n-use ext::base::*;\n-use codemap::span;\n-use std::map;\n-use std::map::HashMap;\n-\n-export expand_auto_serialize;\n-export expand_auto_deserialize;\n-\n-// Transitional reexports so qquote can find the paths it is looking for\n-mod syntax {\n-    pub use ext;\n-    pub use parse;\n-}\n-\n-fn expand_auto_serialize(\n-    cx: ext_ctxt,\n-    span: span,\n-    _mitem: ast::meta_item,\n-    in_items: ~[@ast::item]\n-) -> ~[@ast::item] {\n-    fn is_auto_serialize(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) == ~\"auto_serialize\"\n-    }\n-\n-    fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, |a| !is_auto_serialize(a)),\n-          .. *item}\n-    }\n-\n-    do vec::flat_map(in_items) |item| {\n-        if item.attrs.any(is_auto_serialize) {\n-            match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n-                    let ser_impl = mk_rec_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*fields),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                ast::item_struct(@{ fields, _}, tps) => {\n-                    let ser_impl = mk_struct_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        fields,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                ast::item_enum(ref enum_def, tps) => {\n-                    let ser_impl = mk_enum_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*enum_def),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n-                _ => {\n-                    cx.span_err(span, ~\"#[auto_serialize] can only be \\\n-                                        applied to structs, record types, \\\n-                                        and enum definitions\");\n-                    ~[*item]\n-                }\n-            }\n-        } else {\n-            ~[*item]\n-        }\n-    }\n-}\n-\n-fn expand_auto_deserialize(\n-    cx: ext_ctxt,\n-    span: span,\n-    _mitem: ast::meta_item,\n-    in_items: ~[@ast::item]\n-) -> ~[@ast::item] {\n-    fn is_auto_deserialize(a: &ast::attribute) -> bool {\n-        attr::get_attr_name(*a) == ~\"auto_deserialize\"\n-    }\n-\n-    fn filter_attrs(item: @ast::item) -> @ast::item {\n-        @{attrs: vec::filter(item.attrs, |a| !is_auto_deserialize(a)),\n-          .. *item}\n-    }\n-\n-    do vec::flat_map(in_items) |item| {\n-        if item.attrs.any(is_auto_deserialize) {\n-            match item.node {\n-                ast::item_ty(@{node: ast::ty_rec(ref fields), _}, tps) => {\n-                    let deser_impl = mk_rec_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*fields),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                ast::item_struct(@{ fields, _}, tps) => {\n-                    let deser_impl = mk_struct_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        fields,\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                ast::item_enum(ref enum_def, tps) => {\n-                    let deser_impl = mk_enum_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*enum_def),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n-                _ => {\n-                    cx.span_err(span, ~\"#[auto_deserialize] can only be \\\n-                                        applied to structs, record types, \\\n-                                        and enum definitions\");\n-                    ~[*item]\n-                }\n-            }\n-        } else {\n-            ~[*item]\n-        }\n-    }\n-}\n-\n-fn mk_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    ty_param: ast::ty_param,\n-    path: @ast::path,\n-    tps: ~[ast::ty_param],\n-    f: fn(@ast::Ty) -> @ast::method\n-) -> @ast::item {\n-    // All the type parameters need to bound to the trait.\n-    let mut trait_tps = vec::append(\n-        ~[ty_param],\n-         do tps.map |tp| {\n-            let t_bound = ast::ty_param_bound(@{\n-                id: cx.next_id(),\n-                node: ast::ty_path(path, cx.next_id()),\n-                span: span,\n-            });\n-\n-            {\n-                ident: tp.ident,\n-                id: cx.next_id(),\n-                bounds: @vec::append(~[t_bound], *tp.bounds)\n-            }\n-        }\n-    );\n-\n-    let opt_trait = Some(@{\n-        path: path,\n-        ref_id: cx.next_id(),\n-    });\n-\n-    let ty = cx.ty_path(\n-        span,\n-        ~[ident],\n-        tps.map(|tp| cx.ty_path(span, ~[tp.ident], ~[]))\n-    );\n-\n-    @{\n-        // This is a new-style impl declaration.\n-        // XXX: clownshoes\n-        ident: ast::token::special_idents::clownshoes_extensions,\n-        attrs: ~[],\n-        id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n-        vis: ast::public,\n-        span: span,\n-    }\n-}\n-\n-fn mk_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    tps: ~[ast::ty_param],\n-    body: @ast::expr\n-) -> @ast::item {\n-    // Make a path to the std::serialization::Serializable typaram.\n-    let ty_param = cx.bind_path(\n-        span,\n-        cx.ident_of(~\"__S\"),\n-        cx.path(\n-            span,\n-            ~[\n-                cx.ident_of(~\"std\"),\n-                cx.ident_of(~\"serialization\"),\n-                cx.ident_of(~\"Serializer\"),\n-            ]\n-        ),\n-        @~[]\n-    );\n-\n-    // Make a path to the std::serialization::Serializable trait.\n-    let path = cx.path_tps(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization\"),\n-            cx.ident_of(~\"Serializable\"),\n-        ],\n-        ~[cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[])]\n-    );\n-\n-    mk_impl(\n-        cx,\n-        span,\n-        ident,\n-        ty_param,\n-        path,\n-        tps,\n-        |_ty| mk_ser_method(cx, span, cx.expr_blk(body))\n-    )\n-}\n-\n-fn mk_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    tps: ~[ast::ty_param],\n-    body: @ast::expr\n-) -> @ast::item {\n-    // Make a path to the std::serialization::Deserializable typaram.\n-    let ty_param = cx.bind_path(\n-        span,\n-        cx.ident_of(~\"__D\"),\n-        cx.path(\n-            span,\n-            ~[\n-                cx.ident_of(~\"std\"),\n-                cx.ident_of(~\"serialization\"),\n-                cx.ident_of(~\"Deserializer\"),\n-            ]\n-        ),\n-        @~[]\n-    );\n-\n-    // Make a path to the std::serialization::Deserializable trait.\n-    let path = cx.path_tps(\n-        span,\n-        ~[\n-            cx.ident_of(~\"std\"),\n-            cx.ident_of(~\"serialization\"),\n-            cx.ident_of(~\"Deserializable\"),\n-        ],\n-        ~[cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[])]\n-    );\n-\n-    mk_impl(\n-        cx,\n-        span,\n-        ident,\n-        ty_param,\n-        path,\n-        tps,\n-        |ty| mk_deser_method(cx, span, ty, cx.expr_blk(body))\n-    )\n-}\n-\n-fn mk_ser_method(\n-    cx: ext_ctxt,\n-    span: span,\n-    ser_body: ast::blk\n-) -> @ast::method {\n-    let ty_s = @{\n-        id: cx.next_id(),\n-        node: ast::ty_rptr(\n-            @{\n-                id: cx.next_id(),\n-                node: ast::re_anon,\n-            },\n-            {\n-                ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n-                mutbl: ast::m_imm\n-            }\n-        ),\n-        span: span,\n-    };\n-\n-    let ser_inputs = ~[{\n-        mode: ast::infer(cx.next_id()),\n-        ty: ty_s,\n-        pat: @{id: cx.next_id(),\n-               node: ast::pat_ident(\n-                    ast::bind_by_value,\n-                    ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n-                    None),\n-               span: span},\n-        id: cx.next_id(),\n-    }];\n-\n-    let ser_output = @{\n-        id: cx.next_id(),\n-        node: ast::ty_nil,\n-        span: span,\n-    };\n-\n-    let ser_decl = {\n-        inputs: ser_inputs,\n-        output: ser_output,\n-        cf: ast::return_val,\n-    };\n-\n-    @{\n-        ident: cx.ident_of(~\"serialize\"),\n-        attrs: ~[],\n-        tps: ~[],\n-        self_ty: { node: ast::sty_region(ast::m_imm), span: span },\n-        purity: ast::impure_fn,\n-        decl: ser_decl,\n-        body: ser_body,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: ast::public,\n-    }\n-}\n-\n-fn mk_deser_method(\n-    cx: ext_ctxt,\n-    span: span,\n-    ty: @ast::Ty,\n-    deser_body: ast::blk\n-) -> @ast::method {\n-    let ty_d = @{\n-        id: cx.next_id(),\n-        node: ast::ty_rptr(\n-            @{\n-                id: cx.next_id(),\n-                node: ast::re_anon,\n-            },\n-            {\n-                ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n-                mutbl: ast::m_imm\n-            }\n-        ),\n-        span: span,\n-    };\n-\n-    let deser_inputs = ~[{\n-        mode: ast::infer(cx.next_id()),\n-        ty: ty_d,\n-        pat: @{id: cx.next_id(),\n-               node: ast::pat_ident(\n-                    ast::bind_by_value,\n-                    ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n-                    None),\n-               span: span},\n-        id: cx.next_id(),\n-    }];\n-\n-    let deser_decl = {\n-        inputs: deser_inputs,\n-        output: ty,\n-        cf: ast::return_val,\n-    };\n-\n-    @{\n-        ident: cx.ident_of(~\"deserialize\"),\n-        attrs: ~[],\n-        tps: ~[],\n-        self_ty: { node: ast::sty_static, span: span },\n-        purity: ast::impure_fn,\n-        decl: deser_decl,\n-        body: deser_body,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: ast::public,\n-    }\n-}\n-\n-fn mk_rec_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[ast::ty_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `__s.emit_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_rec\")\n-        ),\n-        ~[cx.lambda_stmts(span, fields)]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_rec_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[ast::ty_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `read_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_rec\")\n-        ),\n-        ~[\n-            cx.lambda_expr(\n-                cx.expr(\n-                    span,\n-                    ast::expr_rec(fields, None)\n-                )\n-            )\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_struct_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n-\n-    // ast for `__s.emit_struct($(name), || $(fields))`\n-    let ser_body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_struct\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lambda_stmts(span, fields),\n-        ]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, ser_body)\n-}\n-\n-fn mk_struct_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n-\n-    // ast for `read_struct($(name), || $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_struct\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(ident)),\n-            cx.lambda_expr(\n-                cx.expr(\n-                    span,\n-                    ast::expr_struct(\n-                        cx.path(span, ~[ident]),\n-                        fields,\n-                        None\n-                    )\n-                )\n-            ),\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n-\n-// Records and structs don't have the same fields types, but they share enough\n-// that if we extract the right subfields out we can share the serialization\n-// generator code.\n-type field = { span: span, ident: ast::ident, mutbl: ast::mutability };\n-\n-fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n-    do fields.map |field| {\n-        {\n-            span: field.span,\n-            ident: field.node.ident,\n-            mutbl: field.node.mt.mutbl,\n-        }\n-    }\n-}\n-\n-fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n-    do fields.map |field| {\n-        let (ident, mutbl) = match field.node.kind {\n-            ast::named_field(ident, mutbl, _) => (ident, mutbl),\n-            _ => fail ~\"[auto_serialize] does not support \\\n-                        unnamed fields\",\n-        };\n-\n-        {\n-            span: field.span,\n-            ident: ident,\n-            mutbl: match mutbl {\n-                ast::struct_mutable => ast::m_mutbl,\n-                ast::struct_immutable => ast::m_imm,\n-            },\n-        }\n-    }\n-}\n-\n-fn mk_ser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[field]\n-) -> ~[@ast::stmt] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| self.$(name).serialize(__s)`\n-        let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_field(\n-                        span,\n-                        cx.expr_var(span, ~\"self\"),\n-                        field.ident\n-                    ),\n-                    cx.ident_of(~\"serialize\")\n-                ),\n-                ~[cx.expr_var(span, ~\"__s\")]\n-            )\n-        );\n-\n-        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_field\")\n-                ),\n-                ~[\n-                    cx.lit_str(span, @cx.str_of(field.ident)),\n-                    cx.lit_uint(span, idx),\n-                    expr_lambda,\n-                ]\n-            )\n-        )\n-    }\n-}\n-\n-fn mk_deser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[{ span: span, ident: ast::ident, mutbl: ast::mutability }]\n-) -> ~[ast::field] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| std::serialization::deserialize(__d)`\n-        let expr_lambda = cx.lambda(\n-            cx.expr_blk(\n-                cx.expr_call(\n-                    span,\n-                    cx.expr_path(span, ~[\n-                        cx.ident_of(~\"std\"),\n-                        cx.ident_of(~\"serialization\"),\n-                        cx.ident_of(~\"deserialize\"),\n-                    ]),\n-                    ~[cx.expr_var(span, ~\"__d\")]\n-                )\n-            )\n-        );\n-\n-        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_field\")\n-            ),\n-            ~[\n-                cx.lit_str(span, @cx.str_of(field.ident)),\n-                cx.lit_uint(span, idx),\n-                expr_lambda,\n-            ]\n-        );\n-\n-        {\n-            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n-            span: span,\n-        }\n-    }\n-}\n-\n-fn mk_enum_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let body = mk_enum_ser_body(\n-        cx,\n-        span,\n-        ident,\n-        enum_def.variants\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_enum_deser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    enum_def: ast::enum_def,\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let body = mk_enum_deser_body(\n-        cx,\n-        span,\n-        ident,\n-        enum_def.variants\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn ser_variant(\n-    cx: ext_ctxt,\n-    span: span,\n-    v_name: ast::ident,\n-    v_idx: uint,\n-    args: ~[ast::variant_arg]\n-) -> ast::arm {\n-    // Name the variant arguments.\n-    let names = args.mapi(|i, _arg| cx.ident_of(fmt!(\"__v%u\", i)));\n-\n-    // Bind the names to the variant argument type.\n-    let pats = args.mapi(|i, arg| cx.binder_pat(arg.ty.span, names[i]));\n-\n-    let pat_node = if pats.is_empty() {\n-        ast::pat_ident(\n-            ast::bind_by_ref(ast::m_imm),\n-            cx.path(span, ~[v_name]),\n-            None\n-        )\n-    } else {\n-        ast::pat_enum(\n-            cx.path(span, ~[v_name]),\n-            Some(pats)\n-        )\n-    };\n-\n-    let pat = @{\n-        id: cx.next_id(),\n-        node: pat_node,\n-        span: span,\n-    };\n-\n-    let stmts = do args.mapi |a_idx, _arg| {\n-        // ast for `__s.emit_enum_variant_arg`\n-        let expr_emit = cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant_arg\")\n-        );\n-\n-        // ast for `|| $(v).serialize(__s)`\n-        let expr_serialize = cx.lambda_expr(\n-             cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_path(span, ~[names[a_idx]]),\n-                    cx.ident_of(~\"serialize\")\n-                ),\n-                ~[cx.expr_var(span, ~\"__s\")]\n-            )\n-        );\n-\n-        // ast for `$(expr_emit)($(a_idx), $(expr_serialize))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                expr_emit,\n-                ~[cx.lit_uint(span, a_idx), expr_serialize]\n-            )\n-        )\n-    };\n-\n-    // ast for `__s.emit_enum_variant($(name), $(idx), $(sz), $(lambda))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum_variant\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(v_name)),\n-            cx.lit_uint(span, v_idx),\n-            cx.lit_uint(span, stmts.len()),\n-            cx.lambda_stmts(span, stmts),\n-        ]\n-    );\n-\n-    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n-}\n-\n-fn mk_enum_ser_body(\n-    cx: ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    variants: ~[ast::variant]\n-) -> @ast::expr {\n-    let arms = do variants.mapi |v_idx, variant| {\n-        match variant.node.kind {\n-            ast::tuple_variant_kind(args) =>\n-                ser_variant(cx, span, variant.node.name, v_idx, args),\n-            ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\",\n-            ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\",\n-        }\n-    };\n-\n-    // ast for `match *self { $(arms) }`\n-    let match_expr = cx.expr(\n-        span,\n-        ast::expr_match(\n-            cx.expr(\n-                span,\n-                ast::expr_unary(ast::deref, cx.expr_var(span, ~\"self\"))\n-            ),\n-            arms\n-        )\n-    );\n-\n-    // ast for `__s.emit_enum($(name), || $(match_expr))`\n-    cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_enum\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(name)),\n-            cx.lambda_expr(match_expr),\n-        ]\n-    )\n-}\n-\n-fn mk_enum_deser_variant_nary(\n-    cx: ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    args: ~[ast::variant_arg]\n-) -> @ast::expr {\n-    let args = do args.mapi |idx, _arg| {\n-        // ast for `|| std::serialization::deserialize(__d)`\n-        let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n-                span,\n-                cx.expr_path(span, ~[\n-                    cx.ident_of(~\"std\"),\n-                    cx.ident_of(~\"serialization\"),\n-                    cx.ident_of(~\"deserialize\"),\n-                ]),\n-                ~[cx.expr_var(span, ~\"__d\")]\n-            )\n-        );\n-\n-        // ast for `__d.read_enum_variant_arg($(a_idx), $(expr_lambda))`\n-        cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant_arg\")\n-            ),\n-            ~[cx.lit_uint(span, idx), expr_lambda]\n-        )\n-    };\n-\n-    // ast for `$(name)($(args))`\n-    cx.expr_call(span, cx.expr_path(span, ~[name]), args)\n-}\n-\n-fn mk_enum_deser_body(\n-    cx: ext_ctxt,\n-    span: span,\n-    name: ast::ident,\n-    variants: ~[ast::variant]\n-) -> @ast::expr {\n-    let mut arms = do variants.mapi |v_idx, variant| {\n-        let body = match variant.node.kind {\n-            ast::tuple_variant_kind(args) => {\n-                if args.is_empty() {\n-                    // for a nullary variant v, do \"v\"\n-                    cx.expr_path(span, ~[variant.node.name])\n-                } else {\n-                    // for an n-ary variant v, do \"v(a_1, ..., a_n)\"\n-                    mk_enum_deser_variant_nary(\n-                        cx,\n-                        span,\n-                        variant.node.name,\n-                        args\n-                    )\n-                }\n-            },\n-            ast::struct_variant_kind(*) =>\n-                fail ~\"struct variants unimplemented\",\n-            ast::enum_variant_kind(*) =>\n-                fail ~\"enum variants unimplemented\",\n-        };\n-\n-        let pat = @{\n-            id: cx.next_id(),\n-            node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n-            span: span,\n-        };\n-\n-        {\n-            pats: ~[pat],\n-            guard: None,\n-            body: cx.expr_blk(body),\n-        }\n-    };\n-\n-    let impossible_case = {\n-        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n-        guard: None,\n-\n-        // FIXME(#3198): proper error message\n-        body: cx.expr_blk(cx.expr(span, ast::expr_fail(None))),\n-    };\n-\n-    arms.push(impossible_case);\n-\n-    // ast for `|i| { match i { $(arms) } }`\n-    let expr_lambda = cx.expr(\n-        span,\n-        ast::expr_fn_block(\n-            {\n-                inputs: ~[{\n-                    mode: ast::infer(cx.next_id()),\n-                    ty: @{\n-                        id: cx.next_id(),\n-                        node: ast::ty_infer,\n-                        span: span\n-                    },\n-                    pat: @{id: cx.next_id(),\n-                           node: ast::pat_ident(\n-                                ast::bind_by_value,\n-                                ast_util::ident_to_path(span,\n-                                                        cx.ident_of(~\"i\")),\n-                                None),\n-                           span: span},\n-                    id: cx.next_id(),\n-                }],\n-                output: @{\n-                    id: cx.next_id(),\n-                    node: ast::ty_infer,\n-                    span: span,\n-                },\n-                cf: ast::return_val,\n-            },\n-            cx.expr_blk(\n-                cx.expr(\n-                    span,\n-                    ast::expr_match(cx.expr_var(span, ~\"i\"), arms)\n-                )\n-            ),\n-            @~[]\n-        )\n-    );\n-\n-    // ast for `__d.read_enum_variant($(expr_lambda))`\n-    let expr_lambda = cx.lambda_expr(\n-        cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_enum_variant\")\n-            ),\n-            ~[expr_lambda]\n-        )\n-    );\n-\n-    // ast for `__d.read_enum($(e_name), $(expr_lambda))`\n-    cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_enum\")\n-        ),\n-        ~[\n-            cx.lit_str(span, @cx.str_of(name)),\n-            expr_lambda\n-        ]\n-    )\n-}"}, {"sha": "cf994e0ea52240ebf5485904d0814ad789e383db", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "patch": "@@ -73,12 +73,6 @@ fn syntax_expander_table() -> HashMap<~str, syntax_extension> {\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(~\"fmt\",\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(\n-        ~\"auto_serialize\",\n-        item_decorator(ext::auto_serialize::expand_auto_serialize));\n-    syntax_expanders.insert(\n-        ~\"auto_deserialize\",\n-        item_decorator(ext::auto_serialize::expand_auto_deserialize));\n     syntax_expanders.insert(\n         ~\"auto_encode\",\n         item_decorator(ext::auto_encode::expand_auto_encode));"}, {"sha": "522e46422d62ca64024baa6bd9a6addb9f7c7061", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9c673b246c69d1cdcffbaf0e5cf012941b0b78e2/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=9c673b246c69d1cdcffbaf0e5cf012941b0b78e2", "patch": "@@ -105,8 +105,6 @@ mod ext {\n     #[legacy_exports]\n     mod auto_encode;\n     #[legacy_exports]\n-    mod auto_serialize;\n-    #[legacy_exports]\n     mod source_util;\n \n     #[legacy_exports]"}]}