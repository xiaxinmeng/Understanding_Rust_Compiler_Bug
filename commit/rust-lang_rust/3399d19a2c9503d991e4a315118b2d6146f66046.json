{"sha": "3399d19a2c9503d991e4a315118b2d6146f66046", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOTlkMTlhMmM5NTAzZDk5MWU0YTMxNTExOGIyZDYxNDZmNjYwNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-31T16:09:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-31T16:09:34Z"}, "message": "Auto merge of #31938 - jseyfried:autoderef_privacy, r=nikomatsakis\n\nIntegrate privacy into field and method selection\n\nThis PR integrates privacy checking into field and method selection so that an inaccessible field/method can not stop an accessible field/method from being used (fixes #12808 and fixes #22684).\nr? @eddyb", "tree": {"sha": "27689b22c55f114be2220b940d53c3b6771e24d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27689b22c55f114be2220b940d53c3b6771e24d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3399d19a2c9503d991e4a315118b2d6146f66046", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3399d19a2c9503d991e4a315118b2d6146f66046", "html_url": "https://github.com/rust-lang/rust/commit/3399d19a2c9503d991e4a315118b2d6146f66046", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3399d19a2c9503d991e4a315118b2d6146f66046/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4583dc9b13f8a46b10bcc8eb4483080b9736cdd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4583dc9b13f8a46b10bcc8eb4483080b9736cdd2", "html_url": "https://github.com/rust-lang/rust/commit/4583dc9b13f8a46b10bcc8eb4483080b9736cdd2"}, {"sha": "48c20b0e73b083090c6dcf65ecd460eb073cc0b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/48c20b0e73b083090c6dcf65ecd460eb073cc0b4", "html_url": "https://github.com/rust-lang/rust/commit/48c20b0e73b083090c6dcf65ecd460eb073cc0b4"}], "stats": {"total": 754, "additions": 236, "deletions": 518}, "files": [{"sha": "3605de44495b1e1de9dc9538e87c509d9f772df7", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -581,14 +581,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn get_foreign_vis(&self, id: NodeId) -> Visibility {\n-        let vis = self.expect_foreign_item(id).vis; // read recorded by `expect_foreign_item`\n-        match self.find(self.get_parent(id)) { // read recorded by `find`\n-            Some(NodeItem(i)) => vis.inherit_from(i.vis),\n-            _ => vis\n-        }\n-    }\n-\n     pub fn expect_item(&self, id: NodeId) -> &'ast Item {\n         match self.find(id) { // read recorded by `find`\n             Some(NodeItem(item)) => item,"}, {"sha": "d4b309fb039c1a256087fc57c81d6f27ef30dc1c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 28, "deletions": 438, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -27,9 +27,6 @@\n extern crate rustc;\n extern crate rustc_front;\n \n-use self::PrivacyResult::*;\n-use self::FieldName::*;\n-\n use std::cmp;\n use std::mem::replace;\n \n@@ -43,7 +40,7 @@ use rustc::middle::def::{self, Def};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{NodeMap, NodeSet};\n+use rustc::util::nodemap::NodeSet;\n use rustc::front::map as ast_map;\n \n use syntax::ast;\n@@ -58,98 +55,6 @@ type Context<'a, 'tcx> = (&'a ty::MethodMap<'tcx>, &'a def::ExportMap);\n /// optionally the same for a note about the error.\n type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n \n-////////////////////////////////////////////////////////////////////////////////\n-/// The parent visitor, used to determine what's the parent of what (node-wise)\n-////////////////////////////////////////////////////////////////////////////////\n-\n-struct ParentVisitor<'a, 'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n-    parents: NodeMap<ast::NodeId>,\n-    curparent: ast::NodeId,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for ParentVisitor<'a, 'tcx> {\n-    /// We want to visit items in the context of their containing\n-    /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n-    }\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        self.parents.insert(item.id, self.curparent);\n-\n-        let prev = self.curparent;\n-        match item.node {\n-            hir::ItemMod(..) => { self.curparent = item.id; }\n-            // Enum variants are parented to the enum definition itself because\n-            // they inherit privacy\n-            hir::ItemEnum(ref def, _) => {\n-                for variant in &def.variants {\n-                    // The parent is considered the enclosing enum because the\n-                    // enum will dictate the privacy visibility of this variant\n-                    // instead.\n-                    self.parents.insert(variant.node.data.id(), item.id);\n-                }\n-            }\n-\n-            // Trait methods are always considered \"public\", but if the trait is\n-            // private then we need some private item in the chain from the\n-            // method to the root. In this case, if the trait is private, then\n-            // parent all the methods to the trait to indicate that they're\n-            // private.\n-            hir::ItemTrait(_, _, _, ref trait_items) if item.vis != hir::Public => {\n-                for trait_item in trait_items {\n-                    self.parents.insert(trait_item.id, item.id);\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-        intravisit::walk_item(self, item);\n-        self.curparent = prev;\n-    }\n-\n-    fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n-        self.parents.insert(a.id, self.curparent);\n-        intravisit::walk_foreign_item(self, a);\n-    }\n-\n-    fn visit_fn(&mut self, a: intravisit::FnKind<'v>, b: &'v hir::FnDecl,\n-                c: &'v hir::Block, d: Span, id: ast::NodeId) {\n-        // We already took care of some trait methods above, otherwise things\n-        // like impl methods and pub trait methods are parented to the\n-        // containing module, not the containing trait.\n-        if !self.parents.contains_key(&id) {\n-            self.parents.insert(id, self.curparent);\n-        }\n-        intravisit::walk_fn(self, a, b, c, d);\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n-        // visit_fn handles methods, but associated consts have to be handled\n-        // here.\n-        if !self.parents.contains_key(&ii.id) {\n-            self.parents.insert(ii.id, self.curparent);\n-        }\n-        intravisit::walk_impl_item(self, ii);\n-    }\n-\n-    fn visit_variant_data(&mut self, s: &hir::VariantData, _: ast::Name,\n-                        _: &'v hir::Generics, item_id: ast::NodeId, _: Span) {\n-        // Struct constructors are parented to their struct definitions because\n-        // they essentially are the struct definitions.\n-        if !s.is_struct() {\n-            self.parents.insert(s.id(), item_id);\n-        }\n-\n-        // While we have the id of the struct definition, go ahead and parent\n-        // all the fields.\n-        for field in s.fields() {\n-            self.parents.insert(field.id, self.curparent);\n-        }\n-        intravisit::walk_struct_def(self, s)\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n@@ -475,331 +380,45 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n-    parents: NodeMap<ast::NodeId>,\n-}\n-\n-#[derive(Debug)]\n-enum PrivacyResult {\n-    Allowable,\n-    ExternallyDenied,\n-    DisallowedBy(ast::NodeId),\n-}\n-\n-enum FieldName {\n-    UnnamedField(usize), // index\n-    NamedField(ast::Name),\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    // Determines whether the given definition is public from the point of view\n-    // of the current item.\n-    fn def_privacy(&self, did: DefId) -> PrivacyResult {\n-        let node_id = if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            node_id\n-        } else {\n-            if self.tcx.sess.cstore.visibility(did) == hir::Public {\n-                debug!(\"privacy - {:?} was externally exported\", did);\n-                return Allowable;\n-            }\n-            debug!(\"privacy - is {:?} a public method\", did);\n-\n-            return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n-                Some(&ty::ConstTraitItem(ref ac)) => {\n-                    debug!(\"privacy - it's a const: {:?}\", *ac);\n-                    match ac.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match self.tcx.impl_trait_ref(id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found inherent \\\n-                                            associated constant {:?}\",\n-                                            ac.vis);\n-                                    if ac.vis == hir::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                Some(&ty::MethodTraitItem(ref meth)) => {\n-                    debug!(\"privacy - well at least it's a method: {:?}\",\n-                           *meth);\n-                    match meth.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match self.tcx.impl_trait_ref(id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found a method {:?}\",\n-                                            meth.vis);\n-                                    if meth.vis == hir::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                Some(&ty::TypeTraitItem(ref typedef)) => {\n-                    match typedef.container {\n-                        ty::TraitContainer(id) => {\n-                            debug!(\"privacy - recursing on trait {:?}\", id);\n-                            self.def_privacy(id)\n-                        }\n-                        ty::ImplContainer(id) => {\n-                            match self.tcx.impl_trait_ref(id) {\n-                                Some(t) => {\n-                                    debug!(\"privacy - impl of trait {:?}\", id);\n-                                    self.def_privacy(t.def_id)\n-                                }\n-                                None => {\n-                                    debug!(\"privacy - found a typedef {:?}\",\n-                                            typedef.vis);\n-                                    if typedef.vis == hir::Public {\n-                                        Allowable\n-                                    } else {\n-                                        ExternallyDenied\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                None => {\n-                    debug!(\"privacy - nope, not even a method\");\n-                    ExternallyDenied\n-                }\n-            };\n+    fn item_is_visible(&self, did: DefId) -> bool {\n+        let visibility = match self.tcx.map.as_local_node_id(did) {\n+            Some(node_id) => self.tcx.map.expect_item(node_id).vis,\n+            None => self.tcx.sess.cstore.visibility(did),\n         };\n-\n-        debug!(\"privacy - local {} not public all the way down\",\n-               self.tcx.map.node_to_string(node_id));\n-        // return quickly for things in the same module\n-        if self.parents.get(&node_id) == self.parents.get(&self.curitem) {\n-            debug!(\"privacy - same parent, we're done here\");\n-            return Allowable;\n-        }\n-\n-        let vis = match self.tcx.map.find(node_id) {\n-            // If this item is a method, then we know for sure that it's an\n-            // actual method and not a static method. The reason for this is\n-            // that these cases are only hit in the ExprMethodCall\n-            // expression, and ExprCall will have its path checked later\n-            // (the path of the trait/impl) if it's a static method.\n-            //\n-            // With this information, then we can completely ignore all\n-            // trait methods. The privacy violation would be if the trait\n-            // couldn't get imported, not if the method couldn't be used\n-            // (all trait methods are public).\n-            //\n-            // However, if this is an impl method, then we dictate this\n-            // decision solely based on the privacy of the method\n-            // invocation.\n-            Some(ast_map::NodeImplItem(ii)) => {\n-                let imp = self.tcx.map.get_parent_did(node_id);\n-                match self.tcx.impl_trait_ref(imp) {\n-                    Some(..) => hir::Public,\n-                    _ => ii.vis,\n-                }\n-            }\n-            Some(ast_map::NodeTraitItem(_)) => hir::Public,\n-\n-            // This is not a method call, extract the visibility as one\n-            // would normally look at it\n-            Some(ast_map::NodeItem(it)) => it.vis,\n-            Some(ast_map::NodeForeignItem(_)) => {\n-                self.tcx.map.get_foreign_vis(node_id)\n-            }\n-            _ => hir::Public,\n-        };\n-        if vis == hir::Public { return Allowable }\n-\n-        if self.private_accessible(node_id) {\n-            Allowable\n-        } else {\n-            DisallowedBy(node_id)\n-        }\n+        visibility == hir::Public || self.private_accessible(did)\n     }\n \n-    /// True if `id` is both local and private-accessible\n-    fn local_private_accessible(&self, did: DefId) -> bool {\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            self.private_accessible(node_id)\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// For a local private node in the AST, this function will determine\n-    /// whether the node is accessible by the current module that iteration is\n-    /// inside.\n-    fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        self.tcx.map.private_item_is_visible_from(id, self.curitem)\n-    }\n-\n-    fn report_error(&self, result: CheckResult) -> bool {\n-        match result {\n-            None => true,\n-            Some((span, msg, note)) => {\n-                let mut err = self.tcx.sess.struct_span_err(span, &msg[..]);\n-                if let Some((span, msg)) = note {\n-                    err.span_note(span, &msg[..]);\n-                }\n-                err.emit();\n-                false\n-            },\n+    /// True if `did` is private-accessible\n+    fn private_accessible(&self, did: DefId) -> bool {\n+        match self.tcx.map.as_local_node_id(did) {\n+            Some(node_id) => self.tcx.map.private_item_is_visible_from(node_id, self.curitem),\n+            None => false,\n         }\n     }\n \n-    /// Guarantee that a particular definition is public. Returns a CheckResult\n-    /// which contains any errors found. These can be reported using `report_error`.\n-    /// If the result is `None`, no errors were found.\n-    fn ensure_public(&self,\n-                     span: Span,\n-                     to_check: DefId,\n-                     source_did: Option<DefId>,\n-                     msg: &str)\n-                     -> CheckResult {\n-        debug!(\"ensure_public(span={:?}, to_check={:?}, source_did={:?}, msg={:?})\",\n-               span, to_check, source_did, msg);\n-        let def_privacy = self.def_privacy(to_check);\n-        debug!(\"ensure_public: def_privacy={:?}\", def_privacy);\n-        let id = match def_privacy {\n-            ExternallyDenied => {\n-                return Some((span, format!(\"{} is private\", msg), None))\n-            }\n-            Allowable => return None,\n-            DisallowedBy(id) => id,\n-        };\n-\n-        // If we're disallowed by a particular id, then we attempt to\n-        // give a nice error message to say why it was disallowed. It\n-        // was either because the item itself is private or because\n-        // its parent is private and its parent isn't in our\n-        // ancestry. (Both the item being checked and its parent must\n-        // be local.)\n-        let def_id = source_did.unwrap_or(to_check);\n-        let node_id = self.tcx.map.as_local_node_id(def_id);\n-\n-        let (err_span, err_msg) = if Some(id) == node_id {\n-            return Some((span, format!(\"{} is private\", msg), None));\n-        } else {\n-            (span, format!(\"{} is inaccessible\", msg))\n-        };\n-        let item = match self.tcx.map.find(id) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    // If an impl disallowed this item, then this is resolve's\n-                    // way of saying that a struct/enum's static method was\n-                    // invoked, and the struct/enum itself is private. Crawl\n-                    // back up the chains to find the relevant struct/enum that\n-                    // was private.\n-                    hir::ItemImpl(_, _, _, _, ref ty, _) => {\n-                        match ty.node {\n-                            hir::TyPath(..) => {}\n-                            _ => return Some((err_span, err_msg, None)),\n-                        };\n-                        let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n-                        let did = def.def_id();\n-                        let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n-                        match self.tcx.map.get(node_id) {\n-                            ast_map::NodeItem(item) => item,\n-                            _ => self.tcx.sess.span_bug(item.span,\n-                                                        \"path is not an item\")\n-                        }\n-                    }\n-                    _ => item\n-                }\n-            }\n-            Some(..) | None => return Some((err_span, err_msg, None)),\n-        };\n-        let desc = match item.node {\n-            hir::ItemMod(..) => \"module\",\n-            hir::ItemTrait(..) => \"trait\",\n-            hir::ItemStruct(..) => \"struct\",\n-            hir::ItemEnum(..) => \"enum\",\n-            _ => return Some((err_span, err_msg, None))\n-        };\n-        let msg = format!(\"{} `{}` is private\", desc, item.name);\n-        Some((err_span, err_msg, Some((span, msg))))\n-    }\n-\n     // Checks that a field is in scope.\n-    fn check_field(&mut self,\n-                   span: Span,\n-                   def: ty::AdtDef<'tcx>,\n-                   v: ty::VariantDef<'tcx>,\n-                   name: FieldName) {\n-        let field = match name {\n-            NamedField(f_name) => {\n-                debug!(\"privacy - check named field {} in struct {:?}\", f_name, def);\n-                v.field_named(f_name)\n-            }\n-            UnnamedField(idx) => &v.fields[idx]\n-        };\n-        if field.vis == hir::Public || self.local_private_accessible(def.did) {\n-            return;\n+    fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n+        if def.adt_kind() == ty::AdtKind::Struct &&\n+                field.vis != hir::Public && !self.private_accessible(def.did) {\n+            span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n+                      field.name, self.tcx.item_path_str(def.did));\n         }\n-\n-        let struct_desc = match def.adt_kind() {\n-            ty::AdtKind::Struct =>\n-                format!(\"struct `{}`\", self.tcx.item_path_str(def.did)),\n-            // struct variant fields have inherited visibility\n-            ty::AdtKind::Enum => return\n-        };\n-        let msg = match name {\n-            NamedField(name) => format!(\"field `{}` of {} is private\",\n-                                        name, struct_desc),\n-            UnnamedField(idx) => format!(\"field #{} of {} is private\",\n-                                         idx, struct_desc),\n-        };\n-        span_err!(self.tcx.sess, span, E0451,\n-                  \"{}\", &msg[..]);\n-    }\n-\n-    // Given the ID of a method, checks to ensure it's in scope.\n-    fn check_static_method(&mut self,\n-                           span: Span,\n-                           method_id: DefId,\n-                           name: ast::Name) {\n-        self.report_error(self.ensure_public(span,\n-                                             method_id,\n-                                             None,\n-                                             &format!(\"method `{}`\",\n-                                                     name)));\n     }\n \n     // Checks that a method is in scope.\n-    fn check_method(&mut self, span: Span, method_def_id: DefId,\n-                    name: ast::Name) {\n+    fn check_method(&mut self, span: Span, method_def_id: DefId) {\n         match self.tcx.impl_or_trait_item(method_def_id).container() {\n-            ty::ImplContainer(_) => {\n-                self.check_static_method(span, method_def_id, name)\n-            }\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) => {\n-                let msg = format!(\"source trait `{}`\", self.tcx.item_path_str(trait_def_id));\n-                self.report_error(self.ensure_public(span, trait_def_id, None, &msg));\n+            ty::TraitContainer(trait_def_id) if !self.item_is_visible(trait_def_id) => {\n+                let msg = format!(\"source trait `{}` is private\",\n+                                  self.tcx.item_path_str(trait_def_id));\n+                self.tcx.sess.span_err(span, &msg);\n             }\n+            _ => {}\n         }\n     }\n }\n@@ -819,27 +438,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprField(ref base, name) => {\n-                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&base).sty {\n-                    self.check_field(expr.span,\n-                                     def,\n-                                     def.struct_variant(),\n-                                     NamedField(name.node));\n-                }\n-            }\n-            hir::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&base).sty {\n-                    self.check_field(expr.span,\n-                                     def,\n-                                     def.struct_variant(),\n-                                     UnnamedField(idx.node));\n-                }\n-            }\n-            hir::ExprMethodCall(name, _, _) => {\n+            hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 debug!(\"(privacy checking) checking impl method\");\n-                self.check_method(expr.span, method.def_id, name.node);\n+                self.check_method(expr.span, method.def_id);\n             }\n             hir::ExprStruct(..) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n@@ -848,7 +451,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 // Rather than computing the set of unmentioned fields\n                 // (i.e. `all_fields - fields`), just check them all.\n                 for field in &variant.fields {\n-                    self.check_field(expr.span, adt, variant, NamedField(field.name));\n+                    self.check_field(expr.span, adt, field);\n                 }\n             }\n             hir::ExprPath(..) => {\n@@ -862,7 +465,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.local_private_accessible(def.did)\n+                        f.vis != hir::Public && !self.private_accessible(def.did)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n@@ -890,8 +493,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n-                    self.check_field(pattern.span, adt, variant,\n-                                     NamedField(field.node.name));\n+                    self.check_field(pattern.span, adt, variant.field_named(field.node.name));\n                 }\n             }\n \n@@ -904,10 +506,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                             if let PatKind::Wild = field.node {\n                                 continue\n                             }\n-                            self.check_field(field.span,\n-                                             def,\n-                                             def.struct_variant(),\n-                                             UnnamedField(i));\n+                            self.check_field(field.span, def, &def.struct_variant().fields[i]);\n                         }\n                     }\n                     ty::TyEnum(..) => {\n@@ -1575,20 +1174,11 @@ pub fn check_crate(tcx: &TyCtxt, export_map: &def::ExportMap) -> AccessLevels {\n     let mut visitor = SanePrivacyVisitor { tcx: tcx };\n     krate.visit_all_items(&mut visitor);\n \n-    // Figure out who everyone's parent is\n-    let mut visitor = ParentVisitor {\n-        tcx: tcx,\n-        parents: NodeMap(),\n-        curparent: ast::DUMMY_NODE_ID,\n-    };\n-    intravisit::walk_crate(&mut visitor, krate);\n-\n     // Use the parent map to check the privacy of everything\n     let mut visitor = PrivacyVisitor {\n         curitem: ast::DUMMY_NODE_ID,\n         in_foreign: false,\n         tcx: tcx,\n-        parents: visitor.parents,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "8c8d02bd3e6d68eb03ae664729f0179d95b0d15c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -43,6 +43,9 @@ pub enum MethodError<'tcx> {\n \n     // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n     ClosureAmbiguity(/* DefId of fn trait */ DefId),\n+\n+    // Found an applicable method, but it is not visible.\n+    PrivateMatch(Def),\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -90,6 +93,7 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Err(NoMatch(..)) => false,\n         Err(Ambiguity(..)) => true,\n         Err(ClosureAmbiguity(..)) => true,\n+        Err(PrivateMatch(..)) => true,\n     }\n }\n "}, {"sha": "477b46ce4cef4f41c334708b7b18e22ed389add6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -16,6 +16,7 @@ use super::suggest;\n use check;\n use check::{FnCtxt, UnresolvedTypeAction};\n use middle::def_id::DefId;\n+use middle::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n@@ -47,6 +48,9 @@ struct ProbeContext<'a, 'tcx:'a> {\n     /// used for error reporting\n     static_candidates: Vec<CandidateSource>,\n \n+    /// Some(candidate) if there is a private candidate\n+    private_candidate: Option<Def>,\n+\n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n     unsatisfied_predicates: Vec<TraitRef<'tcx>>\n@@ -247,6 +251,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n+            private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n         }\n     }\n@@ -256,6 +261,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.extension_candidates.clear();\n         self.impl_dups.clear();\n         self.static_candidates.clear();\n+        self.private_candidate = None;\n     }\n \n     fn tcx(&self) -> &'a TyCtxt<'tcx> {\n@@ -407,6 +413,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n+        if item.vis() != hir::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n+            self.private_candidate = Some(item.def());\n+            return\n+        }\n+\n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n         let impl_ty = impl_ty.subst(self.tcx(), &impl_substs);\n \n@@ -846,6 +857,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n+        let private_candidate = mem::replace(&mut self.private_candidate, None);\n         let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n@@ -879,9 +891,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 // this error only occurs when assembling candidates\n                 tcx.sess.span_bug(span, \"encountered ClosureAmbiguity from pick_core\");\n             }\n-            None => vec![],\n+            _ => vec![],\n         };\n \n+        if let Some(def) = private_candidate {\n+            return Err(MethodError::PrivateMatch(def));\n+        }\n+\n         Err(MethodError::NoMatch(NoMatchData::new(static_candidates, unsatisfied_predicates,\n                                                   out_of_scope_traits, self.mode)))\n     }"}, {"sha": "f1d67883117ec0595b4baf01bc3d72c7ceae3ebb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -91,7 +91,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n                                            unsatisfied_predicates,\n                                            out_of_scope_traits,\n-                                           mode }) => {\n+                                           mode, .. }) => {\n             let cx = fcx.tcx();\n \n             let mut err = fcx.type_error_struct(\n@@ -208,6 +208,11 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             };\n             fcx.sess().span_err(span, &msg);\n         }\n+\n+        MethodError::PrivateMatch(def) => {\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n+            fcx.tcx().sess.span_err(span, &msg);\n+        }\n     }\n \n     fn report_candidates(fcx: &FnCtxt,"}, {"sha": "9ed82fbab467275c4e300e4b763cebe74aacbfe0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 67, "deletions": 47, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -2939,25 +2939,26 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             base: &'tcx hir::Expr,\n                             field: &Spanned<ast::Name>) {\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n-        let expr_t = structurally_resolved_type(fcx, expr.span,\n-                                                fcx.expr_ty(base));\n-        // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n+        let expr_t = structurally_resolved_type(fcx, expr.span, fcx.expr_ty(base));\n+        let mut private_candidate = None;\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n                                                   || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n-                match base_t.sty {\n-                    ty::TyStruct(base_def, substs) => {\n-                        debug!(\"struct named {:?}\",  base_t);\n-                        base_def.struct_variant()\n-                                .find_field_named(field.node)\n-                                .map(|f| fcx.field_ty(expr.span, f, substs))\n+                if let ty::TyStruct(base_def, substs) = base_t.sty {\n+                    debug!(\"struct named {:?}\",  base_t);\n+                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                        let field_ty = fcx.field_ty(expr.span, field, substs);\n+                        if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                            return Some(field_ty);\n+                        }\n+                        private_candidate = Some((base_def.did, field_ty));\n                     }\n-                    _ => None\n                 }\n+                None\n             });\n         match field_ty {\n             Some(field_ty) => {\n@@ -2968,12 +2969,14 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             None => {}\n         }\n \n-        if field.node == special_idents::invalid.name {\n+        if let Some((did, field_ty)) = private_candidate {\n+            let struct_path = fcx.tcx().item_path_str(did);\n+            let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n+            fcx.tcx().sess.span_err(expr.span, &msg);\n+            fcx.write_ty(expr.id, field_ty);\n+        } else if field.node == special_idents::invalid.name {\n             fcx.write_error(expr.id);\n-            return;\n-        }\n-\n-        if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n+        } else if method::exists(fcx, field.span, field.node, expr_t, expr.id) {\n             fcx.type_error_struct(field.span,\n                                   |actual| {\n                                        format!(\"attempted to take value of method `{}` on type \\\n@@ -2984,6 +2987,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                \"maybe a `()` to call it is missing? \\\n                                If not, try an anonymous function\")\n                 .emit();\n+            fcx.write_error(expr.id);\n         } else {\n             let mut err = fcx.type_error_struct(\n                 expr.span,\n@@ -2999,9 +3003,8 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n             }\n             err.emit();\n+            fcx.write_error(expr.id);\n         }\n-\n-        fcx.write_error(expr.id);\n     }\n \n     // displays hints about the closest matches in field names\n@@ -3036,36 +3039,37 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 base: &'tcx hir::Expr,\n                                 idx: codemap::Spanned<usize>) {\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n-        let expr_t = structurally_resolved_type(fcx, expr.span,\n-                                                fcx.expr_ty(base));\n+        let expr_t = structurally_resolved_type(fcx, expr.span, fcx.expr_ty(base));\n+        let mut private_candidate = None;\n         let mut tuple_like = false;\n-        // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n                                                   || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n-                match base_t.sty {\n-                    ty::TyStruct(base_def, substs) => {\n-                        tuple_like = base_def.struct_variant().is_tuple_struct();\n-                        if tuple_like {\n-                            debug!(\"tuple struct named {:?}\",  base_t);\n-                            base_def.struct_variant()\n-                                    .fields\n-                                    .get(idx.node)\n-                                    .map(|f| fcx.field_ty(expr.span, f, substs))\n-                        } else {\n-                            None\n-                        }\n-                    }\n+                let (base_def, substs) = match base_t.sty {\n+                    ty::TyStruct(base_def, substs) => (base_def, substs),\n                     ty::TyTuple(ref v) => {\n                         tuple_like = true;\n-                        if idx.node < v.len() { Some(v[idx.node]) } else { None }\n+                        return if idx.node < v.len() { Some(v[idx.node]) } else { None }\n                     }\n-                    _ => None\n+                    _ => return None,\n+                };\n+\n+                tuple_like = base_def.struct_variant().is_tuple_struct();\n+                if !tuple_like { return None }\n+\n+                debug!(\"tuple struct named {:?}\",  base_t);\n+                if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n+                    let field_ty = fcx.field_ty(expr.span, field, substs);\n+                    if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                        return Some(field_ty);\n+                    }\n+                    private_candidate = Some((base_def.did, field_ty));\n                 }\n+                None\n             });\n         match field_ty {\n             Some(field_ty) => {\n@@ -3075,6 +3079,15 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             None => {}\n         }\n+\n+        if let Some((did, field_ty)) = private_candidate {\n+            let struct_path = fcx.tcx().item_path_str(did);\n+            let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n+            fcx.tcx().sess.span_err(expr.span, &msg);\n+            fcx.write_ty(expr.id, field_ty);\n+            return;\n+        }\n+\n         fcx.type_error_message(\n             expr.span,\n             |actual| {\n@@ -3745,23 +3758,30 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                                      &ty_segments[base_ty_end..]);\n         let item_segment = path.segments.last().unwrap();\n         let item_name = item_segment.identifier.name;\n-        match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n-            Ok(def) => {\n-                // Write back the new resolution.\n-                fcx.ccx.tcx.def_map.borrow_mut()\n-                       .insert(node_id, def::PathResolution {\n-                   base_def: def,\n-                   depth: 0\n-                });\n-                Some((Some(ty), slice::ref_slice(item_segment), def))\n-            }\n+        let def = match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n+            Ok(def) => Some(def),\n             Err(error) => {\n+                let def = match error {\n+                    method::MethodError::PrivateMatch(def) => Some(def),\n+                    _ => None,\n+                };\n                 if item_name != special_idents::invalid.name {\n                     method::report_error(fcx, span, ty, item_name, None, error);\n                 }\n-                fcx.write_error(node_id);\n-                None\n+                def\n             }\n+        };\n+\n+        if let Some(def) = def {\n+            // Write back the new resolution.\n+            fcx.ccx.tcx.def_map.borrow_mut().insert(node_id, def::PathResolution {\n+                base_def: def,\n+                depth: 0,\n+            });\n+            Some((Some(ty), slice::ref_slice(item_segment), def))\n+        } else {\n+            fcx.write_error(node_id);\n+            None\n         }\n     }\n }"}, {"sha": "b7ffbefba6a08423a3879b5caf2548634bf4b91d", "filename": "src/test/compile-fail/issue-22684.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22684.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    pub struct Foo;\n+    impl Foo {\n+        fn bar(&self) {}\n+    }\n+\n+    pub trait Baz {\n+        fn bar(&self) -> bool {}\n+    }\n+    impl Baz for Foo {}\n+}\n+\n+fn main() {\n+    use foo::Baz;\n+\n+    // Check that `bar` resolves to the trait method, not the inherent impl method.\n+    let _: () = foo::Foo.bar(); //~ ERROR mismatched types\n+}"}, {"sha": "afe8c2fda3d4c75bfe26f1c91425f4d9b49b9851", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -102,6 +102,7 @@ mod foo {\n                                 //~^ ERROR: method `bar` is private\n         ::bar::baz::A.foo2();   //~ ERROR: module `baz` is private\n         ::bar::baz::A.bar2();   //~ ERROR: module `baz` is private\n+                                //~^ ERROR: method `bar2` is private\n \n         let _: isize =\n         ::bar::B::foo();        //~ ERROR: trait `B` is private"}, {"sha": "9d6ae187cd381f0aa2f9d9c5257d6b0d93772475", "filename": "src/test/compile-fail/privacy5.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -63,25 +63,25 @@ fn this_crate() {\n     let c = a::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n     let d = a::D(4);\n \n-    let a::A(()) = a; //~ ERROR: field #0 of struct `a::A` is private\n+    let a::A(()) = a; //~ ERROR: field `0` of struct `a::A` is private\n     let a::A(_) = a;\n-    match a { a::A(()) => {} } //~ ERROR: field #0 of struct `a::A` is private\n+    match a { a::A(()) => {} } //~ ERROR: field `0` of struct `a::A` is private\n     match a { a::A(_) => {} }\n \n     let a::B(_) = b;\n-    let a::B(_b) = b; //~ ERROR: field #0 of struct `a::B` is private\n+    let a::B(_b) = b; //~ ERROR: field `0` of struct `a::B` is private\n     match b { a::B(_) => {} }\n-    match b { a::B(_b) => {} } //~ ERROR: field #0 of struct `a::B` is private\n-    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR: field #0 of struct `a::B` is private\n+    match b { a::B(_b) => {} } //~ ERROR: field `0` of struct `a::B` is private\n+    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR: field `0` of struct `a::B` is private\n \n     let a::C(_, _) = c;\n     let a::C(_a, _) = c;\n-    let a::C(_, _b) = c; //~ ERROR: field #1 of struct `a::C` is private\n-    let a::C(_a, _b) = c; //~ ERROR: field #1 of struct `a::C` is private\n+    let a::C(_, _b) = c; //~ ERROR: field `1` of struct `a::C` is private\n+    let a::C(_a, _b) = c; //~ ERROR: field `1` of struct `a::C` is private\n     match c { a::C(_, _) => {} }\n     match c { a::C(_a, _) => {} }\n-    match c { a::C(_, _b) => {} } //~ ERROR: field #1 of struct `a::C` is private\n-    match c { a::C(_a, _b) => {} } //~ ERROR: field #1 of struct `a::C` is private\n+    match c { a::C(_, _b) => {} } //~ ERROR: field `1` of struct `a::C` is private\n+    match c { a::C(_a, _b) => {} } //~ ERROR: field `1` of struct `a::C` is private\n \n     let a::D(_) = d;\n     let a::D(_d) = d;\n@@ -101,30 +101,30 @@ fn xcrate() {\n     let c = other::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n     let d = other::D(4);\n \n-    let other::A(()) = a; //~ ERROR: field #0 of struct `other::A` is private\n+    let other::A(()) = a; //~ ERROR: field `0` of struct `other::A` is private\n     let other::A(_) = a;\n     match a { other::A(()) => {} }\n-    //~^ ERROR: field #0 of struct `other::A` is private\n+    //~^ ERROR: field `0` of struct `other::A` is private\n     match a { other::A(_) => {} }\n \n     let other::B(_) = b;\n-    let other::B(_b) = b; //~ ERROR: field #0 of struct `other::B` is private\n+    let other::B(_b) = b; //~ ERROR: field `0` of struct `other::B` is private\n     match b { other::B(_) => {} }\n     match b { other::B(_b) => {} }\n-    //~^ ERROR: field #0 of struct `other::B` is private\n+    //~^ ERROR: field `0` of struct `other::B` is private\n     match b { other::B(1) => {} other::B(_) => {} }\n-    //~^ ERROR: field #0 of struct `other::B` is private\n+    //~^ ERROR: field `0` of struct `other::B` is private\n \n     let other::C(_, _) = c;\n     let other::C(_a, _) = c;\n-    let other::C(_, _b) = c; //~ ERROR: field #1 of struct `other::C` is private\n-    let other::C(_a, _b) = c; //~ ERROR: field #1 of struct `other::C` is private\n+    let other::C(_, _b) = c; //~ ERROR: field `1` of struct `other::C` is private\n+    let other::C(_a, _b) = c; //~ ERROR: field `1` of struct `other::C` is private\n     match c { other::C(_, _) => {} }\n     match c { other::C(_a, _) => {} }\n     match c { other::C(_, _b) => {} }\n-    //~^ ERROR: field #1 of struct `other::C` is private\n+    //~^ ERROR: field `1` of struct `other::C` is private\n     match c { other::C(_a, _b) => {} }\n-    //~^ ERROR: field #1 of struct `other::C` is private\n+    //~^ ERROR: field `1` of struct `other::C` is private\n \n     let other::D(_) = d;\n     let other::D(_d) = d;"}, {"sha": "586a8a183a4e6317bb34d1bde8c4baff8c91f464", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -11,7 +11,7 @@\n mod argparse {\n     pub struct Flag<'a> {\n         name: &'a str,\n-        desc: &'a str,\n+        pub desc: &'a str,\n         max_count: usize,\n         value: usize\n     }"}, {"sha": "f487ef62aa435d22887b120fc595ceca5fb80436", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -25,9 +25,10 @@ mod inner {\n         pub a: isize,\n         b: isize,\n     }\n+    pub struct Z(pub isize, isize);\n }\n \n-fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B) {\n+fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B, z: inner::Z) {\n     a.a;\n     b.a; //~ ERROR: field `a` of struct `inner::A` is private\n     b.b;\n@@ -39,6 +40,9 @@ fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B) {\n \n     e.a;\n     e.b; //~ ERROR: field `b` of struct `xc::B` is private\n+\n+    z.0;\n+    z.1; //~ ERROR: field `1` of struct `inner::Z` is private\n }\n \n fn main() {}"}, {"sha": "83db24b8c01ef2258bac77f91c18e7e2e46ec3b6", "filename": "src/test/parse-fail/pub-method-macro.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fparse-fail%2Fpub-method-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Fparse-fail%2Fpub-method-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpub-method-macro.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -29,6 +29,4 @@ mod bleh {\n     }\n }\n \n-fn main() {\n-    bleh::S.f();\n-}\n+fn main() {}"}, {"sha": "e50f1bea0d3babdcc1252884173d778fbb8f9a72", "filename": "src/test/run-pass/autoderef-privacy.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Frun-pass%2Fautoderef-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3399d19a2c9503d991e4a315118b2d6146f66046/src%2Ftest%2Frun-pass%2Fautoderef-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-privacy.rs?ref=3399d19a2c9503d991e4a315118b2d6146f66046", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check we do not select a private method or field when computing autoderefs\n+\n+#![allow(unused)]\n+\n+#[derive(Default)]\n+pub struct Bar2 { i: i32 }\n+#[derive(Default)]\n+pub struct Baz2(i32);\n+\n+impl Bar2 {\n+    fn f(&self) -> bool { true }\n+}\n+\n+mod foo {\n+    #[derive(Default)]\n+    pub struct Bar { i: ::Bar2 }\n+    #[derive(Default)]\n+    pub struct Baz(::Baz2);\n+\n+    impl Bar {\n+        fn f(&self) -> bool { false }\n+    }\n+\n+    impl ::std::ops::Deref for Bar {\n+        type Target = ::Bar2;\n+        fn deref(&self) -> &::Bar2 { &self.i }\n+    }\n+\n+    impl ::std::ops::Deref for Baz {\n+        type Target = ::Baz2;\n+        fn deref(&self) -> &::Baz2 { &self.0 }\n+    }\n+\n+    pub fn f(bar: &Bar, baz: &Baz) {\n+        // Since the private fields and methods are visible here, there should be no autoderefs.\n+        let _: &::Bar2 = &bar.i;\n+        let _: &::Baz2 = &baz.0;\n+        assert!(!bar.f());\n+    }\n+}\n+\n+fn main() {\n+    let bar = foo::Bar::default();\n+    let baz = foo::Baz::default();\n+    foo::f(&bar, &baz);\n+\n+    let _: i32 = bar.i;\n+    let _: i32 = baz.0;\n+    assert!(bar.f());\n+}"}]}