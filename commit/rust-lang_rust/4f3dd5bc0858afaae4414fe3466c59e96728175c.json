{"sha": "4f3dd5bc0858afaae4414fe3466c59e96728175c", "node_id": "C_kwDOAAsO6NoAKDRmM2RkNWJjMDg1OGFmYWFlNDQxNGZlMzQ2NmM1OWU5NjcyODE3NWM", "commit": {"author": {"name": "Jeroen Vannevel", "email": "jer_vannevel@outlook.com", "date": "2022-01-19T23:21:17Z"}, "committer": {"name": "Jeroen Vannevel", "email": "jer_vannevel@outlook.com", "date": "2022-01-22T12:08:32Z"}, "message": "very rough but comments get extracted", "tree": {"sha": "31fec9db2362ac1833bde250a58cb3927770beab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31fec9db2362ac1833bde250a58cb3927770beab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f3dd5bc0858afaae4414fe3466c59e96728175c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3dd5bc0858afaae4414fe3466c59e96728175c", "html_url": "https://github.com/rust-lang/rust/commit/4f3dd5bc0858afaae4414fe3466c59e96728175c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f3dd5bc0858afaae4414fe3466c59e96728175c/comments", "author": {"login": "Vannevelj", "id": 2777107, "node_id": "MDQ6VXNlcjI3NzcxMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/2777107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vannevelj", "html_url": "https://github.com/Vannevelj", "followers_url": "https://api.github.com/users/Vannevelj/followers", "following_url": "https://api.github.com/users/Vannevelj/following{/other_user}", "gists_url": "https://api.github.com/users/Vannevelj/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vannevelj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vannevelj/subscriptions", "organizations_url": "https://api.github.com/users/Vannevelj/orgs", "repos_url": "https://api.github.com/users/Vannevelj/repos", "events_url": "https://api.github.com/users/Vannevelj/events{/privacy}", "received_events_url": "https://api.github.com/users/Vannevelj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vannevelj", "id": 2777107, "node_id": "MDQ6VXNlcjI3NzcxMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/2777107?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vannevelj", "html_url": "https://github.com/Vannevelj", "followers_url": "https://api.github.com/users/Vannevelj/followers", "following_url": "https://api.github.com/users/Vannevelj/following{/other_user}", "gists_url": "https://api.github.com/users/Vannevelj/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vannevelj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vannevelj/subscriptions", "organizations_url": "https://api.github.com/users/Vannevelj/orgs", "repos_url": "https://api.github.com/users/Vannevelj/repos", "events_url": "https://api.github.com/users/Vannevelj/events{/privacy}", "received_events_url": "https://api.github.com/users/Vannevelj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f662d8bf38267bb39ac2db0891615febc9f8d2a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f662d8bf38267bb39ac2db0891615febc9f8d2a9", "html_url": "https://github.com/rust-lang/rust/commit/f662d8bf38267bb39ac2db0891615febc9f8d2a9"}], "stats": {"total": 252, "additions": 227, "deletions": 25}, "files": [{"sha": "8f9d305b4db9233d492873f52254965e854026ec", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 204, "deletions": 25, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/4f3dd5bc0858afaae4414fe3466c59e96728175c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3dd5bc0858afaae4414fe3466c59e96728175c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=4f3dd5bc0858afaae4414fe3466c59e96728175c", "patch": "@@ -69,11 +69,16 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         return None;\n     }\n \n+    println!(\"initial node: {:?}\", node);\n+\n     let node = match node {\n         syntax::NodeOrToken::Node(n) => n,\n         syntax::NodeOrToken::Token(t) => t.parent()?,\n     };\n+\n+    println!(\"next node: {:?}\", node);\n     let body = extraction_target(&node, range)?;\n+    println!(\"body: {:?}\", body);\n     let container_info = body.analyze_container(&ctx.sema)?;\n \n     let (locals_used, self_param) = body.analyze(&ctx.sema);\n@@ -182,6 +187,8 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n         };\n     }\n \n+    println!(\"node: {:?}\", node);\n+\n     // Covering element returned the parent block of one or multiple statements that have been selected\n     if let Some(stmt_list) = ast::StmtList::cast(node.clone()) {\n         if let Some(block_expr) = stmt_list.syntax().parent().and_then(ast::BlockExpr::cast) {\n@@ -191,6 +198,8 @@ fn extraction_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Fu\n         }\n \n         // Extract the full statements.\n+        println!(\"stmt_list: {:?}\", stmt_list);\n+        println!(\"selection_range: {:?}\", selection_range);\n         return Some(FunctionBody::from_range(stmt_list, selection_range));\n     }\n \n@@ -475,12 +484,21 @@ impl FunctionBody {\n         }\n     }\n \n+    // selection: 36..67\n+    // resulting: 57..67\n+\n     fn from_range(parent: ast::StmtList, selected: TextRange) -> FunctionBody {\n-        let mut text_range = parent\n-            .statements()\n-            .map(|stmt| stmt.syntax().text_range())\n+        let full_body = parent.syntax().children_with_tokens();\n+        for st in parent.syntax().children_with_tokens() {\n+            println!(\"Statement: {:?}\", &st);\n+        }\n+\n+        let mut text_range = full_body\n+            .map(|stmt| stmt.text_range())\n             .filter(|&stmt| selected.intersect(stmt).filter(|it| !it.is_empty()).is_some())\n             .reduce(|acc, stmt| acc.cover(stmt));\n+\n+        println!(\"from_range text_range first: {:?}\", text_range);\n         if let Some(tail_range) = parent\n             .tail_expr()\n             .map(|it| it.syntax().text_range())\n@@ -490,6 +508,8 @@ impl FunctionBody {\n                 Some(text_range) => text_range.cover(tail_range),\n                 None => tail_range,\n             });\n+\n+            println!(\"from_range text_range second: {:?}\", text_range);\n         }\n         Self::Span { parent, text_range: text_range.unwrap_or(selected) }\n     }\n@@ -1420,6 +1440,8 @@ fn make_body(\n     } else {\n         FlowHandler::from_ret_ty(fun, &ret_ty)\n     };\n+\n+    println!(\"making body: {:?}\", fun.body);\n     let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n             let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n@@ -1441,17 +1463,32 @@ fn make_body(\n         FunctionBody::Span { parent, text_range } => {\n             let mut elements: Vec<_> = parent\n                 .syntax()\n-                .children()\n+                .children_with_tokens()\n                 .filter(|it| text_range.contains_range(it.text_range()))\n-                .map(|it| rewrite_body_segment(ctx, &fun.params, &handler, &it))\n+                .map(|it| match it {\n+                    syntax::NodeOrToken::Node(n) => {\n+                        return syntax::NodeOrToken::try_from(rewrite_body_segment(\n+                            ctx,\n+                            &fun.params,\n+                            &handler,\n+                            &n,\n+                        ))\n+                        .unwrap()\n+                    }\n+                    syntax::NodeOrToken::Token(t) => {\n+                        return syntax::NodeOrToken::try_from(t).unwrap()\n+                    }\n+                })\n                 .collect();\n \n             let mut tail_expr = match elements.pop() {\n-                Some(node) => ast::Expr::cast(node.clone()).or_else(|| {\n-                    elements.push(node);\n-                    None\n-                }),\n-                None => None,\n+                Some(node) if node.as_node().is_some() => {\n+                    ast::Expr::cast(node.as_node().unwrap().clone()).or_else(|| {\n+                        elements.push(node);\n+                        None\n+                    })\n+                }\n+                _ => None,\n             };\n \n             if tail_expr.is_none() {\n@@ -1467,20 +1504,30 @@ fn make_body(\n                     }\n                 }\n             }\n-\n-            let elements = elements.into_iter().filter_map(|node| match ast::Stmt::cast(node) {\n-                Some(stmt) => Some(stmt),\n-                None => {\n-                    stdx::never!(\"block contains non-statement\");\n-                    None\n-                }\n-            });\n-\n+            \n             let body_indent = IndentLevel(1);\n-            let elements = elements.map(|stmt| stmt.dedent(old_indent).indent(body_indent));\n+            let elements: Vec<SyntaxElement> = elements.into_iter().map(|stmt| {\n+                match stmt {\n+                    syntax::NodeOrToken::Node(n) => {\n+                        let ast_element = ast::Stmt::cast(n).unwrap();\n+                        let indented = ast_element.dedent(old_indent).indent(body_indent);\n+                        let ast_node = indented.syntax().clone_subtree();\n+                        syntax::NodeOrToken::try_from(ast_node).unwrap()\n+                    },\n+                    syntax::NodeOrToken::Token(t) => syntax::NodeOrToken::try_from(t).unwrap()\n+                }\n+            }).collect::<Vec<SyntaxElement>>();\n             let tail_expr = tail_expr.map(|expr| expr.dedent(old_indent).indent(body_indent));\n \n-            make::block_expr(elements, tail_expr)\n+            for element in &elements {\n+                println!(\"element: {:?}\", element);\n+            }\n+\n+            make::block_expr_full(elements, tail_expr)\n+\n+            \n+\n+            // make::block_expr(parent.statements().into_iter(), tail_expr)\n         }\n     };\n \n@@ -4092,14 +4139,14 @@ fn foo() {\n \"#,\n             r#\"\n fn foo() {\n-    /**/\n     fun_name();\n-    /**/\n }\n \n fn $0fun_name() {\n+    /**/\n     foo();\n     foo();\n+    /**/\n }\n \"#,\n         );\n@@ -4399,28 +4446,160 @@ fn $0fun_name(arg: &mut Foo) {\n     }\n \n     #[test]\n-    fn extract_function_copies_comments() {\n+    fn extract_function_copies_comment_at_start() {\n         check_assist(\n             extract_function,\n             r#\"\n fn func() {\n     let i = 0;\n-    $0\n+    $0// comment here!\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n     // comment here!\n     let x = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_in_between() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n     $0\n+    let a = 0;\n+    // comment here!\n+    let x = 0;$0\n }\n \"#,\n             r#\"\n fn func() {\n     let i = 0;\n+    \n     fun_name();\n }\n \n fn $0fun_name() {\n+    let a = 0;\n     // comment here!\n     let x = 0;\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_at_end() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0let x = 0;\n+    // comment here!$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let x = 0;\n+    // comment here!\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_copies_comment_indented() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0let x = 0;\n+    while(true) {\n+        // comment here!\n+    }$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let x = 0;\n+    while(true) {\n+        // comment here!\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_does_not_preserve_whitespace() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0let a = 0;\n+\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    let a = 0;\n+    let x = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_function_long_form_comment() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    $0/* a comment */\n+    let x = 0;$0\n+}\n+\"#,\n+            r#\"\n+fn func() {\n+    let i = 0;\n+    fun_name();\n+}\n+\n+fn $0fun_name() {\n+    /* a comment */\n+    let x = 0;\n+}\n \"#,\n         );\n     }"}, {"sha": "3b492a4257a5f9b58b674394db7a140bd582f9cf", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f3dd5bc0858afaae4414fe3466c59e96728175c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3dd5bc0858afaae4414fe3466c59e96728175c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=4f3dd5bc0858afaae4414fe3466c59e96728175c", "patch": "@@ -329,6 +329,29 @@ pub fn block_expr(\n     ast_from_text(&format!(\"fn f() {}\", buf))\n }\n \n+pub fn block_expr_full(\n+    stmts: impl IntoIterator<Item = crate::SyntaxElement>,\n+    tail_expr: Option<ast::Expr>,\n+) -> ast::BlockExpr {\n+    let mut buf = \"{\\n\".to_string();\n+    for stmt in stmts.into_iter() {\n+        \n+        match stmt {\n+            rowan::NodeOrToken::Node(n) => {\n+                println!(\"Node: {:?}\", n.text());\n+                format_to!(buf, \"    {}\\n\", n)\n+            },\n+            rowan::NodeOrToken::Token(t) if t.kind() == SyntaxKind::COMMENT => format_to!(buf, \"    {}\\n\", t),\n+            _ => ()\n+        }\n+    }\n+    if let Some(tail_expr) = tail_expr {\n+        format_to!(buf, \"    {}\\n\", tail_expr);\n+    }\n+    buf += \"}\";\n+    ast_from_text(&format!(\"fn f() {}\", buf))\n+}\n+\n pub fn expr_unit() -> ast::Expr {\n     expr_from_text(\"()\")\n }"}]}