{"sha": "1e5f496143aabf1d4d158d99b73afee7b00f0650", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlNWY0OTYxNDNhYWJmMWQ0ZDE1OGQ5OWI3M2FmZWU3YjAwZjA2NTA=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-05-29T16:28:51Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-06-03T09:20:35Z"}, "message": "rustc: async fn drop order lowering in HIR\n\nThis commit re-implements the async fn drop order lowering changes so\nthat it all takes place in HIR lowering, building atop the work done by\n`@eddyb` to refactor `Res::Upvar`.\n\nPreviously, this types involved in the lowering were constructed in\nlibsyntax as they had to be used during name resolution and HIR\nlowering. This was awful because none of that logic should have existed\nin libsyntax.\n\nThis commit also changes `ArgSource` to keep a `HirId` to the original\nargument pattern rather than a cloned copy of the pattern.", "tree": {"sha": "8f7a031fe975cd4d5fed86d0730b2a053cbad641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f7a031fe975cd4d5fed86d0730b2a053cbad641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e5f496143aabf1d4d158d99b73afee7b00f0650", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlz05mMACgkQAXYLT59T\n8VR3jw//ZGe+Q8oDcRUQoecCIcG0lPLJeTXmcLviruIV4awGLXO8wHQEL2Bkbkt9\nhTA9+GwOiHSIzw/E/921A4K92ba8fp+pqJsoWXXbUxnLyXMTPLwHCRR1UrbKc/jb\n99WhIm6uCa3uDeIzUfyLA/IH9n50Q0fyLvMuMRCMvrX6SVVFdDbpk8DlihJsvHjT\n3wcaqq0oJ3WyJUKEuiToIgkhH4u0a9Y+5BOX5ypqVi9eYVMIufvpppXMkohxuLX/\nivTjkcM7+0HRHVKVwjmqJ9hv2PAvKpo7MjuEmgF2DlMXuZmQJD8nZgof+VaWg06z\naVJYYmJbvvmvfxXoFx7qu8uLpPtT2/nYhUr1vI3ECUCxHb5/8XpXDPqAH65mApVo\noeqCE5UYiBnjjLT8knM3gZyGfEJub8uh56y9cItI8q6XDEacA1yx1/9jONpZEeAf\nK94cSaukj5E43T7C4Pfv+vVSc5niulKZQOJFmWHh0FkUwCdPaeJ1lpj1kawHoPZ9\ntqqASSHBA9uEo8hfdKnY7WqK6gdiq40eoul6HAeg0DH2kZcmTOibcGshNo15TACn\nAMzysbvVYEJGR4O1B8MzSrcG1k1pXWhMjhi3dYHbJwZj/8XU8tK6Nl721LkgK9xy\nNFWgWlmi8CjMinZ0WM/u8Mlam0us5FJdyH1sYIvwa6WCa69lTLQ=\n=7BnC\n-----END PGP SIGNATURE-----", "payload": "tree 8f7a031fe975cd4d5fed86d0730b2a053cbad641\nparent 32771071e8d6731e2ff747de04aabe9a4d499b24\nauthor David Wood <david@davidtw.co> 1559147331 +0300\ncommitter David Wood <david@davidtw.co> 1559553635 +0100\n\nrustc: async fn drop order lowering in HIR\n\nThis commit re-implements the async fn drop order lowering changes so\nthat it all takes place in HIR lowering, building atop the work done by\n`@eddyb` to refactor `Res::Upvar`.\n\nPreviously, this types involved in the lowering were constructed in\nlibsyntax as they had to be used during name resolution and HIR\nlowering. This was awful because none of that logic should have existed\nin libsyntax.\n\nThis commit also changes `ArgSource` to keep a `HirId` to the original\nargument pattern rather than a cloned copy of the pattern.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5f496143aabf1d4d158d99b73afee7b00f0650", "html_url": "https://github.com/rust-lang/rust/commit/1e5f496143aabf1d4d158d99b73afee7b00f0650", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e5f496143aabf1d4d158d99b73afee7b00f0650/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32771071e8d6731e2ff747de04aabe9a4d499b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/32771071e8d6731e2ff747de04aabe9a4d499b24", "html_url": "https://github.com/rust-lang/rust/commit/32771071e8d6731e2ff747de04aabe9a4d499b24"}], "stats": {"total": 472, "additions": 317, "deletions": 155}, "files": [{"sha": "9cf365addca9bb060e3a5c941d1c38d0c3230fd9", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -262,9 +262,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_pat(&mut self, p: &'v Pat) {\n         walk_pat(self, p)\n     }\n-    fn visit_argument_source(&mut self, s: &'v ArgSource) {\n-        walk_argument_source(self, s)\n-    }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n@@ -402,17 +399,10 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n     for argument in &body.arguments {\n         visitor.visit_id(argument.hir_id);\n         visitor.visit_pat(&argument.pat);\n-        visitor.visit_argument_source(&argument.source);\n     }\n     visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_argument_source<'v, V: Visitor<'v>>(visitor: &mut V, source: &'v ArgSource) {\n-    if let ArgSource::AsyncFn(pat) = source {\n-        visitor.visit_pat(pat);\n-    }\n-}\n-\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition."}, {"sha": "e82b3df8550357139f7e6f6607ed4f878a50f986", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 226, "deletions": 68, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -781,7 +781,7 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, value: hir::Expr, arguments: HirVec<hir::Arg>) -> hir::BodyId {\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n         if self.is_generator && self.is_async_body {\n             span_err!(\n                 self.sess,\n@@ -1121,27 +1121,21 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_is_async_body = mem::replace(&mut self.is_async_body, true);\n+        let capture_clause = self.lower_capture_clause(capture_clause);\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n             None => FunctionRetTy::Default(span),\n         };\n-        let decl = FnDecl {\n+        let ast_decl = FnDecl {\n             inputs: vec![],\n             output,\n             c_variadic: false\n         };\n-        // Lower the arguments before the body otherwise the body will call `lower_res` expecting\n-        // the argument to have been assigned an id already.\n-        let arguments = self.lower_args(Some(&decl));\n-        let body_expr = body(self);\n-        let body_id = self.record_body(body_expr, arguments);\n-        self.is_generator = prev_is_generator;\n-        self.is_async_body = prev_is_async_body;\n-\n-        let capture_clause = self.lower_capture_clause(capture_clause);\n-        let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n+        let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n+        let body_id = self.lower_fn_body(&ast_decl, |this| {\n+            this.is_async_body = true;\n+            body(this)\n+        });\n         let generator = hir::Expr {\n             hir_id: self.lower_node_id(closure_node_id),\n             node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n@@ -1160,18 +1154,32 @@ impl<'a> LoweringContext<'a> {\n         hir::ExprKind::Call(P(gen_future), hir_vec![generator])\n     }\n \n-    fn lower_body<F>(&mut self, decl: Option<&FnDecl>, f: F) -> hir::BodyId\n-    where\n-        F: FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n-    {\n-        let prev_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_async = mem::replace(&mut self.is_async_body, false);\n-        let arguments = self.lower_args(decl);\n-        let result = f(self);\n-        let r = self.record_body(result, arguments);\n-        self.is_generator = prev_generator;\n-        self.is_async_body = prev_async;\n-        return r;\n+    fn lower_body(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+    ) -> hir::BodyId {\n+        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n+        let prev_is_async_body = mem::replace(&mut self.is_async_body, false);\n+        let (arguments, result) = f(self);\n+        let body_id = self.record_body(arguments, result);\n+        self.is_generator = prev_is_generator;\n+        self.is_async_body = prev_is_async_body;\n+        body_id\n+    }\n+\n+    fn lower_fn_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+    ) -> hir::BodyId {\n+        self.lower_body(|this| (\n+            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            body(this),\n+        ))\n+    }\n+\n+    fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n+        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n     }\n \n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n@@ -2273,10 +2281,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_args(&mut self, decl: Option<&FnDecl>) -> HirVec<hir::Arg> {\n-        decl.map_or(hir_vec![], |decl| decl.inputs.iter().map(|x| self.lower_arg(x)).collect())\n-    }\n-\n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         hir::Arg {\n             hir_id: self.lower_node_id(arg.id),\n@@ -2980,11 +2984,14 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+    fn lower_block_with_stmts(\n+        &mut self,\n+        b: &Block,\n+        targeted_by_break: bool,\n+        mut stmts: Vec<hir::Stmt>,\n+    ) -> P<hir::Block> {\n         let mut expr = None;\n \n-        let mut stmts = vec![];\n-\n         for (index, stmt) in b.stmts.iter().enumerate() {\n             if index == b.stmts.len() - 1 {\n                 if let StmtKind::Expr(ref e) = stmt.node {\n@@ -3007,25 +3014,177 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_async_body(\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+        self.lower_block_with_stmts(b, targeted_by_break, vec![])\n+    }\n+\n+    fn lower_maybe_async_body(\n         &mut self,\n         decl: &FnDecl,\n         asyncness: IsAsync,\n         body: &Block,\n     ) -> hir::BodyId {\n-        self.lower_body(Some(&decl), |this| {\n-            if let IsAsync::Async { closure_id, .. } = asyncness {\n-                let async_expr = this.make_async_expr(\n-                    CaptureBy::Value, closure_id, None, body.span,\n-                    |this| {\n-                        let body = this.lower_block(&body, false);\n-                        this.expr_block(body, ThinVec::new())\n-                    });\n-                this.expr(body.span, async_expr, ThinVec::new())\n-            } else {\n+        let closure_id = match asyncness {\n+            IsAsync::Async { closure_id, .. } => closure_id,\n+            IsAsync::NotAsync => return self.lower_fn_body(&decl, |this| {\n                 let body = this.lower_block(body, false);\n                 this.expr_block(body, ThinVec::new())\n+            }),\n+        };\n+\n+        self.lower_body(|this| {\n+            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut statements: Vec<(hir::Stmt, Option<hir::Stmt>)> = Vec::new();\n+\n+            // Async function arguments are lowered into the closure body so that they are\n+            // captured and so that the drop order matches the equivalent non-async functions.\n+            //\n+            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+            //       async move {\n+            //       }\n+            //     }\n+            //\n+            //     // ...becomes...\n+            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+            //       async move {\n+            //         let __arg2 = __arg2;\n+            //         let <pattern> = __arg2;\n+            //         let __arg1 = __arg1;\n+            //         let <pattern> = __arg1;\n+            //         let __arg0 = __arg0;\n+            //         let <pattern> = __arg0;\n+            //       }\n+            //     }\n+            //\n+            // If `<pattern>` is a simple ident, then it is lowered to a single\n+            // `let <pattern> = <pattern>;` statement as an optimization.\n+            for (index, argument) in decl.inputs.iter().enumerate() {\n+                let argument = this.lower_arg(argument);\n+                let span = argument.pat.span;\n+\n+                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n+                let (ident, is_simple_argument) = match argument.pat.node {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n+                        (ident, true),\n+                    _ => {\n+                        // Replace the ident for bindings that aren't simple.\n+                        let name = format!(\"__arg{}\", index);\n+                        let ident = Ident::from_str(&name);\n+\n+                        (ident, false)\n+                    },\n+                };\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n+                //\n+                // If this is the simple case, this argument will end up being the same as the\n+                // original argument, but with a different pattern id.\n+                let new_argument_id = this.next_id();\n+                let desugared_span =\n+                    this.mark_span_with_reason(CompilerDesugaringKind::Async, span, None);\n+                let new_argument = hir::Arg {\n+                    hir_id: argument.hir_id,\n+                    pat: P(hir::Pat {\n+                        hir_id: new_argument_id,\n+                        node: hir::PatKind::Binding(hir::BindingAnnotation::Unannotated,\n+                                                   new_argument_id, ident, None),\n+                        span: desugared_span,\n+                    }),\n+                    source: hir::ArgSource::AsyncFn(argument.pat.hir_id),\n+                };\n+\n+                let construct_stmt = |this: &mut LoweringContext<'_>, pat: P<hir::Pat>,\n+                                      init_pat_id: hir::HirId| {\n+                    hir::Stmt {\n+                        hir_id: this.next_id(),\n+                        node: hir::StmtKind::Local(P(hir::Local {\n+                            pat,\n+                            // We explicitly do not specify the type for any statements. When the\n+                            // user's argument type is `impl Trait` then this would require the\n+                            // `impl_trait_in_bindings` feature to also be present for that same\n+                            // type to be valid in this binding. At the time of writing (13 Mar 19),\n+                            // `impl_trait_in_bindings` is not stable.\n+                            ty: None,\n+                            init: Some(P(hir::Expr {\n+                                span,\n+                                node: hir::ExprKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                                    span,\n+                                    res: Res::Local(init_pat_id),\n+                                    segments: hir_vec![ hir::PathSegment::from_ident(ident) ],\n+                                }))),\n+                                attrs: ThinVec::new(),\n+                                hir_id: this.next_id(),\n+                            })),\n+                            hir_id: this.next_id(),\n+                            span: desugared_span,\n+                            attrs: ThinVec::new(),\n+                            source: hir::LocalSource::AsyncFn,\n+                        })),\n+                        span: desugared_span,\n+                    }\n+                };\n+\n+                let new_statements = if is_simple_argument {\n+                    // If this is the simple case, then we only insert one statement that is\n+                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n+                    // `HirId`s are densely assigned.\n+                    (construct_stmt(this, argument.pat, new_argument_id), None)\n+                } else {\n+                    // If this is not the simple case, then we construct two statements:\n+                    //\n+                    // ```\n+                    // let __argN = __argN;\n+                    // let <pat> = __argN;\n+                    // ```\n+                    //\n+                    // The first statement moves the argument into the closure and thus ensures\n+                    // that the drop order is correct.\n+                    //\n+                    // The second statement creates the bindings that the user wrote.\n+\n+                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n+                    // because the user may have specified a `ref mut` binding in the next\n+                    // statement.\n+                    let hir_id = this.next_id();\n+                    let move_stmt = construct_stmt(\n+                        this,\n+                        P(hir::Pat {\n+                            hir_id,\n+                            node: hir::PatKind::Binding(hir::BindingAnnotation::Mutable,\n+                                                        hir_id, ident, None),\n+                            span: desugared_span,\n+                        }),\n+                        new_argument_id,\n+                    );\n+\n+                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n+                    // argument's pattern so that `HirId`s are densely assigned.\n+                    let pattern_stmt = construct_stmt(this, argument.pat, hir_id);\n+                    (move_stmt, Some(pattern_stmt))\n+                };\n+\n+                arguments.push(new_argument);\n+                statements.push(new_statements);\n             }\n+\n+            let async_expr = this.make_async_expr(\n+                CaptureBy::Value, closure_id, None, body.span,\n+                |this| {\n+                    let mut stmts = vec![];\n+                    for (move_stmt, pattern_stmt) in statements.drain(..) {\n+                        // Insert the `let __argN = __argN` statement first.\n+                        stmts.push(move_stmt);\n+                        // Then insert the `let <pat> = __argN` statement, if there is one.\n+                        if let Some(pattern_stmt) = pattern_stmt {\n+                            stmts.push(pattern_stmt);\n+                        }\n+                    }\n+                    let body = this.lower_block_with_stmts(body, false, stmts);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n \n@@ -3049,7 +3208,6 @@ impl<'a> LoweringContext<'a> {\n                 self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n-                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Static(\n                     self.lower_ty(\n                         t,\n@@ -3060,11 +3218,10 @@ impl<'a> LoweringContext<'a> {\n                         }\n                     ),\n                     self.lower_mutability(m),\n-                    value,\n+                    self.lower_const_body(e),\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n-                let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Const(\n                     self.lower_ty(\n                         t,\n@@ -3074,29 +3231,31 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n-                    value\n+                    self.lower_const_body(e)\n                 )\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n+\n                     // Note: we don't need to change the return type from `T` to\n                     // `impl Future<Output = T>` here because lower_body\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n-                    let body_id = this.lower_async_body(decl, header.asyncness.node, body);\n+                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n+\n                     let (generics, fn_decl) = this.add_in_band_defs(\n                         generics,\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, idty| this.lower_fn_decl(\n-                            decl,\n+                            &decl,\n                             Some((fn_def_id, idty)),\n                             true,\n                             header.asyncness.node.opt_return_id()\n                         ),\n                     );\n-                    this.current_item = Some(ident.span);\n \n                     hir::ItemKind::Fn(\n                         fn_decl,\n@@ -3478,7 +3637,7 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_ty(ty, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n-                        .map(|x| self.lower_body(None, |this| this.lower_expr(x))),\n+                        .map(|x| self.lower_const_body(x)),\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n@@ -3493,7 +3652,7 @@ impl<'a> LoweringContext<'a> {\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n             TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                let body_id = self.lower_body(Some(&sig.decl), |this| {\n+                let body_id = self.lower_fn_body(&sig.decl, |this| {\n                     let body = this.lower_block(body, false);\n                     this.expr_block(body, ThinVec::new())\n                 });\n@@ -3557,18 +3716,18 @@ impl<'a> LoweringContext<'a> {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, node) = match i.node {\n-            ImplItemKind::Const(ref ty, ref expr) => {\n-                let body_id = self.lower_body(None, |this| this.lower_expr(expr));\n-                (\n-                    self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                    hir::ImplItemKind::Const(\n-                        self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                        body_id,\n-                    ),\n-                )\n-            }\n+            ImplItemKind::Const(ref ty, ref expr) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    self.lower_const_body(expr),\n+                ),\n+            ),\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness.node, body);\n+                self.current_item = Some(i.span);\n+                let body_id = self.lower_maybe_async_body(\n+                    &sig.decl, sig.header.asyncness.node, body\n+                );\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n@@ -3577,7 +3736,6 @@ impl<'a> LoweringContext<'a> {\n                     impl_trait_return_allow,\n                     sig.header.asyncness.node.opt_return_id(),\n                 );\n-                self.current_item = Some(i.span);\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -3973,7 +4131,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_new_scopes(|this| {\n             hir::AnonConst {\n                 hir_id: this.lower_node_id(c.id),\n-                body: this.lower_body(None, |this| this.lower_expr(&c.value)),\n+                body: this.lower_const_body(&c.value),\n             }\n         })\n     }\n@@ -4161,7 +4319,7 @@ impl<'a> LoweringContext<'a> {\n \n                         // Transform `async |x: u8| -> X { ... }` into\n                         // `|x: u8| future_from_generator(|| -> X { ... })`.\n-                        let body_id = this.lower_body(Some(&outer_decl), |this| {\n+                        let body_id = this.lower_fn_body(&outer_decl, |this| {\n                             let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n                                 Some(&**ty)\n                             } else { None };\n@@ -4187,7 +4345,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_new_scopes(|this| {\n                         this.current_item = Some(fn_decl_span);\n                         let mut is_generator = false;\n-                        let body_id = this.lower_body(Some(decl), |this| {\n+                        let body_id = this.lower_fn_body(decl, |this| {\n                             let e = this.lower_expr(body);\n                             is_generator = this.is_generator;\n                             e"}, {"sha": "2d3de5af9927fe76786ce01b712be051a5135771", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -699,6 +699,19 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Returns the `HirId` of this pattern, or, if this is an `async fn` desugaring, the `HirId`\n+    /// of the original pattern that the user wrote.\n+    pub fn original_pat_of_argument(&self, arg: &'hir Arg) -> &'hir Pat {\n+        match &arg.source {\n+            ArgSource::Normal => &*arg.pat,\n+            ArgSource::AsyncFn(hir_id) => match self.find_by_hir_id(*hir_id) {\n+                Some(Node::Pat(pat)) | Some(Node::Binding(pat)) => &pat,\n+                Some(Node::Local(local)) => &*local.pat,\n+                x => bug!(\"ArgSource::AsyncFn HirId not a pattern/binding/local: {:?}\", x),\n+            },\n+        }\n+    }\n+\n     pub fn is_const_scope(&self, hir_id: HirId) -> bool {\n         self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(Item { node: ItemKind::Const(_, _), .. }) => true,"}, {"sha": "817c4cb540f67f20ff13425876eace1e3b9fc308", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -1932,23 +1932,13 @@ pub struct Arg {\n     pub source: ArgSource,\n }\n \n-impl Arg {\n-    /// Returns the pattern representing the original binding for this argument.\n-    pub fn original_pat(&self) -> &P<Pat> {\n-        match &self.source {\n-            ArgSource::Normal => &self.pat,\n-            ArgSource::AsyncFn(pat) => &pat,\n-        }\n-    }\n-}\n-\n /// Represents the source of an argument in a function header.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum ArgSource {\n     /// Argument as specified by the user.\n     Normal,\n-    /// Generated argument from `async fn` lowering, contains the original binding pattern.\n-    AsyncFn(P<Pat>),\n+    /// Generated argument from `async fn` lowering, `HirId` is the original pattern.\n+    AsyncFn(HirId),\n }\n \n /// Represents the header (not the body) of a function declaration."}, {"sha": "46785f7ada1feecd691074f3708c68f8abdb1c20", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -86,12 +86,14 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.original_pat().simple_ident() {\n+        let arg_sup_pat = self.tcx().hir().original_pat_of_argument(anon_arg_sup);\n+        let span_label_var1 = match arg_sup_pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.original_pat().simple_ident() {\n+        let arg_sub_pat = self.tcx().hir().original_pat_of_argument(anon_arg_sub);\n+        let span_label_var2 = match arg_sub_pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "1eb2af2bd58180ec41e582b1999e5842ca278291", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -95,7 +95,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.original_pat().simple_ident() {\n+        let arg_pat = self.tcx().hir().original_pat_of_argument(arg);\n+        let (error_var, span_label_var) = match arg_pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "f48da4762b768022c34acc4a1b0c51bdf73f2784", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -2416,7 +2416,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let help_name = if let Some(body) = parent {\n                 let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.original_pat().hir_id))\n+                let original_pat = self.tcx.hir().original_pat_of_argument(arg);\n+                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(original_pat.hir_id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };"}, {"sha": "a5d92d6c88f9923fd5d9e8af63f28c8950fff024", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 46, "deletions": 20, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -84,11 +84,23 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n-                    Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n+                    Some(ArgInfo {\n+                        ty: liberated_closure_env_ty(tcx, id, body_id),\n+                        span: None,\n+                        pattern: None,\n+                        user_pattern: None,\n+                        self_kind: None,\n+                    })\n                 }\n                 ty::Generator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_type(id);\n-                    Some(ArgInfo(gen_ty, None, None, None))\n+                    Some(ArgInfo {\n+                        ty: gen_ty,\n+                        span: None,\n+                        pattern: None,\n+                        user_pattern: None,\n+                        self_kind: None,\n+                    })\n                 }\n                 _ => None,\n             };\n@@ -126,7 +138,15 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n                             opt_ty_info = None;\n                             self_arg = None;\n                         }\n-                        ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&*arg.pat), self_arg)\n+\n+                        let original_pat = tcx.hir().original_pat_of_argument(arg);\n+                        ArgInfo {\n+                            ty: fn_sig.inputs()[index],\n+                            span: opt_ty_info,\n+                            pattern: Some(&*arg.pat),\n+                            user_pattern: Some(&original_pat),\n+                            self_kind: self_arg,\n+                        }\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n@@ -614,10 +634,13 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'gcx>(Ty<'gcx>,\n-                     Option<Span>,\n-                     Option<&'gcx hir::Pat>,\n-                     Option<ImplicitSelfKind>);\n+struct ArgInfo<'gcx> {\n+    ty: Ty<'gcx>,\n+    span: Option<Span>,\n+    pattern: Option<&'gcx hir::Pat>,\n+    user_pattern: Option<&'gcx hir::Pat>,\n+    self_kind: Option<ImplicitSelfKind>,\n+}\n \n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: hir::HirId,\n@@ -878,26 +901,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n-        for &ArgInfo(ty, _, pattern, _) in arguments.iter() {\n+        for &ArgInfo { ty, span: _, pattern, user_pattern, self_kind: _ } in arguments.iter() {\n             // If this is a simple binding pattern, give the local a name for\n             // debuginfo and so that error reporting knows that this is a user\n             // variable. For any other pattern the pattern introduces new\n             // variables which will be named instead.\n-            let mut name = None;\n-            if let Some(pat) = pattern {\n+            let (name, span) = if let Some(pat) = user_pattern {\n                 match pat.node {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _)\n-                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, _) => {\n-                        name = Some(ident.name);\n-                    }\n-                    _ => (),\n+                    | hir::PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, _) =>\n+                        (Some(ident.name), pat.span),\n+                    _ => (None, pattern.map_or(self.fn_span, |pat| pat.span))\n                 }\n-            }\n-\n-            let source_info = SourceInfo {\n-                scope: OUTERMOST_SOURCE_SCOPE,\n-                span: pattern.map_or(self.fn_span, |pat| pat.span)\n+            } else {\n+                (None, self.fn_span)\n             };\n+\n+            let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span, };\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n@@ -917,7 +937,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::Base(PlaceBase::Local(local));\n-            let &ArgInfo(ty, opt_ty_info, pattern, ref self_binding) = arg_info;\n+            let &ArgInfo {\n+                ty,\n+                span: opt_ty_info,\n+                pattern,\n+                user_pattern: _,\n+                self_kind: ref self_binding\n+            } = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n             self.schedule_drop("}, {"sha": "f084d3b9f28c3a4c8c7dae9793f215a4fd24cf58", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -948,16 +948,6 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n         intravisit::walk_pat(self, pat);\n     }\n-\n-    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1147,16 +1137,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n-    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n-\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {"}, {"sha": "3ada80b3e8b7015e03df59364917ae815ec77cbd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -1009,16 +1009,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 _: hir::BodyId, _: Span, _: hir::HirId) { }\n-\n-    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n /// When `check_fn` is invoked on a generator (i.e., a body that"}, {"sha": "6f8682e64671c3fb4afe381816858d7c0f7c907d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -311,16 +311,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         let ty = self.resolve(&ty, &hir_ty.span);\n         self.write_ty_to_tables(hir_ty.hir_id, ty);\n     }\n-\n-    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n-        match s {\n-            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n-            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n-            // pattern for diagnostics where only an `hir::Arg` is present.\n-            hir::ArgSource::AsyncFn(..) => {},\n-            _ => intravisit::walk_argument_source(self, s),\n-        }\n-    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "319adea6b86820da580e72a0309052b5967f6d9d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -2018,8 +2018,9 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n \n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n+                let original_pat = cx.tcx.hir().original_pat_of_argument(&body.arguments[i]);\n                 Argument {\n-                    name: name_from_pat(&body.arguments[i].original_pat()),\n+                    name: name_from_pat(original_pat),\n                     type_: ty.clean(cx),\n                 }\n             }).collect()"}, {"sha": "8b939b43b8bd406fdfb717943131a4300419440a", "filename": "src/test/ui/async-await/issues/issue-61187.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.rs?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -0,0 +1,9 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+fn main() {\n+}\n+\n+async fn response(data: Vec<u8>) {\n+    data.reverse(); //~ ERROR E0596\n+}"}, {"sha": "a03142263202ef304fb469d94a9b465444952d3f", "filename": "src/test/ui/async-await/issues/issue-61187.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1e5f496143aabf1d4d158d99b73afee7b00f0650/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-61187.stderr?ref=1e5f496143aabf1d4d158d99b73afee7b00f0650", "patch": "@@ -0,0 +1,11 @@\n+error[E0596]: cannot borrow `data` as mutable, as it is not declared as mutable\n+  --> $DIR/issue-61187.rs:8:5\n+   |\n+LL | async fn response(data: Vec<u8>) {\n+   |                   ---- help: consider changing this to be mutable: `mut data`\n+LL |     data.reverse();\n+   |     ^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}]}