{"sha": "b53406f8241edb45eb962795da99cb2cf73d8c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzQwNmY4MjQxZWRiNDVlYjk2Mjc5NWRhOTljYjJjZjczZDhjMWE=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T21:40:54Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-27T21:42:04Z"}, "message": "fixups for aturon", "tree": {"sha": "f2d470b38a85d0139d3ab9eafb55fd13498b7f53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2d470b38a85d0139d3ab9eafb55fd13498b7f53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b53406f8241edb45eb962795da99cb2cf73d8c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b53406f8241edb45eb962795da99cb2cf73d8c1a", "html_url": "https://github.com/rust-lang/rust/commit/b53406f8241edb45eb962795da99cb2cf73d8c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b53406f8241edb45eb962795da99cb2cf73d8c1a/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7111da07f20422a6bd5243b56d302f0f02c3a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7111da07f20422a6bd5243b56d302f0f02c3a5", "html_url": "https://github.com/rust-lang/rust/commit/8c7111da07f20422a6bd5243b56d302f0f02c3a5"}], "stats": {"total": 68, "additions": 43, "deletions": 25}, "files": [{"sha": "f4475b738509b2b8ac1354e0bf368c171b38845e", "filename": "src/doc/tarpl/lifetimes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b53406f8241edb45eb962795da99cb2cf73d8c1a/src%2Fdoc%2Ftarpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b53406f8241edb45eb962795da99cb2cf73d8c1a/src%2Fdoc%2Ftarpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Flifetimes.md?ref=b53406f8241edb45eb962795da99cb2cf73d8c1a", "patch": "@@ -19,7 +19,7 @@ our toes with lifetimes, we're going to pretend that we're actually allowed\n to label scopes with lifetimes, and desugar the examples from the start of\n this chapter.\n \n-Our examples made use of *aggressive* sugar -- high fructose corn syrup even --\n+Originally, our examples made use of *aggressive* sugar -- high fructose corn syrup even --\n around scopes and lifetimes, because writing everything out explicitly is\n *extremely noisy*. All Rust code relies on aggressive inference and elision of\n \"obvious\" things.\n@@ -166,7 +166,7 @@ our implementation *just a bit*.)\n \n \n \n-# Example 2: aliasing a mutable reference\n+# Example: aliasing a mutable reference\n \n How about the other example:\n "}, {"sha": "da70dd529078b3cee5c71ddb70b3fb2101fb2911", "filename": "src/doc/tarpl/references.md", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b53406f8241edb45eb962795da99cb2cf73d8c1a/src%2Fdoc%2Ftarpl%2Freferences.md", "raw_url": "https://github.com/rust-lang/rust/raw/b53406f8241edb45eb962795da99cb2cf73d8c1a/src%2Fdoc%2Ftarpl%2Freferences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Freferences.md?ref=b53406f8241edb45eb962795da99cb2cf73d8c1a", "patch": "@@ -1,59 +1,76 @@\n % References\n \n+This section gives a high-level view of the memory model that *all* Rust\n+programs must satisfy to be correct. Safe code is statically verified\n+to obey this model by the borrow checker. Unsafe code may go above\n+and beyond the borrow checker while still satisfying this model. The borrow\n+checker may also be extended to allow more programs to compile, as long as\n+this more fundamental model is satisfied.\n+\n There are two kinds of reference:\n \n * Shared reference: `&`\n * Mutable reference: `&mut`\n \n Which obey the following rules:\n \n-* A reference cannot outlive its referent A mutable reference cannot be aliased\n+* A reference cannot outlive its referent\n+* A mutable reference cannot be aliased\n \n-To define aliasing, we must define the notion of *paths* and *liveness*.\n+That's it. That's the whole model. Of course, we should probably define\n+what *aliased* means. To define aliasing, we must define the notion of\n+*paths* and *liveness*.\n \n \n \n \n # Paths\n \n-If all Rust had were values, then every value would be uniquely owned by a\n-variable or composite structure. From this we naturally derive a *tree* of\n-ownership. The stack itself is the root of the tree, with every variable as its\n-direct children. Each variable's direct children would be their fields (if any),\n-and so on.\n+If all Rust had were values (no pointers), then every value would be uniquely\n+owned by a variable or composite structure. From this we naturally derive a\n+*tree* of ownership. The stack itself is the root of the tree, with every\n+variable as its direct children. Each variable's direct children would be their\n+fields (if any), and so on.\n \n From this view, every value in Rust has a unique *path* in the tree of\n-ownership. References to a value can subsequently be interpreted as a path in\n-this tree. Of particular interest are *ancestors* and *descendants*: if `x` owns\n-`y`, then `x` is an *ancestor* of `y`, and `y` is a *descendant* of `x`. Note\n+ownership. Of particular interest are *ancestors* and *descendants*: if `x` owns\n+`y`, then `x` is an ancestor of `y`, and `y` is a descendant of `x`. Note\n that this is an inclusive relationship: `x` is a descendant and ancestor of\n itself.\n \n+We can then define references as simply *names* for paths. When you create a\n+reference, you're declaring that an ownership path exists to this address\n+of memory.\n+\n Tragically, plenty of data doesn't reside on the stack, and we must also\n accommodate this. Globals and thread-locals are simple enough to model as\n residing at the bottom of the stack (though we must be careful with mutable\n globals). Data on the heap poses a different problem.\n \n If all Rust had on the heap was data uniquely owned by a pointer on the stack,\n-then we can just treat that pointer as a struct that owns the value on the heap.\n-Box, Vec, String, and HashMap, are examples of types which uniquely own data on\n-the heap.\n+then we could just treat such a pointer as a struct that owns the value on the\n+heap. Box, Vec, String, and HashMap, are examples of types which uniquely\n+own data on the heap.\n \n Unfortunately, data on the heap is not *always* uniquely owned. Rc for instance\n-introduces a notion of *shared* ownership. Shared ownership means there is no\n-unique path. A value with no unique path limits what we can do with it. In\n-general, only shared references can be created to these values. However\n+introduces a notion of *shared* ownership. Shared ownership of a value means\n+there is no unique path to it. A value with no unique path limits what we can do\n+with it.\n+\n+In general, only shared references can be created to non-unique paths. However\n mechanisms which ensure mutual exclusion may establish One True Owner\n-temporarily, establishing a unique path to that value (and therefore all its\n-children).\n+temporarily, establishing a unique path to that value (and therefore all\n+its children). If this is done, the value may be mutated. In particular, a\n+mutable reference can be taken.\n \n The most common way to establish such a path is through *interior mutability*,\n in contrast to the *inherited mutability* that everything in Rust normally uses.\n Cell, RefCell, Mutex, and RWLock are all examples of interior mutability types.\n-These types provide exclusive access through runtime restrictions. However it is\n-also possible to establish unique ownership without interior mutability. For\n-instance, if an Rc has refcount 1, then it is safe to mutate or move its\n-internals.\n+These types provide exclusive access through runtime restrictions.\n+\n+An interesting case of this effect is Rc itself: if an Rc has refcount 1,\n+then it is safe to mutate or even move its internals. Note however that the\n+refcount itself uses interior mutability.\n \n In order to correctly communicate to the type system that a variable or field of\n a struct can have interior mutability, it must be wrapped in an UnsafeCell. This\n@@ -62,6 +79,7 @@ that value. You still must yourself ensure that mutual exclusion is upheld.\n \n \n \n+\n # Liveness\n \n Note: Liveness is not the same thing as a *lifetime*, which will be explained"}, {"sha": "8c5ac9cca6b3fdbc7631aa27fa247608080f2d7f", "filename": "src/doc/tarpl/subtyping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b53406f8241edb45eb962795da99cb2cf73d8c1a/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/b53406f8241edb45eb962795da99cb2cf73d8c1a/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=b53406f8241edb45eb962795da99cb2cf73d8c1a", "patch": "@@ -100,7 +100,7 @@ subsequently be dropped, and `forever_str` would point to freed memory when we\n print it! Therefore `&mut` should be invariant.\n \n This is the general theme of variance vs invariance: if variance would allow you\n-to *store* a short-lived value over a longer-lived slot, then you must be\n+to store a short-lived value into a longer-lived slot, then you must be\n invariant.\n \n However it *is* sound for `&'a mut T` to be variant over `'a`. The key difference"}]}