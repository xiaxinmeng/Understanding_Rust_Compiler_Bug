{"sha": "e75b4fc85e82c749d1b961841b55ca1345fdf6f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NWI0ZmM4NWU4MmM3NDlkMWI5NjE4NDFiNTVjYTEzNDVmZGY2Zjc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-02T13:55:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-02T13:55:14Z"}, "message": "Merge #5189\n\n5189: Record and suggest assoc. items of traits via ImportMap r=matklad a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5115\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "39760746c3e619f9a991dbb89dc64fe1494c5b9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39760746c3e619f9a991dbb89dc64fe1494c5b9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e75b4fc85e82c749d1b961841b55ca1345fdf6f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/edCCRBK7hj4Ov3rIwAAdHIIAEAxBWUmRsttwOawcfGpLgMR\nrWoRD6F93emxz5THeZBV16eqtOcBAzGYnVewTtpjvnZi3d0nZknzJkR3hBX0wHJt\n72Ytx7IiINxDZymZ/+8/ajuGDpRwSk8QzbzuNdWBUoQ0pM5QU+zrueqVo4/96VTH\nze55vzwS1/Je2mS5JP1a3BFyYHverUR+2HmS2jxxgkFihH/j38dR2WTc80VXlv5v\nG4w0FfluvgzzU6qs2YE3ZHI1gb0pcm73gog5bF/0RdbP5ZTDpEPocb3Je7KvTDQ8\n+k2CeHYt9RAaC5HRrGQG5rKB8jrSiArT3r7Tx/Ap5G9x+5Pkz6+Jn1sPl0p/SGY=\n=YNxi\n-----END PGP SIGNATURE-----\n", "payload": "tree 39760746c3e619f9a991dbb89dc64fe1494c5b9d\nparent 57ed622ec4f0f71a618f99a46aa0026e81eb2583\nparent 6ee73cd334d927e6ff4b7225d653dacca3293ae5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593698114 +0000\ncommitter GitHub <noreply@github.com> 1593698114 +0000\n\nMerge #5189\n\n5189: Record and suggest assoc. items of traits via ImportMap r=matklad a=jonas-schievink\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5115\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e75b4fc85e82c749d1b961841b55ca1345fdf6f7", "html_url": "https://github.com/rust-lang/rust/commit/e75b4fc85e82c749d1b961841b55ca1345fdf6f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e75b4fc85e82c749d1b961841b55ca1345fdf6f7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ed622ec4f0f71a618f99a46aa0026e81eb2583", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ed622ec4f0f71a618f99a46aa0026e81eb2583", "html_url": "https://github.com/rust-lang/rust/commit/57ed622ec4f0f71a618f99a46aa0026e81eb2583"}, {"sha": "6ee73cd334d927e6ff4b7225d653dacca3293ae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee73cd334d927e6ff4b7225d653dacca3293ae5", "html_url": "https://github.com/rust-lang/rust/commit/6ee73cd334d927e6ff4b7225d653dacca3293ae5"}], "stats": {"total": 216, "additions": 207, "deletions": 9}, "files": [{"sha": "4cd77adbfe2a31d4e17b3a4ae7384314071cdd87", "filename": "crates/ra_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e75b4fc85e82c749d1b961841b55ca1345fdf6f7/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75b4fc85e82c749d1b961841b55ca1345fdf6f7/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=e75b4fc85e82c749d1b961841b55ca1345fdf6f7", "patch": "@@ -810,6 +810,146 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn trait_method_cross_crate() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+            r\"\n+            use dep::test_mod::TestTrait;\n+\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_method()\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_cross_crate() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::test_func<|>tion\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+            r\"\n+            use dep::test_mod::TestTrait;\n+\n+            fn main() {\n+                dep::test_mod::TestStruct::test_function\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_const_cross_crate() {\n+        check_assist(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                dep::test_mod::TestStruct::CONST<|>\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    const CONST: bool;\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    const CONST: bool = true;\n+                }\n+            }\n+            \",\n+            r\"\n+            use dep::test_mod::TestTrait;\n+\n+            fn main() {\n+                dep::test_mod::TestStruct::CONST\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_fn_as_method_cross_crate() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_func<|>tion()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                pub trait TestTrait {\n+                    fn test_function();\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_function() {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn private_trait_cross_crate() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            //- /main.rs crate:main deps:dep\n+            fn main() {\n+                let test_struct = dep::test_mod::TestStruct {};\n+                test_struct.test_meth<|>od()\n+            }\n+            //- /dep.rs crate:dep\n+            pub mod test_mod {\n+                trait TestTrait {\n+                    fn test_method(&self);\n+                }\n+                pub struct TestStruct {}\n+                impl TestTrait for TestStruct {\n+                    fn test_method(&self) {}\n+                }\n+            }\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn not_applicable_for_imported_trait_for_method() {\n         check_assist_not_applicable("}, {"sha": "869f3ca5a81f2121083361ad4392e57643ddeb81", "filename": "crates/ra_hir_def/src/import_map.rs", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e75b4fc85e82c749d1b961841b55ca1345fdf6f7/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75b4fc85e82c749d1b961841b55ca1345fdf6f7/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fimport_map.rs?ref=e75b4fc85e82c749d1b961841b55ca1345fdf6f7", "patch": "@@ -5,14 +5,16 @@ use std::{cmp::Ordering, fmt, hash::BuildHasherDefault, sync::Arc};\n use fst::{self, Streamer};\n use indexmap::{map::Entry, IndexMap};\n use ra_db::CrateId;\n-use rustc_hash::FxHasher;\n+use ra_syntax::SmolStr;\n+use rustc_hash::{FxHashMap, FxHasher};\n+use smallvec::SmallVec;\n \n use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n     visibility::Visibility,\n-    ModuleDefId, ModuleId,\n+    AssocItemId, ModuleDefId, ModuleId, TraitId,\n };\n \n type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n@@ -34,6 +36,7 @@ pub struct ImportInfo {\n ///\n /// Note that all paths are relative to the containing crate's root, so the crate name still needs\n /// to be prepended to the `ModPath` before the path is valid.\n+#[derive(Default)]\n pub struct ImportMap {\n     map: FxIndexMap<ItemInNs, ImportInfo>,\n \n@@ -45,13 +48,17 @@ pub struct ImportMap {\n     /// the index of the first one.\n     importables: Vec<ItemInNs>,\n     fst: fst::Map<Vec<u8>>,\n+\n+    /// Maps names of associated items to the item's ID. Only includes items whose defining trait is\n+    /// exported.\n+    assoc_map: FxHashMap<SmolStr, SmallVec<[AssocItemId; 1]>>,\n }\n \n impl ImportMap {\n     pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n         let _p = ra_prof::profile(\"import_map_query\");\n         let def_map = db.crate_def_map(krate);\n-        let mut import_map = FxIndexMap::with_capacity_and_hasher(64, Default::default());\n+        let mut import_map = Self::default();\n \n         // We look only into modules that are public(ly reexported), starting with the crate root.\n         let empty = ModPath { kind: PathKind::Plain, segments: vec![] };\n@@ -85,7 +92,7 @@ impl ImportMap {\n \n                 for item in per_ns.iter_items() {\n                     let path = mk_path();\n-                    match import_map.entry(item) {\n+                    match import_map.map.entry(item) {\n                         Entry::Vacant(entry) => {\n                             entry.insert(ImportInfo { path, container: module });\n                         }\n@@ -105,11 +112,16 @@ impl ImportMap {\n                     if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n                         worklist.push((mod_id, mk_path()));\n                     }\n+\n+                    // If we've added a path to a trait, add the trait's methods to the method map.\n+                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                        import_map.collect_trait_methods(db, tr);\n+                    }\n                 }\n             }\n         }\n \n-        let mut importables = import_map.iter().collect::<Vec<_>>();\n+        let mut importables = import_map.map.iter().collect::<Vec<_>>();\n \n         importables.sort_by(cmp);\n \n@@ -133,10 +145,10 @@ impl ImportMap {\n             builder.insert(key, start as u64).unwrap();\n         }\n \n-        let fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n-        let importables = importables.iter().map(|(item, _)| **item).collect();\n+        import_map.fst = fst::Map::new(builder.into_inner().unwrap()).unwrap();\n+        import_map.importables = importables.iter().map(|(item, _)| **item).collect();\n \n-        Arc::new(Self { map: import_map, fst, importables })\n+        Arc::new(import_map)\n     }\n \n     /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n@@ -147,6 +159,13 @@ impl ImportMap {\n     pub fn import_info_for(&self, item: ItemInNs) -> Option<&ImportInfo> {\n         self.map.get(&item)\n     }\n+\n+    fn collect_trait_methods(&mut self, db: &dyn DefDatabase, tr: TraitId) {\n+        let data = db.trait_data(tr);\n+        for (name, item) in data.items.iter() {\n+            self.assoc_map.entry(name.to_string().into()).or_default().push(*item);\n+        }\n+    }\n }\n \n impl PartialEq for ImportMap {\n@@ -290,13 +309,26 @@ pub fn search_dependencies<'a>(\n         }\n     }\n \n+    // Add all exported associated items whose names match the query (exactly).\n+    for map in &import_maps {\n+        if let Some(v) = map.assoc_map.get(&*query.query) {\n+            res.extend(v.iter().map(|&assoc| {\n+                ItemInNs::Types(match assoc {\n+                    AssocItemId::FunctionId(it) => it.into(),\n+                    AssocItemId::ConstId(it) => it.into(),\n+                    AssocItemId::TypeAliasId(it) => it.into(),\n+                })\n+            }));\n+        }\n+    }\n+\n     res\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_db::TestDB;\n+    use crate::{test_db::TestDB, AssocContainerId, Lookup};\n     use insta::assert_snapshot;\n     use itertools::Itertools;\n     use ra_db::fixture::WithFixture;\n@@ -339,6 +371,7 @@ mod tests {\n                     ItemInNs::Values(_) => \"v\",\n                     ItemInNs::Macros(_) => \"m\",\n                 };\n+                let item = assoc_to_trait(&db, item);\n                 item.krate(db.upcast()).map(|krate| {\n                     let map = db.import_map(krate);\n                     let path = map.path_of(item).unwrap();\n@@ -353,6 +386,29 @@ mod tests {\n             .join(\"\\n\")\n     }\n \n+    fn assoc_to_trait(db: &dyn DefDatabase, item: ItemInNs) -> ItemInNs {\n+        let assoc: AssocItemId = match item {\n+            ItemInNs::Types(it) | ItemInNs::Values(it) => match it {\n+                ModuleDefId::TypeAliasId(it) => it.into(),\n+                ModuleDefId::FunctionId(it) => it.into(),\n+                ModuleDefId::ConstId(it) => it.into(),\n+                _ => return item,\n+            },\n+            _ => return item,\n+        };\n+\n+        let container = match assoc {\n+            AssocItemId::FunctionId(it) => it.lookup(db).container,\n+            AssocItemId::ConstId(it) => it.lookup(db).container,\n+            AssocItemId::TypeAliasId(it) => it.lookup(db).container,\n+        };\n+\n+        match container {\n+            AssocContainerId::TraitId(it) => ItemInNs::Types(it.into()),\n+            _ => item,\n+        }\n+    }\n+\n     #[test]\n     fn smoke() {\n         let map = import_map(\n@@ -610,6 +666,7 @@ mod tests {\n         dep::Fmt (m)\n         dep::fmt::Display (t)\n         dep::format (v)\n+        dep::fmt::Display (t)\n         \"###);\n \n         let res = search_dependencies_of(ra_fixture, \"main\", Query::new(\"fmt\").anchor_end());\n@@ -618,6 +675,7 @@ mod tests {\n         dep::Fmt (t)\n         dep::Fmt (v)\n         dep::Fmt (m)\n+        dep::fmt::Display (t)\n         \"###);\n     }\n "}]}