{"sha": "4195b60323046c86d9431e82665de6d2f71a2289", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOTViNjAzMjMwNDZjODZkOTQzMWU4MjY2NWRlNmQyZjcxYTIyODk=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-08T21:53:36Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-27T19:28:15Z"}, "message": "Rename `cmt_` to `Place`", "tree": {"sha": "f05c2b11a1d51f6a758ec8ae82ab3bb35d158770", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f05c2b11a1d51f6a758ec8ae82ab3bb35d158770"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4195b60323046c86d9431e82665de6d2f71a2289", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4195b60323046c86d9431e82665de6d2f71a2289", "html_url": "https://github.com/rust-lang/rust/commit/4195b60323046c86d9431e82665de6d2f71a2289", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4195b60323046c86d9431e82665de6d2f71a2289/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04e69e4f4234beb4f12cc76dcc53e2cc4247a9be", "url": "https://api.github.com/repos/rust-lang/rust/commits/04e69e4f4234beb4f12cc76dcc53e2cc4247a9be", "html_url": "https://github.com/rust-lang/rust/commit/04e69e4f4234beb4f12cc76dcc53e2cc4247a9be"}], "stats": {"total": 104, "additions": 52, "deletions": 52}, "files": [{"sha": "2b18ecb169ecd97ff649722964e99d89e5ef7e63", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4195b60323046c86d9431e82665de6d2f71a2289", "patch": "@@ -25,13 +25,13 @@ use syntax_pos::Span;\n pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, cmt: &mc::cmt_<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, cmt: &mc::Place<'tcx>, mode: ConsumeMode);\n \n     // The value found at `cmt` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, cmt: &mc::cmt_<'tcx>, bk: ty::BorrowKind);\n+    fn borrow(&mut self, cmt: &mc::Place<'tcx>, bk: ty::BorrowKind);\n \n     // The path at `cmt` is being assigned to.\n-    fn mutate(&mut self, assignee_cmt: &mc::cmt_<'tcx>);\n+    fn mutate(&mut self, assignee_cmt: &mc::Place<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.mc.tcx\n     }\n \n-    fn delegate_consume(&mut self, cmt: &mc::cmt_<'tcx>) {\n+    fn delegate_consume(&mut self, cmt: &mc::Place<'tcx>) {\n         debug!(\"delegate_consume(cmt={:?})\", cmt);\n \n         let mode = copy_or_move(&self.mc, self.param_env, cmt);\n@@ -528,7 +528,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// after all relevant autoderefs have occurred.\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n-                    cmt_base: &mc::cmt_<'tcx>,\n+                    cmt_base: &mc::Place<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n         debug!(\"walk_autoref(expr.hir_id={} cmt_base={:?} autoref={:?})\",\n                expr.hir_id,\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         closure_hir_id: hir::HirId,\n                         closure_span: Span,\n                         var_id: hir::HirId)\n-                        -> mc::McResult<mc::cmt_<'tcx>> {\n+                        -> mc::McResult<mc::Place<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;\n@@ -656,7 +656,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    cmt: &mc::cmt_<'tcx>,\n+    cmt: &mc::Place<'tcx>,\n ) -> ConsumeMode {\n     if !mc.type_is_copy_modulo_regions(param_env, cmt.ty, cmt.span) {\n         Move"}, {"sha": "1b641cba770a83477f452d6a4c6acfc5b90392bd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4195b60323046c86d9431e82665de6d2f71a2289", "patch": "@@ -184,7 +184,7 @@ pub enum Note {\n // dereference (`@T`). So use `cmt.ty` to find the type of the value in\n // a consistent fashion. For more details, see the method `cat_pattern`\n #[derive(Clone, Debug, PartialEq)]\n-pub struct cmt_<'tcx> {\n+pub struct Place<'tcx> {\n     pub hir_id: hir::HirId,        // HIR id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n     pub cat: Categorization<'tcx>, // categorization of expr\n@@ -193,7 +193,7 @@ pub struct cmt_<'tcx> {\n     pub note: Note,                // Note about the provenance of this cmt\n }\n \n-pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n+pub type cmt<'tcx> = Rc<Place<'tcx>>;\n \n pub trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n@@ -504,14 +504,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n+    pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n             mc: &MemCategorizationContext<'a, 'tcx>,\n             expr: &hir::Expr,\n             adjustments: &[adjustment::Adjustment<'tcx>],\n-        ) -> McResult<cmt_<'tcx>> {\n+        ) -> McResult<Place<'tcx>> {\n             match adjustments.split_last() {\n                 None => mc.cat_expr_unadjusted(expr),\n                 Some((adjustment, previous)) => {\n@@ -524,17 +524,17 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     }\n \n     pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n-                             previous: cmt_<'tcx>,\n+                             previous: Place<'tcx>,\n                              adjustment: &adjustment::Adjustment<'tcx>)\n-                             -> McResult<cmt_<'tcx>> {\n+                             -> McResult<Place<'tcx>> {\n         self.cat_expr_adjusted_with(expr, || Ok(previous), adjustment)\n     }\n \n     fn cat_expr_adjusted_with<F>(&self, expr: &hir::Expr,\n                                  previous: F,\n                                  adjustment: &adjustment::Adjustment<'tcx>)\n-                                 -> McResult<cmt_<'tcx>>\n-        where F: FnOnce() -> McResult<cmt_<'tcx>>\n+                                 -> McResult<Place<'tcx>>\n+        where F: FnOnce() -> McResult<Place<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n         let target = self.resolve_vars_if_possible(&adjustment.target);\n@@ -562,7 +562,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n+    pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<Place<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -630,7 +630,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n                    res: Res)\n-                   -> McResult<cmt_<'tcx>> {\n+                   -> McResult<Place<'tcx>> {\n         debug!(\"cat_res: id={:?} expr={:?} def={:?}\",\n                hir_id, expr_ty, res);\n \n@@ -658,7 +658,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     Categorization::StaticItem\n                 };\n \n-                Ok(cmt_ {\n+                Ok(Place {\n                     hir_id,\n                     span,\n                     cat,\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n                     self.cat_upvar(hir_id, span, var_id)\n                 } else {\n-                    Ok(cmt_ {\n+                    Ok(Place {\n                         hir_id,\n                         span,\n                         cat: Categorization::Local(var_id),\n@@ -697,7 +697,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         hir_id: hir::HirId,\n         span: Span,\n         var_id: hir::HirId,\n-    ) -> McResult<cmt_<'tcx>> {\n+    ) -> McResult<Place<'tcx>> {\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n         // field from the environment.\n@@ -758,7 +758,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // Construct the upvar. This represents access to the field\n         // from the environment (perhaps we should eventually desugar\n         // this field further, but it will do for now).\n-        let cmt_result = cmt_ {\n+        let cmt_result = Place {\n             hir_id,\n             span,\n             cat: Categorization::Upvar(Upvar {id: upvar_id, kind: kind}),\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n             ty::UpvarCapture::ByRef(upvar_borrow) => {\n                 let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n-                cmt_ {\n+                Place {\n                     hir_id,\n                     span,\n                     cat: Categorization::Deref(Rc::new(cmt_result), ptr),\n@@ -814,8 +814,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                  upvar_id: ty::UpvarId,\n                  upvar_mutbl: MutabilityCategory,\n                  env_borrow_kind: ty::BorrowKind,\n-                 cmt_result: cmt_<'tcx>)\n-                 -> cmt_<'tcx>\n+                 cmt_result: Place<'tcx>)\n+                 -> Place<'tcx>\n     {\n         // Region of environment pointer\n         let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n@@ -837,7 +837,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // away with stuffing a `Error` in there\n         // instead of bothering to construct a proper\n         // one.\n-        let cmt_result = cmt_ {\n+        let cmt_result = Place {\n             mutbl: McImmutable,\n             ty: self.tcx.types.err,\n             ..cmt_result\n@@ -852,7 +852,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             McDeclared | McInherited => { }\n         }\n \n-        let ret = cmt_ {\n+        let ret = Place {\n             hir_id,\n             span,\n             cat: Categorization::Deref(Rc::new(cmt_result), env_ptr),\n@@ -870,7 +870,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                            hir_id: hir::HirId,\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n-                           -> cmt_<'tcx> {\n+                           -> Place<'tcx> {\n         debug!(\"cat_rvalue_node(id={:?}, span={:?}, expr_ty={:?})\",\n                hir_id, span, expr_ty);\n \n@@ -882,8 +882,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     pub fn cat_rvalue(&self,\n                       cmt_hir_id: hir::HirId,\n                       span: Span,\n-                      expr_ty: Ty<'tcx>) -> cmt_<'tcx> {\n-        let ret = cmt_ {\n+                      expr_ty: Ty<'tcx>) -> Place<'tcx> {\n+        let ret = Place {\n             hir_id: cmt_hir_id,\n             span:span,\n             cat:Categorization::Rvalue,\n@@ -901,8 +901,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                                  f_index: usize,\n                                  f_ident: ast::Ident,\n                                  f_ty: Ty<'tcx>)\n-                                 -> cmt_<'tcx> {\n-        let ret = cmt_ {\n+                                 -> Place<'tcx> {\n+        let ret = Place {\n             hir_id: node.hir_id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n@@ -920,7 +920,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         expr: &hir::Expr,\n         base: &hir::Expr,\n         note: Note,\n-    ) -> McResult<cmt_<'tcx>> {\n+    ) -> McResult<Place<'tcx>> {\n         debug!(\"cat_overloaded_place(expr={:?}, base={:?}, note={:?})\",\n                expr,\n                base,\n@@ -950,7 +950,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         node: &impl HirNode,\n         base_cmt: cmt<'tcx>,\n         note: Note,\n-    ) -> McResult<cmt_<'tcx>> {\n+    ) -> McResult<Place<'tcx>> {\n         debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n \n         let base_cmt_ty = base_cmt.ty;\n@@ -971,7 +971,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n             _ => bug!(\"unexpected type in cat_deref: {:?}\", base_cmt.ty)\n         };\n-        let ret = cmt_ {\n+        let ret = Place {\n             hir_id: node.hir_id(),\n             span: node.span(),\n             // For unique ptrs, we inherit mutability from the owning reference.\n@@ -989,7 +989,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                              base_cmt: cmt<'tcx>,\n                              element_ty: Ty<'tcx>,\n                              context: InteriorOffsetKind)\n-                             -> McResult<cmt_<'tcx>> {\n+                             -> McResult<Place<'tcx>> {\n         //! Creates a cmt for an indexing operation (`[]`).\n         //!\n         //! One subtle aspect of indexing that may not be\n@@ -1018,8 +1018,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                                        base_cmt: cmt<'tcx>,\n                                        interior_ty: Ty<'tcx>,\n                                        interior: InteriorKind)\n-                                       -> cmt_<'tcx> {\n-        let ret = cmt_ {\n+                                       -> Place<'tcx> {\n+        let ret = Place {\n             hir_id: node.hir_id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let base_did = self.tcx.parent(variant_did).unwrap();\n         if self.tcx.adt_def(base_did).variants.len() != 1 {\n             let base_ty = base_cmt.ty;\n-            let ret = Rc::new(cmt_ {\n+            let ret = Rc::new(Place {\n                 hir_id: node.hir_id(),\n                 span: node.span(),\n                 mutbl: base_cmt.mutbl.inherit(),\n@@ -1327,8 +1327,8 @@ pub enum AliasableReason {\n     AliasableStaticMut,\n }\n \n-impl<'tcx> cmt_<'tcx> {\n-    pub fn guarantor(&self) -> cmt_<'tcx> {\n+impl<'tcx> Place<'tcx> {\n+    pub fn guarantor(&self) -> Place<'tcx> {\n         //! Returns `self` after stripping away any derefs or\n         //! interior content. The return value is basically the `cmt` which\n         //! determines how long the value in `self` remains live."}, {"sha": "170c4acad8b400b057707c4341062df843684f1f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4195b60323046c86d9431e82665de6d2f71a2289", "patch": "@@ -825,7 +825,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt_<'tcx>> {\n+    fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::Place<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n         let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n@@ -921,7 +921,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::cmt_<'tcx>, span: Span) {\n+    fn check_safety_of_rvalue_destructor_if_necessary(&mut self, cmt: &mc::Place<'tcx>, span: Span) {\n         if let Categorization::Rvalue = cmt.cat {\n             let typ = self.resolve_type(cmt.ty);\n             let body_id = self.body_id;\n@@ -1100,7 +1100,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     fn link_autoref(\n         &self,\n         expr: &hir::Expr,\n-        expr_cmt: &mc::cmt_<'tcx>,\n+        expr_cmt: &mc::Place<'tcx>,\n         autoref: &adjustment::AutoBorrow<'tcx>,\n     ) {\n         debug!(\n@@ -1130,7 +1130,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         id: hir::HirId,\n         mutbl: hir::Mutability,\n-        cmt_borrowed: &mc::cmt_<'tcx>,\n+        cmt_borrowed: &mc::Place<'tcx>,\n     ) {\n         debug!(\n             \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n@@ -1153,7 +1153,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         span: Span,\n         borrow_region: ty::Region<'tcx>,\n         borrow_kind: ty::BorrowKind,\n-        borrow_cmt: &mc::cmt_<'tcx>,\n+        borrow_cmt: &mc::Place<'tcx>,\n     ) {\n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n         self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);"}, {"sha": "5d17074e65e4e195e0cb1a3ad842cf1fdaeacb72", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4195b60323046c86d9431e82665de6d2f71a2289/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=4195b60323046c86d9431e82665de6d2f71a2289", "patch": "@@ -312,7 +312,7 @@ struct InferBorrowKind<'a, 'tcx> {\n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(\n         &mut self,\n-        cmt: &mc::cmt_<'tcx>,\n+        cmt: &mc::Place<'tcx>,\n         mode: euv::ConsumeMode,\n     ) {\n         debug!(\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n     /// Indicates that `cmt` is being directly mutated (e.g., assigned\n     /// to). If cmt contains any by-ref upvars, this implies that\n     /// those upvars must be borrowed using an `&mut` borrow.\n-    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: &mc::cmt_<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_mut(&mut self, cmt: &mc::Place<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n@@ -421,7 +421,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: &mc::cmt_<'tcx>) {\n+    fn adjust_upvar_borrow_kind_for_unique(&mut self, cmt: &mc::Place<'tcx>) {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n     fn try_adjust_upvar_deref(\n         &mut self,\n-        cmt: &mc::cmt_<'tcx>,\n+        cmt: &mc::Place<'tcx>,\n         borrow_kind: ty::BorrowKind,\n     ) -> bool {\n         assert!(match borrow_kind {\n@@ -586,12 +586,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn consume(&mut self, cmt: &mc::cmt_<'tcx>,mode: euv::ConsumeMode) {\n+    fn consume(&mut self, cmt: &mc::Place<'tcx>,mode: euv::ConsumeMode) {\n         debug!(\"consume(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn borrow(&mut self, cmt: &mc::cmt_<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &mc::Place<'tcx>, bk: ty::BorrowKind) {\n         debug!(\"borrow(cmt={:?}, bk={:?})\", cmt, bk);\n \n         match bk {\n@@ -605,7 +605,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n     }\n \n-    fn mutate(&mut self, assignee_cmt: &mc::cmt_<'tcx>) {\n+    fn mutate(&mut self, assignee_cmt: &mc::Place<'tcx>) {\n         debug!(\"mutate(assignee_cmt={:?})\", assignee_cmt);\n \n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);"}]}