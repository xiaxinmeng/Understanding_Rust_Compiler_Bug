{"sha": "d09412ab893f54ef5309cf63d17bcb6110d582b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOTQxMmFiODkzZjU0ZWY1MzA5Y2Y2M2QxN2JjYjYxMTBkNTgyYjk=", "commit": {"author": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-07T11:05:06Z"}, "committer": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-19T23:26:50Z"}, "message": "Homed UDP sockets", "tree": {"sha": "a671032792b1fa050e395dc05c0d9aea5c8c8f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a671032792b1fa050e395dc05c0d9aea5c8c8f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d09412ab893f54ef5309cf63d17bcb6110d582b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d09412ab893f54ef5309cf63d17bcb6110d582b9", "html_url": "https://github.com/rust-lang/rust/commit/d09412ab893f54ef5309cf63d17bcb6110d582b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d09412ab893f54ef5309cf63d17bcb6110d582b9/comments", "author": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3", "html_url": "https://github.com/rust-lang/rust/commit/d7b6fcba2978cbbcfccce83e6f4f54c5eec998f3"}], "stats": {"total": 237, "additions": 213, "deletions": 24}, "files": [{"sha": "2bec782847b387182a9329781dced2b9ff744b32", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d09412ab893f54ef5309cf63d17bcb6110d582b9/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09412ab893f54ef5309cf63d17bcb6110d582b9/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=d09412ab893f54ef5309cf63d17bcb6110d582b9", "patch": "@@ -22,7 +22,7 @@ pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n-pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n+pub type RtioUdpSocketObject = uvio::HomedUvUdpSocket; //uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n \n pub trait EventLoop {"}, {"sha": "43be09434a4c491e9d8377de089ae8ba95500e76", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 212, "deletions": 23, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/d09412ab893f54ef5309cf63d17bcb6110d582b9/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09412ab893f54ef5309cf63d17bcb6110d582b9/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=d09412ab893f54ef5309cf63d17bcb6110d582b9", "patch": "@@ -239,27 +239,6 @@ impl UvIoFactory {\n     pub fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n-\n-    pub fn homed_udp_bind(&mut self, addr: SocketAddr) -> Result<~HomedUvUdpSocket, IoError> {\n-        let mut watcher = UdpWatcher::new(self.uv_loop());\n-        match watcher.bind(addr) {\n-            Ok(_) => {\n-                let home = do Local::borrow::<Scheduler, SchedHandle> |sched| {sched.make_handle()};\n-                Ok(~HomedUvUdpSocket { watcher: watcher, home: home })\n-            }\n-            Err(uverr) => {\n-                let scheduler = Local::take::<Scheduler>();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    do watcher.close {\n-                        let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-                Err(uv_error_to_io_error(uverr))\n-            }\n-        }\n-    }\n }\n \n impl IoFactory for UvIoFactory {\n@@ -331,6 +310,7 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n+    /*\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError> {\n         let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n@@ -348,6 +328,28 @@ impl IoFactory for UvIoFactory {\n             }\n         }\n     }\n+    */\n+\n+    pub fn /*homed_*/udp_bind(&mut self, addr: SocketAddr) -> Result<~/*HomedUvUdpSocket*/RtioUdpSocketObject, IoError> {\n+        let mut watcher = UdpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => {\n+                let home = do Local::borrow::<Scheduler, SchedHandle> |sched| {sched.make_handle()};\n+                Ok(~HomedUvUdpSocket { watcher: watcher, home: home })\n+            }\n+            Err(uverr) => {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do watcher.close {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n \n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError> {\n         Ok(~UvTimer(TimerWatcher::new(self.uv_loop())))\n@@ -640,18 +642,205 @@ impl Drop for HomedUvUdpSocket {\n \n impl RtioSocket for HomedUvUdpSocket {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+\t// first go home\n         self.go_home();\n         socket_name(Udp, self.watcher)\n     }\n }\n \n+impl RtioUdpSocket for HomedUvUdpSocket {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+\tlet result_cell = Cell::new_empty();\n+\tlet result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n+\n+\tlet scheduler = Local::take::<Scheduler>();\n+\tlet buf_ptr: *&mut [u8] = &buf;\n+\tdo scheduler.deschedule_running_task_and_then |_, task| {\n+\t    rtdebug!(\"recvfrom: entered scheduler context\");\n+\t    let task_cell = Cell::new(task);\n+\t    let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+\t    do self.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n+\t\tlet _ = flags; // /XXX add handling for partials?\n+\n+\t\twatcher.recv_stop();\n+\n+\t\tlet result = match status {\n+\t\t    None => {\n+\t\t\tassert!(nread >= 0);\n+\t\t\tOk((nread as uint, addr))\n+\t\t    }\n+\t\t    Some(err) => Err(uv_error_to_io_error(err)),\n+\t\t};\n+\n+\t\tunsafe { (*result_cell_ptr).put_back(result); }\n+\n+\t\tlet scheduler = Local::take::<Scheduler>();\n+\t\tscheduler.resume_blocked_task_immediately(task_cell.take());\n+\t    }\n+\t}\n+\n+\tassert!(!result_cell.is_empty());\n+\treturn result_cell.take();\n+    }\n+\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+\tlet result_cell = Cell::new_empty();\n+\tlet result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let scheduler = Local::take::<Scheduler>();\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell::new(task);\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do self.watcher.send(buf, dst) |_watcher, status| {\n+\n+                let result = match status {\n+                    None => Ok(()),\n+                    Some(err) => Err(uv_error_to_io_error(err)),\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_blocked_task_immediately(task_cell.take());\n+            }\n+        }\n+\n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n+    }\n+\n+    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            do multi.to_str().as_c_str |m_addr| {\n+                uvll::udp_set_membership(self.watcher.native_handle(), m_addr,\n+                                         ptr::null(), uvll::UV_JOIN_GROUP)\n+            }\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            do multi.to_str().as_c_str |m_addr| {\n+                uvll::udp_set_membership(self.watcher.native_handle(), m_addr,\n+                                         ptr::null(), uvll::UV_LEAVE_GROUP)\n+            }\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            uvll::udp_set_multicast_loop(self.watcher.native_handle(), 1 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            uvll::udp_set_multicast_loop(self.watcher.native_handle(), 0 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            uvll::udp_set_multicast_ttl(self.watcher.native_handle(), ttl as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            uvll::udp_set_ttl(self.watcher.native_handle(), ttl as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            uvll::udp_set_broadcast(self.watcher.native_handle(), 1 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+\n+    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n+\t// first go home\n+\tself.go_home();\n+\n+        let r = unsafe {\n+            uvll::udp_set_broadcast(self.watcher.native_handle(), 0 as c_int)\n+        };\n+\n+        match status_to_maybe_uv_error(self.watcher, r) {\n+            Some(err) => Err(uv_error_to_io_error(err)),\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n #[test]\n fn test_simple_homed_udp_io_bind_only() {\n     do run_in_newsched_task {\n         unsafe {\n             let io = Local::unsafe_borrow::<IoFactoryObject>();\n             let addr = next_test_ip4();\n-            let maybe_socket = (*io).homed_udp_bind(addr);\n+            let maybe_socket = (*io)./*homed_*/udp_bind(addr);\n             assert!(maybe_socket.is_ok());\n         }\n     }\n@@ -688,7 +877,7 @@ fn test_simple_homed_udp_io_bind_then_move_then_home_and_close() {\n \tlet test_function: ~fn() = || {\n \t    let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n \t    let addr = next_test_ip4();\n-\t    let maybe_socket = unsafe { (*io).homed_udp_bind(addr) };\n+\t    let maybe_socket = unsafe { (*io)./*homed_*/udp_bind(addr) };\n \t    // this socket is bound to this event loop\n \t    assert!(maybe_socket.is_ok());\n "}]}