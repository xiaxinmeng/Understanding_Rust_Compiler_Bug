{"sha": "ce9cd15ce637928d6b571b0c7a248ab678908c6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOWNkMTVjZTYzNzkyOGQ2YjU3MWIwYzdhMjQ4YWI2Nzg5MDhjNmQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-16T12:50:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-18T10:08:22Z"}, "message": "provide machine hooks for creating references and accessing memory", "tree": {"sha": "b88fb0f5d0995530b7ba47a62f6d98d19a6e7c0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b88fb0f5d0995530b7ba47a62f6d98d19a6e7c0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce9cd15ce637928d6b571b0c7a248ab678908c6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9cd15ce637928d6b571b0c7a248ab678908c6d", "html_url": "https://github.com/rust-lang/rust/commit/ce9cd15ce637928d6b571b0c7a248ab678908c6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce9cd15ce637928d6b571b0c7a248ab678908c6d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7185794faf47c8907a386d60516a4fa2249e4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7185794faf47c8907a386d60516a4fa2249e4f", "html_url": "https://github.com/rust-lang/rust/commit/5b7185794faf47c8907a386d60516a4fa2249e4f"}], "stats": {"total": 135, "additions": 103, "deletions": 32}, "files": [{"sha": "baf6a4ecaa02accc66f6b116780cc3b086c7d2df", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -33,7 +33,7 @@ use rustc::mir::interpret::{\n     Scalar, Allocation, AllocId, ConstValue,\n };\n use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Value,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, Operand, Value,\n     EvalContext, StackPopCleanup, MemoryKind,\n     snapshot,\n };\n@@ -464,6 +464,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n             &ecx.stack[..],\n         )\n     }\n+\n+    #[inline(always)]\n+    fn tag_reference(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _place: MPlaceTy<'tcx, Self::PointerTag>,\n+        _borrow_kind: mir::BorrowKind,\n+    ) -> EvalResult<'tcx, Self::PointerTag> {\n+        Ok(())\n+    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "e30874ce7b386e3b4d469ac291525e93bdc78525", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -16,11 +16,19 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{Allocation, AllocId, EvalResult, Scalar};\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc::ty::{self, layout::{Size, TyLayout}, query::TyCtxtAt};\n \n-use super::{EvalContext, PlaceTy, OpTy, MemoryKind};\n+use super::{\n+    Allocation, AllocId, EvalResult, Scalar,\n+    EvalContext, PlaceTy, OpTy, MPlaceTy, Pointer, MemoryKind,\n+};\n+\n+/// Classifying memory accesses\n+pub enum MemoryAccess {\n+    Read,\n+    Write,\n+}\n \n /// Whether this kind of memory is allowed to leak\n pub trait MayLeak: Copy {\n@@ -160,15 +168,47 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n-    /// Heap allocations via the `box` keyword\n-    ///\n-    /// Returns a pointer to the allocated memory\n+    /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n+    /// Hook for performing extra checks on a memory access.\n+    ///\n+    /// Takes read-only access to the allocation so we can keep all the memory read\n+    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// need to mutate.\n+    #[inline]\n+    fn memory_accessed(\n+        _alloc: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n+        _access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks when memory gets deallocated.\n+    #[inline]\n+    fn memory_deallocated(\n+        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _id: AllocId,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Executed when evaluating the `&` operator: Creating a new reference.\n+    /// This has the chance to adjust the tag.  It is only ever called if the\n+    /// pointer in `place` is really a pointer, not another scalar.\n+    fn tag_reference(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        place: MPlaceTy<'tcx, Self::PointerTag>,\n+        borrow_kind: mir::BorrowKind,\n+    ) -> EvalResult<'tcx, Self::PointerTag>;\n+\n     /// Execute a validation operation\n+    #[inline]\n     fn validation_op(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,"}, {"sha": "faa165723db2aa069dba713a61e329fceaa69757", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -22,17 +22,16 @@ use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n-use rustc::mir::interpret::{\n-    Pointer, AllocId, Allocation, ConstValue, GlobalId,\n-    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n-    truncate\n-};\n-pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n+pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n-use super::{Machine, AllocMap, MayLeak, ScalarMaybeUndef};\n+use super::{\n+    Pointer, AllocId, Allocation, ConstValue, GlobalId,\n+    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+    Machine, MemoryAccess, AllocMap, MayLeak, ScalarMaybeUndef,\n+};\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n@@ -197,7 +196,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let (alloc_kind, alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n@@ -232,6 +231,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n+        // Let the machine take some extra action\n+        M::memory_deallocated(&mut alloc, ptr.alloc_id)?;\n+\n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(\n             ptr.alloc_id,\n@@ -632,6 +634,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         let alloc = self.get(ptr.alloc_id)?;\n+        M::memory_accessed(alloc, ptr, size, MemoryAccess::Read)?;\n+\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -676,6 +680,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.clear_relocations(ptr, size)?;\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n+        M::memory_accessed(alloc, ptr, size, MemoryAccess::Write)?;\n+\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;"}, {"sha": "55037a99e0124827ce4adffb000862d856e30bcd", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -24,6 +24,8 @@ mod traits;\n mod validity;\n mod intrinsics;\n \n+pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n+\n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n };\n@@ -32,7 +34,7 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind};\n \n-pub use self::machine::{Machine, AllocMap, MayLeak};\n+pub use self::machine::{Machine, AllocMap, MemoryAccess, MayLeak};\n \n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n "}, {"sha": "51406a686bcc96f846229a7f1cb39158363012db", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -144,17 +144,6 @@ impl<Tag> MemPlace<Tag> {\n         // it now must be aligned.\n         self.to_scalar_ptr_align().0.to_ptr()\n     }\n-\n-    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n-    /// This is the inverse of `ref_to_mplace`.\n-    pub fn to_ref(self) -> Value<Tag> {\n-        // We ignore the alignment of the place here -- special handling for packed structs ends\n-        // at the `&` operator.\n-        match self.meta {\n-            None => Value::Scalar(self.ptr.into()),\n-            Some(meta) => Value::ScalarPair(self.ptr.into(), meta.into()),\n-        }\n-    }\n }\n \n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n@@ -270,9 +259,10 @@ where\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n-    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n+    /// Alignment is just based on the type.  This is the inverse of `create_ref`.\n     pub fn ref_to_mplace(\n-        &self, val: ValTy<'tcx, M::PointerTag>\n+        &self,\n+        val: ValTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n@@ -286,6 +276,26 @@ where\n         Ok(MPlaceTy { mplace, layout })\n     }\n \n+    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// This is the inverse of `ref_to_mplace`.\n+    pub fn create_ref(\n+        &mut self,\n+        place: MPlaceTy<'tcx, M::PointerTag>,\n+        borrow_kind: mir::BorrowKind,\n+    ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n+        let ptr = match place.ptr {\n+            Scalar::Ptr(ptr) => {\n+                let tag = M::tag_reference(self, place, borrow_kind)?;\n+                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n+            },\n+            scalar @ Scalar::Bits { .. } => scalar,\n+        };\n+        Ok(match place.meta {\n+            None => Value::Scalar(ptr.into()),\n+            Some(meta) => Value::ScalarPair(ptr.into(), meta.into()),\n+        })\n+    }\n+\n     /// Offset a pointer to project to a field. Unlike place_field, this is always\n     /// possible without allocating, so it can take &self. Also return the field's layout.\n     /// This supports both struct and array fields."}, {"sha": "cb629e8313cd6ef4bdbe40c86396f0cc563b080c", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -248,9 +248,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 )?;\n             }\n \n-            Ref(_, _, ref place) => {\n+            Ref(_, borrow_kind, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?.to_ref();\n+                let val = self.force_allocation(src)?;\n+                let val = self.create_ref(val, borrow_kind)?;\n                 self.write_value(val, dest)?;\n             }\n "}, {"sha": "bb2dc7322004f8bb04c50b9156916975698f832a", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce9cd15ce637928d6b571b0c7a248ab678908c6d/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=ce9cd15ce637928d6b571b0c7a248ab678908c6d", "patch": "@@ -446,7 +446,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref()),\n+            op: Operand::Immediate(self.create_ref(\n+                place,\n+                mir::BorrowKind::Mut { allow_two_phase_borrow: false }\n+            )?),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n "}]}