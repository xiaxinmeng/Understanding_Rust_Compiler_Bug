{"sha": "77425c21c797bab5ae66c418751d689691229651", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3NDI1YzIxYzc5N2JhYjVhZTY2YzQxODc1MWQ2ODk2OTEyMjk2NTE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-15T08:17:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-15T08:17:13Z"}, "message": "Merge #5385\n\n5385: Off by one error when determining the active param r=matklad a=matklad\n\ncloses #3615\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "1f6ac29ef9654f781355931556a36aad8674fafa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f6ac29ef9654f781355931556a36aad8674fafa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77425c21c797bab5ae66c418751d689691229651", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDruJCRBK7hj4Ov3rIwAAdHIIAKxngQI794UsIDf+KQMBcLMc\nTGBLc2i0nuWnxn8LnB5i5D+5YMNcIT/PhZ8zlgdb69RDQm+gYnIJ9NmKWZzBoks4\nb3MZLujJ0racnJINjTlCrGgKJSjvYPGizKSEQ8+XK3w9yPX/8GD+n6134JnMh7Yj\nCKLX+GolVIG0Zt1V92yZw1x08vhtruKPivGRs1/Fknj98N/TO3wz03LpM0AFx9SS\nYNkUdUgl3wOsnwfJGAlMPtE6PEeK/Vgx37WUcb5EhmX3gM00hEIWOiW6n/aoAAf7\nHTgce/8KHdViR4PjAhLOwoJpqcb6dy2SA26ZozqYP1nKv3GYfqeE9qjsolZQYuA=\n=5F8j\n-----END PGP SIGNATURE-----\n", "payload": "tree 1f6ac29ef9654f781355931556a36aad8674fafa\nparent fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0\nparent fac1b0def12855fade4b29c180d5233a9b33646a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594801033 +0000\ncommitter GitHub <noreply@github.com> 1594801033 +0000\n\nMerge #5385\n\n5385: Off by one error when determining the active param r=matklad a=matklad\n\ncloses #3615\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77425c21c797bab5ae66c418751d689691229651", "html_url": "https://github.com/rust-lang/rust/commit/77425c21c797bab5ae66c418751d689691229651", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77425c21c797bab5ae66c418751d689691229651/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0", "html_url": "https://github.com/rust-lang/rust/commit/fc2f761d654aa17f4af7d3c40cb9b31ea7d91ad0"}, {"sha": "fac1b0def12855fade4b29c180d5233a9b33646a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fac1b0def12855fade4b29c180d5233a9b33646a", "html_url": "https://github.com/rust-lang/rust/commit/fac1b0def12855fade4b29c180d5233a9b33646a"}], "stats": {"total": 467, "additions": 240, "deletions": 227}, "files": [{"sha": "e1d6efb2ab82a2a54d7bdb7704170d01d9ddfad5", "filename": "crates/ra_ide/src/call_info.rs", "status": "modified", "additions": 240, "deletions": 227, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/77425c21c797bab5ae66c418751d689691229651/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77425c21c797bab5ae66c418751d689691229651/crates%2Fra_ide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcall_info.rs?ref=77425c21c797bab5ae66c418751d689691229651", "patch": "@@ -93,7 +93,7 @@ fn call_info_for_token(sema: &Semantics<RootDatabase>, token: SyntaxToken) -> Op\n                     arg_list\n                         .args()\n                         .take_while(|arg| {\n-                            arg.syntax().text_range().end() < token.text_range().start()\n+                            arg.syntax().text_range().end() <= token.text_range().start()\n                         })\n                         .count(),\n                 );\n@@ -213,169 +213,187 @@ impl CallInfo {\n \n #[cfg(test)]\n mod tests {\n+    use expect::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::mock_analysis::analysis_and_position;\n \n-    use super::*;\n-\n-    // These are only used when testing\n-    impl CallInfo {\n-        fn doc(&self) -> Option<hir::Documentation> {\n-            self.signature.doc.clone()\n-        }\n-\n-        fn label(&self) -> String {\n-            self.signature.to_string()\n-        }\n-    }\n-\n-    fn call_info_helper(text: &str) -> Option<CallInfo> {\n-        let (analysis, position) = analysis_and_position(text);\n-        analysis.call_info(position).unwrap()\n-    }\n-\n-    fn call_info(text: &str) -> CallInfo {\n-        let info = call_info_helper(text);\n-        assert!(info.is_some());\n-        info.unwrap()\n-    }\n-\n-    fn no_call_info(text: &str) {\n-        let info = call_info_helper(text);\n-        assert!(info.is_none());\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let (analysis, position) = analysis_and_position(ra_fixture);\n+        let call_info = analysis.call_info(position).unwrap();\n+        let actual = match call_info {\n+            Some(call_info) => {\n+                let docs = match &call_info.signature.doc {\n+                    None => \"\".to_string(),\n+                    Some(docs) => format!(\"{}\\n------\\n\", docs.as_str()),\n+                };\n+                let params = call_info\n+                    .parameters()\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, param)| {\n+                        if Some(i) == call_info.active_parameter {\n+                            format!(\"<{}>\", param)\n+                        } else {\n+                            param.clone()\n+                        }\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}{}\\n({})\\n\", docs, call_info.signature, params)\n+            }\n+            None => String::new(),\n+        };\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n-    fn test_fn_signature_two_args_firstx() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n+    fn test_fn_signature_two_args() {\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"x: u32\", \"y: u32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_second() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\"#,\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3<|>, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3,<|> ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(3, <|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (x: u32, <y: u32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"x: u32\", \"y: u32\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n     }\n \n     #[test]\n     fn test_fn_signature_two_args_empty() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>); }\"#,\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo(x: u32, y: u32) -> u32\n+                (<x: u32>, y: u32)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"x: u32\", \"y: u32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn test_fn_signature_two_args_first_generics() {\n-        let info = call_info(\n-            r#\"fn foo<T, U: Copy + Display>(x: T, y: U) -> u32 where T: Copy + Display, U: Debug {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n-        );\n-\n-        assert_eq!(info.parameters(), [\"x: T\", \"y: U\"]);\n-        assert_eq!(\n-            info.label(),\n+        check(\n             r#\"\n fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n-where T: Copy + Display,\n-      U: Debug\n-    \"#\n-            .trim()\n+    where T: Copy + Display, U: Debug\n+{ x + y }\n+\n+fn bar() { foo(<|>3, ); }\n+\"#,\n+            expect![[r#\"\n+                fn foo<T, U: Copy + Display>(x: T, y: U) -> u32\n+                where T: Copy + Display,\n+                      U: Debug\n+                (<x: T>, y: U)\n+            \"#]],\n         );\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn test_fn_signature_no_params() {\n-        let info = call_info(\n-            r#\"fn foo<T>() -> T where T: Copy + Display {}\n-fn bar() { foo(<|>); }\"#,\n-        );\n-\n-        assert!(info.parameters().is_empty());\n-        assert_eq!(\n-            info.label(),\n+        check(\n             r#\"\n-fn foo<T>() -> T\n-where T: Copy + Display\n-    \"#\n-            .trim()\n+fn foo<T>() -> T where T: Copy + Display {}\n+fn bar() { foo(<|>); }\n+\"#,\n+            expect![[r#\"\n+                fn foo<T>() -> T\n+                where T: Copy + Display\n+                ()\n+            \"#]],\n         );\n-        assert!(info.active_parameter.is_none());\n     }\n \n     #[test]\n     fn test_fn_signature_for_impl() {\n-        let info = call_info(\n-            r#\"struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\"#,\n+        check(\n+            r#\"\n+struct F; impl F { pub fn new() { F{}} }\n+fn bar() {let _ : F = F::new(<|>);}\n+\"#,\n+            expect![[r#\"\n+                pub fn new()\n+                ()\n+            \"#]],\n         );\n-\n-        assert!(info.parameters().is_empty());\n-        assert_eq!(info.active_parameter, None);\n     }\n \n     #[test]\n     fn test_fn_signature_for_method_self() {\n-        let info = call_info(\n-            r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self) {}\n-}\n+        check(\n+            r#\"\n+struct S;\n+impl S { pub fn do_it(&self) {} }\n \n fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n+    let s: S = S;\n+    s.do_it(<|>);\n+}\n+\"#,\n+            expect![[r#\"\n+                pub fn do_it(&self)\n+                (&self)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"&self\"]);\n-        assert_eq!(info.active_parameter, None);\n     }\n \n     #[test]\n     fn test_fn_signature_for_method_with_arg() {\n-        let info = call_info(\n-            r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self, x: i32) {}\n-}\n+        check(\n+            r#\"\n+struct S;\n+impl S { pub fn do_it(&self, x: i32) {} }\n \n fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n+    let s: S = S;\n+    s.do_it(<|>);\n+}\n+\"#,\n+            expect![[r#\"\n+                pub fn do_it(&self, x: i32)\n+                (&self, <x: i32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"&self\", \"x: i32\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs_simple() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// test\n // non-doc-comment\n@@ -387,17 +405,18 @@ fn bar() {\n     let _ = foo(<|>);\n }\n \"#,\n+            expect![[r#\"\n+                test\n+                ------\n+                fn foo(j: u32) -> u32\n+                (<j: u32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"j: u32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label(), \"fn foo(j: u32) -> u32\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"test\".to_string()));\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// Adds one to the number given.\n ///\n@@ -415,31 +434,26 @@ pub fn add_one(x: i32) -> i32 {\n pub fn do() {\n     add_one(<|>\n }\"#,\n-        );\n-\n-        assert_eq!(info.parameters(), [\"x: i32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label(), \"pub fn add_one(x: i32) -> i32\");\n-        assert_eq!(\n-            info.doc().map(|it| it.into()),\n-            Some(\n-                r#\"Adds one to the number given.\n+            expect![[r##\"\n+                Adds one to the number given.\n \n-# Examples\n+                # Examples\n \n-```\n-let five = 5;\n+                ```\n+                let five = 5;\n \n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                    .to_string()\n-            )\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                pub fn add_one(x: i32) -> i32\n+                (<x: i32>)\n+            \"##]],\n         );\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs_impl() {\n-        let info = call_info(\n+        check(\n             r#\"\n struct addr;\n impl addr {\n@@ -460,32 +474,28 @@ impl addr {\n pub fn do_it() {\n     addr {};\n     addr::add_one(<|>);\n-}\"#,\n-        );\n-\n-        assert_eq!(info.parameters(), [\"x: i32\"]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label(), \"pub fn add_one(x: i32) -> i32\");\n-        assert_eq!(\n-            info.doc().map(|it| it.into()),\n-            Some(\n-                r#\"Adds one to the number given.\n+}\n+\"#,\n+            expect![[r##\"\n+                Adds one to the number given.\n \n-# Examples\n+                # Examples\n \n-```\n-let five = 5;\n+                ```\n+                let five = 5;\n \n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                    .to_string()\n-            )\n+                assert_eq!(6, my_crate::add_one(5));\n+                ```\n+                ------\n+                pub fn add_one(x: i32) -> i32\n+                (<x: i32>)\n+            \"##]],\n         );\n     }\n \n     #[test]\n     fn test_fn_signature_with_docs_from_actix() {\n-        let info = call_info(\n+        check(\n             r#\"\n struct WriteHandler<E>;\n \n@@ -509,101 +519,102 @@ impl<E> WriteHandler<E> {\n pub fn foo(mut r: WriteHandler<()>) {\n     r.finished(<|>);\n }\n-\n \"#,\n-        );\n-\n-        assert_eq!(info.label(), \"fn finished(&mut self, ctx: &mut Self::Context)\".to_string());\n-        assert_eq!(info.parameters(), [\"&mut self\", \"ctx: &mut Self::Context\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n-        assert_eq!(\n-            info.doc().map(|it| it.into()),\n-            Some(\n-                r#\"Method is called when writer finishes.\n-\n-By default this method stops actor's `Context`.\"#\n-                    .to_string()\n-            )\n+            expect![[r#\"\n+                Method is called when writer finishes.\n+\n+                By default this method stops actor's `Context`.\n+                ------\n+                fn finished(&mut self, ctx: &mut Self::Context)\n+                (&mut self, <ctx: &mut Self::Context>)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn call_info_bad_offset() {\n         mark::check!(call_info_bad_offset);\n-        let (analysis, position) = analysis_and_position(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-               fn bar() { foo <|> (3, ); }\"#,\n+        check(\n+            r#\"\n+fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo <|> (3, ); }\n+\"#,\n+            expect![[\"\"]],\n         );\n-        let call_info = analysis.call_info(position).unwrap();\n-        assert!(call_info.is_none());\n     }\n \n     #[test]\n-    fn test_nested_method_in_lamba() {\n-        let info = call_info(\n-            r#\"struct Foo;\n-\n-impl Foo {\n-    fn bar(&self, _: u32) { }\n-}\n+    fn test_nested_method_in_lambda() {\n+        check(\n+            r#\"\n+struct Foo;\n+impl Foo { fn bar(&self, _: u32) { } }\n \n fn bar(_: u32) { }\n \n fn main() {\n     let foo = Foo;\n     std::thread::spawn(move || foo.bar(<|>));\n-}\"#,\n+}\n+\"#,\n+            expect![[r#\"\n+                fn bar(&self, _: u32)\n+                (&self, <_: u32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.parameters(), [\"&self\", \"_: u32\"]);\n-        assert_eq!(info.active_parameter, Some(1));\n-        assert_eq!(info.label(), \"fn bar(&self, _: u32)\");\n     }\n \n     #[test]\n     fn works_for_tuple_structs() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// A cool tuple struct\n struct TS(u32, i32);\n fn main() {\n     let s = TS(0, <|>);\n-}\"#,\n+}\n+\"#,\n+            expect![[r#\"\n+                A cool tuple struct\n+                ------\n+                struct TS(u32, i32) -> TS\n+                (u32, <i32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"struct TS(u32, i32) -> TS\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"A cool tuple struct\".to_string()));\n-        assert_eq!(info.active_parameter, Some(1));\n     }\n \n     #[test]\n     fn generic_struct() {\n-        let info = call_info(\n+        check(\n             r#\"\n struct TS<T>(T);\n fn main() {\n     let s = TS(<|>);\n-}\"#,\n+}\n+\"#,\n+            expect![[r#\"\n+                struct TS<T>(T) -> TS\n+                (<T>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"struct TS<T>(T) -> TS\");\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn cant_call_named_structs() {\n-        no_call_info(\n+        check(\n             r#\"\n struct TS { x: u32, y: i32 }\n fn main() {\n     let s = TS(<|>);\n-}\"#,\n+}\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n     fn works_for_enum_variants() {\n-        let info = call_info(\n+        check(\n             r#\"\n enum E {\n     /// A Variant\n@@ -617,17 +628,19 @@ enum E {\n fn main() {\n     let a = E::A(<|>);\n }\n-            \"#,\n+\"#,\n+            expect![[r#\"\n+                A Variant\n+                ------\n+                E::A(0: i32)\n+                (<0: i32>)\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"E::A(0: i32)\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"A Variant\".to_string()));\n-        assert_eq!(info.active_parameter, Some(0));\n     }\n \n     #[test]\n     fn cant_call_enum_records() {\n-        no_call_info(\n+        check(\n             r#\"\n enum E {\n     /// A Variant\n@@ -641,13 +654,14 @@ enum E {\n fn main() {\n     let a = E::C(<|>);\n }\n-            \"#,\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n     fn fn_signature_for_macro() {\n-        let info = call_info(\n+        check(\n             r#\"\n /// empty macro\n macro_rules! foo {\n@@ -657,31 +671,30 @@ macro_rules! foo {\n fn f() {\n     foo!(<|>);\n }\n-        \"#,\n+\"#,\n+            expect![[r#\"\n+                empty macro\n+                ------\n+                foo!()\n+                ()\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"foo!()\");\n-        assert_eq!(info.doc().map(|it| it.into()), Some(\"empty macro\".to_string()));\n     }\n \n     #[test]\n     fn fn_signature_for_call_in_macro() {\n-        let info = call_info(\n+        check(\n             r#\"\n-            macro_rules! id {\n-                ($($tt:tt)*) => { $($tt)* }\n-            }\n-            fn foo() {\n-\n-            }\n-            id! {\n-                fn bar() {\n-                    foo(<|>);\n-                }\n-            }\n-            \"#,\n+macro_rules! id { ($($tt:tt)*) => { $($tt)* } }\n+fn foo() { }\n+id! {\n+    fn bar() { foo(<|>); }\n+}\n+\"#,\n+            expect![[r#\"\n+                fn foo()\n+                ()\n+            \"#]],\n         );\n-\n-        assert_eq!(info.label(), \"fn foo()\");\n     }\n }"}]}