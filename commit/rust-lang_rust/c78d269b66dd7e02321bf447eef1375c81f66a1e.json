{"sha": "c78d269b66dd7e02321bf447eef1375c81f66a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3OGQyNjliNjZkZDdlMDIzMjFiZjQ0N2VlZjEzNzVjODFmNjZhMWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-15T19:38:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-15T19:38:10Z"}, "message": "Merge #2837\n\n2837: Accidentally quadratic r=matklad a=matklad\n\nOur syntax highlighting is accdentally quadratic. Current state of the PR fixes it in a pretty crude way, looks like for the proper fix we need to redo how source-analyzer works. \r\n\r\n**NB:** don't be scared by diff stats, that's mostly a test-data file\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "8ec28f0ecd713783aa4d7032bdf324ace7bc8911", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ec28f0ecd713783aa4d7032bdf324ace7bc8911"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c78d269b66dd7e02321bf447eef1375c81f66a1e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeH2oiCRBK7hj4Ov3rIwAAdHIIACFHt8FVnFZIA5AJ4MFSxG/S\nckJ+DGYiZny3L9SvXGvUSHS6yaFmg8Asc6BzSwr/NcJvgtta0eAioqPSk2ppnnHI\nvdjSnVX5IL1X1Z23iru+jYXTdgM91yE9IS0Y/ArcuC/utjZGxKbXpVZiBs/D19TY\nw1qIXA8CpslGl9viLoQk3aJQf+ujKVNxCInCi02yaMGsJq0brBTw3NjU7Jk5Y9NN\n7UI+ObcQjvusvJfz4MqK5lQjK0wF3U28ljNU+Dih7eG8/C0BCuHvNZNl5z5eZchK\nBlXebgaDjaTNigRbTS8qbUTuc0D9lXx2os+gtXNYtloXDThWEXhL0xF33tsjM8A=\n=SNav\n-----END PGP SIGNATURE-----\n", "payload": "tree 8ec28f0ecd713783aa4d7032bdf324ace7bc8911\nparent aa2e13b37f4508168fb064a79d0190fa705d8a47\nparent aaef88db0e2602e010f78e26a80d974be12c1f71\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1579117090 +0000\ncommitter GitHub <noreply@github.com> 1579117090 +0000\n\nMerge #2837\n\n2837: Accidentally quadratic r=matklad a=matklad\n\nOur syntax highlighting is accdentally quadratic. Current state of the PR fixes it in a pretty crude way, looks like for the proper fix we need to redo how source-analyzer works. \r\n\r\n**NB:** don't be scared by diff stats, that's mostly a test-data file\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c78d269b66dd7e02321bf447eef1375c81f66a1e", "html_url": "https://github.com/rust-lang/rust/commit/c78d269b66dd7e02321bf447eef1375c81f66a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c78d269b66dd7e02321bf447eef1375c81f66a1e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa2e13b37f4508168fb064a79d0190fa705d8a47", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2e13b37f4508168fb064a79d0190fa705d8a47", "html_url": "https://github.com/rust-lang/rust/commit/aa2e13b37f4508168fb064a79d0190fa705d8a47"}, {"sha": "aaef88db0e2602e010f78e26a80d974be12c1f71", "url": "https://api.github.com/repos/rust-lang/rust/commits/aaef88db0e2602e010f78e26a80d974be12c1f71", "html_url": "https://github.com/rust-lang/rust/commit/aaef88db0e2602e010f78e26a80d974be12c1f71"}], "stats": {"total": 4486, "additions": 4309, "deletions": 177}, "files": [{"sha": "10bd94f7b072b19d8327b9d9442d8403b8a3e24c", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -739,7 +739,7 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.2.0\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -981,7 +981,7 @@ dependencies = [\n  \"either 1.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"insta 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_arena 0.1.0\",\n  \"ra_cfg 0.1.0\",\n  \"ra_db 0.1.0\",\n@@ -1043,7 +1043,7 @@ dependencies = [\n  \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proptest 0.9.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_assists 0.1.0\",\n  \"ra_cfg 0.1.0\",\n@@ -1118,7 +1118,7 @@ dependencies = [\n  \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemalloc-ctl 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jemallocator 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1141,7 +1141,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"once_cell 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_text_edit 0.1.0\",\n  \"rowan 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1864,7 +1864,7 @@ dependencies = [\n \"checksum notify 4.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80ae4a7688d1fab81c5bf19c64fc8db920be8d519ce6336ed4e7efe024724dbd\"\n \"checksum num-traits 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c62be47e61d1842b9170f0fdeec8eba98e60e90e5446449a0545e5152acd7096\"\n \"checksum num_cpus 1.11.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76dac5ed2a876980778b8b85f75a71b6cbf0db0b1232ee12f826bccb00d09d72\"\n-\"checksum once_cell 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"891f486f630e5c5a4916c7e16c4b24a53e78c860b646e9f8e005e4f16847bfed\"\n+\"checksum once_cell 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5941ec2d5ee5916c709580d71553b81a633df245bcc73c04dcbd62152ceefc4\"\n \"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum parking_lot 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92e98c49ab0b7ce5b222f2cc9193fc4efe11c6d0bd4f648e374684a6857b1cfc\"\n \"checksum parking_lot_core 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7582838484df45743c8434fbff785e8edf260c28748353d44bc0da32e0ceabf1\""}, {"sha": "a2350573c7c5f5f568b5e7ceb332d560605333d0", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -8,7 +8,7 @@\n #![recursion_limit = \"512\"]\n \n macro_rules! impl_froms {\n-    ($e:ident: $($v:ident $(($($sv:ident),*))?),*) => {\n+    ($e:ident: $($v:ident $(($($sv:ident),*))?),*$(,)?) => {\n         $(\n             impl From<$v> for $e {\n                 fn from(it: $v) -> $e {\n@@ -28,6 +28,7 @@ macro_rules! impl_froms {\n \n pub mod db;\n pub mod source_analyzer;\n+pub mod source_binder;\n \n pub mod diagnostics;\n \n@@ -47,6 +48,7 @@ pub use crate::{\n     from_source::FromSource,\n     has_source::HasSource,\n     source_analyzer::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n+    source_binder::SourceBinder,\n };\n \n pub use hir_def::{"}, {"sha": "4f8fc960202bfae5eccaa5aa08c642ee40bc6b24", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 41, "deletions": 97, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -14,26 +14,22 @@ use hir_def::{\n         BodySourceMap,\n     },\n     expr::{ExprId, PatId},\n-    nameres::ModuleSource,\n-    resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n+    resolver::{self, resolver_for_scope, Resolver, TypeNs, ValueNs},\n     DefWithBodyId, TraitId,\n };\n use hir_expand::{\n     hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n };\n use hir_ty::{InEnvironment, InferenceResult, TraitEnvironment};\n-use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode},\n-    match_ast, AstPtr,\n-    SyntaxKind::*,\n-    SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n+    AstPtr, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::FxHashSet;\n \n use crate::{\n-    db::HirDatabase, Adt, Const, DefWithBody, Enum, EnumVariant, FromSource, Function, ImplBlock,\n-    Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n+    db::HirDatabase, Adt, Const, DefWithBody, EnumVariant, Function, Local, MacroDef, Name, Path,\n+    ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n@@ -109,37 +105,43 @@ impl SourceAnalyzer {\n         node: InFile<&SyntaxNode>,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n-        let _p = profile(\"SourceAnalyzer::new\");\n-        let def_with_body = def_with_body_from_child_node(db, node);\n-        if let Some(def) = def_with_body {\n-            let (_body, source_map) = db.body_with_source_map(def.into());\n-            let scopes = db.expr_scopes(def.into());\n-            let scope = match offset {\n-                None => scope_for(&scopes, &source_map, node),\n-                Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n-            };\n-            let resolver = resolver_for_scope(db, def.into(), scope);\n-            SourceAnalyzer {\n-                resolver,\n-                body_owner: Some(def),\n-                body_source_map: Some(source_map),\n-                infer: Some(db.infer(def.into())),\n-                scopes: Some(scopes),\n-                file_id: node.file_id,\n-            }\n-        } else {\n-            SourceAnalyzer {\n-                resolver: node\n-                    .value\n-                    .ancestors()\n-                    .find_map(|it| try_get_resolver_for_node(db, node.with_value(&it)))\n-                    .unwrap_or_default(),\n-                body_owner: None,\n-                body_source_map: None,\n-                infer: None,\n-                scopes: None,\n-                file_id: node.file_id,\n-            }\n+        crate::source_binder::SourceBinder::new(db).analyze(node, offset)\n+    }\n+\n+    pub(crate) fn new_for_body(\n+        db: &impl HirDatabase,\n+        def: DefWithBodyId,\n+        node: InFile<&SyntaxNode>,\n+        offset: Option<TextUnit>,\n+    ) -> SourceAnalyzer {\n+        let (_body, source_map) = db.body_with_source_map(def);\n+        let scopes = db.expr_scopes(def);\n+        let scope = match offset {\n+            None => scope_for(&scopes, &source_map, node),\n+            Some(offset) => scope_for_offset(&scopes, &source_map, node.with_value(offset)),\n+        };\n+        let resolver = resolver_for_scope(db, def, scope);\n+        SourceAnalyzer {\n+            resolver,\n+            body_owner: Some(def.into()),\n+            body_source_map: Some(source_map),\n+            infer: Some(db.infer(def)),\n+            scopes: Some(scopes),\n+            file_id: node.file_id,\n+        }\n+    }\n+\n+    pub(crate) fn new_for_resolver(\n+        resolver: Resolver,\n+        node: InFile<&SyntaxNode>,\n+    ) -> SourceAnalyzer {\n+        SourceAnalyzer {\n+            resolver,\n+            body_owner: None,\n+            body_source_map: None,\n+            infer: None,\n+            scopes: None,\n+            file_id: node.file_id,\n         }\n     }\n \n@@ -366,64 +368,6 @@ impl SourceAnalyzer {\n     }\n }\n \n-fn try_get_resolver_for_node(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> Option<Resolver> {\n-    match_ast! {\n-        match (node.value) {\n-            ast::Module(it) => {\n-                let src = node.with_value(it);\n-                Some(crate::Module::from_declaration(db, src)?.id.resolver(db))\n-            },\n-             ast::SourceFile(it) => {\n-                let src = node.with_value(ModuleSource::SourceFile(it));\n-                Some(crate::Module::from_definition(db, src)?.id.resolver(db))\n-            },\n-            ast::StructDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Struct::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::EnumDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Enum::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::ImplBlock(it) => {\n-                let src = node.with_value(it);\n-                Some(ImplBlock::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::TraitDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Trait::from_source(db, src)?.id.resolver(db))\n-            },\n-            _ => match node.value.kind() {\n-                FN_DEF | CONST_DEF | STATIC_DEF => {\n-                    let def = def_with_body_from_child_node(db, node)?;\n-                    let def = DefWithBodyId::from(def);\n-                    Some(def.resolver(db))\n-                }\n-                // FIXME add missing cases\n-                _ => None\n-            }\n-        }\n-    }\n-}\n-\n-fn def_with_body_from_child_node(\n-    db: &impl HirDatabase,\n-    child: InFile<&SyntaxNode>,\n-) -> Option<DefWithBody> {\n-    let _p = profile(\"def_with_body_from_child_node\");\n-    child.cloned().ancestors_with_macros(db).find_map(|node| {\n-        let n = &node.value;\n-        match_ast! {\n-            match n {\n-                ast::FnDef(def)  => { return Function::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                ast::ConstDef(def) => { return Const::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                ast::StaticDef(def) => { return Static::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                _ => { None },\n-            }\n-        }\n-    })\n-}\n-\n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,"}, {"sha": "00541dbe1201a43248382b3c2325c75fa8504090", "filename": "crates/ra_hir/src/source_binder.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -0,0 +1,173 @@\n+//! `SourceBinder` should be the main entry point for getting info about source code.\n+//! It's main task is to map source syntax trees to hir-level IDs.\n+//!\n+//! It is intended to subsume `FromSource` and `SourceAnalyzer`.\n+\n+use hir_def::{\n+    child_by_source::ChildBySource,\n+    dyn_map::DynMap,\n+    keys::{self, Key},\n+    resolver::{HasResolver, Resolver},\n+    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, ImplId, ModuleId, StaticId,\n+    StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+};\n+use hir_expand::InFile;\n+use ra_prof::profile;\n+use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, TextUnit};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{db::HirDatabase, ModuleSource, SourceAnalyzer};\n+\n+pub struct SourceBinder<'a, DB> {\n+    pub db: &'a DB,\n+    child_by_source_cache: FxHashMap<ChildContainer, DynMap>,\n+}\n+\n+impl<DB: HirDatabase> SourceBinder<'_, DB> {\n+    pub fn new(db: &DB) -> SourceBinder<DB> {\n+        SourceBinder { db, child_by_source_cache: FxHashMap::default() }\n+    }\n+\n+    pub fn analyze(\n+        &mut self,\n+        src: InFile<&SyntaxNode>,\n+        offset: Option<TextUnit>,\n+    ) -> SourceAnalyzer {\n+        let _p = profile(\"SourceBinder::analyzer\");\n+        let container = match self.find_container(src) {\n+            Some(it) => it,\n+            None => return SourceAnalyzer::new_for_resolver(Resolver::default(), src),\n+        };\n+\n+        let resolver = match container {\n+            ChildContainer::DefWithBodyId(def) => {\n+                return SourceAnalyzer::new_for_body(self.db, def, src, offset)\n+            }\n+            ChildContainer::TraitId(it) => it.resolver(self.db),\n+            ChildContainer::ImplId(it) => it.resolver(self.db),\n+            ChildContainer::ModuleId(it) => it.resolver(self.db),\n+            ChildContainer::EnumId(it) => it.resolver(self.db),\n+            ChildContainer::VariantId(it) => it.resolver(self.db),\n+        };\n+        SourceAnalyzer::new_for_resolver(resolver, src)\n+    }\n+\n+    pub fn to_def<D, T>(&mut self, src: InFile<T>) -> Option<D>\n+    where\n+        D: From<T::ID>,\n+        T: ToId,\n+    {\n+        let id: T::ID = self.to_id(src)?;\n+        Some(id.into())\n+    }\n+\n+    fn to_id<T: ToId>(&mut self, src: InFile<T>) -> Option<T::ID> {\n+        let container = self.find_container(src.as_ref().map(|it| it.syntax()))?;\n+        let db = self.db;\n+        let dyn_map =\n+            &*self.child_by_source_cache.entry(container).or_insert_with(|| match container {\n+                ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n+                ChildContainer::ModuleId(it) => it.child_by_source(db),\n+                ChildContainer::TraitId(it) => it.child_by_source(db),\n+                ChildContainer::ImplId(it) => it.child_by_source(db),\n+                ChildContainer::EnumId(it) => it.child_by_source(db),\n+                ChildContainer::VariantId(it) => it.child_by_source(db),\n+            });\n+        dyn_map[T::KEY].get(&src).copied()\n+    }\n+\n+    fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n+        for container in src.cloned().ancestors_with_macros(self.db).skip(1) {\n+            let res: ChildContainer = match_ast! {\n+                match (container.value) {\n+                    ast::TraitDef(it) => {\n+                        let def: TraitId = self.to_id(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::ImplBlock(it) => {\n+                        let def: ImplId = self.to_id(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::FnDef(it) => {\n+                        let def: FunctionId = self.to_id(container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::StaticDef(it) => {\n+                        let def: StaticId = self.to_id(container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::ConstDef(it) => {\n+                        let def: ConstId = self.to_id(container.with_value(it))?;\n+                        DefWithBodyId::from(def).into()\n+                    },\n+                    ast::EnumDef(it) => {\n+                        let def: EnumId = self.to_id(container.with_value(it))?;\n+                        def.into()\n+                    },\n+                    ast::StructDef(it) => {\n+                        let def: StructId = self.to_id(container.with_value(it))?;\n+                        VariantId::from(def).into()\n+                    },\n+                    ast::UnionDef(it) => {\n+                        let def: UnionId = self.to_id(container.with_value(it))?;\n+                        VariantId::from(def).into()\n+                    },\n+                    // FIXME: handle out-of-line modules here\n+                    _ => { continue },\n+                }\n+            };\n+            return Some(res);\n+        }\n+\n+        let module_source = ModuleSource::from_child_node(self.db, src);\n+        let c = crate::Module::from_definition(self.db, src.with_value(module_source))?;\n+        Some(c.id.into())\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+enum ChildContainer {\n+    DefWithBodyId(DefWithBodyId),\n+    ModuleId(ModuleId),\n+    TraitId(TraitId),\n+    ImplId(ImplId),\n+    EnumId(EnumId),\n+    VariantId(VariantId),\n+}\n+impl_froms! {\n+    ChildContainer:\n+    DefWithBodyId,\n+    ModuleId,\n+    TraitId,\n+    ImplId,\n+    EnumId,\n+    VariantId,\n+}\n+\n+pub trait ToId: Sized + AstNode + 'static {\n+    type ID: Sized + Copy + 'static;\n+    const KEY: Key<Self, Self::ID>;\n+}\n+\n+macro_rules! to_id_impls {\n+    ($(($id:ident, $ast:path, $key:path)),* ,) => {$(\n+        impl ToId for $ast {\n+            type ID = $id;\n+            const KEY: Key<Self, Self::ID> = $key;\n+        }\n+    )*}\n+}\n+\n+to_id_impls![\n+    (StructId, ast::StructDef, keys::STRUCT),\n+    (UnionId, ast::UnionDef, keys::UNION),\n+    (EnumId, ast::EnumDef, keys::ENUM),\n+    (TraitId, ast::TraitDef, keys::TRAIT),\n+    (FunctionId, ast::FnDef, keys::FUNCTION),\n+    (StaticId, ast::StaticDef, keys::STATIC),\n+    (ConstId, ast::ConstDef, keys::CONST),\n+    (TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n+    (ImplId, ast::ImplBlock, keys::IMPL),\n+    (StructFieldId, ast::RecordFieldDef, keys::RECORD_FIELD),\n+    (EnumVariantId, ast::EnumVariant, keys::ENUM_VARIANT),\n+];"}, {"sha": "feb3a300d581ee687103f7bb2291d7974689898c", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -332,7 +332,7 @@ pub enum VariantId {\n     StructId(StructId),\n     UnionId(UnionId),\n }\n-impl_froms!(VariantId: EnumVariantId, StructId);\n+impl_froms!(VariantId: EnumVariantId, StructId, UnionId);\n \n trait Intern {\n     type ID;"}, {"sha": "f2b5af3214155f98427c4c89907d2726acb3e87b", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{db::AstDatabase, InFile};\n+use hir::{db::AstDatabase, InFile, SourceBinder};\n use ra_syntax::{\n     ast::{self, DocCommentsOwner},\n     match_ast, AstNode,\n@@ -72,7 +72,8 @@ pub(crate) fn reference_definition(\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let name_kind = classify_name_ref(db, name_ref).map(|d| d.kind);\n+    let mut sb = SourceBinder::new(db);\n+    let name_kind = classify_name_ref(&mut sb, name_ref).map(|d| d.kind);\n     match name_kind {\n         Some(Macro(it)) => return Exact(it.to_nav(db)),\n         Some(Field(it)) => return Exact(it.to_nav(db)),"}, {"sha": "6661e5cb22c29d66d949765697f850f72b589a61", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{db::AstDatabase, Adt, HasSource, HirDisplay};\n+use hir::{db::AstDatabase, Adt, HasSource, HirDisplay, SourceBinder};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::find_covering_element,\n@@ -152,13 +152,14 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n \n     let mut res = HoverResult::new();\n \n+    let mut sb = SourceBinder::new(db);\n     if let Some((range, name_kind)) = match_ast! {\n         match (token.value.parent()) {\n             ast::NameRef(name_ref) => {\n-                classify_name_ref(db, token.with_value(&name_ref)).map(|d| (name_ref.syntax().text_range(), d.kind))\n+                classify_name_ref(&mut sb, token.with_value(&name_ref)).map(|d| (name_ref.syntax().text_range(), d.kind))\n             },\n             ast::Name(name) => {\n-                classify_name(db, token.with_value(&name)).map(|d| (name.syntax().text_range(), d.kind))\n+                classify_name(&mut sb, token.with_value(&name)).map(|d| (name.syntax().text_range(), d.kind))\n             },\n             _ => None,\n         }\n@@ -742,7 +743,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             }\n             fn foo(bar:u32) {\n                 let a = id!(ba<|>r);\n-            }            \n+            }\n             \",\n             &[\"u32\"],\n         );"}, {"sha": "e2da96129d3697356af056ed527929ff223fd6d2", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{HirDisplay, SourceAnalyzer};\n+use hir::{HirDisplay, SourceAnalyzer, SourceBinder};\n use once_cell::unsync::Lazy;\n use ra_prof::profile;\n use ra_syntax::{\n@@ -29,22 +29,23 @@ pub(crate) fn inlay_hints(\n     file: &SourceFile,\n     max_inlay_hint_length: Option<usize>,\n ) -> Vec<InlayHint> {\n+    let mut sb = SourceBinder::new(db);\n     file.syntax()\n         .descendants()\n-        .flat_map(|node| get_inlay_hints(db, file_id, &node, max_inlay_hint_length))\n+        .flat_map(|node| get_inlay_hints(&mut sb, file_id, &node, max_inlay_hint_length))\n         .flatten()\n         .collect()\n }\n \n fn get_inlay_hints(\n-    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n     file_id: FileId,\n     node: &SyntaxNode,\n     max_inlay_hint_length: Option<usize>,\n ) -> Option<Vec<InlayHint>> {\n     let _p = profile(\"get_inlay_hints\");\n-    let analyzer =\n-        Lazy::new(|| SourceAnalyzer::new(db, hir::InFile::new(file_id.into(), node), None));\n+    let db = sb.db;\n+    let analyzer = Lazy::new(move || sb.analyze(hir::InFile::new(file_id.into(), node), None));\n     match_ast! {\n         match node {\n             ast::LetStmt(it) => {"}, {"sha": "5e2fe1905ad71cc8477906d10054578201d437ee", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -14,7 +14,7 @@ mod name_definition;\n mod rename;\n mod search_scope;\n \n-use hir::InFile;\n+use hir::{InFile, SourceBinder};\n use once_cell::unsync::Lazy;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n use ra_prof::profile;\n@@ -171,13 +171,14 @@ fn find_name(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n ) -> Option<RangeInfo<(String, NameDefinition)>> {\n+    let mut sb = SourceBinder::new(db);\n     if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n-        let def = classify_name(db, InFile::new(position.file_id.into(), &name))?;\n+        let def = classify_name(&mut sb, InFile::new(position.file_id.into(), &name))?;\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n     }\n     let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(db, InFile::new(position.file_id.into(), &name_ref))?;\n+    let def = classify_name_ref(&mut sb, InFile::new(position.file_id.into(), &name_ref))?;\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, (name_ref.text().to_string(), def)))\n }\n@@ -195,7 +196,9 @@ fn process_definition(\n \n     for (file_id, search_range) in scope {\n         let text = db.file_text(file_id);\n+\n         let parse = Lazy::new(|| SourceFile::parse(&text));\n+        let mut sb = Lazy::new(|| SourceBinder::new(db));\n \n         for (idx, _) in text.match_indices(pat) {\n             let offset = TextUnit::from_usize(idx);\n@@ -209,7 +212,11 @@ fn process_definition(\n                         continue;\n                     }\n                 }\n-                if let Some(d) = classify_name_ref(db, InFile::new(file_id.into(), &name_ref)) {\n+                // FIXME: reuse sb\n+                // See https://github.com/rust-lang/rust/pull/68198#issuecomment-574269098\n+\n+                if let Some(d) = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n+                {\n                     if d == def {\n                         let kind = if name_ref\n                             .syntax()\n@@ -309,7 +316,7 @@ mod tests {\n     }\n     impl Foo {\n         fn f() -> i32 { 42 }\n-    }    \n+    }\n     fn main() {\n         let f: Foo;\n         f = Foo {a: Foo::f()};\n@@ -319,7 +326,7 @@ mod tests {\n         check_result(\n             refs,\n             \"Foo STRUCT_DEF FileId(1) [5; 39) [12; 15) Other\",\n-            &[\"FileId(1) [142; 145) StructLiteral\"],\n+            &[\"FileId(1) [138; 141) StructLiteral\"],\n         );\n     }\n "}, {"sha": "4a6e11e27ec0418070992fac6da12a4daeba076e", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -1,6 +1,6 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{FromSource, InFile, Module, ModuleSource, PathResolution, SourceAnalyzer};\n+use hir::{FromSource, InFile, Module, ModuleSource, PathResolution, SourceBinder};\n use ra_prof::profile;\n use ra_syntax::{ast, match_ast, AstNode};\n use test_utils::tested_by;\n@@ -11,98 +11,100 @@ use super::{\n };\n use crate::db::RootDatabase;\n \n-pub(crate) fn classify_name(db: &RootDatabase, name: InFile<&ast::Name>) -> Option<NameDefinition> {\n+pub(crate) fn classify_name(\n+    sb: &mut SourceBinder<RootDatabase>,\n+    name: InFile<&ast::Name>,\n+) -> Option<NameDefinition> {\n     let _p = profile(\"classify_name\");\n     let parent = name.value.syntax().parent()?;\n \n     match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n                 let src = name.with_value(it);\n-                let local = hir::Local::from_source(db, src)?;\n+                let local = hir::Local::from_source(sb.db, src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: local.module(db),\n+                    container: local.module(sb.db),\n                     kind: NameKind::Local(local),\n                 })\n             },\n             ast::RecordFieldDef(it) => {\n-                let ast = hir::FieldSource::Named(it);\n-                let src = name.with_value(ast);\n-                let field = hir::StructField::from_source(db, src)?;\n-                Some(from_struct_field(db, field))\n+                let src = name.with_value(it);\n+                let field: hir::StructField = sb.to_def(src)?;\n+                Some(from_struct_field(sb.db, field))\n             },\n             ast::Module(it) => {\n                 let def = {\n                     if !it.has_semi() {\n                         let ast = hir::ModuleSource::Module(it);\n                         let src = name.with_value(ast);\n-                        hir::Module::from_definition(db, src)\n+                        hir::Module::from_definition(sb.db, src)\n                     } else {\n                         let src = name.with_value(it);\n-                        hir::Module::from_declaration(db, src)\n+                        hir::Module::from_declaration(sb.db, src)\n                     }\n                 }?;\n-                Some(from_module_def(db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::StructDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Struct::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Struct = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::EnumDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Enum::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Enum = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::TraitDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Trait::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Trait = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::StaticDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Static::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::Static = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::EnumVariant(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::EnumVariant::from_source(db, src)?;\n-                Some(from_module_def(db, def.into(), None))\n+                let def: hir::EnumVariant = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::FnDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Function::from_source(db, src)?;\n+                let def: hir::Function = sb.to_def(src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(db, def.into()))\n+                    Some(from_assoc_item(sb.db, def.into()))\n                 } else {\n-                    Some(from_module_def(db, def.into(), None))\n+                    Some(from_module_def(sb.db, def.into(), None))\n                 }\n             },\n             ast::ConstDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::Const::from_source(db, src)?;\n+                let def: hir::Const = sb.to_def(src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(db, def.into()))\n+                    Some(from_assoc_item(sb.db, def.into()))\n                 } else {\n-                    Some(from_module_def(db, def.into(), None))\n+                    Some(from_module_def(sb.db, def.into(), None))\n                 }\n             },\n             ast::TypeAliasDef(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::TypeAlias::from_source(db, src)?;\n+                let def: hir::TypeAlias = sb.to_def(src)?;\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(db, def.into()))\n+                    Some(from_assoc_item(sb.db, def.into()))\n                 } else {\n-                    Some(from_module_def(db, def.into(), None))\n+                    Some(from_module_def(sb.db, def.into(), None))\n                 }\n             },\n             ast::MacroCall(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::MacroDef::from_source(db, src.clone())?;\n+                let def = hir::MacroDef::from_source(sb.db, src.clone())?;\n \n-                let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n-                let module = Module::from_definition(db, src.with_value(module_src))?;\n+                let module_src = ModuleSource::from_child_node(sb.db, src.as_ref().map(|it| it.syntax()));\n+                let module = Module::from_definition(sb.db, src.with_value(module_src))?;\n \n                 Some(NameDefinition {\n                     visibility: None,\n@@ -112,10 +114,10 @@ pub(crate) fn classify_name(db: &RootDatabase, name: InFile<&ast::Name>) -> Opti\n             },\n             ast::TypeParam(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::TypeParam::from_source(db, src)?;\n+                let def = hir::TypeParam::from_source(sb.db, src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: def.module(db),\n+                    container: def.module(sb.db),\n                     kind: NameKind::TypeParam(def),\n                 })\n             },\n@@ -125,56 +127,58 @@ pub(crate) fn classify_name(db: &RootDatabase, name: InFile<&ast::Name>) -> Opti\n }\n \n pub(crate) fn classify_name_ref(\n-    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n     name_ref: InFile<&ast::NameRef>,\n ) -> Option<NameDefinition> {\n     let _p = profile(\"classify_name_ref\");\n \n     let parent = name_ref.value.syntax().parent()?;\n-    let analyzer = SourceAnalyzer::new(db, name_ref.map(|it| it.syntax()), None);\n+    let analyzer = sb.analyze(name_ref.map(|it| it.syntax()), None);\n \n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(from_assoc_item(db, func.into()));\n+            return Some(from_assoc_item(sb.db, func.into()));\n         }\n     }\n \n     if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_fields);\n         if let Some(field) = analyzer.resolve_field(&field_expr) {\n-            return Some(from_struct_field(db, field));\n+            return Some(from_struct_field(sb.db, field));\n         }\n     }\n \n     if let Some(record_field) = ast::RecordField::cast(parent.clone()) {\n         tested_by!(goto_def_for_record_fields);\n         tested_by!(goto_def_for_field_init_shorthand);\n         if let Some(field_def) = analyzer.resolve_record_field(&record_field) {\n-            return Some(from_struct_field(db, field_def));\n+            return Some(from_struct_field(sb.db, field_def));\n         }\n     }\n \n-    let ast = ModuleSource::from_child_node(db, name_ref.with_value(&parent));\n+    let ast = ModuleSource::from_child_node(sb.db, name_ref.with_value(&parent));\n     // FIXME: find correct container and visibility for each case\n-    let container = Module::from_definition(db, name_ref.with_value(ast))?;\n+    let container = Module::from_definition(sb.db, name_ref.with_value(ast))?;\n     let visibility = None;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n-        if let Some(macro_def) = analyzer.resolve_macro_call(db, name_ref.with_value(&macro_call)) {\n+        if let Some(macro_def) =\n+            analyzer.resolve_macro_call(sb.db, name_ref.with_value(&macro_call))\n+        {\n             let kind = NameKind::Macro(macro_def);\n             return Some(NameDefinition { kind, container, visibility });\n         }\n     }\n \n     let path = name_ref.value.syntax().ancestors().find_map(ast::Path::cast)?;\n-    let resolved = analyzer.resolve_path(db, &path)?;\n+    let resolved = analyzer.resolve_path(sb.db, &path)?;\n     match resolved {\n-        PathResolution::Def(def) => Some(from_module_def(db, def, Some(container))),\n-        PathResolution::AssocItem(item) => Some(from_assoc_item(db, item)),\n+        PathResolution::Def(def) => Some(from_module_def(sb.db, def, Some(container))),\n+        PathResolution::AssocItem(item) => Some(from_assoc_item(sb.db, item)),\n         PathResolution::Local(local) => {\n-            let container = local.module(db);\n+            let container = local.module(sb.db);\n             let kind = NameKind::Local(local);\n             Some(NameDefinition { kind, container, visibility: None })\n         }\n@@ -188,7 +192,7 @@ pub(crate) fn classify_name_ref(\n         }\n         PathResolution::SelfType(impl_block) => {\n             let kind = NameKind::SelfType(impl_block);\n-            let container = impl_block.module(db);\n+            let container = impl_block.module(sb.db);\n             Some(NameDefinition { kind, container, visibility })\n         }\n     }"}, {"sha": "0411977b9e6f2b9c73e1fbe99aab1ca0bb9de9f4", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{InFile, Name};\n+use hir::{InFile, Name, SourceBinder};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n@@ -84,6 +84,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n         hash((file_id, name, shadow_count))\n     }\n \n+    let mut sb = SourceBinder::new(db);\n+\n     // Visited nodes to handle highlighting priorities\n     // FIXME: retain only ranges here\n     let mut highlighted: FxHashSet<SyntaxElement> = FxHashSet::default();\n@@ -108,8 +110,8 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             NAME_REF if node.ancestors().any(|it| it.kind() == ATTR) => continue,\n             NAME_REF => {\n                 let name_ref = node.as_node().cloned().and_then(ast::NameRef::cast).unwrap();\n-                let name_kind =\n-                    classify_name_ref(db, InFile::new(file_id.into(), &name_ref)).map(|d| d.kind);\n+                let name_kind = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n+                    .map(|d| d.kind);\n                 match name_kind {\n                     Some(name_kind) => {\n                         if let Local(local) = &name_kind {\n@@ -129,7 +131,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n             NAME => {\n                 let name = node.as_node().cloned().and_then(ast::Name::cast).unwrap();\n                 let name_kind =\n-                    classify_name(db, InFile::new(file_id.into(), &name)).map(|d| d.kind);\n+                    classify_name(&mut sb, InFile::new(file_id.into(), &name)).map(|d| d.kind);\n \n                 if let Some(Local(local)) = &name_kind {\n                     if let Some(name) = local.name(db) {\n@@ -308,9 +310,12 @@ pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padd\n \n #[cfg(test)]\n mod tests {\n-    use crate::mock_analysis::single_file;\n+    use std::fs;\n+\n     use test_utils::{assert_eq_text, project_dir, read_text};\n \n+    use crate::mock_analysis::{single_file, MockAnalysis};\n+\n     #[test]\n     fn test_highlighting() {\n         let (analysis, file_id) = single_file(\n@@ -357,7 +362,7 @@ impl<X> E<X> {\n         let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/highlighting.html\");\n         let actual_html = &analysis.highlight_as_html(file_id, false).unwrap();\n         let expected_html = &read_text(&dst_file);\n-        std::fs::write(dst_file, &actual_html).unwrap();\n+        fs::write(dst_file, &actual_html).unwrap();\n         assert_eq_text!(expected_html, actual_html);\n     }\n \n@@ -383,7 +388,21 @@ fn bar() {\n         let dst_file = project_dir().join(\"crates/ra_ide/src/snapshots/rainbow_highlighting.html\");\n         let actual_html = &analysis.highlight_as_html(file_id, true).unwrap();\n         let expected_html = &read_text(&dst_file);\n-        std::fs::write(dst_file, &actual_html).unwrap();\n+        fs::write(dst_file, &actual_html).unwrap();\n         assert_eq_text!(expected_html, actual_html);\n     }\n+\n+    #[test]\n+    fn accidentally_quadratic() {\n+        let file = project_dir().join(\"crates/ra_syntax/test_data/accidentally_quadratic\");\n+        let src = fs::read_to_string(file).unwrap();\n+\n+        let mut mock = MockAnalysis::new();\n+        let file_id = mock.add_file(\"/main.rs\", &src);\n+        let host = mock.analysis_host();\n+\n+        // let t = std::time::Instant::now();\n+        let _ = host.analysis().highlight(file_id).unwrap();\n+        // eprintln!(\"elapsed: {:?}\", t.elapsed());\n+    }\n }"}, {"sha": "428f83a627b2e597ffefe9f77e02abbe675f847b", "filename": "crates/ra_syntax/test_data/accidentally_quadratic", "status": "added", "additions": 3980, "deletions": 0, "changes": 3980, "blob_url": "https://github.com/rust-lang/rust/blob/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_syntax%2Ftest_data%2Faccidentally_quadratic", "raw_url": "https://github.com/rust-lang/rust/raw/c78d269b66dd7e02321bf447eef1375c81f66a1e/crates%2Fra_syntax%2Ftest_data%2Faccidentally_quadratic", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftest_data%2Faccidentally_quadratic?ref=c78d269b66dd7e02321bf447eef1375c81f66a1e"}]}