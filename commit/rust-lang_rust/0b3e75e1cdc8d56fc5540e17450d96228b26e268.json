{"sha": "0b3e75e1cdc8d56fc5540e17450d96228b26e268", "node_id": "C_kwDOAAsO6NoAKDBiM2U3NWUxY2RjOGQ1NmZjNTU0MGUxNzQ1MGQ5NjIyOGIyNmUyNjg", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-11-01T09:31:31Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-11-01T09:31:31Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "ba2f1ca144b5dcfa25847ad79acc642691b0b34f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba2f1ca144b5dcfa25847ad79acc642691b0b34f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b3e75e1cdc8d56fc5540e17450d96228b26e268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3e75e1cdc8d56fc5540e17450d96228b26e268", "html_url": "https://github.com/rust-lang/rust/commit/0b3e75e1cdc8d56fc5540e17450d96228b26e268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b3e75e1cdc8d56fc5540e17450d96228b26e268/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc05f60c1ff4e2cb2e6eb80c9b3afa612ce28c7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc05f60c1ff4e2cb2e6eb80c9b3afa612ce28c7f", "html_url": "https://github.com/rust-lang/rust/commit/dc05f60c1ff4e2cb2e6eb80c9b3afa612ce28c7f"}, {"sha": "ba28e19b7838e3ad4223ae82d074dc3950ef1548", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba28e19b7838e3ad4223ae82d074dc3950ef1548", "html_url": "https://github.com/rust-lang/rust/commit/ba28e19b7838e3ad4223ae82d074dc3950ef1548"}], "stats": {"total": 1228, "additions": 824, "deletions": 404}, "files": [{"sha": "8931c17bbdc16fec06fd99243ef9a62e40f62ab1", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -872,9 +872,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.93.1\"\n+version = \"0.93.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3bcfee315dde785ba887edb540b08765fd7df75a7d948844be6bf5712246734\"\n+checksum = \"9be6e9c7e2d18f651974370d7aff703f9513e0df6e464fd795660edc77e6ca51\"\n dependencies = [\n  \"bitflags\",\n  \"serde\","}, {"sha": "8a91d6066614f5b34e5a1c0a138c97ec42fe33d7", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -295,7 +295,9 @@ impl FlycheckActor {\n             } => {\n                 let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\"]);\n+                cmd.current_dir(&self.root);\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.root.join(\"Cargo.toml\").as_os_str());\n \n                 if let Some(target) = target_triple {\n                     cmd.args(&[\"--target\", target.as_str()]);"}, {"sha": "79249757d9e9bb407aee638c8338e489b58c7842", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -662,8 +662,12 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let mut generic_args: Vec<_> =\n         std::iter::repeat(None).take(path.segments().len() - 1).collect();\n     let mut last = GenericArgs::empty();\n-    let binding =\n-        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    let binding = AssociatedTypeBinding {\n+        name: name![Output],\n+        args: None,\n+        type_ref: Some(orig),\n+        bounds: Vec::new(),\n+    };\n     last.bindings.push(binding);\n     generic_args.push(Some(Interned::new(last)));\n "}, {"sha": "592223f7d85fe76c020892ce158625c9eeec28a5", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -68,6 +68,9 @@ pub struct GenericArgs {\n pub struct AssociatedTypeBinding {\n     /// The name of the associated type.\n     pub name: Name,\n+    /// The generic arguments to the associated type. e.g. For `Trait<Assoc<'a, T> = &'a T>`, this\n+    /// would be `['a, T]`.\n+    pub args: Option<Interned<GenericArgs>>,\n     /// The type bound to this associated type (in `Item = T`, this would be the\n     /// `T`). This can be `None` if there are bounds instead.\n     pub type_ref: Option<TypeRef>,"}, {"sha": "cfa3a6baaf8b4aae5cfc8dcdda63202036fd9c6a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -163,6 +163,10 @@ pub(super) fn lower_generic_args(\n             ast::GenericArg::AssocTypeArg(assoc_type_arg) => {\n                 if let Some(name_ref) = assoc_type_arg.name_ref() {\n                     let name = name_ref.as_name();\n+                    let args = assoc_type_arg\n+                        .generic_arg_list()\n+                        .and_then(|args| lower_generic_args(lower_ctx, args))\n+                        .map(Interned::new);\n                     let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n                     let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n                         l.bounds()\n@@ -171,7 +175,7 @@ pub(super) fn lower_generic_args(\n                     } else {\n                         Vec::new()\n                     };\n-                    bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+                    bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });\n                 }\n             }\n             ast::GenericArg::LifetimeArg(lifetime_arg) => {\n@@ -214,6 +218,7 @@ fn lower_generic_args_from_fn_path(\n         let type_ref = TypeRef::from_ast_opt(ctx, ret_type.ty());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n+            args: None,\n             type_ref: Some(type_ref),\n             bounds: Vec::new(),\n         });\n@@ -222,6 +227,7 @@ fn lower_generic_args_from_fn_path(\n         let type_ref = TypeRef::Tuple(Vec::new());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n+            args: None,\n             type_ref: Some(type_ref),\n             bounds: Vec::new(),\n         });"}, {"sha": "996b42f5bd83c03bb906bddf466d5eaa2c863973", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -11,9 +11,9 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n-    from_placeholder_idx, to_chalk_trait_id, AdtId, AliasEq, AliasTy, Binders, CallableDefId,\n-    CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy, QuantifiedWhereClause,\n-    Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n+    from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n+    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, WhereClause,\n };\n \n pub trait TyExt {\n@@ -338,10 +338,13 @@ pub trait ProjectionTyExt {\n \n impl ProjectionTyExt for ProjectionTy {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n-        TraitRef {\n-            trait_id: to_chalk_trait_id(self.trait_(db)),\n-            substitution: self.substitution.clone(),\n-        }\n+        // FIXME: something like `Split` trait from chalk-solve might be nice.\n+        let generics = generics(db.upcast(), from_assoc_type_id(self.associated_ty_id).into());\n+        let substitution = Substitution::from_iter(\n+            Interner,\n+            self.substitution.iter(Interner).skip(generics.len_self()),\n+        );\n+        TraitRef { trait_id: to_chalk_trait_id(self.trait_(db)), substitution }\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {"}, {"sha": "5ad66132635340c410488f425529be1d4397720f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -289,16 +289,18 @@ impl HirDisplay for ProjectionTy {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        let trait_ = f.db.trait_data(self.trait_(f.db));\n+        let trait_ref = self.trait_ref(f.db);\n         write!(f, \"<\")?;\n-        self.self_type_parameter(f.db).hir_fmt(f)?;\n-        write!(f, \" as {}\", trait_.name)?;\n-        if self.substitution.len(Interner) > 1 {\n+        fmt_trait_ref(&trait_ref, f, true)?;\n+        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n+        let proj_params_count =\n+            self.substitution.len(Interner) - trait_ref.substitution.len(Interner);\n+        let proj_params = &self.substitution.as_slice(Interner)[..proj_params_count];\n+        if !proj_params.is_empty() {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.substitution.as_slice(Interner)[1..], \", \")?;\n+            f.write_joined(proj_params, \", \")?;\n             write!(f, \">\")?;\n         }\n-        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n         Ok(())\n     }\n }\n@@ -641,9 +643,12 @@ impl HirDisplay for Ty {\n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     write!(f, \"{}::{}\", trait_.name, type_alias_data.name)?;\n+                    // Note that the generic args for the associated type come before those for the\n+                    // trait (including the self type).\n+                    // FIXME: reconsider the generic args order upon formatting?\n                     if parameters.len(Interner) > 0 {\n                         write!(f, \"<\")?;\n-                        f.write_joined(&*parameters.as_slice(Interner), \", \")?;\n+                        f.write_joined(parameters.as_slice(Interner), \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 } else {\n@@ -972,9 +977,20 @@ fn write_bounds_like_dyn_trait(\n                     angle_open = true;\n                 }\n                 if let AliasTy::Projection(proj) = alias {\n-                    let type_alias =\n-                        f.db.type_alias_data(from_assoc_type_id(proj.associated_ty_id));\n-                    write!(f, \"{} = \", type_alias.name)?;\n+                    let assoc_ty_id = from_assoc_type_id(proj.associated_ty_id);\n+                    let type_alias = f.db.type_alias_data(assoc_ty_id);\n+                    write!(f, \"{}\", type_alias.name)?;\n+\n+                    let proj_arg_count = generics(f.db.upcast(), assoc_ty_id.into()).len_self();\n+                    if proj_arg_count > 0 {\n+                        write!(f, \"<\")?;\n+                        f.write_joined(\n+                            &proj.substitution.as_slice(Interner)[..proj_arg_count],\n+                            \", \",\n+                        )?;\n+                        write!(f, \">\")?;\n+                    }\n+                    write!(f, \" = \")?;\n                 }\n                 ty.hir_fmt(f)?;\n             }"}, {"sha": "ebe9d6fb5e0146d6c687f17a925c1c1e74a88a2e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -157,7 +157,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let TyKind::Error = ty.kind(Interner) {\n+                if ty.is_unknown() {\n                     return None;\n                 }\n "}, {"sha": "12f45f00f9c4dce9a1052c39fe7e6f6c2f6b70fa", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -340,8 +340,8 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback(t, &|_, _, d, _| d)\n     }\n \n-    /// Unify two types and register new trait goals that arise from that.\n-    pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+    /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.\n+    pub(crate) fn unify<T: ?Sized + Zip<Interner>>(&mut self, ty1: &T, ty2: &T) -> bool {\n         let result = match self.try_unify(ty1, ty2) {\n             Ok(r) => r,\n             Err(_) => return false,\n@@ -350,9 +350,13 @@ impl<'a> InferenceTable<'a> {\n         true\n     }\n \n-    /// Unify two types and return new trait goals arising from it, so the\n+    /// Unify two relatable values (e.g. `Ty`) and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult<()> {\n+    pub(crate) fn try_unify<T: ?Sized + Zip<Interner>>(\n+        &mut self,\n+        t1: &T,\n+        t2: &T,\n+    ) -> InferResult<()> {\n         match self.var_unification_table.relate(\n             Interner,\n             &self.db,"}, {"sha": "42c3b58d5ada520ba626c22c5ace408f007b2797", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -81,7 +81,20 @@ pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n pub type VariableKind = chalk_ir::VariableKind<Interner>;\n pub type VariableKinds = chalk_ir::VariableKinds<Interner>;\n pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n+/// Represents generic parameters and an item bound by them. When the item has parent, the binders\n+/// also contain the generic parameters for its parent. See chalk's documentation for details.\n+///\n+/// One thing to keep in mind when working with `Binders` (and `Substitution`s, which represent\n+/// generic arguments) in rust-analyzer is that the ordering within *is* significant - the generic\n+/// parameters/arguments for an item MUST come before those for its parent. This is to facilitate\n+/// the integration with chalk-solve, which mildly puts constraints as such. See #13335 for its\n+/// motivation in detail.\n pub type Binders<T> = chalk_ir::Binders<T>;\n+/// Interned list of generic arguments for an item. When an item has parent, the `Substitution` for\n+/// it contains generic arguments for both its parent and itself. See chalk's documentation for\n+/// details.\n+///\n+/// See `Binders` for the constraint on the ordering.\n pub type Substitution = chalk_ir::Substitution<Interner>;\n pub type GenericArg = chalk_ir::GenericArg<Interner>;\n pub type GenericArgData = chalk_ir::GenericArgData<Interner>;\n@@ -124,14 +137,6 @@ pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;\n pub type Guidance = chalk_solve::Guidance<Interner>;\n pub type WhereClause = chalk_ir::WhereClause<Interner>;\n \n-// FIXME: get rid of this\n-pub fn subst_prefix(s: &Substitution, n: usize) -> Substitution {\n-    Substitution::from_iter(\n-        Interner,\n-        s.as_slice(Interner)[..std::cmp::min(s.len(Interner), n)].iter().cloned(),\n-    )\n-}\n-\n /// Return an index of a parameter in the generic type parameter list by it's id.\n pub fn param_idx(db: &dyn HirDatabase, id: TypeOrConstParamId) -> Option<usize> {\n     generics(db.upcast(), id.parent).param_idx(id)\n@@ -382,7 +387,6 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n pub fn replace_errors_with_variables<T>(t: &T) -> Canonical<T>\n where\n     T: HasInterner<Interner = Interner> + TypeFoldable<Interner> + Clone,\n-    T: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n         fold::{FallibleTypeFolder, TypeSuperFoldable},"}, {"sha": "22a85cf154587fa79e05807f3196391255b6513e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 91, "deletions": 33, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -447,12 +447,31 @@ impl<'a> TyLoweringContext<'a> {\n                             .db\n                             .trait_data(trait_ref.hir_trait_id())\n                             .associated_type_by_name(segment.name);\n+\n                         match found {\n                             Some(associated_ty) => {\n-                                // FIXME handle type parameters on the segment\n+                                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                                // that method to optionally take parent `Substitution` as we already know them at\n+                                // this point (`trait_ref.substitution`).\n+                                let substitution = self.substs_from_path_segment(\n+                                    segment,\n+                                    Some(associated_ty.into()),\n+                                    false,\n+                                    None,\n+                                );\n+                                let len_self =\n+                                    generics(self.db.upcast(), associated_ty.into()).len_self();\n+                                let substitution = Substitution::from_iter(\n+                                    Interner,\n+                                    substitution\n+                                        .iter(Interner)\n+                                        .take(len_self)\n+                                        .chain(trait_ref.substitution.iter(Interner)),\n+                                );\n                                 TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                                    substitution: trait_ref.substitution,\n+                                    substitution,\n                                 }))\n                                 .intern(Interner)\n                             }\n@@ -590,36 +609,48 @@ impl<'a> TyLoweringContext<'a> {\n             res,\n             Some(segment.name.clone()),\n             move |name, t, associated_ty| {\n-                if name == segment.name {\n-                    let substs = match self.type_param_mode {\n-                        ParamLoweringMode::Placeholder => {\n-                            // if we're lowering to placeholders, we have to put\n-                            // them in now\n-                            let generics = generics(\n-                                self.db.upcast(),\n-                                self.resolver\n-                                    .generic_def()\n-                                    .expect(\"there should be generics if there's a generic param\"),\n-                            );\n-                            let s = generics.placeholder_subst(self.db);\n-                            s.apply(t.substitution.clone(), Interner)\n-                        }\n-                        ParamLoweringMode::Variable => t.substitution.clone(),\n-                    };\n-                    // We need to shift in the bound vars, since\n-                    // associated_type_shorthand_candidates does not do that\n-                    let substs = substs.shifted_in_from(Interner, self.in_binders);\n-                    // FIXME handle type parameters on the segment\n-                    Some(\n-                        TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                            associated_ty_id: to_assoc_type_id(associated_ty),\n-                            substitution: substs,\n-                        }))\n-                        .intern(Interner),\n-                    )\n-                } else {\n-                    None\n+                if name != segment.name {\n+                    return None;\n                 }\n+\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`t.substitution`).\n+                let substs = self.substs_from_path_segment(\n+                    segment.clone(),\n+                    Some(associated_ty.into()),\n+                    false,\n+                    None,\n+                );\n+\n+                let len_self = generics(self.db.upcast(), associated_ty.into()).len_self();\n+\n+                let substs = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter(Interner).take(len_self).chain(t.substitution.iter(Interner)),\n+                );\n+\n+                let substs = match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // if we're lowering to placeholders, we have to put\n+                        // them in now\n+                        let generics = generics(self.db.upcast(), def);\n+                        let s = generics.placeholder_subst(self.db);\n+                        s.apply(substs, Interner)\n+                    }\n+                    ParamLoweringMode::Variable => substs,\n+                };\n+                // We need to shift in the bound vars, since\n+                // associated_type_shorthand_candidates does not do that\n+                let substs = substs.shifted_in_from(Interner, self.in_binders);\n+                Some(\n+                    TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(associated_ty),\n+                        substitution: substs,\n+                    }))\n+                    .intern(Interner),\n+                )\n             },\n         );\n \n@@ -777,7 +808,15 @@ impl<'a> TyLoweringContext<'a> {\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n-        if !infer_args || had_explicit_args {\n+        // Generic parameters for associated types are not supposed to have defaults, so we just\n+        // ignore them.\n+        let is_assoc_ty = if let GenericDefId::TypeAliasId(id) = def {\n+            let container = id.lookup(self.db.upcast()).container;\n+            matches!(container, ItemContainerId::TraitId(_))\n+        } else {\n+            false\n+        };\n+        if !is_assoc_ty && (!infer_args || had_explicit_args) {\n             let defaults = self.db.generic_defaults(def);\n             assert_eq!(total_len, defaults.len());\n             let parent_from = item_len - substs.len();\n@@ -966,9 +1005,28 @@ impl<'a> TyLoweringContext<'a> {\n                     None => return SmallVec::new(),\n                     Some(t) => t,\n                 };\n+                // FIXME: `substs_from_path_segment()` pushes `TyKind::Error` for every parent\n+                // generic params. It's inefficient to splice the `Substitution`s, so we may want\n+                // that method to optionally take parent `Substitution` as we already know them at\n+                // this point (`super_trait_ref.substitution`).\n+                let substitution = self.substs_from_path_segment(\n+                    // FIXME: This is hack. We shouldn't really build `PathSegment` directly.\n+                    PathSegment { name: &binding.name, args_and_bindings: binding.args.as_deref() },\n+                    Some(associated_ty.into()),\n+                    false, // this is not relevant\n+                    Some(super_trait_ref.self_type_parameter(Interner)),\n+                );\n+                let self_params = generics(self.db.upcast(), associated_ty.into()).len_self();\n+                let substitution = Substitution::from_iter(\n+                    Interner,\n+                    substitution\n+                        .iter(Interner)\n+                        .take(self_params)\n+                        .chain(super_trait_ref.substitution.iter(Interner)),\n+                );\n                 let projection_ty = ProjectionTy {\n                     associated_ty_id: to_assoc_type_id(associated_ty),\n-                    substitution: super_trait_ref.substitution,\n+                    substitution,\n                 };\n                 let mut preds: SmallVec<[_; 1]> = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),"}, {"sha": "50859475e1d948cf8361522dcefc40fa7c32b2b6", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -22,10 +22,10 @@ use crate::{\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n-    static_lifetime,\n+    static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -624,52 +624,76 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+/// Looks up the impl method that actually runs for the trait method `func`.\n+///\n+/// Returns `func` if it's not a method defined in a trait or the lookup failed.\n pub fn lookup_impl_method(\n-    self_ty: &Ty,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: TraitId,\n+    func: FunctionId,\n+    fn_subst: Substitution,\n+) -> FunctionId {\n+    let trait_id = match func.lookup(db.upcast()).container {\n+        ItemContainerId::TraitId(id) => id,\n+        _ => return func,\n+    };\n+    let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n+    let fn_params = fn_subst.len(Interner) - trait_params;\n+    let trait_ref = TraitRef {\n+        trait_id: to_chalk_trait_id(trait_id),\n+        substitution: Substitution::from_iter(Interner, fn_subst.iter(Interner).skip(fn_params)),\n+    };\n+\n+    let name = &db.function_data(func).name;\n+    lookup_impl_method_for_trait_ref(trait_ref, db, env, name).unwrap_or(func)\n+}\n+\n+fn lookup_impl_method_for_trait_ref(\n+    trait_ref: TraitRef,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: &Name,\n ) -> Option<FunctionId> {\n-    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty)?;\n-    let trait_impls = db.trait_impls_in_deps(env.krate);\n-    let impls = trait_impls.for_trait_and_self_ty(trait_, self_ty_fp);\n-    let mut table = InferenceTable::new(db, env.clone());\n-    find_matching_impl(impls, &mut table, &self_ty).and_then(|data| {\n-        data.items.iter().find_map(|it| match it {\n-            AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n-            _ => None,\n-        })\n+    let self_ty = trait_ref.self_type_parameter(Interner);\n+    let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n+    let impls = db.trait_impls_in_deps(env.krate);\n+    let impls = impls.for_trait_and_self_ty(trait_ref.hir_trait_id(), self_ty_fp);\n+\n+    let table = InferenceTable::new(db, env);\n+\n+    let impl_data = find_matching_impl(impls, table, trait_ref)?;\n+    impl_data.items.iter().find_map(|it| match it {\n+        AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+        _ => None,\n     })\n }\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n-    table: &mut InferenceTable<'_>,\n-    self_ty: &Ty,\n+    mut table: InferenceTable<'_>,\n+    actual_trait_ref: TraitRef,\n ) -> Option<Arc<ImplData>> {\n     let db = table.db;\n     loop {\n         let impl_ = impls.next()?;\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n-            let substs =\n+            let impl_substs =\n                 TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n-            let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n-\n-            table\n-                .unify(self_ty, &impl_ty)\n-                .then(|| {\n-                    let wh_goals =\n-                        crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n-                            .into_iter()\n-                            .map(|b| b.cast(Interner));\n+            let trait_ref = db\n+                .impl_trait(impl_)\n+                .expect(\"non-trait method in find_matching_impl\")\n+                .substitute(Interner, &impl_substs);\n \n-                    let goal = crate::Goal::all(Interner, wh_goals);\n+            if !table.unify(&trait_ref, &actual_trait_ref) {\n+                return None;\n+            }\n \n-                    table.try_obligation(goal).map(|_| impl_data)\n-                })\n-                .flatten()\n+            let wcs = crate::chalk_db::convert_where_clauses(db, impl_.into(), &impl_substs)\n+                .into_iter()\n+                .map(|b| b.cast(Interner));\n+            let goal = crate::Goal::all(Interner, wcs);\n+            table.try_obligation(goal).map(|_| impl_data)\n         });\n         if r.is_some() {\n             break r;\n@@ -1214,7 +1238,7 @@ fn is_valid_fn_candidate(\n             let expected_receiver =\n                 sig.map(|s| s.params()[0].clone()).substitute(Interner, &fn_subst);\n \n-            check_that!(table.unify(&receiver_ty, &expected_receiver));\n+            check_that!(table.unify(receiver_ty, &expected_receiver));\n         }\n \n         if let ItemContainerId::ImplId(impl_id) = container {"}, {"sha": "425432479e8159a822c907ce1b7ddd245530fbe1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/display_source_code.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -196,3 +196,34 @@ fn test(\n \"#,\n     );\n }\n+\n+#[test]\n+fn projection_type_correct_arguments_order() {\n+    check_types_source_code(\n+        r#\"\n+trait Foo<T> {\n+    type Assoc<U>;\n+}\n+fn f<T: Foo<i32>>(a: T::Assoc<usize>) {\n+    a;\n+  //^ <T as Foo<i32>>::Assoc<usize>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn generic_associated_type_binding_in_impl_trait() {\n+    check_types_source_code(\n+        r#\"\n+//- minicore: sized\n+trait Foo<T> {\n+    type Assoc<U>;\n+}\n+fn f(a: impl Foo<i8, Assoc<i16> = i32>) {\n+    a;\n+  //^ impl Foo<i8, Assoc<i16> = i32>\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "7d42b8b9bc8d80951f258da956e786ee0a681273", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -3963,3 +3963,124 @@ fn g(t: &(dyn T + Send)) {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn gats_in_path() {\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+trait PointerFamily {\n+    type Pointer<T>: Deref<Target = T>;\n+}\n+\n+fn f<P: PointerFamily>(p: P::Pointer<i32>) {\n+    let a = *p;\n+      //^ i32\n+}\n+fn g<P: PointerFamily>(p: <P as PointerFamily>::Pointer<i32>) {\n+    let a = *p;\n+      //^ i32\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn gats_with_impl_trait() {\n+    // FIXME: the last function (`fn i()`) is not valid Rust as of this writing because you cannot\n+    // specify the same associated type multiple times even if their arguments are different (c.f.\n+    // `fn h()`, which is valid). Reconsider how to treat these invalid types.\n+    check_types(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(v: impl Trait) {\n+    let a = v.get::<i32>().deref();\n+      //^ &i32\n+    let a = v.get::<T>().deref();\n+      //^ &T\n+}\n+fn g<'a, T: 'a>(v: impl Trait<Assoc<T> = &'a T>) {\n+    let a = v.get::<T>();\n+      //^ &T\n+    let a = v.get::<()>();\n+      //^ Trait::Assoc<(), impl Trait<Assoc<T> = &T>>\n+}\n+fn h<'a>(v: impl Trait<Assoc<i32> = &'a i32> + Trait<Assoc<i64> = &'a i64>) {\n+    let a = v.get::<i32>();\n+      //^ &i32\n+    let a = v.get::<i64>();\n+      //^ &i64\n+}\n+fn i<'a>(v: impl Trait<Assoc<i32> = &'a i32, Assoc<i64> = &'a i64>) {\n+    let a = v.get::<i32>();\n+      //^ &i32\n+    let a = v.get::<i64>();\n+      //^ &i64\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn gats_with_dyn() {\n+    // This test is here to keep track of how we infer things despite traits with GATs being not\n+    // object-safe currently.\n+    // FIXME: reconsider how to treat these invalid types.\n+    check_infer_with_mismatches(\n+        r#\"\n+//- minicore: deref\n+use core::ops::Deref;\n+\n+trait Trait {\n+    type Assoc<T>: Deref<Target = T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<'a>(v: &dyn Trait<Assoc<i32> = &'a i32>) {\n+    v.get::<i32>().deref();\n+}\n+    \"#,\n+        expect![[r#\"\n+            90..94 'self': &Self\n+            127..128 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            164..195 '{     ...f(); }': ()\n+            170..171 'v': &(dyn Trait<Assoc<i32> = &i32>)\n+            170..184 'v.get::<i32>()': &i32\n+            170..192 'v.get:...eref()': &i32\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn gats_in_associated_type_binding() {\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Assoc<T>;\n+    fn get<U>(&self) -> Self::Assoc<U>;\n+}\n+\n+fn f<T>(t: T)\n+where\n+    T: Trait<Assoc<i32> = u32>,\n+    T: Trait<Assoc<isize> = usize>,\n+{\n+    let a = t.get::<i32>();\n+      //^ u32\n+    let a = t.get::<isize>();\n+      //^ usize\n+    let a = t.get::<()>();\n+      //^ Trait::Assoc<(), T>\n+}\n+\n+    \"#,\n+    );\n+}"}, {"sha": "92711a24fe39fdc317328f7c76894c859ef76e64", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tls.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -5,7 +5,7 @@ use itertools::Itertools;\n \n use crate::{\n     chalk_db, db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, mapping::from_chalk,\n-    CallableDefId, Interner,\n+    CallableDefId, Interner, ProjectionTyExt,\n };\n use hir_def::{AdtId, ItemContainerId, Lookup, TypeAliasId};\n \n@@ -63,17 +63,31 @@ impl DebugContext<'_> {\n             ItemContainerId::TraitId(t) => t,\n             _ => panic!(\"associated type not in trait\"),\n         };\n-        let trait_data = self.0.trait_data(trait_);\n-        let params = projection_ty.substitution.as_slice(Interner);\n-        write!(fmt, \"<{:?} as {}\", &params[0], trait_data.name,)?;\n-        if params.len() > 1 {\n+        let trait_name = &self.0.trait_data(trait_).name;\n+        let trait_ref = projection_ty.trait_ref(self.0);\n+        let trait_params = trait_ref.substitution.as_slice(Interner);\n+        let self_ty = trait_ref.self_type_parameter(Interner);\n+        write!(fmt, \"<{:?} as {}\", self_ty, trait_name)?;\n+        if trait_params.len() > 1 {\n+            write!(\n+                fmt,\n+                \"<{}>\",\n+                trait_params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+            )?;\n+        }\n+        write!(fmt, \">::{}\", type_alias_data.name)?;\n+\n+        let proj_params_count = projection_ty.substitution.len(Interner) - trait_params.len();\n+        let proj_params = &projection_ty.substitution.as_slice(Interner)[..proj_params_count];\n+        if !proj_params.is_empty() {\n             write!(\n                 fmt,\n                 \"<{}>\",\n-                &params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n+                proj_params.iter().format_with(\", \", |x, f| f(&format_args!(\"{:?}\", x))),\n             )?;\n         }\n-        write!(fmt, \">::{}\", type_alias_data.name)\n+\n+        Ok(())\n     }\n \n     pub(crate) fn debug_fn_def_id("}, {"sha": "f86c571005367e5b4015472c55d1b8fd694c2d99", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -270,7 +270,7 @@ impl SourceAnalyzer {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n \n-        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs))\n     }\n \n     pub(crate) fn resolve_await_to_poll(\n@@ -311,7 +311,7 @@ impl SourceAnalyzer {\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n-        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, substs))\n     }\n \n     pub(crate) fn resolve_prefix_expr(\n@@ -331,7 +331,7 @@ impl SourceAnalyzer {\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_index_expr(\n@@ -351,7 +351,7 @@ impl SourceAnalyzer {\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_bin_expr(\n@@ -372,7 +372,7 @@ impl SourceAnalyzer {\n             .push(rhs.clone())\n             .build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_try_expr(\n@@ -392,7 +392,7 @@ impl SourceAnalyzer {\n         // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -487,19 +487,22 @@ impl SourceAnalyzer {\n \n         let mut prefer_value_ns = false;\n         let resolved = (|| {\n+            let infer = self.infer.as_deref()?;\n             if let Some(path_expr) = parent().and_then(ast::PathExpr::cast) {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n-                let infer = self.infer.as_ref()?;\n                 if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n                     let assoc = match assoc {\n                         AssocItemId::FunctionId(f_in_trait) => {\n                             match infer.type_of_expr.get(expr_id) {\n                                 None => assoc,\n                                 Some(func_ty) => {\n                                     if let TyKind::FnDef(_fn_def, subs) = func_ty.kind(Interner) {\n-                                        self.resolve_impl_method(db, f_in_trait, subs)\n-                                            .map(AssocItemId::FunctionId)\n-                                            .unwrap_or(assoc)\n+                                        self.resolve_impl_method_or_trait_def(\n+                                            db,\n+                                            f_in_trait,\n+                                            subs.clone(),\n+                                        )\n+                                        .into()\n                                     } else {\n                                         assoc\n                                     }\n@@ -520,18 +523,18 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n+                if let Some(assoc) = infer.assoc_resolutions_for_pat(pat_id) {\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n-                    self.infer.as_ref()?.variant_resolution_for_pat(pat_id)\n+                    infer.variant_resolution_for_pat(pat_id)\n                 {\n                     return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                 }\n             } else if let Some(rec_lit) = parent().and_then(ast::RecordExpr::cast) {\n                 let expr_id = self.expr_id(db, &rec_lit.into())?;\n                 if let Some(VariantId::EnumVariantId(variant)) =\n-                    self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n+                    infer.variant_resolution_for_expr(expr_id)\n                 {\n                     return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                 }\n@@ -541,8 +544,7 @@ impl SourceAnalyzer {\n                     || parent().and_then(ast::TupleStructPat::cast).map(ast::Pat::from);\n                 if let Some(pat) = record_pat.or_else(tuple_struct_pat) {\n                     let pat_id = self.pat_id(&pat)?;\n-                    let variant_res_for_pat =\n-                        self.infer.as_ref()?.variant_resolution_for_pat(pat_id);\n+                    let variant_res_for_pat = infer.variant_resolution_for_pat(pat_id);\n                     if let Some(VariantId::EnumVariantId(variant)) = variant_res_for_pat {\n                         return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                     }\n@@ -780,37 +782,22 @@ impl SourceAnalyzer {\n         false\n     }\n \n-    fn resolve_impl_method(\n+    fn resolve_impl_method_or_trait_def(\n         &self,\n         db: &dyn HirDatabase,\n         func: FunctionId,\n-        substs: &Substitution,\n-    ) -> Option<FunctionId> {\n-        let impled_trait = match func.lookup(db.upcast()).container {\n-            ItemContainerId::TraitId(trait_id) => trait_id,\n-            _ => return None,\n-        };\n-        if substs.is_empty(Interner) {\n-            return None;\n-        }\n-        let self_ty = substs.at(Interner, 0).ty(Interner)?;\n+        substs: Substitution,\n+    ) -> FunctionId {\n         let krate = self.resolver.krate();\n-        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+        let owner = match self.resolver.body_owner() {\n+            Some(it) => it,\n+            None => return func,\n+        };\n+        let env = owner.as_generic_def_id().map_or_else(\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-\n-        let fun_data = db.function_data(func);\n-        method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n-    }\n-\n-    fn resolve_impl_method_or_trait_def(\n-        &self,\n-        db: &dyn HirDatabase,\n-        func: FunctionId,\n-        substs: &Substitution,\n-    ) -> FunctionId {\n-        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+        method_resolution::lookup_impl_method(db, env, func, substs)\n     }\n \n     fn lang_trait_fn("}, {"sha": "f97c67b144ac15e4c67d8ee86d2a6563ebdda77d", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -1834,4 +1834,86 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_bin_op_multiple_impl() {\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 S\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 0usize\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn path_call_multiple_trait_impl() {\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+     //^\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+}\n+fn main() {\n+    usize::f$0(0i32);\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+     //^\n+}\n+fn main() {\n+    usize::f$0(0i64);\n+}\n+\"#,\n+        )\n+    }\n }"}, {"sha": "7ae5324ab051ae7320d310ea01a54bc8a8c470a6", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -23,7 +23,7 @@ crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.5\"\n scip = \"0.1.1\"\n-lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n+lsp-types = { version = \"=0.93.2\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n xflags = \"0.3.0\"\n oorandom = \"11.1.3\""}, {"sha": "7bf595d2a45f51c8a0784c6790bab4af0ae6f72d", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -11,7 +11,7 @@ use std::{env, fs, path::Path, process};\n \n use lsp_server::Connection;\n use project_model::ProjectManifest;\n-use rust_analyzer::{cli::flags, config::Config, from_json, lsp_ext::supports_utf8, Result};\n+use rust_analyzer::{cli::flags, config::Config, from_json, Result};\n use vfs::AbsPathBuf;\n \n #[cfg(all(feature = \"mimalloc\"))]\n@@ -191,11 +191,7 @@ fn run_server() -> Result<()> {\n             name: String::from(\"rust-analyzer\"),\n             version: Some(rust_analyzer::version().to_string()),\n         }),\n-        offset_encoding: if supports_utf8(config.caps()) {\n-            Some(\"utf-8\".to_string())\n-        } else {\n-            None\n-        },\n+        offset_encoding: None,\n     };\n \n     let initialize_result = serde_json::to_value(initialize_result).unwrap();"}, {"sha": "723b888d9abc8a1100184debf1e4b47c33c6a740", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -6,19 +6,25 @@ use lsp_types::{\n     FileOperationFilter, FileOperationPattern, FileOperationPatternKind,\n     FileOperationRegistrationOptions, FoldingRangeProviderCapability, HoverProviderCapability,\n     ImplementationProviderCapability, InlayHintOptions, InlayHintServerCapabilities, OneOf,\n-    RenameOptions, SaveOptions, SelectionRangeProviderCapability, SemanticTokensFullOptions,\n-    SemanticTokensLegend, SemanticTokensOptions, ServerCapabilities, SignatureHelpOptions,\n-    TextDocumentSyncCapability, TextDocumentSyncKind, TextDocumentSyncOptions,\n-    TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n+    PositionEncodingKind, RenameOptions, SaveOptions, SelectionRangeProviderCapability,\n+    SemanticTokensFullOptions, SemanticTokensLegend, SemanticTokensOptions, ServerCapabilities,\n+    SignatureHelpOptions, TextDocumentSyncCapability, TextDocumentSyncKind,\n+    TextDocumentSyncOptions, TypeDefinitionProviderCapability, WorkDoneProgressOptions,\n     WorkspaceFileOperationsServerCapabilities, WorkspaceServerCapabilities,\n };\n use serde_json::json;\n \n use crate::config::{Config, RustfmtConfig};\n+use crate::lsp_ext::supports_utf8;\n use crate::semantic_tokens;\n \n pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n     ServerCapabilities {\n+        position_encoding: if supports_utf8(config.caps()) {\n+            Some(PositionEncodingKind::UTF8)\n+        } else {\n+            None\n+        },\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n             change: Some(TextDocumentSyncKind::INCREMENTAL),"}, {"sha": "5ff347b9bd7227dd886e73bf2b7bec69ce012a30", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -20,7 +20,7 @@ use crate::cli::{\n     load_cargo::{load_workspace, LoadCargoConfig},\n     Result,\n };\n-use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use crate::line_index::{LineEndings, LineIndex, PositionEncoding};\n use crate::to_proto;\n use crate::version::version;\n \n@@ -126,7 +126,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: OffsetEncoding::Utf16,\n+            encoding: PositionEncoding::Utf16,\n             endings: LineEndings::Unix,\n         };\n         let range_id = self.add_vertex(lsif::Vertex::Range {\n@@ -248,7 +248,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: OffsetEncoding::Utf16,\n+            encoding: PositionEncoding::Utf16,\n             endings: LineEndings::Unix,\n         };\n         let result = folds"}, {"sha": "16298862b50f39fbaee254c76ccb8190ad4ec017", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -5,7 +5,7 @@ use std::{\n     time::Instant,\n };\n \n-use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use crate::line_index::{LineEndings, LineIndex, PositionEncoding};\n use hir::Name;\n use ide::{\n     LineCol, MonikerDescriptorKind, StaticIndex, StaticIndexedFile, TextRange, TokenId,\n@@ -91,7 +91,7 @@ impl flags::Scip {\n \n             let line_index = LineIndex {\n                 index: db.line_index(file_id),\n-                encoding: OffsetEncoding::Utf8,\n+                encoding: PositionEncoding::Utf8,\n                 endings: LineEndings::Unix,\n             };\n "}, {"sha": "1ed8f2bb5f35a639e16d7a4b641677ce94ead90c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -32,7 +32,7 @@ use vfs::AbsPathBuf;\n use crate::{\n     caps::completion_item_edit_resolve,\n     diagnostics::DiagnosticsMapConfig,\n-    line_index::OffsetEncoding,\n+    line_index::PositionEncoding,\n     lsp_ext::{self, supports_utf8, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n };\n \n@@ -948,11 +948,11 @@ impl Config {\n         .is_some()\n     }\n \n-    pub fn offset_encoding(&self) -> OffsetEncoding {\n+    pub fn position_encoding(&self) -> PositionEncoding {\n         if supports_utf8(&self.caps) {\n-            OffsetEncoding::Utf8\n+            PositionEncoding::Utf8\n         } else {\n-            OffsetEncoding::Utf16\n+            PositionEncoding::Utf16\n         }\n     }\n "}, {"sha": "189ac2fbf53393a1752ab1c50114803751ae3c58", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -8,7 +8,7 @@ use stdx::format_to;\n use vfs::{AbsPath, AbsPathBuf};\n \n use crate::{\n-    global_state::GlobalStateSnapshot, line_index::OffsetEncoding, lsp_ext,\n+    global_state::GlobalStateSnapshot, line_index::PositionEncoding, lsp_ext,\n     to_proto::url_from_abs_path,\n };\n \n@@ -66,17 +66,17 @@ fn location(\n     let uri = url_from_abs_path(&file_name);\n \n     let range = {\n-        let offset_encoding = snap.config.offset_encoding();\n+        let position_encoding = snap.config.position_encoding();\n         lsp_types::Range::new(\n-            position(&offset_encoding, span, span.line_start, span.column_start),\n-            position(&offset_encoding, span, span.line_end, span.column_end),\n+            position(&position_encoding, span, span.line_start, span.column_start),\n+            position(&position_encoding, span, span.line_end, span.column_end),\n         )\n     };\n     lsp_types::Location::new(uri, range)\n }\n \n fn position(\n-    offset_encoding: &OffsetEncoding,\n+    position_encoding: &PositionEncoding,\n     span: &DiagnosticSpan,\n     line_offset: usize,\n     column_offset: usize,\n@@ -93,9 +93,9 @@ fn position(\n             };\n         }\n         let mut char_offset = 0;\n-        let len_func = match offset_encoding {\n-            OffsetEncoding::Utf8 => char::len_utf8,\n-            OffsetEncoding::Utf16 => char::len_utf16,\n+        let len_func = match position_encoding {\n+            PositionEncoding::Utf8 => char::len_utf8,\n+            PositionEncoding::Utf16 => char::len_utf16,\n         };\n         for c in line.text.chars() {\n             char_offset += 1;"}, {"sha": "936957bab4882a41d3cfbdd3b7330c102c7c56e9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -8,7 +8,7 @@ use vfs::AbsPathBuf;\n use crate::{\n     from_json,\n     global_state::GlobalStateSnapshot,\n-    line_index::{LineIndex, OffsetEncoding},\n+    line_index::{LineIndex, PositionEncoding},\n     lsp_ext,\n     lsp_utils::invalid_params_error,\n     Result,\n@@ -25,10 +25,10 @@ pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n \n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> Result<TextSize> {\n     let line_col = match line_index.encoding {\n-        OffsetEncoding::Utf8 => {\n+        PositionEncoding::Utf8 => {\n             LineCol { line: position.line as u32, col: position.character as u32 }\n         }\n-        OffsetEncoding::Utf16 => {\n+        PositionEncoding::Utf16 => {\n             let line_col =\n                 LineColUtf16 { line: position.line as u32, col: position.character as u32 };\n             line_index.index.to_utf8(line_col)"}, {"sha": "74277ff2e576e45e6fa8501cd702b4c7f479061f", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -383,7 +383,7 @@ impl GlobalStateSnapshot {\n     pub(crate) fn file_line_index(&self, file_id: FileId) -> Cancellable<LineIndex> {\n         let endings = self.vfs.read().1[&file_id];\n         let index = self.analysis.file_line_index(file_id)?;\n-        let res = LineIndex { index, endings, encoding: self.config.offset_encoding() };\n+        let res = LineIndex { index, endings, encoding: self.config.position_encoding() };\n         Ok(res)\n     }\n "}, {"sha": "0d424b915703a7db1e56c56dd22bd955e44cdd81", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -7,15 +7,15 @@\n \n use std::sync::Arc;\n \n-pub enum OffsetEncoding {\n+pub enum PositionEncoding {\n     Utf8,\n     Utf16,\n }\n \n pub(crate) struct LineIndex {\n     pub(crate) index: Arc<ide::LineIndex>,\n     pub(crate) endings: LineEndings,\n-    pub(crate) encoding: OffsetEncoding,\n+    pub(crate) encoding: PositionEncoding,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]"}, {"sha": "8cc5648f3ce0cfb3e9f4f6d369b6553cc3c8a24a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -3,6 +3,7 @@\n use std::{collections::HashMap, path::PathBuf};\n \n use lsp_types::request::Request;\n+use lsp_types::PositionEncodingKind;\n use lsp_types::{\n     notification::Notification, CodeActionKind, DocumentOnTypeFormattingParams,\n     PartialResultParams, Position, Range, TextDocumentIdentifier, WorkDoneProgressParams,\n@@ -455,7 +456,15 @@ pub(crate) enum CodeLensResolveData {\n }\n \n pub fn supports_utf8(caps: &lsp_types::ClientCapabilities) -> bool {\n-    caps.offset_encoding.as_deref().unwrap_or_default().iter().any(|it| it == \"utf-8\")\n+    match &caps.general {\n+        Some(general) => general\n+            .position_encodings\n+            .as_deref()\n+            .unwrap_or_default()\n+            .iter()\n+            .any(|it| it == &PositionEncodingKind::UTF8),\n+        _ => false,\n+    }\n }\n \n pub enum MoveItem {}"}, {"sha": "c6a4db9a453ac5069a27b3b2f6472ff21e40e997", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -6,7 +6,7 @@ use lsp_server::Notification;\n use crate::{\n     from_proto,\n     global_state::GlobalState,\n-    line_index::{LineEndings, LineIndex, OffsetEncoding},\n+    line_index::{LineEndings, LineIndex, PositionEncoding},\n     LspError,\n };\n \n@@ -140,7 +140,7 @@ pub(crate) fn apply_document_changes(\n         index: Arc::new(ide::LineIndex::new(old_text)),\n         // We don't care about line endings or offset encoding here.\n         endings: LineEndings::Unix,\n-        encoding: OffsetEncoding::Utf16,\n+        encoding: PositionEncoding::Utf16,\n     };\n \n     // The changes we got must be applied sequentially, but can cross lines so we"}, {"sha": "7d10dc5d15b62d1143e2dd07ad18358d642b71c9", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -607,30 +607,34 @@ impl GlobalState {\n \n     /// Handles a request.\n     fn on_request(&mut self, req: Request) {\n-        if self.shutdown_requested {\n-            self.respond(lsp_server::Response::new_err(\n-                req.id,\n-                lsp_server::ErrorCode::InvalidRequest as i32,\n-                \"Shutdown already requested.\".to_owned(),\n-            ));\n-            return;\n-        }\n+        let mut dispatcher = RequestDispatcher { req: Some(req), global_state: self };\n+        dispatcher.on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {\n+            s.shutdown_requested = true;\n+            Ok(())\n+        });\n+\n+        if let RequestDispatcher { req: Some(req), global_state: this } = &mut dispatcher {\n+            if this.shutdown_requested {\n+                this.respond(lsp_server::Response::new_err(\n+                    req.id.clone(),\n+                    lsp_server::ErrorCode::InvalidRequest as i32,\n+                    \"Shutdown already requested.\".to_owned(),\n+                ));\n+                return;\n+            }\n \n-        // Avoid flashing a bunch of unresolved references during initial load.\n-        if self.workspaces.is_empty() && !self.is_quiescent() {\n-            self.respond(lsp_server::Response::new_err(\n-                req.id,\n-                lsp_server::ErrorCode::ContentModified as i32,\n-                \"waiting for cargo metadata or cargo check\".to_owned(),\n-            ));\n-            return;\n+            // Avoid flashing a bunch of unresolved references during initial load.\n+            if this.workspaces.is_empty() && !this.is_quiescent() {\n+                this.respond(lsp_server::Response::new_err(\n+                    req.id.clone(),\n+                    lsp_server::ErrorCode::ContentModified as i32,\n+                    \"waiting for cargo metadata or cargo check\".to_owned(),\n+                ));\n+                return;\n+            }\n         }\n \n-        RequestDispatcher { req: Some(req), global_state: self }\n-            .on_sync_mut::<lsp_types::request::Shutdown>(|s, ()| {\n-                s.shutdown_requested = true;\n-                Ok(())\n-            })\n+        dispatcher\n             .on_sync_mut::<lsp_ext::ReloadWorkspace>(handlers::handle_workspace_reload)\n             .on_sync_mut::<lsp_ext::MemoryUsage>(handlers::handle_memory_usage)\n             .on_sync_mut::<lsp_ext::ShuffleCrateGraph>(handlers::handle_shuffle_crate_graph)"}, {"sha": "6c84a2069cd5779a439c43e7056f62ea8e8b9fc0", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     cargo_target_spec::CargoTargetSpec,\n     config::{CallInfoConfig, Config},\n     global_state::GlobalStateSnapshot,\n-    line_index::{LineEndings, LineIndex, OffsetEncoding},\n+    line_index::{LineEndings, LineIndex, PositionEncoding},\n     lsp_ext,\n     lsp_utils::invalid_params_error,\n     semantic_tokens, Result,\n@@ -30,8 +30,8 @@ use crate::{\n pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::Position {\n     let line_col = line_index.index.line_col(offset);\n     match line_index.encoding {\n-        OffsetEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n-        OffsetEncoding::Utf16 => {\n+        PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n+        PositionEncoding::Utf16 => {\n             let line_col = line_index.index.to_utf16(line_col);\n             lsp_types::Position::new(line_col.line, line_col.col)\n         }\n@@ -1394,7 +1394,7 @@ fn main() {\n         let line_index = LineIndex {\n             index: Arc::new(ide::LineIndex::new(text)),\n             endings: LineEndings::Unix,\n-            encoding: OffsetEncoding::Utf16,\n+            encoding: PositionEncoding::Utf16,\n         };\n         let converted: Vec<lsp_types::FoldingRange> =\n             folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();"}, {"sha": "5379732ac6c377d3e5fbf23d5c801afd2dd4c960", "filename": "src/tools/rust-analyzer/crates/syntax/rust.ungram", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -51,7 +51,7 @@ TypeArg =\n   Type\n \n AssocTypeArg =\n-  NameRef GenericParamList? (':' TypeBoundList | ('=' Type | ConstArg))\n+  NameRef GenericArgList? (':' TypeBoundList | ('=' Type | ConstArg))\n \n LifetimeArg =\n   Lifetime"}, {"sha": "6cfb98d92fcf289c5a69c4504e69f10e6d31202d", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -120,7 +120,7 @@ pub struct AssocTypeArg {\n impl ast::HasTypeBounds for AssocTypeArg {}\n impl AssocTypeArg {\n     pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }\n-    pub fn generic_param_list(&self) -> Option<GenericParamList> { support::child(&self.syntax) }\n+    pub fn generic_arg_list(&self) -> Option<GenericArgList> { support::child(&self.syntax) }\n     pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n     pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }\n     pub fn const_arg(&self) -> Option<ConstArg> { support::child(&self.syntax) }\n@@ -142,16 +142,6 @@ impl ConstArg {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct GenericParamList {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl GenericParamList {\n-    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n-    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n-    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TypeBoundList {\n     pub(crate) syntax: SyntaxNode,\n@@ -527,6 +517,16 @@ impl Abi {\n     pub fn extern_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![extern]) }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct GenericParamList {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl GenericParamList {\n+    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }\n+    pub fn generic_params(&self) -> AstChildren<GenericParam> { support::children(&self.syntax) }\n+    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct WhereClause {\n     pub(crate) syntax: SyntaxNode,\n@@ -1834,17 +1834,6 @@ impl AstNode for ConstArg {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for GenericParamList {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for TypeBoundList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_BOUND_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2153,6 +2142,17 @@ impl AstNode for Abi {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for GenericParamList {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == GENERIC_PARAM_LIST }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for WhereClause {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_CLAUSE }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -4263,11 +4263,6 @@ impl std::fmt::Display for ConstArg {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for GenericParamList {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for TypeBoundList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4408,6 +4403,11 @@ impl std::fmt::Display for Abi {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for GenericParamList {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for WhereClause {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "e3a4fdfda90c2f5bf76ef521248a73c2a5161325", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -479,7 +479,9 @@ It is not cheap enough to enable in prod, and this is a bug which should be fixe\n ### Configurability\n \n rust-analyzer strives to be as configurable as possible while offering reasonable defaults where no configuration exists yet.\n+The rule of thumb is to enable most features by default unless they are buggy or degrade performance too much.\n There will always be features that some people find more annoying than helpful, so giving the users the ability to tweak or disable these is a big part of offering a good user experience.\n+Enabling them by default is a matter of discoverability, as many users end up don't know about some features even though they are presented in the manual.\n Mind the code--architecture gap: at the moment, we are using fewer feature flags than we really should.\n \n ### Serialization"}, {"sha": "fe316fcae9b8817c51402932947cc26a0308bc92", "filename": "src/tools/rust-analyzer/docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: 7b710095d773b978\n+lsp_ext.rs hash: 62068e53ac202dc8\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:\n@@ -19,12 +19,6 @@ Requests, which are likely to always remain specific to `rust-analyzer` are unde\n \n If you want to be notified about the changes to this document, subscribe to [#4604](https://github.com/rust-lang/rust-analyzer/issues/4604).\n \n-## UTF-8 offsets\n-\n-rust-analyzer supports clangd's extension for opting into UTF-8 as the coordinate space for offsets (by default, LSP uses UTF-16 offsets).\n-\n-https://clangd.llvm.org/extensions.html#utf-8-offsets\n-\n ## Configuration in `initializationOptions`\n \n **Upstream Issue:** https://github.com/microsoft/language-server-protocol/issues/567"}, {"sha": "312087e4cffef9d6c7d5e74a7590a3d2837522a1", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 62, "deletions": 67, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -3,7 +3,7 @@ import * as lc from \"vscode-languageclient\";\n import * as ra from \"./lsp_ext\";\n import * as path from \"path\";\n \n-import { Ctx, Cmd } from \"./ctx\";\n+import { Ctx, Cmd, CtxInit } from \"./ctx\";\n import { applySnippetWorkspaceEdit, applySnippetTextEdits } from \"./snippets\";\n import { spawnSync } from \"child_process\";\n import { RunnableQuickPick, selectRunnable, createTask, createArgs } from \"./run\";\n@@ -16,14 +16,14 @@ import { LINKED_COMMANDS } from \"./client\";\n export * from \"./ast_inspector\";\n export * from \"./run\";\n \n-export function analyzerStatus(ctx: Ctx): Cmd {\n+export function analyzerStatus(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-status://status\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n \n         async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n             if (!vscode.window.activeTextEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const params: ra.AnalyzerStatusParams = {};\n             const doc = ctx.activeRustEditor?.document;\n@@ -52,22 +52,17 @@ export function analyzerStatus(ctx: Ctx): Cmd {\n     };\n }\n \n-export function memoryUsage(ctx: Ctx): Cmd {\n+export function memoryUsage(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-memory://memory\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n \n         provideTextDocumentContent(_uri: vscode.Uri): vscode.ProviderResult<string> {\n             if (!vscode.window.activeTextEditor) return \"\";\n \n-            return ctx\n-                .getClient()\n-                .then((it) => it.sendRequest(ra.memoryUsage))\n-                .then((mem: any) => {\n-                    return (\n-                        \"Per-query memory usage:\\n\" + mem + \"\\n(note: database has been cleared)\"\n-                    );\n-                });\n+            return ctx.client.sendRequest(ra.memoryUsage).then((mem: any) => {\n+                return \"Per-query memory usage:\\n\" + mem + \"\\n(note: database has been cleared)\";\n+            });\n         }\n \n         get onDidChange(): vscode.Event<vscode.Uri> {\n@@ -86,18 +81,18 @@ export function memoryUsage(ctx: Ctx): Cmd {\n     };\n }\n \n-export function shuffleCrateGraph(ctx: Ctx): Cmd {\n+export function shuffleCrateGraph(ctx: CtxInit): Cmd {\n     return async () => {\n-        return ctx.getClient().then((it) => it.sendRequest(ra.shuffleCrateGraph));\n+        return ctx.client.sendRequest(ra.shuffleCrateGraph);\n     };\n }\n \n-export function matchingBrace(ctx: Ctx): Cmd {\n+export function matchingBrace(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const response = await client.sendRequest(ra.matchingBrace, {\n             textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n@@ -114,12 +109,12 @@ export function matchingBrace(ctx: Ctx): Cmd {\n     };\n }\n \n-export function joinLines(ctx: Ctx): Cmd {\n+export function joinLines(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const items: lc.TextEdit[] = await client.sendRequest(ra.joinLines, {\n             ranges: editor.selections.map((it) => client.code2ProtocolConverter.asRange(it)),\n@@ -134,19 +129,19 @@ export function joinLines(ctx: Ctx): Cmd {\n     };\n }\n \n-export function moveItemUp(ctx: Ctx): Cmd {\n+export function moveItemUp(ctx: CtxInit): Cmd {\n     return moveItem(ctx, ra.Direction.Up);\n }\n \n-export function moveItemDown(ctx: Ctx): Cmd {\n+export function moveItemDown(ctx: CtxInit): Cmd {\n     return moveItem(ctx, ra.Direction.Down);\n }\n \n-export function moveItem(ctx: Ctx, direction: ra.Direction): Cmd {\n+export function moveItem(ctx: CtxInit, direction: ra.Direction): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const lcEdits = await client.sendRequest(ra.moveItem, {\n             range: client.code2ProtocolConverter.asRange(editor.selection),\n@@ -161,13 +156,13 @@ export function moveItem(ctx: Ctx, direction: ra.Direction): Cmd {\n     };\n }\n \n-export function onEnter(ctx: Ctx): Cmd {\n+export function onEnter(ctx: CtxInit): Cmd {\n     async function handleKeypress() {\n         const editor = ctx.activeRustEditor;\n \n         if (!editor) return false;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const lcEdits = await client\n             .sendRequest(ra.onEnter, {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n@@ -193,13 +188,13 @@ export function onEnter(ctx: Ctx): Cmd {\n     };\n }\n \n-export function parentModule(ctx: Ctx): Cmd {\n+export function parentModule(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n         if (!editor) return;\n         if (!(isRustDocument(editor.document) || isCargoTomlDocument(editor.document))) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const locations = await client.sendRequest(ra.parentModule, {\n             textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n@@ -230,12 +225,12 @@ export function parentModule(ctx: Ctx): Cmd {\n     };\n }\n \n-export function openCargoToml(ctx: Ctx): Cmd {\n+export function openCargoToml(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const response = await client.sendRequest(ra.openCargoToml, {\n             textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(editor.document),\n         });\n@@ -251,12 +246,12 @@ export function openCargoToml(ctx: Ctx): Cmd {\n     };\n }\n \n-export function ssr(ctx: Ctx): Cmd {\n+export function ssr(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n         if (!editor) return;\n \n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const position = editor.selection.active;\n         const selections = editor.selections;\n@@ -308,7 +303,7 @@ export function ssr(ctx: Ctx): Cmd {\n     };\n }\n \n-export function serverVersion(ctx: Ctx): Cmd {\n+export function serverVersion(ctx: CtxInit): Cmd {\n     return async () => {\n         if (!ctx.serverPath) {\n             void vscode.window.showWarningMessage(`rust-analyzer server is not running`);\n@@ -324,7 +319,7 @@ export function serverVersion(ctx: Ctx): Cmd {\n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n-export function syntaxTree(ctx: Ctx): Cmd {\n+export function syntaxTree(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-syntax-tree://syntaxtree/tree.rast\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -360,7 +355,7 @@ export function syntaxTree(ctx: Ctx): Cmd {\n         ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             // When the range based query is enabled we take the range of the selection\n             const range =\n@@ -407,7 +402,7 @@ export function syntaxTree(ctx: Ctx): Cmd {\n // Opens the virtual file that will show the HIR of the function containing the cursor position\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n-export function viewHir(ctx: Ctx): Cmd {\n+export function viewHir(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-hir://viewHir/hir.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -444,7 +439,7 @@ export function viewHir(ctx: Ctx): Cmd {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n \n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n             const params = {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n                     rustEditor.document\n@@ -473,7 +468,7 @@ export function viewHir(ctx: Ctx): Cmd {\n     };\n }\n \n-export function viewFileText(ctx: Ctx): Cmd {\n+export function viewFileText(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-file-text://viewFileText/file.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -509,7 +504,7 @@ export function viewFileText(ctx: Ctx): Cmd {\n         ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const params = client.code2ProtocolConverter.asTextDocumentIdentifier(\n                 rustEditor.document\n@@ -536,7 +531,7 @@ export function viewFileText(ctx: Ctx): Cmd {\n     };\n }\n \n-export function viewItemTree(ctx: Ctx): Cmd {\n+export function viewItemTree(ctx: CtxInit): Cmd {\n     const tdcp = new (class implements vscode.TextDocumentContentProvider {\n         readonly uri = vscode.Uri.parse(\"rust-analyzer-item-tree://viewItemTree/itemtree.rs\");\n         readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n@@ -572,7 +567,7 @@ export function viewItemTree(ctx: Ctx): Cmd {\n         ): Promise<string> {\n             const rustEditor = ctx.activeRustEditor;\n             if (!rustEditor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const params = {\n                 textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(\n@@ -601,7 +596,7 @@ export function viewItemTree(ctx: Ctx): Cmd {\n     };\n }\n \n-function crateGraph(ctx: Ctx, full: boolean): Cmd {\n+function crateGraph(ctx: CtxInit, full: boolean): Cmd {\n     return async () => {\n         const nodeModulesPath = vscode.Uri.file(path.join(ctx.extensionPath, \"node_modules\"));\n \n@@ -618,7 +613,7 @@ function crateGraph(ctx: Ctx, full: boolean): Cmd {\n         const params = {\n             full: full,\n         };\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const dot = await client.sendRequest(ra.viewCrateGraph, params);\n         const uri = panel.webview.asWebviewUri(nodeModulesPath);\n \n@@ -664,18 +659,18 @@ function crateGraph(ctx: Ctx, full: boolean): Cmd {\n     };\n }\n \n-export function viewCrateGraph(ctx: Ctx): Cmd {\n+export function viewCrateGraph(ctx: CtxInit): Cmd {\n     return crateGraph(ctx, false);\n }\n \n-export function viewFullCrateGraph(ctx: Ctx): Cmd {\n+export function viewFullCrateGraph(ctx: CtxInit): Cmd {\n     return crateGraph(ctx, true);\n }\n \n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n-export function expandMacro(ctx: Ctx): Cmd {\n+export function expandMacro(ctx: CtxInit): Cmd {\n     function codeFormat(expanded: ra.ExpandedMacro): string {\n         let result = `// Recursive expansion of ${expanded.name}! macro\\n`;\n         result += \"// \" + \"=\".repeat(result.length - 3);\n@@ -691,7 +686,7 @@ export function expandMacro(ctx: Ctx): Cmd {\n         async provideTextDocumentContent(_uri: vscode.Uri): Promise<string> {\n             const editor = vscode.window.activeTextEditor;\n             if (!editor) return \"\";\n-            const client = await ctx.getClient();\n+            const client = ctx.client;\n \n             const position = editor.selection.active;\n \n@@ -723,8 +718,8 @@ export function expandMacro(ctx: Ctx): Cmd {\n     };\n }\n \n-export function reloadWorkspace(ctx: Ctx): Cmd {\n-    return async () => (await ctx.getClient()).sendRequest(ra.reloadWorkspace);\n+export function reloadWorkspace(ctx: CtxInit): Cmd {\n+    return async () => ctx.client.sendRequest(ra.reloadWorkspace);\n }\n \n async function showReferencesImpl(\n@@ -743,13 +738,13 @@ async function showReferencesImpl(\n     }\n }\n \n-export function showReferences(ctx: Ctx): Cmd {\n+export function showReferences(ctx: CtxInit): Cmd {\n     return async (uri: string, position: lc.Position, locations: lc.Location[]) => {\n-        await showReferencesImpl(await ctx.getClient(), uri, position, locations);\n+        await showReferencesImpl(ctx.client, uri, position, locations);\n     };\n }\n \n-export function applyActionGroup(_ctx: Ctx): Cmd {\n+export function applyActionGroup(_ctx: CtxInit): Cmd {\n     return async (actions: { label: string; arguments: lc.CodeAction }[]) => {\n         const selectedAction = await vscode.window.showQuickPick(actions);\n         if (!selectedAction) return;\n@@ -760,9 +755,9 @@ export function applyActionGroup(_ctx: Ctx): Cmd {\n     };\n }\n \n-export function gotoLocation(ctx: Ctx): Cmd {\n+export function gotoLocation(ctx: CtxInit): Cmd {\n     return async (locationLink: lc.LocationLink) => {\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         const uri = client.protocol2CodeConverter.asUri(locationLink.targetUri);\n         let range = client.protocol2CodeConverter.asRange(locationLink.targetSelectionRange);\n         // collapse the range to a cursor position\n@@ -772,13 +767,13 @@ export function gotoLocation(ctx: Ctx): Cmd {\n     };\n }\n \n-export function openDocs(ctx: Ctx): Cmd {\n+export function openDocs(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n         if (!editor) {\n             return;\n         }\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         const position = editor.selection.active;\n         const textDocument = { uri: editor.document.uri.toString() };\n@@ -791,16 +786,16 @@ export function openDocs(ctx: Ctx): Cmd {\n     };\n }\n \n-export function cancelFlycheck(ctx: Ctx): Cmd {\n+export function cancelFlycheck(ctx: CtxInit): Cmd {\n     return async () => {\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         await client.sendRequest(ra.cancelFlycheck);\n     };\n }\n \n-export function resolveCodeAction(ctx: Ctx): Cmd {\n+export function resolveCodeAction(ctx: CtxInit): Cmd {\n     return async (params: lc.CodeAction) => {\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n         params.command = undefined;\n         const item = await client?.sendRequest(lc.CodeActionResolveRequest.type, params);\n         if (!item?.edit) {\n@@ -825,13 +820,13 @@ export function resolveCodeAction(ctx: Ctx): Cmd {\n     };\n }\n \n-export function applySnippetWorkspaceEditCommand(_ctx: Ctx): Cmd {\n+export function applySnippetWorkspaceEditCommand(_ctx: CtxInit): Cmd {\n     return async (edit: vscode.WorkspaceEdit) => {\n         await applySnippetWorkspaceEdit(edit);\n     };\n }\n \n-export function run(ctx: Ctx): Cmd {\n+export function run(ctx: CtxInit): Cmd {\n     let prevRunnable: RunnableQuickPick | undefined;\n \n     return async () => {\n@@ -845,11 +840,11 @@ export function run(ctx: Ctx): Cmd {\n     };\n }\n \n-export function peekTests(ctx: Ctx): Cmd {\n+export function peekTests(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n-        const client = await ctx.getClient();\n+        const client = ctx.client;\n \n         await vscode.window.withProgress(\n             {\n@@ -878,7 +873,7 @@ export function peekTests(ctx: Ctx): Cmd {\n     };\n }\n \n-export function runSingle(ctx: Ctx): Cmd {\n+export function runSingle(ctx: CtxInit): Cmd {\n     return async (runnable: ra.Runnable) => {\n         const editor = ctx.activeRustEditor;\n         if (!editor) return;\n@@ -895,7 +890,7 @@ export function runSingle(ctx: Ctx): Cmd {\n     };\n }\n \n-export function copyRunCommandLine(ctx: Ctx) {\n+export function copyRunCommandLine(ctx: CtxInit) {\n     let prevRunnable: RunnableQuickPick | undefined;\n     return async () => {\n         const item = await selectRunnable(ctx, prevRunnable);\n@@ -907,7 +902,7 @@ export function copyRunCommandLine(ctx: Ctx) {\n     };\n }\n \n-export function debug(ctx: Ctx): Cmd {\n+export function debug(ctx: CtxInit): Cmd {\n     let prevDebuggee: RunnableQuickPick | undefined;\n \n     return async () => {\n@@ -920,13 +915,13 @@ export function debug(ctx: Ctx): Cmd {\n     };\n }\n \n-export function debugSingle(ctx: Ctx): Cmd {\n+export function debugSingle(ctx: CtxInit): Cmd {\n     return async (config: ra.Runnable) => {\n         await startDebugSession(ctx, config);\n     };\n }\n \n-export function newDebugConfig(ctx: Ctx): Cmd {\n+export function newDebugConfig(ctx: CtxInit): Cmd {\n     return async () => {\n         const item = await selectRunnable(ctx, undefined, true, false);\n         if (!item) return;"}, {"sha": "3e366525ee295392fcdef55b019aa6d511ba5bea", "filename": "src/tools/rust-analyzer/editors/code/src/ctx.ts", "status": "modified", "additions": 126, "deletions": 46, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fctx.ts?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -4,12 +4,17 @@ import * as ra from \"./lsp_ext\";\n \n import { Config, substituteVariablesInEnv, substituteVSCodeVariables } from \"./config\";\n import { createClient } from \"./client\";\n-import { isRustEditor, log, RustEditor } from \"./util\";\n+import { isRustDocument, isRustEditor, log, RustEditor } from \"./util\";\n import { ServerStatusParams } from \"./lsp_ext\";\n import { PersistentState } from \"./persistent_state\";\n import { bootstrap } from \"./bootstrap\";\n \n+// We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n+// only those are in use. We use \"Empty\" to represent these scenarios\n+// (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n+\n export type Workspace =\n+    | { kind: \"Empty\" }\n     | {\n           kind: \"Workspace Folder\";\n       }\n@@ -18,16 +23,39 @@ export type Workspace =\n           files: vscode.TextDocument[];\n       };\n \n+export function fetchWorkspace(): Workspace {\n+    const folders = (vscode.workspace.workspaceFolders || []).filter(\n+        (folder) => folder.uri.scheme === \"file\"\n+    );\n+    const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n+        isRustDocument(document)\n+    );\n+\n+    return folders.length === 0\n+        ? rustDocuments.length === 0\n+            ? { kind: \"Empty\" }\n+            : {\n+                  kind: \"Detached Files\",\n+                  files: rustDocuments,\n+              }\n+        : { kind: \"Workspace Folder\" };\n+}\n+\n export type CommandFactory = {\n-    enabled: (ctx: Ctx) => Cmd;\n+    enabled: (ctx: CtxInit) => Cmd;\n     disabled?: (ctx: Ctx) => Cmd;\n };\n \n+export type CtxInit = Ctx & {\n+    readonly client: lc.LanguageClient;\n+};\n+\n export class Ctx {\n     readonly statusBar: vscode.StatusBarItem;\n     readonly config: Config;\n+    readonly workspace: Workspace;\n \n-    private client: lc.LanguageClient | undefined;\n+    private _client: lc.LanguageClient | undefined;\n     private _serverPath: string | undefined;\n     private traceOutputChannel: vscode.OutputChannel | undefined;\n     private outputChannel: vscode.OutputChannel | undefined;\n@@ -36,18 +64,17 @@ export class Ctx {\n     private commandFactories: Record<string, CommandFactory>;\n     private commandDisposables: Disposable[];\n \n-    workspace: Workspace;\n+    get client() {\n+        return this._client;\n+    }\n \n     constructor(\n         readonly extCtx: vscode.ExtensionContext,\n-        workspace: Workspace,\n-        commandFactories: Record<string, CommandFactory>\n+        commandFactories: Record<string, CommandFactory>,\n+        workspace: Workspace\n     ) {\n         extCtx.subscriptions.push(this);\n         this.statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);\n-        this.statusBar.text = \"rust-analyzer\";\n-        this.statusBar.tooltip = \"ready\";\n-        this.statusBar.command = \"rust-analyzer.analyzerStatus\";\n         this.statusBar.show();\n         this.workspace = workspace;\n         this.clientSubscriptions = [];\n@@ -57,7 +84,10 @@ export class Ctx {\n         this.state = new PersistentState(extCtx.globalState);\n         this.config = new Config(extCtx);\n \n-        this.updateCommands();\n+        this.updateCommands(\"disable\");\n+        this.setServerStatus({\n+            health: \"stopped\",\n+        });\n     }\n \n     dispose() {\n@@ -67,16 +97,36 @@ export class Ctx {\n         this.commandDisposables.forEach((disposable) => disposable.dispose());\n     }\n \n-    clientFetcher() {\n-        const self = this;\n-        return {\n-            get client(): lc.LanguageClient | undefined {\n-                return self.client;\n-            },\n-        };\n+    async onWorkspaceFolderChanges() {\n+        const workspace = fetchWorkspace();\n+        if (workspace.kind === \"Detached Files\" && this.workspace.kind === \"Detached Files\") {\n+            if (workspace.files !== this.workspace.files) {\n+                if (this.client?.isRunning()) {\n+                    // Ideally we wouldn't need to tear down the server here, but currently detached files\n+                    // are only specified at server start\n+                    await this.stopAndDispose();\n+                    await this.start();\n+                }\n+                return;\n+            }\n+        }\n+        if (workspace.kind === \"Workspace Folder\" && this.workspace.kind === \"Workspace Folder\") {\n+            return;\n+        }\n+        if (workspace.kind === \"Empty\") {\n+            await this.stopAndDispose();\n+            return;\n+        }\n+        if (this.client?.isRunning()) {\n+            await this.restart();\n+        }\n     }\n \n-    async getClient() {\n+    private async getOrCreateClient() {\n+        if (this.workspace.kind === \"Empty\") {\n+            return;\n+        }\n+\n         if (!this.traceOutputChannel) {\n             this.traceOutputChannel = vscode.window.createOutputChannel(\n                 \"Rust Analyzer Language Server Trace\"\n@@ -88,7 +138,7 @@ export class Ctx {\n             this.pushExtCleanup(this.outputChannel);\n         }\n \n-        if (!this.client) {\n+        if (!this._client) {\n             this._serverPath = await bootstrap(this.extCtx, this.config, this.state).catch(\n                 (err) => {\n                     let message = \"bootstrap error. \";\n@@ -125,47 +175,61 @@ export class Ctx {\n \n             const initializationOptions = substituteVSCodeVariables(rawInitializationOptions);\n \n-            this.client = await createClient(\n+            this._client = await createClient(\n                 this.traceOutputChannel,\n                 this.outputChannel,\n                 initializationOptions,\n                 serverOptions\n             );\n             this.pushClientCleanup(\n-                this.client.onNotification(ra.serverStatus, (params) =>\n+                this._client.onNotification(ra.serverStatus, (params) =>\n                     this.setServerStatus(params)\n                 )\n             );\n         }\n-        return this.client;\n+        return this._client;\n     }\n \n-    async activate() {\n-        log.info(\"Activating language client\");\n-        const client = await this.getClient();\n+    async start() {\n+        log.info(\"Starting language client\");\n+        const client = await this.getOrCreateClient();\n+        if (!client) {\n+            return;\n+        }\n         await client.start();\n         this.updateCommands();\n-        return client;\n     }\n \n-    async deactivate() {\n-        log.info(\"Deactivating language client\");\n-        await this.client?.stop();\n-        this.updateCommands();\n+    async restart() {\n+        // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n+        await this.stopAndDispose();\n+        await this.start();\n     }\n \n     async stop() {\n+        if (!this._client) {\n+            return;\n+        }\n         log.info(\"Stopping language client\");\n+        this.updateCommands(\"disable\");\n+        await this._client.stop();\n+    }\n+\n+    async stopAndDispose() {\n+        if (!this._client) {\n+            return;\n+        }\n+        log.info(\"Disposing language client\");\n+        this.updateCommands(\"disable\");\n         await this.disposeClient();\n-        this.updateCommands();\n     }\n \n     private async disposeClient() {\n         this.clientSubscriptions?.forEach((disposable) => disposable.dispose());\n         this.clientSubscriptions = [];\n-        await this.client?.dispose();\n+        await this._client?.dispose();\n         this._serverPath = undefined;\n-        this.client = undefined;\n+        this._client = undefined;\n     }\n \n     get activeRustEditor(): RustEditor | undefined {\n@@ -185,32 +249,41 @@ export class Ctx {\n         return this._serverPath;\n     }\n \n-    private updateCommands() {\n+    private updateCommands(forceDisable?: \"disable\") {\n         this.commandDisposables.forEach((disposable) => disposable.dispose());\n         this.commandDisposables = [];\n-        const fetchFactory = (factory: CommandFactory, fullName: string) => {\n-            return this.client && this.client.isRunning()\n-                ? factory.enabled\n-                : factory.disabled ||\n-                      ((_) => () =>\n-                          vscode.window.showErrorMessage(\n-                              `command ${fullName} failed: rust-analyzer server is not running`\n-                          ));\n+\n+        const clientRunning = (!forceDisable && this._client?.isRunning()) ?? false;\n+        const isClientRunning = function (_ctx: Ctx): _ctx is CtxInit {\n+            return clientRunning;\n         };\n+\n         for (const [name, factory] of Object.entries(this.commandFactories)) {\n             const fullName = `rust-analyzer.${name}`;\n-            const callback = fetchFactory(factory, fullName)(this);\n+            let callback;\n+            if (isClientRunning(this)) {\n+                // we asserted that `client` is defined\n+                callback = factory.enabled(this);\n+            } else if (factory.disabled) {\n+                callback = factory.disabled(this);\n+            } else {\n+                callback = () =>\n+                    vscode.window.showErrorMessage(\n+                        `command ${fullName} failed: rust-analyzer server is not running`\n+                    );\n+            }\n+\n             this.commandDisposables.push(vscode.commands.registerCommand(fullName, callback));\n         }\n     }\n \n-    setServerStatus(status: ServerStatusParams) {\n+    setServerStatus(status: ServerStatusParams | { health: \"stopped\" }) {\n         let icon = \"\";\n         const statusBar = this.statusBar;\n         switch (status.health) {\n             case \"ok\":\n-                statusBar.tooltip = status.message ?? \"Ready\";\n-                statusBar.command = undefined;\n+                statusBar.tooltip = (status.message ?? \"Ready\") + \"\\nClick to stop server.\";\n+                statusBar.command = \"rust-analyzer.stopServer\";\n                 statusBar.color = undefined;\n                 statusBar.backgroundColor = undefined;\n                 break;\n@@ -234,6 +307,13 @@ export class Ctx {\n                 statusBar.backgroundColor = new vscode.ThemeColor(\"statusBarItem.errorBackground\");\n                 icon = \"$(error) \";\n                 break;\n+            case \"stopped\":\n+                statusBar.tooltip = \"Server is stopped.\\nClick to start.\";\n+                statusBar.command = \"rust-analyzer.startServer\";\n+                statusBar.color = undefined;\n+                statusBar.backgroundColor = undefined;\n+                statusBar.text = `$(stop-circle) rust-analyzer`;\n+                return;\n         }\n         if (!status.quiescent) icon = \"$(sync~spin) \";\n         statusBar.text = `${icon}rust-analyzer`;"}, {"sha": "e76b657c1bfb50605b1e77f85c329bc08ce06090", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -2,15 +2,13 @@ import * as vscode from \"vscode\";\n import * as lc from \"vscode-languageclient/node\";\n \n import * as commands from \"./commands\";\n-import { CommandFactory, Ctx, Workspace } from \"./ctx\";\n-import { isRustDocument } from \"./util\";\n+import { CommandFactory, Ctx, fetchWorkspace } from \"./ctx\";\n import { activateTaskProvider } from \"./tasks\";\n import { setContextValue } from \"./util\";\n \n const RUST_PROJECT_CONTEXT_NAME = \"inRustProject\";\n \n export interface RustAnalyzerExtensionApi {\n-    // FIXME: this should be non-optional\n     readonly client?: lc.LanguageClient;\n }\n \n@@ -32,32 +30,7 @@ export async function activate(\n             .then(() => {}, console.error);\n     }\n \n-    // We only support local folders, not eg. Live Share (`vlsl:` scheme), so don't activate if\n-    // only those are in use.\n-    // (r-a still somewhat works with Live Share, because commands are tunneled to the host)\n-    const folders = (vscode.workspace.workspaceFolders || []).filter(\n-        (folder) => folder.uri.scheme === \"file\"\n-    );\n-    const rustDocuments = vscode.workspace.textDocuments.filter((document) =>\n-        isRustDocument(document)\n-    );\n-\n-    if (folders.length === 0 && rustDocuments.length === 0) {\n-        // FIXME: Ideally we would choose not to activate at all (and avoid registering\n-        // non-functional editor commands), but VS Code doesn't seem to have a good way of doing\n-        // that\n-        return {};\n-    }\n-\n-    const workspace: Workspace =\n-        folders.length === 0\n-            ? {\n-                  kind: \"Detached Files\",\n-                  files: rustDocuments,\n-              }\n-            : { kind: \"Workspace Folder\" };\n-\n-    const ctx = new Ctx(context, workspace, createCommands());\n+    const ctx = new Ctx(context, createCommands(), fetchWorkspace());\n     // VS Code doesn't show a notification when an extension fails to activate\n     // so we do it ourselves.\n     const api = await activateServer(ctx).catch((err) => {\n@@ -75,18 +48,23 @@ async function activateServer(ctx: Ctx): Promise<RustAnalyzerExtensionApi> {\n         ctx.pushExtCleanup(activateTaskProvider(ctx.config));\n     }\n \n+    vscode.workspace.onDidChangeWorkspaceFolders(\n+        async (_) => ctx.onWorkspaceFolderChanges(),\n+        null,\n+        ctx.subscriptions\n+    );\n     vscode.workspace.onDidChangeConfiguration(\n         async (_) => {\n-            await ctx\n-                .clientFetcher()\n-                .client?.sendNotification(\"workspace/didChangeConfiguration\", { settings: \"\" });\n+            await ctx.client?.sendNotification(\"workspace/didChangeConfiguration\", {\n+                settings: \"\",\n+            });\n         },\n         null,\n         ctx.subscriptions\n     );\n \n-    await ctx.activate();\n-    return ctx.clientFetcher();\n+    await ctx.start();\n+    return ctx;\n }\n \n function createCommands(): Record<string, CommandFactory> {\n@@ -98,33 +76,30 @@ function createCommands(): Record<string, CommandFactory> {\n         reload: {\n             enabled: (ctx) => async () => {\n                 void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n-                // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n-                await ctx.stop();\n-                await ctx.activate();\n+                await ctx.restart();\n             },\n             disabled: (ctx) => async () => {\n                 void vscode.window.showInformationMessage(\"Reloading rust-analyzer...\");\n-                await ctx.activate();\n+                await ctx.start();\n             },\n         },\n         startServer: {\n             enabled: (ctx) => async () => {\n-                await ctx.activate();\n+                await ctx.start();\n             },\n             disabled: (ctx) => async () => {\n-                await ctx.activate();\n+                await ctx.start();\n             },\n         },\n         stopServer: {\n             enabled: (ctx) => async () => {\n                 // FIXME: We should re-use the client, that is ctx.deactivate() if none of the configs have changed\n-                await ctx.stop();\n+                await ctx.stopAndDispose();\n                 ctx.setServerStatus({\n-                    health: \"ok\",\n-                    quiescent: true,\n-                    message: \"server is not running\",\n+                    health: \"stopped\",\n                 });\n             },\n+            disabled: (_) => async () => {},\n         },\n \n         analyzerStatus: { enabled: commands.analyzerStatus },"}, {"sha": "35627e2fc6beb1b60a1d58ab4712877dc23a6678", "filename": "src/tools/rust-analyzer/editors/code/src/run.ts", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Frun.ts?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -3,7 +3,7 @@ import * as lc from \"vscode-languageclient\";\n import * as ra from \"./lsp_ext\";\n import * as tasks from \"./tasks\";\n \n-import { Ctx } from \"./ctx\";\n+import { CtxInit } from \"./ctx\";\n import { makeDebugConfig } from \"./debug\";\n import { Config, RunnableEnvCfg } from \"./config\";\n \n@@ -12,15 +12,15 @@ const quickPickButtons = [\n ];\n \n export async function selectRunnable(\n-    ctx: Ctx,\n+    ctx: CtxInit,\n     prevRunnable?: RunnableQuickPick,\n     debuggeeOnly = false,\n     showButtons: boolean = true\n ): Promise<RunnableQuickPick | undefined> {\n     const editor = ctx.activeRustEditor;\n     if (!editor) return;\n \n-    const client = await ctx.getClient();\n+    const client = ctx.client;\n     const textDocument: lc.TextDocumentIdentifier = {\n         uri: editor.document.uri.toString(),\n     };"}, {"sha": "9bba9e87ecb554f34d8b9b3a0ef6dd0314728531", "filename": "src/tools/rust-analyzer/lib/lsp-server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0b3e75e1cdc8d56fc5540e17450d96228b26e268/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml?ref=0b3e75e1cdc8d56fc5540e17450d96228b26e268", "patch": "@@ -13,4 +13,4 @@ serde = { version = \"1.0.144\", features = [\"derive\"] }\n crossbeam-channel = \"0.5.6\"\n \n [dev-dependencies]\n-lsp-types = \"0.93.1\"\n+lsp-types = \"=0.93.2\""}]}