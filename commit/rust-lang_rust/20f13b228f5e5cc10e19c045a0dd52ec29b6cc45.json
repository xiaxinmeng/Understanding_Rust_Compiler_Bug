{"sha": "20f13b228f5e5cc10e19c045a0dd52ec29b6cc45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZjEzYjIyOGY1ZTVjYzEwZTE5YzA0NWEwZGQ1MmVjMjliNmNjNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-21T04:01:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-21T04:01:41Z"}, "message": "auto merge of #10930 : DaGenix/rust/remove-unnecessary-fields, r=alexcrichton\n\n3 minor clean-ups now that #9629 is fixed:\r\n\r\n* Update MutChunkIter to remove the ```remainder``` that existed just to allow the size_hint() method to be implemented. This is no longer necessary since we can just access the length of the slice directly.\r\n* Update MutSplitIterator to address the FIXME in its size_hint() method. This method was only partially implemented due to the issue. Also, implement a minor optimization in the case that its the last iteration.\r\n* Update ByRef iterator to implement the size_hint() method.\r\n\r\nI noticed that MutSplitIterator returns an empty slice if called on an empty slice. I don't know if this is intended or not, but I left the ```finished``` field in-place to preserve this behavior.\r\n\r\n@TeXitoi @blake2-ppc", "tree": {"sha": "f387a8adc8ef497cc0f5792e3839b7fb541ae5fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f387a8adc8ef497cc0f5792e3839b7fb541ae5fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45", "html_url": "https://github.com/rust-lang/rust/commit/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35fc0c8fe4210517508d624695e81c47bda00602", "url": "https://api.github.com/repos/rust-lang/rust/commits/35fc0c8fe4210517508d624695e81c47bda00602", "html_url": "https://github.com/rust-lang/rust/commit/35fc0c8fe4210517508d624695e81c47bda00602"}, {"sha": "765bc9064f9b38ae227a2c61a8ed34f67f0afd0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/765bc9064f9b38ae227a2c61a8ed34f67f0afd0f", "html_url": "https://github.com/rust-lang/rust/commit/765bc9064f9b38ae227a2c61a8ed34f67f0afd0f"}], "stats": {"total": 45, "additions": 20, "deletions": 25}, "files": [{"sha": "f16e9b5392977ded3d473e5ceb7f5a8d8c48cd5e", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=20f13b228f5e5cc10e19c045a0dd52ec29b6cc45", "patch": "@@ -795,7 +795,8 @@ pub struct ByRef<'a, T> {\n impl<'a, A, T: Iterator<A>> Iterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next() }\n-    // FIXME: #9629 we cannot implement &self methods like size_hint on ByRef\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for ByRef<'a, T> {"}, {"sha": "b03cef093504398e14f247b6ffee43da112d2efc", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20f13b228f5e5cc10e19c045a0dd52ec29b6cc45/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=20f13b228f5e5cc10e19c045a0dd52ec29b6cc45", "patch": "@@ -2127,8 +2127,7 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n     fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'a, T> {\n         assert!(chunk_size > 0);\n-        let len = self.len();\n-        MutChunkIter { v: self, chunk_size: chunk_size, remaining: len }\n+        MutChunkIter { v: self, chunk_size: chunk_size }\n     }\n \n     fn mut_shift_ref(&mut self) -> &'a mut T {\n@@ -2529,13 +2528,13 @@ impl<'a, T> Iterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished { return (0, Some(0)) }\n-\n-        // if the predicate doesn't match anything, we yield one slice\n-        // if it matches every element, we yield len+1 empty slices.\n-        // FIXME #9629\n-        //(1, Some(self.v.len() + 1))\n-        (1, None)\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n     }\n }\n \n@@ -2548,10 +2547,7 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n             None => {\n                 self.finished = true;\n                 let tmp = util::replace(&mut self.v, &mut []);\n-                let len = tmp.len();\n-                let (head, tail) = tmp.mut_split_at(len);\n-                self.v = tail;\n-                Some(head)\n+                Some(tmp)\n             }\n             Some(idx) => {\n                 let tmp = util::replace(&mut self.v, &mut []);\n@@ -2568,31 +2564,29 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n /// the remainder.\n pub struct MutChunkIter<'a, T> {\n     priv v: &'a mut [T],\n-    priv chunk_size: uint,\n-    priv remaining: uint\n+    priv chunk_size: uint\n }\n \n impl<'a, T> Iterator<&'a mut [T]> for MutChunkIter<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.remaining == 0 {\n+        if self.v.len() == 0 {\n             None\n         } else {\n-            let sz = cmp::min(self.remaining, self.chunk_size);\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n             let tmp = util::replace(&mut self.v, &mut []);\n             let (head, tail) = tmp.mut_split_at(sz);\n             self.v = tail;\n-            self.remaining -= sz;\n             Some(head)\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.remaining == 0 {\n+        if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n-            let (n, rem) = self.remaining.div_rem(&self.chunk_size);\n+            let (n, rem) = self.v.len().div_rem(&self.chunk_size);\n             let n = if rem > 0 { n + 1 } else { n };\n             (n, Some(n))\n         }\n@@ -2602,15 +2596,15 @@ impl<'a, T> Iterator<&'a mut [T]> for MutChunkIter<'a, T> {\n impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunkIter<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.remaining == 0 {\n+        if self.v.len() == 0 {\n             None\n         } else {\n-            let remainder = self.remaining % self.chunk_size;\n+            let remainder = self.v.len() % self.chunk_size;\n             let sz = if remainder != 0 { remainder } else { self.chunk_size };\n             let tmp = util::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.mut_split_at(self.remaining - sz);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n             self.v = head;\n-            self.remaining -= sz;\n             Some(tail)\n         }\n     }"}]}