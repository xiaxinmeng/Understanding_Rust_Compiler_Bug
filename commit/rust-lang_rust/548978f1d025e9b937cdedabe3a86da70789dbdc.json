{"sha": "548978f1d025e9b937cdedabe3a86da70789dbdc", "node_id": "C_kwDOAAsO6NoAKDU0ODk3OGYxZDAyNWU5YjkzN2NkZWRhYmUzYTg2ZGE3MDc4OWRiZGM", "commit": {"author": {"name": "ozkanonur", "email": "work@onurozkan.dev", "date": "2023-05-09T18:11:13Z"}, "committer": {"name": "ozkanonur", "email": "work@onurozkan.dev", "date": "2023-05-16T08:16:20Z"}, "message": "add lib module to `src/tool/compiletest`\n\nSigned-off-by: ozkanonur <work@onurozkan.dev>", "tree": {"sha": "b7b86be7dfc7e87eaa6a6f79b68dd1488c309c3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7b86be7dfc7e87eaa6a6f79b68dd1488c309c3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/548978f1d025e9b937cdedabe3a86da70789dbdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/548978f1d025e9b937cdedabe3a86da70789dbdc", "html_url": "https://github.com/rust-lang/rust/commit/548978f1d025e9b937cdedabe3a86da70789dbdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/548978f1d025e9b937cdedabe3a86da70789dbdc/comments", "author": {"login": "ozkanonur", "id": 39852038, "node_id": "MDQ6VXNlcjM5ODUyMDM4", "avatar_url": "https://avatars.githubusercontent.com/u/39852038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ozkanonur", "html_url": "https://github.com/ozkanonur", "followers_url": "https://api.github.com/users/ozkanonur/followers", "following_url": "https://api.github.com/users/ozkanonur/following{/other_user}", "gists_url": "https://api.github.com/users/ozkanonur/gists{/gist_id}", "starred_url": "https://api.github.com/users/ozkanonur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ozkanonur/subscriptions", "organizations_url": "https://api.github.com/users/ozkanonur/orgs", "repos_url": "https://api.github.com/users/ozkanonur/repos", "events_url": "https://api.github.com/users/ozkanonur/events{/privacy}", "received_events_url": "https://api.github.com/users/ozkanonur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ozkanonur", "id": 39852038, "node_id": "MDQ6VXNlcjM5ODUyMDM4", "avatar_url": "https://avatars.githubusercontent.com/u/39852038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ozkanonur", "html_url": "https://github.com/ozkanonur", "followers_url": "https://api.github.com/users/ozkanonur/followers", "following_url": "https://api.github.com/users/ozkanonur/following{/other_user}", "gists_url": "https://api.github.com/users/ozkanonur/gists{/gist_id}", "starred_url": "https://api.github.com/users/ozkanonur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ozkanonur/subscriptions", "organizations_url": "https://api.github.com/users/ozkanonur/orgs", "repos_url": "https://api.github.com/users/ozkanonur/repos", "events_url": "https://api.github.com/users/ozkanonur/events{/privacy}", "received_events_url": "https://api.github.com/users/ozkanonur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea9ad532474343426e564b997891e459cda89a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea9ad532474343426e564b997891e459cda89a6", "html_url": "https://github.com/rust-lang/rust/commit/3ea9ad532474343426e564b997891e459cda89a6"}], "stats": {"total": 2276, "additions": 1141, "deletions": 1135}, "files": [{"sha": "ae43d470ab3e8e8412f694ebb5addcb0abd1688e", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/548978f1d025e9b937cdedabe3a86da70789dbdc/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/548978f1d025e9b937cdedabe3a86da70789dbdc/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=548978f1d025e9b937cdedabe3a86da70789dbdc", "patch": "@@ -3,6 +3,9 @@ name = \"compiletest\"\n version = \"0.0.0\"\n edition = \"2021\"\n \n+[lib]\n+doctest = false\n+\n [dependencies]\n colored = \"2\"\n diff = \"0.1.10\""}, {"sha": "fc48d0159905b1ffc3dd60a8cb9d57586d8bce7f", "filename": "src/tools/compiletest/src/lib.rs", "status": "added", "additions": 1136, "deletions": 0, "changes": 1136, "blob_url": "https://github.com/rust-lang/rust/blob/548978f1d025e9b937cdedabe3a86da70789dbdc/src%2Ftools%2Fcompiletest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548978f1d025e9b937cdedabe3a86da70789dbdc/src%2Ftools%2Fcompiletest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Flib.rs?ref=548978f1d025e9b937cdedabe3a86da70789dbdc", "patch": "@@ -0,0 +1,1136 @@\n+#![crate_name = \"compiletest\"]\n+// The `test` crate is the only unstable feature\n+// allowed here, just to share similar code.\n+#![feature(test)]\n+\n+extern crate test;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+pub mod common;\n+pub mod compute_diff;\n+pub mod errors;\n+pub mod header;\n+mod json;\n+mod raise_fd_limit;\n+mod read2;\n+pub mod runtest;\n+pub mod util;\n+\n+use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n+use crate::common::{Config, Debugger, Mode, PassMode, TestPaths};\n+use crate::util::logv;\n+use build_helper::git::{get_git_modified_files, get_git_untracked_files};\n+use core::panic;\n+use getopts::Options;\n+use lazycell::AtomicLazyCell;\n+use std::collections::BTreeSet;\n+use std::ffi::OsString;\n+use std::fs;\n+use std::io::{self, ErrorKind};\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n+use std::time::SystemTime;\n+use std::{env, vec};\n+use test::ColorConfig;\n+use tracing::*;\n+use walkdir::WalkDir;\n+\n+use self::header::{make_test_description, EarlyProps};\n+use crate::header::HeadersCache;\n+use std::sync::Arc;\n+\n+pub fn parse_config(args: Vec<String>) -> Config {\n+    let mut opts = Options::new();\n+    opts.reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\")\n+        .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n+        .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n+        .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n+        .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n+        .reqopt(\"\", \"python\", \"path to python to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"jsondoclint-path\", \"path to jsondoclint to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n+        .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n+        .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n+        .optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\")\n+        .reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\")\n+        .reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\")\n+        .reqopt(\"\", \"sysroot-base\", \"directory containing the compiler sysroot\", \"PATH\")\n+        .reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\")\n+        .reqopt(\n+            \"\",\n+            \"mode\",\n+            \"which sort of compile tests to run\",\n+            \"run-pass-valgrind | pretty | debug-info | codegen | rustdoc \\\n+            | rustdoc-json | codegen-units | incremental | run-make | ui | js-doc-test | mir-opt | assembly\",\n+        )\n+        .reqopt(\n+            \"\",\n+            \"suite\",\n+            \"which suite of compile tests to run. used for nicer error reporting.\",\n+            \"SUITE\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"pass\",\n+            \"force {check,build,run}-pass tests to this mode.\",\n+            \"check | build | run\",\n+        )\n+        .optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\")\n+        .optflag(\"\", \"ignored\", \"run tests marked as ignored\")\n+        .optmulti(\"\", \"skip\", \"skip tests matching SUBSTRING. Can be passed multiple times\", \"SUBSTRING\")\n+        .optflag(\"\", \"exact\", \"filters match exactly\")\n+        .optopt(\n+            \"\",\n+            \"runtool\",\n+            \"supervisor program to run tests under \\\n+             (eg. emulator, valgrind)\",\n+            \"PROGRAM\",\n+        )\n+        .optmulti(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\")\n+        .optmulti(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\")\n+        .optflag(\"\", \"optimize-tests\", \"run tests with optimizations enabled\")\n+        .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n+        .optflag(\n+            \"\",\n+            \"bless\",\n+            \"overwrite stderr/stdout files instead of complaining about a mismatch\",\n+        )\n+        .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n+        .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n+        .optflag(\"\", \"json\", \"emit json output instead of plaintext output\")\n+        .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n+        .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n+        .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n+        .optopt(\"\", \"cdb\", \"path to CDB to use for CDB debuginfo tests\", \"PATH\")\n+        .optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\")\n+        .optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\")\n+        .optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\")\n+        .optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\")\n+        .optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\")\n+        .optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\")\n+        .optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\")\n+        .optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\")\n+        .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n+        .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n+        .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n+        .reqopt(\"\", \"cxxflags\", \"flags for the CXX compiler\", \"FLAGS\")\n+        .optopt(\"\", \"ar\", \"path to an archiver\", \"PATH\")\n+        .optopt(\"\", \"target-linker\", \"path to a linker for the target\", \"PATH\")\n+        .optopt(\"\", \"host-linker\", \"path to a linker for the host\", \"PATH\")\n+        .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n+        .optopt(\"\", \"llvm-bin-dir\", \"Path to LLVM's `bin` directory\", \"PATH\")\n+        .optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\")\n+        .optopt(\"\", \"npm\", \"the name of npm\", \"PATH\")\n+        .optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\")\n+        .optopt(\n+            \"\",\n+            \"compare-mode\",\n+            \"mode describing what file the actual ui output will be compared to\",\n+            \"COMPARE MODE\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"rustfix-coverage\",\n+            \"enable this to generate a Rustfix coverage file, which is saved in \\\n+            `./<build_base>/rustfix_missing_coverage.txt`\",\n+        )\n+        .optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\")\n+        .optflag(\"\", \"only-modified\", \"only run tests that result been modified\")\n+        .optflag(\"\", \"nocapture\", \"\")\n+        .optflag(\"h\", \"help\", \"show this message\")\n+        .reqopt(\"\", \"channel\", \"current Rust channel\", \"CHANNEL\")\n+        .optflag(\"\", \"git-hash\", \"run tests which rely on commit version being compiled into the binaries\")\n+        .optopt(\"\", \"edition\", \"default Rust edition\", \"EDITION\");\n+\n+    let (argv0, args_) = args.split_first().unwrap();\n+    if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n+        let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n+        println!(\"{}\", opts.usage(&message));\n+        println!();\n+        panic!()\n+    }\n+\n+    let matches = &match opts.parse(args_) {\n+        Ok(m) => m,\n+        Err(f) => panic!(\"{:?}\", f),\n+    };\n+\n+    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n+        let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n+        println!(\"{}\", opts.usage(&message));\n+        println!();\n+        panic!()\n+    }\n+\n+    fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n+        match m.opt_str(nm) {\n+            Some(s) => PathBuf::from(&s),\n+            None => panic!(\"no option (=path) found for {}\", nm),\n+        }\n+    }\n+\n+    fn make_absolute(path: PathBuf) -> PathBuf {\n+        if path.is_relative() { env::current_dir().unwrap().join(path) } else { path }\n+    }\n+\n+    let target = opt_str2(matches.opt_str(\"target\"));\n+    let android_cross_path = opt_path(matches, \"android-cross-path\");\n+    let (cdb, cdb_version) = analyze_cdb(matches.opt_str(\"cdb\"), &target);\n+    let (gdb, gdb_version, gdb_native_rust) =\n+        analyze_gdb(matches.opt_str(\"gdb\"), &target, &android_cross_path);\n+    let (lldb_version, lldb_native_rust) = matches\n+        .opt_str(\"lldb-version\")\n+        .as_deref()\n+        .and_then(extract_lldb_version)\n+        .map(|(v, b)| (Some(v), b))\n+        .unwrap_or((None, false));\n+    let color = match matches.opt_str(\"color\").as_deref() {\n+        Some(\"auto\") | None => ColorConfig::AutoColor,\n+        Some(\"always\") => ColorConfig::AlwaysColor,\n+        Some(\"never\") => ColorConfig::NeverColor,\n+        Some(x) => panic!(\"argument for --color must be auto, always, or never, but found `{}`\", x),\n+    };\n+    let llvm_version =\n+        matches.opt_str(\"llvm-version\").as_deref().and_then(header::extract_llvm_version).or_else(\n+            || header::extract_llvm_version_from_binary(&matches.opt_str(\"llvm-filecheck\")?),\n+        );\n+\n+    let src_base = opt_path(matches, \"src-base\");\n+    let run_ignored = matches.opt_present(\"ignored\");\n+    let mode = matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\");\n+    let has_tidy = if mode == Mode::Rustdoc {\n+        Command::new(\"tidy\")\n+            .arg(\"--version\")\n+            .stdout(Stdio::null())\n+            .status()\n+            .map_or(false, |status| status.success())\n+    } else {\n+        // Avoid spawning an external command when we know tidy won't be used.\n+        false\n+    };\n+    Config {\n+        bless: matches.opt_present(\"bless\"),\n+        compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n+        run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n+        rustc_path: opt_path(matches, \"rustc-path\"),\n+        rustdoc_path: matches.opt_str(\"rustdoc-path\").map(PathBuf::from),\n+        rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n+        python: matches.opt_str(\"python\").unwrap(),\n+        jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n+        jsondoclint_path: matches.opt_str(\"jsondoclint-path\"),\n+        valgrind_path: matches.opt_str(\"valgrind-path\"),\n+        force_valgrind: matches.opt_present(\"force-valgrind\"),\n+        run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),\n+        llvm_filecheck: matches.opt_str(\"llvm-filecheck\").map(PathBuf::from),\n+        llvm_bin_dir: matches.opt_str(\"llvm-bin-dir\").map(PathBuf::from),\n+        src_base,\n+        build_base: opt_path(matches, \"build-base\"),\n+        sysroot_base: opt_path(matches, \"sysroot-base\"),\n+        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n+        mode,\n+        suite: matches.opt_str(\"suite\").unwrap(),\n+        debugger: None,\n+        run_ignored,\n+        filters: matches.free.clone(),\n+        skip: matches.opt_strs(\"skip\"),\n+        filter_exact: matches.opt_present(\"exact\"),\n+        force_pass_mode: matches.opt_str(\"pass\").map(|mode| {\n+            mode.parse::<PassMode>()\n+                .unwrap_or_else(|_| panic!(\"unknown `--pass` option `{}` given\", mode))\n+        }),\n+        run: matches.opt_str(\"run\").and_then(|mode| match mode.as_str() {\n+            \"auto\" => None,\n+            \"always\" => Some(true),\n+            \"never\" => Some(false),\n+            _ => panic!(\"unknown `--run` option `{}` given\", mode),\n+        }),\n+        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n+        runtool: matches.opt_str(\"runtool\"),\n+        host_rustcflags: matches.opt_strs(\"host-rustcflags\"),\n+        target_rustcflags: matches.opt_strs(\"target-rustcflags\"),\n+        optimize_tests: matches.opt_present(\"optimize-tests\"),\n+        target,\n+        host: opt_str2(matches.opt_str(\"host\")),\n+        cdb,\n+        cdb_version,\n+        gdb,\n+        gdb_version,\n+        gdb_native_rust,\n+        lldb_version,\n+        lldb_native_rust,\n+        llvm_version,\n+        system_llvm: matches.opt_present(\"system-llvm\"),\n+        android_cross_path,\n+        adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n+        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n+        adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n+            && \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\"))\n+            && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n+        lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n+        verbose: matches.opt_present(\"verbose\"),\n+        format: match (matches.opt_present(\"quiet\"), matches.opt_present(\"json\")) {\n+            (true, true) => panic!(\"--quiet and --json are incompatible\"),\n+            (true, false) => test::OutputFormat::Terse,\n+            (false, true) => test::OutputFormat::Json,\n+            (false, false) => test::OutputFormat::Pretty,\n+        },\n+        only_modified: matches.opt_present(\"only-modified\"),\n+        color,\n+        remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n+        compare_mode: matches\n+            .opt_str(\"compare-mode\")\n+            .map(|s| s.parse().expect(\"invalid --compare-mode provided\")),\n+        rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n+        has_tidy,\n+        channel: matches.opt_str(\"channel\").unwrap(),\n+        git_hash: matches.opt_present(\"git-hash\"),\n+        edition: matches.opt_str(\"edition\"),\n+\n+        cc: matches.opt_str(\"cc\").unwrap(),\n+        cxx: matches.opt_str(\"cxx\").unwrap(),\n+        cflags: matches.opt_str(\"cflags\").unwrap(),\n+        cxxflags: matches.opt_str(\"cxxflags\").unwrap(),\n+        ar: matches.opt_str(\"ar\").unwrap_or_else(|| String::from(\"ar\")),\n+        target_linker: matches.opt_str(\"target-linker\"),\n+        host_linker: matches.opt_str(\"host-linker\"),\n+        llvm_components: matches.opt_str(\"llvm-components\").unwrap(),\n+        nodejs: matches.opt_str(\"nodejs\"),\n+        npm: matches.opt_str(\"npm\"),\n+\n+        force_rerun: matches.opt_present(\"force-rerun\"),\n+\n+        target_cfgs: AtomicLazyCell::new(),\n+\n+        nocapture: matches.opt_present(\"nocapture\"),\n+    }\n+}\n+\n+pub fn log_config(config: &Config) {\n+    let c = config;\n+    logv(c, \"configuration:\".to_string());\n+    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n+    logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n+    logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n+    logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n+    logv(c, format!(\"rust_demangler_path: {:?}\", config.rust_demangler_path));\n+    logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n+    logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n+    logv(c, format!(\"stage_id: {}\", config.stage_id));\n+    logv(c, format!(\"mode: {}\", config.mode));\n+    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n+    logv(c, format!(\"filters: {:?}\", config.filters));\n+    logv(c, format!(\"skip: {:?}\", config.skip));\n+    logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n+    logv(\n+        c,\n+        format!(\"force_pass_mode: {}\", opt_str(&config.force_pass_mode.map(|m| format!(\"{}\", m))),),\n+    );\n+    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n+    logv(c, format!(\"host-rustcflags: {:?}\", config.host_rustcflags));\n+    logv(c, format!(\"target-rustcflags: {:?}\", config.target_rustcflags));\n+    logv(c, format!(\"target: {}\", config.target));\n+    logv(c, format!(\"host: {}\", config.host));\n+    logv(c, format!(\"android-cross-path: {:?}\", config.android_cross_path.display()));\n+    logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n+    logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n+    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n+    logv(c, format!(\"ar: {}\", config.ar));\n+    logv(c, format!(\"target-linker: {:?}\", config.target_linker));\n+    logv(c, format!(\"host-linker: {:?}\", config.host_linker));\n+    logv(c, format!(\"verbose: {}\", config.verbose));\n+    logv(c, format!(\"format: {:?}\", config.format));\n+    logv(c, \"\\n\".to_string());\n+}\n+\n+pub fn opt_str(maybestr: &Option<String>) -> &str {\n+    match *maybestr {\n+        None => \"(none)\",\n+        Some(ref s) => s,\n+    }\n+}\n+\n+pub fn opt_str2(maybestr: Option<String>) -> String {\n+    match maybestr {\n+        None => \"(none)\".to_owned(),\n+        Some(s) => s,\n+    }\n+}\n+\n+pub fn run_tests(config: Arc<Config>) {\n+    // If we want to collect rustfix coverage information,\n+    // we first make sure that the coverage file does not exist.\n+    // It will be created later on.\n+    if config.rustfix_coverage {\n+        let mut coverage_file_path = config.build_base.clone();\n+        coverage_file_path.push(\"rustfix_missing_coverage.txt\");\n+        if coverage_file_path.exists() {\n+            if let Err(e) = fs::remove_file(&coverage_file_path) {\n+                panic!(\"Could not delete {} due to {}\", coverage_file_path.display(), e)\n+            }\n+        }\n+    }\n+\n+    // sadly osx needs some file descriptor limits raised for running tests in\n+    // parallel (especially when we have lots and lots of child processes).\n+    // For context, see #8904\n+    unsafe {\n+        raise_fd_limit::raise_fd_limit();\n+    }\n+    // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n+    // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n+    env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n+\n+    // Let tests know which target they're running as\n+    env::set_var(\"TARGET\", &config.target);\n+\n+    let opts = test_opts(&config);\n+\n+    let mut configs = Vec::new();\n+    if let Mode::DebugInfo = config.mode {\n+        // Debugging emscripten code doesn't make sense today\n+        if !config.target.contains(\"emscripten\") {\n+            configs.extend(configure_cdb(&config));\n+            configs.extend(configure_gdb(&config));\n+            configs.extend(configure_lldb(&config));\n+        }\n+    } else {\n+        configs.push(config.clone());\n+    };\n+\n+    let mut tests = Vec::new();\n+    for c in configs {\n+        let mut found_paths = BTreeSet::new();\n+        make_tests(c, &mut tests, &mut found_paths);\n+        check_overlapping_tests(&found_paths);\n+    }\n+\n+    tests.sort_by(|a, b| a.desc.name.as_slice().cmp(&b.desc.name.as_slice()));\n+\n+    let res = test::run_tests_console(&opts, tests);\n+    match res {\n+        Ok(true) => {}\n+        Ok(false) => {\n+            // We want to report that the tests failed, but we also want to give\n+            // some indication of just what tests we were running. Especially on\n+            // CI, where there can be cross-compiled tests for a lot of\n+            // architectures, without this critical information it can be quite\n+            // easy to miss which tests failed, and as such fail to reproduce\n+            // the failure locally.\n+\n+            println!(\n+                \"Some tests failed in compiletest suite={}{} mode={} host={} target={}\",\n+                config.suite,\n+                config\n+                    .compare_mode\n+                    .as_ref()\n+                    .map(|c| format!(\" compare_mode={:?}\", c))\n+                    .unwrap_or_default(),\n+                config.mode,\n+                config.host,\n+                config.target\n+            );\n+\n+            std::process::exit(1);\n+        }\n+        Err(e) => {\n+            // We don't know if tests passed or not, but if there was an error\n+            // during testing we don't want to just succeed (we may not have\n+            // tested something), so fail.\n+            //\n+            // This should realistically \"never\" happen, so don't try to make\n+            // this a pretty error message.\n+            panic!(\"I/O failure during tests: {:?}\", e);\n+        }\n+    }\n+}\n+\n+fn configure_cdb(config: &Config) -> Option<Arc<Config>> {\n+    config.cdb.as_ref()?;\n+\n+    Some(Arc::new(Config { debugger: Some(Debugger::Cdb), ..config.clone() }))\n+}\n+\n+fn configure_gdb(config: &Config) -> Option<Arc<Config>> {\n+    config.gdb_version?;\n+\n+    if config.matches_env(\"msvc\") {\n+        return None;\n+    }\n+\n+    if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n+        println!(\n+            \"WARNING: debuginfo tests are not available when \\\n+             testing with remote\"\n+        );\n+        return None;\n+    }\n+\n+    if config.target.contains(\"android\") {\n+        println!(\n+            \"{} debug-info test uses tcp 5039 port.\\\n+             please reserve it\",\n+            config.target\n+        );\n+\n+        // android debug-info test uses remote debugger so, we test 1 thread\n+        // at once as they're all sharing the same TCP port to communicate\n+        // over.\n+        //\n+        // we should figure out how to lift this restriction! (run them all\n+        // on different ports allocated dynamically).\n+        env::set_var(\"RUST_TEST_THREADS\", \"1\");\n+    }\n+\n+    Some(Arc::new(Config { debugger: Some(Debugger::Gdb), ..config.clone() }))\n+}\n+\n+fn configure_lldb(config: &Config) -> Option<Arc<Config>> {\n+    config.lldb_python_dir.as_ref()?;\n+\n+    if let Some(350) = config.lldb_version {\n+        println!(\n+            \"WARNING: The used version of LLDB (350) has a \\\n+             known issue that breaks debuginfo tests. See \\\n+             issue #32520 for more information. Skipping all \\\n+             LLDB-based tests!\",\n+        );\n+        return None;\n+    }\n+\n+    Some(Arc::new(Config { debugger: Some(Debugger::Lldb), ..config.clone() }))\n+}\n+\n+pub fn test_opts(config: &Config) -> test::TestOpts {\n+    if env::var(\"RUST_TEST_NOCAPTURE\").is_ok() {\n+        eprintln!(\n+            \"WARNING: RUST_TEST_NOCAPTURE is no longer used. \\\n+                   Use the `--nocapture` flag instead.\"\n+        );\n+    }\n+\n+    test::TestOpts {\n+        exclude_should_panic: false,\n+        filters: config.filters.clone(),\n+        filter_exact: config.filter_exact,\n+        run_ignored: if config.run_ignored { test::RunIgnored::Yes } else { test::RunIgnored::No },\n+        format: config.format,\n+        logfile: config.logfile.clone(),\n+        run_tests: true,\n+        bench_benchmarks: true,\n+        nocapture: config.nocapture,\n+        color: config.color,\n+        shuffle: false,\n+        shuffle_seed: None,\n+        test_threads: None,\n+        skip: config.skip.clone(),\n+        list: false,\n+        options: test::Options::new(),\n+        time_options: None,\n+        force_run_in_process: false,\n+        fail_fast: std::env::var_os(\"RUSTC_TEST_FAIL_FAST\").is_some(),\n+    }\n+}\n+\n+pub fn make_tests(\n+    config: Arc<Config>,\n+    tests: &mut Vec<test::TestDescAndFn>,\n+    found_paths: &mut BTreeSet<PathBuf>,\n+) {\n+    debug!(\"making tests from {:?}\", config.src_base.display());\n+    let inputs = common_inputs_stamp(&config);\n+    let modified_tests = modified_tests(&config, &config.src_base).unwrap_or_else(|err| {\n+        panic!(\"modified_tests got error from dir: {}, error: {}\", config.src_base.display(), err)\n+    });\n+\n+    let cache = HeadersCache::load(&config);\n+    let mut poisoned = false;\n+    collect_tests_from_dir(\n+        config.clone(),\n+        &cache,\n+        &config.src_base,\n+        &PathBuf::new(),\n+        &inputs,\n+        tests,\n+        found_paths,\n+        &modified_tests,\n+        &mut poisoned,\n+    )\n+    .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n+\n+    if poisoned {\n+        eprintln!();\n+        panic!(\"there are errors in tests\");\n+    }\n+}\n+\n+/// Returns a stamp constructed from input files common to all test cases.\n+fn common_inputs_stamp(config: &Config) -> Stamp {\n+    let rust_src_dir = config.find_rust_src_root().expect(\"Could not find Rust source root\");\n+\n+    let mut stamp = Stamp::from_path(&config.rustc_path);\n+\n+    // Relevant pretty printer files\n+    let pretty_printer_files = [\n+        \"src/etc/rust_types.py\",\n+        \"src/etc/gdb_load_rust_pretty_printers.py\",\n+        \"src/etc/gdb_lookup.py\",\n+        \"src/etc/gdb_providers.py\",\n+        \"src/etc/lldb_batchmode.py\",\n+        \"src/etc/lldb_lookup.py\",\n+        \"src/etc/lldb_providers.py\",\n+    ];\n+    for file in &pretty_printer_files {\n+        let path = rust_src_dir.join(file);\n+        stamp.add_path(&path);\n+    }\n+\n+    stamp.add_dir(&rust_src_dir.join(\"src/etc/natvis\"));\n+\n+    stamp.add_dir(&config.run_lib_path);\n+\n+    if let Some(ref rustdoc_path) = config.rustdoc_path {\n+        stamp.add_path(&rustdoc_path);\n+        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n+    }\n+\n+    // Compiletest itself.\n+    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n+\n+    stamp\n+}\n+\n+fn modified_tests(config: &Config, dir: &Path) -> Result<Vec<PathBuf>, String> {\n+    if !config.only_modified {\n+        return Ok(vec![]);\n+    }\n+    let files =\n+        get_git_modified_files(Some(dir), &vec![\"rs\", \"stderr\", \"fixed\"])?.unwrap_or(vec![]);\n+    // Add new test cases to the list, it will be convenient in daily development.\n+    let untracked_files = get_git_untracked_files(None)?.unwrap_or(vec![]);\n+\n+    let all_paths = [&files[..], &untracked_files[..]].concat();\n+    let full_paths = {\n+        let mut full_paths: Vec<PathBuf> = all_paths\n+            .into_iter()\n+            .map(|f| PathBuf::from(f).with_extension(\"\").with_extension(\"rs\"))\n+            .filter_map(|f| if Path::new(&f).exists() { f.canonicalize().ok() } else { None })\n+            .collect();\n+        full_paths.dedup();\n+        full_paths.sort_unstable();\n+        full_paths\n+    };\n+    Ok(full_paths)\n+}\n+\n+fn collect_tests_from_dir(\n+    config: Arc<Config>,\n+    cache: &HeadersCache,\n+    dir: &Path,\n+    relative_dir_path: &Path,\n+    inputs: &Stamp,\n+    tests: &mut Vec<test::TestDescAndFn>,\n+    found_paths: &mut BTreeSet<PathBuf>,\n+    modified_tests: &Vec<PathBuf>,\n+    poisoned: &mut bool,\n+) -> io::Result<()> {\n+    // Ignore directories that contain a file named `compiletest-ignore-dir`.\n+    if dir.join(\"compiletest-ignore-dir\").exists() {\n+        return Ok(());\n+    }\n+\n+    if config.mode == Mode::RunMake && dir.join(\"Makefile\").exists() {\n+        let paths = TestPaths {\n+            file: dir.to_path_buf(),\n+            relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n+        };\n+        tests.extend(make_test(config, cache, &paths, inputs, poisoned));\n+        return Ok(());\n+    }\n+\n+    // If we find a test foo/bar.rs, we have to build the\n+    // output directory `$build/foo` so we can write\n+    // `$build/foo/bar` into it. We do this *now* in this\n+    // sequential loop because otherwise, if we do it in the\n+    // tests themselves, they race for the privilege of\n+    // creating the directories and sometimes fail randomly.\n+    let build_dir = output_relative_path(&config, relative_dir_path);\n+    fs::create_dir_all(&build_dir).unwrap();\n+\n+    // Add each `.rs` file as a test, and recurse further on any\n+    // subdirectories we find, except for `aux` directories.\n+    for file in fs::read_dir(dir)? {\n+        let file = file?;\n+        let file_path = file.path();\n+        let file_name = file.file_name();\n+        if is_test(&file_name) && (!config.only_modified || modified_tests.contains(&file_path)) {\n+            debug!(\"found test file: {:?}\", file_path.display());\n+            let rel_test_path = relative_dir_path.join(file_path.file_stem().unwrap());\n+            found_paths.insert(rel_test_path);\n+            let paths =\n+                TestPaths { file: file_path, relative_dir: relative_dir_path.to_path_buf() };\n+\n+            tests.extend(make_test(config.clone(), cache, &paths, inputs, poisoned))\n+        } else if file_path.is_dir() {\n+            let relative_file_path = relative_dir_path.join(file.file_name());\n+            if &file_name != \"auxiliary\" {\n+                debug!(\"found directory: {:?}\", file_path.display());\n+                collect_tests_from_dir(\n+                    config.clone(),\n+                    cache,\n+                    &file_path,\n+                    &relative_file_path,\n+                    inputs,\n+                    tests,\n+                    found_paths,\n+                    modified_tests,\n+                    poisoned,\n+                )?;\n+            }\n+        } else {\n+            debug!(\"found other file/directory: {:?}\", file_path.display());\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// Returns true if `file_name` looks like a proper test file name.\n+pub fn is_test(file_name: &OsString) -> bool {\n+    let file_name = file_name.to_str().unwrap();\n+\n+    if !file_name.ends_with(\".rs\") {\n+        return false;\n+    }\n+\n+    // `.`, `#`, and `~` are common temp-file prefixes.\n+    let invalid_prefixes = &[\".\", \"#\", \"~\"];\n+    !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n+}\n+\n+fn make_test(\n+    config: Arc<Config>,\n+    cache: &HeadersCache,\n+    testpaths: &TestPaths,\n+    inputs: &Stamp,\n+    poisoned: &mut bool,\n+) -> Vec<test::TestDescAndFn> {\n+    let test_path = if config.mode == Mode::RunMake {\n+        // Parse directives in the Makefile\n+        testpaths.file.join(\"Makefile\")\n+    } else {\n+        PathBuf::from(&testpaths.file)\n+    };\n+    let early_props = EarlyProps::from_file(&config, &test_path);\n+\n+    // Incremental tests are special, they inherently cannot be run in parallel.\n+    // `runtest::run` will be responsible for iterating over revisions.\n+    let revisions = if early_props.revisions.is_empty() || config.mode == Mode::Incremental {\n+        vec![None]\n+    } else {\n+        early_props.revisions.iter().map(Some).collect()\n+    };\n+\n+    revisions\n+        .into_iter()\n+        .map(|revision| {\n+            let src_file =\n+                std::fs::File::open(&test_path).expect(\"open test file to parse ignores\");\n+            let cfg = revision.map(|v| &**v);\n+            let test_name = crate::make_test_name(&config, testpaths, revision);\n+            let mut desc = make_test_description(\n+                &config, cache, test_name, &test_path, src_file, cfg, poisoned,\n+            );\n+            // Ignore tests that already run and are up to date with respect to inputs.\n+            if !config.force_rerun {\n+                desc.ignore |= is_up_to_date(\n+                    &config,\n+                    testpaths,\n+                    &early_props,\n+                    revision.map(|s| s.as_str()),\n+                    inputs,\n+                );\n+            }\n+            test::TestDescAndFn {\n+                desc,\n+                testfn: make_test_closure(config.clone(), testpaths, revision),\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n+    output_base_dir(config, testpaths, revision).join(\"stamp\")\n+}\n+\n+fn files_related_to_test(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    props: &EarlyProps,\n+    revision: Option<&str>,\n+) -> Vec<PathBuf> {\n+    let mut related = vec![];\n+\n+    if testpaths.file.is_dir() {\n+        // run-make tests use their individual directory\n+        for entry in WalkDir::new(&testpaths.file) {\n+            let path = entry.unwrap().into_path();\n+            if path.is_file() {\n+                related.push(path);\n+            }\n+        }\n+    } else {\n+        related.push(testpaths.file.clone());\n+    }\n+\n+    for aux in &props.aux {\n+        let path = testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux);\n+        related.push(path);\n+    }\n+\n+    // UI test files.\n+    for extension in UI_EXTENSIONS {\n+        let path = expected_output_path(testpaths, revision, &config.compare_mode, extension);\n+        related.push(path);\n+    }\n+\n+    related\n+}\n+\n+fn is_up_to_date(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    props: &EarlyProps,\n+    revision: Option<&str>,\n+    inputs: &Stamp,\n+) -> bool {\n+    let stamp_name = stamp(config, testpaths, revision);\n+    // Check hash.\n+    let contents = match fs::read_to_string(&stamp_name) {\n+        Ok(f) => f,\n+        Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n+        Err(_) => return false,\n+    };\n+    let expected_hash = runtest::compute_stamp_hash(config);\n+    if contents != expected_hash {\n+        return false;\n+    }\n+\n+    // Check timestamps.\n+    let mut inputs = inputs.clone();\n+    for path in files_related_to_test(config, testpaths, props, revision) {\n+        inputs.add_path(&path);\n+    }\n+\n+    inputs < Stamp::from_path(&stamp_name)\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+struct Stamp {\n+    time: SystemTime,\n+}\n+\n+impl Stamp {\n+    fn from_path(path: &Path) -> Self {\n+        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n+        stamp.add_path(path);\n+        stamp\n+    }\n+\n+    fn add_path(&mut self, path: &Path) {\n+        let modified = fs::metadata(path)\n+            .and_then(|metadata| metadata.modified())\n+            .unwrap_or(SystemTime::UNIX_EPOCH);\n+        self.time = self.time.max(modified);\n+    }\n+\n+    fn add_dir(&mut self, path: &Path) {\n+        for entry in WalkDir::new(path) {\n+            let entry = entry.unwrap();\n+            if entry.file_type().is_file() {\n+                let modified = entry\n+                    .metadata()\n+                    .ok()\n+                    .and_then(|metadata| metadata.modified().ok())\n+                    .unwrap_or(SystemTime::UNIX_EPOCH);\n+                self.time = self.time.max(modified);\n+            }\n+        }\n+    }\n+}\n+\n+fn make_test_name(\n+    config: &Config,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestName {\n+    // Print the name of the file, relative to the repository root.\n+    // `src_base` looks like `/path/to/rust/tests/ui`\n+    let root_directory = config.src_base.parent().unwrap().parent().unwrap();\n+    let path = testpaths.file.strip_prefix(root_directory).unwrap();\n+    let debugger = match config.debugger {\n+        Some(d) => format!(\"-{}\", d),\n+        None => String::new(),\n+    };\n+    let mode_suffix = match config.compare_mode {\n+        Some(ref mode) => format!(\" ({})\", mode.to_str()),\n+        None => String::new(),\n+    };\n+\n+    test::DynTestName(format!(\n+        \"[{}{}{}] {}{}\",\n+        config.mode,\n+        debugger,\n+        mode_suffix,\n+        path.display(),\n+        revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n+    ))\n+}\n+\n+fn make_test_closure(\n+    config: Arc<Config>,\n+    testpaths: &TestPaths,\n+    revision: Option<&String>,\n+) -> test::TestFn {\n+    let config = config.clone();\n+    let testpaths = testpaths.clone();\n+    let revision = revision.cloned();\n+    test::DynTestFn(Box::new(move || {\n+        runtest::run(config, &testpaths, revision.as_deref());\n+        Ok(())\n+    }))\n+}\n+\n+/// Returns `true` if the given target is an Android target for the\n+/// purposes of GDB testing.\n+fn is_android_gdb_target(target: &str) -> bool {\n+    matches!(\n+        &target[..],\n+        \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\"\n+    )\n+}\n+\n+/// Returns `true` if the given target is a MSVC target for the purpouses of CDB testing.\n+fn is_pc_windows_msvc_target(target: &str) -> bool {\n+    target.ends_with(\"-pc-windows-msvc\")\n+}\n+\n+fn find_cdb(target: &str) -> Option<OsString> {\n+    if !(cfg!(windows) && is_pc_windows_msvc_target(target)) {\n+        return None;\n+    }\n+\n+    let pf86 = env::var_os(\"ProgramFiles(x86)\").or_else(|| env::var_os(\"ProgramFiles\"))?;\n+    let cdb_arch = if cfg!(target_arch = \"x86\") {\n+        \"x86\"\n+    } else if cfg!(target_arch = \"x86_64\") {\n+        \"x64\"\n+    } else if cfg!(target_arch = \"aarch64\") {\n+        \"arm64\"\n+    } else if cfg!(target_arch = \"arm\") {\n+        \"arm\"\n+    } else {\n+        return None; // No compatible CDB.exe in the Windows 10 SDK\n+    };\n+\n+    let mut path = PathBuf::new();\n+    path.push(pf86);\n+    path.push(r\"Windows Kits\\10\\Debuggers\"); // We could check 8.1 etc. too?\n+    path.push(cdb_arch);\n+    path.push(r\"cdb.exe\");\n+\n+    if !path.exists() {\n+        return None;\n+    }\n+\n+    Some(path.into_os_string())\n+}\n+\n+/// Returns Path to CDB\n+fn analyze_cdb(cdb: Option<String>, target: &str) -> (Option<OsString>, Option<[u16; 4]>) {\n+    let cdb = cdb.map(OsString::from).or_else(|| find_cdb(target));\n+\n+    let mut version = None;\n+    if let Some(cdb) = cdb.as_ref() {\n+        if let Ok(output) = Command::new(cdb).arg(\"/version\").output() {\n+            if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n+                version = extract_cdb_version(&first_line);\n+            }\n+        }\n+    }\n+\n+    (cdb, version)\n+}\n+\n+fn extract_cdb_version(full_version_line: &str) -> Option<[u16; 4]> {\n+    // Example full_version_line: \"cdb version 10.0.18362.1\"\n+    let version = full_version_line.rsplit(' ').next()?;\n+    let mut components = version.split('.');\n+    let major: u16 = components.next().unwrap().parse().unwrap();\n+    let minor: u16 = components.next().unwrap().parse().unwrap();\n+    let patch: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n+    let build: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n+    Some([major, minor, patch, build])\n+}\n+\n+/// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n+fn analyze_gdb(\n+    gdb: Option<String>,\n+    target: &str,\n+    android_cross_path: &PathBuf,\n+) -> (Option<String>, Option<u32>, bool) {\n+    #[cfg(not(windows))]\n+    const GDB_FALLBACK: &str = \"gdb\";\n+    #[cfg(windows)]\n+    const GDB_FALLBACK: &str = \"gdb.exe\";\n+\n+    const MIN_GDB_WITH_RUST: u32 = 7011010;\n+\n+    let fallback_gdb = || {\n+        if is_android_gdb_target(target) {\n+            let mut gdb_path = match android_cross_path.to_str() {\n+                Some(x) => x.to_owned(),\n+                None => panic!(\"cannot find android cross path\"),\n+            };\n+            gdb_path.push_str(\"/bin/gdb\");\n+            gdb_path\n+        } else {\n+            GDB_FALLBACK.to_owned()\n+        }\n+    };\n+\n+    let gdb = match gdb {\n+        None => fallback_gdb(),\n+        Some(ref s) if s.is_empty() => fallback_gdb(), // may be empty if configure found no gdb\n+        Some(ref s) => s.to_owned(),\n+    };\n+\n+    let mut version_line = None;\n+    if let Ok(output) = Command::new(&gdb).arg(\"--version\").output() {\n+        if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n+            version_line = Some(first_line.to_string());\n+        }\n+    }\n+\n+    let version = match version_line {\n+        Some(line) => extract_gdb_version(&line),\n+        None => return (None, None, false),\n+    };\n+\n+    let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n+\n+    (Some(gdb), version, gdb_native_rust)\n+}\n+\n+fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n+    let full_version_line = full_version_line.trim();\n+\n+    // GDB versions look like this: \"major.minor.patch?.yyyymmdd?\", with both\n+    // of the ? sections being optional\n+\n+    // We will parse up to 3 digits for each component, ignoring the date\n+\n+    // We skip text in parentheses.  This avoids accidentally parsing\n+    // the openSUSE version, which looks like:\n+    //  GNU gdb (GDB; openSUSE Leap 15.0) 8.1\n+    // This particular form is documented in the GNU coding standards:\n+    // https://www.gnu.org/prep/standards/html_node/_002d_002dversion.html#g_t_002d_002dversion\n+\n+    let unbracketed_part = full_version_line.split('[').next().unwrap();\n+    let mut splits = unbracketed_part.trim_end().rsplit(' ');\n+    let version_string = splits.next().unwrap();\n+\n+    let mut splits = version_string.split('.');\n+    let major = splits.next().unwrap();\n+    let minor = splits.next().unwrap();\n+    let patch = splits.next();\n+\n+    let major: u32 = major.parse().unwrap();\n+    let (minor, patch): (u32, u32) = match minor.find(not_a_digit) {\n+        None => {\n+            let minor = minor.parse().unwrap();\n+            let patch: u32 = match patch {\n+                Some(patch) => match patch.find(not_a_digit) {\n+                    None => patch.parse().unwrap(),\n+                    Some(idx) if idx > 3 => 0,\n+                    Some(idx) => patch[..idx].parse().unwrap(),\n+                },\n+                None => 0,\n+            };\n+            (minor, patch)\n+        }\n+        // There is no patch version after minor-date (e.g. \"4-2012\").\n+        Some(idx) => {\n+            let minor = minor[..idx].parse().unwrap();\n+            (minor, 0)\n+        }\n+    };\n+\n+    Some(((major * 1000) + minor) * 1000 + patch)\n+}\n+\n+/// Returns (LLDB version, LLDB is rust-enabled)\n+fn extract_lldb_version(full_version_line: &str) -> Option<(u32, bool)> {\n+    // Extract the major LLDB version from the given version string.\n+    // LLDB version strings are different for Apple and non-Apple platforms.\n+    // The Apple variant looks like this:\n+    //\n+    // LLDB-179.5 (older versions)\n+    // lldb-300.2.51 (new versions)\n+    //\n+    // We are only interested in the major version number, so this function\n+    // will return `Some(179)` and `Some(300)` respectively.\n+    //\n+    // Upstream versions look like:\n+    // lldb version 6.0.1\n+    //\n+    // There doesn't seem to be a way to correlate the Apple version\n+    // with the upstream version, and since the tests were originally\n+    // written against Apple versions, we make a fake Apple version by\n+    // multiplying the first number by 100.  This is a hack, but\n+    // normally fine because the only non-Apple version we test is\n+    // rust-enabled.\n+\n+    let full_version_line = full_version_line.trim();\n+\n+    if let Some(apple_ver) =\n+        full_version_line.strip_prefix(\"LLDB-\").or_else(|| full_version_line.strip_prefix(\"lldb-\"))\n+    {\n+        if let Some(idx) = apple_ver.find(not_a_digit) {\n+            let version: u32 = apple_ver[..idx].parse().unwrap();\n+            return Some((version, full_version_line.contains(\"rust-enabled\")));\n+        }\n+    } else if let Some(lldb_ver) = full_version_line.strip_prefix(\"lldb version \") {\n+        if let Some(idx) = lldb_ver.find(not_a_digit) {\n+            let version: u32 = lldb_ver[..idx].parse().ok()?;\n+            return Some((version * 100, full_version_line.contains(\"rust-enabled\")));\n+        }\n+    }\n+    None\n+}\n+\n+fn not_a_digit(c: char) -> bool {\n+    !c.is_digit(10)\n+}\n+\n+fn check_overlapping_tests(found_paths: &BTreeSet<PathBuf>) {\n+    let mut collisions = Vec::new();\n+    for path in found_paths {\n+        for ancestor in path.ancestors().skip(1) {\n+            if found_paths.contains(ancestor) {\n+                collisions.push((path, ancestor.clone()));\n+            }\n+        }\n+    }\n+    if !collisions.is_empty() {\n+        let collisions: String = collisions\n+            .into_iter()\n+            .map(|(path, check_parent)| format!(\"test {path:?} clashes with {check_parent:?}\\n\"))\n+            .collect();\n+        panic!(\n+            \"{collisions}\\n\\\n+            Tests cannot have overlapping names. Make sure they use unique prefixes.\"\n+        );\n+    }\n+}"}, {"sha": "34d48559c378da12748c63c7e0421b7bfd3d82cd", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 2, "deletions": 1135, "changes": 1137, "blob_url": "https://github.com/rust-lang/rust/blob/548978f1d025e9b937cdedabe3a86da70789dbdc/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548978f1d025e9b937cdedabe3a86da70789dbdc/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=548978f1d025e9b937cdedabe3a86da70789dbdc", "patch": "@@ -1,45 +1,6 @@\n-#![crate_name = \"compiletest\"]\n-// The `test` crate is the only unstable feature\n-// allowed here, just to share similar code.\n-#![feature(test)]\n+use std::{env, sync::Arc};\n \n-extern crate test;\n-\n-use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n-use crate::common::{Config, Debugger, Mode, PassMode, TestPaths};\n-use crate::util::logv;\n-use build_helper::git::{get_git_modified_files, get_git_untracked_files};\n-use core::panic;\n-use getopts::Options;\n-use lazycell::AtomicLazyCell;\n-use std::collections::BTreeSet;\n-use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, ErrorKind};\n-use std::path::{Path, PathBuf};\n-use std::process::{Command, Stdio};\n-use std::time::SystemTime;\n-use std::{env, vec};\n-use test::ColorConfig;\n-use tracing::*;\n-use walkdir::WalkDir;\n-\n-use self::header::{make_test_description, EarlyProps};\n-use crate::header::HeadersCache;\n-use std::sync::Arc;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-pub mod common;\n-pub mod compute_diff;\n-pub mod errors;\n-pub mod header;\n-mod json;\n-mod raise_fd_limit;\n-mod read2;\n-pub mod runtest;\n-pub mod util;\n+use compiletest::{common::Mode, log_config, parse_config, run_tests};\n \n fn main() {\n     tracing_subscriber::fmt::init();\n@@ -57,1097 +18,3 @@ fn main() {\n     log_config(&config);\n     run_tests(config);\n }\n-\n-pub fn parse_config(args: Vec<String>) -> Config {\n-    let mut opts = Options::new();\n-    opts.reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\")\n-        .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n-        .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n-        .optopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n-        .optopt(\"\", \"rust-demangler-path\", \"path to rust-demangler to use in tests\", \"PATH\")\n-        .reqopt(\"\", \"python\", \"path to python to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"jsondocck-path\", \"path to jsondocck to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"jsondoclint-path\", \"path to jsondoclint to use for doc tests\", \"PATH\")\n-        .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n-        .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n-        .optopt(\"\", \"run-clang-based-tests-with\", \"path to Clang executable\", \"PATH\")\n-        .optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\")\n-        .reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\")\n-        .reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\")\n-        .reqopt(\"\", \"sysroot-base\", \"directory containing the compiler sysroot\", \"PATH\")\n-        .reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\")\n-        .reqopt(\n-            \"\",\n-            \"mode\",\n-            \"which sort of compile tests to run\",\n-            \"run-pass-valgrind | pretty | debug-info | codegen | rustdoc \\\n-            | rustdoc-json | codegen-units | incremental | run-make | ui | js-doc-test | mir-opt | assembly\",\n-        )\n-        .reqopt(\n-            \"\",\n-            \"suite\",\n-            \"which suite of compile tests to run. used for nicer error reporting.\",\n-            \"SUITE\",\n-        )\n-        .optopt(\n-            \"\",\n-            \"pass\",\n-            \"force {check,build,run}-pass tests to this mode.\",\n-            \"check | build | run\",\n-        )\n-        .optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\")\n-        .optflag(\"\", \"ignored\", \"run tests marked as ignored\")\n-        .optmulti(\"\", \"skip\", \"skip tests matching SUBSTRING. Can be passed multiple times\", \"SUBSTRING\")\n-        .optflag(\"\", \"exact\", \"filters match exactly\")\n-        .optopt(\n-            \"\",\n-            \"runtool\",\n-            \"supervisor program to run tests under \\\n-             (eg. emulator, valgrind)\",\n-            \"PROGRAM\",\n-        )\n-        .optmulti(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\")\n-        .optmulti(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\")\n-        .optflag(\"\", \"optimize-tests\", \"run tests with optimizations enabled\")\n-        .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n-        .optflag(\n-            \"\",\n-            \"bless\",\n-            \"overwrite stderr/stdout files instead of complaining about a mismatch\",\n-        )\n-        .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n-        .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n-        .optflag(\"\", \"json\", \"emit json output instead of plaintext output\")\n-        .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n-        .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n-        .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n-        .optopt(\"\", \"cdb\", \"path to CDB to use for CDB debuginfo tests\", \"PATH\")\n-        .optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\")\n-        .optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\")\n-        .optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\")\n-        .optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\")\n-        .optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\")\n-        .optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\")\n-        .optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\")\n-        .optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\")\n-        .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n-        .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n-        .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n-        .reqopt(\"\", \"cxxflags\", \"flags for the CXX compiler\", \"FLAGS\")\n-        .optopt(\"\", \"ar\", \"path to an archiver\", \"PATH\")\n-        .optopt(\"\", \"target-linker\", \"path to a linker for the target\", \"PATH\")\n-        .optopt(\"\", \"host-linker\", \"path to a linker for the host\", \"PATH\")\n-        .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n-        .optopt(\"\", \"llvm-bin-dir\", \"Path to LLVM's `bin` directory\", \"PATH\")\n-        .optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\")\n-        .optopt(\"\", \"npm\", \"the name of npm\", \"PATH\")\n-        .optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\")\n-        .optopt(\n-            \"\",\n-            \"compare-mode\",\n-            \"mode describing what file the actual ui output will be compared to\",\n-            \"COMPARE MODE\",\n-        )\n-        .optflag(\n-            \"\",\n-            \"rustfix-coverage\",\n-            \"enable this to generate a Rustfix coverage file, which is saved in \\\n-            `./<build_base>/rustfix_missing_coverage.txt`\",\n-        )\n-        .optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\")\n-        .optflag(\"\", \"only-modified\", \"only run tests that result been modified\")\n-        .optflag(\"\", \"nocapture\", \"\")\n-        .optflag(\"h\", \"help\", \"show this message\")\n-        .reqopt(\"\", \"channel\", \"current Rust channel\", \"CHANNEL\")\n-        .optflag(\"\", \"git-hash\", \"run tests which rely on commit version being compiled into the binaries\")\n-        .optopt(\"\", \"edition\", \"default Rust edition\", \"EDITION\");\n-\n-    let (argv0, args_) = args.split_first().unwrap();\n-    if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n-        let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", opts.usage(&message));\n-        println!();\n-        panic!()\n-    }\n-\n-    let matches = &match opts.parse(args_) {\n-        Ok(m) => m,\n-        Err(f) => panic!(\"{:?}\", f),\n-    };\n-\n-    if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n-        let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", opts.usage(&message));\n-        println!();\n-        panic!()\n-    }\n-\n-    fn opt_path(m: &getopts::Matches, nm: &str) -> PathBuf {\n-        match m.opt_str(nm) {\n-            Some(s) => PathBuf::from(&s),\n-            None => panic!(\"no option (=path) found for {}\", nm),\n-        }\n-    }\n-\n-    fn make_absolute(path: PathBuf) -> PathBuf {\n-        if path.is_relative() { env::current_dir().unwrap().join(path) } else { path }\n-    }\n-\n-    let target = opt_str2(matches.opt_str(\"target\"));\n-    let android_cross_path = opt_path(matches, \"android-cross-path\");\n-    let (cdb, cdb_version) = analyze_cdb(matches.opt_str(\"cdb\"), &target);\n-    let (gdb, gdb_version, gdb_native_rust) =\n-        analyze_gdb(matches.opt_str(\"gdb\"), &target, &android_cross_path);\n-    let (lldb_version, lldb_native_rust) = matches\n-        .opt_str(\"lldb-version\")\n-        .as_deref()\n-        .and_then(extract_lldb_version)\n-        .map(|(v, b)| (Some(v), b))\n-        .unwrap_or((None, false));\n-    let color = match matches.opt_str(\"color\").as_deref() {\n-        Some(\"auto\") | None => ColorConfig::AutoColor,\n-        Some(\"always\") => ColorConfig::AlwaysColor,\n-        Some(\"never\") => ColorConfig::NeverColor,\n-        Some(x) => panic!(\"argument for --color must be auto, always, or never, but found `{}`\", x),\n-    };\n-    let llvm_version =\n-        matches.opt_str(\"llvm-version\").as_deref().and_then(header::extract_llvm_version).or_else(\n-            || header::extract_llvm_version_from_binary(&matches.opt_str(\"llvm-filecheck\")?),\n-        );\n-\n-    let src_base = opt_path(matches, \"src-base\");\n-    let run_ignored = matches.opt_present(\"ignored\");\n-    let mode = matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\");\n-    let has_tidy = if mode == Mode::Rustdoc {\n-        Command::new(\"tidy\")\n-            .arg(\"--version\")\n-            .stdout(Stdio::null())\n-            .status()\n-            .map_or(false, |status| status.success())\n-    } else {\n-        // Avoid spawning an external command when we know tidy won't be used.\n-        false\n-    };\n-    Config {\n-        bless: matches.opt_present(\"bless\"),\n-        compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n-        run_lib_path: make_absolute(opt_path(matches, \"run-lib-path\")),\n-        rustc_path: opt_path(matches, \"rustc-path\"),\n-        rustdoc_path: matches.opt_str(\"rustdoc-path\").map(PathBuf::from),\n-        rust_demangler_path: matches.opt_str(\"rust-demangler-path\").map(PathBuf::from),\n-        python: matches.opt_str(\"python\").unwrap(),\n-        jsondocck_path: matches.opt_str(\"jsondocck-path\"),\n-        jsondoclint_path: matches.opt_str(\"jsondoclint-path\"),\n-        valgrind_path: matches.opt_str(\"valgrind-path\"),\n-        force_valgrind: matches.opt_present(\"force-valgrind\"),\n-        run_clang_based_tests_with: matches.opt_str(\"run-clang-based-tests-with\"),\n-        llvm_filecheck: matches.opt_str(\"llvm-filecheck\").map(PathBuf::from),\n-        llvm_bin_dir: matches.opt_str(\"llvm-bin-dir\").map(PathBuf::from),\n-        src_base,\n-        build_base: opt_path(matches, \"build-base\"),\n-        sysroot_base: opt_path(matches, \"sysroot-base\"),\n-        stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode,\n-        suite: matches.opt_str(\"suite\").unwrap(),\n-        debugger: None,\n-        run_ignored,\n-        filters: matches.free.clone(),\n-        skip: matches.opt_strs(\"skip\"),\n-        filter_exact: matches.opt_present(\"exact\"),\n-        force_pass_mode: matches.opt_str(\"pass\").map(|mode| {\n-            mode.parse::<PassMode>()\n-                .unwrap_or_else(|_| panic!(\"unknown `--pass` option `{}` given\", mode))\n-        }),\n-        run: matches.opt_str(\"run\").and_then(|mode| match mode.as_str() {\n-            \"auto\" => None,\n-            \"always\" => Some(true),\n-            \"never\" => Some(false),\n-            _ => panic!(\"unknown `--run` option `{}` given\", mode),\n-        }),\n-        logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n-        runtool: matches.opt_str(\"runtool\"),\n-        host_rustcflags: matches.opt_strs(\"host-rustcflags\"),\n-        target_rustcflags: matches.opt_strs(\"target-rustcflags\"),\n-        optimize_tests: matches.opt_present(\"optimize-tests\"),\n-        target,\n-        host: opt_str2(matches.opt_str(\"host\")),\n-        cdb,\n-        cdb_version,\n-        gdb,\n-        gdb_version,\n-        gdb_native_rust,\n-        lldb_version,\n-        lldb_native_rust,\n-        llvm_version,\n-        system_llvm: matches.opt_present(\"system-llvm\"),\n-        android_cross_path,\n-        adb_path: opt_str2(matches.opt_str(\"adb-path\")),\n-        adb_test_dir: opt_str2(matches.opt_str(\"adb-test-dir\")),\n-        adb_device_status: opt_str2(matches.opt_str(\"target\")).contains(\"android\")\n-            && \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\"))\n-            && !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n-        lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n-        verbose: matches.opt_present(\"verbose\"),\n-        format: match (matches.opt_present(\"quiet\"), matches.opt_present(\"json\")) {\n-            (true, true) => panic!(\"--quiet and --json are incompatible\"),\n-            (true, false) => test::OutputFormat::Terse,\n-            (false, true) => test::OutputFormat::Json,\n-            (false, false) => test::OutputFormat::Pretty,\n-        },\n-        only_modified: matches.opt_present(\"only-modified\"),\n-        color,\n-        remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n-        compare_mode: matches\n-            .opt_str(\"compare-mode\")\n-            .map(|s| s.parse().expect(\"invalid --compare-mode provided\")),\n-        rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n-        has_tidy,\n-        channel: matches.opt_str(\"channel\").unwrap(),\n-        git_hash: matches.opt_present(\"git-hash\"),\n-        edition: matches.opt_str(\"edition\"),\n-\n-        cc: matches.opt_str(\"cc\").unwrap(),\n-        cxx: matches.opt_str(\"cxx\").unwrap(),\n-        cflags: matches.opt_str(\"cflags\").unwrap(),\n-        cxxflags: matches.opt_str(\"cxxflags\").unwrap(),\n-        ar: matches.opt_str(\"ar\").unwrap_or_else(|| String::from(\"ar\")),\n-        target_linker: matches.opt_str(\"target-linker\"),\n-        host_linker: matches.opt_str(\"host-linker\"),\n-        llvm_components: matches.opt_str(\"llvm-components\").unwrap(),\n-        nodejs: matches.opt_str(\"nodejs\"),\n-        npm: matches.opt_str(\"npm\"),\n-\n-        force_rerun: matches.opt_present(\"force-rerun\"),\n-\n-        target_cfgs: AtomicLazyCell::new(),\n-\n-        nocapture: matches.opt_present(\"nocapture\"),\n-    }\n-}\n-\n-pub fn log_config(config: &Config) {\n-    let c = config;\n-    logv(c, \"configuration:\".to_string());\n-    logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n-    logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n-    logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n-    logv(c, format!(\"rustdoc_path: {:?}\", config.rustdoc_path));\n-    logv(c, format!(\"rust_demangler_path: {:?}\", config.rust_demangler_path));\n-    logv(c, format!(\"src_base: {:?}\", config.src_base.display()));\n-    logv(c, format!(\"build_base: {:?}\", config.build_base.display()));\n-    logv(c, format!(\"stage_id: {}\", config.stage_id));\n-    logv(c, format!(\"mode: {}\", config.mode));\n-    logv(c, format!(\"run_ignored: {}\", config.run_ignored));\n-    logv(c, format!(\"filters: {:?}\", config.filters));\n-    logv(c, format!(\"skip: {:?}\", config.skip));\n-    logv(c, format!(\"filter_exact: {}\", config.filter_exact));\n-    logv(\n-        c,\n-        format!(\"force_pass_mode: {}\", opt_str(&config.force_pass_mode.map(|m| format!(\"{}\", m))),),\n-    );\n-    logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n-    logv(c, format!(\"host-rustcflags: {:?}\", config.host_rustcflags));\n-    logv(c, format!(\"target-rustcflags: {:?}\", config.target_rustcflags));\n-    logv(c, format!(\"target: {}\", config.target));\n-    logv(c, format!(\"host: {}\", config.host));\n-    logv(c, format!(\"android-cross-path: {:?}\", config.android_cross_path.display()));\n-    logv(c, format!(\"adb_path: {:?}\", config.adb_path));\n-    logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n-    logv(c, format!(\"adb_device_status: {}\", config.adb_device_status));\n-    logv(c, format!(\"ar: {}\", config.ar));\n-    logv(c, format!(\"target-linker: {:?}\", config.target_linker));\n-    logv(c, format!(\"host-linker: {:?}\", config.host_linker));\n-    logv(c, format!(\"verbose: {}\", config.verbose));\n-    logv(c, format!(\"format: {:?}\", config.format));\n-    logv(c, \"\\n\".to_string());\n-}\n-\n-pub fn opt_str(maybestr: &Option<String>) -> &str {\n-    match *maybestr {\n-        None => \"(none)\",\n-        Some(ref s) => s,\n-    }\n-}\n-\n-pub fn opt_str2(maybestr: Option<String>) -> String {\n-    match maybestr {\n-        None => \"(none)\".to_owned(),\n-        Some(s) => s,\n-    }\n-}\n-\n-pub fn run_tests(config: Arc<Config>) {\n-    // If we want to collect rustfix coverage information,\n-    // we first make sure that the coverage file does not exist.\n-    // It will be created later on.\n-    if config.rustfix_coverage {\n-        let mut coverage_file_path = config.build_base.clone();\n-        coverage_file_path.push(\"rustfix_missing_coverage.txt\");\n-        if coverage_file_path.exists() {\n-            if let Err(e) = fs::remove_file(&coverage_file_path) {\n-                panic!(\"Could not delete {} due to {}\", coverage_file_path.display(), e)\n-            }\n-        }\n-    }\n-\n-    // sadly osx needs some file descriptor limits raised for running tests in\n-    // parallel (especially when we have lots and lots of child processes).\n-    // For context, see #8904\n-    unsafe {\n-        raise_fd_limit::raise_fd_limit();\n-    }\n-    // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n-    // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n-    env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");\n-\n-    // Let tests know which target they're running as\n-    env::set_var(\"TARGET\", &config.target);\n-\n-    let opts = test_opts(&config);\n-\n-    let mut configs = Vec::new();\n-    if let Mode::DebugInfo = config.mode {\n-        // Debugging emscripten code doesn't make sense today\n-        if !config.target.contains(\"emscripten\") {\n-            configs.extend(configure_cdb(&config));\n-            configs.extend(configure_gdb(&config));\n-            configs.extend(configure_lldb(&config));\n-        }\n-    } else {\n-        configs.push(config.clone());\n-    };\n-\n-    let mut tests = Vec::new();\n-    for c in configs {\n-        let mut found_paths = BTreeSet::new();\n-        make_tests(c, &mut tests, &mut found_paths);\n-        check_overlapping_tests(&found_paths);\n-    }\n-\n-    tests.sort_by(|a, b| a.desc.name.as_slice().cmp(&b.desc.name.as_slice()));\n-\n-    let res = test::run_tests_console(&opts, tests);\n-    match res {\n-        Ok(true) => {}\n-        Ok(false) => {\n-            // We want to report that the tests failed, but we also want to give\n-            // some indication of just what tests we were running. Especially on\n-            // CI, where there can be cross-compiled tests for a lot of\n-            // architectures, without this critical information it can be quite\n-            // easy to miss which tests failed, and as such fail to reproduce\n-            // the failure locally.\n-\n-            println!(\n-                \"Some tests failed in compiletest suite={}{} mode={} host={} target={}\",\n-                config.suite,\n-                config\n-                    .compare_mode\n-                    .as_ref()\n-                    .map(|c| format!(\" compare_mode={:?}\", c))\n-                    .unwrap_or_default(),\n-                config.mode,\n-                config.host,\n-                config.target\n-            );\n-\n-            std::process::exit(1);\n-        }\n-        Err(e) => {\n-            // We don't know if tests passed or not, but if there was an error\n-            // during testing we don't want to just succeed (we may not have\n-            // tested something), so fail.\n-            //\n-            // This should realistically \"never\" happen, so don't try to make\n-            // this a pretty error message.\n-            panic!(\"I/O failure during tests: {:?}\", e);\n-        }\n-    }\n-}\n-\n-fn configure_cdb(config: &Config) -> Option<Arc<Config>> {\n-    config.cdb.as_ref()?;\n-\n-    Some(Arc::new(Config { debugger: Some(Debugger::Cdb), ..config.clone() }))\n-}\n-\n-fn configure_gdb(config: &Config) -> Option<Arc<Config>> {\n-    config.gdb_version?;\n-\n-    if config.matches_env(\"msvc\") {\n-        return None;\n-    }\n-\n-    if config.remote_test_client.is_some() && !config.target.contains(\"android\") {\n-        println!(\n-            \"WARNING: debuginfo tests are not available when \\\n-             testing with remote\"\n-        );\n-        return None;\n-    }\n-\n-    if config.target.contains(\"android\") {\n-        println!(\n-            \"{} debug-info test uses tcp 5039 port.\\\n-             please reserve it\",\n-            config.target\n-        );\n-\n-        // android debug-info test uses remote debugger so, we test 1 thread\n-        // at once as they're all sharing the same TCP port to communicate\n-        // over.\n-        //\n-        // we should figure out how to lift this restriction! (run them all\n-        // on different ports allocated dynamically).\n-        env::set_var(\"RUST_TEST_THREADS\", \"1\");\n-    }\n-\n-    Some(Arc::new(Config { debugger: Some(Debugger::Gdb), ..config.clone() }))\n-}\n-\n-fn configure_lldb(config: &Config) -> Option<Arc<Config>> {\n-    config.lldb_python_dir.as_ref()?;\n-\n-    if let Some(350) = config.lldb_version {\n-        println!(\n-            \"WARNING: The used version of LLDB (350) has a \\\n-             known issue that breaks debuginfo tests. See \\\n-             issue #32520 for more information. Skipping all \\\n-             LLDB-based tests!\",\n-        );\n-        return None;\n-    }\n-\n-    Some(Arc::new(Config { debugger: Some(Debugger::Lldb), ..config.clone() }))\n-}\n-\n-pub fn test_opts(config: &Config) -> test::TestOpts {\n-    if env::var(\"RUST_TEST_NOCAPTURE\").is_ok() {\n-        eprintln!(\n-            \"WARNING: RUST_TEST_NOCAPTURE is no longer used. \\\n-                   Use the `--nocapture` flag instead.\"\n-        );\n-    }\n-\n-    test::TestOpts {\n-        exclude_should_panic: false,\n-        filters: config.filters.clone(),\n-        filter_exact: config.filter_exact,\n-        run_ignored: if config.run_ignored { test::RunIgnored::Yes } else { test::RunIgnored::No },\n-        format: config.format,\n-        logfile: config.logfile.clone(),\n-        run_tests: true,\n-        bench_benchmarks: true,\n-        nocapture: config.nocapture,\n-        color: config.color,\n-        shuffle: false,\n-        shuffle_seed: None,\n-        test_threads: None,\n-        skip: config.skip.clone(),\n-        list: false,\n-        options: test::Options::new(),\n-        time_options: None,\n-        force_run_in_process: false,\n-        fail_fast: std::env::var_os(\"RUSTC_TEST_FAIL_FAST\").is_some(),\n-    }\n-}\n-\n-pub fn make_tests(\n-    config: Arc<Config>,\n-    tests: &mut Vec<test::TestDescAndFn>,\n-    found_paths: &mut BTreeSet<PathBuf>,\n-) {\n-    debug!(\"making tests from {:?}\", config.src_base.display());\n-    let inputs = common_inputs_stamp(&config);\n-    let modified_tests = modified_tests(&config, &config.src_base).unwrap_or_else(|err| {\n-        panic!(\"modified_tests got error from dir: {}, error: {}\", config.src_base.display(), err)\n-    });\n-\n-    let cache = HeadersCache::load(&config);\n-    let mut poisoned = false;\n-    collect_tests_from_dir(\n-        config.clone(),\n-        &cache,\n-        &config.src_base,\n-        &PathBuf::new(),\n-        &inputs,\n-        tests,\n-        found_paths,\n-        &modified_tests,\n-        &mut poisoned,\n-    )\n-    .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n-\n-    if poisoned {\n-        eprintln!();\n-        panic!(\"there are errors in tests\");\n-    }\n-}\n-\n-/// Returns a stamp constructed from input files common to all test cases.\n-fn common_inputs_stamp(config: &Config) -> Stamp {\n-    let rust_src_dir = config.find_rust_src_root().expect(\"Could not find Rust source root\");\n-\n-    let mut stamp = Stamp::from_path(&config.rustc_path);\n-\n-    // Relevant pretty printer files\n-    let pretty_printer_files = [\n-        \"src/etc/rust_types.py\",\n-        \"src/etc/gdb_load_rust_pretty_printers.py\",\n-        \"src/etc/gdb_lookup.py\",\n-        \"src/etc/gdb_providers.py\",\n-        \"src/etc/lldb_batchmode.py\",\n-        \"src/etc/lldb_lookup.py\",\n-        \"src/etc/lldb_providers.py\",\n-    ];\n-    for file in &pretty_printer_files {\n-        let path = rust_src_dir.join(file);\n-        stamp.add_path(&path);\n-    }\n-\n-    stamp.add_dir(&rust_src_dir.join(\"src/etc/natvis\"));\n-\n-    stamp.add_dir(&config.run_lib_path);\n-\n-    if let Some(ref rustdoc_path) = config.rustdoc_path {\n-        stamp.add_path(&rustdoc_path);\n-        stamp.add_path(&rust_src_dir.join(\"src/etc/htmldocck.py\"));\n-    }\n-\n-    // Compiletest itself.\n-    stamp.add_dir(&rust_src_dir.join(\"src/tools/compiletest/\"));\n-\n-    stamp\n-}\n-\n-fn modified_tests(config: &Config, dir: &Path) -> Result<Vec<PathBuf>, String> {\n-    if !config.only_modified {\n-        return Ok(vec![]);\n-    }\n-    let files =\n-        get_git_modified_files(Some(dir), &vec![\"rs\", \"stderr\", \"fixed\"])?.unwrap_or(vec![]);\n-    // Add new test cases to the list, it will be convenient in daily development.\n-    let untracked_files = get_git_untracked_files(None)?.unwrap_or(vec![]);\n-\n-    let all_paths = [&files[..], &untracked_files[..]].concat();\n-    let full_paths = {\n-        let mut full_paths: Vec<PathBuf> = all_paths\n-            .into_iter()\n-            .map(|f| PathBuf::from(f).with_extension(\"\").with_extension(\"rs\"))\n-            .filter_map(|f| if Path::new(&f).exists() { f.canonicalize().ok() } else { None })\n-            .collect();\n-        full_paths.dedup();\n-        full_paths.sort_unstable();\n-        full_paths\n-    };\n-    Ok(full_paths)\n-}\n-\n-fn collect_tests_from_dir(\n-    config: Arc<Config>,\n-    cache: &HeadersCache,\n-    dir: &Path,\n-    relative_dir_path: &Path,\n-    inputs: &Stamp,\n-    tests: &mut Vec<test::TestDescAndFn>,\n-    found_paths: &mut BTreeSet<PathBuf>,\n-    modified_tests: &Vec<PathBuf>,\n-    poisoned: &mut bool,\n-) -> io::Result<()> {\n-    // Ignore directories that contain a file named `compiletest-ignore-dir`.\n-    if dir.join(\"compiletest-ignore-dir\").exists() {\n-        return Ok(());\n-    }\n-\n-    if config.mode == Mode::RunMake && dir.join(\"Makefile\").exists() {\n-        let paths = TestPaths {\n-            file: dir.to_path_buf(),\n-            relative_dir: relative_dir_path.parent().unwrap().to_path_buf(),\n-        };\n-        tests.extend(make_test(config, cache, &paths, inputs, poisoned));\n-        return Ok(());\n-    }\n-\n-    // If we find a test foo/bar.rs, we have to build the\n-    // output directory `$build/foo` so we can write\n-    // `$build/foo/bar` into it. We do this *now* in this\n-    // sequential loop because otherwise, if we do it in the\n-    // tests themselves, they race for the privilege of\n-    // creating the directories and sometimes fail randomly.\n-    let build_dir = output_relative_path(&config, relative_dir_path);\n-    fs::create_dir_all(&build_dir).unwrap();\n-\n-    // Add each `.rs` file as a test, and recurse further on any\n-    // subdirectories we find, except for `aux` directories.\n-    for file in fs::read_dir(dir)? {\n-        let file = file?;\n-        let file_path = file.path();\n-        let file_name = file.file_name();\n-        if is_test(&file_name) && (!config.only_modified || modified_tests.contains(&file_path)) {\n-            debug!(\"found test file: {:?}\", file_path.display());\n-            let rel_test_path = relative_dir_path.join(file_path.file_stem().unwrap());\n-            found_paths.insert(rel_test_path);\n-            let paths =\n-                TestPaths { file: file_path, relative_dir: relative_dir_path.to_path_buf() };\n-\n-            tests.extend(make_test(config.clone(), cache, &paths, inputs, poisoned))\n-        } else if file_path.is_dir() {\n-            let relative_file_path = relative_dir_path.join(file.file_name());\n-            if &file_name != \"auxiliary\" {\n-                debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(\n-                    config.clone(),\n-                    cache,\n-                    &file_path,\n-                    &relative_file_path,\n-                    inputs,\n-                    tests,\n-                    found_paths,\n-                    modified_tests,\n-                    poisoned,\n-                )?;\n-            }\n-        } else {\n-            debug!(\"found other file/directory: {:?}\", file_path.display());\n-        }\n-    }\n-    Ok(())\n-}\n-\n-/// Returns true if `file_name` looks like a proper test file name.\n-pub fn is_test(file_name: &OsString) -> bool {\n-    let file_name = file_name.to_str().unwrap();\n-\n-    if !file_name.ends_with(\".rs\") {\n-        return false;\n-    }\n-\n-    // `.`, `#`, and `~` are common temp-file prefixes.\n-    let invalid_prefixes = &[\".\", \"#\", \"~\"];\n-    !invalid_prefixes.iter().any(|p| file_name.starts_with(p))\n-}\n-\n-fn make_test(\n-    config: Arc<Config>,\n-    cache: &HeadersCache,\n-    testpaths: &TestPaths,\n-    inputs: &Stamp,\n-    poisoned: &mut bool,\n-) -> Vec<test::TestDescAndFn> {\n-    let test_path = if config.mode == Mode::RunMake {\n-        // Parse directives in the Makefile\n-        testpaths.file.join(\"Makefile\")\n-    } else {\n-        PathBuf::from(&testpaths.file)\n-    };\n-    let early_props = EarlyProps::from_file(&config, &test_path);\n-\n-    // Incremental tests are special, they inherently cannot be run in parallel.\n-    // `runtest::run` will be responsible for iterating over revisions.\n-    let revisions = if early_props.revisions.is_empty() || config.mode == Mode::Incremental {\n-        vec![None]\n-    } else {\n-        early_props.revisions.iter().map(Some).collect()\n-    };\n-\n-    revisions\n-        .into_iter()\n-        .map(|revision| {\n-            let src_file =\n-                std::fs::File::open(&test_path).expect(\"open test file to parse ignores\");\n-            let cfg = revision.map(|v| &**v);\n-            let test_name = crate::make_test_name(&config, testpaths, revision);\n-            let mut desc = make_test_description(\n-                &config, cache, test_name, &test_path, src_file, cfg, poisoned,\n-            );\n-            // Ignore tests that already run and are up to date with respect to inputs.\n-            if !config.force_rerun {\n-                desc.ignore |= is_up_to_date(\n-                    &config,\n-                    testpaths,\n-                    &early_props,\n-                    revision.map(|s| s.as_str()),\n-                    inputs,\n-                );\n-            }\n-            test::TestDescAndFn {\n-                desc,\n-                testfn: make_test_closure(config.clone(), testpaths, revision),\n-            }\n-        })\n-        .collect()\n-}\n-\n-fn stamp(config: &Config, testpaths: &TestPaths, revision: Option<&str>) -> PathBuf {\n-    output_base_dir(config, testpaths, revision).join(\"stamp\")\n-}\n-\n-fn files_related_to_test(\n-    config: &Config,\n-    testpaths: &TestPaths,\n-    props: &EarlyProps,\n-    revision: Option<&str>,\n-) -> Vec<PathBuf> {\n-    let mut related = vec![];\n-\n-    if testpaths.file.is_dir() {\n-        // run-make tests use their individual directory\n-        for entry in WalkDir::new(&testpaths.file) {\n-            let path = entry.unwrap().into_path();\n-            if path.is_file() {\n-                related.push(path);\n-            }\n-        }\n-    } else {\n-        related.push(testpaths.file.clone());\n-    }\n-\n-    for aux in &props.aux {\n-        let path = testpaths.file.parent().unwrap().join(\"auxiliary\").join(aux);\n-        related.push(path);\n-    }\n-\n-    // UI test files.\n-    for extension in UI_EXTENSIONS {\n-        let path = expected_output_path(testpaths, revision, &config.compare_mode, extension);\n-        related.push(path);\n-    }\n-\n-    related\n-}\n-\n-fn is_up_to_date(\n-    config: &Config,\n-    testpaths: &TestPaths,\n-    props: &EarlyProps,\n-    revision: Option<&str>,\n-    inputs: &Stamp,\n-) -> bool {\n-    let stamp_name = stamp(config, testpaths, revision);\n-    // Check hash.\n-    let contents = match fs::read_to_string(&stamp_name) {\n-        Ok(f) => f,\n-        Err(ref e) if e.kind() == ErrorKind::InvalidData => panic!(\"Can't read stamp contents\"),\n-        Err(_) => return false,\n-    };\n-    let expected_hash = runtest::compute_stamp_hash(config);\n-    if contents != expected_hash {\n-        return false;\n-    }\n-\n-    // Check timestamps.\n-    let mut inputs = inputs.clone();\n-    for path in files_related_to_test(config, testpaths, props, revision) {\n-        inputs.add_path(&path);\n-    }\n-\n-    inputs < Stamp::from_path(&stamp_name)\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-struct Stamp {\n-    time: SystemTime,\n-}\n-\n-impl Stamp {\n-    fn from_path(path: &Path) -> Self {\n-        let mut stamp = Stamp { time: SystemTime::UNIX_EPOCH };\n-        stamp.add_path(path);\n-        stamp\n-    }\n-\n-    fn add_path(&mut self, path: &Path) {\n-        let modified = fs::metadata(path)\n-            .and_then(|metadata| metadata.modified())\n-            .unwrap_or(SystemTime::UNIX_EPOCH);\n-        self.time = self.time.max(modified);\n-    }\n-\n-    fn add_dir(&mut self, path: &Path) {\n-        for entry in WalkDir::new(path) {\n-            let entry = entry.unwrap();\n-            if entry.file_type().is_file() {\n-                let modified = entry\n-                    .metadata()\n-                    .ok()\n-                    .and_then(|metadata| metadata.modified().ok())\n-                    .unwrap_or(SystemTime::UNIX_EPOCH);\n-                self.time = self.time.max(modified);\n-            }\n-        }\n-    }\n-}\n-\n-fn make_test_name(\n-    config: &Config,\n-    testpaths: &TestPaths,\n-    revision: Option<&String>,\n-) -> test::TestName {\n-    // Print the name of the file, relative to the repository root.\n-    // `src_base` looks like `/path/to/rust/tests/ui`\n-    let root_directory = config.src_base.parent().unwrap().parent().unwrap();\n-    let path = testpaths.file.strip_prefix(root_directory).unwrap();\n-    let debugger = match config.debugger {\n-        Some(d) => format!(\"-{}\", d),\n-        None => String::new(),\n-    };\n-    let mode_suffix = match config.compare_mode {\n-        Some(ref mode) => format!(\" ({})\", mode.to_str()),\n-        None => String::new(),\n-    };\n-\n-    test::DynTestName(format!(\n-        \"[{}{}{}] {}{}\",\n-        config.mode,\n-        debugger,\n-        mode_suffix,\n-        path.display(),\n-        revision.map_or(\"\".to_string(), |rev| format!(\"#{}\", rev))\n-    ))\n-}\n-\n-fn make_test_closure(\n-    config: Arc<Config>,\n-    testpaths: &TestPaths,\n-    revision: Option<&String>,\n-) -> test::TestFn {\n-    let config = config.clone();\n-    let testpaths = testpaths.clone();\n-    let revision = revision.cloned();\n-    test::DynTestFn(Box::new(move || {\n-        runtest::run(config, &testpaths, revision.as_deref());\n-        Ok(())\n-    }))\n-}\n-\n-/// Returns `true` if the given target is an Android target for the\n-/// purposes of GDB testing.\n-fn is_android_gdb_target(target: &str) -> bool {\n-    matches!(\n-        &target[..],\n-        \"arm-linux-androideabi\" | \"armv7-linux-androideabi\" | \"aarch64-linux-android\"\n-    )\n-}\n-\n-/// Returns `true` if the given target is a MSVC target for the purpouses of CDB testing.\n-fn is_pc_windows_msvc_target(target: &str) -> bool {\n-    target.ends_with(\"-pc-windows-msvc\")\n-}\n-\n-fn find_cdb(target: &str) -> Option<OsString> {\n-    if !(cfg!(windows) && is_pc_windows_msvc_target(target)) {\n-        return None;\n-    }\n-\n-    let pf86 = env::var_os(\"ProgramFiles(x86)\").or_else(|| env::var_os(\"ProgramFiles\"))?;\n-    let cdb_arch = if cfg!(target_arch = \"x86\") {\n-        \"x86\"\n-    } else if cfg!(target_arch = \"x86_64\") {\n-        \"x64\"\n-    } else if cfg!(target_arch = \"aarch64\") {\n-        \"arm64\"\n-    } else if cfg!(target_arch = \"arm\") {\n-        \"arm\"\n-    } else {\n-        return None; // No compatible CDB.exe in the Windows 10 SDK\n-    };\n-\n-    let mut path = PathBuf::new();\n-    path.push(pf86);\n-    path.push(r\"Windows Kits\\10\\Debuggers\"); // We could check 8.1 etc. too?\n-    path.push(cdb_arch);\n-    path.push(r\"cdb.exe\");\n-\n-    if !path.exists() {\n-        return None;\n-    }\n-\n-    Some(path.into_os_string())\n-}\n-\n-/// Returns Path to CDB\n-fn analyze_cdb(cdb: Option<String>, target: &str) -> (Option<OsString>, Option<[u16; 4]>) {\n-    let cdb = cdb.map(OsString::from).or_else(|| find_cdb(target));\n-\n-    let mut version = None;\n-    if let Some(cdb) = cdb.as_ref() {\n-        if let Ok(output) = Command::new(cdb).arg(\"/version\").output() {\n-            if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n-                version = extract_cdb_version(&first_line);\n-            }\n-        }\n-    }\n-\n-    (cdb, version)\n-}\n-\n-fn extract_cdb_version(full_version_line: &str) -> Option<[u16; 4]> {\n-    // Example full_version_line: \"cdb version 10.0.18362.1\"\n-    let version = full_version_line.rsplit(' ').next()?;\n-    let mut components = version.split('.');\n-    let major: u16 = components.next().unwrap().parse().unwrap();\n-    let minor: u16 = components.next().unwrap().parse().unwrap();\n-    let patch: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n-    let build: u16 = components.next().unwrap_or(\"0\").parse().unwrap();\n-    Some([major, minor, patch, build])\n-}\n-\n-/// Returns (Path to GDB, GDB Version, GDB has Rust Support)\n-fn analyze_gdb(\n-    gdb: Option<String>,\n-    target: &str,\n-    android_cross_path: &PathBuf,\n-) -> (Option<String>, Option<u32>, bool) {\n-    #[cfg(not(windows))]\n-    const GDB_FALLBACK: &str = \"gdb\";\n-    #[cfg(windows)]\n-    const GDB_FALLBACK: &str = \"gdb.exe\";\n-\n-    const MIN_GDB_WITH_RUST: u32 = 7011010;\n-\n-    let fallback_gdb = || {\n-        if is_android_gdb_target(target) {\n-            let mut gdb_path = match android_cross_path.to_str() {\n-                Some(x) => x.to_owned(),\n-                None => panic!(\"cannot find android cross path\"),\n-            };\n-            gdb_path.push_str(\"/bin/gdb\");\n-            gdb_path\n-        } else {\n-            GDB_FALLBACK.to_owned()\n-        }\n-    };\n-\n-    let gdb = match gdb {\n-        None => fallback_gdb(),\n-        Some(ref s) if s.is_empty() => fallback_gdb(), // may be empty if configure found no gdb\n-        Some(ref s) => s.to_owned(),\n-    };\n-\n-    let mut version_line = None;\n-    if let Ok(output) = Command::new(&gdb).arg(\"--version\").output() {\n-        if let Some(first_line) = String::from_utf8_lossy(&output.stdout).lines().next() {\n-            version_line = Some(first_line.to_string());\n-        }\n-    }\n-\n-    let version = match version_line {\n-        Some(line) => extract_gdb_version(&line),\n-        None => return (None, None, false),\n-    };\n-\n-    let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n-\n-    (Some(gdb), version, gdb_native_rust)\n-}\n-\n-fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n-    let full_version_line = full_version_line.trim();\n-\n-    // GDB versions look like this: \"major.minor.patch?.yyyymmdd?\", with both\n-    // of the ? sections being optional\n-\n-    // We will parse up to 3 digits for each component, ignoring the date\n-\n-    // We skip text in parentheses.  This avoids accidentally parsing\n-    // the openSUSE version, which looks like:\n-    //  GNU gdb (GDB; openSUSE Leap 15.0) 8.1\n-    // This particular form is documented in the GNU coding standards:\n-    // https://www.gnu.org/prep/standards/html_node/_002d_002dversion.html#g_t_002d_002dversion\n-\n-    let unbracketed_part = full_version_line.split('[').next().unwrap();\n-    let mut splits = unbracketed_part.trim_end().rsplit(' ');\n-    let version_string = splits.next().unwrap();\n-\n-    let mut splits = version_string.split('.');\n-    let major = splits.next().unwrap();\n-    let minor = splits.next().unwrap();\n-    let patch = splits.next();\n-\n-    let major: u32 = major.parse().unwrap();\n-    let (minor, patch): (u32, u32) = match minor.find(not_a_digit) {\n-        None => {\n-            let minor = minor.parse().unwrap();\n-            let patch: u32 = match patch {\n-                Some(patch) => match patch.find(not_a_digit) {\n-                    None => patch.parse().unwrap(),\n-                    Some(idx) if idx > 3 => 0,\n-                    Some(idx) => patch[..idx].parse().unwrap(),\n-                },\n-                None => 0,\n-            };\n-            (minor, patch)\n-        }\n-        // There is no patch version after minor-date (e.g. \"4-2012\").\n-        Some(idx) => {\n-            let minor = minor[..idx].parse().unwrap();\n-            (minor, 0)\n-        }\n-    };\n-\n-    Some(((major * 1000) + minor) * 1000 + patch)\n-}\n-\n-/// Returns (LLDB version, LLDB is rust-enabled)\n-fn extract_lldb_version(full_version_line: &str) -> Option<(u32, bool)> {\n-    // Extract the major LLDB version from the given version string.\n-    // LLDB version strings are different for Apple and non-Apple platforms.\n-    // The Apple variant looks like this:\n-    //\n-    // LLDB-179.5 (older versions)\n-    // lldb-300.2.51 (new versions)\n-    //\n-    // We are only interested in the major version number, so this function\n-    // will return `Some(179)` and `Some(300)` respectively.\n-    //\n-    // Upstream versions look like:\n-    // lldb version 6.0.1\n-    //\n-    // There doesn't seem to be a way to correlate the Apple version\n-    // with the upstream version, and since the tests were originally\n-    // written against Apple versions, we make a fake Apple version by\n-    // multiplying the first number by 100.  This is a hack, but\n-    // normally fine because the only non-Apple version we test is\n-    // rust-enabled.\n-\n-    let full_version_line = full_version_line.trim();\n-\n-    if let Some(apple_ver) =\n-        full_version_line.strip_prefix(\"LLDB-\").or_else(|| full_version_line.strip_prefix(\"lldb-\"))\n-    {\n-        if let Some(idx) = apple_ver.find(not_a_digit) {\n-            let version: u32 = apple_ver[..idx].parse().unwrap();\n-            return Some((version, full_version_line.contains(\"rust-enabled\")));\n-        }\n-    } else if let Some(lldb_ver) = full_version_line.strip_prefix(\"lldb version \") {\n-        if let Some(idx) = lldb_ver.find(not_a_digit) {\n-            let version: u32 = lldb_ver[..idx].parse().ok()?;\n-            return Some((version * 100, full_version_line.contains(\"rust-enabled\")));\n-        }\n-    }\n-    None\n-}\n-\n-fn not_a_digit(c: char) -> bool {\n-    !c.is_digit(10)\n-}\n-\n-fn check_overlapping_tests(found_paths: &BTreeSet<PathBuf>) {\n-    let mut collisions = Vec::new();\n-    for path in found_paths {\n-        for ancestor in path.ancestors().skip(1) {\n-            if found_paths.contains(ancestor) {\n-                collisions.push((path, ancestor.clone()));\n-            }\n-        }\n-    }\n-    if !collisions.is_empty() {\n-        let collisions: String = collisions\n-            .into_iter()\n-            .map(|(path, check_parent)| format!(\"test {path:?} clashes with {check_parent:?}\\n\"))\n-            .collect();\n-        panic!(\n-            \"{collisions}\\n\\\n-            Tests cannot have overlapping names. Make sure they use unique prefixes.\"\n-        );\n-    }\n-}"}]}