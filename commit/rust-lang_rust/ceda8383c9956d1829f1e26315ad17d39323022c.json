{"sha": "ceda8383c9956d1829f1e26315ad17d39323022c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZGE4MzgzYzk5NTZkMTgyOWYxZTI2MzE1YWQxN2QzOTMyMzAyMmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-16T02:10:09Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2015-11-16T02:10:09Z"}, "message": "Replace `TypeNsDef` and `ValueNsDef` with a more general type `NsDef`.\n\nDefine a newtype `NameBinding` for `Rc<RefCell<Option<NsDef>>>` and refactor `NameBindings` to be a `NameBinding` for each namespace.\n\nReplace uses of `NameBindings` with `NameBinding` where only one binding is being used (in `NamespaceResult`, `Target,` etc).\n\nRefactor away `resolve_definition_of_name_in_module` and `NameDefinition`.", "tree": {"sha": "5959f304d95f31ac9ea6cc937f4d9de0adfa072a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5959f304d95f31ac9ea6cc937f4d9de0adfa072a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceda8383c9956d1829f1e26315ad17d39323022c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceda8383c9956d1829f1e26315ad17d39323022c", "html_url": "https://github.com/rust-lang/rust/commit/ceda8383c9956d1829f1e26315ad17d39323022c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceda8383c9956d1829f1e26315ad17d39323022c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7845f93b54d3e45fcac94e7d7f3111aad90142f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7845f93b54d3e45fcac94e7d7f3111aad90142f", "html_url": "https://github.com/rust-lang/rust/commit/b7845f93b54d3e45fcac94e7d7f3111aad90142f"}], "stats": {"total": 714, "additions": 236, "deletions": 478}, "files": [{"sha": "802f9a0d40f80f544346987e50c03f30ed52d612", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ceda8383c9956d1829f1e26315ad17d39323022c", "patch": "@@ -25,7 +25,6 @@ use {names_to_string, module_to_string};\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n-use TypeNsDef;\n use {resolve_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n@@ -130,7 +129,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: Span)\n-                 -> Rc<NameBindings> {\n+                 -> NameBindings {\n         // If this is the immediate descendant of a module, then we add the\n         // child name directly. Otherwise, we create or reuse an anonymous\n         // module and add the child to that.\n@@ -141,7 +140,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let child = parent.children.borrow().get(&name).cloned();\n         match child {\n             None => {\n-                let child = Rc::new(NameBindings::new());\n+                let child = NameBindings::new();\n                 parent.children.borrow_mut().insert(name, child.clone());\n                 child\n             }\n@@ -173,27 +172,27 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                         Some(TypeNS)\n                     }\n                     ForbidDuplicateTypesAndModules => {\n-                        if child.defined_in_namespace(TypeNS) {\n+                        if child.type_ns.defined() {\n                             duplicate_type = TypeError;\n                         }\n                         Some(TypeNS)\n                     }\n                     ForbidDuplicateValues => {\n-                        if child.defined_in_namespace(ValueNS) {\n+                        if child.value_ns.defined() {\n                             duplicate_type = ValueError;\n                         }\n                         Some(ValueNS)\n                     }\n                     ForbidDuplicateTypesAndValues => {\n                         let mut n = None;\n-                        match child.def_for_namespace(TypeNS) {\n+                        match child.type_ns.def() {\n                             Some(DefMod(_)) | None => {}\n                             Some(_) => {\n                                 n = Some(TypeNS);\n                                 duplicate_type = TypeError;\n                             }\n                         }\n-                        if child.defined_in_namespace(ValueNS) {\n+                        if child.value_ns.defined() {\n                             duplicate_type = ValueError;\n                             n = Some(ValueNS);\n                         }\n@@ -213,7 +212,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             name)\n                     );\n                     {\n-                        let r = child.span_for_namespace(ns);\n+                        let r = child[ns].span();\n                         if let Some(sp) = r {\n                             self.session.span_note(sp,\n                                                    &format!(\"first definition of {} `{}` here\",\n@@ -415,7 +414,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let child = parent.children.borrow().get(&name).cloned();\n                 if let Some(child) = child {\n                     // check if there's struct of the same name already defined\n-                    if child.defined_in_namespace(TypeNS) &&\n+                    if child.type_ns.defined() &&\n                        child.get_module_if_available().is_none() {\n                         self.session.span_warn(sp,\n                                                &format!(\"duplicate definition of {} `{}`. \\\n@@ -424,7 +423,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                         namespace_error_to_string(TypeError),\n                                                         name));\n                         {\n-                            let r = child.span_for_namespace(TypeNS);\n+                            let r = child.type_ns.span();\n                             if let Some(sp) = r {\n                                 self.session.span_note(sp,\n                                                        &format!(\"first definition of {} `{}` here\",\n@@ -530,7 +529,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     let child = parent.children.borrow().get(&name).cloned();\n                     if let Some(child) = child {\n                         // check if theres a DefMod\n-                        if let Some(DefMod(_)) = child.def_for_namespace(TypeNS) {\n+                        if let Some(DefMod(_)) = child.type_ns.def() {\n                             self.session.span_warn(sp,\n                                                    &format!(\"duplicate definition of {} `{}`. \\\n                                                              Defining a module and a struct \\\n@@ -539,7 +538,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                             namespace_error_to_string(TypeError),\n                                                             name));\n                             {\n-                                let r = child.span_for_namespace(TypeNS);\n+                                let r = child.type_ns.span();\n                                 if let Some(sp) = r {\n                                     self.session\n                                         .span_note(sp,\n@@ -752,26 +751,21 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             DefForeignMod(def_id) |\n             DefStruct(def_id) |\n             DefTy(def_id, _) => {\n-                let type_def = child_name_bindings.type_def.borrow().clone();\n-                match type_def {\n-                    Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n-                        debug!(\"(building reduced graph for external crate) already created \\\n-                                module\");\n-                        module_def.def_id.set(Some(def_id));\n-                    }\n-                    Some(_) | None => {\n-                        debug!(\"(building reduced graph for external crate) building module {} {}\",\n-                               final_ident,\n-                               is_public);\n-                        let parent_link = self.get_parent_link(new_parent, name);\n-\n-                        child_name_bindings.define_module(parent_link,\n-                                                          Some(def_id),\n-                                                          kind,\n-                                                          true,\n-                                                          is_public,\n-                                                          DUMMY_SP);\n-                    }\n+                if let Some(module_def) = child_name_bindings.type_ns.module() {\n+                    debug!(\"(building reduced graph for external crate) already created module\");\n+                    module_def.def_id.set(Some(def_id));\n+                } else {\n+                    debug!(\"(building reduced graph for external crate) building module {} {}\",\n+                           final_ident,\n+                           is_public);\n+                    let parent_link = self.get_parent_link(new_parent, name);\n+\n+                    child_name_bindings.define_module(parent_link,\n+                                                      Some(def_id),\n+                                                      kind,\n+                                                      true,\n+                                                      is_public,\n+                                                      DUMMY_SP);\n                 }\n             }\n             _ => {}\n@@ -807,7 +801,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                        final_ident);\n                 // impl methods have already been defined with the correct importability\n                 // modifier\n-                let mut modifiers = match *child_name_bindings.value_def.borrow() {\n+                let mut modifiers = match *child_name_bindings.value_ns.borrow() {\n                     Some(ref def) => (modifiers & !DefModifiers::IMPORTABLE) |\n                                      (def.modifiers & DefModifiers::IMPORTABLE),\n                     None => modifiers,\n@@ -922,7 +916,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                         self.handle_external_def(def,\n                                                  def_visibility,\n-                                                 &*child_name_bindings,\n+                                                 &child_name_bindings,\n                                                  &name.as_str(),\n                                                  name,\n                                                  root);"}, {"sha": "3f6f66cad7a21ce814a4b2e3ac159b5647d6ba84", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 159, "deletions": 387, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ceda8383c9956d1829f1e26315ad17d39323022c", "patch": "@@ -39,7 +39,6 @@ extern crate rustc;\n use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::NamespaceResult::*;\n-use self::NameDefinition::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -513,8 +512,8 @@ enum NamespaceResult {\n     /// not bound in the namespace.\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n-    /// argument, and specified by the NameBindings argument.\n-    BoundResult(Rc<Module>, Rc<NameBindings>),\n+    /// argument, and specified by the NameBinding argument.\n+    BoundResult(Rc<Module>, NameBinding),\n }\n \n impl NamespaceResult {\n@@ -532,15 +531,6 @@ impl NamespaceResult {\n     }\n }\n \n-enum NameDefinition {\n-    // The name was unbound.\n-    NoNameDefinition,\n-    // The name identifies an immediate child.\n-    ChildNameDefinition(Def, LastPrivate),\n-    // The name identifies an import.\n-    ImportNameDefinition(Def, LastPrivate),\n-}\n-\n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         execute_callback!(hir_map::Node::NodeItem(item), self);\n@@ -786,7 +776,7 @@ pub struct Module {\n     kind: Cell<ModuleKind>,\n     is_public: bool,\n \n-    children: RefCell<HashMap<Name, Rc<NameBindings>>>,\n+    children: RefCell<HashMap<Name, NameBindings>>,\n     imports: RefCell<Vec<ImportDirective>>,\n \n     // The external module children of this node that were declared with\n@@ -911,36 +901,103 @@ bitflags! {\n     }\n }\n \n-// Records a possibly-private type definition.\n+// Records a possibly-private definition.\n #[derive(Clone,Debug)]\n-struct TypeNsDef {\n+struct NsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n-    module_def: Option<Rc<Module>>,\n-    type_def: Option<Def>,\n-    type_span: Option<Span>,\n+    def: Option<Def>,\n+    module: Option<Rc<Module>>,\n+    span: Option<Span>,\n }\n \n-// Records a possibly-private value definition.\n-#[derive(Clone, Copy, Debug)]\n-struct ValueNsDef {\n-    modifiers: DefModifiers, // see note in ImportResolution about how to use this\n-    def: Def,\n-    value_span: Option<Span>,\n+impl NsDef {\n+    fn def(&self) -> Option<Def> {\n+        match (self.def, &self.module) {\n+            (def @ Some(_), _) => def,\n+            (_, &Some(ref module)) => module.def_id.get().map(|def_id| DefMod(def_id)),\n+            _ => panic!(\"NsDef has neither a Def nor a Module\"),\n+        }\n+    }\n+}\n+\n+// Records at most one definition that a name in a namespace is bound to\n+#[derive(Clone,Debug)]\n+pub struct NameBinding(Rc<RefCell<Option<NsDef>>>);\n+\n+impl NameBinding {\n+    fn new() -> Self {\n+        NameBinding(Rc::new(RefCell::new(None)))\n+    }\n+\n+    fn create_from_module(module: Rc<Module>) -> Self {\n+        NameBinding(Rc::new(RefCell::new(Some(NsDef {\n+            modifiers: DefModifiers::IMPORTABLE,\n+            def: None,\n+            module: Some(module),\n+            span: None,\n+        }))))\n+    }\n+\n+    fn set(&self, modifiers: DefModifiers, def: Option<Def>, mod_: Option<Rc<Module>>, sp: Span) {\n+        *self.0.borrow_mut() =\n+            Some(NsDef { modifiers: modifiers, def: def, module: mod_, span: Some(sp) });\n+    }\n+\n+    fn and_then<T, F: Fn(&NsDef) -> Option<T>>(&self, f: F) -> Option<T> {\n+        self.borrow().as_ref().and_then(f)\n+    }\n+\n+    fn borrow(&self) -> ::std::cell::Ref<Option<NsDef>> { self.0.borrow() }\n+\n+    // Lifted versions of the NsDef fields and method\n+    fn def(&self) -> Option<Def>           { self.and_then(NsDef::def) }\n+    fn span(&self) -> Option<Span>         { self.and_then(|def| def.span) }\n+    fn module(&self) -> Option<Rc<Module>> { self.and_then(|def| def.module.clone()) }\n+    fn modifiers(&self) -> Option<DefModifiers> { self.and_then(|def| Some(def.modifiers)) }\n+\n+    fn defined(&self) -> bool { self.borrow().is_some() }\n+\n+    fn defined_with(&self, modifiers: DefModifiers) -> bool {\n+        self.modifiers().map(|m| m.contains(modifiers)).unwrap_or(false)\n+    }\n+\n+    fn is_public(&self) -> bool {\n+        self.defined_with(DefModifiers::PUBLIC)\n+    }\n+\n+    fn def_and_lp(&self) -> (Def, LastPrivate) {\n+        let def = self.def().unwrap();\n+        (def, LastMod(if self.is_public() { AllPublic } else { DependsOn(def.def_id()) }))\n+    }\n }\n \n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n-#[derive(Debug)]\n+#[derive(Clone,Debug)]\n pub struct NameBindings {\n-    type_def: RefCell<Option<TypeNsDef>>, // < Meaning in type namespace.\n-    value_def: RefCell<Option<ValueNsDef>>, // < Meaning in value namespace.\n+    type_ns: NameBinding, // < Meaning in type namespace.\n+    value_ns: NameBinding, // < Meaning in value namespace.\n+}\n+\n+impl ::std::ops::Index<Namespace> for NameBindings {\n+    type Output = NameBinding;\n+    fn index(&self, namespace: Namespace) -> &NameBinding {\n+        match namespace { TypeNS => &self.type_ns, ValueNS => &self.value_ns }\n+    }\n }\n \n impl NameBindings {\n     fn new() -> NameBindings {\n         NameBindings {\n-            type_def: RefCell::new(None),\n-            value_def: RefCell::new(None),\n+            type_ns: NameBinding::new(),\n+            value_ns: NameBinding::new(),\n+        }\n+    }\n+\n+    fn create_from_module(module: Rc<Module>) -> NameBindings {\n+        NameBindings {\n+            type_ns: NameBinding::create_from_module(module),\n+            value_ns: NameBinding::new(),\n         }\n     }\n \n@@ -958,26 +1015,9 @@ impl NameBindings {\n         } else {\n             DefModifiers::empty()\n         } | DefModifiers::IMPORTABLE;\n+\n         let module_ = Rc::new(Module::new(parent_link, def_id, kind, external, is_public));\n-        let type_def = self.type_def.borrow().clone();\n-        match type_def {\n-            None => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    modifiers: modifiers,\n-                    module_def: Some(module_),\n-                    type_def: None,\n-                    type_span: Some(sp),\n-                });\n-            }\n-            Some(type_def) => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    modifiers: modifiers,\n-                    module_def: Some(module_),\n-                    type_span: Some(sp),\n-                    type_def: type_def.type_def,\n-                });\n-            }\n-        }\n+        self.type_ns.set(modifiers, self.type_ns.def(), Some(module_), sp);\n     }\n \n     /// Sets the kind of the module, creating a new one if necessary.\n@@ -988,36 +1028,10 @@ impl NameBindings {\n                        external: bool,\n                        is_public: bool,\n                        _sp: Span) {\n-        let modifiers = if is_public {\n-            DefModifiers::PUBLIC\n+        if let Some(module) = self.type_ns.module() {\n+            module.kind.set(kind)\n         } else {\n-            DefModifiers::empty()\n-        } | DefModifiers::IMPORTABLE;\n-        let type_def = self.type_def.borrow().clone();\n-        match type_def {\n-            None => {\n-                let module = Module::new(parent_link, def_id, kind, external, is_public);\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    modifiers: modifiers,\n-                    module_def: Some(Rc::new(module)),\n-                    type_def: None,\n-                    type_span: None,\n-                });\n-            }\n-            Some(type_def) => {\n-                match type_def.module_def {\n-                    None => {\n-                        let module = Module::new(parent_link, def_id, kind, external, is_public);\n-                        *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                            modifiers: modifiers,\n-                            module_def: Some(Rc::new(module)),\n-                            type_def: type_def.type_def,\n-                            type_span: None,\n-                        });\n-                    }\n-                    Some(module_def) => module_def.kind.set(kind),\n-                }\n-            }\n+            self.define_module(parent_link, def_id, kind, external, is_public, _sp)\n         }\n     }\n \n@@ -1027,46 +1041,17 @@ impl NameBindings {\n                def,\n                modifiers);\n         // Merges the type with the existing type def or creates a new one.\n-        let type_def = self.type_def.borrow().clone();\n-        match type_def {\n-            None => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    module_def: None,\n-                    type_def: Some(def),\n-                    type_span: Some(sp),\n-                    modifiers: modifiers,\n-                });\n-            }\n-            Some(type_def) => {\n-                *self.type_def.borrow_mut() = Some(TypeNsDef {\n-                    module_def: type_def.module_def,\n-                    type_def: Some(def),\n-                    type_span: Some(sp),\n-                    modifiers: modifiers,\n-                });\n-            }\n-        }\n+        self.type_ns.set(modifiers, Some(def), self.type_ns.module(), sp);\n     }\n \n     /// Records a value definition.\n     fn define_value(&self, def: Def, sp: Span, modifiers: DefModifiers) {\n-        debug!(\"defining value for def {:?} with modifiers {:?}\",\n-               def,\n-               modifiers);\n-        *self.value_def.borrow_mut() = Some(ValueNsDef {\n-            def: def,\n-            value_span: Some(sp),\n-            modifiers: modifiers,\n-        });\n+        debug!(\"defining value for def {:?} with modifiers {:?}\", def, modifiers);\n+        self.value_ns.set(modifiers, Some(def), None, sp);\n     }\n \n     /// Returns the module node if applicable.\n-    fn get_module_if_available(&self) -> Option<Rc<Module>> {\n-        match *self.type_def.borrow() {\n-            Some(ref type_def) => type_def.module_def.clone(),\n-            None => None,\n-        }\n-    }\n+    fn get_module_if_available(&self) -> Option<Rc<Module>> { self.type_ns.module() }\n \n     /// Returns the module node. Panics if this node does not have a module\n     /// definition.\n@@ -1078,96 +1063,6 @@ impl NameBindings {\n             Some(module_def) => module_def,\n         }\n     }\n-\n-    fn defined_in_namespace(&self, namespace: Namespace) -> bool {\n-        match namespace {\n-            TypeNS => return self.type_def.borrow().is_some(),\n-            ValueNS => return self.value_def.borrow().is_some(),\n-        }\n-    }\n-\n-    fn defined_in_public_namespace(&self, namespace: Namespace) -> bool {\n-        self.defined_in_namespace_with(namespace, DefModifiers::PUBLIC)\n-    }\n-\n-    fn defined_in_namespace_with(&self, namespace: Namespace, modifiers: DefModifiers) -> bool {\n-        match namespace {\n-            TypeNS => match *self.type_def.borrow() {\n-                Some(ref def) => def.modifiers.contains(modifiers),\n-                None => false,\n-            },\n-            ValueNS => match *self.value_def.borrow() {\n-                Some(ref def) => def.modifiers.contains(modifiers),\n-                None => false,\n-            },\n-        }\n-    }\n-\n-    fn def_for_namespace(&self, namespace: Namespace) -> Option<Def> {\n-        match namespace {\n-            TypeNS => {\n-                match *self.type_def.borrow() {\n-                    None => None,\n-                    Some(ref type_def) => {\n-                        match type_def.type_def {\n-                            Some(type_def) => Some(type_def),\n-                            None => {\n-                                match type_def.module_def {\n-                                    Some(ref module) => {\n-                                        match module.def_id.get() {\n-                                            Some(did) => Some(DefMod(did)),\n-                                            None => None,\n-                                        }\n-                                    }\n-                                    None => None,\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            ValueNS => {\n-                match *self.value_def.borrow() {\n-                    None => None,\n-                    Some(value_def) => Some(value_def.def),\n-                }\n-            }\n-        }\n-    }\n-\n-    fn span_for_namespace(&self, namespace: Namespace) -> Option<Span> {\n-        if self.defined_in_namespace(namespace) {\n-            match namespace {\n-                TypeNS => {\n-                    match *self.type_def.borrow() {\n-                        None => None,\n-                        Some(ref type_def) => type_def.type_span,\n-                    }\n-                }\n-                ValueNS => {\n-                    match *self.value_def.borrow() {\n-                        None => None,\n-                        Some(ref value_def) => value_def.value_span,\n-                    }\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn is_public(&self, namespace: Namespace) -> bool {\n-        match namespace {\n-            TypeNS => {\n-                let type_def = self.type_def.borrow();\n-                type_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n-            }\n-            ValueNS => {\n-                let value_def = self.value_def.borrow();\n-                value_def.as_ref().unwrap().modifiers.contains(DefModifiers::PUBLIC)\n-            }\n-        }\n-    }\n }\n \n /// Interns the names of the primitive types.\n@@ -1356,18 +1251,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n-        NameBindings {\n-            type_def: RefCell::new(Some(TypeNsDef {\n-                modifiers: DefModifiers::IMPORTABLE,\n-                module_def: Some(module),\n-                type_def: None,\n-                type_span: None,\n-            })),\n-            value_def: RefCell::new(None),\n-        }\n-    }\n-\n     /// Checks that the names of external crates don't collide with other\n     /// external crates.\n     fn check_for_conflicts_between_external_crates(&self,\n@@ -1473,38 +1356,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Success((target, used_proxy)) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    match *target.bindings.type_def.borrow() {\n-                        Some(ref type_def) => {\n-                            match type_def.module_def {\n-                                None => {\n-                                    let msg = format!(\"Not a module `{}`\", name);\n+                    if let Some(module_def) = target.binding.module() {\n+                        // track extern crates for unused_extern_crate lint\n+                        if let Some(did) = module_def.def_id.get() {\n+                            self.used_crates.insert(did.krate);\n+                        }\n \n-                                    return Failed(Some((span, msg)));\n-                                }\n-                                Some(ref module_def) => {\n-                                    search_module = module_def.clone();\n+                        search_module = module_def;\n \n-                                    // track extern crates for unused_extern_crate lint\n-                                    if let Some(did) = module_def.def_id.get() {\n-                                        self.used_crates.insert(did.krate);\n-                                    }\n-\n-                                    // Keep track of the closest\n-                                    // private module used when\n-                                    // resolving this import chain.\n-                                    if !used_proxy && !search_module.is_public {\n-                                        if let Some(did) = search_module.def_id.get() {\n-                                            closest_private = LastMod(DependsOn(did));\n-                                        }\n-                                    }\n-                                }\n+                        // Keep track of the closest private module used\n+                        // when resolving this import chain.\n+                        if !used_proxy && !search_module.is_public {\n+                            if let Some(did) = search_module.def_id.get() {\n+                                closest_private = LastMod(DependsOn(did));\n                             }\n                         }\n-                        None => {\n-                            // There are no type bindings at all.\n-                            let msg = format!(\"Not a module `{}`\", name);\n-                            return Failed(Some((span, msg)));\n-                        }\n+                    } else {\n+                        let msg = format!(\"Not a module `{}`\", name);\n+                        return Failed(Some((span, msg)));\n                     }\n                 }\n             }\n@@ -1628,10 +1497,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n-            Some(name_bindings) if name_bindings.defined_in_namespace(namespace) => {\n+            Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"top name bindings succeeded\");\n                 return Success((Target::new(module_.clone(),\n-                                            name_bindings.clone(),\n+                                            name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n             }\n@@ -1671,9 +1540,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // FIXME (21114): In principle unclear `child` *has* to be lifted.\n             let child = module_.external_module_children.borrow().get(&name).cloned();\n             if let Some(module) = child {\n-                let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module));\n+                let name_binding = NameBinding::create_from_module(module);\n                 debug!(\"lower name bindings succeeded\");\n-                return Success((Target::new(module_, name_bindings, Shadowable::Never),\n+                return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -1745,26 +1614,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let resolve_result = self.resolve_item_in_lexical_scope(module_, name, TypeNS);\n         match resolve_result {\n             Success((target, _)) => {\n-                let bindings = &*target.bindings;\n-                match *bindings.type_def.borrow() {\n-                    Some(ref type_def) => {\n-                        match type_def.module_def {\n-                            None => {\n-                                debug!(\"!!! (resolving module in lexical scope) module wasn't \\\n-                                        actually a module!\");\n-                                return Failed(None);\n-                            }\n-                            Some(ref module_def) => {\n-                                return Success(module_def.clone());\n-                            }\n-                        }\n-                    }\n-                    None => {\n-                        debug!(\"!!! (resolving module in lexical scope) module\n-                                \\\n-                                wasn't actually a module!\");\n-                        return Failed(None);\n-                    }\n+                if let Some(module_def) = target.binding.module() {\n+                    return Success(module_def)\n+                } else {\n+                    debug!(\"!!! (resolving module in lexical scope) module \\\n+                            wasn't actually a module!\");\n+                    return Failed(None);\n                 }\n             }\n             Indeterminate => {\n@@ -1872,10 +1727,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n \n         match module_.children.borrow().get(&name) {\n-            Some(name_bindings) if name_bindings.defined_in_namespace(namespace) => {\n+            Some(name_bindings) if name_bindings[namespace].defined() => {\n                 debug!(\"(resolving name in module) found node as child\");\n                 return Success((Target::new(module_.clone(),\n-                                            name_bindings.clone(),\n+                                            name_bindings[namespace].clone(),\n                                             Shadowable::Never),\n                                 false));\n             }\n@@ -1926,8 +1781,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // FIXME (21114): In principle unclear `child` *has* to be lifted.\n             let child = module_.external_module_children.borrow().get(&name).cloned();\n             if let Some(module) = child {\n-                let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module));\n-                return Success((Target::new(module_, name_bindings, Shadowable::Never),\n+                let name_binding = NameBinding::create_from_module(module);\n+                return Success((Target::new(module_, name_binding, Shadowable::Never),\n                                 false));\n             }\n         }\n@@ -2958,32 +2813,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n-                       target.bindings.value_def.borrow());\n-                match *target.bindings.value_def.borrow() {\n+                       target.binding.borrow());\n+                match target.binding.def() {\n                     None => {\n                         panic!(\"resolved name in the value namespace to a set of name bindings \\\n                                 with no def?!\");\n                     }\n-                    Some(def) => {\n-                        // For the two success cases, this lookup can be\n-                        // considered as not having a private component because\n-                        // the lookup happened only within the current module.\n-                        match def.def {\n-                            def @ DefVariant(..) | def @ DefStruct(..) => {\n-                                return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n-                            }\n-                            def @ DefConst(..) | def @ DefAssociatedConst(..) => {\n-                                return FoundConst(def, LastMod(AllPublic), name);\n-                            }\n-                            DefStatic(..) => {\n-                                resolve_error(self, span, ResolutionError::StaticVariableReference);\n-                                return BareIdentifierPatternUnresolved;\n-                            }\n-                            _ => {\n-                                return BareIdentifierPatternUnresolved;\n-                            }\n-                        }\n+                    // For the two success cases, this lookup can be\n+                    // considered as not having a private component because\n+                    // the lookup happened only within the current module.\n+                    Some(def @ DefVariant(..)) | Some(def @ DefStruct(..)) => {\n+                        return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n+                    }\n+                    Some(def @ DefConst(..)) | Some(def @ DefAssociatedConst(..)) => {\n+                        return FoundConst(def, LastMod(AllPublic), name);\n+                    }\n+                    Some(DefStatic(..)) => {\n+                        resolve_error(self, span, ResolutionError::StaticVariableReference);\n+                        return BareIdentifierPatternUnresolved;\n                     }\n+                    _ => return BareIdentifierPatternUnresolved\n                 }\n             }\n \n@@ -3207,85 +3056,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         return Some(def);\n     }\n \n-    // FIXME #4952: Merge me with resolve_name_in_module?\n-    fn resolve_definition_of_name_in_module(&mut self,\n-                                            containing_module: Rc<Module>,\n-                                            name: Name,\n-                                            namespace: Namespace)\n-                                            -> NameDefinition {\n-        // First, search children.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n-\n-        match containing_module.children.borrow().get(&name) {\n-            Some(child_name_bindings) => {\n-                match child_name_bindings.def_for_namespace(namespace) {\n-                    Some(def) => {\n-                        // Found it. Stop the search here.\n-                        let p = child_name_bindings.defined_in_public_namespace(namespace);\n-                        let lp = if p {\n-                            LastMod(AllPublic)\n-                        } else {\n-                            LastMod(DependsOn(def.def_id()))\n-                        };\n-                        return ChildNameDefinition(def, lp);\n-                    }\n-                    None => {}\n-                }\n-            }\n-            None => {}\n-        }\n-\n-        // Next, search import resolutions.\n-        match containing_module.import_resolutions.borrow().get(&name) {\n-            Some(import_resolution) if import_resolution.is_public => {\n-                if let Some(target) = (*import_resolution).target_for_namespace(namespace) {\n-                    match target.bindings.def_for_namespace(namespace) {\n-                        Some(def) => {\n-                            // Found it.\n-                            let id = import_resolution.id(namespace);\n-                            // track imports and extern crates as well\n-                            self.used_imports.insert((id, namespace));\n-                            self.record_import_use(id, name);\n-                            match target.target_module.def_id.get() {\n-                                Some(DefId{krate: kid, ..}) => {\n-                                    self.used_crates.insert(kid);\n-                                }\n-                                _ => {}\n-                            }\n-                            return ImportNameDefinition(def, LastMod(AllPublic));\n-                        }\n-                        None => {\n-                            // This can happen with external impls, due to\n-                            // the imperfect way we read the metadata.\n-                        }\n-                    }\n-                }\n-            }\n-            Some(..) | None => {} // Continue.\n-        }\n-\n-        // Finally, search through external children.\n-        if namespace == TypeNS {\n-            if let Some(module) = containing_module.external_module_children\n-                                                   .borrow()\n-                                                   .get(&name)\n-                                                   .cloned() {\n-                if let Some(def_id) = module.def_id.get() {\n-                    // track used crates\n-                    self.used_crates.insert(def_id.krate);\n-                    let lp = if module.is_public {\n-                        LastMod(AllPublic)\n-                    } else {\n-                        LastMod(DependsOn(def_id))\n-                    };\n-                    return ChildNameDefinition(DefMod(def_id), lp);\n-                }\n-            }\n-        }\n-\n-        return NoNameDefinition;\n-    }\n-\n     // resolve a \"module-relative\" path, e.g. a::b::c\n     fn resolve_module_relative_path(&mut self,\n                                     span: Span,\n@@ -3328,16 +3098,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let def = match self.resolve_definition_of_name_in_module(containing_module.clone(),\n-                                                                  name,\n-                                                                  namespace) {\n-            NoNameDefinition => {\n-                // We failed to resolve the name. Report an error.\n-                return None;\n-            }\n-            ChildNameDefinition(def, lp) | ImportNameDefinition(def, lp) => {\n+        let def = match self.resolve_name_in_module(containing_module.clone(),\n+                                                    name,\n+                                                    namespace,\n+                                                    NameSearchType::PathSearch,\n+                                                    false) {\n+            Success((Target { binding, .. }, _)) => {\n+                let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n             }\n+            _ => return None,\n         };\n         if let Some(DefId{krate: kid, ..}) = containing_module.def_id.get() {\n             self.used_crates.insert(kid);\n@@ -3394,14 +3164,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        match self.resolve_definition_of_name_in_module(containing_module, name, namespace) {\n-            NoNameDefinition => {\n-                // We failed to resolve the name. Report an error.\n-                return None;\n-            }\n-            ChildNameDefinition(def, lp) | ImportNameDefinition(def, lp) => {\n-                return Some((def, last_private.or(lp)));\n+        match self.resolve_name_in_module(containing_module,\n+                                          name,\n+                                          namespace,\n+                                          NameSearchType::PathSearch,\n+                                          false) {\n+            Success((Target { binding, .. }, _)) => {\n+                let (def, lp) = binding.def_and_lp();\n+                Some((def, last_private.or(lp)))\n             }\n+            _ => None,\n         }\n     }\n \n@@ -3449,7 +3221,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module = self.current_module.clone();\n         match self.resolve_item_in_lexical_scope(module, name, namespace) {\n             Success((target, _)) => {\n-                match (*target.bindings).def_for_namespace(namespace) {\n+                match target.binding.def() {\n                     None => {\n                         // This can happen if we were looking for a type and\n                         // found a module instead. Modules don't have defs.\n@@ -3586,7 +3358,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n             if let Some(binding) = module.children.borrow().get(&name) {\n-                if let Some(DefMethod(did)) = binding.def_for_namespace(ValueNS) {\n+                if let Some(DefMethod(did)) = binding.value_ns.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n                     }\n@@ -3894,7 +3666,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             {\n                 for (_, child_names) in search_module.children.borrow().iter() {\n-                    let def = match child_names.def_for_namespace(TypeNS) {\n+                    let def = match child_names.type_ns.def() {\n                         Some(def) => def,\n                         None => continue,\n                     };\n@@ -3914,7 +3686,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => continue,\n                     Some(target) => target,\n                 };\n-                let did = match target.bindings.def_for_namespace(TypeNS) {\n+                let did = match target.binding.def() {\n                     Some(DefTrait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };"}, {"sha": "02ab3bd02950940bfb946a8fcdf272236598f041", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=ceda8383c9956d1829f1e26315ad17d39323022c", "patch": "@@ -18,8 +18,8 @@\n // Then this operation can simply be performed as part of item (or import)\n // processing.\n \n-use {Module, NameBindings, Resolver};\n-use Namespace::{self, TypeNS, ValueNS};\n+use {Module, NameBinding, Resolver};\n+use Namespace::{TypeNS, ValueNS};\n \n use build_reduced_graph;\n use module_to_string;\n@@ -108,12 +108,11 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn add_exports_of_namebindings(&mut self,\n-                                   exports: &mut Vec<Export>,\n-                                   name: ast::Name,\n-                                   namebindings: &NameBindings,\n-                                   ns: Namespace) {\n-        match namebindings.def_for_namespace(ns) {\n+    fn add_export_of_namebinding(&mut self,\n+                                 exports: &mut Vec<Export>,\n+                                 name: ast::Name,\n+                                 namebinding: &NameBinding) {\n+        match namebinding.def() {\n             Some(d) => {\n                 debug!(\"(computing exports) YES: export '{}' => {:?}\",\n                        name,\n@@ -139,7 +138,7 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\", name);\n-                        self.add_exports_of_namebindings(exports, *name, &*target.bindings, ns)\n+                        self.add_export_of_namebinding(exports, *name, &target.binding)\n                     }\n                     _ => (),\n                 }"}, {"sha": "150c6ec965752d0d0ae0fa14c1ecdf13b7250c82", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceda8383c9956d1829f1e26315ad17d39323022c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ceda8383c9956d1829f1e26315ad17d39323022c", "patch": "@@ -14,7 +14,7 @@ use DefModifiers;\n use Module;\n use ModuleKind;\n use Namespace::{self, TypeNS, ValueNS};\n-use NameBindings;\n+use {NameBindings, NameBinding};\n use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n use NamespaceResult;\n use NameSearchType;\n@@ -86,18 +86,18 @@ impl ImportDirective {\n #[derive(Clone,Debug)]\n pub struct Target {\n     pub target_module: Rc<Module>,\n-    pub bindings: Rc<NameBindings>,\n+    pub binding: NameBinding,\n     pub shadowable: Shadowable,\n }\n \n impl Target {\n     pub fn new(target_module: Rc<Module>,\n-               bindings: Rc<NameBindings>,\n+               binding: NameBinding,\n                shadowable: Shadowable)\n                -> Target {\n         Target {\n             target_module: target_module,\n-            bindings: bindings,\n+            binding: binding,\n             shadowable: shadowable,\n         }\n     }\n@@ -459,11 +459,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref child_name_bindings) => {\n                 // pub_err makes sure we don't give the same error twice.\n                 let mut pub_err = false;\n-                if child_name_bindings.defined_in_namespace(ValueNS) {\n+                if child_name_bindings.value_ns.defined() {\n                     debug!(\"(resolving single import) found value binding\");\n                     value_result = BoundResult(target_module.clone(),\n-                                               (*child_name_bindings).clone());\n-                    if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n+                                               child_name_bindings.value_ns.clone());\n+                    if directive.is_public && !child_name_bindings.value_ns.is_public() {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                         let note_msg = format!(\"Consider marking `{}` as `pub` in the imported \\\n                                                 module\",\n@@ -473,11 +473,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         pub_err = true;\n                     }\n                 }\n-                if child_name_bindings.defined_in_namespace(TypeNS) {\n+                if child_name_bindings.type_ns.defined() {\n                     debug!(\"(resolving single import) found type binding\");\n                     type_result = BoundResult(target_module.clone(),\n-                                              (*child_name_bindings).clone());\n-                    if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n+                                              child_name_bindings.type_ns.clone());\n+                    if !pub_err && directive.is_public &&\n+                       !child_name_bindings.type_ns.is_public() {\n                         let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                         let note_msg = format!(\"Consider declaring module `{}` as a `pub mod`\",\n                                                source);\n@@ -540,7 +541,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                 }\n                                 Some(Target {\n                                     target_module,\n-                                    bindings,\n+                                    binding,\n                                     shadowable: _\n                                 }) => {\n                                     debug!(\"(resolving single import) found import in ns {:?}\",\n@@ -555,7 +556,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                         }\n                                         _ => {}\n                                     }\n-                                    return BoundResult(target_module, bindings);\n+                                    return BoundResult(target_module, binding);\n                                 }\n                             }\n                         }\n@@ -630,9 +631,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             }\n                             _ => {}\n                         }\n-                        let name_bindings =\n-                            Rc::new(Resolver::create_name_bindings_from_module(module));\n-                        type_result = BoundResult(target_module.clone(), name_bindings);\n+                        let name_binding = NameBinding::create_from_module(module);\n+                        type_result = BoundResult(target_module.clone(), name_binding);\n                         type_used_public = true;\n                     }\n                 }\n@@ -651,26 +651,25 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 };\n \n                 match *result {\n-                    BoundResult(ref target_module, ref name_bindings) => {\n+                    BoundResult(ref target_module, ref name_binding) => {\n                         debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n-                               name_bindings.def_for_namespace(namespace));\n+                               name_binding.def());\n                         self.check_for_conflicting_import(&import_resolution,\n                                                           directive.span,\n                                                           target,\n                                                           namespace);\n \n-                        self.check_that_import_is_importable(&**name_bindings,\n+                        self.check_that_import_is_importable(&name_binding,\n                                                              directive.span,\n-                                                             target,\n-                                                             namespace);\n+                                                             target);\n \n                         let target = Some(Target::new(target_module.clone(),\n-                                                      name_bindings.clone(),\n+                                                      name_binding.clone(),\n                                                       directive.shadowable));\n                         import_resolution.set_target_and_id(namespace, target, directive.id);\n                         import_resolution.is_public = directive.is_public;\n-                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                        *used_public = name_binding.is_public();\n                     }\n                     UnboundResult => {\n                         // Continue.\n@@ -705,7 +704,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n+            let def = target.binding.def().unwrap();\n             (def,\n              if value_used_public {\n                 lp\n@@ -714,7 +713,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             })\n         });\n         let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n+            let def = target.binding.def().unwrap();\n             (def,\n              if type_used_public {\n                 lp\n@@ -857,12 +856,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         // Add external module children from the containing module.\n         for (&name, module) in target_module.external_module_children.borrow().iter() {\n-            let name_bindings = Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n             self.merge_import_resolution(module_,\n                                          target_module.clone(),\n                                          import_directive,\n                                          name,\n-                                         name_bindings);\n+                                         NameBindings::create_from_module(module.clone()));\n         }\n \n         // Record the destination of this import\n@@ -884,7 +882,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                containing_module: Rc<Module>,\n                                import_directive: &ImportDirective,\n                                name: Name,\n-                               name_bindings: Rc<NameBindings>) {\n+                               name_bindings: NameBindings) {\n         let id = import_directive.id;\n         let is_public = import_directive.is_public;\n \n@@ -904,7 +902,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             let mut merge_child_item = |namespace| {\n                 let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n \n-                if name_bindings.defined_in_namespace_with(namespace, modifier) {\n+                if name_bindings[namespace].defined_with(modifier) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\",\n                         ValueNS => \"value\",\n@@ -922,7 +920,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                   msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n-                                                 name_bindings.clone(),\n+                                                 name_bindings[namespace].clone(),\n                                                  import_directive.shadowable);\n                         dest_import_resolution.set_target_and_id(namespace, Some(target), id);\n                     }\n@@ -955,16 +953,12 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n                 let ns_word = match namespace {\n                     TypeNS => {\n-                        if let Some(ref ty_def) = *target.bindings.type_def.borrow() {\n-                            match ty_def.module_def {\n-                                Some(ref module) if module.kind.get() ==\n-                                                    ModuleKind::NormalModuleKind => \"module\",\n-                                Some(ref module) if module.kind.get() ==\n-                                                    ModuleKind::TraitModuleKind => \"trait\",\n-                                _ => \"type\",\n-                            }\n-                        } else {\n-                            \"type\"\n+                        match target.binding.module() {\n+                            Some(ref module) if module.kind.get() ==\n+                                                ModuleKind::NormalModuleKind => \"module\",\n+                            Some(ref module) if module.kind.get() ==\n+                                                ModuleKind::TraitModuleKind => \"trait\",\n+                            _ => \"type\",\n                         }\n                     }\n                     ValueNS => \"value\",\n@@ -989,11 +983,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that an import is actually importable\n     fn check_that_import_is_importable(&mut self,\n-                                       name_bindings: &NameBindings,\n+                                       name_binding: &NameBinding,\n                                        import_span: Span,\n-                                       name: Name,\n-                                       namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n+                                       name: Name) {\n+        if !name_binding.defined_with(DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\", name);\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n@@ -1032,13 +1025,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         match import_resolution.value_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref value) = *name_bindings.value_def.borrow() {\n+                if let Some(ref value) = *name_bindings.value_ns.borrow() {\n                     span_err!(self.resolver.session,\n                               import_span,\n                               E0255,\n                               \"import `{}` conflicts with value in this module\",\n                               name);\n-                    if let Some(span) = value.value_span {\n+                    if let Some(span) = value.span {\n                         self.resolver.session.span_note(span, \"conflicting value here\");\n                     }\n                 }\n@@ -1048,8 +1041,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         match import_resolution.type_target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n-                    let (what, note) = match ty.module_def {\n+                if let Some(ref ty) = *name_bindings.type_ns.borrow() {\n+                    let (what, note) = match ty.module.clone() {\n                         Some(ref module) if module.kind.get() == ModuleKind::NormalModuleKind =>\n                             (\"existing submodule\", \"note conflicting module here\"),\n                         Some(ref module) if module.kind.get() == ModuleKind::TraitModuleKind =>\n@@ -1062,7 +1055,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                               \"import `{}` conflicts with {}\",\n                               name,\n                               what);\n-                    if let Some(span) = ty.type_span {\n+                    if let Some(span) = ty.span {\n                         self.resolver.session.span_note(span, note);\n                     }\n                 }"}]}