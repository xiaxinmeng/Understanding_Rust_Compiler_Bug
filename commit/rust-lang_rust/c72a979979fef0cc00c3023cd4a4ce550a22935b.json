{"sha": "c72a979979fef0cc00c3023cd4a4ce550a22935b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MmE5Nzk5NzlmZWYwY2MwMGMzMDIzY2Q0YTRjZTU1MGEyMjkzNWI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-19T13:20:02Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-24T09:46:00Z"}, "message": "move unsafety checking to MIR\n\nNo functional changes intended.", "tree": {"sha": "84bee9c7350fe34d8866d870a2d0c54b611be4f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84bee9c7350fe34d8866d870a2d0c54b611be4f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c72a979979fef0cc00c3023cd4a4ce550a22935b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c72a979979fef0cc00c3023cd4a4ce550a22935b", "html_url": "https://github.com/rust-lang/rust/commit/c72a979979fef0cc00c3023cd4a4ce550a22935b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c72a979979fef0cc00c3023cd4a4ce550a22935b/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7500f9b68d56b8313a8d3c103fd31b638ec8d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7500f9b68d56b8313a8d3c103fd31b638ec8d2", "html_url": "https://github.com/rust-lang/rust/commit/8c7500f9b68d56b8313a8d3c103fd31b638ec8d2"}], "stats": {"total": 1050, "additions": 662, "deletions": 388}, "files": [{"sha": "7a78765365db047e86492d36d152343cc0083bf5", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -445,6 +445,7 @@ define_dep_nodes!( <'tcx>\n     [] BorrowCheckKrate,\n     [] BorrowCheck(DefId),\n     [] MirBorrowCheck(DefId),\n+    [] UnsafetyViolations(DefId),\n \n     [] RvalueCheck(DefId),\n     [] Reachability,"}, {"sha": "6b79f0cde1a8f4a26b5c9ceee1b430413726c9c4", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -479,40 +479,6 @@ fn main() {\n ```\n \"##,\n \n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n-\"##,\n-\n // This shouldn't really ever trigger since the repeated value error comes first\n E0136: r##\"\n A binary can only have one entry point, and by default that entry point is the"}, {"sha": "4bda89690b7a9b8a1c64498e4a6420295babb95c", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -33,6 +33,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n });\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n+impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, lint_node_id });\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::Terminator<'gcx> {\n@@ -364,7 +365,26 @@ for mir::ProjectionElem<'gcx, V, T>\n }\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n-impl_stable_hash_for!(struct mir::VisibilityScopeInfo { lint_root });\n+impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n+    lint_root, safety\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            mir::Safety::Safe |\n+            mir::Safety::BuiltinUnsafe |\n+            mir::Safety::FnUnsafe => {}\n+            mir::Safety::ExplicitUnsafe(node_id) => {\n+                node_id.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "1e90aa47267ff18b5388dd9182bccc5ca07f0536", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -111,7 +111,6 @@ pub mod middle {\n     pub mod dataflow;\n     pub mod dead;\n     pub mod dependency_format;\n-    pub mod effect;\n     pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;"}, {"sha": "7290353e48b0c379b04756512b6e84bfc80f7e12", "filename": "src/librustc/middle/effect.rs", "status": "removed", "additions": 0, "deletions": 316, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/8c7500f9b68d56b8313a8d3c103fd31b638ec8d2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7500f9b68d56b8313a8d3c103fd31b638ec8d2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=8c7500f9b68d56b8313a8d3c103fd31b638ec8d2", "patch": "@@ -1,316 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Enforces the Rust effect system. Currently there is just one effect,\n-//! `unsafe`.\n-use self::RootUnsafeContext::*;\n-\n-use ty::{self, TyCtxt};\n-use lint;\n-use lint::builtin::UNUSED_UNSAFE;\n-\n-use hir::def::Def;\n-use hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n-use hir::{self, PatKind};\n-use syntax::ast;\n-use syntax_pos::Span;\n-use util::nodemap::FxHashSet;\n-\n-#[derive(Copy, Clone)]\n-struct UnsafeContext {\n-    push_unsafe_count: usize,\n-    root: RootUnsafeContext,\n-}\n-\n-impl UnsafeContext {\n-    fn new(root: RootUnsafeContext) -> UnsafeContext {\n-        UnsafeContext { root: root, push_unsafe_count: 0 }\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RootUnsafeContext {\n-    SafeContext,\n-    UnsafeFn,\n-    UnsafeBlock(ast::NodeId),\n-}\n-\n-struct EffectCheckVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    body_id: hir::BodyId,\n-\n-    /// Whether we're in an unsafe context.\n-    unsafe_context: UnsafeContext,\n-    used_unsafe: FxHashSet<ast::NodeId>,\n-}\n-\n-impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n-    fn require_unsafe_ext(&mut self, node_id: ast::NodeId, span: Span,\n-                          description: &str, is_lint: bool) {\n-        if self.unsafe_context.push_unsafe_count > 0 { return; }\n-        match self.unsafe_context.root {\n-            SafeContext => {\n-                if is_lint {\n-                    self.tcx.lint_node(lint::builtin::SAFE_EXTERN_STATICS,\n-                                       node_id,\n-                                       span,\n-                                       &format!(\"{} requires unsafe function or \\\n-                                                 block (error E0133)\", description));\n-                } else {\n-                    // Report an error.\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0133,\n-                        \"{} requires unsafe function or block\", description)\n-                        .span_label(span, description)\n-                        .emit();\n-                }\n-            }\n-            UnsafeBlock(block_id) => {\n-                // OK, but record this.\n-                debug!(\"effect: recording unsafe block as used: {}\", block_id);\n-                self.used_unsafe.insert(block_id);\n-            }\n-            UnsafeFn => {}\n-        }\n-    }\n-\n-    fn require_unsafe(&mut self, span: Span, description: &str) {\n-        self.require_unsafe_ext(ast::DUMMY_NODE_ID, span, description, false)\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        let old_body_id = self.body_id;\n-        self.tables = self.tcx.body_tables(body);\n-        self.body_id = body;\n-        let body = self.tcx.hir.body(body);\n-        self.visit_body(body);\n-        self.tables = old_tables;\n-        self.body_id = old_body_id;\n-    }\n-\n-    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n-                body_id: hir::BodyId, span: Span, id: ast::NodeId) {\n-\n-        let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            FnKind::ItemFn(_, _, unsafety, ..) =>\n-                (true, unsafety == hir::Unsafety::Unsafe),\n-            FnKind::Method(_, sig, ..) =>\n-                (true, sig.unsafety == hir::Unsafety::Unsafe),\n-            _ => (false, false),\n-        };\n-\n-        let old_unsafe_context = self.unsafe_context;\n-        if is_unsafe_fn {\n-            self.unsafe_context = UnsafeContext::new(UnsafeFn)\n-        } else if is_item_fn {\n-            self.unsafe_context = UnsafeContext::new(SafeContext)\n-        }\n-\n-        intravisit::walk_fn(self, fn_kind, fn_decl, body_id, span, id);\n-\n-        self.unsafe_context = old_unsafe_context\n-    }\n-\n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        let old_unsafe_context = self.unsafe_context;\n-        match block.rules {\n-            hir::UnsafeBlock(source) => {\n-                // By default only the outermost `unsafe` block is\n-                // \"used\" and so nested unsafe blocks are pointless\n-                // (the inner ones are unnecessary and we actually\n-                // warn about them). As such, there are two cases when\n-                // we need to create a new context, when we're\n-                // - outside `unsafe` and found a `unsafe` block\n-                //   (normal case)\n-                // - inside `unsafe`, found an `unsafe` block\n-                //   created internally to the compiler\n-                //\n-                // The second case is necessary to ensure that the\n-                // compiler `unsafe` blocks don't accidentally \"use\"\n-                // external blocks (e.g. `unsafe { println(\"\") }`,\n-                // expands to `unsafe { ... unsafe { ... } }` where\n-                // the inner one is compiler generated).\n-                if self.unsafe_context.root == SafeContext || source == hir::CompilerGenerated {\n-                    self.unsafe_context.root = UnsafeBlock(block.id)\n-                }\n-            }\n-            hir::PushUnsafeBlock(..) => {\n-                self.unsafe_context.push_unsafe_count =\n-                    self.unsafe_context.push_unsafe_count.checked_add(1).unwrap();\n-            }\n-            hir::PopUnsafeBlock(..) => {\n-                self.unsafe_context.push_unsafe_count =\n-                    self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n-            }\n-            hir::DefaultBlock => {}\n-        }\n-\n-        intravisit::walk_block(self, block);\n-\n-        self.unsafe_context = old_unsafe_context;\n-\n-        // Don't warn about generated blocks, that'll just pollute the output.\n-        match block.rules {\n-            hir::UnsafeBlock(hir::UserProvided) => {}\n-            _ => return,\n-        }\n-        if self.used_unsafe.contains(&block.id) {\n-            return\n-        }\n-\n-        /// Return the NodeId for an enclosing scope that is also `unsafe`\n-        fn is_enclosed(tcx: TyCtxt,\n-                       used_unsafe: &FxHashSet<ast::NodeId>,\n-                       id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n-            let parent_id = tcx.hir.get_parent_node(id);\n-            if parent_id != id {\n-                if used_unsafe.contains(&parent_id) {\n-                    Some((\"block\".to_string(), parent_id))\n-                } else if let Some(hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n-                    ..\n-                })) = tcx.hir.find(parent_id) {\n-                    Some((\"fn\".to_string(), parent_id))\n-                } else {\n-                    is_enclosed(tcx, used_unsafe, parent_id)\n-                }\n-            } else {\n-                None\n-            }\n-        }\n-\n-        let mut db = self.tcx.struct_span_lint_node(UNUSED_UNSAFE,\n-                                                    block.id,\n-                                                    block.span,\n-                                                    \"unnecessary `unsafe` block\");\n-        db.span_label(block.span, \"unnecessary `unsafe` block\");\n-        if let Some((kind, id)) = is_enclosed(self.tcx, &self.used_unsafe, block.id) {\n-            db.span_note(self.tcx.hir.span(id),\n-                         &format!(\"because it's nested under this `unsafe` {}\", kind));\n-        }\n-        db.emit();\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        match expr.node {\n-            hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n-                let sig = self.tcx.fn_sig(def_id);\n-                debug!(\"effect: method call case, signature is {:?}\",\n-                        sig);\n-\n-                if sig.0.unsafety == hir::Unsafety::Unsafe {\n-                    self.require_unsafe(expr.span,\n-                                        \"invocation of unsafe method\")\n-                }\n-            }\n-            hir::ExprCall(ref base, _) => {\n-                let base_type = self.tables.expr_ty_adjusted(base);\n-                debug!(\"effect: call case, base type is {:?}\",\n-                        base_type);\n-                match base_type.sty {\n-                    ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                        if base_type.fn_sig(self.tcx).unsafety() == hir::Unsafety::Unsafe {\n-                            self.require_unsafe(expr.span, \"call to unsafe function\")\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tables.expr_ty_adjusted(base);\n-                debug!(\"effect: unary case, base type is {:?}\",\n-                        base_type);\n-                if let ty::TyRawPtr(_) = base_type.sty {\n-                    self.require_unsafe(expr.span, \"dereference of raw pointer\")\n-                }\n-            }\n-            hir::ExprInlineAsm(..) => {\n-                self.require_unsafe(expr.span, \"use of inline assembly\");\n-            }\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                if let Def::Static(def_id, mutbl) = path.def {\n-                    if mutbl {\n-                        self.require_unsafe(expr.span, \"use of mutable static\");\n-                    } else if match self.tcx.hir.get_if_local(def_id) {\n-                        Some(hir::map::NodeForeignItem(..)) => true,\n-                        Some(..) => false,\n-                        None => self.tcx.is_foreign_item(def_id),\n-                    } {\n-                        self.require_unsafe_ext(expr.id, expr.span, \"use of extern static\", true);\n-                    }\n-                }\n-            }\n-            hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n-                    if adt.is_union() {\n-                        self.require_unsafe(field.span, \"access to union field\");\n-                    }\n-                }\n-            }\n-            hir::ExprAssign(ref lhs, ref rhs) => {\n-                if let hir::ExprField(ref base_expr, field) = lhs.node {\n-                    if let ty::TyAdt(adt, ..) = self.tables.expr_ty_adjusted(base_expr).sty {\n-                        if adt.is_union() {\n-                            let field_ty = self.tables.expr_ty_adjusted(lhs);\n-                            let owner_def_id = self.tcx.hir.body_owner_def_id(self.body_id);\n-                            let param_env = self.tcx.param_env(owner_def_id);\n-                            if field_ty.moves_by_default(self.tcx, param_env, field.span) {\n-                                self.require_unsafe(field.span,\n-                                                    \"assignment to non-`Copy` union field\");\n-                            }\n-                            // Do not walk the field expr again.\n-                            intravisit::walk_expr(self, base_expr);\n-                            intravisit::walk_expr(self, rhs);\n-                            return\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        if let PatKind::Struct(_, ref fields, _) = pat.node {\n-            if let ty::TyAdt(adt, ..) = self.tables.pat_ty(pat).sty {\n-                if adt.is_union() {\n-                    for field in fields {\n-                        self.require_unsafe(field.span, \"matching on union field\");\n-                    }\n-                }\n-            }\n-        }\n-\n-        intravisit::walk_pat(self, pat);\n-    }\n-}\n-\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut visitor = EffectCheckVisitor {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        body_id: hir::BodyId { node_id: ast::CRATE_NODE_ID },\n-        unsafe_context: UnsafeContext::new(SafeContext),\n-        used_unsafe: FxHashSet(),\n-    };\n-\n-    tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n-}"}, {"sha": "a5fe482845367cb571c45fbf69a02d676d4712a8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -290,6 +290,19 @@ impl<'tcx> Mir<'tcx> {\n pub struct VisibilityScopeInfo {\n     /// A NodeId with lint levels equivalent to this scope's lint levels.\n     pub lint_root: ast::NodeId,\n+    /// The unsafe block that contains this node.\n+    pub safety: Safety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum Safety {\n+    Safe,\n+    /// Unsafe because of a PushUnsafeBlock\n+    BuiltinUnsafe,\n+    /// Unsafe because of an unsafe fn\n+    FnUnsafe,\n+    /// Unsafe because of an `unsafe` block\n+    ExplicitUnsafe(ast::NodeId)\n }\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n@@ -346,7 +359,7 @@ impl<T> serialize::Decodable for ClearOnDecode<T> {\n /// Grouped information about the source code origin of a MIR entity.\n /// Intended to be inspected by diagnostics and debuginfo.\n /// Most passes can work with it as a whole, within a single function.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct SourceInfo {\n     /// Source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -447,14 +460,17 @@ pub struct LocalDecl<'tcx> {\n     /// True if this is an internal local\n     ///\n     /// These locals are not based on types in the source code and are only used\n-    /// for drop flags at the moment.\n+    /// for a few desugarings at the moment.\n     ///\n     /// The generator transformation will sanity check the locals which are live\n     /// across a suspension point against the type components of the generator\n     /// which type checking knows are live across a suspension point. We need to\n     /// flag drop flags to avoid triggering this check as they are introduced\n     /// after typeck.\n     ///\n+    /// Unsafety checking will also ignore dereferences of these locals,\n+    /// so they can be used for raw pointers only used in a desugaring.\n+    ///\n     /// This should be sound because the drop flags are fully algebraic, and\n     /// therefore don't affect the OIBIT or outlives properties of the\n     /// generator.\n@@ -1634,6 +1650,13 @@ impl Location {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct UnsafetyViolation {\n+    pub source_info: SourceInfo,\n+    pub description: &'static str,\n+    pub lint_node_id: Option<ast::NodeId>,\n+}\n+\n /// The layout of generator state\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct GeneratorLayout<'tcx> {"}, {"sha": "4bd2d5be6d716f09a66d51cd6134190f8b9af034", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -159,6 +159,10 @@ define_maps! { <'tcx>\n     /// expression defining the closure.\n     [] fn closure_kind: ClosureKind(DefId) -> ty::ClosureKind,\n \n+    /// Unsafety violations for this def ID.\n+    [] fn unsafety_violations: UnsafetyViolations(DefId)\n+        -> Rc<[mir::UnsafetyViolation]>,\n+\n     /// The signature of functions and closures.\n     [] fn fn_sig: FnSignature(DefId) -> ty::PolyFnSig<'tcx>,\n "}, {"sha": "4725f6e2c7839e534319a27fca4d067eea47eafb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -1081,10 +1081,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"intrinsic checking\",\n              || middle::intrinsicck::check_crate(tcx));\n \n-        time(time_passes,\n-             \"effect checking\",\n-             || middle::effect::check_crate(tcx));\n-\n         time(time_passes,\n              \"match checking\",\n              || check_match::check_crate(tcx));\n@@ -1105,6 +1101,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR borrow checking\",\n              || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n \n+        time(time_passes,\n+             \"MIR effect checking\",\n+             || for def_id in tcx.body_owners() {\n+                 mir::transform::check_unsafety::check_unsafety(tcx, def_id)\n+             });\n         // Avoid overwhelming user with errors if type checking failed.\n         // I'm not sure how helpful this is, to be honest, but it avoids\n         // a"}, {"sha": "1fc96dbf451972eae1b440dcdea88dfe9a0df029", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 61, "deletions": 4, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -21,7 +21,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      ast_block: &'tcx hir::Block,\n                      source_info: SourceInfo)\n                      -> BlockAnd<()> {\n-        let Block { region_scope, opt_destruction_scope, span, stmts, expr, targeted_by_break } =\n+        let Block {\n+            region_scope,\n+            opt_destruction_scope,\n+            span,\n+            stmts,\n+            expr,\n+            targeted_by_break,\n+            safety_mode\n+        } =\n             self.hir.mirror(ast_block);\n         self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, block, move |this| {\n@@ -30,13 +38,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let exit_block = this.cfg.start_new_block();\n                     let block_exit = this.in_breakable_scope(\n                         None, exit_block, destination.clone(), |this| {\n-                            this.ast_block_stmts(destination, block, span, stmts, expr)\n+                            this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                                 safety_mode)\n                         });\n                     this.cfg.terminate(unpack!(block_exit), source_info,\n                                        TerminatorKind::Goto { target: exit_block });\n                     exit_block.unit()\n                 } else {\n-                    this.ast_block_stmts(destination, block, span, stmts, expr)\n+                    this.ast_block_stmts(destination, block, span, stmts, expr,\n+                                         safety_mode)\n                 }\n             })\n         })\n@@ -47,7 +57,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                        mut block: BasicBlock,\n                        span: Span,\n                        stmts: Vec<StmtRef<'tcx>>,\n-                       expr: Option<ExprRef<'tcx>>)\n+                       expr: Option<ExprRef<'tcx>>,\n+                       safety_mode: BlockSafety)\n                        -> BlockAnd<()> {\n         let this = self;\n \n@@ -69,6 +80,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // First we build all the statements in the block.\n         let mut let_scope_stack = Vec::with_capacity(8);\n         let outer_visibility_scope = this.visibility_scope;\n+        let outer_push_unsafe_count = this.push_unsafe_count;\n+        let outer_unpushed_unsafe = this.unpushed_unsafe;\n+        this.update_visibility_scope_for_safety_mode(span, safety_mode);\n+\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n             let Stmt { kind, opt_destruction_scope } = this.hir.mirror(stmt);\n@@ -137,6 +152,48 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         // Restore the original visibility scope.\n         this.visibility_scope = outer_visibility_scope;\n+        this.push_unsafe_count = outer_push_unsafe_count;\n+        this.unpushed_unsafe = outer_unpushed_unsafe;\n         block.unit()\n     }\n+\n+    /// If we are changing the safety mode, create a new visibility scope\n+    fn update_visibility_scope_for_safety_mode(&mut self,\n+                                               span: Span,\n+                                               safety_mode: BlockSafety)\n+    {\n+        debug!(\"update_visibility_scope_for({:?}, {:?})\", span, safety_mode);\n+        let new_unsafety = match safety_mode {\n+            BlockSafety::Safe => None,\n+            BlockSafety::ExplicitUnsafe(node_id) => {\n+                assert_eq!(self.push_unsafe_count, 0);\n+                match self.unpushed_unsafe {\n+                    Safety::Safe => {}\n+                    _ => return\n+                }\n+                self.unpushed_unsafe = Safety::ExplicitUnsafe(node_id);\n+                Some(Safety::ExplicitUnsafe(node_id))\n+            }\n+            BlockSafety::PushUnsafe => {\n+                self.push_unsafe_count += 1;\n+                Some(Safety::BuiltinUnsafe)\n+            }\n+            BlockSafety::PopUnsafe => {\n+                self.push_unsafe_count =\n+                    self.push_unsafe_count.checked_sub(1).unwrap_or_else(|| {\n+                        span_bug!(span, \"unsafe count underflow\")\n+                    });\n+                if self.push_unsafe_count == 0 {\n+                    Some(self.unpushed_unsafe)\n+                } else {\n+                    None\n+                }\n+            }\n+        };\n+\n+        if let Some(unsafety) = new_unsafety {\n+            self.visibility_scope = self.new_visibility_scope(\n+                span, LintLevel::Inherited, Some(unsafety));\n+        }\n+    }\n }"}, {"sha": "cdbcb43370fe0e6eb91f0d5829e53bfaa201bbc7", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -228,9 +228,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let val = args.next().expect(\"1 argument to `move_val_init`\");\n                     assert!(args.next().is_none(), \">2 arguments to `move_val_init`\");\n \n-                    let topmost_scope = this.topmost_scope();\n-                    let ptr = unpack!(block = this.as_temp(block, Some(topmost_scope), ptr));\n-                    this.into(&Lvalue::Local(ptr).deref(), block, val)\n+                    let ptr = this.hir.mirror(ptr);\n+                    let ptr_ty = ptr.ty;\n+                    // Create an *internal* temp for the pointer, so that unsafety\n+                    // checking won't complain about the raw pointer assignment.\n+                    let ptr_temp = this.local_decls.push(LocalDecl {\n+                        mutability: Mutability::Mut,\n+                        ty: ptr_ty,\n+                        name: None,\n+                        source_info,\n+                        lexical_scope: source_info.scope,\n+                        internal: true,\n+                        is_user_variable: false\n+                    });\n+                    let ptr_temp = Lvalue::Local(ptr_temp);\n+                    let block = unpack!(this.into(&ptr_temp, block, ptr));\n+                    this.into(&ptr_temp.deref(), block, val)\n                 } else {\n                     let args: Vec<_> =\n                         args.into_iter()"}, {"sha": "f04dede6e4005d55271442a332a63be99522dba7", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -182,11 +182,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n             if var_scope.is_none() {\n                 var_scope = Some(this.new_visibility_scope(scope_span,\n-                                                           LintLevel::Inherited));\n+                                                           LintLevel::Inherited,\n+                                                           None));\n                 // If we have lints, create a new visibility scope\n                 // that marks the lints for the locals.\n                 if lint_level.is_explicit() {\n-                    this.new_visibility_scope(scope_span, lint_level);\n+                    this.visibility_scope =\n+                        this.new_visibility_scope(scope_span, lint_level, None);\n                 }\n             }\n             let source_info = SourceInfo {"}, {"sha": "68ef646184c2c3a577624bece4aca793c8ef13d3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -72,14 +72,14 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // is a constant \"initializer\" expression.\n             match expr.node {\n                 hir::ExprClosure(_, _, body, _, _) => body,\n-                _ => hir::BodyId { node_id: expr.id }\n+                _ => hir::BodyId { node_id: expr.id },\n             }\n         }\n         hir::map::NodeVariant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         hir::map::NodeStructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n-        _ => unsupported()\n+        _ => unsupported(),\n     };\n \n     let src = MirSource::from_node(tcx, id);\n@@ -109,6 +109,12 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 _ => None,\n             };\n \n+            // FIXME: safety in closures\n+            let safety = match fn_sig.unsafety {\n+                hir::Unsafety::Normal => Safety::Safe,\n+                hir::Unsafety::Unsafe => Safety::FnUnsafe,\n+            };\n+\n             let body = tcx.hir.body(body_id);\n             let explicit_arguments =\n                 body.arguments\n@@ -127,7 +133,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 (None, fn_sig.output())\n             };\n \n-            build::construct_fn(cx, id, arguments, abi, return_ty, yield_ty, body)\n+            build::construct_fn(cx, id, arguments, safety, abi,\n+                                return_ty, yield_ty, body)\n         } else {\n             build::construct_const(cx, body_id)\n         };\n@@ -271,6 +278,13 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n \n+    /// The current unsafe block in scope, even if it is hidden by\n+    /// a PushUnsafeBlock\n+    unpushed_unsafe: Safety,\n+\n+    /// The number of `push_unsafe_block` levels in scope\n+    push_unsafe_count: usize,\n+\n     /// the current set of breakables; see the `scope` module for more\n     /// details\n     breakable_scopes: Vec<scope::BreakableScope<'tcx>>,\n@@ -360,6 +374,7 @@ macro_rules! unpack {\n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: ast::NodeId,\n                                    arguments: A,\n+                                   safety: Safety,\n                                    abi: Abi,\n                                    return_ty: Ty<'gcx>,\n                                    yield_ty: Option<Ty<'gcx>>,\n@@ -374,6 +389,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let mut builder = Builder::new(hir.clone(),\n         span,\n         arguments.len(),\n+        safety,\n         return_ty);\n \n     let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n@@ -444,7 +460,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -465,7 +481,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir.body_owner(body_id);\n     let span = hir.tcx().hir.span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, ty);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(vec![], ty, None)\n@@ -475,6 +491,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,\n            arg_count: usize,\n+           safety: Safety,\n            return_ty: Ty<'tcx>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n@@ -487,6 +504,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             visibility_scope_info: IndexVec::new(),\n+            push_unsafe_count: 0,\n+            unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty,\n                                                                              span), 1),\n@@ -498,7 +517,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);\n         assert_eq!(\n-            builder.new_visibility_scope(span, lint_level),\n+            builder.new_visibility_scope(span, lint_level, Some(safety)),\n             ARGUMENT_VISIBILITY_SCOPE);\n         builder.visibility_scopes[ARGUMENT_VISIBILITY_SCOPE].parent_scope = None;\n "}, {"sha": "20d3efdfffc3d5af66181aba6fe40ac71073911d", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -330,7 +330,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             if !same_lint_scopes {\n                 self.visibility_scope =\n-                    self.new_visibility_scope(region_scope.1.span, lint_level);\n+                    self.new_visibility_scope(region_scope.1.span, lint_level,\n+                                              None);\n             }\n         }\n         self.push_scope(region_scope);\n@@ -500,19 +501,27 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Creates a new visibility scope, nested in the current one.\n     pub fn new_visibility_scope(&mut self,\n                                 span: Span,\n-                                lint_level: LintLevel) -> VisibilityScope {\n-        debug!(\"new_visibility_scope({:?}, {:?})\", span, lint_level);\n+                                lint_level: LintLevel,\n+                                safety: Option<Safety>) -> VisibilityScope {\n         let parent = self.visibility_scope;\n-        let info = if let LintLevel::Explicit(lint_level) = lint_level {\n-            VisibilityScopeInfo { lint_root: lint_level }\n-        } else {\n-            self.visibility_scope_info[parent].clone()\n-        };\n+        debug!(\"new_visibility_scope({:?}, {:?}, {:?}) - parent({:?})={:?}\",\n+               span, lint_level, safety,\n+               parent, self.visibility_scope_info.get(parent));\n         let scope = self.visibility_scopes.push(VisibilityScopeData {\n             span,\n             parent_scope: Some(parent),\n         });\n-        self.visibility_scope_info.push(info);\n+        let scope_info = VisibilityScopeInfo {\n+            lint_root: if let LintLevel::Explicit(lint_root) = lint_level {\n+                lint_root\n+            } else {\n+                self.visibility_scope_info[parent].lint_root\n+            },\n+            safety: safety.unwrap_or_else(|| {\n+                self.visibility_scope_info[parent].safety\n+            })\n+        };\n+        self.visibility_scope_info.push(scope_info);\n         scope\n     }\n "}, {"sha": "2c4afb0aa0e045f26e7c2883e032bee685ccf376", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -195,6 +195,40 @@ instead of using a `const fn`, or refactoring the code to a functional style to\n avoid mutation if possible.\n \"##,\n \n+E0133: r##\"\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/first-edition/unsafe.html\n+\"##,\n+\n E0381: r##\"\n It is not allowed to use or capture an uninitialized variable. For example:\n "}, {"sha": "a8172a60174fa2a7c9b2c8fd20614e79161a1b08", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -30,6 +30,16 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n             span: self.span,\n             stmts,\n             expr: self.expr.to_ref(),\n+            safety_mode: match self.rules {\n+                hir::BlockCheckMode::DefaultBlock =>\n+                    BlockSafety::Safe,\n+                hir::BlockCheckMode::UnsafeBlock(..) =>\n+                    BlockSafety::ExplicitUnsafe(self.id),\n+                hir::BlockCheckMode::PushUnsafeBlock(..) =>\n+                    BlockSafety::PushUnsafe,\n+                hir::BlockCheckMode::PopUnsafeBlock(..) =>\n+                    BlockSafety::PopUnsafe\n+            },\n         }\n     }\n }"}, {"sha": "09a31f9ab8fa55d1c753d34ecf9bb429f0cc7f64", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -52,6 +52,15 @@ pub struct Block<'tcx> {\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n+    pub safety_mode: BlockSafety,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum BlockSafety {\n+    Safe,\n+    ExplicitUnsafe(ast::NodeId),\n+    PushUnsafe,\n+    PopUnsafe\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "49ce36223994b56f53c8825da2773078532edd79", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "added", "additions": 387, "deletions": 0, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -0,0 +1,387 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+\n+use rustc::ty::maps::Providers;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::hir;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::{DefPathData, Node};\n+use rustc::lint::builtin::{SAFE_EXTERN_STATICS, UNUSED_UNSAFE};\n+use rustc::mir::*;\n+use rustc::mir::visit::{LvalueContext, Visitor};\n+\n+use syntax::ast;\n+\n+use std::rc::Rc;\n+\n+\n+pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n+    mir: &'a Mir<'tcx>,\n+    visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+    violations: Vec<UnsafetyViolation>,\n+    source_info: SourceInfo,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    used_unsafe: FxHashSet<ast::NodeId>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+    fn new(mir: &'a Mir<'tcx>,\n+           visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n+           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: ty::ParamEnv<'tcx>) -> Self {\n+        Self {\n+            mir,\n+            visibility_scope_info,\n+            violations: vec![],\n+            source_info: SourceInfo {\n+                span: mir.span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            tcx,\n+            param_env,\n+            used_unsafe: FxHashSet(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n+    fn visit_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &Terminator<'tcx>,\n+                        location: Location)\n+    {\n+        self.source_info = terminator.source_info;\n+        match terminator.kind {\n+            TerminatorKind::Goto { .. } |\n+            TerminatorKind::SwitchInt { .. } |\n+            TerminatorKind::Drop { .. } |\n+            TerminatorKind::Yield { .. } |\n+            TerminatorKind::Assert { .. } |\n+            TerminatorKind::DropAndReplace { .. } |\n+            TerminatorKind::GeneratorDrop |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                                // safe (at least as emitted during MIR construction)\n+            }\n+\n+            TerminatorKind::Call { ref func, .. } => {\n+                let func_ty = func.ty(self.mir, self.tcx);\n+                let sig = func_ty.fn_sig(self.tcx);\n+                if let hir::Unsafety::Unsafe = sig.unsafety() {\n+                    self.require_unsafe(\"call to unsafe function\")\n+                }\n+            }\n+        }\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &Statement<'tcx>,\n+                       location: Location)\n+    {\n+        self.source_info = statement.source_info;\n+        match statement.kind {\n+            StatementKind::Assign(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(..) |\n+            StatementKind::StorageDead(..) |\n+            StatementKind::EndRegion(..) |\n+            StatementKind::Validate(..) |\n+            StatementKind::Nop => {\n+                // safe (at least as emitted during MIR construction)\n+            }\n+\n+            StatementKind::InlineAsm { .. } => {\n+                self.require_unsafe(\"use of inline assembly\")\n+            },\n+        }\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_rvalue(&mut self,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location)\n+    {\n+        if let &Rvalue::Aggregate(\n+            box AggregateKind::Closure(def_id, _),\n+            _\n+        ) = rvalue {\n+            let unsafety_violations = self.tcx.unsafety_violations(def_id);\n+            self.register_violations(&unsafety_violations);\n+        }\n+        self.super_rvalue(rvalue, location);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        match lvalue {\n+            &Lvalue::Projection(box Projection {\n+                ref base, ref elem\n+            }) => {\n+                let old_source_info = self.source_info;\n+                if let &Lvalue::Local(local) = base {\n+                    if self.mir.local_decls[local].internal {\n+                        // Internal locals are used in the `move_val_init` desugaring.\n+                        // We want to check unsafety against the source info of the\n+                        // desugaring, rather than the source info of the RHS.\n+                        self.source_info = self.mir.local_decls[local].source_info;\n+                    }\n+                }\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                match base_ty.sty {\n+                    ty::TyRawPtr(..) => {\n+                        self.require_unsafe(\"dereference of raw pointer\")\n+                    }\n+                    ty::TyAdt(adt, _) if adt.is_union() => {\n+                        if context == LvalueContext::Store ||\n+                            context == LvalueContext::Drop\n+                        {\n+                            let elem_ty = match elem {\n+                                &ProjectionElem::Field(_, ty) => ty,\n+                                _ => span_bug!(\n+                                    self.source_info.span,\n+                                    \"non-field projection {:?} from union?\",\n+                                    lvalue)\n+                            };\n+                            if elem_ty.moves_by_default(self.tcx, self.param_env,\n+                                                        self.source_info.span) {\n+                                self.require_unsafe(\n+                                    \"assignment to non-`Copy` union field\")\n+                            } else {\n+                                // write to non-move union, safe\n+                            }\n+                        } else {\n+                            self.require_unsafe(\"access to union field\")\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                self.source_info = old_source_info;\n+            }\n+            &Lvalue::Local(..) => {\n+                // locals are safe\n+            }\n+            &Lvalue::Static(box Static { def_id, ty: _ }) => {\n+                if self.is_static_mut(def_id) {\n+                    self.require_unsafe(\"use of mutable static\");\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.visibility_scope_info[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: \"use of extern static\",\n+                        lint_node_id: Some(lint_root)\n+                    }]);\n+                }\n+            }\n+        }\n+        self.super_lvalue(lvalue, context, location);\n+    }\n+}\n+\n+impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+    fn is_static_mut(&self, def_id: DefId) -> bool {\n+        if let Some(node) = self.tcx.hir.get_if_local(def_id) {\n+            match node {\n+                Node::NodeItem(&hir::Item {\n+                    node: hir::ItemStatic(_, hir::MutMutable, _), ..\n+                }) => true,\n+                Node::NodeForeignItem(&hir::ForeignItem {\n+                    node: hir::ForeignItemStatic(_, mutbl), ..\n+                }) => mutbl,\n+                _ => false\n+            }\n+        } else {\n+            match self.tcx.describe_def(def_id) {\n+                Some(Def::Static(_, mutbl)) => mutbl,\n+                _ => false\n+            }\n+        }\n+    }\n+    fn require_unsafe(&mut self,\n+                      description: &'static str)\n+    {\n+        let source_info = self.source_info;\n+        self.register_violations(&[UnsafetyViolation {\n+            source_info, description, lint_node_id: None\n+        }]);\n+    }\n+\n+    fn register_violations(&mut self, violations: &[UnsafetyViolation]) {\n+        match self.visibility_scope_info[self.source_info.scope].safety {\n+            Safety::Safe => {\n+                for violation in violations {\n+                    if !self.violations.contains(violation) {\n+                        self.violations.push(violation.clone())\n+                    }\n+                }\n+            }\n+            Safety::BuiltinUnsafe | Safety::FnUnsafe => {}\n+            Safety::ExplicitUnsafe(node_id) => {\n+                if !violations.is_empty() {\n+                    self.used_unsafe.insert(node_id);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        unsafety_violations,\n+        ..*providers\n+    };\n+}\n+\n+struct UnusedUnsafeVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    used_unsafe: FxHashSet<ast::NodeId>\n+}\n+\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) ->\n+        hir::intravisit::NestedVisitorMap<'this, 'tcx>\n+    {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n+        hir::intravisit::walk_block(self, block);\n+\n+        if let hir::UnsafeBlock(hir::UserProvided) = block.rules {\n+            if !self.used_unsafe.contains(&block.id) {\n+                self.report_unused_unsafe(block);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> UnusedUnsafeVisitor<'a, 'tcx> {\n+    /// Return the NodeId for an enclosing scope that is also `unsafe`\n+    fn is_enclosed(&self, id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n+        let parent_id = self.tcx.hir.get_parent_node(id);\n+        if parent_id != id {\n+            if self.used_unsafe.contains(&parent_id) {\n+                Some((\"block\".to_string(), parent_id))\n+            } else if let Some(hir::map::NodeItem(&hir::Item {\n+                node: hir::ItemFn(_, hir::Unsafety::Unsafe, _, _, _, _),\n+                ..\n+            })) = self.tcx.hir.find(parent_id) {\n+                Some((\"fn\".to_string(), parent_id))\n+            } else {\n+                self.is_enclosed(parent_id)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn report_unused_unsafe(&self, block: &'tcx hir::Block) {\n+        let mut db = self.tcx.struct_span_lint_node(UNUSED_UNSAFE,\n+                                                    block.id,\n+                                                    block.span,\n+                                                    \"unnecessary `unsafe` block\");\n+        db.span_label(block.span, \"unnecessary `unsafe` block\");\n+        if let Some((kind, id)) = self.is_enclosed(block.id) {\n+            db.span_note(self.tcx.hir.span(id),\n+                         &format!(\"because it's nested under this `unsafe` {}\", kind));\n+        }\n+        db.emit();\n+    }\n+}\n+\n+fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 def_id: DefId,\n+                                 used_unsafe: FxHashSet<ast::NodeId>)\n+{\n+    let body_id =\n+        tcx.hir.as_local_node_id(def_id).and_then(|node_id| {\n+            tcx.hir.maybe_body_owned_by(node_id)\n+        });\n+\n+    let body_id = match body_id {\n+        Some(body) => body,\n+        None => {\n+            debug!(\"check_unused_unsafe({:?}) - no body found\", def_id);\n+            return\n+        }\n+    };\n+    let body = tcx.hir.body(body_id);\n+    debug!(\"check_unused_unsafe({:?}, body={:?}, used_unsafe={:?})\",\n+           def_id, body, used_unsafe);\n+\n+    hir::intravisit::Visitor::visit_body(\n+        &mut UnusedUnsafeVisitor { tcx, used_unsafe },\n+        body);\n+}\n+\n+fn unsafety_violations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) ->\n+    Rc<[UnsafetyViolation]>\n+{\n+    debug!(\"unsafety_violations({:?})\", def_id);\n+\n+    // NB: this borrow is valid because all the consumers of\n+    // `mir_const` force this.\n+    let mir = &tcx.mir_const(def_id).borrow();\n+\n+    let visibility_scope_info = match mir.visibility_scope_info {\n+        ClearOnDecode::Set(ref data) => data,\n+        ClearOnDecode::Clear => {\n+            debug!(\"unsafety_violations: {:?} - remote, skipping\", def_id);\n+            return Rc::new([])\n+        }\n+    };\n+\n+    let param_env = tcx.param_env(def_id);\n+    let mut checker = UnsafetyChecker::new(\n+        mir, visibility_scope_info, tcx, param_env);\n+    checker.visit_mir(mir);\n+\n+    check_unused_unsafe(tcx, def_id, checker.used_unsafe);\n+    checker.violations.into()\n+}\n+\n+pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    debug!(\"check_unsafety({:?})\", def_id);\n+    match tcx.def_key(def_id).disambiguated_data.data {\n+        // closures are handled by their parent fn.\n+        DefPathData::ClosureExpr => return,\n+        _ => {}\n+    };\n+\n+    for &UnsafetyViolation {\n+        source_info, description, lint_node_id\n+    } in &*tcx.unsafety_violations(def_id) {\n+        // Report an error.\n+        if let Some(lint_node_id) = lint_node_id {\n+            tcx.lint_node(SAFE_EXTERN_STATICS,\n+                          lint_node_id,\n+                          source_info.span,\n+                          &format!(\"{} requires unsafe function or \\\n+                                    block (error E0133)\", description));\n+        } else {\n+            struct_span_err!(\n+                tcx.sess, source_info.span, E0133,\n+                \"{} requires unsafe function or block\", description)\n+                .span_label(source_info.span, description)\n+                .emit();\n+        }\n+    }\n+}"}, {"sha": "7245b2daa126081b57cd0329e55e3ec754ed9de6", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -26,6 +26,7 @@ use transform;\n \n pub mod add_validation;\n pub mod clean_end_regions;\n+pub mod check_unsafety;\n pub mod simplify_branches;\n pub mod simplify;\n pub mod erase_regions;\n@@ -46,6 +47,7 @@ pub mod nll;\n \n pub(crate) fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n+    self::check_unsafety::provide(providers);\n     *providers = Providers {\n         mir_keys,\n         mir_const,\n@@ -116,6 +118,7 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         // directly need the result or `mir_const_qualif`, so we can just force it.\n         ty::queries::mir_const_qualif::force(tcx, DUMMY_SP, def_id);\n     }\n+    ty::queries::unsafety_violations::force(tcx, DUMMY_SP, def_id);\n \n     let mut mir = tcx.mir_const(def_id).steal();\n     transform::run_suite(tcx, source, MIR_VALIDATED, &mut mir);"}, {"sha": "5311b80d4bdf77b8cc9a264a116a65b32dfc03d2", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -487,6 +487,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 if self.is_box_free(func) {\n                     self.check_box_free_inputs(mir, term, &sig, args);\n+                    // THIS IS A TEST. TEST TEST.\n+                    if let ClearOnDecode::Set(ref data) = mir.visibility_scope_info {\n+                        let lint_node_id = data[term.source_info.scope].lint_root;\n+                        tcx.struct_span_lint_node(\n+                            ::rustc::lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                                  lint_node_id,\n+                                                  term.source_info.span,\n+                                                  \"hi I'm a lint\")\n+                            .emit();\n+                    }\n                 } else {\n                     self.check_call_inputs(mir, term, &sig, args);\n                 }"}, {"sha": "9a39ff6206bfb5b6c0f3a6ef9505bcca29745a09", "filename": "src/test/compile-fail/borrowck/borrowck-move-from-unsafe-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-move-from-unsafe-ptr.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n \n-fn foo(x: *const Box<isize>) -> Box<isize> {\n-    let y = *x; //~ ERROR dereference of raw pointer requires unsafe function or block\n+unsafe fn foo(x: *const Box<isize>) -> Box<isize> {\n+    let y = *x; //~ ERROR cannot move out of dereference of raw pointer\n     return y;\n }\n "}, {"sha": "0ae4cafa88b669acb724738a7e4ab62ae22a756e", "filename": "src/test/compile-fail/issue-43733.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -16,6 +16,8 @@ type Foo = std::cell::RefCell<String>;\n #[cfg(target_thread_local)]\n static __KEY: std::thread::__FastLocalKeyInner<Foo> =\n     std::thread::__FastLocalKeyInner::new();\n+//~^^ ERROR Sync` is not satisfied\n+//~^^^ ERROR Sync` is not satisfied\n \n #[cfg(not(target_thread_local))]\n static __KEY: std::thread::__OsLocalKeyInner<Foo> =\n@@ -25,7 +27,7 @@ fn __getit() -> std::option::Option<\n     &'static std::cell::UnsafeCell<\n         std::option::Option<Foo>>>\n {\n-    __KEY.get() //~ ERROR  invocation of unsafe method requires unsafe\n+    __KEY.get() //~ ERROR call to unsafe function requires unsafe\n }\n \n static FOO: std::thread::LocalKey<Foo> ="}, {"sha": "e57d65dcb891f7b5b1439969f12ac5e80e617be9", "filename": "src/test/compile-fail/union/union-unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -42,8 +42,8 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field requires unsafe\n     u1.a = 11; // OK\n-    let U1 { a } = u1; //~ ERROR matching on union field requires unsafe\n-    if let U1 { a: 12 } = u1 {} //~ ERROR matching on union field requires unsafe\n+    let U1 { a } = u1; //~ ERROR access to union field requires unsafe\n+    if let U1 { a: 12 } = u1 {} //~ ERROR access to union field requires unsafe\n     // let U1 { .. } = u1; // OK\n \n     let mut u2 = U2 { a: String::from(\"old\") }; // OK"}, {"sha": "f30da250f6ac80f2eb8a0ec66d429a4d17c6d077", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -1,3 +1,4 @@\n+\n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -9,7 +10,7 @@\n // except according to those terms.\n \n \n-fn f(p: *const u8) {\n+fn f(p: *mut u8) {\n     *p = 0; //~ ERROR dereference of raw pointer requires unsafe function or block\n     return;\n }"}, {"sha": "84a8c84a0dbd203ae46cf6ca2e64a06e097b4fb6", "filename": "src/test/compile-fail/unsafe-move-val-init.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c72a979979fef0cc00c3023cd4a4ce550a22935b/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs?ref=c72a979979fef0cc00c3023cd4a4ce550a22935b", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics;\n+\n+// `move_val_init` has an odd desugaring, check that it is still treated\n+// as unsafe.\n+fn main() {\n+    intrinsics::move_val_init(1 as *mut u32, 1);\n+    //~^ ERROR dereference of raw pointer requires unsafe function or block\n+}"}]}