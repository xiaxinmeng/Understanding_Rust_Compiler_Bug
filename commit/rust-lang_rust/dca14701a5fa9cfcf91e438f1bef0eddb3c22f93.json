{"sha": "dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYTE0NzAxYTVmYTljZmNmOTFlNDM4ZjFiZWYwZWRkYjNjMjJmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-29T05:44:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-29T05:44:40Z"}, "message": "Auto merge of #49313 - sgrif:sg-revert-stuff, r=nikomatsakis\n\nRemove universes from `ty::ParamEnv`\n\nThis change was never meant to land. #48407 takes an alternate approach. However, that PR is now blocked on some issues with canonicalization, and rebasing these reverts gets harder each time, so let's just get this bit out of the way now.\n\nr? @nikomatsakis", "tree": {"sha": "d01447bd27475d64309623075c166f1d543e972e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d01447bd27475d64309623075c166f1d543e972e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "html_url": "https://github.com/rust-lang/rust/commit/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "361509320c882ee76f0d1359f842dec4637e6b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/361509320c882ee76f0d1359f842dec4637e6b08", "html_url": "https://github.com/rust-lang/rust/commit/361509320c882ee76f0d1359f842dec4637e6b08"}, {"sha": "dd60beae47374344d4b0c5f8515c064f829f6b7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd60beae47374344d4b0c5f8515c064f829f6b7a", "html_url": "https://github.com/rust-lang/rust/commit/dd60beae47374344d4b0c5f8515c064f829f6b7a"}], "stats": {"total": 341, "additions": 97, "deletions": 244}, "files": [{"sha": "594adfca6b3c0ad3eefd8023bb28b1c447bdb15b", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -1111,7 +1111,6 @@ for ty::steal::Steal<T>\n \n impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n     caller_bounds,\n-    universe,\n     reveal\n });\n \n@@ -1282,15 +1281,6 @@ for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ty::UniverseIndex {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.depth().hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl_stable_hash_for!(\n     impl<'tcx, V> for struct infer::canonical::Canonical<'tcx, V> {\n         variables, value"}, {"sha": "eb5df697216a362bd15164efa26b39d8fcaa57b4", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -726,10 +726,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(\n-            ty::UniverseIndex::ROOT,\n-            TypeVariableOrigin::TypeInference(span),\n-        );\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "4357c9a5a776acd3cdec0084200f0e8337b3972f", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -254,8 +254,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 let ty = match ty_kind {\n                     CanonicalTyVarKind::General => {\n                         self.next_ty_var(\n-                            // FIXME(#48696) this handling of universes is not right.\n-                            ty::UniverseIndex::ROOT,\n                             TypeVariableOrigin::MiscVariable(span),\n                         )\n                     }"}, {"sha": "c2167751a27e7d099ec527fa2104357b27ddb6bf", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { universe } => {\n+                        TypeVariableValue::Unknown { .. } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -424,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(universe, false, origin);\n+                            let new_var_id = variables.new_var(false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);"}, {"sha": "961dd70a4685204b927909c1738f9f3463b73b6b", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -141,11 +141,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // This variable was created during the\n                         // fudging. Recreate it with a fresh variable\n                         // here.\n-                        //\n-                        // The ROOT universe is fine because we only\n-                        // ever invoke this routine at the\n-                        // \"item-level\" of inference.\n-                        self.infcx.next_ty_var(ty::UniverseIndex::ROOT, origin)\n+                        self.infcx.next_ty_var(origin)\n                     }\n                 }\n             }"}, {"sha": "28aba51ab372468b403f4ff62525bb9d176db1c4", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -88,17 +88,13 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(a_vid)), _) => {\n-            let universe = infcx.type_variables.borrow_mut().probe(a_vid).universe().unwrap();\n-            let v = infcx.next_ty_var(universe,\n-                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (&ty::TyInfer(TyVar(..)), _) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(b_vid))) => {\n-            let universe = infcx.type_variables.borrow_mut().probe(b_vid).universe().unwrap();\n-            let v = infcx.next_ty_var(universe,\n-                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (_, &ty::TyInfer(TyVar(..))) => {\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "032a5c59d2dcaac063b1e11b2687fab781ad75b9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -837,25 +837,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self,\n-                          universe: ty::UniverseIndex,\n-                          diverging: bool,\n-                          origin: TypeVariableOrigin)\n-                          -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(universe, diverging, origin)\n+            .new_var(diverging, origin)\n     }\n \n-    pub fn next_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(universe, false, origin))\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self,\n-                                 universe: ty::UniverseIndex,\n-                                 origin: TypeVariableOrigin)\n-                                 -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(universe, true, origin))\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -910,14 +903,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// use an inference variable for `C` with `[T, U]`\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n-                            universe: ty::UniverseIndex,\n                             span: Span,\n                             def: &ty::TypeParameterDef)\n                             -> Ty<'tcx> {\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(universe,\n-                                     false,\n+                            .new_var(false,\n                                      TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n@@ -926,14 +917,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_item(&self,\n-                                 universe: ty::UniverseIndex,\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, _| {\n-            self.type_var_for_def(universe, span, def)\n+            self.type_var_for_def(span, def)\n         })\n     }\n "}, {"sha": "4113a2dd4178bfd8e92a162d6e8d2c6ab673c642", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -48,7 +48,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     glbs: CombineMap<'tcx>,\n \n     /// Number of skolemized variables currently active.\n-    skolemization_count: ty::UniverseIndex,\n+    skolemization_count: u32,\n \n     /// Global counter used during the GLB algorithm to create unique\n     /// names for fresh bound regions\n@@ -233,7 +233,7 @@ type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n-    skolemization_count: ty::UniverseIndex,\n+    skolemization_count: u32,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -277,7 +277,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n-            skolemization_count: ty::UniverseIndex::ROOT,\n+            skolemization_count: 0,\n             bound_count: 0,\n             undo_log: Vec::new(),\n             unification_table: ut::UnificationTable::new(),\n@@ -329,7 +329,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             unification_table,\n         } = self;\n \n-        assert_eq!(skolemization_count.as_usize(), 0);\n+        assert_eq!(*skolemization_count, 0);\n \n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n@@ -375,7 +375,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n             self.skolemization_count == snapshot.skolemization_count,\n-            \"failed to pop skolemized regions: {:?} now vs {:?} at start\",\n+            \"failed to pop skolemized regions: {} now vs {} at start\",\n             self.skolemization_count,\n             snapshot.skolemization_count\n         );\n@@ -485,9 +485,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n \n-        let universe = self.skolemization_count.subuniverse();\n-        self.skolemization_count = universe;\n-        tcx.mk_region(ReSkolemized(universe, br))\n+        let sc = self.skolemization_count;\n+        self.skolemization_count = sc + 1;\n+        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n@@ -505,34 +505,34 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count.as_usize() >= skols.len(),\n+            self.skolemization_count as usize >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n              sc now = {}, skols.len = {}\",\n-            self.skolemization_count.as_usize(),\n+            self.skolemization_count,\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count.subuniverse();\n-        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - (skols.len() as u32));\n+        let last_to_pop = self.skolemization_count;\n+        let first_to_pop = last_to_pop - (skols.len() as u32);\n \n         assert!(\n             first_to_pop >= snapshot.skolemization_count,\n             \"popping more regions than snapshot contains, \\\n-             sc now = {:?}, sc then = {:?}, skols.len = {}\",\n+             sc now = {}, sc then = {}, skols.len = {}\",\n             self.skolemization_count,\n             snapshot.skolemization_count,\n             skols.len()\n         );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(universe, _) =>\n-                         universe >= first_to_pop &&\n-                         universe < last_to_pop,\n+                     ty::ReSkolemized(index, _) =>\n+                         index.index >= first_to_pop &&\n+                         index.index < last_to_pop,\n                      _ =>\n                          false\n                  }),\n-            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n+            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n             snapshot.skolemization_count,\n             self.skolemization_count,\n             skols\n@@ -867,7 +867,7 @@ impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             f,\n-            \"RegionSnapshot(length={},skolemization={:?})\",\n+            \"RegionSnapshot(length={},skolemization={})\",\n             self.length,\n             self.skolemization_count\n         )"}, {"sha": "91df6cabf3a8b88c4ae0e5a6a5b947a494638aa7", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -78,33 +78,17 @@ struct TypeVariableData {\n #[derive(Copy, Clone, Debug)]\n pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n-    Unknown { universe: ty::UniverseIndex },\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum ProbeTyValue<'tcx> {\n-    Ty(Ty<'tcx>),\n-    Vid(ty::TyVid),\n+    Unknown,\n }\n \n impl<'tcx> TypeVariableValue<'tcx> {\n-    /// If this value is known, returns the type it is known to be.\n-    /// Otherwise, `None`.\n     pub fn known(&self) -> Option<Ty<'tcx>> {\n         match *self {\n             TypeVariableValue::Unknown { .. } => None,\n             TypeVariableValue::Known { value } => Some(value),\n         }\n     }\n \n-    /// If this value is unknown, returns the universe, otherwise `None`.\n-    pub fn universe(&self) -> Option<ty::UniverseIndex> {\n-        match *self {\n-            TypeVariableValue::Unknown { universe } => Some(universe),\n-            TypeVariableValue::Known { .. } => None,\n-        }\n-    }\n-\n     pub fn is_unknown(&self) -> bool {\n         match *self {\n             TypeVariableValue::Unknown { .. } => true,\n@@ -197,11 +181,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///   The code in this module doesn't care, but it can be useful\n     ///   for improving error messages.\n     pub fn new_var(&mut self,\n-                   universe: ty::UniverseIndex,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n \n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n@@ -453,12 +436,8 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n             (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n             (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n-            // If both sides are unknown, we need to pick the most restrictive universe.\n-            (&TypeVariableValue::Unknown { universe: universe1 },\n-             &TypeVariableValue::Unknown { universe: universe2 }) => {\n-                let universe = cmp::min(universe1, universe2);\n-                Ok(TypeVariableValue::Unknown { universe })\n-            }\n+            // If both sides are *unknown*, it hardly matters, does it?\n+            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n         }\n     }\n }"}, {"sha": "31f8af1f96872a94189d9e9e0ef32da0e801d285", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -92,9 +92,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n                                        -> ty::ImplHeader<'tcx>\n {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(param_env.universe,\n-                                                          DUMMY_SP,\n-                                                          impl_def_id);\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,"}, {"sha": "d2bde14732bbcdab4eca9a21ea495311826b497d", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -292,9 +292,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.for_each_relevant_impl(\n             trait_ref.def_id, trait_self_ty, |def_id| {\n-                let impl_substs = self.fresh_substs_for_item(param_env.universe,\n-                                                             obligation.cause.span,\n-                                                             def_id);\n+                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n@@ -1285,7 +1283,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                            -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-            param_env: ty::ParamEnv<'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n@@ -1295,14 +1292,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    let param_env = self.param_env;\n-                    self.var_map\n-                        .entry(ty)\n-                        .or_insert_with(|| {\n-                            let origin = TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP,\n-                                                                                     name);\n-                            infcx.next_ty_var(param_env.universe, origin)\n-                        })\n+                    self.var_map.entry(ty).or_insert_with(||\n+                        infcx.next_ty_var(\n+                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1314,7 +1306,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n-                param_env,\n                 var_map: FxHashMap()\n             });\n "}, {"sha": "2ce1b75e3151fa5e3d86b4393d2e6cdee6fe4202", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -612,8 +612,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            predicates);\n \n     let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                           unnormalized_env.reveal,\n-                                           unnormalized_env.universe);\n+                                           unnormalized_env.reveal);\n \n     tcx.infer_ctxt().enter(|infcx| {\n         // FIXME. We should really... do something with these region\n@@ -687,9 +686,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n                predicates);\n \n-        ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                          unnormalized_env.reveal,\n-                          unnormalized_env.universe)\n+        ty::ParamEnv::new(tcx.intern_predicates(&predicates), unnormalized_env.reveal)\n     })\n }\n "}, {"sha": "2a62d0b5ee39a282db94d4fd89611ce153e45d4e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -477,7 +477,6 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let tcx = selcx.infcx().tcx;\n             let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n-                param_env.universe,\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty,\n@@ -798,7 +797,6 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx().next_ty_var(\n-        param_env.universe,\n         TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,"}, {"sha": "93ae101eb1426fcdeb45742de465a5c50223f4ca", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -3040,8 +3040,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = self.infcx.fresh_substs_for_item(obligation.param_env.universe,\n-                                                           obligation.cause.span,\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n                                                            impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),"}, {"sha": "30b2c55afa1948c5c9f24277655d78d5d15fae8e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -221,7 +221,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = infcx.fresh_substs_for_item(param_env.universe, DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,"}, {"sha": "72ba199eb24122d38032e4f5717d6b9911a2b240", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 41, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -69,7 +69,7 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -1344,13 +1344,15 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// type name in a non-zero universe is a skolemized type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct UniverseIndex(u32);\n \n impl UniverseIndex {\n     /// The root universe, where things that the user defined are\n     /// visible.\n-    pub const ROOT: UniverseIndex = UniverseIndex(0);\n+    pub fn root() -> UniverseIndex {\n+        UniverseIndex(0)\n+    }\n \n     /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n     /// So, for example, suppose we have this type in universe `U`:\n@@ -1364,26 +1366,7 @@ impl UniverseIndex {\n     /// region `'a`, but that region was not nameable from `U` because\n     /// it was not in scope there.\n     pub fn subuniverse(self) -> UniverseIndex {\n-        UniverseIndex(self.0.checked_add(1).unwrap())\n-    }\n-\n-    pub fn from(v: u32) -> UniverseIndex {\n-        UniverseIndex(v)\n-    }\n-\n-    pub fn as_u32(&self) -> u32 {\n-        self.0\n-    }\n-\n-    pub fn as_usize(&self) -> usize {\n-        self.0 as usize\n-    }\n-\n-    /// Gets the \"depth\" of this universe in the universe tree. This\n-    /// is not really useful except for e.g. the `HashStable`\n-    /// implementation\n-    pub fn depth(&self) -> u32 {\n-        self.0\n+        UniverseIndex(self.0 + 1)\n     }\n }\n \n@@ -1401,17 +1384,6 @@ pub struct ParamEnv<'tcx> {\n     /// want `Reveal::All` -- note that this is always paired with an\n     /// empty environment. To get that, use `ParamEnv::reveal()`.\n     pub reveal: traits::Reveal,\n-\n-    /// What is the innermost universe we have created? Starts out as\n-    /// `UniverseIndex::root()` but grows from there as we enter\n-    /// universal quantifiers.\n-    ///\n-    /// NB: At present, we exclude the universal quantifiers on the\n-    /// item we are type-checking, and just consider those names as\n-    /// part of the root universe. So this would only get incremented\n-    /// when we enter into a higher-ranked (`for<..>`) type or trait\n-    /// bound.\n-    pub universe: UniverseIndex,\n }\n \n impl<'tcx> ParamEnv<'tcx> {\n@@ -1420,7 +1392,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Trait`) are left hidden, so this is suitable for ordinary\n     /// type-checking.\n     pub fn empty() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::UserFacing, ty::UniverseIndex::ROOT)\n+        Self::new(ty::Slice::empty(), Reveal::UserFacing)\n     }\n \n     /// Construct a trait environment with no where clauses in scope\n@@ -1431,15 +1403,14 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// NB. If you want to have predicates in scope, use `ParamEnv::new`,\n     /// or invoke `param_env.with_reveal_all()`.\n     pub fn reveal_all() -> Self {\n-        Self::new(ty::Slice::empty(), Reveal::All, ty::UniverseIndex::ROOT)\n+        Self::new(ty::Slice::empty(), Reveal::All)\n     }\n \n     /// Construct a trait environment with the given set of predicates.\n     pub fn new(caller_bounds: &'tcx ty::Slice<ty::Predicate<'tcx>>,\n-               reveal: Reveal,\n-               universe: ty::UniverseIndex)\n+               reveal: Reveal)\n                -> Self {\n-        ty::ParamEnv { caller_bounds, reveal, universe }\n+        ty::ParamEnv { caller_bounds, reveal }\n     }\n \n     /// Returns a new parameter environment with the same clauses, but\n@@ -2731,8 +2702,7 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // sure that this will succeed without errors anyway.\n \n     let unnormalized_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n-                                             traits::Reveal::UserFacing,\n-                                             ty::UniverseIndex::ROOT);\n+                                             traits::Reveal::UserFacing);\n \n     let body_id = tcx.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n         tcx.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)"}, {"sha": "8cf662ccaea9254f9421c5ee4d37a504b828662f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -280,7 +280,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n         tcx.lift(&self.caller_bounds).map(|caller_bounds| {\n             ty::ParamEnv {\n                 reveal: self.reveal,\n-                universe: self.universe,\n                 caller_bounds,\n             }\n         })\n@@ -738,29 +737,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::ParamEnv {\n-            reveal: self.reveal,\n-            caller_bounds: self.caller_bounds.fold_with(folder),\n-            universe: self.universe.fold_with(folder),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let &ty::ParamEnv { reveal: _, ref universe, ref caller_bounds } = self;\n-        universe.super_visit_with(visitor) || caller_bounds.super_visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for ty::UniverseIndex {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ty::ParamEnv<'tcx> { reveal, caller_bounds }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {"}, {"sha": "ed04d41ba1457fbfddb518db98a4928884b7d4a9", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -1028,7 +1028,7 @@ pub enum RegionKind {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(ty::UniverseIndex, BoundRegion),\n+    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1082,6 +1082,11 @@ newtype_index!(RegionVid\n         DEBUG_FORMAT = custom,\n     });\n \n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+pub struct SkolemizedRegionVid {\n+    pub index: u32,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),"}, {"sha": "d27cda4040e5646bf249eeb85e7564efe8c4a6f0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -793,7 +793,7 @@ define_print! {\n                 }\n \n                 ty::ReSkolemized(id, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({:?}, {:?})\", id, bound_region)\n+                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),"}, {"sha": "9efd8844977f905e7bf41fa15a25dee7e19b367a", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -455,8 +455,7 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                             TypeVariableOrigin::MiscVariable(DUMMY_SP));\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));"}, {"sha": "ae373fbad22465cc034cc68c644883cdd2ab99ea", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -296,7 +296,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n                     // FIXME: MiscVariable for now, obtaining the span and name information\n                     //       from all tuple elements isn't trivial.\n-                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys));\n@@ -307,8 +306,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 pat_ty\n             }\n             PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                                TypeVariableOrigin::TypeInference(inner.span));\n+                let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));\n                 let uniq_ty = tcx.mk_box(inner_ty);\n \n                 if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -341,7 +339,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         _ => {\n                             let inner_ty = self.next_ty_var(\n-                                ty::UniverseIndex::ROOT,\n                                 TypeVariableOrigin::TypeInference(inner.span));\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n@@ -600,8 +597,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                          TypeVariableOrigin::TypeInference(discrim.span));\n+            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type_or_error(discrim, discrim_ty);\n         };\n \n@@ -662,8 +658,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 // arm for inconsistent arms or to the whole match when a `()` type\n                 // is required).\n                 Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n-                _ => self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                      TypeVariableOrigin::MiscVariable(expr.span)),\n+                _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n             };\n             CoerceMany::with_coercion_sites(coerce_first, arms)\n         };"}, {"sha": "68b0560355fc3d4ca40c03760eeb2c8bc4199862", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -110,8 +110,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |_, _| span_bug!(expr.span, \"closure has region param\"),\n             |_, _| {\n                 self.infcx\n-                    .next_ty_var(ty::UniverseIndex::ROOT,\n-                                 TypeVariableOrigin::ClosureSynthetic(expr.span))\n+                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n             },\n         );\n         let substs = ty::ClosureSubsts { substs };"}, {"sha": "bc8f107951b144c54ff4d9af452a4c9a285917cf", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -176,7 +176,6 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n-                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n                 self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n@@ -510,7 +509,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n-        let coerce_target = self.next_ty_var(ty::UniverseIndex::ROOT, origin);\n+        let coerce_target = self.next_ty_var(origin);\n         let mut coercion = self.unify_and(coerce_target, target, |target| {\n             let unsize = Adjustment {\n                 kind: Adjust::Unsize,"}, {"sha": "e1e3dea9a2a11c83167f7e34dce34e5adcd7ad9d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -218,8 +218,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // the new hybrid bounds we computed.\n     let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n     let param_env = ty::ParamEnv::new(tcx.intern_predicates(&hybrid_preds.predicates),\n-                                      Reveal::UserFacing,\n-                                      ty::UniverseIndex::ROOT);\n+                                      Reveal::UserFacing);\n     let param_env = traits::normalize_param_env_or_error(tcx,\n                                                          impl_m.def_id,\n                                                          param_env,"}, {"sha": "b8aa39a202bee18c054f22fd26629e745550f24f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -90,7 +90,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(ty::UniverseIndex::ROOT, drop_impl_span, drop_impl_did);\n+            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);"}, {"sha": "a3233c8d8659958b86161627cb164d88d9ea1906", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.fresh_substs_for_item(ty::UniverseIndex::ROOT, self.span, trait_def_id)\n+                self.fresh_substs_for_item(self.span, trait_def_id)\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             {\n                 self.to_ty(ast_ty)\n             } else {\n-                self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n+                self.type_var_for_def(self.span, def)\n             }\n         })\n     }"}, {"sha": "e33e4c518924ed70d05251e5262ef2c708117a1c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else if let Some(ref input_types) = opt_input_types {\n                 input_types[def.index as usize - 1]\n             } else {\n-                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n+                self.type_var_for_def(span, def)\n             }\n         });\n "}, {"sha": "fa2022e8cc994ea5ddff0685719f413c5cd7be15", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -736,9 +736,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             Def::Method(def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n-                    let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT,\n-                                                            self.span,\n-                                                            method.def_id);\n+                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n                     let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &fty);\n@@ -1389,7 +1387,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if i < substs.len() {\n                     substs.type_at(i)\n                 } else {\n-                    self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n+                    self.type_var_for_def(self.span, def)\n                 }\n             });\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1406,7 +1404,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                          def_id,\n                          |_, _| self.tcx.types.re_erased,\n                          |_, _| self.next_ty_var(\n-                             ty::UniverseIndex::ROOT,\n                              TypeVariableOrigin::SubstitutionPlaceholder(\n                                  self.tcx.def_span(def_id))))\n     }"}, {"sha": "c4d98c8a2abb536b7bdc36caf9436eb7035b7286", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -56,8 +56,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     self.probe(|_| {\n                         let fn_once_substs = tcx.mk_substs_trait(ty,\n-                            &[self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                               TypeVariableOrigin::MiscVariable(span))]);\n+                            &[self.next_ty_var(TypeVariableOrigin::MiscVariable(span))]);\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation ="}, {"sha": "187f220f7f830b5bb906a339f08c88be047af0e6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -362,8 +362,7 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// hard constraint exists, creates a fresh type variable.\n     fn coercion_target_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, span: Span) -> Ty<'tcx> {\n         self.only_has_type(fcx)\n-            .unwrap_or_else(|| fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                               TypeVariableOrigin::MiscVariable(span)))\n+            .unwrap_or_else(|| fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span)))\n     }\n }\n \n@@ -938,8 +937,7 @@ impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                                  TypeVariableOrigin::TypeInference(span));\n+                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n                 self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -1052,8 +1050,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let span = body.value.span;\n \n     if body.is_generator && can_be_generator.is_some() {\n-        let yield_ty = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                       TypeVariableOrigin::TypeInference(span));\n+        let yield_ty = fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n         fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n         fcx.yield_ty = Some(yield_ty);\n     }\n@@ -1086,8 +1083,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n     let gen_ty = if can_be_generator.is_some() && body.is_generator {\n-        let witness = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                      TypeVariableOrigin::MiscVariable(span));\n+        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n         let interior = ty::GeneratorInterior {\n             witness,\n             movable: can_be_generator.unwrap() == hir::GeneratorMovability::Movable,\n@@ -1125,7 +1121,6 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut actual_return_ty = coercion.complete(&fcx);\n     if actual_return_ty.is_never() {\n         actual_return_ty = fcx.next_diverging_ty_var(\n-            ty::UniverseIndex::ROOT,\n             TypeVariableOrigin::DivergingFn(span));\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n@@ -1738,14 +1733,13 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.next_ty_var(ty::UniverseIndex::ROOT,\n-                         TypeVariableOrigin::TypeInference(span))\n+        self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n     }\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef,\n                         span: Span) -> Ty<'tcx> {\n-        self.type_var_for_def(ty::UniverseIndex::ROOT, span, ty_param_def)\n+        self.type_var_for_def(span, ty_param_def)\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -2370,8 +2364,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If some lookup succeeds, write callee into table and extract index/element\n             // type from the method signature.\n             // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                            TypeVariableOrigin::AutoDeref(base_expr.span));\n+            let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n             let method = self.try_overloaded_place_op(\n                 expr.span, self_ty, &[input_ty], needs, PlaceOp::Index);\n \n@@ -2810,7 +2803,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n-                ty::UniverseIndex::ROOT,\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n             self.apply_adjustments(expr, vec![Adjustment {\n                 kind: Adjust::NeverToAny,\n@@ -2888,7 +2880,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ity = self.tcx.type_of(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT, span, did);\n+        let substs = self.fresh_substs_for_item(span, did);\n         let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -4021,8 +4013,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               let element_ty = if !args.is_empty() {\n                   let coerce_to = uty.unwrap_or_else(\n-                      || self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                          TypeVariableOrigin::TypeInference(expr.span)));\n+                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n                   let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n                   assert_eq!(self.diverges.get(), Diverges::Maybe);\n                   for e in args {\n@@ -4032,8 +4023,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n                   coerce.complete(self)\n               } else {\n-                  self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                   TypeVariableOrigin::TypeInference(expr.span))\n+                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n               };\n               tcx.mk_array(element_ty, args.len() as u64)\n           }\n@@ -4073,8 +4063,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (uty, uty)\n                 }\n                 None => {\n-                    let t: Ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                                                 TypeVariableOrigin::MiscVariable(element.span));\n+                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n                     let element_ty = self.check_expr_has_type_or_error(&element, t);\n                     (element_ty, t)\n                 }\n@@ -4853,7 +4842,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n                     return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n+                        self.type_var_for_def(span, def)\n                     });\n                 }\n                 i -= has_self as usize;\n@@ -4886,7 +4875,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This can also be reached in some error cases:\n                 // We prefer to use inference variables instead of\n                 // TyError to let type inference recover somewhat.\n-                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n+                self.type_var_for_def(span, def)\n             }\n         });\n "}, {"sha": "faebb370a6c46eb5a07ff285c3c051d1a2c258c7", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -174,10 +174,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_needs(\n-            lhs_expr,\n-            self.next_ty_var(ty::UniverseIndex::ROOT,\n-                             TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n+        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n+            self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n             lhs_needs);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n@@ -187,8 +185,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // using this variable as the expected type, which sometimes lets\n         // us do better coercions than we would be able to do otherwise,\n         // particularly for things like `String + &String`.\n-        let rhs_ty_var = self.next_ty_var(ty::UniverseIndex::ROOT,\n-                         TypeVariableOrigin::MiscVariable(rhs_expr.span));\n+        let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n "}, {"sha": "fe4f785aa915ee9de5795d402b89419b9b8f1d68", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca14701a5fa9cfcf91e438f1bef0eddb3c22f93/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=dca14701a5fa9cfcf91e438f1bef0eddb3c22f93", "patch": "@@ -685,14 +685,12 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             new_env = ty::ParamEnv::new(\n                 tcx.mk_predicates(normalized_preds),\n                 param_env.reveal,\n-                ty::UniverseIndex::ROOT,\n             );\n         }\n \n         let final_user_env = ty::ParamEnv::new(\n             tcx.mk_predicates(user_computed_preds.into_iter()),\n             user_env.reveal,\n-            ty::UniverseIndex::ROOT,\n         );\n         debug!(\n             \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\"}]}