{"sha": "6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYTdjM2Y3OWVkMzc3NTkxMmM5ZWM1ZGI4YTgyNGRlZTY0NmU0ZGQ=", "commit": {"author": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-08-22T15:27:43Z"}, "committer": {"name": "LinkTed", "email": "LinkTed@users.noreply.github.com", "date": "2020-10-10T13:19:11Z"}, "message": "Split net.rs into multiple files", "tree": {"sha": "e39c3f3a9f4ed132fc2516ae629226df25ae0618", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e39c3f3a9f4ed132fc2516ae629226df25ae0618"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "html_url": "https://github.com/rust-lang/rust/commit/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/comments", "author": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LinkTed", "id": 6806266, "node_id": "MDQ6VXNlcjY4MDYyNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6806266?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LinkTed", "html_url": "https://github.com/LinkTed", "followers_url": "https://api.github.com/users/LinkTed/followers", "following_url": "https://api.github.com/users/LinkTed/following{/other_user}", "gists_url": "https://api.github.com/users/LinkTed/gists{/gist_id}", "starred_url": "https://api.github.com/users/LinkTed/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LinkTed/subscriptions", "organizations_url": "https://api.github.com/users/LinkTed/orgs", "repos_url": "https://api.github.com/users/LinkTed/repos", "events_url": "https://api.github.com/users/LinkTed/events{/privacy}", "received_events_url": "https://api.github.com/users/LinkTed/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "html_url": "https://github.com/rust-lang/rust/commit/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb"}], "stats": {"total": 5932, "additions": 3297, "deletions": 2635}, "files": [{"sha": "c72800b5d573ac8a4fb1d5b223f23fcfa4c1f6dd", "filename": "library/std/src/sys/unix/ext/net.rs", "status": "removed", "additions": 0, "deletions": 2635, "changes": 2635, "blob_url": "https://github.com/rust-lang/rust/blob/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs?ref=0b3c9d84656a86cb3c57b20fff6bef5f8f2aeabb", "patch": "@@ -1,2635 +0,0 @@\n-//! Unix-specific networking functionality.\n-\n-#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests;\n-\n-// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n-#[cfg(not(unix))]\n-#[allow(non_camel_case_types)]\n-mod libc {\n-    pub use libc::c_int;\n-    pub type socklen_t = u32;\n-    pub struct sockaddr;\n-    #[derive(Clone)]\n-    pub struct sockaddr_un;\n-}\n-\n-use crate::ascii;\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{self, Shutdown};\n-use crate::os::unix::ffi::OsStrExt;\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n-use crate::path::Path;\n-use crate::ptr::null_mut;\n-use crate::slice::from_raw_parts;\n-use crate::sys::net::Socket;\n-use crate::sys::unix::net::{add_to_ancillary_data, AncillaryDataIter};\n-use crate::sys::{self, cvt};\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-use crate::time::Duration;\n-\n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"linux\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\"\n-))]\n-use crate::os::unix::ucred;\n-\n-#[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"linux\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\"\n-))]\n-pub use ucred::UCred;\n-\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-))]\n-use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-)))]\n-const MSG_NOSIGNAL: libc::c_int = 0x0;\n-\n-fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n-    // Work with an actual instance of the type since using a null pointer is UB\n-    let base = addr as *const _ as usize;\n-    let path = &addr.sun_path as *const _ as usize;\n-    path - base\n-}\n-\n-unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n-    let mut addr: libc::sockaddr_un = mem::zeroed();\n-    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-    let bytes = path.as_os_str().as_bytes();\n-\n-    if bytes.contains(&0) {\n-        return Err(io::Error::new(\n-            io::ErrorKind::InvalidInput,\n-            \"paths may not contain interior null bytes\",\n-        ));\n-    }\n-\n-    if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new(\n-            io::ErrorKind::InvalidInput,\n-            \"path must be shorter than SUN_LEN\",\n-        ));\n-    }\n-    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n-        *dst = *src as libc::c_char;\n-    }\n-    // null byte for pathname addresses is already there because we zeroed the\n-    // struct\n-\n-    let mut len = sun_path_offset(&addr) + bytes.len();\n-    match bytes.get(0) {\n-        Some(&0) | None => {}\n-        Some(_) => len += 1,\n-    }\n-    Ok((addr, len as libc::socklen_t))\n-}\n-\n-fn recv_vectored_with_ancillary_from(\n-    socket: &Socket,\n-    bufs: &mut [IoSliceMut<'_>],\n-    ancillary: &mut SocketAncillary<'_>,\n-) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n-    unsafe {\n-        let mut msg_name: libc::sockaddr_un = mem::zeroed();\n-\n-        let mut msg = libc::msghdr {\n-            msg_name: &mut msg_name as *mut _ as *mut _,\n-            msg_namelen: mem::size_of::<libc::sockaddr_un>() as libc::socklen_t,\n-            msg_iov: bufs.as_mut_ptr().cast(),\n-            msg_iovlen: bufs.len(),\n-            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n-            msg_controllen: ancillary.buffer.len(),\n-            msg_flags: 0,\n-        };\n-\n-        let count = socket.recv_msg(&mut msg)?;\n-\n-        ancillary.length = msg.msg_controllen;\n-        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n-\n-        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n-        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);\n-\n-        Ok((count, truncated, addr))\n-    }\n-}\n-\n-fn send_vectored_with_ancillary_to(\n-    socket: &Socket,\n-    path: Option<&Path>,\n-    bufs: &mut [IoSliceMut<'_>],\n-    ancillary: &mut SocketAncillary<'_>,\n-) -> io::Result<usize> {\n-    unsafe {\n-        let (mut msg_name, msg_namelen) =\n-            if let Some(path) = path { sockaddr_un(path)? } else { (mem::zeroed(), 0) };\n-\n-        let mut msg = libc::msghdr {\n-            msg_name: &mut msg_name as *mut _ as *mut _,\n-            msg_namelen,\n-            msg_iov: bufs.as_mut_ptr().cast(),\n-            msg_iovlen: bufs.len(),\n-            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n-            msg_controllen: ancillary.length,\n-            msg_flags: 0,\n-        };\n-\n-        ancillary.truncated = false;\n-\n-        socket.send_msg(&mut msg)\n-    }\n-}\n-\n-enum AddressKind<'a> {\n-    Unnamed,\n-    Pathname(&'a Path),\n-    Abstract(&'a [u8]),\n-}\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n-}\n-\n-impl SocketAddr {\n-    fn new<F>(f: F) -> io::Result<SocketAddr>\n-    where\n-        F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int,\n-    {\n-        unsafe {\n-            let mut addr: libc::sockaddr_un = mem::zeroed();\n-            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n-            SocketAddr::from_parts(addr, len)\n-        }\n-    }\n-\n-    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n-        if len == 0 {\n-            // When there is a datagram from unnamed unix socket\n-            // linux returns zero bytes of address\n-            len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n-        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"file descriptor did not correspond to a Unix socket\",\n-            ));\n-        }\n-\n-        Ok(SocketAddr { addr, len })\n-    }\n-\n-    /// Returns `true` if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.is_unnamed(), false);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.is_unnamed(), true);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        if let AddressKind::Unnamed = self.address() { true } else { false }\n-    }\n-\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.as_pathname(), None);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n-    }\n-\n-    fn address(&self) -> AddressKind<'_> {\n-        let len = self.len as usize - sun_path_offset(&self.addr);\n-        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n-\n-        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n-        if len == 0\n-            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n-                && self.addr.sun_path[0] == 0)\n-        {\n-            AddressKind::Unnamed\n-        } else if self.addr.sun_path[0] == 0 {\n-            AddressKind::Abstract(&path[1..len])\n-        } else {\n-            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.address() {\n-            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n-            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n-            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n-        }\n-    }\n-}\n-\n-#[cfg(any(\n-    target_os = \"haiku\",\n-    target_os = \"solaris\",\n-    target_os = \"illumos\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-pub struct ScmRights<'a>(AncillaryDataIter<'a, RawFd>);\n-\n-#[cfg(any(\n-    target_os = \"haiku\",\n-    target_os = \"solaris\",\n-    target_os = \"illumos\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-impl<'a> Iterator for ScmRights<'a> {\n-    type Item = RawFd;\n-\n-    fn next(&mut self) -> Option<RawFd> {\n-        self.0.next()\n-    }\n-}\n-\n-#[cfg(any(\n-    target_os = \"netbsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::ucred>);\n-\n-#[cfg(any(\n-    target_os = \"netbsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-impl<'a> Iterator for ScmCredentials<'a> {\n-    type Item = libc::ucred;\n-\n-    fn next(&mut self) -> Option<libc::ucred> {\n-        self.0.next()\n-    }\n-}\n-\n-#[cfg(any(\n-    target_os = \"haiku\",\n-    target_os = \"solaris\",\n-    target_os = \"illumos\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-pub enum AncillaryData<'a> {\n-    ScmRights(ScmRights<'a>),\n-    #[cfg(any(\n-        target_os = \"netbsd\",\n-        target_os = \"openbsd\",\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_env = \"uclibc\",\n-    ))]\n-    ScmCredentials(ScmCredentials<'a>),\n-}\n-\n-impl<'a> AncillaryData<'a> {\n-    #[cfg(any(\n-        target_os = \"haiku\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"openbsd\",\n-        target_os = \"netbsd\",\n-        target_os = \"linux\",\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_env = \"uclibc\",\n-    ))]\n-    fn as_rights(data: &'a [u8]) -> Self {\n-        let ancillary_data_iter = AncillaryDataIter::new(data);\n-        let scm_rights = ScmRights(ancillary_data_iter);\n-        AncillaryData::ScmRights(scm_rights)\n-    }\n-\n-    #[cfg(any(\n-        target_os = \"netbsd\",\n-        target_os = \"openbsd\",\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_env = \"uclibc\",\n-    ))]\n-    fn as_credentials(data: &'a [u8]) -> Self {\n-        let ancillary_data_iter = AncillaryDataIter::new(data);\n-        let scm_credentials = ScmCredentials(ancillary_data_iter);\n-        AncillaryData::ScmCredentials(scm_credentials)\n-    }\n-}\n-\n-#[cfg(any(\n-    target_os = \"haiku\",\n-    target_os = \"solaris\",\n-    target_os = \"illumos\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-impl<'a> AncillaryData<'a> {\n-    fn from(cmsg: &'a libc::cmsghdr) -> Self {\n-        unsafe {\n-            let cmsg_len_zero = libc::CMSG_LEN(0) as usize;\n-            let data_len = (*cmsg).cmsg_len - cmsg_len_zero;\n-            let data = libc::CMSG_DATA(cmsg).cast();\n-            let data = from_raw_parts(data, data_len);\n-\n-            if (*cmsg).cmsg_level == libc::SOL_SOCKET {\n-                match (*cmsg).cmsg_type {\n-                    libc::SCM_RIGHTS => AncillaryData::as_rights(data),\n-                    #[cfg(any(\n-                        target_os = \"linux\",\n-                        target_os = \"android\",\n-                        target_os = \"emscripten\",\n-                        target_os = \"fuchsia\",\n-                        target_env = \"uclibc\",\n-                    ))]\n-                    libc::SCM_CREDENTIALS => AncillaryData::as_credentials(data),\n-                    #[cfg(any(\n-                        target_os = \"netbsd\",\n-                        target_os = \"openbsd\",\n-                        target_os = \"freebsd\",\n-                        target_os = \"dragonfly\",\n-                        target_os = \"macos\",\n-                        target_os = \"ios\",\n-                    ))]\n-                    libc::SCM_CREDS => AncillaryData::as_credentials(data),\n-                    _ => panic!(\"Unknown cmsg type\"),\n-                }\n-            } else {\n-                panic!(\"Unknown cmsg level\");\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(any(\n-    target_os = \"haiku\",\n-    target_os = \"solaris\",\n-    target_os = \"illumos\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-pub struct Messages<'a> {\n-    buffer: &'a [u8],\n-    current: Option<&'a libc::cmsghdr>,\n-}\n-\n-#[cfg(any(\n-    target_os = \"haiku\",\n-    target_os = \"solaris\",\n-    target_os = \"illumos\",\n-    target_os = \"macos\",\n-    target_os = \"ios\",\n-    target_os = \"freebsd\",\n-    target_os = \"dragonfly\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"emscripten\",\n-    target_os = \"fuchsia\",\n-    target_env = \"uclibc\",\n-))]\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-impl<'a> Iterator for Messages<'a> {\n-    type Item = AncillaryData<'a>;\n-\n-    fn next(&mut self) -> Option<AncillaryData<'a>> {\n-        unsafe {\n-            let msg = libc::msghdr {\n-                msg_name: null_mut(),\n-                msg_namelen: 0,\n-                msg_iov: null_mut(),\n-                msg_iovlen: 0,\n-                msg_control: self.buffer.as_ptr() as *mut _,\n-                msg_controllen: self.buffer.len(),\n-                msg_flags: 0,\n-            };\n-\n-            let cmsg = if let Some(current) = self.current {\n-                libc::CMSG_NXTHDR(&msg, current)\n-            } else {\n-                libc::CMSG_FIRSTHDR(&msg)\n-            };\n-\n-            let cmsg = cmsg.as_ref()?;\n-            self.current = Some(cmsg);\n-            let ancillary_data = AncillaryData::from(cmsg);\n-            Some(ancillary_data)\n-        }\n-    }\n-}\n-\n-/// A Unix socket Ancillary data struct.\n-///\n-/// # Example\n-/// ```no_run\n-/// #![feature(unix_socket_ancillary_data)]\n-/// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n-/// use std::io::IoSliceMut;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n-///\n-///     let mut fds = [0; 8];\n-///     let mut ancillary_buffer = [0; 128];\n-///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-///\n-///     let mut buf = [1; 8];\n-///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n-///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n-///\n-///     for ancillary_data in ancillary.messages() {\n-///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n-///             for fd in scm_rights {\n-///                 println!(\"receive file descriptor: {}\", fd);\n-///             }\n-///         }\n-///     }\n-///     Ok(())\n-/// }\n-/// ```\n-#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-#[derive(Debug)]\n-pub struct SocketAncillary<'a> {\n-    buffer: &'a mut [u8],\n-    length: usize,\n-    truncated: bool,\n-}\n-\n-impl<'a> SocketAncillary<'a> {\n-    /// Create an ancillary data with the given buffer.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// # #![allow(unused_mut)]\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::SocketAncillary;\n-    /// let mut ancillary_buffer = [0; 128];\n-    /// let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn new(buffer: &'a mut [u8]) -> Self {\n-        SocketAncillary { buffer, length: 0, truncated: false }\n-    }\n-\n-    /// Returns the capacity of the buffer.\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn capacity(&self) -> usize {\n-        self.buffer.len()\n-    }\n-\n-    /// Returns the number of used bytes.\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn len(&self) -> usize {\n-        self.length\n-    }\n-\n-    #[cfg(any(\n-        target_os = \"haiku\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"openbsd\",\n-        target_os = \"netbsd\",\n-        target_os = \"linux\",\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_env = \"uclibc\",\n-    ))]\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn messages(&'a self) -> Messages<'a> {\n-        Messages { buffer: &self.buffer[..self.length], current: None }\n-    }\n-\n-    /// Is `true` if during a recv operation the ancillary was truncated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n-    ///\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///\n-    ///     let mut buf = [1; 8];\n-    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n-    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n-    ///\n-    ///     println!(\"Is truncated: {}\", ancillary.truncated());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn truncated(&self) -> bool {\n-        self.truncated\n-    }\n-\n-    /// Add file descriptors to the ancillary data.\n-    ///\n-    /// The function returns `true` if there was enough space in the buffer.\n-    /// If there was not enough space then no file descriptors was appended.\n-    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n-    /// and type `SCM_RIGHTS`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n-    /// use std::os::unix::io::AsRawFd;\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n-    ///\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     ancillary.add_fds(&[sock.as_raw_fd()][..]);\n-    ///\n-    ///     let mut buf = [1; 8];\n-    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n-    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary)?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[cfg(any(\n-        target_os = \"haiku\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"openbsd\",\n-        target_os = \"netbsd\",\n-        target_os = \"linux\",\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_env = \"uclibc\",\n-    ))]\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn add_fds(&mut self, fds: &[RawFd]) -> bool {\n-        self.truncated = false;\n-        add_to_ancillary_data(\n-            &mut self.buffer,\n-            &mut self.length,\n-            fds,\n-            libc::SOL_SOCKET,\n-            libc::SCM_RIGHTS,\n-        )\n-    }\n-\n-    /// Add credentials to the ancillary data.\n-    ///\n-    /// The function returns `true` if there was enough space in the buffer.\n-    /// If there was not enough space then no credentials was appended.\n-    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n-    /// and type `SCM_CREDENTIALS`.\n-    ///\n-    #[cfg(any(\n-        target_os = \"netbsd\",\n-        target_os = \"openbsd\",\n-        target_os = \"freebsd\",\n-        target_os = \"dragonfly\",\n-        target_os = \"macos\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_env = \"uclibc\",\n-    ))]\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn add_creds(&mut self, creds: &[libc::ucred]) -> bool {\n-        self.truncated = false;\n-        add_to_ancillary_data(\n-            &mut self.buffer,\n-            &mut self.length,\n-            creds,\n-            libc::SOL_SOCKET,\n-            #[cfg(any(\n-                target_os = \"linux\",\n-                target_os = \"android\",\n-                target_os = \"emscripten\",\n-                target_os = \"fuchsia\",\n-                target_env = \"uclibc\",\n-            ))]\n-            libc::SCM_CREDENTIALS,\n-            #[cfg(any(\n-                target_os = \"netbsd\",\n-                target_os = \"openbsd\",\n-                target_os = \"freebsd\",\n-                target_os = \"dragonfly\",\n-                target_os = \"macos\",\n-                target_os = \"ios\",\n-            ))]\n-            libc::SCM_CREDS,\n-        )\n-    }\n-\n-    /// Clears the ancillary data, removing all values.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n-    ///\n-    ///     let mut fds1 = [0; 8];\n-    ///     let mut fds2 = [0; 8];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///\n-    ///     let mut buf = [1; 8];\n-    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n-    ///\n-    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n-    ///     for ancillary_data in ancillary.messages() {\n-    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n-    ///             for fd in scm_rights {\n-    ///                 println!(\"receive file descriptor: {}\", fd);\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///\n-    ///     ancillary.clear();\n-    ///\n-    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n-    ///     for ancillary_data in ancillary.messages() {\n-    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n-    ///             for fd in scm_rights {\n-    ///                 println!(\"receive file descriptor: {}\", fd);\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn clear(&mut self) {\n-        self.length = 0;\n-        self.truncated = false;\n-    }\n-}\n-\n-struct AsciiEscaped<'a>(&'a [u8]);\n-\n-impl<'a> fmt::Display for AsciiEscaped<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"\\\"\")?;\n-        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            write!(fmt, \"{}\", byte as char)?;\n-        }\n-        write!(fmt, \"\\\"\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let mut stream = UnixStream::connect(\"/path/to/my/socket\")?;\n-///     stream.write_all(b\"hello world\")?;\n-///     let mut response = String::new();\n-///     stream.read_to_string(&mut response)?;\n-///     println!(\"{}\", response);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        fn inner(path: &Path) -> io::Result<UnixStream> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n-                Ok(UnixStream(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-        Ok((UnixStream(i1), UnixStream(i2)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Gets the peer credentials for this Unix domain socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(peer_credentials_unix_socket)]\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let peer_cred = socket.peer_cred().expect(\"Couldn't get peer credentials\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n-    #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"linux\",\n-        target_os = \"dragonfly\",\n-        target_os = \"freebsd\",\n-        target_os = \"ios\",\n-        target_os = \"macos\",\n-        target_os = \"openbsd\"\n-    ))]\n-    pub fn peer_cred(&self) -> io::Result<UCred> {\n-        ucred::peer_cred(self)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`read`]: io::Read::read\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`read`]: io::Read::read\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"Couldn't set write timeout\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n-    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    ///     assert_eq!(socket.read_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"Couldn't set write timeout\");\n-    ///     assert_eq!(socket.write_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     if let Ok(Some(err)) = socket.take_error() {\n-    ///         println!(\"Got error: {:?}\", err);\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-\n-    /// Receives data and ancillary data from socket.\n-    ///\n-    /// On success, returns the number of bytes read.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let mut buf1 = [1; 8];\n-    ///     let mut buf2 = [2; 16];\n-    ///     let mut buf3 = [3; 8];\n-    ///     let mut bufs = &mut [\n-    ///         IoSliceMut::new(&mut buf1),\n-    ///         IoSliceMut::new(&mut buf2),\n-    ///         IoSliceMut::new(&mut buf3),\n-    ///     ][..];\n-    ///     let mut fds = [0; 8];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     let size = socket.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n-    ///     println!(\"received {}\", size);\n-    ///     for ancillary_data in ancillary.messages() {\n-    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n-    ///             for fd in scm_rights {\n-    ///                 println!(\"receive file descriptor: {}\", fd);\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn recv_vectored_with_ancillary(\n-        &self,\n-        bufs: &mut [IoSliceMut<'_>],\n-        ancillary: &mut SocketAncillary<'_>,\n-    ) -> io::Result<usize> {\n-        let (count, _, _) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n-\n-        Ok(count)\n-    }\n-\n-    /// Sends data and ancillary data on the socket.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let mut buf1 = [1; 8];\n-    ///     let mut buf2 = [2; 16];\n-    ///     let mut buf3 = [3; 8];\n-    ///     let mut bufs = &mut [\n-    ///         IoSliceMut::new(&mut buf1),\n-    ///         IoSliceMut::new(&mut buf2),\n-    ///         IoSliceMut::new(&mut buf3),\n-    ///     ][..];\n-    ///     let fds = [0, 1, 2];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     ancillary.add_fds(&fds[..]);\n-    ///     socket.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn send_vectored_with_ancillary(\n-        &self,\n-        bufs: &mut [IoSliceMut<'_>],\n-        ancillary: &mut SocketAncillary<'_>,\n-    ) -> io::Result<usize> {\n-        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n-    }\n-\n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n-    ///\n-    /// Successive calls return the same data. This is accomplished by passing\n-    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_peek)]\n-    ///\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let mut buf = [0; 10];\n-    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.peek(buf)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::Read::read_vectored(&mut &*self, bufs)\n-    }\n-\n-    #[inline]\n-    fn is_read_vectored(&self) -> bool {\n-        io::Read::is_read_vectored(&&*self)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::Write::write_vectored(&mut &*self, bufs)\n-    }\n-\n-    #[inline]\n-    fn is_write_vectored(&self) -> bool {\n-        io::Write::is_write_vectored(&&*self)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-///\n-///     // accept connections and process them, spawning a new thread for each one\n-///     for stream in listener.incoming() {\n-///         match stream {\n-///             Ok(stream) => {\n-///                 /* connection succeeded */\n-///                 thread::spawn(|| handle_client(stream));\n-///             }\n-///             Err(err) => {\n-///                 /* connection failed */\n-///                 break;\n-///             }\n-///         }\n-///     }\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        fn inner(path: &Path) -> io::Result<UnixListener> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-                cvt(libc::listen(*inner.as_inner(), 128))?;\n-\n-                Ok(UnixListener(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: crate::os::unix::net::UnixStream\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///\n-    ///     match listener.accept() {\n-    ///         Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///         Err(e) => println!(\"accept function failed: {:?}\", e),\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n-        let addr = SocketAddr::from_parts(storage, len)?;\n-        Ok((UnixStream(sock), addr))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///     let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///     let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// This will result in the `accept` operation becoming nonblocking,\n-    /// i.e., immediately returning from their calls. If the IO operation is\n-    /// successful, `Ok` is returned and no further action is required. If the\n-    /// IO operation could not be completed and needs to be retried, an error\n-    /// with kind [`io::ErrorKind::WouldBlock`] is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///     listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/tmp/sock\")?;\n-    ///\n-    ///     if let Ok(Some(err)) = listener.take_error() {\n-    ///         println!(\"Got error: {:?}\", err);\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///\n-    ///     for stream in listener.incoming() {\n-    ///         match stream {\n-    ///             Ok(stream) => {\n-    ///                 thread::spawn(|| handle_client(stream));\n-    ///             }\n-    ///             Err(err) => {\n-    ///                 break;\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn incoming(&self) -> Incoming<'_> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-///\n-///     for stream in listener.incoming() {\n-///         match stream {\n-///             Ok(stream) => {\n-///                 thread::spawn(|| handle_client(stream));\n-///             }\n-///             Err(err) => {\n-///                 break;\n-///             }\n-///         }\n-///     }\n-///     Ok(())\n-/// }\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-/// A Unix datagram socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixDatagram;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let socket = UnixDatagram::bind(\"/path/to/my/socket\")?;\n-///     socket.send_to(b\"hello world\", \"/path/to/other/socket\")?;\n-///     let mut buf = [0; 100];\n-///     let (count, address) = socket.recv_from(&mut buf)?;\n-///     println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixDatagram(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixDatagram {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixDatagram {\n-    /// Creates a Unix datagram socket bound to the given path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't bind: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n-        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n-            unsafe {\n-                let socket = UnixDatagram::unbound()?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n-\n-                Ok(socket)\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates a Unix Datagram socket which is not bound to any address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::unbound() {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn unbound() -> io::Result<UnixDatagram> {\n-        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok(UnixDatagram(inner))\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixDatagrams`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let (sock1, sock2) = match UnixDatagram::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n-    }\n-\n-    /// Connects the socket to the specified address.\n-    ///\n-    /// The [`send`] method may be used to send data to the specified address.\n-    /// [`recv`] and [`recv_from`] will only receive data from that address.\n-    ///\n-    /// [`send`]: UnixDatagram::send\n-    /// [`recv`]: UnixDatagram::recv\n-    /// [`recv_from`]: UnixDatagram::recv_from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     match sock.connect(\"/path/to/the/socket\") {\n-    ///         Ok(sock) => sock,\n-    ///         Err(e) => {\n-    ///             println!(\"Couldn't connect: {:?}\", e);\n-    ///             return Err(e)\n-    ///         }\n-    ///     };\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n-\n-                Ok(())\n-            }\n-        }\n-        inner(self, path.as_ref())\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixDatagram` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one side will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n-    ///     let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n-        self.0.duplicate().map(UnixDatagram)\n-    }\n-\n-    /// Returns the address of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n-    ///     let addr = sock.local_addr().expect(\"Couldn't get local address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the address of this socket's peer.\n-    ///\n-    /// The [`connect`] method will connect the socket to a peer.\n-    ///\n-    /// [`connect`]: UnixDatagram::connect\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.connect(\"/path/to/the/socket\")?;\n-    ///\n-    ///     let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    fn recv_from_flags(\n-        &self,\n-        buf: &mut [u8],\n-        flags: libc::c_int,\n-    ) -> io::Result<(usize, SocketAddr)> {\n-        let mut count = 0;\n-        let addr = SocketAddr::new(|addr, len| unsafe {\n-            count = libc::recvfrom(\n-                *self.0.as_inner(),\n-                buf.as_mut_ptr() as *mut _,\n-                buf.len(),\n-                flags,\n-                addr,\n-                len,\n-            );\n-            if count > 0 {\n-                1\n-            } else if count == 0 {\n-                0\n-            } else {\n-                -1\n-            }\n-        })?;\n-\n-        Ok((count as usize, addr))\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read and the address from\n-    /// whence the data came.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     let mut buf = vec![0; 10];\n-    ///     let (size, sender) = sock.recv_from(buf.as_mut_slice())?;\n-    ///     println!(\"received {} bytes from {:?}\", size, sender);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_flags(buf, 0)\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n-    ///     let mut buf = vec![0; 10];\n-    ///     sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    /// Receives data and ancillary data from socket.\n-    ///\n-    /// On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     let mut buf1 = [1; 8];\n-    ///     let mut buf2 = [2; 16];\n-    ///     let mut buf3 = [3; 8];\n-    ///     let mut bufs = &mut [\n-    ///         IoSliceMut::new(&mut buf1),\n-    ///         IoSliceMut::new(&mut buf2),\n-    ///         IoSliceMut::new(&mut buf3),\n-    ///     ][..];\n-    ///     let mut fds = [0; 8];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;\n-    ///     println!(\"received {}\", size);\n-    ///     for ancillary_data in ancillary.messages() {\n-    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n-    ///             for fd in scm_rights {\n-    ///                 println!(\"receive file descriptor: {}\", fd);\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn recv_vectored_with_ancillary_from(\n-        &self,\n-        bufs: &mut [IoSliceMut<'_>],\n-        ancillary: &mut SocketAncillary<'_>,\n-    ) -> io::Result<(usize, bool, SocketAddr)> {\n-        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n-        let addr = addr?;\n-\n-        Ok((count, truncated, addr))\n-    }\n-\n-    /// Receives data and ancillary data from socket.\n-    ///\n-    /// On success, returns the number of bytes read and if the data was truncated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     let mut buf1 = [1; 8];\n-    ///     let mut buf2 = [2; 16];\n-    ///     let mut buf3 = [3; 8];\n-    ///     let mut bufs = &mut [\n-    ///         IoSliceMut::new(&mut buf1),\n-    ///         IoSliceMut::new(&mut buf2),\n-    ///         IoSliceMut::new(&mut buf3),\n-    ///     ][..];\n-    ///     let mut fds = [0; 8];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     let (size, _truncated) = sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n-    ///     println!(\"received {}\", size);\n-    ///     for ancillary_data in ancillary.messages() {\n-    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n-    ///             for fd in scm_rights {\n-    ///                 println!(\"receive file descriptor: {}\", fd);\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn recv_vectored_with_ancillary(\n-        &self,\n-        bufs: &mut [IoSliceMut<'_>],\n-        ancillary: &mut SocketAncillary<'_>,\n-    ) -> io::Result<(usize, bool)> {\n-        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n-        addr?;\n-\n-        Ok((count, truncated))\n-    }\n-\n-    /// Sends data on the socket to the specified address.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n-        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                let count = cvt(libc::sendto(\n-                    *d.0.as_inner(),\n-                    buf.as_ptr() as *const _,\n-                    buf.len(),\n-                    MSG_NOSIGNAL,\n-                    &addr as *const _ as *const _,\n-                    len,\n-                ))?;\n-                Ok(count as usize)\n-            }\n-        }\n-        inner(self, buf, path.as_ref())\n-    }\n-\n-    /// Sends data on the socket to the socket's peer.\n-    ///\n-    /// The peer address may be set by the `connect` method, and this method\n-    /// will return an error if the socket has not already been connected.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n-    ///     sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    /// Sends data and ancillary data on the socket to the specified address.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     let mut buf1 = [1; 8];\n-    ///     let mut buf2 = [2; 16];\n-    ///     let mut buf3 = [3; 8];\n-    ///     let mut bufs = &mut [\n-    ///         IoSliceMut::new(&mut buf1),\n-    ///         IoSliceMut::new(&mut buf2),\n-    ///         IoSliceMut::new(&mut buf3),\n-    ///     ][..];\n-    ///     let fds = [0, 1, 2];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     ancillary.add_fds(&fds[..]);\n-    ///     sock.send_vectored_with_ancillary_to(bufs, &mut ancillary, \"/some/sock\").expect(\"send_vectored_with_ancillary_to function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn send_vectored_with_ancillary_to<P: AsRef<Path>>(\n-        &self,\n-        bufs: &mut [IoSliceMut<'_>],\n-        ancillary: &mut SocketAncillary<'_>,\n-        path: P,\n-    ) -> io::Result<usize> {\n-        send_vectored_with_ancillary_to(&self.0, Some(path.as_ref()), bufs, ancillary)\n-    }\n-\n-    /// Sends data and ancillary data on the socket.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_ancillary_data)]\n-    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n-    /// use std::io::IoSliceMut;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     let mut buf1 = [1; 8];\n-    ///     let mut buf2 = [2; 16];\n-    ///     let mut buf3 = [3; 8];\n-    ///     let mut bufs = &mut [\n-    ///         IoSliceMut::new(&mut buf1),\n-    ///         IoSliceMut::new(&mut buf2),\n-    ///         IoSliceMut::new(&mut buf3),\n-    ///     ][..];\n-    ///     let fds = [0, 1, 2];\n-    ///     let mut ancillary_buffer = [0; 128];\n-    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n-    ///     ancillary.add_fds(&fds[..]);\n-    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n-    pub fn send_vectored_with_ancillary(\n-        &self,\n-        bufs: &mut [IoSliceMut<'_>],\n-        ancillary: &mut SocketAncillary<'_>,\n-    ) -> io::Result<usize> {\n-        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n-    /// is passed to this method.\n-    ///\n-    /// [`recv`]: UnixDatagram::recv\n-    /// [`recv_from`]: UnixDatagram::recv_from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_read_timeout function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`send`]: UnixDatagram::send\n-    /// [`send_to`]: UnixDatagram::send_to\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_write_timeout function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_read_timeout function failed\");\n-    ///     assert_eq!(sock.read_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_write_timeout function failed\");\n-    ///     assert_eq!(sock.write_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     if let Ok(Some(err)) = sock.take_error() {\n-    ///         println!(\"Got error: {:?}\", err);\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shut down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-\n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n-    ///\n-    /// Successive calls return the same data. This is accomplished by passing\n-    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_peek)]\n-    ///\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n-    ///     let mut buf = [0; 10];\n-    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.peek(buf)\n-    }\n-\n-    /// Receives a single datagram message on the socket, without removing it from the\n-    /// queue. On success, returns the number of bytes read and the origin.\n-    ///\n-    /// The function must be called with valid byte array `buf` of sufficient size to\n-    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n-    /// excess bytes may be discarded.\n-    ///\n-    /// Successive calls return the same data. This is accomplished by passing\n-    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n-    ///\n-    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n-    /// synchronize IO events on one or more sockets.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_peek)]\n-    ///\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n-    ///     let mut buf = [0; 10];\n-    ///     let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n-    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_flags(buf, libc::MSG_PEEK)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixDatagram {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixDatagram {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n-        UnixDatagram(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixDatagram {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}"}, {"sha": "15fc5bb5b4e6bdcbf53fe4c8753bc5d759342a5b", "filename": "library/std/src/sys/unix/ext/net/addr.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,226 @@\n+use crate::ffi::OsStr;\n+use crate::os::unix::ffi::OsStrExt;\n+use crate::path::Path;\n+use crate::sys::unix::cvt;\n+use crate::{ascii, fmt, io, mem};\n+\n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(not(unix))]\n+#[allow(non_camel_case_types)]\n+mod libc {\n+    pub use libc::c_int;\n+    pub type socklen_t = u32;\n+    pub struct sockaddr;\n+    #[derive(Clone)]\n+    pub struct sockaddr_un;\n+}\n+\n+fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n+    // Work with an actual instance of the type since using a null pointer is UB\n+    let base = addr as *const _ as usize;\n+    let path = &addr.sun_path as *const _ as usize;\n+    path - base\n+}\n+\n+pub(super) unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n+    let mut addr: libc::sockaddr_un = mem::zeroed();\n+    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+\n+    let bytes = path.as_os_str().as_bytes();\n+\n+    if bytes.contains(&0) {\n+        return Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            \"paths may not contain interior null bytes\",\n+        ));\n+    }\n+\n+    if bytes.len() >= addr.sun_path.len() {\n+        return Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            \"path must be shorter than SUN_LEN\",\n+        ));\n+    }\n+    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n+        *dst = *src as libc::c_char;\n+    }\n+    // null byte for pathname addresses is already there because we zeroed the\n+    // struct\n+\n+    let mut len = sun_path_offset(&addr) + bytes.len();\n+    match bytes.get(0) {\n+        Some(&0) | None => {}\n+        Some(_) => len += 1,\n+    }\n+    Ok((addr, len as libc::socklen_t))\n+}\n+\n+enum AddressKind<'a> {\n+    Unnamed,\n+    Pathname(&'a Path),\n+    Abstract(&'a [u8]),\n+}\n+\n+struct AsciiEscaped<'a>(&'a [u8]);\n+\n+impl<'a> fmt::Display for AsciiEscaped<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(fmt, \"\\\"\")?;\n+        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n+            write!(fmt, \"{}\", byte as char)?;\n+        }\n+        write!(fmt, \"\\\"\")\n+    }\n+}\n+\n+/// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n+#[derive(Clone)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct SocketAddr {\n+    addr: libc::sockaddr_un,\n+    len: libc::socklen_t,\n+}\n+\n+impl SocketAddr {\n+    pub(super) fn new<F>(f: F) -> io::Result<SocketAddr>\n+    where\n+        F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int,\n+    {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n+\n+    pub(super) fn from_parts(\n+        addr: libc::sockaddr_un,\n+        mut len: libc::socklen_t,\n+    ) -> io::Result<SocketAddr> {\n+        if len == 0 {\n+            // When there is a datagram from unnamed unix socket\n+            // linux returns zero bytes of address\n+            len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n+        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"file descriptor did not correspond to a Unix socket\",\n+            ));\n+        }\n+\n+        Ok(SocketAddr { addr, len })\n+    }\n+\n+    /// Returns `true` if the address is unnamed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A named address:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.is_unnamed(), false);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.is_unnamed(), true);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn is_unnamed(&self) -> bool {\n+        if let AddressKind::Unnamed = self.address() { true } else { false }\n+    }\n+\n+    /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.as_pathname(), None);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n+    }\n+\n+    fn address(&self) -> AddressKind<'_> {\n+        let len = self.len as usize - sun_path_offset(&self.addr);\n+        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n+\n+        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n+        if len == 0\n+            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n+                && self.addr.sun_path[0] == 0)\n+        {\n+            AddressKind::Unnamed\n+        } else if self.addr.sun_path[0] == 0 {\n+            AddressKind::Abstract(&path[1..len])\n+        } else {\n+            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.address() {\n+            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n+            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n+            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n+        }\n+    }\n+}"}, {"sha": "4e584cb143faa45ec2bac2ac72a2cdcfae74a875", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,614 @@\n+use crate::io::{self, IoSliceMut};\n+use crate::mem;\n+use crate::os::unix::io::RawFd;\n+use crate::path::Path;\n+use crate::ptr::null_mut;\n+use crate::slice::from_raw_parts;\n+use crate::sys::unix::ext::net::addr::{sockaddr_un, SocketAddr};\n+use crate::sys::unix::net::{add_to_ancillary_data, AncillaryDataIter, Socket};\n+\n+pub(super) fn recv_vectored_with_ancillary_from(\n+    socket: &Socket,\n+    bufs: &mut [IoSliceMut<'_>],\n+    ancillary: &mut SocketAncillary<'_>,\n+) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n+    unsafe {\n+        let mut msg_name: libc::sockaddr_un = mem::zeroed();\n+\n+        let mut msg = libc::msghdr {\n+            msg_name: &mut msg_name as *mut _ as *mut _,\n+            msg_namelen: mem::size_of::<libc::sockaddr_un>() as libc::socklen_t,\n+            msg_iov: bufs.as_mut_ptr().cast(),\n+            msg_iovlen: bufs.len(),\n+            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n+            msg_controllen: ancillary.buffer.len(),\n+            msg_flags: 0,\n+        };\n+\n+        let count = socket.recv_msg(&mut msg)?;\n+\n+        ancillary.length = msg.msg_controllen;\n+        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n+\n+        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n+        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);\n+\n+        Ok((count, truncated, addr))\n+    }\n+}\n+\n+pub(super) fn send_vectored_with_ancillary_to(\n+    socket: &Socket,\n+    path: Option<&Path>,\n+    bufs: &mut [IoSliceMut<'_>],\n+    ancillary: &mut SocketAncillary<'_>,\n+) -> io::Result<usize> {\n+    unsafe {\n+        let (mut msg_name, msg_namelen) =\n+            if let Some(path) = path { sockaddr_un(path)? } else { (mem::zeroed(), 0) };\n+\n+        let mut msg = libc::msghdr {\n+            msg_name: &mut msg_name as *mut _ as *mut _,\n+            msg_namelen,\n+            msg_iov: bufs.as_mut_ptr().cast(),\n+            msg_iovlen: bufs.len(),\n+            msg_control: ancillary.buffer.as_mut_ptr().cast(),\n+            msg_controllen: ancillary.length,\n+            msg_flags: 0,\n+        };\n+\n+        ancillary.truncated = false;\n+\n+        socket.send_msg(&mut msg)\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub struct ScmRights<'a>(AncillaryDataIter<'a, RawFd>);\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> Iterator for ScmRights<'a> {\n+    type Item = RawFd;\n+\n+    fn next(&mut self) -> Option<RawFd> {\n+        self.0.next()\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::ucred>);\n+\n+#[cfg(any(\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> Iterator for ScmCredentials<'a> {\n+    type Item = libc::ucred;\n+\n+    fn next(&mut self) -> Option<libc::ucred> {\n+        self.0.next()\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub enum AncillaryData<'a> {\n+    ScmRights(ScmRights<'a>),\n+    #[cfg(any(\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    ScmCredentials(ScmCredentials<'a>),\n+}\n+\n+impl<'a> AncillaryData<'a> {\n+    #[cfg(any(\n+        target_os = \"haiku\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"openbsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    fn as_rights(data: &'a [u8]) -> Self {\n+        let ancillary_data_iter = AncillaryDataIter::new(data);\n+        let scm_rights = ScmRights(ancillary_data_iter);\n+        AncillaryData::ScmRights(scm_rights)\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    fn as_credentials(data: &'a [u8]) -> Self {\n+        let ancillary_data_iter = AncillaryDataIter::new(data);\n+        let scm_credentials = ScmCredentials(ancillary_data_iter);\n+        AncillaryData::ScmCredentials(scm_credentials)\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> AncillaryData<'a> {\n+    fn from(cmsg: &'a libc::cmsghdr) -> Self {\n+        unsafe {\n+            let cmsg_len_zero = libc::CMSG_LEN(0) as usize;\n+            let data_len = (*cmsg).cmsg_len - cmsg_len_zero;\n+            let data = libc::CMSG_DATA(cmsg).cast();\n+            let data = from_raw_parts(data, data_len);\n+\n+            if (*cmsg).cmsg_level == libc::SOL_SOCKET {\n+                match (*cmsg).cmsg_type {\n+                    libc::SCM_RIGHTS => AncillaryData::as_rights(data),\n+                    #[cfg(any(\n+                        target_os = \"linux\",\n+                        target_os = \"android\",\n+                        target_os = \"emscripten\",\n+                        target_os = \"fuchsia\",\n+                        target_env = \"uclibc\",\n+                    ))]\n+                    libc::SCM_CREDENTIALS => AncillaryData::as_credentials(data),\n+                    #[cfg(any(\n+                        target_os = \"netbsd\",\n+                        target_os = \"openbsd\",\n+                        target_os = \"freebsd\",\n+                        target_os = \"dragonfly\",\n+                        target_os = \"macos\",\n+                        target_os = \"ios\",\n+                    ))]\n+                    libc::SCM_CREDS => AncillaryData::as_credentials(data),\n+                    _ => panic!(\"Unknown cmsg type\"),\n+                }\n+            } else {\n+                panic!(\"Unknown cmsg level\");\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub struct Messages<'a> {\n+    buffer: &'a [u8],\n+    current: Option<&'a libc::cmsghdr>,\n+}\n+\n+#[cfg(any(\n+    target_os = \"haiku\",\n+    target_os = \"solaris\",\n+    target_os = \"illumos\",\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"freebsd\",\n+    target_os = \"dragonfly\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_env = \"uclibc\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+impl<'a> Iterator for Messages<'a> {\n+    type Item = AncillaryData<'a>;\n+\n+    fn next(&mut self) -> Option<AncillaryData<'a>> {\n+        unsafe {\n+            let msg = libc::msghdr {\n+                msg_name: null_mut(),\n+                msg_namelen: 0,\n+                msg_iov: null_mut(),\n+                msg_iovlen: 0,\n+                msg_control: self.buffer.as_ptr() as *mut _,\n+                msg_controllen: self.buffer.len(),\n+                msg_flags: 0,\n+            };\n+\n+            let cmsg = if let Some(current) = self.current {\n+                libc::CMSG_NXTHDR(&msg, current)\n+            } else {\n+                libc::CMSG_FIRSTHDR(&msg)\n+            };\n+\n+            let cmsg = cmsg.as_ref()?;\n+            self.current = Some(cmsg);\n+            let ancillary_data = AncillaryData::from(cmsg);\n+            Some(ancillary_data)\n+        }\n+    }\n+}\n+\n+/// A Unix socket Ancillary data struct.\n+///\n+/// # Example\n+/// ```no_run\n+/// #![feature(unix_socket_ancillary_data)]\n+/// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+/// use std::io::IoSliceMut;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+///\n+///     let mut fds = [0; 8];\n+///     let mut ancillary_buffer = [0; 128];\n+///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+///\n+///     let mut buf = [1; 8];\n+///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+///\n+///     for ancillary_data in ancillary.messages() {\n+///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+///             for fd in scm_rights {\n+///                 println!(\"receive file descriptor: {}\", fd);\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+#[derive(Debug)]\n+pub struct SocketAncillary<'a> {\n+    buffer: &'a mut [u8],\n+    length: usize,\n+    truncated: bool,\n+}\n+\n+impl<'a> SocketAncillary<'a> {\n+    /// Create an ancillary data with the given buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(unused_mut)]\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::SocketAncillary;\n+    /// let mut ancillary_buffer = [0; 128];\n+    /// let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn new(buffer: &'a mut [u8]) -> Self {\n+        SocketAncillary { buffer, length: 0, truncated: false }\n+    }\n+\n+    /// Returns the capacity of the buffer.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buffer.len()\n+    }\n+\n+    /// Returns the number of used bytes.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn len(&self) -> usize {\n+        self.length\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"haiku\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"openbsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn messages(&'a self) -> Messages<'a> {\n+        Messages { buffer: &self.buffer[..self.length], current: None }\n+    }\n+\n+    /// Is `true` if during a recv operation the ancillary was truncated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///\n+    ///     println!(\"Is truncated: {}\", ancillary.truncated());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn truncated(&self) -> bool {\n+        self.truncated\n+    }\n+\n+    /// Add file descriptors to the ancillary data.\n+    ///\n+    /// The function returns `true` if there was enough space in the buffer.\n+    /// If there was not enough space then no file descriptors was appended.\n+    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n+    /// and type `SCM_RIGHTS`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::os::unix::io::AsRawFd;\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&[sock.as_raw_fd()][..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"haiku\",\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"openbsd\",\n+        target_os = \"netbsd\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn add_fds(&mut self, fds: &[RawFd]) -> bool {\n+        self.truncated = false;\n+        add_to_ancillary_data(\n+            &mut self.buffer,\n+            &mut self.length,\n+            fds,\n+            libc::SOL_SOCKET,\n+            libc::SCM_RIGHTS,\n+        )\n+    }\n+\n+    /// Add credentials to the ancillary data.\n+    ///\n+    /// The function returns `true` if there was enough space in the buffer.\n+    /// If there was not enough space then no credentials was appended.\n+    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n+    /// and type `SCM_CREDENTIALS`.\n+    ///\n+    #[cfg(any(\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"android\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_env = \"uclibc\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn add_creds(&mut self, creds: &[libc::ucred]) -> bool {\n+        self.truncated = false;\n+        add_to_ancillary_data(\n+            &mut self.buffer,\n+            &mut self.length,\n+            creds,\n+            libc::SOL_SOCKET,\n+            #[cfg(any(\n+                target_os = \"linux\",\n+                target_os = \"android\",\n+                target_os = \"emscripten\",\n+                target_os = \"fuchsia\",\n+                target_env = \"uclibc\",\n+            ))]\n+            libc::SCM_CREDENTIALS,\n+            #[cfg(any(\n+                target_os = \"netbsd\",\n+                target_os = \"openbsd\",\n+                target_os = \"freebsd\",\n+                target_os = \"dragonfly\",\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+            ))]\n+            libc::SCM_CREDS,\n+        )\n+    }\n+\n+    /// Clears the ancillary data, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut fds1 = [0; 8];\n+    ///     let mut fds2 = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///\n+    ///     ancillary.clear();\n+    ///\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn clear(&mut self) {\n+        self.length = 0;\n+        self.truncated = false;\n+    }\n+}"}, {"sha": "e5630127ccbcb5ccad753ceb2489c952c602a0cb", "filename": "library/std/src/sys/unix/ext/net/datagram.rs", "status": "added", "additions": 819, "deletions": 0, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fdatagram.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,819 @@\n+use crate::io::IoSliceMut;\n+use crate::net::Shutdown;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::path::Path;\n+use crate::sys::unix::cvt;\n+use crate::sys::unix::ext::net::addr::{sockaddr_un, SocketAddr};\n+use crate::sys::unix::ext::net::ancillary::{\n+    recv_vectored_with_ancillary_from, send_vectored_with_ancillary_to, SocketAncillary,\n+};\n+use crate::sys::unix::net::Socket;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::time::Duration;\n+use crate::{fmt, io};\n+\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"haiku\"\n+))]\n+use libc::MSG_NOSIGNAL;\n+#[cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"haiku\"\n+)))]\n+const MSG_NOSIGNAL: libc::c_int = 0x0;\n+\n+/// A Unix datagram socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixDatagram;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let socket = UnixDatagram::bind(\"/path/to/my/socket\")?;\n+///     socket.send_to(b\"hello world\", \"/path/to/other/socket\")?;\n+///     let mut buf = [0; 100];\n+///     let (count, address) = socket.recv_from(&mut buf)?;\n+///     println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixDatagram(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixDatagram {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixDatagram {\n+    /// Creates a Unix datagram socket bound to the given path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't bind: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n+        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n+            unsafe {\n+                let socket = UnixDatagram::unbound()?;\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n+\n+                Ok(socket)\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Creates a Unix Datagram socket which is not bound to any address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::unbound() {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn unbound() -> io::Result<UnixDatagram> {\n+        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n+        Ok(UnixDatagram(inner))\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixDatagrams`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let (sock1, sock2) = match UnixDatagram::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n+        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n+    }\n+\n+    /// Connects the socket to the specified address.\n+    ///\n+    /// The [`send`] method may be used to send data to the specified address.\n+    /// [`recv`] and [`recv_from`] will only receive data from that address.\n+    ///\n+    /// [`send`]: UnixDatagram::send\n+    /// [`recv`]: UnixDatagram::recv\n+    /// [`recv_from`]: UnixDatagram::recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     match sock.connect(\"/path/to/the/socket\") {\n+    ///         Ok(sock) => sock,\n+    ///         Err(e) => {\n+    ///             println!(\"Couldn't connect: {:?}\", e);\n+    ///             return Err(e)\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n+            unsafe {\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n+\n+                Ok(())\n+            }\n+        }\n+        inner(self, path.as_ref())\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixDatagram` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one side will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n+    ///     let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n+        self.0.duplicate().map(UnixDatagram)\n+    }\n+\n+    /// Returns the address of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n+    ///     let addr = sock.local_addr().expect(\"Couldn't get local address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the address of this socket's peer.\n+    ///\n+    /// The [`connect`] method will connect the socket to a peer.\n+    ///\n+    /// [`connect`]: UnixDatagram::connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.connect(\"/path/to/the/socket\")?;\n+    ///\n+    ///     let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    fn recv_from_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: libc::c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n+        let mut count = 0;\n+        let addr = SocketAddr::new(|addr, len| unsafe {\n+            count = libc::recvfrom(\n+                *self.0.as_inner(),\n+                buf.as_mut_ptr() as *mut _,\n+                buf.len(),\n+                flags,\n+                addr,\n+                len,\n+            );\n+            if count > 0 {\n+                1\n+            } else if count == 0 {\n+                0\n+            } else {\n+                -1\n+            }\n+        })?;\n+\n+        Ok((count as usize, addr))\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read and the address from\n+    /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf = vec![0; 10];\n+    ///     let (size, sender) = sock.recv_from(buf.as_mut_slice())?;\n+    ///     println!(\"received {} bytes from {:?}\", size, sender);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_flags(buf, 0)\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n+    ///     let mut buf = vec![0; 10];\n+    ///     sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn recv_vectored_with_ancillary_from(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<(usize, bool, SocketAddr)> {\n+        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+        let addr = addr?;\n+\n+        Ok((count, truncated, addr))\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read and if the data was truncated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let (size, _truncated) = sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn recv_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<(usize, bool)> {\n+        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+        addr?;\n+\n+        Ok((count, truncated))\n+    }\n+\n+    /// Sends data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n+        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n+            unsafe {\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                let count = cvt(libc::sendto(\n+                    *d.0.as_inner(),\n+                    buf.as_ptr() as *const _,\n+                    buf.len(),\n+                    MSG_NOSIGNAL,\n+                    &addr as *const _ as *const _,\n+                    len,\n+                ))?;\n+                Ok(count as usize)\n+            }\n+        }\n+        inner(self, buf, path.as_ref())\n+    }\n+\n+    /// Sends data on the socket to the socket's peer.\n+    ///\n+    /// The peer address may be set by the `connect` method, and this method\n+    /// will return an error if the socket has not already been connected.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n+    ///     sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    /// Sends data and ancillary data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     sock.send_vectored_with_ancillary_to(bufs, &mut ancillary, \"/some/sock\").expect(\"send_vectored_with_ancillary_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn send_vectored_with_ancillary_to<P: AsRef<Path>>(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+        path: P,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, Some(path.as_ref()), bufs, ancillary)\n+    }\n+\n+    /// Sends data and ancillary data on the socket.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn send_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n+    /// is passed to this method.\n+    ///\n+    /// [`recv`]: UnixDatagram::recv\n+    /// [`recv_from`]: UnixDatagram::recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_read_timeout function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`send`]: UnixDatagram::send\n+    /// [`send_to`]: UnixDatagram::send_to\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_write_timeout function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_read_timeout function failed\");\n+    ///     assert_eq!(sock.read_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_write_timeout function failed\");\n+    ///     assert_eq!(sock.write_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     if let Ok(Some(err)) = sock.take_error() {\n+    ///         println!(\"Got error: {:?}\", err);\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shut down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n+    /// Receives a single datagram message on the socket, without removing it from the\n+    /// queue. On success, returns the number of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n+    ///\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_flags(buf, libc::MSG_PEEK)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixDatagram {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixDatagram {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n+        UnixDatagram(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixDatagram {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}"}, {"sha": "84386ea6381c1b5490e2172dcb2b3bc19710a35c", "filename": "library/std/src/sys/unix/ext/net/listener.rs", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Flistener.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,323 @@\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::path::Path;\n+use crate::sys::net::Socket;\n+use crate::sys::unix::cvt;\n+use crate::sys::unix::ext::net::addr::{sockaddr_un, SocketAddr};\n+use crate::sys::unix::ext::net::stream::UnixStream;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::{fmt, io, mem};\n+\n+/// A structure representing a Unix domain socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+///\n+///     // accept connections and process them, spawning a new thread for each one\n+///     for stream in listener.incoming() {\n+///         match stream {\n+///             Ok(stream) => {\n+///                 /* connection succeeded */\n+///                 thread::spawn(|| handle_client(stream));\n+///             }\n+///             Err(err) => {\n+///                 /* connection failed */\n+///                 break;\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixListener(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n+        fn inner(path: &Path) -> io::Result<UnixListener> {\n+            unsafe {\n+                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n+                cvt(libc::listen(*inner.as_inner(), 128))?;\n+\n+                Ok(UnixListener(inner))\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Accepts a new incoming connection to this listener.\n+    ///\n+    /// This function will block the calling thread until a new Unix connection\n+    /// is established. When established, the corresponding [`UnixStream`] and\n+    /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: crate::os::unix::net::UnixStream\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///\n+    ///     match listener.accept() {\n+    ///         Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///         Err(e) => println!(\"accept function failed: {:?}\", e),\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n+        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n+        let addr = SocketAddr::from_parts(storage, len)?;\n+        Ok((UnixStream(sock), addr))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// This will result in the `accept` operation becoming nonblocking,\n+    /// i.e., immediately returning from their calls. If the IO operation is\n+    /// successful, `Ok` is returned and no further action is required. If the\n+    /// IO operation could not be completed and needs to be retried, an error\n+    /// with kind [`io::ErrorKind::WouldBlock`] is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/tmp/sock\")?;\n+    ///\n+    ///     if let Ok(Some(err)) = listener.take_error() {\n+    ///         println!(\"Got error: {:?}\", err);\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns `None`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Returns an iterator over incoming connections.\n+    ///\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///\n+    ///     for stream in listener.incoming() {\n+    ///         match stream {\n+    ///             Ok(stream) => {\n+    ///                 thread::spawn(|| handle_client(stream));\n+    ///             }\n+    ///             Err(err) => {\n+    ///                 break;\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn incoming(&self) -> Incoming<'_> {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> IntoIterator for &'a UnixListener {\n+    type Item = io::Result<UnixStream>;\n+    type IntoIter = Incoming<'a>;\n+\n+    fn into_iter(self) -> Incoming<'a> {\n+        self.incoming()\n+    }\n+}\n+\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+///\n+///     for stream in listener.incoming() {\n+///         match stream {\n+///             Ok(stream) => {\n+///                 thread::spawn(|| handle_client(stream));\n+///             }\n+///             Err(err) => {\n+///                 break;\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct Incoming<'a> {\n+    listener: &'a UnixListener,\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<UnixStream>;\n+\n+    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n+        Some(self.listener.accept().map(|s| s.0))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}"}, {"sha": "93b72df520aa3f10088d8f34293e571ba6e1bdea", "filename": "library/std/src/sys/unix/ext/net/mod.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,25 @@\n+//! Unix-specific networking functionality\n+\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+\n+mod addr;\n+mod ancillary;\n+mod datagram;\n+mod listener;\n+mod raw_fd;\n+mod stream;\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod test;\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::addr::*;\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+pub use self::ancillary::*;\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::datagram::*;\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::listener::*;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::raw_fd::*;\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::stream::*;"}, {"sha": "059c0fec06f2f5138cd91023fb019cb566711632", "filename": "library/std/src/sys/unix/ext/net/raw_fd.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fraw_fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fraw_fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fraw_fd.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,67 @@\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::{net, sys};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.as_inner().socket().as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}"}, {"sha": "75b9190266811eaf996b8a11f2131858ab11f2d0", "filename": "library/std/src/sys/unix/ext/net/stream.rs", "status": "added", "additions": 615, "deletions": 0, "changes": 615, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fstream.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,615 @@\n+use crate::fmt;\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::net::Shutdown;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\"\n+))]\n+use crate::os::unix::ucred;\n+use crate::path::Path;\n+use crate::sys::cvt;\n+use crate::sys::net::Socket;\n+use crate::sys::unix::ext::net::addr::{sockaddr_un, SocketAddr};\n+use crate::sys::unix::ext::net::ancillary::{\n+    recv_vectored_with_ancillary_from, send_vectored_with_ancillary_to, SocketAncillary,\n+};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::time::Duration;\n+\n+#[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\"\n+))]\n+pub use ucred::UCred;\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let mut stream = UnixStream::connect(\"/path/to/my/socket\")?;\n+///     stream.write_all(b\"hello world\")?;\n+///     let mut response = String::new();\n+///     stream.read_to_string(&mut response)?;\n+///     println!(\"{}\", response);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixStream(pub(super) Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n+        fn inner(path: &Path) -> io::Result<UnixStream> {\n+            unsafe {\n+                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+                let (addr, len) = sockaddr_un(path)?;\n+\n+                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+                Ok(UnixStream(inner))\n+            }\n+        }\n+        inner(path.as_ref())\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+        Ok((UnixStream(i1), UnixStream(i2)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Gets the peer credentials for this Unix domain socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peer_credentials_unix_socket)]\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let peer_cred = socket.peer_cred().expect(\"Couldn't get peer credentials\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"ios\",\n+        target_os = \"macos\",\n+        target_os = \"openbsd\"\n+    ))]\n+    pub fn peer_cred(&self) -> io::Result<UCred> {\n+        ucred::peer_cred(self)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`read`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`read`]: io::Read::read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`write`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n+    ///\n+    /// [`read`]: io::Read::read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"Couldn't set write timeout\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n+    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    ///     assert_eq!(socket.read_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"Couldn't set write timeout\");\n+    ///     assert_eq!(socket.write_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     if let Ok(Some(err)) = socket.take_error() {\n+    ///         println!(\"Got error: {:?}\", err);\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns `None`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let size = socket.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_data in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_data {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn recv_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        let (count, _, _) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+\n+        Ok(count)\n+    }\n+\n+    /// Sends data and ancillary data on the socket.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     socket.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"none\")]\n+    pub fn send_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Read for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &*self, buf)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        io::Read::read_vectored(&mut &*self, bufs)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        io::Read::is_read_vectored(&&*self)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        self.0.is_read_vectored()\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Write for UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &*self, buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        io::Write::write_vectored(&mut &*self, bufs)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        io::Write::is_write_vectored(&&*self)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &*self)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        self.0.is_write_vectored()\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}"}, {"sha": "724d73c9b1ed95232b4a663d04e252d4bf07e8fe", "filename": "library/std/src/sys/unix/ext/net/test.rs", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/rust-lang/rust/blob/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fa7c3f79ed3775912c9ec5db8a824dee646e4dd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftest.rs?ref=6fa7c3f79ed3775912c9ec5db8a824dee646e4dd", "patch": "@@ -0,0 +1,608 @@\n+use super::*;\n+use crate::io::prelude::*;\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n+use crate::iter::FromIterator;\n+use crate::mem;\n+use crate::sys::unix::ext::io::AsRawFd;\n+use crate::sys_common::io::test::tmpdir;\n+use crate::thread;\n+use crate::time::Duration;\n+\n+macro_rules! or_panic {\n+    ($e:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => panic!(\"{}\", e),\n+        }\n+    };\n+}\n+\n+#[test]\n+fn basic() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+    let msg1 = b\"hello\";\n+    let msg2 = b\"world!\";\n+\n+    let listener = or_panic!(UnixListener::bind(&socket_path));\n+    let thread = thread::spawn(move || {\n+        let mut stream = or_panic!(listener.accept()).0;\n+        let mut buf = [0; 5];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(stream.write_all(msg2));\n+    });\n+\n+    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+    assert_eq!(Some(&*socket_path), stream.peer_addr().unwrap().as_pathname());\n+    or_panic!(stream.write_all(msg1));\n+    let mut buf = vec![];\n+    or_panic!(stream.read_to_end(&mut buf));\n+    assert_eq!(&msg2[..], &buf[..]);\n+    drop(stream);\n+\n+    thread.join().unwrap();\n+}\n+\n+#[test]\n+fn vectored() {\n+    let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+\n+    let len = or_panic!(s1.write_vectored(&[\n+        IoSlice::new(b\"hello\"),\n+        IoSlice::new(b\" \"),\n+        IoSlice::new(b\"world!\")\n+    ],));\n+    assert_eq!(len, 12);\n+\n+    let mut buf1 = [0; 6];\n+    let mut buf2 = [0; 7];\n+    let len =\n+        or_panic!(s2.read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],));\n+    assert_eq!(len, 12);\n+    assert_eq!(&buf1, b\"hello \");\n+    assert_eq!(&buf2, b\"world!\\0\");\n+}\n+\n+#[test]\n+fn pair() {\n+    let msg1 = b\"hello\";\n+    let msg2 = b\"world!\";\n+\n+    let (mut s1, mut s2) = or_panic!(UnixStream::pair());\n+    let thread = thread::spawn(move || {\n+        // s1 must be moved in or the test will hang!\n+        let mut buf = [0; 5];\n+        or_panic!(s1.read(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(s1.write_all(msg2));\n+    });\n+\n+    or_panic!(s2.write_all(msg1));\n+    let mut buf = vec![];\n+    or_panic!(s2.read_to_end(&mut buf));\n+    assert_eq!(&msg2[..], &buf[..]);\n+    drop(s2);\n+\n+    thread.join().unwrap();\n+}\n+\n+#[test]\n+fn try_clone() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+    let msg1 = b\"hello\";\n+    let msg2 = b\"world\";\n+\n+    let listener = or_panic!(UnixListener::bind(&socket_path));\n+    let thread = thread::spawn(move || {\n+        let mut stream = or_panic!(listener.accept()).0;\n+        or_panic!(stream.write_all(msg1));\n+        or_panic!(stream.write_all(msg2));\n+    });\n+\n+    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+    let mut stream2 = or_panic!(stream.try_clone());\n+\n+    let mut buf = [0; 5];\n+    or_panic!(stream.read(&mut buf));\n+    assert_eq!(&msg1[..], &buf[..]);\n+    or_panic!(stream2.read(&mut buf));\n+    assert_eq!(&msg2[..], &buf[..]);\n+\n+    thread.join().unwrap();\n+}\n+\n+#[test]\n+fn iter() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+\n+    let listener = or_panic!(UnixListener::bind(&socket_path));\n+    let thread = thread::spawn(move || {\n+        for stream in listener.incoming().take(2) {\n+            let mut stream = or_panic!(stream);\n+            let mut buf = [0];\n+            or_panic!(stream.read(&mut buf));\n+        }\n+    });\n+\n+    for _ in 0..2 {\n+        let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+        or_panic!(stream.write_all(&[0]));\n+    }\n+\n+    thread.join().unwrap();\n+}\n+\n+#[test]\n+fn long_path() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\n+        \"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfa\\\n+                                sasdfasdfasdasdfasdfasdfadfasdfasdfasdfasdfasdf\",\n+    );\n+    match UnixStream::connect(&socket_path) {\n+        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+        Err(e) => panic!(\"unexpected error {}\", e),\n+        Ok(_) => panic!(\"unexpected success\"),\n+    }\n+\n+    match UnixListener::bind(&socket_path) {\n+        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+        Err(e) => panic!(\"unexpected error {}\", e),\n+        Ok(_) => panic!(\"unexpected success\"),\n+    }\n+\n+    match UnixDatagram::bind(&socket_path) {\n+        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+        Err(e) => panic!(\"unexpected error {}\", e),\n+        Ok(_) => panic!(\"unexpected success\"),\n+    }\n+}\n+\n+#[test]\n+fn timeouts() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+\n+    let _listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+    let stream = or_panic!(UnixStream::connect(&socket_path));\n+    let dur = Duration::new(15410, 0);\n+\n+    assert_eq!(None, or_panic!(stream.read_timeout()));\n+\n+    or_panic!(stream.set_read_timeout(Some(dur)));\n+    assert_eq!(Some(dur), or_panic!(stream.read_timeout()));\n+\n+    assert_eq!(None, or_panic!(stream.write_timeout()));\n+\n+    or_panic!(stream.set_write_timeout(Some(dur)));\n+    assert_eq!(Some(dur), or_panic!(stream.write_timeout()));\n+\n+    or_panic!(stream.set_read_timeout(None));\n+    assert_eq!(None, or_panic!(stream.read_timeout()));\n+\n+    or_panic!(stream.set_write_timeout(None));\n+    assert_eq!(None, or_panic!(stream.write_timeout()));\n+}\n+\n+#[test]\n+fn test_read_timeout() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+\n+    let _listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+    or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+    let mut buf = [0; 10];\n+    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n+    assert!(\n+        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+        \"unexpected_error: {:?}\",\n+        kind\n+    );\n+}\n+\n+#[test]\n+fn test_read_with_timeout() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+\n+    let listener = or_panic!(UnixListener::bind(&socket_path));\n+\n+    let mut stream = or_panic!(UnixStream::connect(&socket_path));\n+    or_panic!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+    let mut other_end = or_panic!(listener.accept()).0;\n+    or_panic!(other_end.write_all(b\"hello world\"));\n+\n+    let mut buf = [0; 11];\n+    or_panic!(stream.read(&mut buf));\n+    assert_eq!(b\"hello world\", &buf[..]);\n+\n+    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n+    assert!(\n+        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+        \"unexpected_error: {:?}\",\n+        kind\n+    );\n+}\n+\n+// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+// when passed zero Durations\n+#[test]\n+fn test_unix_stream_timeout_zero_duration() {\n+    let dir = tmpdir();\n+    let socket_path = dir.path().join(\"sock\");\n+\n+    let listener = or_panic!(UnixListener::bind(&socket_path));\n+    let stream = or_panic!(UnixStream::connect(&socket_path));\n+\n+    let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+    let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+    drop(listener);\n+}\n+\n+#[test]\n+fn test_unix_datagram() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock1.send_to(msg, &path2));\n+    let mut buf = [0; 11];\n+    or_panic!(sock2.recv_from(&mut buf));\n+    assert_eq!(msg, &buf[..]);\n+}\n+\n+#[test]\n+fn test_unnamed_unix_datagram() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::unbound());\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock2.send_to(msg, &path1));\n+    let mut buf = [0; 11];\n+    let (usize, addr) = or_panic!(sock1.recv_from(&mut buf));\n+    assert_eq!(usize, 11);\n+    assert!(addr.is_unnamed());\n+    assert_eq!(msg, &buf[..]);\n+}\n+\n+#[test]\n+fn test_connect_unix_datagram() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+    let sock = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock.connect(&path1));\n+\n+    // Check send()\n+    let msg = b\"hello there\";\n+    or_panic!(sock.send(msg));\n+    let mut buf = [0; 11];\n+    let (usize, addr) = or_panic!(bsock1.recv_from(&mut buf));\n+    assert_eq!(usize, 11);\n+    assert!(addr.is_unnamed());\n+    assert_eq!(msg, &buf[..]);\n+\n+    // Changing default socket works too\n+    or_panic!(sock.connect(&path2));\n+    or_panic!(sock.send(msg));\n+    or_panic!(bsock2.recv_from(&mut buf));\n+}\n+\n+#[test]\n+fn test_unix_datagram_recv() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock2.connect(&path1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock2.send(msg));\n+    let mut buf = [0; 11];\n+    let size = or_panic!(sock1.recv(&mut buf));\n+    assert_eq!(size, 11);\n+    assert_eq!(msg, &buf[..]);\n+}\n+\n+#[test]\n+fn datagram_pair() {\n+    let msg1 = b\"hello\";\n+    let msg2 = b\"world!\";\n+\n+    let (s1, s2) = or_panic!(UnixDatagram::pair());\n+    let thread = thread::spawn(move || {\n+        // s1 must be moved in or the test will hang!\n+        let mut buf = [0; 5];\n+        or_panic!(s1.recv(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(s1.send(msg2));\n+    });\n+\n+    or_panic!(s2.send(msg1));\n+    let mut buf = [0; 6];\n+    or_panic!(s2.recv(&mut buf));\n+    assert_eq!(&msg2[..], &buf[..]);\n+    drop(s2);\n+\n+    thread.join().unwrap();\n+}\n+\n+// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+// when passed zero Durations\n+#[test]\n+fn test_unix_datagram_timeout_zero_duration() {\n+    let dir = tmpdir();\n+    let path = dir.path().join(\"sock\");\n+\n+    let datagram = or_panic!(UnixDatagram::bind(&path));\n+\n+    let result = datagram.set_write_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+    let result = datagram.set_read_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+}\n+\n+#[test]\n+fn abstract_namespace_not_allowed() {\n+    assert!(UnixStream::connect(\"\\0asdf\").is_err());\n+}\n+\n+#[test]\n+fn test_unix_stream_peek() {\n+    let (txdone, rxdone) = crate::sync::mpsc::channel();\n+\n+    let dir = tmpdir();\n+    let path = dir.path().join(\"sock\");\n+\n+    let listener = or_panic!(UnixListener::bind(&path));\n+    let thread = thread::spawn(move || {\n+        let mut stream = or_panic!(listener.accept()).0;\n+        or_panic!(stream.write_all(&[1, 3, 3, 7]));\n+        or_panic!(rxdone.recv());\n+    });\n+\n+    let mut stream = or_panic!(UnixStream::connect(&path));\n+    let mut buf = [0; 10];\n+    for _ in 0..2 {\n+        assert_eq!(or_panic!(stream.peek(&mut buf)), 4);\n+    }\n+    assert_eq!(or_panic!(stream.read(&mut buf)), 4);\n+\n+    or_panic!(stream.set_nonblocking(true));\n+    match stream.peek(&mut buf) {\n+        Ok(_) => panic!(\"expected error\"),\n+        Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+        Err(e) => panic!(\"unexpected error: {}\", e),\n+    }\n+\n+    or_panic!(txdone.send(()));\n+    thread.join().unwrap();\n+}\n+\n+#[test]\n+fn test_unix_datagram_peek() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock2.connect(&path1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock2.send(msg));\n+    for _ in 0..2 {\n+        let mut buf = [0; 11];\n+        let size = or_panic!(sock1.peek(&mut buf));\n+        assert_eq!(size, 11);\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    let mut buf = [0; 11];\n+    let size = or_panic!(sock1.recv(&mut buf));\n+    assert_eq!(size, 11);\n+    assert_eq!(msg, &buf[..]);\n+}\n+\n+#[test]\n+fn test_unix_datagram_peek_from() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock2.connect(&path1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock2.send(msg));\n+    for _ in 0..2 {\n+        let mut buf = [0; 11];\n+        let (size, _) = or_panic!(sock1.peek_from(&mut buf));\n+        assert_eq!(size, 11);\n+        assert_eq!(msg, &buf[..]);\n+    }\n+\n+    let mut buf = [0; 11];\n+    let size = or_panic!(sock1.recv(&mut buf));\n+    assert_eq!(size, 11);\n+    assert_eq!(msg, &buf[..]);\n+}\n+\n+#[test]\n+fn test_send_vectored_fds_unix_stream() {\n+    let (s1, s2) = or_panic!(UnixStream::pair());\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    assert!(ancillary1.add_fds(&[s1.as_raw_fd()][..]));\n+\n+    let usize = or_panic!(s1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let usize = or_panic!(s2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(usize, 8);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap() {\n+        let fd_vec = Vec::from_iter(scm_rights);\n+        assert_eq!(fd_vec.len(), 1);\n+        unsafe {\n+            libc::close(fd_vec[0]);\n+        }\n+    } else {\n+        assert!(false);\n+    }\n+}\n+\n+#[test]\n+fn test_send_vectored_with_ancillary_to_unix_datagram() {\n+    fn getpid() -> libc::pid_t {\n+        unsafe { libc::getpid() }\n+    }\n+\n+    fn getuid() -> libc::uid_t {\n+        unsafe { libc::getuid() }\n+    }\n+\n+    fn getgid() -> libc::gid_t {\n+        unsafe { libc::getgid() }\n+    }\n+\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    unsafe {\n+        let optval: libc::c_int = 1;\n+        libc::setsockopt(\n+            bsock2.as_raw_fd(),\n+            libc::SOL_SOCKET,\n+            libc::SO_PASSCRED,\n+            &optval as *const _ as *const _,\n+            mem::size_of::<libc::c_int>() as u32,\n+        );\n+    }\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    let cred1 = libc::ucred { pid: getpid(), uid: getuid(), gid: getgid() };\n+    assert!(ancillary1.add_creds(&[cred1][..]));\n+\n+    let usize =\n+        or_panic!(bsock1.send_vectored_with_ancillary_to(&mut bufs_send, &mut ancillary1, &path2));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let (usize, truncated, _addr) =\n+        or_panic!(bsock2.recv_vectored_with_ancillary_from(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(ancillary2.truncated(), false);\n+    assert_eq!(usize, 8);\n+    assert_eq!(truncated, false);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmCredentials(scm_credentials) = ancillary_data_vec.pop().unwrap() {\n+        let cred_vec = Vec::from_iter(scm_credentials);\n+        assert_eq!(cred_vec.len(), 1);\n+        assert_eq!(cred1.pid, cred_vec[0].pid);\n+        assert_eq!(cred1.uid, cred_vec[0].uid);\n+        assert_eq!(cred1.gid, cred_vec[0].gid);\n+    } else {\n+        assert!(false);\n+    }\n+}\n+\n+#[test]\n+fn test_send_vectored_with_ancillary_unix_datagram() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    assert!(ancillary1.add_fds(&[bsock1.as_raw_fd()][..]));\n+\n+    or_panic!(bsock1.connect(&path2));\n+    let usize = or_panic!(bsock1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let (usize, truncated) =\n+        or_panic!(bsock2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(usize, 8);\n+    assert_eq!(truncated, false);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap() {\n+        let fd_vec = Vec::from_iter(scm_rights);\n+        assert_eq!(fd_vec.len(), 1);\n+        unsafe {\n+            libc::close(fd_vec[0]);\n+        }\n+    } else {\n+        assert!(false);\n+    }\n+}"}]}